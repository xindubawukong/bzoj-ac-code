<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<link rel=stylesheet href='include/hoj.css' type='text/css'>
</head>
<body>
<center>
<div style="width:90%; text-align:left">
<img src="image/logo.png"/>
</div>
<table width=96%> 
	<tr align="center" class='hd' valign="top">
				<th><a href="faqs.php">F.A.Qs</a></th>
		<th><a href="./">Home</a></th>
		<th><a href="./bbs.php">Discuss</a></th>
		<th><a href="./problemset.php">ProblemSet</a></th>
		<th><a href="./status.php">Status</a></th>
		<th><a href="./ranklist.php">Ranklist</a></th>
        <th><a href="./contest.php">Contest</a></th>
        <th><a href="http://begin.lydsy.com/JudgeOnline">入门OJ</a></th>
		<th><a href=./modifypage.php><b>ModifyUser</b></a>&nbsp;&nbsp;<a href='userinfo.php?user=xindubawukong'>
				<font color=red>xindubawukong</font></a></th><th><a href=logout.php>Logout</a></th>		<th><a href="./donation.php"><font color=red>捐赠本站</font></a></th>
	</tr>
</table>
</center>
<title>Export All AC Source</title>
<h2>Problem1000</h2><pre>var
  a,b:int64;
begin
  readln(a,b);
  writeln(a+b);
end.<pre><h2>Problem1000</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int main()
{
	int a,b;
	scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
	printf(&quot;%d\n&quot;,a+b);
	return 0;
}<pre><h2>Problem1000</h2><pre>#include&lt;cstdio&gt;
using namespace std;

int main()
{
	{
		int a,b;
		scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
		printf(&quot;%d\n&quot;,a+b);
	}
	return 0;
}
<pre><h2>Problem1000</h2><pre>#include&lt;cstdio&gt;
using namespace std;

int main()
{
	int a,b;
	scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
	printf(&quot;%d\n&quot;,a+b);
	return 0;
}<pre><h2>Problem1000</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
using namespace std;

int main()
{
	int a, b;
	cin &gt;&gt; a &gt;&gt; b;
	cout &lt;&lt; a + b &lt;&lt; endl;
#ifndef ONLINE_JUDGE
	system(&quot;pause&quot;);
#endif
	return 0;
}<pre><h2>Problem1000</h2><pre>import java.util.*;

public class Main{
	public static void main(String[] srgs){
		Scanner jin=new Scanner(System.in);
		int a=jin.nextInt();
		int b=jin.nextInt();
		int ans=a+b;
		System.out.println(ans);
	}
}<pre><h2>Problem1000</h2><pre>import java.util.*;
public class Main {
	public static void main(String[] args){
		Scanner cin=new Scanner(System.in);
		int a=cin.nextInt();
		int b=cin.nextInt();
		Add tmp=new Add();
		int ans=tmp.add(a,b);
		System.out.println(ans);
	}
}
class Add{
	int add(int x,int y){
		return x+y;
	}
}<pre><h2>Problem1000</h2><pre>var a,b:integer;
begin
    read(a,b);
    writeln(a+b);
end.<pre><h2>Problem1001</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
using namespace std;
int aa[7000000][3],o[2000000],A[1100][1100],B[1100][1100],C[1100][1100],q[10000000],hao[1100][1100][2],dist[2000000];
bool dl[2000000];
int n,m,i,j,num,tot,head,tail,S,T;
void add(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void addedge(int p,int q,int v)
{
	//printf(&quot;addedge:  %d %d %d\n&quot;,p,q,v);
	add(p,q,v);
	add(q,p,v);
}
void pan()
{
	if (n!=1&amp;&amp;m!=1) return;
	int ans=99999999;
	int x;
	if (n==1&amp;&amp;m==1) printf(&quot;%d\n&quot;,0);
	else if (n==1)
	{
		for (int i=1;i&lt;m;i++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			if (x&lt;ans) ans=x;
		}
		printf(&quot;%d\n&quot;,ans);
	}
	else if (m==1)
	{
		for (int i=1;i&lt;n;i++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			if (x&lt;ans) ans=x;
		}
		printf(&quot;%d\n&quot;,ans);
	}
	exit(0);
}
void init()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	pan();
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;m;j++) scanf(&quot;%d&quot;,&amp;A[i][j]);
	for (i=1;i&lt;n;i++)
		for (j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;B[i][j]);
	for (i=1;i&lt;n;i++)
		for (j=1;j&lt;m;j++) scanf(&quot;%d&quot;,&amp;C[i][j]);
	num=0;
	for (i=1;i&lt;n;i++)
		for (j=1;j&lt;m;j++) hao[i][j][0]=++num,hao[i][j][1]=++num;
	//for (i=1;i&lt;n;i++){for (j=1;j&lt;m;j++) printf(&quot;  %d %d  &quot;,hao[i][j][0],hao[i][j][1]);printf(&quot;\n&quot;);}
	S=++num,T=++num;
	for (i=1;i&lt;n;i++)
		for (j=1;j&lt;m;j++)
		{
			addedge(hao[i][j][0],hao[i][j][1],C[i][j]);
			if (i&lt;n-1) addedge(hao[i][j][0],hao[i+1][j][1],A[i+1][j]);
			if (j&lt;m-1) addedge(hao[i][j][1],hao[i][j+1][0],B[i][j+1]);
		}
	for (i=1;i&lt;n;i++)
	{
		addedge(S,hao[i][1][0],B[i][1]);
		addedge(hao[i][m-1][1],T,B[i][m]);
	}
	for (j=1;j&lt;m;j++)
	{
		addedge(S,hao[n-1][j][0],A[n][j]);
		addedge(hao[1][j][1],T,A[1][j]);
	}
}
bool relax(int x,int y,int v)
{
	if (dist[y]&gt;dist[x]+v)
	{
		dist[y]=dist[x]+v;
		return 1;
	}
	return 0;
}
void doit()
{
	head=tail=0;
	memset(dist,127,sizeof(dist[0])*(T+10));
	dist[S]=0;
	q[++tail]=S;
	dl[S]=1;
	while (head!=tail)
	{
		++head;if (head==3000000) head=1;
		int x=q[head];
		int p=o[x];
		dl[x]=0;
		while (p)
		{
			int y=aa[p][1];
			if (relax(x,y,aa[p][2]))
				if (!dl[y])
				{
					//printf(&quot;y=%d\n&quot;,y);
					++tail;if (tail==3000000) tail=1;
					q[tail]=y;
					dl[y]=1;
				}
			p=aa[p][0];
		}
		//printf(&quot;%d\n&quot;,tail);
	}
	printf(&quot;%d\n&quot;,dist[T]);
}
int main()
{
	//freopen(&quot;10014.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	init();
	doit();
	return 0;
}
<pre><h2>Problem1002</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int n;
struct number
{
	int m[51],l;
	void clear()
	{
		memset(m,0,sizeof(m));
		l=1;
	}
	void out()
	{
		for (int i=l;i;i--) printf(&quot;%d&quot;,m[i]);
		printf(&quot;\n&quot;);
	}
	friend number operator *(int x,number a)
	{
		int i;
		for (i=1;i&lt;=a.l;i++) a.m[i]*=x;
		for (i=1;i&lt;a.l;i++)
			if (a.m[i]&gt;9) a.m[i+1]+=a.m[i]/10,a.m[i]%=10;
		while (a.m[a.l]&gt;9)
			a.m[a.l+1]=a.m[a.l]/10,a.m[a.l]%=10,a.l++;
		return a;
	}
	friend number operator -(number a,number b)
	{
		int i;
		for (i=1;i&lt;=b.l;i++) a.m[i]-=b.m[i];
		for (i=1;i&lt;a.l;i++)
			if (a.m[i]&lt;0) a.m[i]+=10,a.m[i+1]--;
		while (a.m[a.l]==0&amp;&amp;a.l&gt;1) a.l--;
		return a;
	}
	friend number operator +(number a,int x)
	{
		a.m[1]+=x;
		int i;
		for (i=1;i&lt;a.l;i++)
			if (a.m[i]&gt;9) a.m[i+1]+=a.m[i]/10,a.m[i]%=10;
		while (a.m[a.l]&gt;9)
			a.m[a.l+1]=a.m[a.l]/10,a.m[a.l]%=10,a.l++;
		return a;
	}
} f[111];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	f[1].l=1,f[1].m[1]=1;
	f[2].l=1,f[2].m[1]=5;
	for (int i=3;i&lt;=n;i++)
		f[i]=3*f[i-1]-f[i-2]+2;
	f[n].out();
	return 0;
}
<pre><h2>Problem1002</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int n;
struct number
{
	int m[51],l;
	void out()
	{
		for (int i=l;i;i--) printf(&quot;%d&quot;,m[i]);
		printf(&quot;\n&quot;);
	}
	friend number operator *(int x,number a)
	{
		int i;
		for (i=1;i&lt;=a.l;i++) a.m[i]*=x;
		for (i=1;i&lt;a.l;i++)
			if (a.m[i]&gt;9) a.m[i+1]+=a.m[i]/10,a.m[i]%=10;
		while (a.m[a.l]&gt;9)
			a.m[a.l+1]=a.m[a.l]/10,a.m[a.l]%=10,a.l++;
		return a;
	}
	friend number operator -(number a,number b)
	{
		int i;
		for (i=1;i&lt;=b.l;i++) a.m[i]-=b.m[i];
		for (i=1;i&lt;a.l;i++)
			if (a.m[i]&lt;0) a.m[i]+=10,a.m[i+1]--;
		while (a.m[a.l]==0&amp;&amp;a.l&gt;1) a.l--;
		return a;
	}
	friend number operator +(number a,int x)
	{
		a.m[1]+=x;
		int i;
		for (i=1;i&lt;a.l;i++)
			if (a.m[i]&gt;9) a.m[i+1]+=a.m[i]/10,a.m[i]%=10;
		while (a.m[a.l]&gt;9)
			a.m[a.l+1]=a.m[a.l]/10,a.m[a.l]%=10,a.l++;
		return a;
	}
} f[111];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	f[1].l=1,f[1].m[1]=1;
	f[2].l=1,f[2].m[1]=5;
	for (int i=3;i&lt;=n;i++)
		f[i]=3*f[i-1]-f[i-2]+2;
	f[n].out();
	return 0;
}
<pre><h2>Problem1003</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 999999999
const int DD=105,NN=23;
int ban[DD][NN],q[1000],dist[NN],o[NN],aa[10000][3],cost[DD][DD],f[DD];
int n,m,D,K,tot=1;
bool flag[NN],dl[NN];
int spfa(int l,int r)
{
	memset(flag,0,sizeof(flag));
	int i,j,head=0,tail=1;
	for (i=l;i&lt;=r;i++)
		for (j=1;j&lt;=n;j++) if (ban[i][j]) flag[j]=true;
	memset(dist,60,sizeof(dist));
	dist[1]=0;
	memset(dl,0,sizeof(dl));
	dl[1]=true;
	q[1]=1;
	while (head&lt;tail)
	{
		int x=q[++head],dd=dist[x];
		dl[x]=false;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (flag[y]) continue;
			if (dist[y]&gt;dd+aa[p][2])
			{
				dist[y]=dd+aa[p][2];
				//printf(&quot;dis[y]=%d\n&quot;,dist[y]);
				if (!dl[y]) dl[y]=true,q[++tail]=y;
			}
		}
	}
	//printf(&quot;dist[n]=%d\n&quot;,dist[n]);
	if (dist[n]==dist[0]) return -1;
	return dist[n];
}
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d%d&quot;,&amp;D,&amp;n,&amp;K,&amp;m);
	int i,j,x,y,z,t;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
	}
	scanf(&quot;%d&quot;,&amp;t);
	for (i=1;i&lt;=t;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		for (j=y;j&lt;=z;j++) ban[j][x]=true;
	}
	for (i=1;i&lt;=D;i++)
		for (j=i;j&lt;=D;j++) cost[i][j]=(j-i+1)*spfa(i,j);//,printf(&quot;cost[%d][%d]=%d\n&quot;,i,j,cost[i][j]);
	for (i=1;i&lt;=D;i++)
	{
		f[i]=inf;
		for (j=0;j&lt;i;j++)
		{
			if (cost[j+1][i]&lt;0) continue;
			int tmp=j?f[j]+cost[j+1][i]+K:cost[j+1][i];
			if (tmp&lt;f[i]) f[i]=tmp;
		}
	}
	printf(&quot;%d\n&quot;,f[D]);
	return 0;
}<pre><h2>Problem1004</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int a[1000][1000],f[100][100][100],sum[1000],b[1000];
int S1,S2,S3,m,mo,n,i,j,k,ans;
bool flag,ttt,vt[1000];
int ksm(int a,int b)
{
	int res=1;
	for (;b;b&gt;&gt;=1,a=a*a%mo) if (b&amp;1) res=res*a%mo;
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d%d%d&quot;,&amp;S1,&amp;S2,&amp;S3,&amp;m,&amp;mo);
	n=S1+S2+S3;	
	for (flag=false,i=1;i&lt;=m;i++)
	{
		ttt=true;
		for (j=1;j&lt;=n;j++)
		{
			scanf(&quot;%d&quot;,&amp;a[i][j]);
			if (a[i][j]!=j) ttt=false;
		}
		if (ttt) flag=true;
	}
	if (!flag)
	{
		m++;
		for (i=1;i&lt;=n;i++) a[m][i]=i;
	}
	ans=0;
	for (int t=1;t&lt;=m;t++)
	{
		//printf(&quot;\n-------------------------------------------------------------\n&quot;);
		memset(vt,0,sizeof(vt));
		int num=0;
		for (j=1;j&lt;=n;j++)
			if (!vt[j])
			{
				vt[j]=true;
				int len=1;
				int now=a[t][j];
				while (now!=j)
				{
					len++;
					vt[now]=true;
					now=a[t][now];
				}
				b[++num]=len;
				sum[num]=sum[num-1]+b[num];
			}
		//for (i=1;i&lt;=num;i++) printf(&quot;%d &quot;,b[i]);printf(&quot;\n&quot;);
		memset(f,0,sizeof(f));
		f[0][0][0]=1;
		for (i=1;i&lt;=num;i++)
			for (j=0;j&lt;=S1;j++)
				for (k=0;k&lt;=S2;k++)
				{
					if (sum[i]&lt;j+k) continue;
					if (sum[i]-j-k&gt;S3) continue;
					if (b[i]&lt;=j) f[i][j][k]+=f[i-1][j-b[i]][k];
					if (b[i]&lt;=k) f[i][j][k]+=f[i-1][j][k-b[i]];
					if (b[i]&lt;=sum[i]-j-k) f[i][j][k]+=f[i-1][j][k];
					f[i][j][k]%=mo;
					//printf(&quot;%d\n&quot;,f[i][j][k]);
				}
		ans=(ans+f[num][S1][S2])%mo;
	}
	//printf(&quot;m=%d\n&quot;,m);
	ans=ans*ksm(m,mo-2)%mo;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1004</h2><pre>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int a[1000][1000],f[100][100][100],sum[1000],b[1000];
int S1,S2,S3,m,mo,n,i,j,k,ans;
int flag,ttt,vt[1000];
int ksm(int a,int b)
{
	int res=1;
	for (;b;b&gt;&gt;=1,a=a*a%mo) if (b&amp;1) res=res*a%mo;
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d%d%d&quot;,&amp;S1,&amp;S2,&amp;S3,&amp;m,&amp;mo);
	n=S1+S2+S3;	
	for (flag=0,i=1;i&lt;=m;i++)
	{
		ttt=1;
		for (j=1;j&lt;=n;j++)
		{
			scanf(&quot;%d&quot;,&amp;a[i][j]);
			if (a[i][j]!=j) ttt=0;
		}
		if (ttt) flag=1;
	}
	if (!flag)
	{
		m++;
		for (i=1;i&lt;=n;i++) a[m][i]=i;
	}
	ans=0;
	int t;
	for (t=1;t&lt;=m;t++)
	{
		//printf(&quot;\n-------------------------------------------------------------\n&quot;);
		memset(vt,0,sizeof(vt));
		int num=0;
		for (j=1;j&lt;=n;j++)
			if (!vt[j])
			{
				vt[j]=1;
				int len=1;
				int now=a[t][j];
				while (now!=j)
				{
					len++;
					vt[now]=1;
					now=a[t][now];
				}
				b[++num]=len;
				sum[num]=sum[num-1]+b[num];
			}
		//for (i=1;i&lt;=num;i++) printf(&quot;%d &quot;,b[i]);printf(&quot;\n&quot;);
		memset(f,0,sizeof(f));
		f[0][0][0]=1;
		for (i=1;i&lt;=num;i++)
			for (j=0;j&lt;=S1;j++)
				for (k=0;k&lt;=S2;k++)
				{
					if (sum[i]&lt;j+k) continue;
					if (sum[i]-j-k&gt;S3) continue;
					if (b[i]&lt;=j) f[i][j][k]+=f[i-1][j-b[i]][k];
					if (b[i]&lt;=k) f[i][j][k]+=f[i-1][j][k-b[i]];
					if (b[i]&lt;=sum[i]-j-k) f[i][j][k]+=f[i-1][j][k];
					f[i][j][k]%=mo;
					//printf(&quot;%d\n&quot;,f[i][j][k]);
				}
		ans=(ans+f[num][S1][S2])%mo;
	}
	//printf(&quot;m=%d\n&quot;,m);
	ans=ans*ksm(m,mo-2)%mo;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1004</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=105;
int a[NN][NN],f[NN][NN][NN],b[NN],vt[NN],num[NN];
int n,S1,S2,S3,m,P;
int ksm(int a,int b,int c)
{
	int res=1;
	for (;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d%d%d&quot;,&amp;S1,&amp;S2,&amp;S3,&amp;m,&amp;P);
	n=S1+S2+S3;
	bool flag=false;
	int i,j,k;
	for (i=1;i&lt;=m;i++)
	{
		bool tt=true;
		for (j=1;j&lt;=n;j++)
		{
			scanf(&quot;%d&quot;,&amp;a[i][j]);
			if (a[i][j]!=j) tt=false;
		}
		if (tt) flag=true;
	}
	if (!flag)
	{
		m++;
		for (i=1;i&lt;=n;i++) a[m][i]=i;
	}
	int ans=0;
	for (int ii=1;ii&lt;=m;ii++)
	{
		//printf(&quot;\n-------------------------------------------------------------------------------\n&quot;);
		for (i=1;i&lt;=n;i++) b[i]=a[ii][i];
		memset(vt,0,sizeof(vt));
		int cnt=0;
		for (i=1;i&lt;=n;i++) if (!vt[i])
		{
			vt[i]=true;
			int x=b[i];
			num[++cnt]=1;
			for (;x!=i;x=b[x]) num[cnt]++,vt[x]=true;
		}
		//for (i=1;i&lt;=cnt;i++) printf(&quot;%d &quot;,num[i]);ln;
		memset(f,0,sizeof(f));
		f[0][0][0]=1;
		for (i=1;i&lt;=cnt;i++)
			for (j=0;j&lt;=S1;j++)
				for (k=0;k&lt;=S2;k++)
				{
					int &amp;res=f[i][j][k];
					if (j&gt;=num[i]) res+=f[i-1][j-num[i]][k];
					if (k&gt;=num[i]) res+=f[i-1][j][k-num[i]];
					if (n-j-k&gt;=num[i]) res+=f[i-1][j][k];
					res%=P;
				}
		ans+=f[n][S1][S2];
		if (ans&gt;P) ans-=P;
		//printf(&quot;ans=%d\n&quot;,ans);
	}
	ans=ans*ksm(m,P-2,P)%P;
	//ln;ln;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1004</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int a[1000][1000],f[100][100][100],sum[1000],b[1000];
int S1,S2,S3,m,mo,n,i,j,k,ans;
bool flag,ttt,vt[1000];
int ksm(int a,int b)
{
    int res=1;
    for (;b;b&gt;&gt;=1,a=a*a%mo) if (b&amp;1) res=res*a%mo;
    return res;
}
int main()
{
   // freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d%d%d%d%d&quot;,&amp;S1,&amp;S2,&amp;S3,&amp;m,&amp;mo);
    n=S1+S2+S3; 
    for (flag=false,i=1;i&lt;=m;i++)
    {
        ttt=true;
        for (j=1;j&lt;=n;j++)
        {
            scanf(&quot;%d&quot;,&amp;a[i][j]);
            if (a[i][j]!=j) ttt=false;
        }
        if (ttt) flag=true;
    }
    if (!flag)//²»Ðý×ªÒ²ÊÇÒ»ÖÖÖÃ»»
    {
        m++;
        for (i=1;i&lt;=n;i++) a[m][i]=i;
    }
    ans=0;
    for (int t=1;t&lt;=m;t++)
    {
        memset(vt,0,sizeof(vt));
        int num=0;
        for (j=1;j&lt;=n;j++)
            if (!vt[j])
            {
                vt[j]=true;
                int len=1;
                int now=a[t][j];
                while (now!=j)
                {
                    len++;
                    vt[now]=true;
                    now=a[t][now];
                }
                b[++num]=len;
                sum[num]=sum[num-1]+b[num];
            }
        memset(f,0,sizeof(f));
        f[0][0][0]=1;//f[i][j][k]±íÊ¾ÒÑ¾­·ÅÍêÁËÇ°i¸öÑ­»·£¬ÓÃÁËj¸öA£¬k¸öB
        for (i=1;i&lt;=num;i++)
            for (j=0;j&lt;=S1;j++)
                for (k=0;k&lt;=S2;k++)
                {
                   
                    if (b[i]&lt;=j) f[i][j][k]+=f[i-1][j-b[i]][k];
                    if (b[i]&lt;=k) f[i][j][k]+=f[i-1][j][k-b[i]];
                    if (b[i]&lt;=sum[i]-j-k) f[i][j][k]+=f[i-1][j][k];
                    f[i][j][k]%=mo;
                }
        ans=(ans+f[num][S1][S2])%mo;
    }
    ans=ans*ksm(m,mo-2)%mo;//Õâ¸öÌâÃ»·¨ÔÚÇóºÍµÄ¹ý³ÌÖÐÈ¡Ä££¬ËùÒÔ×îºóÓÃÄæÔªÇó¡£
    printf(&quot;%d\n&quot;,ans);
    return 0;
}<pre><h2>Problem1004</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
int n,m,P,S1,S2,S3,a[1011][1011];
int calc(int *a)
{
	static bool vt[1011];
	static int num[1011],sum[1011],f[111][111][111];
	int i,j,k,cnt=0;
	memset(vt,0,sizeof(vt));
	//for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,a[i]);ln;
	for (i=1;i&lt;=n;i++) if (!vt[i])
	{
		int x=i,len=0;
		while (!vt[x]) vt[x]=true,len++,x=a[x];
		num[++cnt]=len;
		sum[cnt]=sum[cnt-1]+len;
	}
	memset(f,0,sizeof(f));
	f[0][0][0]=1;
	for (i=1;i&lt;=cnt;i++)
		for (j=0;j&lt;=S1;j++)
			for (k=0;k&lt;=S2;k++)
			{
				int &amp;res=f[i][j][k];
				if (j&gt;=num[i]) res+=f[i-1][j-num[i]][k];
				if (k&gt;=num[i]) res+=f[i-1][j][k-num[i]];
				if (sum[i]-j-k&gt;=num[i]) res+=f[i-1][j][k];
				res%=P;
			}
	return f[cnt][S1][S2];
}
int ksm(int a,int b,int c)
{
	int res=1;
	for (a%=c;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d%d%d&quot;,&amp;S1,&amp;S2,&amp;S3,&amp;m,&amp;P);
	n=S1+S2+S3;
	bool flag=false;
	int i,j;
	for (i=1;i&lt;=m;i++)
	{
		bool tt=true;
		for (j=1;j&lt;=n;j++)
		{
			scanf(&quot;%d&quot;,&amp;a[i][j]);
			if (a[i][j]!=j) tt=false;
		}
		if (tt) flag=true;
	}
	if (!flag)
	{
		m++;
		for (j=1;j&lt;=n;j++) a[m][j]=j;
	}
	int ans=0;
	for (i=1;i&lt;=m;i++)
		ans=(ans+calc(a[i]))%P;
	ans=ans*ksm(m,P-2,P)%P;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1005</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int NN=1011;
int pr[NN],num[NN],du[NN];
int n,cnt,sum,tot;
bool is[NN];
struct big
{
	int m[3000],l;
	big() {memset(m,0,sizeof(m));l=1;}
	void out() {for (int i=l;i;i--) printf(&quot;%d&quot;,m[i]);printf(&quot;\n&quot;);}
	void update()
	{
		for (int i=1;i&lt;l;i++)
			if (m[i]&gt;9) m[i+1]+=m[i]/10,m[i]%=10;
		while (m[l]&gt;9)
			m[l+1]=m[l]/10,m[l]%=10,l++;
	}
	friend big operator *(int x,big a)
	{
		for (int i=1;i&lt;=a.l;i++) a.m[i]*=x;
		a.update();
		return a;
	}
} ans;
void shai()
{
	memset(is,1,sizeof(is));
	is[1]=false;
	for (int i=2;i&lt;=n;i++)
	{
		if (is[i]) pr[++tot]=i;
		for (int j=1;j&lt;=tot;j++)
		{
			int x=i*pr[j];
			if (x&gt;n) break;
			is[x]=false;
			if (i%pr[j]==0) break;
		}
	}
}
void add(int k,int t)
{
	for (int i=1;i&lt;=tot;i++)
	{
		int x=k;
		while (x&gt;1)
		{
			num[i]+=x/pr[i]*t;
			x/=pr[i];
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j,x;
	if (n==1)
	{
		scanf(&quot;%d&quot;,&amp;x);
		printf(x==0?&quot;1\n&quot;:&quot;0\n&quot;);
		return 0;
	}
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;du[i]);
		if (du[i]==0) {printf(&quot;0\n&quot;);return 0;}
		else if (du[i]==-1) cnt++;
		else sum+=du[i]-1;
	}
	if (sum&gt;n-2) {printf(&quot;0\n&quot;);return 0;}
	shai();
	//for (i=1;i&lt;=tot;i++) printf(&quot;%d &quot;,pr[i]);printf(&quot;\n&quot;);
	add(n-2,1);
	add(n-2-sum,-1);
	for (i=1;i&lt;=n;i++)
		if (du[i]&gt;0) add(du[i]-1,-1);
	//for (i=1;i&lt;=tot;i++) printf(&quot;%d &quot;,num[i]);printf(&quot;\n&quot;);
	ans.m[1]=1;
	for (i=1;i&lt;=tot;i++)
		for (j=1;j&lt;=num[i];j++) ans=pr[i]*ans;
	//printf(&quot;cnt=%d\n&quot;,cnt);
	for (i=1;i&lt;=n-2-sum;i++) ans=cnt*ans;
	ans.out();
	return 0;
}
<pre><h2>Problem1006</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
const int NN=10011,MM=1001111;
int o[NN],aa[MM*2][2],pos[NN],label[NN];
int n,m,tot=1;
bool vt[NN];
struct ppt
{
	int num,v;
	ppt(int a=0,int b=0) {num=a,v=b;}
	friend bool operator &lt;(ppt a,ppt b) {return a.num&lt;b.num;}
};
priority_queue&lt;ppt&gt; Q;
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	for (i=1;i&lt;=n;i++) Q.push(ppt(0,i));
	for (i=n;i;i--)
	{
		while (vt[Q.top().v]) Q.pop();
		int v=Q.top().v;
		Q.pop();
		pos[v]=i;
		vt[v]=true;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (!vt[y]) Q.push(ppt(++label[y],y));
		}
	}
	int ans=0;
	for (i=1;i&lt;=n;i++)
	{
		int t=1;
		for (int p=o[i];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (pos[y]&gt;pos[i]) t++;
		}
		if (t&gt;ans) ans=t;
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1006</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
const int NN=10011,MM=1001111;
int o[NN],aa[MM*2][2],pos[NN],label[NN];
int n,m,tot=1;
bool vt[NN];
struct ppt
{
    int num,v;
    ppt(int a=0,int b=0) {num=a,v=b;}
    friend bool operator &lt;(ppt a,ppt b) {return a.num&lt;b.num;}
};
priority_queue&lt;ppt&gt; Q;
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int main()
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    int i,x,y;
    for (i=1;i&lt;=m;i++)
    {
        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
        addedge(x,y),addedge(y,x);
    }
    for (i=1;i&lt;=n;i++) Q.push(ppt(0,i));
    for (i=n;i;i--)
    {
    	while (vt[Q.top().v]) Q.pop();
    	int v=Q.top().v;Q.pop();
    	vt[v]=true;
    	pos[v]=i;
    	for (int p=o[v];p;p=aa[p][0])
    	{
    		int y=aa[p][1];
    		if (!vt[y]) Q.push(ppt(++label[y],y));
    	}
    }
    int ans=0;
    for (i=1;i&lt;=n;i++)
    {
        int t=1;
        for (int p=o[i];p;p=aa[p][0])
        {
            int y=aa[p][1];
            if (pos[y]&gt;pos[i]) t++;
        }
        if (t&gt;ans) ans=t;
    }
    printf(&quot;%d\n&quot;,ans);
    return 0;
}<pre><h2>Problem1007</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define DD double
#define sm 0.00000001
int n,i,num,top,sta[510000];
struct zhixian {DD k,b;int id;} a[510000],b[510000];
struct point {DD x,y;};
bool cmp(zhixian a,zhixian b) {return a.k&lt;b.k;}
point calc(int i,int j)
{
	//printf(&quot;calc:  %d %d\n&quot;,i,j);
	point tmp;
	tmp.x=(a[i].b-a[j].b)/(a[j].k-a[i].k);
	tmp.y=tmp.x*a[i].k+a[i].b;
	//printf(&quot;calc tmp:  %.3f %.3f\n&quot;,tmp.x,tmp.y);
	return tmp;
}
bool check(int i,int j,int k)
{
	point t1,t2;
	t1=calc(i,j);
	//printf(&quot;t1: %.3f %.3f\n&quot;,t1.x,t1.y);
	t2=calc(i,k);
	//printf(&quot;t2: %.3f %.3f\n&quot;,t2.x,t2.y);
	if (t2.x-t1.x&lt;sm) return 1;
	else return 0;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	for (i=1;i&lt;=n;i++) scanf(&quot;%lf%lf&quot;,&amp;a[i].k,&amp;a[i].b),a[i].id=i,b[i]=a[i];
	sort(b+1,b+n+1,cmp);
	//for (i=1;i&lt;=n;i++) printf(&quot;%.0f %.0f %d\n&quot;,b[i].k,b[i].b,b[i].id);
	num=1;
	for (i=2;i&lt;=n;i++)
		if (b[i].k!=b[num].k) b[++num]=b[i];
		else if (b[num].b&lt;b[i].b) b[num]=b[i];
	//for (i=1;i&lt;=num;i++) printf(&quot;%d\n&quot;,b[i].id);
	for (i=1;i&lt;=num;i++)
	{
		//printf(&quot;\n--------------------------------------\n&quot;);
		while (top&gt;1&amp;&amp;check(sta[top-1],sta[top],b[i].id)) --top;
		sta[++top]=b[i].id;
	}
	sort(sta+1,sta+top+1);
	for (i=1;i&lt;=top;i++) printf(&quot;%d &quot;,sta[i]);
	return 0;
}
<pre><h2>Problem1007</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define DD double
#define sm 0.00000001
int n,i,num,top,sta[510000];
struct zhixian {DD k,b;int id;} a[510000],b[510000];
struct point {DD x,y;};
bool cmp(zhixian a,zhixian b) {return a.k&lt;b.k;}
point calc(int i,int j)
{
	point tmp;
	tmp.x=(a[i].b-a[j].b)/(a[j].k-a[i].k);
	tmp.y=tmp.x*a[i].k+a[i].b;
	return tmp;
}
bool check(int i,int j,int k)
{
	point t1,t2;
	t1=calc(i,j);
	t2=calc(i,k);
	if (t2.x-t1.x&lt;sm) return 1;
	else return 0;
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	for (i=1;i&lt;=n;i++) scanf(&quot;%lf%lf&quot;,&amp;a[i].k,&amp;a[i].b),a[i].id=i,b[i]=a[i];
	sort(b+1,b+n+1,cmp);
	num=1;
	for (i=2;i&lt;=n;i++)
		if (b[i].k!=b[num].k) b[++num]=b[i];
		else if (b[num].b&lt;b[i].b) b[num]=b[i];
	for (i=1;i&lt;=num;i++)
	{
		while (top&gt;1&amp;&amp;check(sta[top-1],sta[top],b[i].id)) --top;
		sta[++top]=b[i].id;
	}
	sort(sta+1,sta+top+1);
	for (i=1;i&lt;=top;i++) printf(&quot;%d &quot;,sta[i]);
	return 0;
}
<pre><h2>Problem1008</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define LL long long
const int mo=100003;
LL n,m,ans;
LL ksm(LL a,LL b)
{
	LL res=1;
	for (a%=mo;b;b&gt;&gt;=1,a=a*a%mo) if (b&amp;1) res=res*a%mo;
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld%lld&quot;,&amp;m,&amp;n);
	LL ans=(ksm(m,n)-m*ksm(m-1,n-1))%mo;
	if (ans&lt;0) ans+=mo;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1009</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int n,m,mo,i,j,k,next[22],res;
char s[22];
struct matrix{int a[22][22];matrix(){memset(a,0,sizeof(a));}} sum,ans;
matrix mul(matrix A,matrix B)
{
	matrix C;
	int i,j,k;
	for (k=0;k&lt;m;k++)
		for (i=0;i&lt;m;i++)
			for (j=0;j&lt;m;j++) C.a[i][j]=(C.a[i][j]+A.a[i][k]*B.a[k][j])%mo;
	return C;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d\n&quot;,&amp;n,&amp;m,&amp;mo);
	scanf(&quot;%s&quot;,s+1);
	next[1]=0;
	for (i=2,j=0;i&lt;=m;i++)
	{
		while (s[i]!=s[j+1]&amp;&amp;j&gt;0) j=next[j];
		if (s[i]==s[j+1]) j++;
		next[i]=j;
	}
	for (i=0;i&lt;m;i++)
		for (j=0;j&lt;=9;j++)
		{
			k=i;
			while (k&gt;0&amp;&amp;s[k+1]-'0'!=j) k=next[k];
			if (s[k+1]-'0'==j) ++k;
			++sum.a[i][k];
		}
	for (i=0;i&lt;m;i++) ans.a[i][i]=1;
	while (n&gt;0)
	{
		if (n&amp;1) ans=mul(ans,sum);
		n&gt;&gt;=1;
		sum=mul(sum,sum);
	}
	res=0;
	for (i=0;i&lt;m;i++) res=(res+ans.a[0][i])%mo;
	printf(&quot;%d\n&quot;,res);
	return 0;
}
<pre><h2>Problem1009</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int n,m,mo,i,j,k,next[22],res;
char s[22];
struct matrix{int w[22][22];matrix(){memset(w,0,sizeof(w));}} sum,ans;
matrix mul(matrix A,matrix B)
{
	matrix C;
	int i,j,k;
	for (k=0;k&lt;m;k++)
		for (i=0;i&lt;m;i++)
			for (j=0;j&lt;m;j++) C.w[i][j]=(C.w[i][j]+A.w[i][k]*B.w[k][j])%mo;
	return C;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d\n&quot;,&amp;n,&amp;m,&amp;mo);
	scanf(&quot;%s&quot;,s+1);
	next[1]=0;
	for (i=2,j=0;i&lt;=m;i++)
	{
		while (s[i]!=s[j+1]&amp;&amp;j&gt;0) j=next[j];
		if (s[i]==s[j+1]) j++;
		next[i]=j;
	}
	for (i=0;i&lt;m;i++)
		for (j=0;j&lt;=9;j++)
		{
			k=i;
			while (k&gt;0&amp;&amp;s[k+1]-'0'!=j) k=next[k];
			if (s[k+1]-'0'==j) ++k;
			++sum.w[i][k];
		}
	for (i=0;i&lt;m;i++) ans.w[i][i]=1;
	while (n&gt;0)
	{
		if (n&amp;1) ans=mul(ans,sum);
		n&gt;&gt;=1;
		sum=mul(sum,sum);
	}
	res=0;
	for (i=0;i&lt;m;i++) res=(res+ans.w[0][i])%mo;
	printf(&quot;%d\n&quot;,res);
	return 0;
}
<pre><h2>Problem1010</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define LL long long
int n,head,tail,k,j,i,q[51000];
LL L,f[51000],b[51000],S[51000];
LL fenzi(int i) {return f[i]+b[i]*b[i]+2*(L+1)*b[i];}
int main()
{
	/*
		f[i]:前i个玩具装完的最小费用
		f[i]=min(f[j]+cost[j+1][i]
		cost[i][j]=(j-i+S[j]-S[i-1]-L)^2 
	*/
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%lld&quot;,&amp;n,&amp;L);
	for (i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;S[i]),S[i]+=S[i-1],b[i]=i+S[i];
	head=0;
	q[tail=1]=0;
	for (i=1;i&lt;=n;i++)
	{
		int k=q[head+2],j=q[head+1];
		while (fenzi(k)-fenzi(j)&lt;=(b[k]-b[j])*2*(i+S[i])&amp;&amp;tail&gt;head+1)
		{
			++head;
			k=q[head+2],j=q[head+1];
		}
		f[i]=f[j]+(b[i]-b[j]-(L+1))*(b[i]-b[j]-(L+1));
		k=q[tail],j=q[tail-1];
		while ((fenzi(i)-fenzi(k))*(b[k]-b[j])&lt;=(fenzi(k)-fenzi(j))*(b[i]-b[k])&amp;&amp;tail&gt;head+1)
		{
			--tail;
			k=q[tail],j=q[tail-1];
		}
		q[++tail]=i;
	}
	printf(&quot;%lld\n&quot;,f[n]);
	return 0;
}
<pre><h2>Problem1011</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define mii(a,b) ((a)&lt;(b)?(a):(b))
typedef double DD;
const DD eps=1e-7;
const int NN=101111;
int a[NN],n;
DD alfa,f[NN],sum[NN];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%lf&quot;,&amp;n,&amp;alfa);
	int i,j;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),sum[i]=sum[i-1]+a[i];
	int t=mii(n,2000);
	for (i=1;i&lt;=t;i++)
		for (j=1;j&lt;i;j++)
			if (j-alfa*i&lt;eps) f[i]+=(DD)a[i]*a[j]/(i-j);
	for (i=2001;i&lt;=n;i++)
	{
		int k=(int)(alfa*i);
		DD t=(k+1)*0.5;
		f[i]=(DD)a[i]*sum[k]/(i-t);
	}
	for (i=1;i&lt;=n;i++) printf(&quot;%.6f\n&quot;,f[i]);
	return 0;
}<pre><h2>Problem1011</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define mii(a,b) ((a)&lt;(b)?(a):(b))
typedef double DD;
const DD eps=1e-7;
const int NN=101111;
int a[NN],n;
DD alfa,f[NN],sum[NN];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%lf&quot;,&amp;n,&amp;alfa);
	int i,j;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),sum[i]=sum[i-1]+a[i];
	int t=mii(n,1000);
	for (i=1;i&lt;=t;i++)
		for (j=1;j&lt;i;j++)
			if (j-alfa*i&lt;eps) f[i]+=(DD)a[i]*a[j]/(i-j);
			else break;
	for (i=1001;i&lt;=n;i++)
	{
		int k=(int)(alfa*i);
		DD t=(k+1)*0.5;
		f[i]=(DD)a[i]*sum[k]/(i-t);
	}
	for (i=1;i&lt;=n;i++) printf(&quot;%.6f\n&quot;,f[i]);
	return 0;
}<pre><h2>Problem1011</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define mii(a,b) ((a)&lt;(b)?(a):(b))
typedef double DD;
const DD eps=1e-7;
const int NN=100005;
int a[NN],n;
DD alfa,f[NN],sum[NN];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%lf&quot;,&amp;n,&amp;alfa);
	int i,j;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),sum[i]=sum[i-1]+a[i];
	int t=mii(n,900);
	for (i=1;i&lt;=t;i++)
		for (j=1;j&lt;i;j++)
			if (j-alfa*i&lt;eps) f[i]+=(DD)a[i]*a[j]/(i-j);
			else break;
	for (i=901;i&lt;=n;i++)
	{
		int k=(int)(alfa*i);
		DD t=(k+1)*0.5;
		f[i]=(DD)a[i]*sum[k]/(i-t);
	}
	for (i=1;i&lt;=n;i++) printf(&quot;%.6f\n&quot;,f[i]);
	return 0;
}<pre><h2>Problem1012</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int NN=200011;
int m,D,n,lastans,top;
struct ppt
{
	int w,id;
} s[NN];
int cha(int x)
{
	int l=1,r=top,res;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (s[mid].id&gt;=x) res=s[mid].w,r=mid-1;
		else l=mid+1;
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d\n&quot;,&amp;m,&amp;D);
	n=0;
	lastans=0;
	int i,x;
	for (i=1;i&lt;=m;i++)
	{
		char ch=getchar();
		if (ch=='A')
		{
			scanf(&quot;%d\n&quot;,&amp;x);
			x=(x+lastans)%D;
			while (top&amp;&amp;x&gt;s[top].w) top--;
			top++;
			s[top].w=x,s[top].id=++n;
		}
		else
		{
			scanf(&quot;%d\n&quot;,&amp;x);
			x=cha(n-x+1);
			printf(&quot;%d\n&quot;,lastans=x);
		}
	}
	return 0;
}<pre><h2>Problem1013</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
const int NN=13;
DD a[NN][NN],X[NN],b[NN],c[NN];
int n;
void gause()
{
	int i,j;
	for (i=1;i&lt;n;i++)
	{
		DD tmp=fabs(a[i][i]);
		int mj=i;
		for (j=i+1;j&lt;=n;j++)
			if (fabs(a[j][i])&gt;tmp) tmp=fabs(a[j][i]),mj=j;
		if (mj!=i) for (j=i;j&lt;=n+1;j++) swap(a[i][j],a[mj][j]);
		for (j=i+1;j&lt;=n;j++)
		{
			DD tmp=a[j][i]/a[i][i];
			for (int k=i;k&lt;=n+1;k++) a[j][k]-=a[i][k]*tmp;
		}
	}
	X[n]=a[n][n+1]/a[n][n];
	for (i=n-1;i;i--)
	{
		DD tmp=0;
		for (j=i+1;j&lt;=n;j++) tmp+=X[j]*a[i][j];
		X[i]=(a[i][n+1]-tmp)/a[i][i];
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	DD tmp=0;
	int i,j;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%lf&quot;,&amp;b[i]);
		tmp+=b[i]*b[i];
	}
	for (i=1;i&lt;=n;i++)
	{
		for (j=1;j&lt;=n;j++) scanf(&quot;%lf&quot;,&amp;c[j]);
		for (j=1;j&lt;=n;j++) a[i][j]=-2*c[j]+2*b[j];
		for (j=1;j&lt;=n;j++) a[i][n+1]-=c[j]*c[j];
		a[i][n+1]+=tmp;
	}
	gause();
	for (i=1;i&lt;=n;i++) printf(i==n?&quot;%.3f\n&quot;:&quot;%.3f &quot;,X[i]);
	return 0;
}<pre><h2>Problem1014</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define pp 19980723
const int NN=101111;
int fa[NN],son[NN][2],size[NN],key[NN],h[NN],mi[NN],s[NN];
int n,m,TTT,root;
char ss[NN];
void update(int t)
{
	int x=son[t][0],y=son[t][1];
	size[t]=size[x]+size[y]+1;
	h[t]=h[x]*mi[size[y]+1]+key[t]*mi[size[y]]+h[y];
}
void rotate(int t,int p)
{
	int y=fa[t];
	if (fa[y])
	{
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	}
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
	if (!ff) root=t;
}
int find(int x)
{
	int t=root;
	for (;;)
	{
		int tmp=size[son[t][0]];
		if (x==tmp+1) return t;
		if (x&lt;=tmp) t=son[t][0];
		else x-=(tmp+1),t=son[t][1];
	}
}
int gethash(int l,int r)
{
	l++,r++;
	int x=find(l-1);splay(x,0);
	int y=find(r+1);splay(y,x);
	x=son[y][0];
	return h[x];
}
int build(int l,int r)
{
	int v=++TTT;
	int mid=(l+r)&gt;&gt;1;
	size[v]=1;
	key[v]=h[v]=s[mid];
	if (l&lt;mid) son[v][0]=build(l,mid-1),fa[son[v][0]]=v;
	if (r&gt;mid) son[v][1]=build(mid+1,r),fa[son[v][1]]=v;
	update(v);
	return v;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	mi[0]=1;
	int i,x,y;
	for (i=1;i&lt;=100000;i++) mi[i]=mi[i-1]*pp;
	scanf(&quot;%s&quot;,ss+1);
	n=strlen(ss+1);
	s[1]=0;
	for (i=1;i&lt;=n;i++) s[i+1]=ss[i];
	s[n+2]=0;
	root=build(1,n+2);
	scanf(&quot;%d&quot;,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		char ch=getchar();
		while (ch!='Q'&amp;&amp;ch!='R'&amp;&amp;ch!='I') ch=getchar();
		if (ch=='Q')
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			if (x&gt;y) {int t=x;x=y;y=t;}
			int l=0,r=n-y+1,res=0;
			while (l&lt;=r)
			{
				int mid=(l+r)&gt;&gt;1;
				if (gethash(x,x+mid-1)==gethash(y,y+mid-1)) res=mid,l=mid+1;
				else r=mid-1;
			}
			printf(&quot;%d\n&quot;,res);
		}
		else if (ch=='R')
		{
			scanf(&quot;%d&quot;,&amp;x);
			ch=getchar();
			while (ch&lt;'a'||ch&gt;'z') ch=getchar();
			x=find(x+1);
			key[x]=h[x]=ch;
			splay(x,0);
		}
		else
		{
			scanf(&quot;%d&quot;,&amp;x);
			ch=getchar();
			while (ch&lt;'a'||ch&gt;'z') ch=getchar();
			y=find(x+2),x=find(x+1);
			splay(x,0);
			splay(y,x);
			son[y][0]=++TTT;
			fa[TTT]=y;
			key[TTT]=h[TTT]=ch;
			size[TTT]=1;
			splay(TTT,0);
			n++;
		}
	}
	return 0;
}<pre><h2>Problem1015</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int NN=4001111,MM=2001111;
int fa[NN],size[NN],aa[MM*2][2],del[NN],o[NN],ans[NN];
int n,m,K,tot=1;
bool flag[NN];
int getfa(int x) {return fa[x]==x?x:fa[x]=getfa(fa[x]);}
void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y;
	for (i=1;i&lt;=n;i++) fa[i]=i,size[i]=1;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		x++,y++;
		addedge(x,y),addedge(y,x);
	}
	scanf(&quot;%d&quot;,&amp;K);
	for (i=1;i&lt;=K;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);x++;
		del[i]=x;
		flag[x]=true;
	}
	int now=n-K;
	for (i=1;i&lt;=n;i++)
		if (!flag[i])
			for (int p=o[i];p;p=aa[p][0])
			{
				int y=aa[p][1];
				if (flag[y]) continue;
				int t1=getfa(i),t2=getfa(y);
				if (t1==t2) continue;
				now--;
				if (size[t1]&lt;size[t2]) fa[t1]=t2,size[t2]+=size[t1];
				else fa[t2]=t1,size[t1]+=size[t2];
			}
	for (i=K;i;i--)
	{
		ans[i]=now++;
		flag[del[i]]=false;
		for (int p=o[del[i]];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (flag[y]) continue;
			int t1=getfa(del[i]),t2=getfa(y);
			if (t1==t2) continue;
			now--;
			if (size[t1]&lt;size[t2]) fa[t1]=t2,size[t2]+=size[t1];
			else fa[t2]=t1,size[t1]+=size[t2];
		}
	}
	printf(&quot;%d\n&quot;,now);
	for (i=1;i&lt;=K;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem1016</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
#define mo 31011
#define NN 1100
int K[NN][NN],fa[NN],pos[NN],which[NN];
int n,m,i,j,k,x,y,ans;
bool use[100000],vt[10000];
struct edge {int a,b,w;} e[100000];
bool cmp (edge a,edge b) {return a.w&lt;b.w;}
int getroot(int x) {return fa[x]==x?x:fa[x]=getroot(fa[x]);}
void gaosixiaoyuan(int n)
{
	int i,j,k;
	//for (i=1;i&lt;=n;i++){for (j=1;j&lt;=n;j++) printf(&quot;%d &quot;,K[i][j]);printf(&quot;\n&quot;);}
	for (i=1;i&lt;=n;i++)
	{
		for (j=i+1;j&lt;=n;j++)
			while (K[j][i])
			{
				int tmp=K[i][i]/K[j][i];
				for (k=i;k&lt;=n;k++) K[i][k]=(K[i][k]-tmp*K[j][k])%mo;
				for (k=i;k&lt;=n;k++) tmp=K[i][k],K[i][k]=K[j][k],K[j][k]=tmp;
				ans*=-1;
			}
		ans=ans*K[i][i]%mo;
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=m;i++) scanf(&quot;%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
	sort(e+1,e+m+1,cmp);
	for (i=1;i&lt;=n;i++) fa[i]=i;
	for (i=1;i&lt;=m;i++)
	{
		int x=e[i].a,y=e[i].b;
		if (getroot(x)==getroot(y)) continue;
		use[i]=true;
		fa[getroot(x)]=y;
	}
	ans=1;
	for (i=1;i&lt;=m;i=j+1)
	{
		for (j=i;e[j].w==e[i].w;j++);
		j--;
		for (k=1;k&lt;=n;k++) fa[k]=k;
		for (k=1;k&lt;i;k++)
			if (use[k]) fa[getroot(e[k].a)]=e[k].b;
		for (k=j+1;k&lt;=m;k++)
			if (use[k]) fa[getroot(e[k].a)]=e[k].b;
		memset(vt,0,sizeof(vt[0])*(n+10));
		int cnt=0;
		for (k=1;k&lt;=n;k++)
		{
			int x=getroot(k);
			if (!vt[x])
			{
				vt[x]=true;
				pos[x]=++cnt;
				which[cnt]=x;
			}
		}
		memset(K,0,sizeof(K));
		for (k=i;k&lt;=j;k++)
		{
			int x=getroot(e[k].a),y=getroot(e[k].b);
			if (x==y) continue;
			x=pos[x],y=pos[y]; 
			K[x][x]++,K[y][y]++;
			K[x][y]--,K[y][x]--;
		}
		gaosixiaoyuan(cnt-1);
	}
	printf(&quot;%d\n&quot;,(ans%mo+mo)%mo);
}
<pre><h2>Problem1016</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
#define mo 31011
#define NN 1005
#define MM 1005
int K[NN][NN],fa[NN],pos[NN],which[NN];
int n,m,i,j,k,x,y,ans;
bool use[MM],vt[NN];
struct edge {int a,b,w;} e[MM];
bool cmp (edge a,edge b) {return a.w&lt;b.w;}
int getroot(int x) {return fa[x]==x?x:fa[x]=getroot(fa[x]);}
void gaosixiaoyuan(int n)
{
	int i,j,k;
	for (i=1;i&lt;=n;i++)
	{
		for (j=i+1;j&lt;=n;j++)
			while (K[j][i])
			{
				int tmp=K[i][i]/K[j][i];
				for (k=i;k&lt;=n;k++) K[i][k]=(K[i][k]-tmp*K[j][k])%mo;
				for (k=i;k&lt;=n;k++) tmp=K[i][k],K[i][k]=K[j][k],K[j][k]=tmp;
				ans*=-1;
			}
		ans=ans*K[i][i]%mo;
	}
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=m;i++) scanf(&quot;%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
	sort(e+1,e+m+1,cmp);
	for (i=1;i&lt;=n;i++) fa[i]=i;
	for (i=1;i&lt;=m;i++)
	{
		int x=e[i].a,y=e[i].b;
		if (getroot(x)==getroot(y)) continue;
		use[i]=true;
		fa[getroot(x)]=y;
	}
	ans=1;
	for (i=1;i&lt;=m;i=j+1)
	{
		for (j=i;e[j].w==e[i].w;j++);
		j--;
		for (k=1;k&lt;=n;k++) fa[k]=k;
		for (k=1;k&lt;i;k++)
			if (use[k]) fa[getroot(e[k].a)]=e[k].b;
		for (k=j+1;k&lt;=m;k++)
			if (use[k]) fa[getroot(e[k].a)]=e[k].b;
		memset(vt,0,sizeof(vt[0])*(n+10));
		int cnt=0;
		for (k=1;k&lt;=n;k++)
		{
			int x=getroot(k);
			if (!vt[x])
			{
				vt[x]=true;
				pos[x]=++cnt;
				which[cnt]=x;
			}
		}
		memset(K,0,sizeof(K));
		for (k=i;k&lt;=j;k++)
		{
			int x=getroot(e[k].a),y=getroot(e[k].b);
			if (x==y) continue;
			x=pos[x],y=pos[y]; 
			K[x][x]++,K[y][y]++;
			K[x][y]--,K[y][x]--;
		}
		gaosixiaoyuan(cnt-1);
	}
	printf(&quot;%d\n&quot;,(ans%mo+mo)%mo);
}
<pre><h2>Problem1016</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
#define mo 31011
#define NN 110
#define MM 1005
int K[NN][NN],fa[NN],pos[NN],which[NN];
int n,m,i,j,k,x,y,ans;
bool use[MM],vt[NN];
struct edge {int a,b,w;} e[MM];
bool cmp (edge a,edge b) {return a.w&lt;b.w;}
int getroot(int x) {return fa[x]==x?x:fa[x]=getroot(fa[x]);}
void gaosixiaoyuan(int n)
{
	int i,j,k;
	for (i=1;i&lt;=n;i++)
	{
		for (j=i+1;j&lt;=n;j++)
			while (K[j][i])
			{
				int tmp=K[i][i]/K[j][i];
				for (k=i;k&lt;=n;k++) K[i][k]=(K[i][k]-tmp*K[j][k])%mo;
				for (k=i;k&lt;=n;k++) tmp=K[i][k],K[i][k]=K[j][k],K[j][k]=tmp;
				ans*=-1;
			}
		ans=ans*K[i][i]%mo;
	}
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=m;i++) scanf(&quot;%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
	sort(e+1,e+m+1,cmp);
	for (i=1;i&lt;=n;i++) fa[i]=i;
	for (i=1;i&lt;=m;i++)
	{
		int x=e[i].a,y=e[i].b;
		if (getroot(x)==getroot(y)) continue;
		use[i]=true;
		fa[getroot(x)]=y;
	}
	ans=1;
	for (i=1;i&lt;=m;i=j+1)
	{
		for (j=i;e[j].w==e[i].w;j++);
		j--;
		for (k=1;k&lt;=n;k++) fa[k]=k;
		for (k=1;k&lt;i;k++)
			if (use[k]) fa[getroot(e[k].a)]=e[k].b;
		for (k=j+1;k&lt;=m;k++)
			if (use[k]) fa[getroot(e[k].a)]=e[k].b;
		memset(vt,0,sizeof(vt[0])*(n+10));
		int cnt=0;
		for (k=1;k&lt;=n;k++)
		{
			int x=getroot(k);
			if (!vt[x])
			{
				vt[x]=true;
				pos[x]=++cnt;
				which[cnt]=x;
			}
		}
		memset(K,0,sizeof(K));
		for (k=i;k&lt;=j;k++)
		{
			int x=getroot(e[k].a),y=getroot(e[k].b);
			if (x==y) continue;
			x=pos[x],y=pos[y]; 
			K[x][x]++,K[y][y]++;
			K[x][y]--,K[y][x]--;
		}
		gaosixiaoyuan(cnt-1);
	}
	printf(&quot;%d\n&quot;,(ans%mo+mo)%mo);
}
<pre><h2>Problem1016</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
#define mo 31011
#define NN 105
#define MM 1005
int K[NN][NN],fa[NN],pos[NN],which[NN];
int n,m,i,j,k,x,y,ans;
bool use[MM],vt[NN];
struct edge {int a,b,w;} e[MM];
bool cmp (edge a,edge b) {return a.w&lt;b.w;}
int getroot(int x) {return fa[x]==x?x:fa[x]=getroot(fa[x]);}
void gaosixiaoyuan(int n)
{
	int i,j,k;
	for (i=1;i&lt;=n;i++)
	{
		for (j=i+1;j&lt;=n;j++)
			while (K[j][i])
			{
				int tmp=K[i][i]/K[j][i];
				for (k=i;k&lt;=n;k++) K[i][k]=(K[i][k]-tmp*K[j][k])%mo;
				for (k=i;k&lt;=n;k++) tmp=K[i][k],K[i][k]=K[j][k],K[j][k]=tmp;
				ans*=-1;
			}
		ans=ans*K[i][i]%mo;
	}
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=m;i++) scanf(&quot;%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
	sort(e+1,e+m+1,cmp);
	for (i=1;i&lt;=n;i++) fa[i]=i;
	for (i=1;i&lt;=m;i++)
	{
		int x=e[i].a,y=e[i].b;
		if (getroot(x)==getroot(y)) continue;
		use[i]=true;
		fa[getroot(x)]=y;
	}
	ans=1;
	for (i=1;i&lt;=m;i=j+1)
	{
		for (j=i;e[j].w==e[i].w;j++);
		j--;
		for (k=1;k&lt;=n;k++) fa[k]=k;
		for (k=1;k&lt;i;k++)
			if (use[k]) fa[getroot(e[k].a)]=e[k].b;
		for (k=j+1;k&lt;=m;k++)
			if (use[k]) fa[getroot(e[k].a)]=e[k].b;
		memset(vt,0,sizeof(vt[0])*(n+5));
		int cnt=0;
		for (k=1;k&lt;=n;k++)
		{
			int x=getroot(k);
			if (!vt[x])
			{
				vt[x]=true;
				pos[x]=++cnt;
				which[cnt]=x;
			}
		}
		memset(K,0,sizeof(K));
		for (k=i;k&lt;=j;k++)
		{
			int x=getroot(e[k].a),y=getroot(e[k].b);
			if (x==y) continue;
			x=pos[x],y=pos[y]; 
			K[x][x]++,K[y][y]++;
			K[x][y]--,K[y][x]--;
		}
		gaosixiaoyuan(cnt-1);
	}
	printf(&quot;%d\n&quot;,(ans%mo+mo)%mo);
}
<pre><h2>Problem1016</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define mo 31011
#define NN 111
#define MM 1111
int a[NN][NN],fa[NN],pos[NN];
int n,m,ans;
bool vt[NN],use[MM];
struct edge
{
	int a,b,w;
	friend bool operator &lt; (edge x,edge y) {return x.w&lt;y.w;}
} e[MM];
void gause(int (*a)[NN],int n)
{
	int i,j,k,t;
	for (i=1;i&lt;=n;i++)
	{
		for (j=i+1;j&lt;=n;j++)
			while (a[j][i])
			{
				for (k=i;k&lt;=n;k++) swap(a[i][k],a[j][k]);
				t=a[j][i]/a[i][i];
				for (k=i;k&lt;=n;k++) a[j][k]=(a[j][k]-t*a[i][k])%mo;
				ans=-ans;
			}
		ans=ans*a[i][i]%mo;
	}
}
int getfa(int x) {return fa[x]==x?x:fa[x]=getfa(fa[x]);}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,x,y,l,r,cnt;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=m;i++) scanf(&quot;%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
	sort(e+1,e+m+1);
	for (i=1;i&lt;=n;i++) fa[i]=i;
	for (i=1;i&lt;=m;i++)
	{
		x=getfa(e[i].a),y=getfa(e[i].b);
		if (x==y) continue;
		fa[x]=y;
		use[i]=true;
	}
	//for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,use[i]);printf(&quot;\n&quot;);
	ans=1;
	for (l=1;l&lt;=m;l=r+1)
	{
		for (r=l;e[r].w==e[l].w&amp;&amp;r&lt;=m;r++);
		r--;
		for (i=1;i&lt;=n;i++) fa[i]=i,vt[i]=false;
		for (i=1;i&lt;l;i++)
			if (use[i]) fa[getfa(e[i].a)]=e[i].b;
		for (i=r+1;i&lt;=m;i++)
			if (use[i]) fa[getfa(e[i].a)]=e[i].b;
		//for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,getfa(i));printf(&quot;\n&quot;);
		for (i=1;i&lt;=n;i++) vt[getfa(i)]=true;
		for (cnt=0,i=1;i&lt;=n;i++)
			if (vt[i]) pos[i]=++cnt;
		memset(a,0,sizeof(a));
		for (i=l;i&lt;=r;i++)
		{
			x=getfa(e[i].a),y=getfa(e[i].b);
			if (x==y) continue;
			x=pos[x],y=pos[y];
			a[x][x]++,a[y][y]++;
			a[x][y]--,a[y][x]--;
		}
		//for (int i=1;i&lt;=cnt;i++){for (int j=1;j&lt;=cnt;j++)printf(&quot;%d &quot;,a[i][j]);printf(&quot;\n&quot;);}printf(&quot;\n&quot;);
		gause(a,cnt-1);
	}
	printf(&quot;%d\n&quot;,(ans%mo+mo)%mo);
	return 0;
}
<pre><h2>Problem1016</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define mo 31011
#define ln printf(&quot;\n&quot;)
const int NN=105,MM=1005;
int n,m,a[NN][NN],fa[NN],pos[NN];
bool use[MM],vt[NN];
struct edge
{
	int u,v,w;
	void in() {scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);}
	friend bool operator &lt;(edge a,edge b) {return a.w&lt;b.w;}
} e[MM];
int gause(int n)
{
	int res=1;
	for (int i=1;i&lt;=n;i++)
	{
		for (int j=i+1;j&lt;=n;j++) while (a[j][i])
		{
			int t=a[i][i]/a[j][i];
			for (int k=i;k&lt;=n;k++) a[i][k]=(a[i][k]-t*a[j][k])%mo;
			for (int k=i;k&lt;=n;k++) swap(a[i][k],a[j][k]);
			res=-res;
		}
		res=res*a[i][i]%mo;
	}
	return res;
}
int getfa(int x) {return fa[x]==x?x:fa[x]=getfa(fa[x]);}
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i;
	for (i=1;i&lt;=m;i++) e[i].in();
	sort(e+1,e+m+1);
	for (i=1;i&lt;=n;i++) fa[i]=i;
	for (i=1;i&lt;=m;i++)
	{
		int x=getfa(e[i].u),y=getfa(e[i].v);
		if (x==y) continue;
		use[i]=true;
		fa[x]=y;
	}
	int ans=1,l,r;
	for (l=1;l&lt;=m;l=r+1)
	{
		for (r=l;r&lt;=m&amp;&amp;e[r].w==e[l].w;r++);r--;
		for (i=1;i&lt;=n;i++) fa[i]=i;
		for (i=1;i&lt;l;i++)
			if (use[i]) fa[getfa(e[i].u)]=e[i].v;
		for (i=m;i&gt;r;i--)
			if (use[i]) fa[getfa(e[i].u)]=e[i].v;
		memset(vt,0,sizeof(vt));
		for (i=1;i&lt;=n;i++) vt[getfa(i)]=true;
		int cnt=0;
		for (i=1;i&lt;=n;i++) if (vt[i]) pos[i]=++cnt;
		memset(a,0,sizeof(a));
		for (i=l;i&lt;=r;i++)
		{
			int x=getfa(e[i].u),y=getfa(e[i].v);
			if (x==y) continue;
			x=pos[x],y=pos[y];
			a[x][x]++,a[y][y]++;
			a[x][y]--,a[y][x]--;
		}
		ans=ans*gause(cnt-1)%mo;
	}
	printf(&quot;%d\n&quot;,(ans%mo+mo)%mo);
	return 0;
}<pre><h2>Problem1017</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 999999999
const int NN=55;
int f[NN][105][2005],g[NN][105][2005],o[NN],w[NN],limit[NN],cost[NN],aa[NN][3];
int n,m,tot=1,ans;
bool vt[NN];
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dp(int v)
{
	//printf(&quot;dp %d\n&quot;,v);
	vt[v]=true;
	int i,j,k,l;
	if (o[v]==0)
	{
		limit[v]=min(limit[v],m/cost[v]);
		for (j=0;j&lt;=limit[v];j++)
			for (k=j;k&lt;=limit[v];k++)
				f[v][j][k*cost[v]]=(k-j)*w[v];
		return;
	}
	limit[v]=inf;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		dp(y);
		limit[v]=min(limit[v],limit[y]/aa[p][2]);
	}
	memset(g,128,sizeof(g));
	//printf(&quot;limit[%d]=%d\n&quot;,v,limit[v]);
	for (j=0;j&lt;=limit[v];j++) g[0][j][0]=0;
	i=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1],need=aa[p][2];
		//printf(&quot;y=%d\n&quot;,y);
		i++;
		for (j=0;j&lt;=limit[v];j++)
			for (k=0;k&lt;=m;k++)
				for (l=0;l&lt;=k;l++)
					if (g[i-1][j][k-l]&gt;=0&amp;&amp;f[y][j*need][l]&gt;=0)
						g[i][j][k]=max(g[i][j][k],g[i-1][j][k-l]+f[y][j*need][l]);
	}
	for (j=0;j&lt;=limit[v];j++)
		for (k=0;k&lt;=m;k++)
			for (l=j;l&lt;=limit[v];l++)
				if (g[i][l][k]&gt;=0)
				{
					f[v][j][k]=max(f[v][j][k],g[i][l][k]+(l-j)*w[v]);
					ans=max(ans,f[v][j][k]);
				}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z,j;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;w[i]);
		char ch=getchar();ch=getchar();
		//printf(&quot;ch=%c\n&quot;,ch);
		if (ch=='A')
		{
			scanf(&quot;%d&quot;,&amp;x);
			for (j=1;j&lt;=x;j++)
			{
				scanf(&quot;%d%d&quot;,&amp;y,&amp;z);
				addedge(i,y,z);
			}
		}
		else scanf(&quot;%d%d&quot;,&amp;cost[i],&amp;limit[i]);
	}
	memset(f,128,sizeof(f));
	for (i=1;i&lt;=n;i++) if (!vt[i]) dp(i);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1017</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 999999999
const int NN=55;
int f[NN][105][2005],g[NN][105][2005],o[NN],w[NN],limit[NN],cost[NN],aa[NN][3];
int n,m,tot=1,ans;
bool vt[NN];
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dp(int v)
{
	//printf(&quot;dp %d\n&quot;,v);
	vt[v]=true;
	int i,j,k,l;
	if (o[v]==0)
	{
		limit[v]=min(limit[v],m/cost[v]);
		for (j=0;j&lt;=limit[v];j++)
			for (k=0;k&lt;=m;k++)
				for (l=j;l&lt;=limit[v];l++)
					if (l*cost[v]&lt;=k)
					{
						f[v][j][k]=(l-j)*w[v];
						ans=max(ans,f[v][j][k]);
					}
		return;
	}
	limit[v]=inf;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		dp(y);
		limit[v]=min(limit[v],limit[y]/aa[p][2]);
	}
	memset(g,128,sizeof(g));
	//printf(&quot;limit[%d]=%d\n&quot;,v,limit[v]);
	for (j=0;j&lt;=limit[v];j++) g[0][j][0]=0;
	i=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1],need=aa[p][2];
		//printf(&quot;y=%d\n&quot;,y);
		i++;
		for (j=0;j&lt;=limit[v];j++)
			for (k=0;k&lt;=m;k++)
				for (l=0;l&lt;=k;l++)
					if (g[i-1][j][k-l]&gt;=0&amp;&amp;f[y][j*need][l]&gt;=0)
						g[i][j][k]=max(g[i][j][k],g[i-1][j][k-l]+f[y][j*need][l]);
	}
	for (j=0;j&lt;=limit[v];j++)
		for (k=0;k&lt;=m;k++)
			for (l=j;l&lt;=limit[v];l++)
				if (g[i][l][k]&gt;=0)
				{
					f[v][j][k]=max(f[v][j][k],g[i][l][k]+(l-j)*w[v]);
					ans=max(ans,f[v][j][k]);
				}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z,j;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;w[i]);
		char ch=getchar();ch=getchar();
		//printf(&quot;ch=%c\n&quot;,ch);
		if (ch=='A')
		{
			scanf(&quot;%d&quot;,&amp;x);
			for (j=1;j&lt;=x;j++)
			{
				scanf(&quot;%d%d&quot;,&amp;y,&amp;z);
				addedge(i,y,z);
			}
		}
		else scanf(&quot;%d%d&quot;,&amp;cost[i],&amp;limit[i]);
	}
	memset(f,128,sizeof(f));
	for (i=1;i&lt;=n;i++) if (!vt[i]) dp(i);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1017</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 999999999
const int NN=55;
int f[NN][105][2005],g[105][2005],o[NN],w[NN],limit[NN],cost[NN],aa[NN][3];
int n,m,tot=1,ans;
bool vt[NN];
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dp(int v)
{
	vt[v]=true;
	int i,j,k,l;
	if (o[v]==0)
	{
		limit[v]=min(limit[v],m/cost[v]);
		for (j=0;j&lt;=limit[v];j++)
			for (k=0;k&lt;=m;k++)
				for (l=j;l&lt;=limit[v];l++)
					if (l*cost[v]&lt;=k)
					{
						f[v][j][k]=(l-j)*w[v];
						ans=max(ans,f[v][j][k]);
					}
		return;
	}
	limit[v]=inf;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		dp(y);
		limit[v]=min(limit[v],limit[y]/aa[p][2]);
	}
	memset(g,128,sizeof(g));
	for (j=0;j&lt;=limit[v];j++)
		for (k=0;k&lt;=m;k++) g[j][k]=0;
	i=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1],need=aa[p][2];
		i++;
		for (j=0;j&lt;=limit[v];j++)
			for (k=m;k&gt;=0;k--)
			{
				if (f[y][j][0]&gt;=0) g[j][k]=g[j][k]+f[y][j][0];
				else g[j][k]=-inf;
				for (l=1;l&lt;=k;l++)
					if (g[j][k-l]&gt;=0&amp;&amp;f[y][j*need][l]&gt;=0)
						g[j][k]=max(g[j][k],g[j][k-l]+f[y][j*need][l]);
			}
	}
	for (j=0;j&lt;=limit[v];j++)
		for (k=0;k&lt;=m;k++)
			for (l=j;l&lt;=limit[v];l++)
				if (g[l][k]&gt;=0)
				{
					f[v][j][k]=max(f[v][j][k],g[l][k]+(l-j)*w[v]);
					ans=max(ans,f[v][j][k]);
				}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z,j;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;w[i]);
		char ch=getchar();ch=getchar();
		if (ch=='A')
		{
			scanf(&quot;%d&quot;,&amp;x);
			for (j=1;j&lt;=x;j++)
			{
				scanf(&quot;%d%d&quot;,&amp;y,&amp;z);
				addedge(i,y,z);
			}
		}
		else scanf(&quot;%d%d&quot;,&amp;cost[i],&amp;limit[i]);
	}
	memset(f,128,sizeof(f));
	for (i=1;i&lt;=n;i++) if (!vt[i]) dp(i);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1018</h2><pre>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;

#define N 111111

using namespace std;

struct DAT
{
    bool v[2],s[2],x[2];
    void prt() {printf(&quot;s:%d      %d\nx:%d      %d\nv:%d      %d\n\n&quot;,s[0],s[1],x[0],x[1],v[0],v[1]);}
}dat[N&lt;&lt;2];

bool a[N][2][2];
int n,r1,r2,c1,c2;
int dx[3]={-1,0,1};
int dy[3]={0,1,0};

inline void build(int u,int l,int r)
{
    if(l==r) {dat[u].s[0]=dat[u].s[1]=true;return;}
    int mid=(l+r)&gt;&gt;1;
    build(u&lt;&lt;1,l,mid); build(u&lt;&lt;1|1,mid+1,r);
}

inline void pack(DAT &amp;u,DAT &amp;ls,DAT &amp;rs,int mid)
{
    u.x[0]=ls.x[0]||(ls.s[0]&amp;&amp;a[mid][0][0]&amp;&amp;rs.x[0]&amp;&amp;a[mid][1][0]&amp;&amp;ls.s[1]);//左上-右上 
    u.x[1]=rs.x[1]||(rs.s[0]&amp;&amp;a[mid][0][0]&amp;&amp;ls.x[1]&amp;&amp;a[mid][1][0]&amp;&amp;rs.s[1]);//左下-右下 
    u.s[0]=(ls.s[0]&amp;&amp;a[mid][0][0]&amp;&amp;rs.s[0])||(ls.v[0]&amp;&amp;a[mid][1][0]&amp;&amp;rs.v[1]);//左上-左下
    u.s[1]=(ls.s[1]&amp;&amp;a[mid][1][0]&amp;&amp;rs.s[1])||(ls.v[1]&amp;&amp;a[mid][0][0]&amp;&amp;rs.v[0]);//右上-右下
    u.v[0]=(ls.s[0]&amp;&amp;a[mid][0][0]&amp;&amp;rs.v[0])||(ls.v[0]&amp;&amp;a[mid][1][0]&amp;&amp;rs.s[1]);//左上-右下
    u.v[1]=(ls.s[1]&amp;&amp;a[mid][1][0]&amp;&amp;rs.v[1])||(ls.v[1]&amp;&amp;a[mid][0][0]&amp;&amp;rs.s[0]);//右上-左下 
}

inline void updata(int u,int l,int r,int p)
{
    if(l==r)
    {
        dat[u].x[0]=dat[u].x[1]=dat[u].v[1]=dat[u].v[0]=a[p][0][1];
        dat[u].s[0]=dat[u].s[1]=true;
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    if(p&lt;=mid) updata(u&lt;&lt;1,l,mid,p);
    else updata(u&lt;&lt;1|1,mid+1,r,p);
    pack(dat[u],dat[u&lt;&lt;1],dat[u&lt;&lt;1|1],mid);
}

inline void change(bool pd)
{
    if(r1&gt;r2) swap(r1,r2),swap(c1,c2);
    int dir;
    for(int i=0;i&lt;3;i++)
        if(c1+dx[i]==c2&amp;&amp;r1+dy[i]==r2) dir=i;
    if(dir==0) a[c2][r2][0]=pd,updata(1,1,n,c2);
    else if(dir==1) a[c1][0][1]=pd,updata(1,1,n,c1);
    else a[c1][r1][0]=pd,updata(1,1,n,c1);
}

inline void getpack(DAT &amp;p,int u,int L,int R,int l,int r)
{
    if(l&lt;=L&amp;&amp;r&gt;=R) {p=dat[u];return;}
    int MID=(L+R)&gt;&gt;1;
    if(r&lt;=MID) getpack(p,u&lt;&lt;1,L,MID,l,r);
    else if(l&gt;=MID+1) getpack(p,u&lt;&lt;1|1,MID+1,R,l,r);
    else
    {
        DAT tmp1,tmp2;
        getpack(tmp1,u&lt;&lt;1,L,MID,l,MID);
        getpack(tmp2,u&lt;&lt;1|1,MID+1,R,MID+1,r);
        pack(p,tmp1,tmp2,MID);
    }
}

inline void getans()
{
    if(c1&gt;c2) swap(c1,c2),swap(r1,r2);
    DAT pa,pb,pc;
    getpack(pa,1,1,n,1,c1);
    getpack(pb,1,1,n,c1,c2);
    getpack(pc,1,1,n,c2,n);
    if(r1==r2)
    {
        if(r1==0)
        {
            if(pb.s[0]||(pa.x[1]&amp;&amp;pb.v[1])||(pc.x[0]&amp;&amp;pb.v[0])||(pa.x[1]&amp;&amp;pb.s[1]&amp;&amp;pc.x[0])) puts(&quot;Y&quot;);
            else puts(&quot;N&quot;);
        }
        else
        {
            if(pb.s[1]||(pa.x[1]&amp;&amp;pb.v[0])||(pc.x[0]&amp;&amp;pb.v[1])||(pa.x[1]&amp;&amp;pb.s[0]&amp;&amp;pc.x[0])) puts(&quot;Y&quot;);
            else puts(&quot;N&quot;);
        }
    }
    else
    {
        if(r1==0)
        {
            if(pb.v[0]||(pa.x[1]&amp;&amp;pb.s[1])||(pc.x[0]&amp;&amp;pb.s[0])) puts(&quot;Y&quot;);
            else puts(&quot;N&quot;);
        }
        else
        {
            if(pb.v[1]||(pa.x[1]&amp;&amp;pb.s[0])||(pc.x[0]&amp;&amp;pb.s[1])) puts(&quot;Y&quot;);
            else puts(&quot;N&quot;);
        }
    }
}

inline void go()
{
    char str[10];
    scanf(&quot;%d&quot;,&amp;n);
    build(1,1,n);
    while(scanf(&quot;%s&quot;,str))
    {
        if(str[0]=='E') break;
        scanf(&quot;%d%d%d%d&quot;,&amp;r1,&amp;c1,&amp;r2,&amp;c2);
        r1--; r2--;
        if(str[0]=='O') change(1);
        else if(str[0]=='C') change(0);
        else getans();
    }
}

int main()
{
    go();
    return 0;
}<pre><h2>Problem1019</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
int n;
LL f[33][3],g[33][3];
bool vt[101];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d\n&quot;,&amp;n);
	int i;
	for (i=1;i&lt;=6;i++)
	{
		char s[3];
		scanf(&quot;%s&quot;,s+1);
		int x=s[1]-'A',y=s[2]-'A';
		if (vt[x]) continue;
		vt[x]=true;
		g[1][x]=y,f[1][x]=1;
	}
	for (i=2;i&lt;=n;i++) for (int x=0;x&lt;3;x++)
	{
		int y=g[i-1][x];
		int z=3-x-y;
		if (g[i-1][y]==z)
		{
			g[i][x]=z;
			f[i][x]=f[i-1][x]+1+f[i-1][y];
		}
		else
		{
			g[i][x]=y;
			f[i][x]=f[i-1][x]+1+f[i-1][y]+1+f[i-1][x];
		}
	}
	printf(&quot;%lld\n&quot;,f[n][0]);
	return 0;
}<pre><h2>Problem1020</h2><pre>#include&lt;cstdio&gt; 
#include&lt;cstdlib&gt; 
#include&lt;cstring&gt; 
#include&lt;cmath&gt; 
#include&lt;algorithm&gt; 
#define eps 1e-5
#define MAXN 30 
#define MAXM 40 
#define MAXQ 1000000 
using namespace std; 
int dcmp(double p) 
{ 
    if(fabs(p)&lt;eps)  return 0; 
    return p&gt;eps?1:-1; 
} 
int n,m; 
double ans; 
struct Point 
{ 
    double x,y; 
    Point() {} 
    Point(double x,double y): x(x),y(y) {} 
    friend Point operator + (const Point &amp;a,const Point &amp;b){  return Point(a.x+b.x,a.y+b.y);  } 
    friend Point operator - (const Point &amp;a,const Point &amp;b){  return Point(a.x-b.x,a.y-b.y);  } 
    friend Point operator * (const Point &amp;a,double p){  return Point(a.x*p,a.y*p);  } 
    friend Point operator / (const Point &amp;a,double p){  return Point(a.x/p,a.y/p);  } 
    friend bool operator == (const Point &amp;a,const Point &amp;b){  return !dcmp(a.x-b.x)&amp;&amp;!dcmp(a.y-b.y);  } 
    void Read(){  scanf(&quot;%lf %lf&quot;,&amp;x,&amp;y);  } 
}temp[MAXN]; 
typedef Point Vector; 
double Dot(const Vector &amp;a,const Vector &amp;b){  return a.x*b.x+a.y*b.y;  } 
double Len(const Vector &amp;a){  return sqrt(Dot(a,a));  } 
double Cross(const Vector &amp;a,const Vector &amp;b){  return a.x*b.y-a.y*b.x;  } 
Vector Normal(const Vector &amp;a){  return Vector(-a.y,a.x);  } 
bool On(const Point &amp;a,const Point &amp;b,const Point &amp;c)
{  return !dcmp(Cross(b-a,c-a))&amp;&amp;dcmp((a.x-b.x)*(a.x-c.x))&lt;=0&amp;&amp;dcmp((a.y-b.y)*(a.y-c.y))&lt;=0;  } 
bool inter(const Point &amp;a,const Point &amp;b,const Point &amp;c,const Point &amp;d)
{  return dcmp(Cross(c-a,b-a)*Cross(d-a,b-a))&lt;=0&amp;&amp;dcmp(Cross(a-c,d-c)*Cross(b-c,d-c))&lt;=0;  } 
Point getinter(const Point &amp;a,const Vector &amp;b,const Point &amp;c,const Vector &amp;d) 
{ 
    Vector u=a-c; 
    double t=Cross(d,u)/Cross(b,d); 
    return a+b*t; 
} 
struct Seg 
{ 
    Point a,b; 
    Seg() {} 
    Seg(const Point &amp;a,const Point &amp;b): a(a),b(b) {} 
}queue[1000010]; 
struct Polygon 
{ 
    Point p[MAXM]; 
    int tot; 
    bool In(Point &amp;point) 
    { 
        int total=0; 
        for(int i=1;i&lt;=tot;i++) 
            if(On(point,p[i],p[i%tot+1])) 
                return true; 
        Point Ray=Point(-10001,point.y+0.1); 
        point.y+=0.1; 
        for(int i=1;i&lt;=tot;i++) 
            total=total+inter(Ray,point,p[i],p[i%tot+1]); 
        point.y-=0.1; 
        return total&amp;1; 
    } 
}island[MAXN]; 
struct near 
{ 
    Point P; 
    double dis; 
    near() {} 
    near(const Point &amp;a,double b): P(a),dis(b) {} 
}; 
near DISPS(const Point &amp;a,const Point &amp;b,const Point &amp;c) 
{ 
    if(b==c)  return near(b,Len(b-a)); 
    Vector v1=c-b,v2=a-b,v3=a-c; 
    if(dcmp(Dot(v1,v2))&lt;=0)  return near(b,Len(v2)); 
    if(dcmp(Dot(v1,v3))&gt;=0)  return near(c,Len(v3)); 
    Vector v=Normal(b-c); 
    Point ans=getinter(a,v,b,v1); 
    return near(ans,Len(a-ans)); 
} 
bool check(Point &amp;p) 
{ 
    for(int i=1;i&lt;=n;i++) 
        if(island[i].In(p)) 
            return true; 
    return false; 
} 
near Find(Point &amp;p) 
{ 
    if(check(p))  return near(p,0); 
    near ans1; 
    ans1.dis=1&lt;&lt;30; 
    for(int i=1;i&lt;=n;i++) 
        for(int j=1;j&lt;=island[i].tot;j++) 
        { 
            near get=DISPS(p,island[i].p[j],island[i].p[j%island[i].tot+1]); 
            if(dcmp(ans1.dis-get.dis)&gt;=0)  ans1=get; 
        } 
    ans=max(ans,ans1.dis); 
    return ans1; 
} 
void read() 
{ 
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m); 
    for(int i=1;i&lt;=m;i++) temp[i].Read(); 
    for(int i=1;i&lt;=n;i++) 
    { 
        scanf(&quot;%d&quot;,&amp;island[i].tot); 
        for(int j=1;j&lt;=island[i].tot;j++) 
            island[i].p[j].Read(); 
    } 
} 
void search() 
{ 
    int front=0,rear=0; 
    for(int i=1;i&lt;m;i++) 
        queue[++rear]=Seg(temp[i],temp[i+1]); 
    Seg head; 
    while(front!=rear) 
    { 
        head=queue[front=front%MAXQ+1]; 
        Point p1=Find(head.a).P,p2=Find(head.b).P,l=head.a,r=head.b,mid=(l+r)/2; 
        while(!(l==r)) 
        { 
            Point mid=(r+l)/2; 
            if(Len(mid-p1)&lt;Len(mid-p2))  l=mid; 
            else r=mid; 
        } 
        double nowans=Len(l-p1);
        if(nowans-ans&gt;eps) queue[rear=rear%MAXQ+1]=Seg(head.a,mid),queue[rear=rear%MAXQ+1]=Seg(mid,head.b); 
    } 
} 
int main() 
{ 
    read(); 
    search(); 
    printf(&quot;%.2lf\n&quot;,ans); 
    return 0; 
}<pre><h2>Problem1022</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int tc,n,ans,i,x;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tc);tc;tc--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		bool flag=false;
		for (ans=0,i=1;i&lt;=n;i++)
		{
			scanf(&quot;%d&quot;,&amp;x),ans^=x;
			if (x&gt;1) flag=true;
		}
		if ((ans&gt;0&amp;&amp;flag)||(ans==0&amp;&amp;!flag)) printf(&quot;John\n&quot;);
		else printf(&quot;Brother\n&quot;);
	}
	return 0;
}<pre><h2>Problem1022</h2><pre>#include&lt;stdio.h&gt;
int tc,n,ans,i,x;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tc);tc;tc--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		int flag=0;
		for (ans=0,i=1;i&lt;=n;i++)
		{
			scanf(&quot;%d&quot;,&amp;x),ans^=x;
			if (x&gt;1) flag=1;
		}
		if ((ans&gt;0&amp;&amp;flag)||(ans==0&amp;&amp;!flag)) printf(&quot;John\n&quot;);
		else printf(&quot;Brother\n&quot;);
	}
	return 0;
}<pre><h2>Problem1022</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int tes;
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		int ans=0,x,n;
		scanf(&quot;%d&quot;,&amp;n);
		bool flag=false;
		for (int i=1;i&lt;=n;i++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			ans^=x;
			if (x&gt;1) flag=true;
		}
		if ((ans==0&amp;&amp;!flag)||(ans&gt;0&amp;&amp;flag)) printf(&quot;John\n&quot;);
		else printf(&quot;Brother\n&quot;);
	}
	return 0;
}
<pre><h2>Problem1022</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int main()
{
	int tes;
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		int ans=0,x,n;
		scanf(&quot;%d&quot;,&amp;n);
		bool flag=false;
		for (int i=1;i&lt;=n;i++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			ans^=x;
			if (x&gt;1) flag=true;
		}
		if ((ans==0&amp;&amp;!flag)||(ans&gt;0&amp;&amp;flag)) printf(&quot;John\n&quot;);
		else printf(&quot;Brother\n&quot;);
	}
	return 0;
}
<pre><h2>Problem1022</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int tes,n;
int main()
{
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		int xorsum=0,i,x;
		bool flag=false;
		for (i=1;i&lt;=n;i++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			xorsum^=x;
			if (x&gt;1) flag=true;
		}
		if ((xorsum==0&amp;&amp;!flag)||(xorsum!=0&amp;&amp;flag)) printf(&quot;John\n&quot;);
		else printf(&quot;Brother\n&quot;);
	}
	return 0;
}<pre><h2>Problem1022</h2><pre>import java.util.*;

public class Main{
	public static void main(String[] srgs){
		Scanner cin=new Scanner(System.in);
		int tes=cin.nextInt();
		for (;tes&gt;0;tes--){
			int n=cin.nextInt();
			int xorsum=0,i,x;
			boolean flag=false;
			for (i=1;i&lt;=n;i++){
				x=cin.nextInt();
				xorsum^=x;
				if (x&gt;1) flag=true;
			}
			if ((xorsum==0&amp;&amp;!flag)||(xorsum!=0&amp;&amp;flag)) System.out.println(&quot;John\r&quot;);
			else System.out.println(&quot;Brother\r&quot;);
		}
	}
}<pre><h2>Problem1023</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define NN 510000
int dfn[NN],low[NN],aa[NN*2][2],o[NN],fa[NN],from[NN],b[NN],f[NN];
int n,tot=1,ans,TIME,m;
struct ppt {int w,id;} q[NN];
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int min(int a,int b) {return a&lt;b?a:b;}
int max(int a,int b) {return a&gt;b?a:b;}
void dp_on_circle()
{
	int head=0,tail=1,i;
	for (i=1;i&lt;b[0];i++) b[i+b[0]]=b[i];
	q[1].id=1,q[1].w=f[b[1]]-1;
	for (i=2;i&lt;b[0]*2;i++)
	{
		while (head&lt;tail&amp;&amp;i-q[head+1].id&gt;b[0]/2) head++;
		ans=max(ans,q[head+1].w+i+f[b[i]]);
		while (head&lt;tail&amp;&amp;f[b[i]]-i&gt;q[tail].w) tail--;
		tail++;
		q[tail].w=f[b[i]]-i,q[tail].id=i;
	}
}
void dfs(int v)
{
	dfn[v]=low[v]=++TIME;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (p==(from[v]^1)) continue;
		if (dfn[y]) low[v]=min(low[v],dfn[y]);
		else
		{
			from[y]=p;
			fa[y]=v;
			dfs(y);
			low[v]=min(low[v],low[y]);
		}
	}
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (p==(from[v]^1)) continue;
		if (p==from[y]&amp;&amp;low[y]&gt;dfn[v])
		{
			ans=max(ans,f[v]+f[y]+1);
			f[v]=max(f[v],f[y]+1);
		}
		if (p!=from[y]&amp;&amp;dfn[v]&lt;dfn[y])
		{
			b[0]=0;
			for (int x=y;x!=fa[v];x=fa[x]) b[++b[0]]=x;
			dp_on_circle();
			for (int i=1;i&lt;b[0];i++) f[v]=max(f[v],f[b[i]]+min(i,b[0]-i));
		}
	}
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,k,last,j,x;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;k);
		scanf(&quot;%d&quot;,&amp;last);
		for (j=2;j&lt;=k;j++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			addedge(last,x);
			addedge(x,last);
			last=x;
		}
	}
	dfs(1);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1023</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define NN 51000*2
int dfn[NN],low[NN],aa[NN*2][2],o[NN],fa[NN],from[NN],b[NN],f[NN];
int n,tot=1,ans,TIME,m;
struct ppt {int w,id;} q[NN];
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int min(int a,int b) {return a&lt;b?a:b;}
int max(int a,int b) {return a&gt;b?a:b;}
void dp_on_circle()
{
	int head=0,tail=1,i;
	for (i=1;i&lt;b[0];i++) b[i+b[0]]=b[i];
	q[1].id=1,q[1].w=f[b[1]]-1;
	for (i=2;i&lt;b[0]*2;i++)
	{
		while (head&lt;tail&amp;&amp;i-q[head+1].id&gt;b[0]/2) head++;
		ans=max(ans,q[head+1].w+i+f[b[i]]);
		while (head&lt;tail&amp;&amp;f[b[i]]-i&gt;q[tail].w) tail--;
		tail++;
		q[tail].w=f[b[i]]-i,q[tail].id=i;
	}
}
void dfs(int v)
{
	dfn[v]=low[v]=++TIME;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (p==(from[v]^1)) continue;
		if (dfn[y]) low[v]=min(low[v],dfn[y]);
		else
		{
			from[y]=p;
			fa[y]=v;
			dfs(y);
			low[v]=min(low[v],low[y]);
		}
	}
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (p==(from[v]^1)) continue;
		if (p==from[y]&amp;&amp;low[y]&gt;dfn[v])
		{
			ans=max(ans,f[v]+f[y]+1);
			f[v]=max(f[v],f[y]+1);
		}
		if (p!=from[y]&amp;&amp;dfn[v]&lt;dfn[y])
		{
			b[0]=0;
			for (int x=y;x!=fa[v];x=fa[x]) b[++b[0]]=x;
			dp_on_circle();
			for (int i=1;i&lt;b[0];i++) f[v]=max(f[v],f[b[i]]+min(i,b[0]-i));
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,k,last,j,x;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;k);
		scanf(&quot;%d&quot;,&amp;last);
		for (j=2;j&lt;=k;j++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			addedge(last,x);
			addedge(x,last);
			last=x;
		}
	}
	dfs(1);
	//for (int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,f[i]);printf(&quot;\n&quot;);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1023</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define NN 51000
int dfn[NN],low[NN],aa[10000000][2],o[NN],fa[NN],from[NN],b[NN*2],f[NN];
int n,tot=1,ans,TIME,m;
struct ppt {int w,id;} q[NN*2];
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int min(int a,int b) {return a&lt;b?a:b;}
int max(int a,int b) {return a&gt;b?a:b;}
void dp_on_circle()
{
	int head=0,tail=1,i;
	for (i=1;i&lt;b[0];i++) b[i+b[0]]=b[i];
	q[1].id=1,q[1].w=f[b[1]]-1;
	for (i=2;i&lt;b[0]*2;i++)
	{
		while (head&lt;tail&amp;&amp;i-q[head+1].id&gt;b[0]/2) head++;
		ans=max(ans,q[head+1].w+i+f[b[i]]);
		while (head&lt;tail&amp;&amp;f[b[i]]-i&gt;q[tail].w) tail--;
		tail++;
		q[tail].w=f[b[i]]-i,q[tail].id=i;
	}
}
void dfs(int v)
{
	dfn[v]=low[v]=++TIME;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (p==(from[v]^1)) continue;
		if (dfn[y]) low[v]=min(low[v],dfn[y]);
		else
		{
			from[y]=p;
			fa[y]=v;
			dfs(y);
			low[v]=min(low[v],low[y]);
		}
	}
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (p==(from[v]^1)) continue;
		if (p==from[y]&amp;&amp;low[y]&gt;dfn[v])
		{
			ans=max(ans,f[v]+f[y]+1);
			f[v]=max(f[v],f[y]+1);
		}
		if (p!=from[y]&amp;&amp;dfn[v]&lt;dfn[y])
		{
			b[0]=0;
			for (int x=y;x!=fa[v];x=fa[x]) b[++b[0]]=x;
			dp_on_circle();
			for (int i=1;i&lt;b[0];i++) f[v]=max(f[v],f[b[i]]+min(i,b[0]-i));
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,k,last,j,x;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;k);
		scanf(&quot;%d&quot;,&amp;last);
		for (j=2;j&lt;=k;j++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			addedge(last,x);
			addedge(x,last);
			last=x;
		}
	}
	dfs(1);
	//for (int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,f[i]);printf(&quot;\n&quot;);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1023</h2><pre>#include&lt;cstdio&gt;

using namespace std;

#define NN 51000

int dfn[NN],low[NN],aa[10000000][2],o[NN],fa[NN],from[NN],b[NN*2],f[NN];

int n,tot=1,ans,TIME,m;

struct ppt {int w,id;} q[NN*2];

void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}

int min(int a,int b) {return a&lt;b?a:b;}

int max(int a,int b) {return a&gt;b?a:b;}

void dp_on_circle()

{

	int head=0,tail=1,i;

	for (i=1;i&lt;b[0];i++) b[i+b[0]]=b[i];

	q[1].id=1,q[1].w=f[b[1]]-1;

	for (i=2;i&lt;b[0]*2;i++)

	{

		while (head&lt;tail&amp;&amp;i-q[head+1].id&gt;b[0]/2) head++;

		ans=max(ans,q[head+1].w+i+f[b[i]]);

		while (head&lt;tail&amp;&amp;f[b[i]]-i&gt;q[tail].w) tail--;

		tail++;

		q[tail].w=f[b[i]]-i,q[tail].id=i;

	}

}

void dfs(int v)

{

	dfn[v]=low[v]=++TIME;

	for (int p=o[v];p;p=aa[p][0])

	{

		int y=aa[p][1];

		if (p==(from[v]^1)) continue;

		if (dfn[y]) low[v]=min(low[v],dfn[y]);

		else

		{

			from[y]=p;

			fa[y]=v;

			dfs(y);

			low[v]=min(low[v],low[y]);

		}

	}

	for (int p=o[v];p;p=aa[p][0])

	{

		int y=aa[p][1];

		if (p==(from[v]^1)) continue;

		if (p==from[y]&amp;&amp;low[y]&gt;dfn[v])

		{

			ans=max(ans,f[v]+f[y]+1);

			f[v]=max(f[v],f[y]+1);

		}

		if (p!=from[y]&amp;&amp;dfn[v]&lt;dfn[y])

		{

			b[0]=0;

			for (int x=y;x!=fa[v];x=fa[x]) b[++b[0]]=x;

			dp_on_circle();

			for (int i=1;i&lt;b[0];i++) f[v]=max(f[v],f[b[i]]+min(i,b[0]-i));

		}

	}

}

int main()

{

//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);

	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);

	int i,k,last,j,x;

	for (i=1;i&lt;=m;i++)

	{

		scanf(&quot;%d&quot;,&amp;k);

		scanf(&quot;%d&quot;,&amp;last);

		for (j=2;j&lt;=k;j++)

		{

			scanf(&quot;%d&quot;,&amp;x);

			addedge(last,x);

			addedge(x,last);

			last=x;

		}

	}

	dfs(1);

	//for (int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,f[i]);printf(&quot;\n&quot;);

	printf(&quot;%d\n&quot;,ans);

	return 0;

}<pre><h2>Problem1023</h2><pre>#include&lt;cstdio&gt;

using namespace std;

#define NN 51000

int dfn[NN],low[NN],aa[10000000][2],o[NN],fa[NN],from[NN],b[NN*2],f[NN];

int n,tot=1,ans,TIME,m;

struct ppt {int w,id;} q[NN*2];

void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}

int min(int a,int b) {return a&lt;b?a:b;}

int max(int a,int b) {return a&gt;b?a:b;}

void dp_on_circle()

{

	int head=0,tail=1,i;

	for (i=1;i&lt;b[0];i++) b[i+b[0]]=b[i];

	q[1].id=1,q[1].w=f[b[1]]-1;

	for (i=2;i&lt;b[0]*2;i++)

	{

		while (head&lt;tail&amp;&amp;i-q[head+1].id&gt;b[0]/2) head++;

		ans=max(ans,q[head+1].w+i+f[b[i]]);

		while (head&lt;tail&amp;&amp;f[b[i]]-i&gt;q[tail].w) tail--;

		tail++;

		q[tail].w=f[b[i]]-i,q[tail].id=i;

	}

}

void dfs(int v)

{

	dfn[v]=low[v]=++TIME;

	for (int p=o[v];p;p=aa[p][0])

	{

		int y=aa[p][1];

		if (p==(from[v]^1)) continue;

		if (dfn[y]) low[v]=min(low[v],dfn[y]);

		else

		{

			from[y]=p;

			fa[y]=v;

			dfs(y);

			low[v]=min(low[v],low[y]);

		}

	}

	for (int p=o[v];p;p=aa[p][0])

	{

		int y=aa[p][1];

		//if (p==(from[v]^1)) continue;

		if (p==from[y]&amp;&amp;low[y]&gt;dfn[v])

		{

			ans=max(ans,f[v]+f[y]+1);

			f[v]=max(f[v],f[y]+1);

		}

		if (p!=from[y]&amp;&amp;dfn[v]&lt;dfn[y])

		{

			b[0]=0;

			for (int x=y;x!=fa[v];x=fa[x]) b[++b[0]]=x;

			dp_on_circle();

			for (int i=1;i&lt;b[0];i++) f[v]=max(f[v],f[b[i]]+min(i,b[0]-i));

		}

	}

}

int main()

{

	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);

	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);

	int i,k,last,j,x;

	for (i=1;i&lt;=m;i++)

	{

		scanf(&quot;%d&quot;,&amp;k);

		scanf(&quot;%d&quot;,&amp;last);

		for (j=2;j&lt;=k;j++)

		{

			scanf(&quot;%d&quot;,&amp;x);

			addedge(last,x);

			addedge(x,last);

			last=x;

		}

	}

	dfs(1);

	//for (int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,f[i]);printf(&quot;\n&quot;);

	printf(&quot;%d\n&quot;,ans);

	return 0;

}<pre><h2>Problem1023</h2><pre>#include&lt;cstdio&gt;

using namespace std;

#define NN 51000

int dfn[NN],low[NN],aa[10000000][2],o[NN],fa[NN],from[NN],b[NN*2],f[NN];

int n,tot=1,ans,TIME,m;

struct ppt {int w,id;} q[NN*2];

void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}

int min(int a,int b) {return a&lt;b?a:b;}

int max(int a,int b) {return a&gt;b?a:b;}

void dp_on_circle()

{

	int head=0,tail=1,i;

	for (i=1;i&lt;b[0];i++) b[i+b[0]]=b[i];

	q[1].id=1,q[1].w=f[b[1]]-1;

	for (i=2;i&lt;b[0]*2;i++)

	{

		while (head&lt;tail&amp;&amp;i-q[head+1].id&gt;b[0]/2) head++;

		ans=max(ans,q[head+1].w+i+f[b[i]]);

		while (head&lt;tail&amp;&amp;f[b[i]]-i&gt;q[tail].w) tail--;

		tail++;

		q[tail].w=f[b[i]]-i,q[tail].id=i;

	}

}

void dfs(int v)

{

	dfn[v]=low[v]=++TIME;

	for (int p=o[v];p;p=aa[p][0])

	{

		int y=aa[p][1];

		if (p==(from[v]^1)) continue;

		if (dfn[y]) low[v]=min(low[v],dfn[y]);

		else

		{

			from[y]=p;

			fa[y]=v;

			dfs(y);

			low[v]=min(low[v],low[y]);

		}

	}

	for (int p=o[v];p;p=aa[p][0])

	{

		int y=aa[p][1];

		//if (p==(from[v]^1)) continue;

		if (low[y]&gt;dfn[v])

		{

			ans=max(ans,f[v]+f[y]+1);

			f[v]=max(f[v],f[y]+1);

		}

		if (p!=from[y]&amp;&amp;dfn[v]&lt;dfn[y])

		{

			b[0]=0;

			for (int x=y;x!=fa[v];x=fa[x]) b[++b[0]]=x;

			dp_on_circle();

			for (int i=1;i&lt;b[0];i++) f[v]=max(f[v],f[b[i]]+min(i,b[0]-i));

		}

	}

}

int main()

{

	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);

	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);

	int i,k,last,j,x;

	for (i=1;i&lt;=m;i++)

	{

		scanf(&quot;%d&quot;,&amp;k);

		scanf(&quot;%d&quot;,&amp;last);

		for (j=2;j&lt;=k;j++)

		{

			scanf(&quot;%d&quot;,&amp;x);

			addedge(last,x);

			addedge(x,last);

			last=x;

		}

	}

	dfs(1);

	//for (int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,f[i]);printf(&quot;\n&quot;);

	printf(&quot;%d\n&quot;,ans);

	return 0;

}<pre><h2>Problem1023</h2><pre>#include&lt;cstdio&gt;

using namespace std;

#define NN 51000

int dfn[NN],low[NN],aa[10000000][2],o[NN],fa[NN],from[NN],b[NN*2],f[NN];

int n,tot=1,ans,TIME,m;

struct ppt {int w,id;} q[NN*2];

void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}

int min(int a,int b) {return a&lt;b?a:b;}

int max(int a,int b) {return a&gt;b?a:b;}

void dp_on_circle()

{

	int head=0,tail=1,i;

	for (i=1;i&lt;b[0];i++) b[i+b[0]]=b[i];

	q[1].id=1,q[1].w=f[b[1]]-1;

	for (i=2;i&lt;b[0]*2;i++)

	{

		while (head&lt;tail&amp;&amp;i-q[head+1].id&gt;b[0]/2) head++;

		ans=max(ans,q[head+1].w+i+f[b[i]]);

		while (head&lt;tail&amp;&amp;f[b[i]]-i&gt;q[tail].w) tail--;

		tail++;

		q[tail].w=f[b[i]]-i,q[tail].id=i;

	}

}

void dfs(int v)

{

	dfn[v]=low[v]=++TIME;

	for (int p=o[v];p;p=aa[p][0])

	{

		int y=aa[p][1];

		if (p==(from[v]^1)) continue;

		if (dfn[y]) low[v]=min(low[v],dfn[y]);

		else

		{

			from[y]=p;

			fa[y]=v;

			dfs(y);

			low[v]=min(low[v],low[y]);

		}

	}

	for (int p=o[v];p;p=aa[p][0])

	{

		int y=aa[p][1];

		//if (p==(from[v]^1)) continue;

		if (low[y]&gt;dfn[v])

		{

			ans=max(ans,f[v]+f[y]+1);

			f[v]=max(f[v],f[y]+1);

		}

		else if (p!=from[y]&amp;&amp;dfn[v]&lt;dfn[y])

		{

			b[0]=0;

			for (int x=y;x!=fa[v];x=fa[x]) b[++b[0]]=x;

			dp_on_circle();

			for (int i=1;i&lt;b[0];i++) f[v]=max(f[v],f[b[i]]+min(i,b[0]-i));

		}

	}

}

int main()

{

	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);

	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);

	int i,k,last,j,x;

	for (i=1;i&lt;=m;i++)

	{

		scanf(&quot;%d&quot;,&amp;k);

		scanf(&quot;%d&quot;,&amp;last);

		for (j=2;j&lt;=k;j++)

		{

			scanf(&quot;%d&quot;,&amp;x);

			addedge(last,x);

			addedge(x,last);

			last=x;

		}

	}

	dfs(1);

	//for (int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,f[i]);printf(&quot;\n&quot;);

	printf(&quot;%d\n&quot;,ans);

	return 0;

}<pre><h2>Problem1023</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define NN 51111
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define maa(a,b) ((a)&gt;(b)?(a):(b))
int dfn[NN],low[NN],aa[10000000][2],o[NN],fa[NN],from[NN],b[NN*2],f[NN];

int n,tot=1,ans,TIME,m;
bool vt[NN];
struct ppt
{
	int w,id;
	ppt(int a=0,int b=0) {w=a,id=b;}
} q[NN*2];
void circle()
{
	int head=0,tail=1,i;
	for (i=1;i&lt;b[0];i++) b[i+b[0]]=b[i];
	q[1].id=1,q[1].w=f[b[1]]-1;
	for (i=2;i&lt;b[0]*2;i++)
	{
		while (head&lt;tail&amp;&amp;i-q[head+1].id&gt;b[0]/2) head++;
		ans=maa(ans,q[head+1].w+i+f[b[i]]);
		while (head&lt;tail&amp;&amp;f[b[i]]-i&gt;q[tail].w) tail--;
		tail++;
		q[tail].w=f[b[i]]-i,q[tail].id=i;
	}
}
/*void circle()
{
	int head=0,tail=0,i;
	//f[i]+f[j]+i-j
	for (i=1;i&lt;=b[0];i++) b[i+b[0]]=b[i];
	for (i=1;i&lt;b[0]*2;i++)
	{
		while (head&lt;tail&amp;&amp;q[head+1].id&lt;i-b[0]/2) head++;
		ans=maa(ans,q[head+1].w+f[b[i]]+i);
		while (head&lt;tail&amp;&amp;q[tail].w&lt;f[b[i]]-i) tail--;
		q[++tail]=ppt(f[b[i]]-i,i);
	}
}*/
void dfs(int v)
{
	vt[v]=true;
	dfn[v]=low[v]=++TIME;
	int p,y,x;
	for (p=o[v];p;p=aa[p][0])
	{
		y=aa[p][1];
		if (p==(from[v]^1)) continue;
		if (vt[y]) low[v]=mii(low[v],dfn[y]);
		else
		{
			from[y]=p;
			fa[y]=v;
			dfs(y);
			low[v]=mii(low[v],low[y]);
		}
	}
	for (p=o[v];p;p=aa[p][0])
	{
		y=aa[p][1];
		if (low[y]&gt;dfn[v])
		{
			ans=maa(ans,f[v]+f[y]+1);
			f[v]=maa(f[v],f[y]+1);
		}
		else if (p!=from[y]&amp;&amp;dfn[v]&lt;dfn[y])
		{
			b[0]=0;
			for (x=y;x!=fa[v];x=fa[x]) b[++b[0]]=x;
			circle();
			for (int i=1;i&lt;b[0];i++) f[v]=maa(f[v],f[b[i]]+mii(i,b[0]-i));
		}
	}
}
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,k,last,j,x;
	for (tot=1,i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;k);
		scanf(&quot;%d&quot;,&amp;last);
		for (j=2;j&lt;=k;j++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			addedge(last,x),addedge(x,last);
			last=x;
		}
	}
	dfs(1);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1023</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define NN 51111
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define maa(a,b) ((a)&gt;(b)?(a):(b))
int dfn[NN],low[NN],aa[10000000][2],o[NN],fa[NN],from[NN],b[NN*2],f[NN];

int n,tot=1,ans,TIME,m;
bool vt[NN];
struct ppt
{
	int w,id;
	ppt(int a=0,int b=0) {w=a,id=b;}
} q[NN*2];
/*void circle()
{
	int head=0,tail=1,i;
	for (i=1;i&lt;b[0];i++) b[i+b[0]]=b[i];
	q[1].id=1,q[1].w=f[b[1]]-1;
	for (i=2;i&lt;b[0]*2;i++)
	{
		while (head&lt;tail&amp;&amp;i-q[head+1].id&gt;b[0]/2) head++;
		ans=maa(ans,q[head+1].w+i+f[b[i]]);
		while (head&lt;tail&amp;&amp;f[b[i]]-i&gt;q[tail].w) tail--;
		tail++;
		q[tail].w=f[b[i]]-i,q[tail].id=i;
	}
}*/
void circle()
{
	int head=0,tail=1,i;
	q[1]=ppt(f[b[1]]-1,1);
	//f[i]+f[j]+i-j
	for (i=1;i&lt;=b[0];i++) b[i+b[0]]=b[i];
	for (i=2;i&lt;b[0]*2;i++)
	{
		while (head&lt;tail&amp;&amp;q[head+1].id&lt;i-b[0]/2) head++;
		ans=maa(ans,q[head+1].w+f[b[i]]+i);
		while (head&lt;tail&amp;&amp;q[tail].w&lt;f[b[i]]-i) tail--;
		q[++tail]=ppt(f[b[i]]-i,i);
	}
}
void dfs(int v)
{
	vt[v]=true;
	dfn[v]=low[v]=++TIME;
	int p,y,x;
	for (p=o[v];p;p=aa[p][0])
	{
		y=aa[p][1];
		if (p==(from[v]^1)) continue;
		if (vt[y]) low[v]=mii(low[v],dfn[y]);
		else
		{
			from[y]=p;
			fa[y]=v;
			dfs(y);
			low[v]=mii(low[v],low[y]);
		}
	}
	for (p=o[v];p;p=aa[p][0])
	{
		y=aa[p][1];
		if (low[y]&gt;dfn[v])
		{
			ans=maa(ans,f[v]+f[y]+1);
			f[v]=maa(f[v],f[y]+1);
		}
		else if (p!=from[y]&amp;&amp;dfn[v]&lt;dfn[y])
		{
			b[0]=0;
			for (x=y;x!=fa[v];x=fa[x]) b[++b[0]]=x;
			circle();
			for (int i=1;i&lt;b[0];i++) f[v]=maa(f[v],f[b[i]]+mii(i,b[0]-i));
		}
	}
}
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,k,last,j,x;
	for (tot=1,i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;k);
		scanf(&quot;%d&quot;,&amp;last);
		for (j=2;j&lt;=k;j++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			addedge(last,x),addedge(x,last);
			last=x;
		}
	}
	dfs(1);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1023</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef pair&lt;int,int&gt; pii;
#define ln printf(&quot;\n&quot;)
#define mp make_pair
#define fi first
#define se second
const int NN=50111,MM=200111;
int o[NN],aa[MM&lt;&lt;1][2],f[NN],dfn[NN],low[NN],from[NN],fa[NN],b[NN&lt;&lt;1];
int n,m,num,ans,TIME,tot=1;
bool vt[NN];
inline int min(int a,int b) {return a&lt;b?a:b;}
inline int max(int a,int b) {return a&gt;b?a:b;}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dp_circle()
{
	//printf(&quot;\n----------------------------------------------------------------------\n&quot;);
	static pii que[NN&lt;&lt;1];
	int i;
	for (i=1;i&lt;=num;i++) b[i+num]=b[i];
	int head=0,tail=1;
	que[1]=mp(1,f[b[1]]-1);
	//for(i=1;i&lt;=num;i++)printf(&quot;%d %d  &quot;,b[i],f[b[i]]);ln;
	for (i=2;i&lt;=num*2;i++)
	{
		while (head&lt;tail&amp;&amp;i-que[head+1].fi&gt;(num&gt;&gt;1)) head++;
		if (head&lt;tail) ans=max(ans,f[b[i]]+i+que[head+1].se);
		//if (ans==12) printf(&quot;i=%d que[head+1].fi=%d que[head+1].se=%d\n&quot;,i,que[head+1].fi,que[head+1].se);
		while (head&lt;tail&amp;&amp;f[b[i]]-i&gt;=que[tail].se) tail--;
		que[++tail]=mp(i,f[b[i]]-i);
	}
}
void dfs(int v)
{
	vt[v]=true;
	dfn[v]=low[v]=++TIME;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if ((p^1)==from[v]) continue;
		if (!vt[y])
		{
			fa[y]=v;
			from[y]=p;
			dfs(y);
			low[v]=min(low[v],low[y]);
		}
		else low[v]=min(low[v],dfn[y]);
	}
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if ((p^1)==from[v]) continue;
		if (p==from[y]&amp;&amp;low[y]&gt;dfn[v])
		{
			ans=max(ans,f[v]+f[y]+1);
			f[v]=max(f[v],f[y]+1);
		}
		else if (p!=from[y]&amp;&amp;dfn[v]&lt;dfn[y])
		{
			num=0;
			for (int x=y;x!=fa[v];x=fa[x]) b[++num]=x;
			//printf(&quot;b &quot;);for (int i=1;i&lt;=num;i++) printf(&quot;%d &quot;,b[i]);ln;
			dp_circle();
			for (int i=1;i&lt;num;i++)
				f[v]=max(f[v],f[b[i]]+min(num-i,i));
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,k,last,j,x;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;k,&amp;last);
		for (j=2;j&lt;=k;j++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			addedge(last,x),addedge(x,last);
			last=x;
		}
	}
	dfs(1);
	//printf(&quot;f &quot;);for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,f[i]);ln;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1024</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
typedef double DD;
DD dfs(DD n,DD m,int K)
{
	if (K==1)
	{
		if (n&lt;m) {DD t=n;n=m;m=t;}
		return n/m;
	}
	DD res=inf;
	for (int i=1;i+i&lt;=K;i++)
	{
		DD x=(DD)i/K*n,y=(DD)i/K*m;
		DD tmp=max(dfs(x,m,i),dfs(n-x,m,K-i));
		if (tmp&lt;res) res=tmp;
		tmp=max(dfs(n,y,i),dfs(n,m-y,K-i));
		if (tmp&lt;res) res=tmp;
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int n,m,K;
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;K);
	printf(&quot;%.6f\n&quot;,dfs(n,m,K));
	return 0;
}<pre><h2>Problem1025</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
const int NN=1005;
int pr[NN];
int n,prcnt;
LL f[NN][NN];
void shai()
{
	static bool vt[NN];
	vt[1]=true;
	for (int i=2;i&lt;=n;i++)
	{
		if (!vt[i]) pr[++prcnt]=i;
		for (int j=1;j&lt;=prcnt;j++)
		{
			int x=i*pr[j];
			if (x&gt;n) break;
			vt[x]=true;
			if (i%pr[j]==0) break;
		}
	}
	//printf(&quot;pr &quot;);for (int i=1;i&lt;=prcnt;i++) printf(&quot;%d &quot;,pr[i]);ln;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	shai();
	f[0][0]=1;
	int i,j;
	for (i=1;i&lt;=prcnt;i++)
		for (j=0;j&lt;=n;j++)
		{
			f[i][j]=f[i-1][j];
			for (LL tmp=pr[i];j&gt;=tmp;tmp=tmp*pr[i])
				f[i][j]+=f[i-1][j-tmp];
			//printf(&quot;f[%d][%d]=%lld\n&quot;,i,j,f[i][j]);
		}
	LL ans=0;
	for (i=0;i&lt;=n;i++) ans+=f[prcnt][i];
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem1026</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define LL long long
LL f[20][11],A,B;
LL abs(LL x) {return x&gt;0?x:-x;}
void prepare()
{
	//f[i][j]:i位数，最高位是j的windy数的个数 
	//f[i][j]=sigma(f[i-1][k])
	int i,j,k;
	for (i=0;i&lt;=9;i++) f[1][i]=1;
	for (i=2;i&lt;=10;i++)
		for (j=0;j&lt;=9;j++)
			for (k=0;k&lt;=9;k++)
				if (abs(j-k)&gt;=2) f[i][j]+=f[i-1][k];
	//for (i=1;i&lt;=10;i++) for (j=0;j&lt;=9;j++) printf(&quot;%d %d:  %lld\n&quot;,i,j,f[i][j]);
}
LL calc(int n)
{
	n++;
	int i,j;
	int a[20];
	a[0]=0;
	int tmp=n;
	while (tmp&gt;0)
	{
		a[++a[0]]=tmp%10;
		tmp/=10;
	}
	//printf(&quot;%d\n&quot;,a[0]);
	LL ans=0;
	for (i=1;i&lt;a[0];i++)
		for (j=1;j&lt;=9;j++) ans+=f[i][j];
	for (i=1;i&lt;a[a[0]];i++) ans+=f[a[0]][i];
	for (i=a[0]-1;i&gt;0;i--)
	{
		for (j=0;j&lt;=a[i]-1;j++)
			if (abs(j-a[i+1])&gt;=2) ans+=f[i][j];
		if (abs(a[i]-a[i+1])&lt;2) break;
	}
	return ans;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld%lld&quot;,&amp;A,&amp;B);
	prepare();
	printf(&quot;%lld\n&quot;,calc(B)-calc(A-1));
	return 0;
}
<pre><h2>Problem1029</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
const int NN=151111;
int n;
struct building
{
	int x,y;
	friend bool operator &lt;(building a,building b) {return a.x&lt;b.x;}
} a[NN];
priority_queue&lt;building&gt; Q;
bool cmp(building a,building b) {return a.y&lt;b.y;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;a[i].x,&amp;a[i].y);
	sort(a+1,a+n+1,cmp);
	int now=0,ans=0;
	for (i=1;i&lt;=n;i++)
	{
		if (now+a[i].x&lt;=a[i].y)
		{
			ans++;
			now+=a[i].x;
			Q.push(a[i]);
		}
		else
		{
			building tmp=Q.top();
			if (tmp.x&gt;=a[i].x)
			{
				Q.pop();
				Q.push(a[i]);
				now=now-tmp.x+a[i].x;
			}
		}
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1030</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mo 10007
const int AA=6011,NN=105;
int son[AA][26],fail[AA],q[AA],f[NN][AA];
int n,m,TTT;
bool flag[AA];
char s[63];
void ACins(int l)
{
	int now=1;
	for (int i=1;i&lt;=l;i++)
	{
		int t=s[i]-'A';
		if (son[now][t]) now=son[now][t];
		else now=son[now][t]=++TTT;
	}
	flag[now]=true;
}
void buildfail()
{
	int head=0,tail=1;
	q[1]=1;
	while (head&lt;tail)
	{
		int x=q[++head];
		flag[x]|=flag[fail[x]];
		for (int i=0;i&lt;26;i++)
			if (son[x][i]==0) son[x][i]=son[fail[x]][i];
			else
			{
				fail[son[x][i]]=son[fail[x]][i];
				q[++tail]=son[x][i];
			}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	int i,j,k;
	for (i=0;i&lt;26;i++) son[0][i]=1,son[1][i]=0;
	TTT=1;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s\n&quot;,s+1);
		ACins(strlen(s+1));
	}
	buildfail();
	int ans=1;
	int li=200000;
	for (i=1;i&lt;=m;i++)
	{
		ans*=26;
		if (ans&gt;=li) ans%=mo;
	}
	f[0][1]=1;
	for (i=0;i&lt;m;i++)
		for (j=1;j&lt;=TTT;j++) if (!flag[j])
			for (k=0;k&lt;26;k++)
			{
				int t=son[j][k];
				if (flag[t]) continue;
				f[i+1][t]+=f[i][j];
				if (f[i+1][t]&gt;mo) f[i+1][t]-=mo;
			}
	for (i=1;i&lt;=TTT;i++)
	{
		ans-=f[m][i];
		if (ans&lt;0) ans+=mo;
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1031</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
int rank[2100000],sa[2100000],sum[2100000],s[2100000],sa2[2100000],wv[2100000],height[2100000];
char sss[2100000];
int n,len;
void suffix_array(int *r,int n,int m)
{
	int i,j,p,*x=rank,*y=sa2,*t;
	memset(x,-1,sizeof(x)*(n+100000));
	memset(y,-1,sizeof(y)*(n+100000));
	for (i=0;i&lt;m;i++) sum[i]=0;
	for (i=0;i&lt;n;i++) sum[x[i]=r[i]]++;
	for (i=1;i&lt;m;i++) sum[i]+=sum[i-1];
	for (i=n-1;i&gt;=0;i--) sa[--sum[x[i]]]=i;
	for (j=p=1;p&lt;n;j&lt;&lt;=1,m=p)
	{
		for (p=0,i=n-j;i&lt;n;i++) y[p++]=i;
		for (i=0;i&lt;n;i++) if (sa[i]&gt;=j) y[p++]=sa[i]-j;
		for (i=0;i&lt;n;i++) wv[i]=x[y[i]];
		for (i=0;i&lt;m;i++) sum[i]=0;
		for (i=0;i&lt;n;i++) sum[wv[i]]++;
		for (i=1;i&lt;m;i++) sum[i]+=sum[i-1];
		for (i=n-1;i&gt;=0;i--) sa[--sum[wv[i]]]=y[i];
		for (t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i&lt;n;i++)
			x[sa[i]]=(y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i]+j]==y[sa[i-1]+j])?p-1:p++;
	}
	//printf(&quot;sa: &quot;);for (i=0;i&lt;n;i++) printf(&quot;%d &quot;,sa[i]);printf(&quot;\n&quot;);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	gets(sss);
	len=strlen(sss);
	int i;
	for (i=0;i&lt;len;i++) s[i]=sss[i];
	n=len*2-1;
	for (i=len;i&lt;n;i++) s[i]=s[i-len];
	//for (i=0;i&lt;n;i++) printf(&quot;%c&quot;,s[i]);printf(&quot;\n&quot;);
	suffix_array(s,n,300);
	for (i=0;i&lt;n;i++)
		if (sa[i]&lt;len) printf(&quot;%c&quot;,s[sa[i]+len-1]);
	printf(&quot;\n&quot;);
	return 0;
}
<pre><h2>Problem1031</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
int rank[4100000],sa[4100000],sum[4100000],s[4100000],sa2[4100000],wv[4100000],height[4100000];
char sss[4100000];
int n,len;
void suffix_array(int *r,int n,int m)
{
	int i,j,p,*x=rank,*y=sa2,*t;
	memset(x,-1,sizeof(x)*(n+100000));
	memset(y,-1,sizeof(y)*(n+100000));
	for (i=0;i&lt;m;i++) sum[i]=0;
	for (i=0;i&lt;n;i++) sum[x[i]=r[i]]++;
	for (i=1;i&lt;m;i++) sum[i]+=sum[i-1];
	for (i=n-1;i&gt;=0;i--) sa[--sum[x[i]]]=i;
	for (j=p=1;p&lt;n;j&lt;&lt;=1,m=p)
	{
		for (p=0,i=n-j;i&lt;n;i++) y[p++]=i;
		for (i=0;i&lt;n;i++) if (sa[i]&gt;=j) y[p++]=sa[i]-j;
		for (i=0;i&lt;n;i++) wv[i]=x[y[i]];
		for (i=0;i&lt;m;i++) sum[i]=0;
		for (i=0;i&lt;n;i++) sum[wv[i]]++;
		for (i=1;i&lt;m;i++) sum[i]+=sum[i-1];
		for (i=n-1;i&gt;=0;i--) sa[--sum[wv[i]]]=y[i];
		for (t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i&lt;n;i++)
			x[sa[i]]=(y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i]+j]==y[sa[i-1]+j])?p-1:p++;
	}
	p=0;
	for (i=0;i&lt;n;i++)
		if (x[i]!=0)
		{
			j=sa[x[i]-1];
			if (i==j) continue;
			while (r[i+p]==r[j+p]) p++;
			height[x[i]]=p;
			if (p) p--;
		}
	//printf(&quot;sa: &quot;);for (i=0;i&lt;n;i++) printf(&quot;%d &quot;,sa[i]);printf(&quot;\n&quot;);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	gets(sss);
	len=strlen(sss);
	int i;
	for (i=0;i&lt;len;i++) s[i]=sss[i];
	n=len*2-1;
	for (i=len;i&lt;n;i++) s[i]=s[i-len];
	//for (i=0;i&lt;n;i++) printf(&quot;%c&quot;,s[i]);printf(&quot;\n&quot;);
	suffix_array(s,n,300);
	for (i=0;i&lt;n;i++)
		if (sa[i]&lt;len) printf(&quot;%c&quot;,s[sa[i]+len-1]);
	printf(&quot;\n&quot;);
	return 0;
}
<pre><h2>Problem1031</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
int rank[4100000],sa[4100000],sum[4100000],s[4100000],sa2[4100000],wv[4100000],height[4100000];
char sss[4100000];
int n,len;
void suffix_array(int *r,int n,int m)
{
	int i,j,p,*x=rank,*y=sa2,*t;
	if (n==1)
	{
		sa[0]=0;
		x[0]=0;
		return;
	}
	memset(x,-1,sizeof(x)*400000);
	memset(y,-1,sizeof(y)*400000);
	for (i=0;i&lt;m;i++) sum[i]=0;
	for (i=0;i&lt;n;i++) sum[x[i]=r[i]]++;
	for (i=1;i&lt;m;i++) sum[i]+=sum[i-1];
	for (i=n-1;i&gt;=0;i--) sa[--sum[x[i]]]=i;
	for (j=p=1;p&lt;n;j&lt;&lt;=1,m=p)
	{
		for (p=0,i=n-j;i&lt;n;i++) y[p++]=i;
		for (i=0;i&lt;n;i++) if (sa[i]&gt;=j) y[p++]=sa[i]-j;
		for (i=0;i&lt;n;i++) wv[i]=x[y[i]];
		for (i=0;i&lt;m;i++) sum[i]=0;
		for (i=0;i&lt;n;i++) sum[wv[i]]++;
		for (i=1;i&lt;m;i++) sum[i]+=sum[i-1];
		for (i=n-1;i&gt;=0;i--) sa[--sum[wv[i]]]=y[i];
		for (t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i&lt;n;i++)
			x[sa[i]]=(y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i]+j]==y[sa[i-1]+j])?p-1:p++;
	}
	p=0;
	for (i=0;i&lt;n;i++)
		if (x[i]!=0)
		{
			j=sa[x[i]-1];
			while (r[i+p]==r[j+p]) p++;
			height[x[i]]=p;
			if (p) p--;
		}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	gets(sss);
	len=strlen(sss);
	int i;
	for (i=0;i&lt;len;i++) s[i]=sss[i];
	n=len*2-1;
	for (i=len;i&lt;n;i++) s[i]=s[i-len];
	suffix_array(s,n,300);
	for (i=0;i&lt;n;i++)
		if (sa[i]&lt;len) printf(&quot;%c&quot;,s[sa[i]+len-1]);
	printf(&quot;\n&quot;);
	return 0;
}
<pre><h2>Problem1031</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
int rank[4100000],sa[4100000],sum[4100000],s[4100000],sa2[4100000],wv[4100000],height[4100000];
char sss[4100000];
int n,len;
void suffix_array(int *r,int n,int m)
{
    int i,j,p,*x=rank,*y=sa2,*t;
    if (n==1)
    {
        sa[0]=0;
        x[0]=0;
        return;
    }
    memset(x,-1,sizeof(x)*400000);
    memset(y,-1,sizeof(y)*400000);
    for (i=0;i&lt;m;i++) sum[i]=0;
    for (i=0;i&lt;n;i++) sum[x[i]=r[i]]++;
    for (i=1;i&lt;m;i++) sum[i]+=sum[i-1];
    for (i=n-1;i&gt;=0;i--) sa[--sum[x[i]]]=i;
    for (j=p=1;p&lt;n;j&lt;&lt;=1,m=p)
    {
        for (p=0,i=n-j;i&lt;n;i++) y[p++]=i;
        for (i=0;i&lt;n;i++) if (sa[i]&gt;=j) y[p++]=sa[i]-j;
        for (i=0;i&lt;n;i++) wv[i]=x[y[i]];
        for (i=0;i&lt;m;i++) sum[i]=0;
        for (i=0;i&lt;n;i++) sum[wv[i]]++;
        for (i=1;i&lt;m;i++) sum[i]+=sum[i-1];
        for (i=n-1;i&gt;=0;i--) sa[--sum[wv[i]]]=y[i];
        for (t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i&lt;n;i++)
            x[sa[i]]=(y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i]+j]==y[sa[i-1]+j])?p-1:p++;
    }
    p=0;
    for (i=0;i&lt;n;i++)
        if (x[i]!=0)
        {
            j=sa[x[i]-1];
            while (r[i+p]==r[j+p]) p++;
            height[x[i]]=p;
            if (p) p--;
        }
}
int main()
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%s&quot;,sss);
    len=strlen(sss);
    int i;
    for (i=0;i&lt;len;i++) s[i]=sss[i];
    n=len*2-1;
    for (i=len;i&lt;n;i++) s[i]=s[i-len];
    suffix_array(s,n,300);
    for (i=0;i&lt;n;i++)
        if (sa[i]&lt;len) printf(&quot;%c&quot;,s[sa[i]+len-1]);
    printf(&quot;\n&quot;);
    return 0;
}
<pre><h2>Problem1031</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
int rank[410000],sa[410000],sum[410000],s[410000],sa2[410000],wv[410000],height[410000];
char sss[410000];
int n,len;
void suffix_array(int *r,int n,int m)
{
    int i,j,p,*x=rank,*y=sa2,*t;
    if (n==1)
    {
        sa[0]=0;
        x[0]=0;
        return;
    }
    memset(x,-1,sizeof(x)*400000);
    memset(y,-1,sizeof(y)*400000);
    for (i=0;i&lt;m;i++) sum[i]=0;
    for (i=0;i&lt;n;i++) sum[x[i]=r[i]]++;
    for (i=1;i&lt;m;i++) sum[i]+=sum[i-1];
    for (i=n-1;i&gt;=0;i--) sa[--sum[x[i]]]=i;
    for (j=p=1;p&lt;n;j&lt;&lt;=1,m=p)
    {
        for (p=0,i=n-j;i&lt;n;i++) y[p++]=i;
        for (i=0;i&lt;n;i++) if (sa[i]&gt;=j) y[p++]=sa[i]-j;
        for (i=0;i&lt;n;i++) wv[i]=x[y[i]];
        for (i=0;i&lt;m;i++) sum[i]=0;
        for (i=0;i&lt;n;i++) sum[wv[i]]++;
        for (i=1;i&lt;m;i++) sum[i]+=sum[i-1];
        for (i=n-1;i&gt;=0;i--) sa[--sum[wv[i]]]=y[i];
        for (t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i&lt;n;i++)
            x[sa[i]]=(y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i]+j]==y[sa[i-1]+j])?p-1:p++;
    }
    p=0;
    for (i=0;i&lt;n;i++)
        if (x[i]!=0)
        {
            j=sa[x[i]-1];
            while (r[i+p]==r[j+p]) p++;
            height[x[i]]=p;
            if (p) p--;
        }
}
int main()
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%s&quot;,sss);
    len=strlen(sss);
    int i;
    for (i=0;i&lt;len;i++) s[i]=sss[i];
    n=len*2-1;
    for (i=len;i&lt;n;i++) s[i]=s[i-len];
    suffix_array(s,n,300);
    for (i=0;i&lt;n;i++)
        if (sa[i]&lt;len) printf(&quot;%c&quot;,s[sa[i]+len-1]);
    printf(&quot;\n&quot;);
    return 0;
}
<pre><h2>Problem1031</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 4111101
int sa[NN],rank[NN],sa2[NN],sum[NN],wv[NN],height[NN],s[NN];
int len,i;
char ss[NN];
void suffix_array(int *r,int n,int m)
{
	memset(rank,-1,sizeof(rank));
	memset(sa2,-1,sizeof(sa2));
	int i,j,p,*x=rank,*y=sa2,*t;
	//for (i=0;i&lt;n;i++) printf(&quot;%d &quot;,x[i]);
	if (n==1)
	{
		sa[0]=0,x[0]=0;
		rank[0]=0;
		return;
	}
	for (i=0;i&lt;m;i++) sum[i]=0;
	for (i=0;i&lt;n;i++) sum[x[i]=r[i]]++;
	for (i=1;i&lt;m;i++) sum[i]+=sum[i-1];
	for (i=n-1;i&gt;=0;i--) sa[--sum[x[i]]]=i;
	for (p=j=1;p&lt;n;j&lt;&lt;=1,m=p)
	{
		for (p=0,i=n-j;i&lt;n;i++) y[p++]=i;
		for (i=0;i&lt;n;i++) if (sa[i]&gt;=j) y[p++]=sa[i]-j;
		for (i=0;i&lt;n;i++) wv[i]=x[y[i]];
		for (i=0;i&lt;m;i++) sum[i]=0;
		for (i=0;i&lt;n;i++) sum[wv[i]]++;
		for (i=1;i&lt;m;i++) sum[i]+=sum[i-1];
		for (i=n-1;i&gt;=0;i--) sa[--sum[wv[i]]]=y[i];
		for (t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i&lt;n;i++)
			x[sa[i]]=(y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i]+j]==y[sa[i-1]+j])?p-1:p++;
	}
	//for (i=0;i&lt;n;i++) printf(&quot;%d &quot;,x[i]);
	for (p=0,i=0;i&lt;n;i++)
		if (x[i]!=0)
		{
			j=sa[x[i]-1];
			while (r[i+p]==r[j+p]) p++;
			height[x[i]]=p;
			if (p) p--;
		}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%s&quot;,ss);
	len=strlen(ss);
	for (i=0;i&lt;len;i++) s[i]=(int)ss[i];
	for (i=len;i&lt;len*2-1;i++) s[i]=s[i-len];
	suffix_array(s,len*2-1,260);
	for (i=0;i&lt;len*2-1;i++)
		if (sa[i]&lt;len) printf(&quot;%c&quot;,s[sa[i]+len-1]);
	printf(&quot;\n&quot;);
	return 0;
}
<pre><h2>Problem1031</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 4111101
int sa[NN],rank[NN],sa2[NN],sum[NN],wv[NN],height[NN],s[NN];
int len,i;
char ss[NN];
void suffix_array(int *r,int n,int m)
{
	memset(rank,-1,sizeof(rank));
	memset(sa2,-1,sizeof(sa2));
	int i,j,p,*x=rank,*y=sa2,*t;
	if (n==1) {sa[0]=0,rank[0]=0;return;}
	for (i=0;i&lt;m;i++) sum[i]=0;
	for (i=0;i&lt;n;i++) sum[x[i]=r[i]]++;
	for (i=1;i&lt;m;i++) sum[i]+=sum[i-1];
	for (i=n-1;i&gt;=0;i--) sa[--sum[x[i]]]=i;
	for (p=j=1;p&lt;n;j&lt;&lt;=1,m=p)
	{
		for (p=0,i=n-j;i&lt;n;i++) y[p++]=i;
		for (i=0;i&lt;n;i++) if (sa[i]&gt;=j) y[p++]=sa[i]-j;
		for (i=0;i&lt;n;i++) wv[i]=x[y[i]];
		for (i=0;i&lt;m;i++) sum[i]=0;
		for (i=0;i&lt;n;i++) sum[wv[i]]++;
		for (i=1;i&lt;m;i++) sum[i]+=sum[i-1];
		for (i=n-1;i&gt;=0;i--) sa[--sum[wv[i]]]=y[i];
		for (t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i&lt;n;i++)
			x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+j]==y[sa[i-1]+j])?p-1:p++;
	}
	for (p=0,i=0;i&lt;n;i++)
		if (x[i]!=0)
		{
			j=sa[x[i]-1];
			while (r[i+p]==r[j+p]) p++;
			height[x[i]]=p;
			if (p) p--;
		}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%s&quot;,ss);
	len=strlen(ss);
	for (i=0;i&lt;len;i++) s[i]=(int)ss[i];
	for (i=len;i&lt;len*2-1;i++) s[i]=s[i-len];
	suffix_array(s,len*2-1,260);
	for (i=0;i&lt;len*2-1;i++)
		if (sa[i]&lt;len) printf(&quot;%c&quot;,s[sa[i]+len-1]);
	printf(&quot;\n&quot;);
	return 0;
}
<pre><h2>Problem1031</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 4111101
int sa[NN],rank[NN],sa2[NN],sum[NN],wv[NN],height[NN],s[NN];
int len,i;
char ss[NN];
void suffix_array(int *r,int n,int m)
{
	memset(rank,-1,sizeof(rank));
	memset(sa2,-1,sizeof(sa2));
	int i,j,p,*x=rank,*y=sa2,*t;
	if (n==1) {sa[0]=0,rank[0]=0;return;}
	for (i=0;i&lt;m;i++) sum[i]=0;
	for (i=0;i&lt;n;i++) sum[x[i]=r[i]]++;
	for (i=1;i&lt;m;i++) sum[i]+=sum[i-1];
	for (i=n-1;i&gt;=0;i--) sa[--sum[x[i]]]=i;
	for (p=j=1;p&lt;n;j&lt;&lt;=1,m=p)
	{
		for (p=0,i=n-j;i&lt;n;i++) y[p++]=i;
		for (i=0;i&lt;n;i++) if (sa[i]&gt;=j) y[p++]=sa[i]-j;
		for (i=0;i&lt;n;i++) wv[i]=x[y[i]];
		for (i=0;i&lt;m;i++) sum[i]=0;
		for (i=0;i&lt;n;i++) sum[wv[i]]++;
		for (i=1;i&lt;m;i++) sum[i]+=sum[i-1];
		for (i=n-1;i&gt;=0;i--) sa[--sum[wv[i]]]=y[i];
		for (t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i&lt;n;i++)
			x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+j]==y[sa[i-1]+j])?p-1:p++;
	}
}
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%s&quot;,ss);
	len=strlen(ss);
	for (i=0;i&lt;len;i++) s[i]=(int)ss[i];
	for (i=len;i&lt;len*2-1;i++) s[i]=s[i-len];
	suffix_array(s,len*2-1,260);
	for (i=0;i&lt;len*2-1;i++)
		if (sa[i]&lt;len) printf(&quot;%c&quot;,s[sa[i]+len-1]);
	printf(&quot;\n&quot;);
	return 0;
}
<pre><h2>Problem1031</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 4111101
int sa[NN],rank[NN],sa2[NN],sum[NN],wv[NN],height[NN],s[NN];
int len,i;
char ss[NN];
void suffix_array(int *r,int n,int m)
{
	memset(rank,-1,sizeof(rank));
	memset(sa2,-1,sizeof(sa2));
	int i,j,p,*x=rank,*y=sa2,*t;
	if (n==1) {sa[1]=1,rank[1]=1;return;}
	for (i=1;i&lt;=m;i++) sum[i]=0;
	for (i=1;i&lt;=n;i++) sum[x[i]=r[i]]++;
	for (i=2;i&lt;=m;i++) sum[i]+=sum[i-1];
	for (i=n;i;i--) sa[sum[x[i]]--]=i;
	for (p=j=1;p&lt;n;j&lt;&lt;=1,m=p)
	{
		for (p=0,i=n-j+1;i&lt;=n;i++) y[++p]=i;
		for (i=1;i&lt;=n;i++) if (sa[i]&gt;j) y[++p]=sa[i]-j;
		for (i=1;i&lt;=n;i++) wv[i]=x[y[i]];
		for (i=1;i&lt;=m;i++) sum[i]=0;
		for (i=1;i&lt;=n;i++) sum[wv[i]]++;
		for (i=2;i&lt;=m;i++) sum[i]+=sum[i-1];
		for (i=n;i;i--) sa[sum[wv[i]]--]=y[i];
		for (t=x,x=y,y=t,p=1,x[sa[1]]=1,i=2;i&lt;=n;i++)
			x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+j]==y[sa[i-1]+j])?p:++p;
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%s&quot;,ss+1);
	len=strlen(ss+1);
	for (i=1;i&lt;=len;i++) s[i]=(int)ss[i];
	for (i=len+1;i&lt;=len*2-1;i++) s[i]=s[i-len];
	suffix_array(s,len*2-1,260);
	for (i=1;i&lt;=len*2-1;i++)
		if (sa[i]&lt;=len) printf(&quot;%c&quot;,s[sa[i]+len-1]);
	printf(&quot;\n&quot;);
	return 0;
}
<pre><h2>Problem1031</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 4111101
int sa[NN],rank[NN],sa2[NN],sum[NN],wv[NN],height[NN],s[NN];
int len,i;
char ss[NN];
void suffix_array(int *r,int n,int m)
{
	int i,j,p,*x=rank,*y=sa2,*t;
	if (n==1) {sa[1]=1,rank[1]=1;return;}
	for (i=0;i&lt;=m;i++) sum[i]=0;
	for (i=1;i&lt;=n;i++) sum[x[i]=r[i]]++;
	for (i=1;i&lt;=m;i++) sum[i]+=sum[i-1];
	for (i=n;i;i--) sa[sum[x[i]]--]=i;
	for (p=j=1;p&lt;n;j&lt;&lt;=1,m=p)
	{
		for (p=0,i=n-j+1;i&lt;=n;i++) y[++p]=i;
		for (i=1;i&lt;=n;i++) if (sa[i]&gt;j) y[++p]=sa[i]-j;
		for (i=1;i&lt;=n;i++) wv[i]=x[y[i]];
		for (i=0;i&lt;=m;i++) sum[i]=0;
		for (i=1;i&lt;=n;i++) sum[wv[i]]++;
		for (i=1;i&lt;=m;i++) sum[i]+=sum[i-1];
		for (i=n;i;i--) sa[sum[wv[i]]--]=y[i];
		for (t=x,x=y,y=t,p=1,x[sa[1]]=1,i=2;i&lt;=n;i++)
			x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+j]==y[sa[i-1]+j])?p:++p;
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%s&quot;,ss+1);
	len=strlen(ss+1);
	for (i=1;i&lt;=len;i++) s[i]=(int)ss[i];
	for (i=len+1;i&lt;=len*2-1;i++) s[i]=s[i-len];
	suffix_array(s,len*2-1,260);
	for (i=1;i&lt;=len*2-1;i++)
		if (sa[i]&lt;=len) printf(&quot;%c&quot;,s[sa[i]+len-1]);
	printf(&quot;\n&quot;);
	return 0;
}
<pre><h2>Problem1032</h2><pre>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
 
using namespace std;
 
const int MaxN = 500 + 5, INF = 999999999;
 
int n, Ans;
int A[MaxN], F[MaxN][MaxN];
 
inline int gmin(int a, int b) {return a &lt; b ? a : b;} 
      
int Solve(int l, int r) 
{
    if (F[l][r] != INF) return F[l][r];
    if (l == r) 
    {
        F[l][r] = 2;
        return F[l][r];
    }
    int Temp = INF, Cntl, Cntr;
    if (A[l] == A[r]) 
    {
        Cntl = Cntr = 0;
        for (int i = l; i &lt;= r; ++i) 
        {
            if (A[i] == A[l]) ++Cntl;
            else break;
        }
        for (int i = r; i &gt;= l; --i) 
        {
            if (A[i] == A[r]) ++Cntr;
            else break;
        }
        if (Cntl + Cntr &gt;= r - l + 1) 
        {
            F[l][r] = 1;
            return F[l][r];
        }
        if (Cntl + Cntr &gt;= 3) Temp = gmin(Temp, Solve(l + Cntl, r - Cntr));
        else Temp = gmin(Temp, Solve(l + Cntl, r - Cntr) + 1);
    }
    for (int i = l; i &lt;= r - 1; ++i) 
        Temp = gmin(Temp, Solve(l, i) + Solve(i + 1, r));
    F[l][r] = Temp;
    return F[l][r];
}
 
int main()
{
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;A[i]);
    for (int i = 1; i &lt;= n; ++i)
        for (int j = i; j &lt;= n; ++j)
            F[i][j] = INF;
    Ans = Solve(1, n);
    printf(&quot;%d\n&quot;, Ans);
    return 0;
}<pre><h2>Problem1034</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;set&gt;
#include&lt;ctime&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
#include&lt;deque&gt;
#define inf 2000000000
#define ll long long 
using namespace std;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int n;
int a[100005],b[100005];
int ans1,ans2;
set&lt;int&gt; q;
int solve(int a[],int b[])
{
	int l1=1,r1=n,l2=1,r2=n,ans=0;
	while(l1&lt;=r1&amp;&amp;l2&lt;=r2)
	{
		if(a[l1]&gt;b[l2]){ans+=2;l1++;l2++;}
		else if(a[r1]&gt;b[r2]){ans+=2;r1--;r2--;}
		else {ans+=(a[l1]==b[r2]);l1++;r2--;}
	}
	return ans;
}
int main()
{
	n=read();
	for(int i=1;i&lt;=n;i++)a[i]=read();
	for(int i=1;i&lt;=n;i++)b[i]=read();
	sort(a+1,a+n+1);
	sort(b+1,b+n+1);
	printf(&quot;%d %d\n&quot;,solve(a,b),2*n-solve(b,a));
	return 0;
}<pre><h2>Problem1036</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
using namespace std;
#define inf 99999999
#define NN 300055
int tsum[NN],tmax[NN],size[NN],deep[NN],root[NN],o[NN],w[NN],fa[NN],aa[NN*2][2];
int tot,n,m,anssum,ansmax;
char s[10];
int max(int a,int b) {return a&gt;b?a:b;}
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
void buildtree(int v,int dep)
{
	int rt=root[v];
	deep[v]=dep;
	size[rt]++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		if (size[rt]&lt;(int)sqrt(n)) root[y]=rt;
		fa[y]=v;
		buildtree(y,dep+1);
	}
}
void dfs(int v,int ssum,int mmax)
{
	ssum+=w[v];
	mmax=max(mmax,w[v]);
	tsum[v]=ssum;
	tmax[v]=mmax;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		if (root[y]==root[v]) dfs(y,ssum,mmax);
	}
}
void calc(int x,int y)
{
	while (root[x]!=root[y])
	{
		if (deep[root[x]]&lt;deep[root[y]]) swap(x,y);
		anssum+=tsum[x];
		ansmax=max(ansmax,tmax[x]);
		x=fa[root[x]];
	}
	while (x!=y)
	{
		if (deep[x]&lt;deep[y]) swap(x,y);
		anssum+=w[x];
		ansmax=max(ansmax,w[x]);
		x=fa[x];
	}
	anssum+=w[x];
	ansmax=max(ansmax,w[x]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y);
		addedge(y,x);
	}
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;w[i]),root[i]=i;
	buildtree(1,1);
	//printf(&quot;root: &quot;);for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,root[i]);printf(&quot;\n&quot;);
	for (i=1;i&lt;=n;i++)
		if (root[i]==i) dfs(i,0,-inf);
	//printf(&quot;tmax: &quot;);for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,tmax[i]);printf(&quot;\n&quot;);
	//printf(&quot;tsum: &quot;);for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,tsum[i]);printf(&quot;\n&quot;);
	scanf(&quot;%d\n&quot;,&amp;m);
	for (;m;m--)
	{
		scanf(&quot;%s %d%d\n&quot;,s+1,&amp;x,&amp;y);
		if (s[1]=='C')
		{
			w[x]=y;
			if (root[x]==x) dfs(x,0,-inf);
			else dfs(x,tsum[fa[x]],tmax[fa[x]]);
		}
		else
		{
			anssum=0,ansmax=-inf;
			calc(x,y);
			if (s[2]=='M') printf(&quot;%d\n&quot;,ansmax);
			else printf(&quot;%d\n&quot;,anssum);
		}
	}
	return 0;
}
<pre><h2>Problem1036</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define NN 31000
#define inf 99999999
int size[NN],up[NN],heavy[NN],fa[NN],pos[NN],which[NN],deep[NN];
int o[NN],aa[NN*2][2],w[NN],lc[NN*4],rc[NN*4],tmax[NN*4],tsum[NN*4];
int n,m,TOT,tot,cnt,ww,ee,ansmax,anssum;
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int max(int a,int b) {return a&gt;b?a:b;}
void dfs1(int v)
{
	int tmp=0,mm=-inf;
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		dfs1(y);
		size[v]+=size[y];
		if (size[y]&gt;mm) mm=size[y],tmp=y;
	}
	heavy[v]=tmp;
}
void dfs2(int v)
{
	pos[v]=++cnt;
	which[cnt]=v;
	if (!heavy[v]) return;
	up[heavy[v]]=up[v];
	dfs2(heavy[v]);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||y==heavy[v]) continue;
		up[y]=y;
		dfs2(y);
	}
}
void update(int v)
{
	tmax[v]=max(tmax[lc[v]],tmax[rc[v]]);
	tsum[v]=tsum[lc[v]]+tsum[rc[v]];
}
void buildseg(int &amp;v,int l,int r)
{
	if (!v) v=++TOT;
	//printf(&quot;buildseg: %d %d %d\n&quot;,v,l,r);
	if (r-l==1)
	{
		tmax[v]=tsum[v]=w[which[l]];
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	buildseg(lc[v],l,mid);
	buildseg(rc[v],mid,r);
	update(v);
}
void change(int v,int l,int r,int i,int x)
{
	if (r-l==1)
	{
		tmax[v]=tsum[v]=x;
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid) change(lc[v],l,mid,i,x);
	else change(rc[v],mid,r,i,x);
	update(v);
}
void find(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		if (tmax[v]&gt;ansmax) ansmax=tmax[v];
		anssum+=tsum[v];
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) find(lc[v],l,mid);
	if (ee&gt;mid) find(rc[v],mid,r);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y);
		addedge(y,x);
	}
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;w[i]);
	dfs1(1);
	up[1]=1;
	dfs2(1);
	//printf(&quot;up: &quot;);for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,up[i]);printf(&quot;\n&quot;);
	//printf(&quot;heavy: &quot;);for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,heavy[i]);printf(&quot;\n&quot;);
	//printf(&quot;pos: &quot;);for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,pos[i]);printf(&quot;\n&quot;);
	buildseg(i=0,1,n+1);
	scanf(&quot;%d\n&quot;,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		char s[10];
		scanf(&quot;%s%d%d\n&quot;,s,&amp;x,&amp;y);
		if (s[0]=='C')
		{
			change(1,1,n+1,pos[x],y);
			w[x]=y;
		}
		else
		{
			ansmax=-inf;
			anssum=0;
			while (up[x]!=up[y])
			{
				if (deep[up[x]]&lt;deep[up[y]]) {int t=x;x=y;y=t;}
				ww=pos[up[x]],ee=pos[x]+1;
				find(1,1,n+1);
				x=fa[up[x]];
			}
			if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
			ww=pos[y],ee=pos[x]+1;
			find(1,1,n+1);
			printf(&quot;%d\n&quot;,s[1]=='M'?ansmax:anssum);
		}
	}
	return 0;
}
<pre><h2>Problem1036</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define NN 31000
#define inf 99999999
int size[NN],up[NN],heavy[NN],fa[NN],pos[NN],which[NN],deep[NN];
int o[NN],aa[NN*2][2],w[NN],lc[NN*4],rc[NN*4],tmax[NN*4],tsum[NN*4];
int n,m,TOT,tot,cnt,ww,ee,ansmax,anssum;
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int max(int a,int b) {return a&gt;b?a:b;}
void dfs1(int v)
{
	int tmp=0,mm=-inf;
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		dfs1(y);
		size[v]+=size[y];
		if (size[y]&gt;mm) mm=size[y],tmp=y;
	}
	heavy[v]=tmp;
}
void dfs2(int v)
{
	pos[v]=++cnt;
	which[cnt]=v;
	if (!heavy[v]) return;
	up[heavy[v]]=up[v];
	dfs2(heavy[v]);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||y==heavy[v]) continue;
		up[y]=y;
		dfs2(y);
	}
}
void update(int v)
{
	tmax[v]=max(tmax[lc[v]],tmax[rc[v]]);
	tsum[v]=tsum[lc[v]]+tsum[rc[v]];
}
void buildseg(int &amp;v,int l,int r)
{
	if (!v) v=++TOT;
	if (r-l==1)
	{
		tmax[v]=tsum[v]=w[which[l]];
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	buildseg(lc[v],l,mid);
	buildseg(rc[v],mid,r);
	update(v);
}
void change(int v,int l,int r,int i,int x)
{
	if (r-l==1)
	{
		tmax[v]=tsum[v]=x;
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid) change(lc[v],l,mid,i,x);
	else change(rc[v],mid,r,i,x);
	update(v);
}
void find(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		if (tmax[v]&gt;ansmax) ansmax=tmax[v];
		anssum+=tsum[v];
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) find(lc[v],l,mid);
	if (ee&gt;mid) find(rc[v],mid,r);
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y);
		addedge(y,x);
	}
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;w[i]);
	dfs1(1);
	up[1]=1;
	dfs2(1);
	buildseg(i=0,1,n+1);
	scanf(&quot;%d\n&quot;,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		char s[10];
		scanf(&quot;%s%d%d\n&quot;,s,&amp;x,&amp;y);
		if (s[0]=='C')
		{
			change(1,1,n+1,pos[x],y);
			w[x]=y;
		}
		else
		{
			ansmax=-inf;
			anssum=0;
			while (up[x]!=up[y])
			{
				if (deep[up[x]]&lt;deep[up[y]]) {int t=x;x=y;y=t;}
				ww=pos[up[x]],ee=pos[x]+1;
				find(1,1,n+1);
				x=fa[up[x]];
			}
			if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
			ww=pos[y],ee=pos[x]+1;
			find(1,1,n+1);
			printf(&quot;%d\n&quot;,s[1]=='M'?ansmax:anssum);
		}
	}
	return 0;
}
<pre><h2>Problem1036</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define NN 31000
#define inf 99999999
int aa[NN*2][2],o[NN],fa[NN],tmax[NN],tsum[NN],w[NN],son[NN][2];
int n,m,tot,ans;
bool root[NN];
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int max(int a,int b) {return a&gt;b?a:b;}
void dfs(int v)
{
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dfs(y);
	}
}
void update(int v)
{
	int x=son[v][0],y=son[v][1];
	tmax[v]=max(w[v],max(tmax[x],tmax[y]));
	tsum[v]=w[v]+tsum[x]+tsum[y];
}
void rotate(int t,int p)
{
	int y=fa[t];
	if (root[y]) root[t]=true,root[y]=false;
	else
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]&gt;0) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!root[t])
	{
		int y=fa[t];
		if (root[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
}
int access(int x)
{
	int y=0;
	for (;x&gt;0;y=x,x=fa[x])
	{
		splay(x);
		root[son[x][1]]=true;
		son[x][1]=y;
		root[y]=false;
		update(x);
	}
	return y;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);	
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y);
		addedge(y,x);
	}
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;w[i]);
		root[i]=true;
		tmax[i]=tsum[i]=w[i];
	}
	tsum[0]=0,tmax[0]=-inf;
	dfs(1);
	for (scanf(&quot;%d\n&quot;,&amp;m);m;m--)
	{
		char s[10];
		scanf(&quot;%s%d%d\n&quot;,s,&amp;x,&amp;y);
		if (s[0]=='C')
		{
			w[x]=y;
			splay(x);
		}
		else if (s[1]=='M')
		{
			access(x);
			int k=access(y);
			ans=max(w[k],tmax[son[k][1]]);
			if (x!=k)
			{
				splay(x);
				ans=max(ans,tmax[x]);
			}
			printf(&quot;%d\n&quot;,ans);
		}
		else
		{
			access(x);
			int k=access(y);
			ans=w[k]+tsum[son[k][1]];
			if (x!=k)
			{
				splay(x);
				ans+=tsum[x];
			}
			printf(&quot;%d\n&quot;,ans);
		}
	}
	return 0;
}
<pre><h2>Problem1036</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define NN 31000
#define inf 99999999
int aa[NN*2][2],o[NN],fa[NN],tmax[NN],tsum[NN],w[NN],son[NN][2],stack[NN],cur[NN];
int n,m,tot,ans;
bool root[NN];
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int max(int a,int b) {return a&gt;b?a:b;}
void dfs(int v)
{
	/*for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dfs(y);
	}*/
	int top=1;
	stack[top]=v;
	cur[top]=o[v];
	while (top)
	{
		int x=stack[top];
		int p=cur[top];
		if (p==0) {top--;continue;}
		cur[top]=aa[p][0];
		int y=aa[p][1];
		if (y!=fa[x])
		{
			fa[y]=x;
			stack[++top]=y;
			cur[top]=o[y];
		}
	}
}
void update(int v)
{
	int x=son[v][0],y=son[v][1];
	tmax[v]=max(w[v],max(tmax[x],tmax[y]));
	tsum[v]=w[v]+tsum[x]+tsum[y];
}
void rotate(int t,int p)
{
	int y=fa[t];
	if (root[y]) root[t]=true,root[y]=false;
	else
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]&gt;0) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!root[t])
	{
		int y=fa[t];
		if (root[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
}
int access(int x)
{
	int y=0;
	for (;x&gt;0;y=x,x=fa[x])
	{
		splay(x);
		root[son[x][1]]=true;
		son[x][1]=y;
		root[y]=false;
		update(x);
	}
	return y;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);	
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y);
		addedge(y,x);
	}
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;w[i]);
		root[i]=true;
		tmax[i]=tsum[i]=w[i];
	}
	tsum[0]=0,tmax[0]=-inf;
	dfs(1);
	for (scanf(&quot;%d\n&quot;,&amp;m);m;m--)
	{
		char s[10];
		scanf(&quot;%s%d%d\n&quot;,s,&amp;x,&amp;y);
		if (s[0]=='C') w[x]=y,splay(x);
		else if (s[1]=='M')
		{
			access(x);
			int k=access(y);
			ans=max(w[k],tmax[son[k][1]]);
			if (x!=k)
			{
				splay(x);
				ans=max(ans,tmax[x]);
			}
			printf(&quot;%d\n&quot;,ans);
		}
		else
		{
			access(x);
			int k=access(y);
			ans=w[k]+tsum[son[k][1]];
			if (x!=k)
			{
				splay(x);
				ans+=tsum[x];
			}
			printf(&quot;%d\n&quot;,ans);
		}
	}
	return 0;
}
<pre><h2>Problem1036</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
using namespace std;
#define NN 301111
#define inf 99999999
int fa[NN],up[NN],deep[NN],size[NN],o[NN],aa[NN*2][2],tsum[NN],tmax[NN],w[NN];
int n,m,tot,sqrtn;
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
void dfs(int v)
{
	size[up[v]]++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		up[y]=size[up[v]]&lt;sqrtn?up[v]:y;
		dfs(y);
	}
}
void maintain(int v,int mm,int ss)
{
	//printf(&quot;%d\n&quot;,v);for (int i=1;i&lt;=50000000;i++);
	tmax[v]=mm=w[v]&gt;mm?w[v]:mm;
	tsum[v]=ss=ss+w[v];
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||up[y]!=up[v]) continue;
		maintain(y,mm,ss);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,x,y;
	scanf(&quot;%d&quot;,&amp;n);
	sqrtn=(int)sqrt(n);
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y);
		addedge(y,x);
	}
	for (i=1;i&lt;=n;scanf(&quot;%d&quot;,&amp;w[i++]));
	up[1]=1;
	dfs(1);
	for (i=1;i&lt;=n;i++)
		if (up[i]==i) maintain(i,-inf,0);
	for (scanf(&quot;%d&quot;,&amp;m);m;m--)
	{
		char s[10];
		scanf(&quot;%s %d%d\n&quot;,s+1,&amp;x,&amp;y);
		if (s[1]=='C')
		{
			w[x]=y;
			maintain(up[x],-inf,0);
		}
		else
		{
			int ans1=-inf,ans2=0;
			while (up[x]!=up[y])
			{
				if (deep[up[x]]&lt;deep[up[y]]) {int t=x;x=y;y=t;}
				if (tmax[x]&gt;ans1) ans1=tmax[x];
				ans2+=tsum[x];
				x=fa[up[x]];
			}
			while (x!=y)
			{
				if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
				if (w[x]&gt;ans1) ans1=w[x];
				ans2+=w[x];
				x=fa[x];
			}
			if (w[x]&gt;ans1) ans1=w[x];
			ans2+=w[x];
			if (s[2]=='M') printf(&quot;%d\n&quot;,ans1);
			else printf(&quot;%d\n&quot;,ans2);
		}
	}
	return 0;
}
<pre><h2>Problem1036</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
using namespace std;
#define NN 301111
#define inf 99999999
int fa[NN],up[NN],deep[NN],size[NN],o[NN],aa[NN*2][2],tsum[NN],tmax[NN],w[NN];
int n,m,tot,sqrtn;
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
void dfs(int v)
{
	size[up[v]]++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		up[y]=size[up[v]]&lt;sqrtn?up[v]:y;
		dfs(y);
	}
}
void maintain(int v,int mm,int ss)
{
	//printf(&quot;%d\n&quot;,v);for (int i=1;i&lt;=50000000;i++);
	tmax[v]=mm=w[v]&gt;mm?w[v]:mm;
	tsum[v]=ss=ss+w[v];
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||up[y]!=up[v]) continue;
		maintain(y,mm,ss);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,x,y;
	scanf(&quot;%d&quot;,&amp;n);
	sqrtn=(int)sqrt(n);
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y);
		addedge(y,x);
	}
	for (i=1;i&lt;=n;scanf(&quot;%d&quot;,&amp;w[i++]));
	up[1]=1;
	dfs(1);
	for (i=1;i&lt;=n;i++)
		if (up[i]==i) maintain(i,-inf,0);
	for (scanf(&quot;%d&quot;,&amp;m);m;m--)
	{
		char s[10];
		scanf(&quot;%s %d%d\n&quot;,s+1,&amp;x,&amp;y);
		if (s[1]=='C')
		{
			w[x]=y;
			if (up[x]==x) maintain(x,-inf,0);
			else maintain(x,tmax[fa[x]],tsum[fa[x]]);
		}
		else
		{
			int ans1=-inf,ans2=0;
			while (up[x]!=up[y])
			{
				if (deep[up[x]]&lt;deep[up[y]]) {int t=x;x=y;y=t;}
				if (tmax[x]&gt;ans1) ans1=tmax[x];
				ans2+=tsum[x];
				x=fa[up[x]];
			}
			while (x!=y)
			{
				if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
				if (w[x]&gt;ans1) ans1=w[x];
				ans2+=w[x];
				x=fa[x];
			}
			if (w[x]&gt;ans1) ans1=w[x];
			ans2+=w[x];
			if (s[2]=='M') printf(&quot;%d\n&quot;,ans1);
			else printf(&quot;%d\n&quot;,ans2);
		}
	}
	return 0;
}
<pre><h2>Problem1036</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
#define inf 999999999
const int NN=31111;
int fa[NN],son[NN][2],key[NN],o[NN],aa[NN*2][2],cur[NN],sta[NN],tmax[NN],tsum[NN];
int n,m,tot=1,top;
bool rrr[NN],tag[NN];
void out(int*a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
void dfs(int v)
{
	sta[top=1]=v;
	cur[v]=o[v];
	while (top)
	{
		v=sta[top];
		int p=cur[v],y=aa[p][1];
		if (!p) {top--;continue;}
		cur[v]=aa[p][0];
		if (y==fa[v]) continue;
		fa[y]=v;
		sta[++top]=y;
		cur[y]=o[y];
	}
}
void rev(int v)
{
	tag[v]=!tag[v];
	swap(son[v][0],son[v][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	rev(son[v][0]),rev(son[v][1]);
	tag[v]=false;
}
void update(int v)
{
	int x=son[v][0],y=son[v][1];
	tmax[v]=max(key[v],max(tmax[x],tmax[y]));
	tsum[v]=tsum[x]+tsum[y]+key[v];
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
	else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
}
void access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
}
void makeroot(int v)
{
	access(v);
	splay(v);
	rev(v);
}
void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	dfs(1);
	//printf(&quot;fa &quot;);out(fa,1,n);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;key[i]);
		rrr[i]=true;
		tmax[i]=tsum[i]=key[i];
	}
	tmax[0]=-inf,tsum[0]=0;
	for (scanf(&quot;%d\n&quot;,&amp;m);m;m--)
	{
		char s[10];
		scanf(&quot;%s%d%d\n&quot;,s+1,&amp;x,&amp;y);
		//printf(&quot;\n---------- %s --------------------------------------------------------------\n&quot;,s+1);
		if (s[1]=='Q'&amp;&amp;s[2]=='M')
		{
			makeroot(x);
			access(y),splay(y);
			printf(&quot;%d\n&quot;,tmax[y]);
		}
		else if (s[1]=='Q'&amp;&amp;s[2]=='S')
		{
			makeroot(x);
			access(y),splay(y);
			printf(&quot;%d\n&quot;,tsum[y]);
		}
		else
		{
			key[x]=y;
			splay(x);
		}
	}
	return 0;
}<pre><h2>Problem1038</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
#define ln printf(&quot;\n&quot;)
const DD eps=1e-7,dinf=1e10;;
const int NN=1111;
int n,m,now,num[2];
int dcmp(DD x)
{
	if (fabs(x)&lt;eps) return 0;
	return x&lt;0?-1:1;
}
struct point
{
	DD x,y;
	point(DD a=0,DD b=0) {x=a;y=b;}
	void out() {printf(&quot;%.3f %.3f  &quot;,x,y);}
	friend point operator +(point a,point b) {return point(a.x+b.x,a.y+b.y);}
	friend point operator -(point a,point b) {return point(a.x-b.x,a.y-b.y);}
	friend point operator *(DD t,point a) {return point(a.x*t,a.y*t);}
	friend DD operator %(point a,point b) {return a.x*b.y-b.x*a.y;}
} q[NN],b[2][NN],a[NN];
bool linesegxj(point P,point v,point A,point B)
{
	return dcmp(v%(A-P))*dcmp(v%(B-P))==-1;
}
point linejd(point P,point v,point Q,point w)
{
	point u=P-Q;
	DD t=(w%u)/(v%w);
	return P+t*v;
}
void ins(point P,point v)
{
	b[now][num[now]+1]=b[now][1];
	now^=1;
	num[now]=0;
	for (int i=1;i&lt;=num[now^1];i++)
	{
		point A=b[now^1][i],B=b[now^1][i+1];
		if (dcmp(v%(A-P)&gt;=0)) b[now][++num[now]]=A;
		if (linesegxj(P,v,A,B))
			b[now][++num[now]]=linejd(P,v,A,B-A);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j;
	for (i=1;i&lt;=n;i++) scanf(&quot;%lf&quot;,&amp;q[i].x);
	for (i=1;i&lt;=n;i++) scanf(&quot;%lf&quot;,&amp;q[i].y);
	now=0;num[now]=4;
	b[0][1]=point(-dinf,dinf);
	b[0][2]=point(-dinf,-dinf);
	b[0][3]=point(dinf,-dinf);
	b[0][4]=point(dinf,dinf);
	for (i=1;i&lt;n;i++)
		ins(q[i],q[i+1]-q[i]);
	m=num[now];
	for (i=1;i&lt;=m;i++) a[i]=b[now][i];
	//for (i=1;i&lt;=m;i++) a[i].out(),ln;
	a[m+1]=a[1];
	DD ans=dinf;
	for (i=1;i&lt;=m;i++)
		for (j=1;j&lt;n;j++)
			if (dcmp(a[i].x-q[j].x)*dcmp(a[i].x-q[j+1].x)&lt;=0)
			{
				point P=linejd(a[i],point(0,1),q[j],q[j+1]-q[j]);
				ans=min(ans,fabs(P.y-a[i].y));
			}
	//ln;printf(&quot;ans=%.3f\n&quot;,ans);ln;
	for (j=1;j&lt;=n;j++)
		for (i=1;i&lt;=m;i++)
			if (dcmp(q[j].x-a[i].x)*dcmp(q[j].x-a[i+1].x)&lt;=0)
			{
				point P=linejd(q[j],point(0,1),a[i],a[i+1]-a[i]);
				ans=min(ans,fabs(P.y-q[j].y));
				//printf(&quot;i=%d j=%d  P:&quot;,i,j);P.out();printf(&quot;\nans=%.3f\n&quot;,ans);
			}
	printf(&quot;%.3f\n&quot;,ans);
	return 0;
}<pre><h2>Problem1040</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define maa(a,b) ((a)&gt;(b)?(a):(b))
#define NN 1001111
#define LL long long
#define INF 9999999999999999ll
#define ln printf(&quot;\n&quot;)
int o[NN],aa[NN*2][2],low[NN],dfn[NN],from[NN],a[NN],b[NN],fa[NN];
int n,TIME,tot=1;
bool vt[NN];
LL f[NN],g[NN];
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
void out(LL *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%lld &quot;,a[i]);ln;}
void dfs(int v)
{
	int p,y;
	low[v]=dfn[v]=++TIME;
	vt[v]=true;
	for (p=o[v];p;p=aa[p][0])
	{
		y=aa[p][1];
		if (p==(from[v]^1)) continue;
		//printf(&quot;%d %d\n&quot;,v,y);
		if (vt[y]) low[v]=mii(low[v],dfn[y]);
		else
		{
			from[y]=p;
			fa[y]=v;
			dfs(y);
			low[v]=mii(low[v],low[y]);
		}
	}
	//printf(&quot;\n--------------------- dfsing %d -------------------\n&quot;,v);
	f[v]=a[v],g[v]=0;
	for (p=o[v];p;p=aa[p][0])
	{
		y=aa[p][1];
		if (p==(from[v]^1)) continue;
		if (p==from[y]&amp;&amp;low[y]&gt;dfn[v])
		{
			//printf(&quot;0\n&quot;);
			f[v]+=g[y];
			g[v]+=maa(g[y],f[y]);
		}
		else if (p!=from[y]&amp;&amp;dfn[y]&gt;dfn[v])
		{
			int i,x;
			LL t1,t2,t3,t4;
			b[0]=0;
			for (x=y;x!=v;x=fa[x]) b[++b[0]]=x;
			//printf(&quot;b &quot;);out(b,1,b[0]);printf(&quot;f &quot;);out(f,1,n);printf(&quot;g &quot;);out(g,1,n);ln;
			t1=0,t2=0;
			for (i=1;i&lt;=b[0];i++)
			{
				t3=t2+f[b[i]];
				t4=maa(t1,t2)+g[b[i]];
				//printf(&quot;t3=%lld t4=%lld\n&quot;,t3,t4);
				t1=t3,t2=t4;
			}
			g[v]+=maa(t1,t2);
			//printf(&quot;g[%d]=%lld\n&quot;,v,g[v]);
			t1=0,t2=-INF;
			for (i=1;i&lt;=b[0];i++)
			{
				t3=t2+f[b[i]];
				t4=maa(t1,t2)+g[b[i]];
				t1=t3,t2=t4;
			}
			f[v]+=t2;
			//printf(&quot;f[%d]=%lld\n&quot;,v,f[v]);
		}
	}
}
void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;a[i],&amp;x);
		addedge(i,x),addedge(x,i);
	}
	LL ans=0;
	for (i=1;i&lt;=n;i++)
		if (!vt[i]) dfs(i),ans+=maa(f[i],g[i]);
	//ln;printf(&quot;fa &quot;),out(fa,1,n);printf(&quot;dfn &quot;),out(dfn,1,n);printf(&quot;low &quot;),out(low,1,n);ln;
	//printf(&quot;f &quot;);out(f,1,n);printf(&quot;g &quot;);out(g,1,n);ln,ln;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1040</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define maa(a,b) ((a)&gt;(b)?(a):(b))
#define NN 1001111
#define LL long long
#define INF 9999999999999999ll
#define ln printf(&quot;\n&quot;)
int o[NN],aa[NN*2][2],low[NN],dfn[NN],from[NN],a[NN],b[NN],fa[NN];
int n,TIME,tot=1;
bool vt[NN];
LL f[NN],g[NN];
void dfs(int v)
{
	int p,y;
	low[v]=dfn[v]=++TIME;
	vt[v]=true;
	for (p=o[v];p;p=aa[p][0])
	{
		y=aa[p][1];
		if (p==(from[v]^1)) continue;
		if (vt[y]) low[v]=mii(low[v],dfn[y]);
		else
		{
			from[y]=p;
			fa[y]=v;
			dfs(y);
			low[v]=mii(low[v],low[y]);
		}
	}
	f[v]=a[v],g[v]=0;
	for (p=o[v];p;p=aa[p][0])
	{
		y=aa[p][1];
		if (p==(from[v]^1)) continue;
		if (p==from[y]&amp;&amp;low[y]&gt;dfn[v])
		{
			f[v]+=g[y];
			g[v]+=maa(g[y],f[y]);
		}
		else if (p!=from[y]&amp;&amp;dfn[y]&gt;dfn[v])
		{
			int i,x;
			LL t1,t2,t3,t4;
			b[0]=0;
			for (x=y;x!=v;x=fa[x]) b[++b[0]]=x;
			t1=0,t2=0;
			for (i=1;i&lt;=b[0];i++)
			{
				t3=t2+f[b[i]];
				t4=maa(t1,t2)+g[b[i]];
				t1=t3,t2=t4;
			}
			g[v]+=maa(t1,t2);
			t1=0,t2=-INF;
			for (i=1;i&lt;=b[0];i++)
			{
				t3=t2+f[b[i]];
				t4=maa(t1,t2)+g[b[i]];
				t1=t3,t2=t4;
			}
			f[v]+=t2;
		}
	}
}
void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;a[i],&amp;x);
		addedge(i,x),addedge(x,i);
	}
	LL ans=0;
	for (i=1;i&lt;=n;i++)
		if (!vt[i]) dfs(i),ans+=maa(f[i],g[i]);
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1040</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define maa(a,b) ((a)&gt;(b)?(a):(b))
#define NN 1001111
#define LL long long
#define INF 9999999999999999ll
int o[NN],aa[NN*2][2],low[NN],dfn[NN],from[NN],a[NN],b[NN],fa[NN];
int n,TIME,tot=1;
bool vt[NN];
LL f[NN],g[NN];
void dfs(int v)
{
	int p,y;
	low[v]=dfn[v]=++TIME;
	vt[v]=true;
	for (p=o[v];p;p=aa[p][0])
	{
		y=aa[p][1];
		if (p==(from[v]^1)) continue;
		if (vt[y]) low[v]=mii(low[v],dfn[y]);
		else
		{
			from[y]=p;
			fa[y]=v;
			dfs(y);
			low[v]=mii(low[v],low[y]);
		}
	}
	f[v]=a[v],g[v]=0;
	for (p=o[v];p;p=aa[p][0])
	{
		y=aa[p][1];
		if (p==(from[v]^1)) continue;
		if (p==from[y]&amp;&amp;low[y]&gt;dfn[v])
		{
			f[v]+=g[y];
			g[v]+=maa(g[y],f[y]);
		}
		else if (p!=from[y]&amp;&amp;dfn[y]&gt;dfn[v])
		{
			int i,x;
			LL t1,t2,t3,t4;
			b[0]=0;
			for (x=y;x!=v;x=fa[x]) b[++b[0]]=x;
			t1=0,t2=0;
			for (i=1;i&lt;=b[0];i++)
			{
				t3=t2+f[b[i]];
				t4=maa(t1,t2)+g[b[i]];
				t1=t3,t2=t4;
			}
			g[v]+=maa(t1,t2);
			t1=0,t2=-INF;
			for (i=1;i&lt;=b[0];i++)
			{
				t3=t2+f[b[i]];
				t4=maa(t1,t2)+g[b[i]];
				t1=t3,t2=t4;
			}
			f[v]+=t2;
		}
	}
}
void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;a[i],&amp;x);
		addedge(i,x),addedge(x,i);
	}
	LL ans=0;
	for (i=1;i&lt;=n;i++)
		if (!vt[i]) dfs(i),ans+=maa(f[i],g[i]);
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1041</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
using namespace std;
typedef long long LL;
LL R;
LL gcd(LL a,LL b) {return !b?a:gcd(b,a%b);}
LL check(LL n)
{
	//printf(&quot;check %I64d\n&quot;,n);
	LL res=0;
	for (LL i=1;i*i&lt;=n;i++)
	{
		LL x=i*i,y=n-x;
		LL tmp=sqrt(y);
		if (tmp*tmp!=y) continue;
		if (x&gt;=y) continue;
		if (gcd(x,y)==1) res++;//,printf(&quot;%I64d %I64d\n&quot;,x,y);;
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld&quot;,&amp;R);
	R&lt;&lt;=1;
	LL ans=0;
	for (LL i=1;i*i&lt;=R;i++) if (R%i==0)
	{
		ans+=check(R/i);
		if (i*i!=R) ans+=check(i);
	}
	printf(&quot;%lld\n&quot;,ans*4+4);
	return 0;
}<pre><h2>Problem1042</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define LL long long
#define ln printf(&quot;\n&quot;)
int a[5],b[5],num,m;
LL f[101111],ans,now;
void dfs(int t)
{
	if (t&gt;4)
	{
		if (num&amp;1) ans-=f[now];
		else ans+=f[now];
		return;
	}
	dfs(t+1);
	if (now-(b[t]+1)*a[t]&gt;=0)
	{
		now-=(b[t]+1)*a[t];
		num++;
		dfs(t+1);
		num--;
		now+=(b[t]+1)*a[t];
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,j,tes;
	for (i=1;i&lt;=4;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	f[0]=1;
	for (i=1;i&lt;=4;i++)
		for (j=0;j&lt;=100000;j++)
			if (j&gt;=a[i]) f[j]+=f[j-a[i]];
	//for (i=1;i&lt;=10;i++)printf(&quot;%lld &quot;,f[i]);ln;
	for (scanf(&quot;%d&quot;,&amp;tes);tes--;)
	{
		for (i=1;i&lt;=4;i++) scanf(&quot;%d&quot;,&amp;b[i]);
		scanf(&quot;%d&quot;,&amp;m);
		ans=0;
		now=m,num=0;
		dfs(1);
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}
<pre><h2>Problem1042</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define LL long long
#define ln printf(&quot;\n&quot;)
int a[5],b[5],num,m;
LL f[101111],ans,now;
void dfs(int t)
{
	if (t&gt;4)
	{
		if (num==0) return;
		if (num&amp;1) ans-=f[now];
		else ans+=f[now];
		return;
	}
	dfs(t+1);
	if (now-(b[t]+1)*a[t]&gt;=0)
	{
		now-=(b[t]+1)*a[t];
		num++;
		dfs(t+1);
		num--;
		now+=(b[t]+1)*a[t];
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,j,tes;
	for (i=1;i&lt;=4;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	f[0]=1;
	for (i=1;i&lt;=4;i++)
		for (j=0;j&lt;=100000;j++)
			if (j&gt;=a[i]) f[j]+=f[j-a[i]];
	//for (i=1;i&lt;=10;i++)printf(&quot;%lld &quot;,f[i]);ln;
	for (scanf(&quot;%d&quot;,&amp;tes);tes--;)
	{
		for (i=1;i&lt;=4;i++) scanf(&quot;%d&quot;,&amp;b[i]);
		scanf(&quot;%d&quot;,&amp;m);
		ans=f[m];
		now=m,num=0;
		dfs(1);
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}
<pre><h2>Problem1043</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define DD double
#define LD long double
#define NN 11000
const LD eps=1e-6;
const LD pai=3.141592653589793238;
LD r[NN];
int num,n;
struct point
{
	LD x,y;
	point (LD a=0,LD b=0) {x=a,y=b;}
	friend point operator * (LD t,point a) {a.x*=t;a.y*=t;return a;}
	friend point operator - (point a,point b) {a.x-=b.x;a.y-=b.y;return a;}
} a[NN];
LD dot(point a,point b) {return a.x*b.x+a.y*b.y;}
LD lenth(point a) {return sqrt(a.x*a.x+a.y*a.y);}
LD yuxiandingli(LD a,LD b,LD c)
{
	LD tmp=(a*a+b*b-c*c)/(2*a*b);
	return acos(tmp);
}
struct seg
{
	LD pos;
	bool flag;
	friend bool operator &lt; (seg a,seg b) {return a.pos&lt;b.pos;}
} b[NN*2];
void push(LD x,LD y)
{
	num++,b[num].pos=x,b[num].flag=true;
	num++,b[num].pos=y,b[num].flag=false;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j;
	for (i=1;i&lt;=n;i++)
	{
		DD qwe,asd,zxc;
		scanf(&quot;%lf%lf%lf&quot;,&amp;qwe,&amp;asd,&amp;zxc);
		r[i]=qwe,a[i].x=asd,a[i].y=zxc;
	}
	LD ans=0;
	for (i=1;i&lt;=n;i++)
	{
		//printf(&quot;\n----------------------------------------------\n&quot;);
		//printf(&quot;%.3f\n&quot;,(DD)ans);
		//printf(&quot;%d\n&quot;,i);
		LD all,cnt,now,last;
		num=0;
		bool cover=false;
		for (j=i+1;j&lt;=n;j++)
		{
			LD dd=lenth(a[i]-a[j]);
			if (r[j]-r[i]-dd&gt;-eps) {cover=true;break;}
			if (dd-r[i]-r[j]&gt;-eps) continue;
			if (r[i]-r[j]-dd&gt;-eps) continue;
			point v=a[j]-a[i];
			LD sita=atan2(v.y,v.x);
			LD alfa=yuxiandingli(dd,r[i],r[j]);
			LD t1=sita-alfa,t2=sita+alfa;
			//printf(&quot;%.3f %.3f\n&quot;,(DD)t1,(DD)t2);
			if (t1-t2&gt;eps) push(t1,pai),push(-pai,t2);
			else if (t2-pai&gt;eps) push(t1,pai),push(-pai,t2-pai*2);
			else if (t1+pai&lt;-eps) push(t1+pai*2,pai),push(-pai,t2);
			else push(t1,t2);
		}
		//printf(&quot;%d\n&quot;,num);
		if (cover) continue;
		sort(b+1,b+num+1);
		//printf(&quot;asdasdasd\n&quot;);
		//for (int ii=1;ii&lt;=num;ii++) printf(&quot;%.3f %d\n&quot;,(DD)b[ii].pos,b[ii].flag);
		all=2*pai*r[i];
		//printf(&quot;%d\n&quot;,i);
		if (num==0) {ans+=all;continue;}
		//printf(&quot;%.3f\n&quot;,(DD)all);
		cnt=0;
		now=0;
		last=-pai;
		for (j=1;j&lt;=num;j++)
		{
			if (now) cnt+=b[j].pos-last;
			if (b[j].flag) now++;else now--;
			last=b[j].pos;
			//printf(&quot;%d %.3f\n&quot;,j,(DD)cnt);
		}
		//printf(&quot;cnt=%.3f\n&quot;,(DD)cnt);
		ans+=(2*pai-cnt)/2/pai*all;
		//printf(&quot;%.3f\n&quot;,(DD)ans);
		//printf(&quot;%d\n&quot;,i);
	}
	printf(&quot;%.3f\n&quot;,(DD)ans);
	return 0;
}
<pre><h2>Problem1045</h2><pre>var
  a,s:array[0..1000000]of int64;
  n,sum,ans,temp:int64;
  i:longint;
procedure kp(l,r:longint);
var
  i,j:longint;
  x,y:int64;
begin
  i:=l;j:=r;
  x:=s[random(j-i+1)+i];
  repeat
    while s[i]&lt;x do inc(i);
    while s[j]&gt;x do dec(j);
    if i&lt;=j then
      begin
        y:=s[i];
        s[i]:=s[j];
        s[j]:=y;
        inc(i);
        dec(j);
      end;
  until i&gt;j;
  if i&lt;r then kp(i,r);
  if j&gt;l then kp(l,j);
end;
begin
 // assign(input,'sss.in');reset(input);
 // assign(output,'sss.out');rewrite(output);
  readln(n);
  for i:=1 to n do
    begin
      readln(a[i]);
      inc(sum,a[i]);
    end;
  sum:=sum div n;
  for i:=1 to n do a[i]:=a[i]-sum;
  s[0]:=0;
  for i:=1 to n do s[i]:=s[i-1]+a[i];
  kp(1,n);
  temp:=-s[(n+1)div 2];
  ans:=0;
  for i:=1 to n do ans:=ans+abs(temp+s[i]);
  writeln(ans);
  //close(input);close(output);
end.<pre><h2>Problem1046</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=10111;
int a[NN],b[NN],c[NN],f[NN],ans[NN];
int n,m,K;
int cha(int x)
{
	int l=1,r=n;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (c[mid]==x) return mid;
		if (x&lt;c[mid]) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
inline int getmax(int i)
{
	int res=0;
	for (;i;i-=i&amp;-i)
		if (c[i]&gt;res) res=c[i];
	return res;
}
inline void change(int i,int x)
{
	for (;i&lt;=n;i+=i&amp;-i)
		if (x&gt;c[i]) c[i]=x;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		b[n-i+1]=-a[i];
		c[i]=-a[i];
	}
	sort(c+1,c+n+1);
	for (i=1;i&lt;=n;i++) b[i]=cha(b[i]);
	//printf(&quot;b &quot;);for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,b[i]);ln;printf(&quot;c &quot;);for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,c[i]);ln;
	for (i=1;i&lt;=n;i++) c[i]=0;
	for (i=1;i&lt;=n;i++)
	{
		f[n-i+1]=getmax(b[i]-1)+1;
		change(b[i],f[n-i+1]);
	}
	//printf(&quot;f &quot;);for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,f[i]);ln;
	for (scanf(&quot;%d&quot;,&amp;m);m;m--)
	{
		scanf(&quot;%d&quot;,&amp;K);
		int cnt=0,last=0;
		for (i=1;i&lt;=n;i++)
			if (f[i]&gt;=K-cnt&amp;&amp;a[i]&gt;last)
				ans[++cnt]=a[i],last=a[i];
		if (cnt&lt;K) printf(&quot;Impossible&quot;);
		else for (i=1;i&lt;=K;i++)
			printf(i==K?&quot;%d&quot;:&quot;%d &quot;,ans[i]);
		printf(&quot;\n&quot;);
	}
	return 0;
}<pre><h2>Problem1047</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define inf 999999999
#define ln printf(&quot;\n&quot;)
const int NN=1011;
int a[NN][NN],ans[NN][NN][2],up[NN][NN],q[NN][2];
int n,m,K;
void work(int t)
{
	int i,j,head,tail;
	for (j=1;j&lt;=m;j++)
	{
		//printf(&quot;\n--------------------- j=%d ---------------------------------------\n&quot;,j);
		head=0,tail=0;
		for (i=1;i&lt;K;i++)
		{
			while (head&lt;tail&amp;&amp;a[i][j]&lt;=q[tail][0]) tail--;
			tail++,q[tail][0]=a[i][j],q[tail][1]=i;
		}
		//printf(&quot;%d %d\n&quot;,head,tail);
		for (i=K;i&lt;=n;i++)
		{
			while (head&lt;tail&amp;&amp;a[i][j]&lt;=q[tail][0]) tail--;
			tail++,q[tail][0]=a[i][j],q[tail][1]=i;
			while (head&lt;tail&amp;&amp;q[head+1][1]&lt;i-K+1) head++;
			up[i][j]=q[head+1][0];
		}
	}
	for (i=K;i&lt;=n;i++)
	{
		head=0,tail=0;
		for (j=1;j&lt;K;j++)
		{
			while (head&lt;tail&amp;&amp;up[i][j]&lt;=q[tail][0]) tail--;
			tail++,q[tail][0]=up[i][j],q[tail][1]=j;
		}
		for (j=K;j&lt;=m;j++)
		{
			while (head&lt;tail&amp;&amp;up[i][j]&lt;=q[tail][0]) tail--;
			tail++,q[tail][0]=up[i][j],q[tail][1]=j;
			while (head&lt;tail&amp;&amp;q[head+1][1]&lt;j-K+1) head++;
			ans[i][j][t]=q[head+1][0];
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;K);
	if (K&gt;mii(n,m)) K=mii(n,m);
	int i,j;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;a[i][j]);
	work(0);
	//ln;printf(&quot;up:\n&quot;);for(i=1;i&lt;=n;i++){for(j=1;j&lt;=m;j++)printf(&quot;%d &quot;,up[i][j]);ln;}ln;
	//ln;printf(&quot;ans[0]:\n&quot;);for(i=1;i&lt;=n;i++){for(j=1;j&lt;=m;j++)printf(&quot;%d &quot;,ans[i][j][0]);ln;}ln;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++) a[i][j]=-a[i][j];
	work(1);
	int res=inf;
	for (i=1;i&lt;=n;i++) if (i&gt;=K)
		for (j=1;j&lt;=m;j++) if (j&gt;=K)
		{
			int t=-ans[i][j][1]-ans[i][j][0];
			if (t&lt;res) res=t;
		}
	printf(&quot;%d\n&quot;,res);
	return 0;
}
<pre><h2>Problem1050</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
#define inf 1000000005
#define ln printf(&quot;\n&quot;)
const DD dinf=1e30;
const int NN=511,MM=5111;
int o[NN],aa[MM*2][3],que[NN],dl[NN],dist[NN],pre[NN];
int n,m,tot,head,tail,TIME,S,T;
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
struct edge
{
	int u,v,w;
	void in() {scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);}
	void add()
	{
		addedge(u,v,w),addedge(v,u,w);
		head=0,tail=2;
		que[1]=u,que[2]=v;
		TIME++;
	}
	friend bool operator &lt;(const edge &amp;a,const edge &amp;b) {return a.w&gt;b.w;}
} e[MM];
int spfa()
{
	while (head!=tail)
	{
		head++;if (head==NN+1) head=1;
		int x=que[head];
		dl[x]=TIME-1;
		if (dist[x]==-1) continue;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1],tmp=max(dist[x],aa[p][2]);
			//printf(&quot;%d %d\n&quot;,x,y);
			if (y==1||y==pre[x]) continue;
			if (dist[y]==-1)
			{
				pre[y]=x;
				dist[y]=max(dist[x],aa[p][2]);
				tail++;if (tail==NN+1) tail=1;
				que[tail]=y;
			}
			else if (dist[y]&gt;tmp)
			{
				pre[y]=x;
				dist[y]=tmp;
				if (dl[y]!=TIME)
				{
					dl[y]=TIME;
					tail++;if (tail==NN+1) tail=1;
					que[tail]=y;
				}
			}
		}
	}
	//printf(&quot;dist &quot;);for (int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,dist[i]);ln;
	return dist[T];
}
int gcd(int a,int b) {return !b?a:gcd(b,a%b);}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i;
	for (i=1;i&lt;=m;i++) e[i].in();
	scanf(&quot;%d%d&quot;,&amp;S,&amp;T);
	sort(e+1,e+m+1);
	for (i=1;i&lt;=n;i++) dist[i]=-1;
	dist[S]=0;
	DD ans=dinf;
	int fz,fm;
	for (i=1;i&lt;=m;i++)
	{
		//printf(&quot;\n------------------------------------------------------------\n&quot;);
		e[i].add();
		int tmp=spfa();
		//printf(&quot;tmp=%d\n&quot;,tmp);
		if (tmp==inf||tmp==-1) continue;
		if (1.0*tmp/e[i].w&lt;ans)
			ans=1.0*tmp/e[i].w,fz=tmp,fm=e[i].w;
	}
	if (ans&gt;dinf*0.5) {printf(&quot;IMPOSSIBLE\n&quot;);return 0;}
	int tmp=gcd(fz,fm);
	fz/=tmp,fm/=tmp;
	if (fm==1) printf(&quot;%d\n&quot;,fz);
	else printf(&quot;%d/%d\n&quot;,fz,fm);
	return 0;
}<pre><h2>Problem1050</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
#define inf 1000000005
#define ln printf(&quot;\n&quot;)
const DD dinf=1e30;
const int NN=511,MM=5111;
int o[NN],aa[MM*2][3],que[NN],dl[NN],dist[NN];
int n,m,tot,head,tail,TIME,S,T;
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
struct edge
{
	int u,v,w;
	void in() {scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);}
	void add()
	{
		addedge(u,v,w),addedge(v,u,w);
		head=0,tail=2;
		que[1]=u,que[2]=v;
		TIME++;
	}
	friend bool operator &lt;(const edge &amp;a,const edge &amp;b) {return a.w&gt;b.w;}
} e[MM];
int spfa()
{
	while (head!=tail)
	{
		head++;if (head==NN+1) head=1;
		int x=que[head];
		dl[x]=TIME-1;
		if (dist[x]==-1) continue;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1],tmp=max(dist[x],aa[p][2]);
			if (dist[y]&gt;tmp)
			{
				dist[y]=tmp;
				if (dl[y]!=TIME)
				{
					dl[y]=TIME;
					tail++;if (tail==NN+1) tail=1;
					que[tail]=y;
				}
			}
		}
	}
	return dist[T];
}
int gcd(int a,int b) {return !b?a:gcd(b,a%b);}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i;
	for (i=1;i&lt;=m;i++) e[i].in();
	scanf(&quot;%d%d&quot;,&amp;S,&amp;T);
	sort(e+1,e+m+1);
	for (i=1;i&lt;=n;i++) dist[i]=inf;
	dist[S]=0;
	DD ans=dinf;
	int fz,fm;
	for (i=1;i&lt;=m;i++)
	{
		e[i].add();
		int tmp=spfa();
		if (tmp==inf) continue;
		if (1.0*tmp/e[i].w&lt;ans)
			ans=1.0*tmp/e[i].w,fz=tmp,fm=e[i].w;
	}
	if (ans&gt;dinf*0.5) {printf(&quot;IMPOSSIBLE\n&quot;);return 0;}
	int tmp=gcd(fz,fm);
	fz/=tmp,fm/=tmp;
	if (fm==1) printf(&quot;%d\n&quot;,fz);
	else printf(&quot;%d/%d\n&quot;,fz,fm);
	return 0;
}<pre><h2>Problem1051</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define mii(a,b) (a&lt;b?a:b)
const int NN=10011,MM=50011;
int dfn[NN],low[NN],sta[NN],belong[NN],out[NN],o[NN],aa[MM*2][2],num[NN];
int n,m,tot=1,top,TIME,cnt;
bool vt[NN];
struct edge {int a,b;} e[MM];
void dfs(int v)
{
	vt[v]=true;
	dfn[v]=low[v]=++TIME;
	sta[++top]=v;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!vt[y])
		{
			vt[y]=true;
			dfs(y);
			low[v]=mii(low[v],low[y]);
		}
		else if (!belong[y])
			low[v]=mii(low[v],dfn[y]);
	}
	if (low[v]==dfn[v])
	{
		cnt++;
		while (sta[top+1]!=v)
		{
			int k=sta[top--];
			belong[k]=cnt;
			num[cnt]++;
		}
	}
}
void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;e[i].a,&amp;e[i].b);
		addedge(e[i].a,e[i].b);
	}
	for (i=1;i&lt;=n;i++)
		if (!vt[i]) dfs(i);
	for (i=1;i&lt;=m;i++)
		if (belong[e[i].a]!=belong[e[i].b])
			out[belong[e[i].a]]++;
	//for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,belong[i]);printf(&quot;\n&quot;);
	int t=0;
	for (i=1;i&lt;=cnt;i++)
		if (out[i]==0) t++;
	if (t&gt;1) {printf(&quot;0\n&quot;);return 0;}
	for (i=1;i&lt;=cnt;i++)
		if (out[i]==0) {printf(&quot;%d\n&quot;,num[i]);return 0;}
	return 0;
}<pre><h2>Problem1051</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=11111,MM=51111;
int o[NN],aa[MM][2],low[NN],dfn[NN],sta[NN],num[NN],belong[NN],du[NN];
int n,m,tot,TIME,cnt,top;
bool vt[NN];
struct edge
{
	int u,v;
} e[MM];
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs(int v)
{
	vt[v]=true;
	dfn[v]=low[v]=++TIME;
	sta[++top]=v;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!vt[y])
		{
			dfs(y);
			if (low[y]&lt;low[v]) low[v]=low[y];
		}
		else if (!belong[y])
			low[v]=min(low[v],dfn[y]);
	}
	if (low[v]==dfn[v])
	{
		cnt++;
		while (sta[top+1]!=v)
		{
			num[cnt]++;
			belong[sta[top--]]=cnt;
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;e[i].u,&amp;e[i].v);
		addedge(e[i].u,e[i].v);
	}
	for (i=1;i&lt;=n;i++)
		if (!vt[i]) dfs(i);
	//printf(&quot;belong &quot;);for(i=1;i&lt;=n;i++) printf(&quot;%d &quot;,belong[i]);ln;
	for (i=1;i&lt;=m;i++)
		if (belong[e[i].u]!=belong[e[i].v])
			du[belong[e[i].u]]++;
	int t=0;
	for (i=1;i&lt;=cnt;i++)
		if (du[i]==0) t++;
	if (t&gt;1) {printf(&quot;0\n&quot;);return 0;}
	for (i=1;i&lt;=cnt;i++)
		if (du[i]==0) printf(&quot;%d\n&quot;,num[i]);
	return 0;
}<pre><h2>Problem1051</h2><pre>program popular;
const
  inf=100000;
var
  n,m,a,b,top,number,num,i,k,t:longint;
  aa,bb,cc:array[1..inf,0..1] of longint;
  dfn,o1,o2,o3:array[1..inf] of longint;
  tot1,tot2,tot3:longint;
  inz:array[1..inf] of boolean;
  zhan,low,kind,outt:array[1..inf] of longint;
  ans,count,tmp:longint;

  function min(a,b:longint):longint;
    begin
      if a&gt;b then exit(b);
      exit(a);
    end;
  procedure addedge(x,y,num:longint);
    begin
      case num of
        1:begin
            inc(tot1); aa[tot1,1]:=y; aa[tot1,0]:=o1[x]; o1[x]:=tot1;
          end;
        2:begin
            inc(tot2); bb[tot2,1]:=y; bb[tot2,0]:=o2[x]; o2[x]:=tot2;
          end;
        3:begin
            inc(tot3); cc[tot3,1]:=y; cc[tot3,0]:=o3[x]; o3[x]:=tot3;
            inc(outt[x]);
          end;
      end;
    end;
  procedure dfs(x:longint);
    var
      t,k:longint;
    begin
      inc(number);
      dfn[x]:=number;
      low[x]:=number;
      k:=o1[x];
      inc(top);
      zhan[top]:=x;
      inz[x]:=true;
      while k&lt;&gt;0 do
        begin
          t:=aa[k,1];
          if dfn[t]=0 then
            begin
              dfs(t);
              low[x]:=min(low[x],low[t]);
            end
          else
            begin
              if inz[t] then low[x]:=min(low[x],low[t]);
            end;
          k:=aa[k,0];
        end;
      if dfn[x]=low[x] then
        begin
          inc(num);
          while zhan[top]&lt;&gt;x do
            begin
              t:=zhan[top];
              kind[t]:=num;
              addedge(num,t,2);
              inz[t]:=false;
              dec(top);
            end;
          t:=zhan[top];
          kind[t]:=num;
          addedge(num,t,2);
          inz[t]:=false;
          dec(top);
        end;
    end;

begin
  readln(n,m);
  for i:=1 to m do
    begin
      readln(a,b);
      addedge(a,b,1);
    end;
  for i:=1 to n do
    if dfn[i]=0 then
      dfs(i);
  for i:=1 to n do
    begin
      k:=o1[i];
      while k&lt;&gt;0 do
        begin
          t:=aa[k,1];
          if kind[i]&lt;&gt;kind[t] then
            begin
              addedge(kind[i],kind[t],3);
            end;
          k:=aa[k,0];
        end;
    end;
  for i:=1 to num do
    begin
      if outt[i]=0 then
        begin
          inc(count);
          k:=o2[i];
          while k&lt;&gt;0 do
            begin
              inc(ans);
              k:=bb[k,0];
            end;
        end;
    end;
  if count&gt;1 then writeln(0)
    else writeln(ans);
end.
















<pre><h2>Problem1051</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=11111,MM=51111;
int o[NN],aa[MM][2],low[NN],dfn[NN],sta[NN],num[NN],belong[NN],du[NN];
int n,m,tot,TIME,cnt,top;
bool vt[NN];
struct edge
{
    int u,v;
} e[MM];
inline void addedge(int p,int q)
{
    tot++;
    aa[tot][1]=q;
    aa[tot][0]=o[p];
    o[p]=tot;
}
void dfs(int v)
{
    vt[v]=true;
    dfn[v]=low[v]=++TIME;
    sta[++top]=v;
    for (int p=o[v];p;p=aa[p][0])
    {
        int y=aa[p][1];
        if (!vt[y])
        {
            dfs(y);
            if (low[y]&lt;low[v]) low[v]=low[y];
        }
        else if (!belong[y])
            low[v]=min(low[v],dfn[y]);
    }
    if (low[v]==dfn[v])
    {
        cnt++;
        while (sta[top+1]!=v)
        {
            num[cnt]++;
            belong[sta[top--]]=cnt;
        }
    }
}
int main()
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    int i;
    for (i=1;i&lt;=m;i++)
    {
        scanf(&quot;%d%d&quot;,&amp;e[i].u,&amp;e[i].v);
        addedge(e[i].u,e[i].v);
    }
    for (i=1;i&lt;=n;i++)
        if (!vt[i]) dfs(i);
    //printf(&quot;belong &quot;);for(i=1;i&lt;=n;i++) printf(&quot;%d &quot;,belong[i]);ln;
    for (i=1;i&lt;=m;i++)
        if (belong[e[i].u]!=belong[e[i].v])
            du[belong[e[i].u]]++;
    int t=0;
    for (i=1;i&lt;=cnt;i++)
        if (du[i]==0) t++;
    if (t&gt;1) {printf(&quot;0\n&quot;);return 0;}
    for (i=1;i&lt;=cnt;i++)
        if (du[i]==0) printf(&quot;%d\n&quot;,num[i]);
    return 0;
}
<pre><h2>Problem1051</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=11111,MM=51111;
int o[NN],aa[MM][2],low[NN],dfn[NN],sta[NN],num[NN],belong[NN],du[NN];
int n,m,tot,TIME,cnt,top;
bool vt[NN];
struct edge
{
    int u,v;
} e[MM];
inline void addedge(int p,int q)
{
    tot++;
    aa[tot][1]=q;
    aa[tot][0]=o[p];
    o[p]=tot;
}
void dfs(int v)
{
    vt[v]=true;
    dfn[v]=low[v]=++TIME;
    sta[++top]=v;
    for (int p=o[v];p;p=aa[p][0])
    {
        int y=aa[p][1];
        if (!vt[y])
        {
            dfs(y);
            if (low[y]&lt;low[v]) low[v]=low[y];
        }
        else
            low[v]=min(low[v],dfn[y]);
    }
    if (low[v]==dfn[v])
    {
        cnt++;
        while (sta[top+1]!=v)
        {
            num[cnt]++;
            belong[sta[top--]]=cnt;
        }
    }
}
int main()
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    int i;
    for (i=1;i&lt;=m;i++)
    {
        scanf(&quot;%d%d&quot;,&amp;e[i].u,&amp;e[i].v);
        addedge(e[i].u,e[i].v);
    }
    for (i=1;i&lt;=n;i++)
        if (!vt[i]) dfs(i);
    //printf(&quot;belong &quot;);for(i=1;i&lt;=n;i++) printf(&quot;%d &quot;,belong[i]);ln;
    for (i=1;i&lt;=m;i++)
        if (belong[e[i].u]!=belong[e[i].v])
            du[belong[e[i].u]]++;
    int t=0;
    for (i=1;i&lt;=cnt;i++)
        if (du[i]==0) t++;
    if (t&gt;1) {printf(&quot;0\n&quot;);return 0;}
    for (i=1;i&lt;=cnt;i++)
        if (du[i]==0) printf(&quot;%d\n&quot;,num[i]);
    return 0;
}
<pre><h2>Problem1055</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const char h[4]={'W','I','N','G'};
int n,a[4];
char s[205],go[4][17][2];
bool can[205][205][4],vt[205][205][4];
int f(char ch)
{
	for (int i=0;i&lt;4;i++)
		if (h[i]==ch) return i;
	return 123123123;
}
bool dp(int l,int r,int c)
{
	if (l==r) return f(s[l])==c;
	if (vt[l][r][c]) return can[l][r][c];
	vt[l][r][c]=true;
	bool &amp;res=can[l][r][c];
	for (int i=1;i&lt;=a[c];i++)
		for (int j=l;j&lt;r;j++)
			if (dp(l,j,f(go[c][i][0]))&amp;&amp;dp(j+1,r,f(go[c][i][1])))
				{res=true;break;}
	//printf(&quot;dp %d %d %d = %d\n&quot;,l,r,c,res);
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,j;
	for (i=0;i&lt;4;i++) scanf(&quot;%d&quot;,&amp;a[i]);scanf(&quot;\n&quot;);
	for (i=0;i&lt;4;i++)
		for (j=1;j&lt;=a[i];j++) scanf(&quot;%s\n&quot;,go[i][j]);
	scanf(&quot;%s&quot;,s+1);
	n=strlen(s+1);
	bool flag=false;
	for (i=0;i&lt;4;i++)
		if (dp(1,n,i))
		{
			flag=true;
			printf(&quot;%c&quot;,h[i]);
		}
	if (!flag) printf(&quot;The name is wrong!\n&quot;);
	return 0;
}<pre><h2>Problem1057</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define NN 2011
#define maa(a,b) ((a)&gt;(b)?(a):(b))
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define sqr(x) ((x)*(x))
int a[NN][NN],left[NN][NN],right[NN][NN],up[NN][NN];
int n,m,i,j,ans1,ans2,now;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;a[i][j]);
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
			if ((i+j)%2==0) a[i][j]^=1;
	//for(i=1;i&lt;=n;i++){for(j=1;j&lt;=m;j++)printf(&quot;%d &quot;,a[i][j]);printf(&quot;\n&quot;);}
	for (j=1;j&lt;=m;j++) left[0][j]=1,right[0][j]=m;
	ans1=ans2=0;
	for (i=1;i&lt;=n;i++)
	{
		now=0;
		for (j=1;j&lt;=m;j++)
		{
			if (a[i][j]==0)
			{
				up[i][j]=up[i-1][j]+1;
				left[i][j]=maa(now+1,left[i-1][j]);
			}
			else
			{
				up[i][j]=0;
				left[i][j]=1;
				now=j;
			}
		}
		now=m+1;
		for (j=m;j;j--)
		{
			if (a[i][j]==0)
			{
				right[i][j]=mii(now-1,right[i-1][j]);
				int c=right[i][j]-left[i][j]+1,k=up[i][j],b=mii(c,k);
				ans1=maa(ans1,sqr(b));
				ans2=maa(ans2,c*k);
			}
			else
			{
				right[i][j]=m;
				now=j;
			}
		}
	}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++) a[i][j]^=1;
	for (i=1;i&lt;=n;i++)
	{
		now=0;
		for (j=1;j&lt;=m;j++)
		{
			if (a[i][j]==0)
			{
				up[i][j]=up[i-1][j]+1;
				left[i][j]=maa(now+1,left[i-1][j]);
			}
			else
			{
				up[i][j]=0;
				left[i][j]=1;
				now=j;
			}
		}
		now=m+1;
		for (j=m;j;j--)
		{
			if (a[i][j]==0)
			{
				right[i][j]=mii(now-1,right[i-1][j]);
				int c=right[i][j]-left[i][j]+1,k=up[i][j],b=mii(c,k);
				ans1=maa(ans1,sqr(b));
				ans2=maa(ans2,c*k);
			}
			else
			{
				right[i][j]=m;
				now=j;
			}
		}
	}
	printf(&quot;%d\n%d\n&quot;,ans1,ans2);
	return 0;
}
<pre><h2>Problem1057</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=2011;
int a[NN][NN],left[NN][NN],right[NN][NN],up[NN][NN];
int n,m;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j;
	for (i=1;i&lt;=n;i++) for (j=1;j&lt;=m;j++)
	{
		char ch=getchar();
		while (ch!='0'&amp;&amp;ch!='1') ch=getchar();
		a[i][j]=(ch=='1');
		if ((i+j+1)&amp;1) a[i][j]^=1;
	}
	//printf(&quot;a:\n&quot;);for(i=1;i&lt;=n;i++){for(j=1;j&lt;=m;j++)printf(&quot;%d &quot;,a[i][j]);ln;}ln;
	for (i=1;i&lt;=m;i++) right[0][i]=m+1;
	int ans1=0,ans2=0;
	for (i=1;i&lt;=n;i++)
	{
		int now=0;
		for (j=1;j&lt;=m;j++)
			if (a[i][j]==1)
			{
				up[i][j]=0;
				left[i][j]=1,now=j;
			}
			else
			{
				up[i][j]=up[i-1][j]+1;
				left[i][j]=max(now+1,left[i-1][j]);
			}
		now=m+1;
		for (j=m;j;j--)
			if (a[i][j]==1)
			{
				right[i][j]=m;
				now=j;
			}
			else
			{
				right[i][j]=min(now-1,right[i-1][j]);
				int a=right[i][j]-left[i][j]+1,b=up[i][j];
				ans1=max(ans1,min(a,b)*min(a,b));
				ans2=max(ans2,a*b);
			}
	}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++) a[i][j]^=1;
	for (i=1;i&lt;=n;i++)
	{
		int now=0;
		for (j=1;j&lt;=m;j++)
			if (a[i][j]==1)
			{
				up[i][j]=0;
				left[i][j]=1,now=j;
			}
			else
			{
				up[i][j]=up[i-1][j]+1;
				left[i][j]=max(now+1,left[i-1][j]);
			}
		now=m+1;
		for (j=m;j;j--)
			if (a[i][j]==1)
			{
				right[i][j]=m;
				now=j;
			}
			else
			{
				right[i][j]=min(now-1,right[i-1][j]);
				int a=right[i][j]-left[i][j]+1,b=up[i][j];
				ans1=max(ans1,min(a,b)*min(a,b));
				ans2=max(ans2,a*b);
			}
	}
	//printf(&quot;left:\n&quot;);for(i=1;i&lt;=n;i++){for(j=1;j&lt;=m;j++)printf(&quot;%d &quot;,left[i][j]);ln;}ln;
	printf(&quot;%d\n%d\n&quot;,ans1,ans2);
	return 0;
}<pre><h2>Problem1058</h2><pre>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#define MAXN 500005
#define INF 1000000007
using namespace std;
int n, m;
set&lt;int&gt;s, ss;
map&lt;int, int&gt;mp;
vector&lt;int&gt;g[MAXN];
int a[MAXN], b[MAXN];
int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    int mg = INF, ms = INF, pos, val;
    for(int i = 0; i &lt; n; i++)
    {
        scanf(&quot;%d&quot;, &amp;a[i]);
        ss.insert(a[i]);
        b[i] = a[i];
        if(i)
        {
            int k = abs(a[i] - a[i - 1]);
            s.insert(k);
            mp[k]++;
        }
    }
    sort(b, b + n);
    for(int i = 1; i &lt; n; i++)
        ms = min(ms, b[i] - b[i - 1]);
    mg = *s.begin();
    char op[33];
    while(m--)
    {
        scanf(&quot;%s&quot;, op);
        if(op[4] == 'R')
        {
            scanf(&quot;%d%d&quot;, &amp;pos, &amp;val);
            pos--;
            g[pos].push_back(val);
            if(ms)
            {set&lt;int&gt;::iterator it = ss.lower_bound(val);
             
            if(it != ss.begin())
            {
                if(it == ss.end())
                {
                    it--;
                    ms = min(ms, abs(val - *it));
                }
                else
                {
                    int x = *it;
                    it--;
                    int y = *it;
                    ms = min(ms, abs(x - val));
                    ms = min(ms, abs(y - val));
                }
            }
            else ms = min(ms, abs(val - *ss.begin()));
            }
            ss.insert(val);
            int x, y = INF;
            if(g[pos].size() == 1) x = a[pos];
            else x = g[pos][g[pos].size() - 2];
            if(pos + 1 &lt; n)
            {
                y = a[pos + 1];
                int k = abs(x - y);
                mp[k]--;
                if(mp[k] == 0) s.erase(k);
                k = abs(x - val);
                s.insert(k);
                mp[k]++;
                k = abs(y - val);
                s.insert(k);
                mp[k]++;
                mg = *s.begin();
            }
            else
            {
                int k = abs(x - val);
                s.insert(k);
                mp[k]++;
                mg = *s.begin();
            }
        }
        else if(op[4] == 'G') printf(&quot;%d\n&quot;, mg);
        else printf(&quot;%d\n&quot;, ms);
    }
    return 0;
}<pre><h2>Problem1059</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 999999999
#define mii(a,b) ((a)&lt;(b)?(a):(b))
const int NN=405,MM=40111;
int q[NN],o[NN],cur[NN],deep[NN],aa[MM*2][3];
int tes,n,tot,S,T;
bool bfs()
{
	int head=0,tail=1;
	q[1]=S;
	memset(deep,0,sizeof(deep));
	deep[S]=1;
	while (head&lt;tail)
	{
		int x=q[++head];
		cur[x]=o[x];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (!deep[y]&amp;&amp;aa[p][2])
				deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[T];
}
int dfs(int v,int f)
{
	if (v==T) return f;
	int res=0;
	for (int &amp;p=cur[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]!=deep[v]+1||!aa[p][2]) continue;
		int tmp=dfs(y,mii(f,aa[p][2]));
		f-=tmp,aa[p][2]-=tmp;
		aa[p^1][2]+=tmp,res+=tmp;
		if (!f) break;
	}
	if (!res) deep[v]=inf;
	return res;
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v)
{
	//printf(&quot;add  %d %d %d\n&quot;,p,q,v);
	addedge(p,q,v);
	addedge(q,p,0);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		memset(o,0,sizeof(o));
		tot=1;
		int i,j,x;
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=n;j++)
			{
				scanf(&quot;%d&quot;,&amp;x);
				if (x) add(i,j+n,inf);
			}
		S=2*n+1,T=S+1;
		for (i=1;i&lt;=n;i++) add(S,i,1),add(i+n,T,1);
		int ans=0;
		while (bfs()) ans+=dfs(S,inf);
		if (ans==n) printf(&quot;Yes\n&quot;);
		else printf(&quot;No\n&quot;);
	}
	return 0;
}<pre><h2>Problem1061</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;cmath&gt;

#define eps 1e-7
#define INF 1e10

using namespace std;

int n,m;


namespace Lp{
	double A[10100][1010],b[10100],c[1010],v;
	void print()
	{
		return;
		for(int i=1;i&lt;=n;i++) printf(&quot;%lf &quot;,c[i]);puts(&quot;&quot;);
		for(int i=1;i&lt;=m;i++){
			for(int j=1;j&lt;=n;j++){
				printf(&quot;%lf &quot;,A[i][j]);
			}puts(&quot;&quot;);
		}
		for(int i=1;i&lt;=m;i++) printf(&quot;%lf &quot;,b[i]);puts(&quot;&quot;);
		puts(&quot;&quot;);
	}
	void pivot(int l,int e){
		int i,j;
		b[l]/=A[l][e];
		for(i=1;i&lt;=n;i++)
			if(i!=e)
				A[l][i]/=A[l][e];
		A[l][e]=1/A[l][e];
		for(i=1;i&lt;=m;i++){
			if(i!=l&amp;&amp;fabs(A[i][e])&gt;eps)
			{
				b[i]-=A[i][e]*b[l];
				for(j=1;j&lt;=n;j++)
					if(j!=e)
						A[i][j]-=A[i][e]*A[l][j];
				A[i][e]=-A[i][e]*A[l][e];
			}
		}
		v+=c[e]*b[l];
		for(i=1;i&lt;=n;i++)
			if(i!=e)
				c[i]-=c[e]*A[l][i];
		c[e]=-c[e]*A[l][e];
		print();
	}
	double Simplex(){
		int i,l,e;
		while(1)
		{
			for(i=1;i&lt;=n;i++)
				if(c[i]&gt;eps) break;
			if((e=i)==n+1) return v;
			double temp=INF;
			for(i=1;i&lt;=m;i++)
				if(A[i][e]&gt;eps&amp;&amp;b[i]/A[i][e]&lt;temp)
					temp=b[i]/A[i][e],l=i;
			if(temp==INF) return INF;
			pivot(l,e);
		}
	}
}

int main()
{
	using namespace Lp;
	int i,j,x,y,z;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(i=1;i&lt;=n;i++) 
		scanf(&quot;%lf&quot;,&amp;c[i]);
	for(i=1;i&lt;=m;i++){
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		for(j=x;j&lt;=y;j++)
			A[i][j]=1;
		b[i]=z;
	}
	print();
	double ans=Simplex();
	printf(&quot;%d\n&quot;,(int)(ans+0.5));
	return 0;
}
<pre><h2>Problem1064</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int NN=101111,MM=1001111;
int o[NN],aa[MM*2][3],f[NN];
int n,m,tot,maxx,minx,ans1,ans2;
bool vt[NN];
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int gcd(int a,int b) {return !b?a:gcd(b,a%b);}
void dfs1(int v)
{
	vt[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (vt[y]) ans1=gcd(ans1,abs(f[v]+aa[p][2]-f[y]));
		else f[y]=f[v]+aa[p][2],dfs1(y);
	}
}
void dfs2(int v)
{
	vt[v]=true;
	maxx=max(maxx,f[v]);
	minx=min(minx,f[v]);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!vt[y]) f[y]=f[v]+aa[p][2],dfs2(y);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y,1),addedge(y,x,-1);
	}
	ans1=0;
	for (i=1;i&lt;=n;i++)
		if (!vt[i]) dfs1(i);
	//printf(&quot;ans1=%d\n&quot;,ans1);
	if (ans1&gt;0)
	{
		ans2=3;
		while (ans2&lt;ans1&amp;&amp;ans1%ans2) ans2++;
	}
	else
	{
		memset(vt,0,sizeof(vt));
		memset(f,0,sizeof(0));
		for (i=1;i&lt;=n;i++) if (!vt[i])
		{
			maxx=minx=0;
			dfs2(i);
			ans1+=maxx-minx+1;
		}
		ans2=3;
	}
	if (ans1&lt;3) printf(&quot;-1 -1\n&quot;);
	else printf(&quot;%d %d\n&quot;,ans1,ans2);
	return 0;
}<pre><h2>Problem1069</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
typedef double DD;
const DD eps=1e-7;
const int NN=4111;
int n,num;
struct point
{
	DD x,y;
	void in() {scanf(&quot;%lf%lf&quot;,&amp;x,&amp;y);}
	void out() {printf(&quot;%.3f %.3f\n&quot;,x,y);}
	friend bool operator &lt;(point a,point b) {return fabs(a.x-b.x)&lt;eps?a.y&lt;b.y:a.x&lt;b.x;}
	friend point operator -(point a,point b) {a.x-=b.x;a.y-=b.y;return a;}
	friend DD operator %(point a,point b) {return a.x*b.y-b.x*a.y;}
} a[NN],b[NN];
DD calc(point A,point B,point C,point D)
{
	DD res=A%B+B%C+C%D+D%A;
	return fabs(res)*0.5;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i;
	for (i=1;i&lt;=n;i++) a[i].in();
	sort(a+1,a+n+1);
	//for (i=1;i&lt;=n;i++) a[i].out();ln;
	for (i=1;i&lt;=n;i++)
	{
		while (num&gt;1&amp;&amp;(b[num]-b[num-1])%(a[i]-b[num-1])&lt;eps) num--;
		b[++num]=a[i];
	}
	int t=num;
	for (i=n-1;i;i--)
	{
		while (num&gt;t&amp;&amp;(b[num]-b[num-1])%(a[i]-b[num-1])&lt;eps) num--;
		b[++num]=a[i];
	}
	num--;
	for (i=1;i&lt;=num;i++) b[i+num]=b[i];
	//for (i=1;i&lt;=num;i++) b[i].out();ln;
	DD ans=0;
	for (i=1;i&lt;num;i++)
	{
		int n1=i,n2=i+1;
		for (int j=i+1;j&lt;=num;j++)
		{
			while ((b[j]-b[i])%(b[n2+1]-b[i])&gt;(b[j]-b[i])%(b[n2]-b[i])) n2++;
			while ((b[n1+1]-b[i])%(b[j]-b[i])&gt;(b[n1]-b[i])%(b[j]-b[i])) n1++;
			//printf(&quot;%d %d %d\n&quot;,j,n1,n2);printf(&quot;%.3f\n&quot;,(b[j]-b[i])%(b[n2+1]-b[i]));(b[j]-b[i]).out(),(b[n2+1]-b[i]).out();
			ans=max(ans,calc(b[i],b[n1],b[j],b[n2]));
		}
	}
	printf(&quot;%.3f\n&quot;,ans);
	return 0;
}<pre><h2>Problem1070</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf=99999999;
int aa[1000000][4],o[100000],dist[100000],a[1000][1000],hao[1000][1000],pre[100000],q[1000000];
bool dl[100000];
int n,m,i,j,k,num,S,T,head,tail,tot,ans;
int min(int a,int b) {return a&lt;b?a:b;}
void add(int p,int q,int v,int cost)
{
	++tot;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][3]=cost;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void addedge(int p,int q,int v,int cost)
{
	add(p,q,v,cost);
	add(q,p,0,-cost);
}
void init()
{
	scanf(&quot;%d%d&quot;,&amp;m,&amp;n);//m,n表示技术人员数与顾客数
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;a[i][j]);//第j位技术人员维修第i辆车
	num=n;
	for (i=1;i&lt;=m;i++)
		for (j=1;j&lt;=n;j++) hao[i][j]=++num;
	S=++num,T=++num;
	tot=1;
	for (i=1;i&lt;=m;i++)
		for (j=1;j&lt;=n;j++) addedge(S,hao[i][j],1,0);
	for (i=1;i&lt;=m;i++)
		for (j=1;j&lt;=n;j++)
			for (k=1;k&lt;=n;k++) addedge(hao[i][j],k,1,(n-(j-1))*a[k][i]);
	for (i=1;i&lt;=n;i++) addedge(i,T,1,0);
}
bool relax(int x,int y,int v)
{
	if (dist[y]&gt;dist[x]+v)
	{
		dist[y]=dist[x]+v;
		return 1;
	}
	return 0;
}
bool spfa()
{
	memset(dist,127,sizeof(dist[0])*(T+10));
	head=tail=0;
	memset(dl,0,sizeof(dl[0])*(T+10));
	dist[S]=0;
	dl[S]=1;
	q[++tail]=S;
	while (head&lt;tail)
	{
		int x=q[++head];
		dl[x]=0;
		int p=o[x];
		while (p)
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;relax(x,y,aa[p][3]))
			{
				pre[y]=p;
				if (!dl[y])
				{
					q[++tail]=y;
					dl[y]=1;
				}
			}
			p=aa[p][0];
		}
	}
	if (dist[T]==dist[T+1]) return 0;
	return 1;
}
void addcost()
{
	int p=pre[T],flow=inf;
	while (p)
	{
		flow=min(flow,aa[p][2]);
		p=pre[aa[p^1][1]];
	}
	p=pre[T];
	while (p)
	{
		ans+=flow*aa[p][3];
		aa[p][2]-=flow;
		aa[p^1][2]+=flow;
		p=pre[aa[p^1][1]];
	}
}
void doit()
{
	ans=0;
	while (spfa()) addcost();
	printf(&quot;%.2f\n&quot;,ans*1.0/n);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	init();
	doit();
	return 0;
}
<pre><h2>Problem1072</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int tc,n,mo,S,i,k,ans,f[1100][1&lt;&lt;10],flag[15];
char s[15];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;tc);
	for (;tc;tc--)
	{
		scanf(&quot;%s&quot;,s+1);
		n=strlen(s+1);
		scanf(&quot;%d\n&quot;,&amp;mo);
		memset(f,0,sizeof(f));
		f[0][0]=1;
		for (S=0;S&lt;1&lt;&lt;n;S++)
			for (i=0;i&lt;mo;i++)
				for (k=1;k&lt;=n;k++)
					if (((1&lt;&lt;(k-1))&amp;S)==0)
						f[(i*10+s[k]-'0')%mo][S^(1&lt;&lt;(k-1))]+=f[i][S];
		ans=f[0][(1&lt;&lt;n)-1];
		for (i=1;i&lt;=n;i++) flag[s[i]-'0']++;
		for (i=0;i&lt;10;i++)
			while (flag[i]) ans/=flag[i],flag[i]--;
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
<pre><h2>Problem1076</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define DD double
#define inf 99999999
int P[120],mast[120],n,kk,i,S,j,x;
DD f[120][1&lt;&lt;15];
DD max(DD a,DD b) {return a&gt;b?a:b;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;kk,&amp;n);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;P[i]);
		for (scanf(&quot;%d&quot;,&amp;x);x;scanf(&quot;%d&quot;,&amp;x)) mast[i]+=(1&lt;&lt;(x-1));
	}
	for (i=kk;i;i--)
		for (S=0;S&lt;1&lt;&lt;n;S++)
			for (j=1;j&lt;=n;j++)
				if ((mast[j]&amp;S)!=mast[j]) f[i][S]+=f[i+1][S]/n;
				else f[i][S]+=max(f[i+1][S|(1&lt;&lt;(j-1))]+P[j],f[i+1][S])/n;
	printf(&quot;%.6f\n&quot;,f[1][0]);
	return 0;
}
<pre><h2>Problem1078</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
int lc[111],rc[111],fa[111],ans[111];
int n,root;
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
int work()
{
	//printf(&quot;\n----------------------- work ------------------------------\n&quot;);
	int x=root;
	for (;;)
	{
		if (!rc[x]) break;
		x=lc[x];
	}
	if (lc[x]&amp;&amp;!lc[lc[x]]&amp;&amp;!rc[lc[x]]) x=lc[x];
	int t=x,f=fa[x];
	if (x==root) root=lc[root],fa[root]=-1;
	//printf(&quot;x=%d t=%d f=%d\n&quot;,x,t,f);
	if (lc[x]) fa[lc[x]]=f;
	if (f!=-1) lc[f]=lc[x];
	for (x=f;x!=-1;x=fa[x]) swap(lc[x],rc[x]);
	return t;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	fa[0]=-1;
	int i,x;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		if (x&lt;100) lc[x]=i,fa[i]=x;
		else rc[x-100]=i,fa[i]=x-100;
	}
	//printf(&quot;fa &quot;);out(fa,0,n);printf(&quot;lc &quot;);out(lc,0,n);printf(&quot;rc &quot;);out(rc,0,n);ln;
	for (i=0;i&lt;=n;i++) ans[i]=work();
	for (i=n;i&gt;=0;i--) printf(&quot;%d &quot;,ans[i]);
	return 0;
}<pre><h2>Problem1079</h2><pre>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;ctime&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#define ll long long
#define p 1000000007
using namespace std;
ll f[16][16][16][16][16][16];
int k,c[20],x;
bool v[16][16][16][16][16][16];
ll dp(int a,int b,int c,int d,int e,int last)
{
	if (v[a][b][c][d][e][last]) return f[a][b][c][d][e][last];
	if (a+b+c+d+e==0) return 1;
	ll sum=0;
	if (a) sum+=(a-(last==2))*dp(a-1,b,c,d,e,1);
	if (b) sum+=(b-(last==3))*dp(a+1,b-1,c,d,e,2);
	if (c) sum+=(c-(last==4))*dp(a,b+1,c-1,d,e,3);
	if (d) sum+=(d-(last==5))*dp(a,b,c+1,d-1,e,4);
	if (e) sum+=e*dp(a,b,c,d+1,e-1,5);
	v[a][b][c][d][e][last]=1;
	return f[a][b][c][d][e][last]=(sum%p);
}
int main()
{
	scanf(&quot;%d&quot;,&amp;k);
	while (k--) {scanf(&quot;%d&quot;,&amp;x);c[x]++;}
	cout&lt;&lt;dp(c[1],c[2],c[3],c[4],c[5],0);
}
<pre><h2>Problem1083</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,m,fa[1000];
struct edge
{
	int u,v,w;
	void in() {scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);}
	friend bool operator &lt;(edge a,edge b) {return a.w&lt;b.w;}
} e[10000];
int getfa(int x) {return fa[x]==x?x:fa[x]=getfa(fa[x]);}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i;
	for (i=1;i&lt;=m;i++) e[i].in();
	sort(e+1,e+m+1);
	for (i=1;i&lt;=n;i++) fa[i]=i;
	int cnt=0,ans=0;
	for (i=1;i&lt;=m&amp;&amp;cnt&lt;n-1;i++)
	{
		int x=getfa(e[i].u),y=getfa(e[i].v);
		if (x==y) continue;
		cnt++;
		fa[x]=y;
		ans=e[i].w;
	}
	printf(&quot;%d %d\n&quot;,n-1,ans);
	return 0;
}<pre><h2>Problem1084</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 999999999
int n,m,K,a[111][3];
inline void renew(int &amp;x,int y) {if (y&gt;x) x=y;}
int work1()
{
	static int sum[111],f[111][13];
	int i,j,k;
	for (i=1;i&lt;=n;i++) sum[i]=sum[i-1]+a[i][1];
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=i&amp;&amp;j&lt;=K;j++)
		{
			f[i][j]=f[i-1][j];
			for (k=0;k&lt;i;k++)
				renew(f[i][j],f[k][j-1]+sum[i]-sum[k]);
		}
	return f[n][K];
}
int work2()
{
	static int s1[111],s2[111],f[111][111][13];
	int i,j,k,l;
	for (i=1;i&lt;=n;i++)
		s1[i]=s1[i-1]+a[i][1],s2[i]=s2[i-1]+a[i][2];
	for (i=0;i&lt;=n;i++)
		for (j=0;j&lt;=n;j++)
			for (k=1;k&lt;=K;k++)
			{
				if (i) renew(f[i][j][k],f[i-1][j][k]);
				if (j) renew(f[i][j][k],f[i][j-1][k]);
				if (i==j)
					for (l=0;l&lt;i&amp;&amp;l&lt;j;l++)
						renew(f[i][j][k],f[l][l][k-1]+s1[i]-s1[l]+s2[j]-s2[l]);
				for (l=0;l&lt;i;l++)
					renew(f[i][j][k],f[l][j][k-1]+s1[i]-s1[l]);
				for (l=0;l&lt;j;l++)
					renew(f[i][j][k],f[i][l][k-1]+s2[j]-s2[l]);
			}
	return f[n][n][K];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;K);
	int i,j;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;a[i][j]);
	if (m==1) printf(&quot;%d\n&quot;,work1());
	else printf(&quot;%d\n&quot;,work2());
	return 0;
}<pre><h2>Problem1085</h2><pre>const
  a0:array[1..5,1..5]of longint=((1,1,1,1,1),
                                 (0,1,1,1,1),
                                 (0,0,-1,1,1),
                                 (0,0,0,0,1),
                                 (0,0,0,0,0));
  dx:array[1..8]of longint=(-2,-2,-1,-1,1,1,2,2);
  dy:array[1..8]of longint=(1,-1,2,-2,2,-2,1,-1);
var
  a:array[1..5,1..5]of longint;
  tt,i,j,ans,x0,y0:longint;
  ch:char;
procedure init;
begin
  for i:=1 to 5 do
    begin
      for j:=1 to 5 do
        begin
          read(ch);
          if ch&lt;&gt;'*' then a[i,j]:=ord(ch)-ord('0')
          else
            begin
              a[i,j]:=-1;
              x0:=i;
              y0:=j;
            end;
        end;
      readln;
    end;
end;
procedure swap(var a,b:longint);
var t:longint;
begin
  t:=a;
  a:=b;
  b:=t;
end;
function check:boolean;
var i,j:longint;
begin
  for i:=1 to 5 do
    for j:=1 to 5 do
      if a[i,j]&lt;&gt;a0[i,j] then exit(false);
  exit(true);
end;
function gu:longint;
var res,i,j:longint;
begin
  res:=0;
  for i:=1 to 5 do
    for j:=1 to 5 do
      if a[i,j]&lt;&gt;a0[i,j] then inc(res);
  exit(res-1);
end;
function dfs(x,y,dep:longint):boolean;
var i,xx,yy:longint;
begin
  if check then exit(true);
  if dep&gt;=ans then exit(false);
  if dep+gu&gt;ans then exit(false);
  for i:=1 to 8 do
    begin
      xx:=x+dx[i];
      yy:=y+dy[i];
      if(xx&lt;1)or(xx&gt;5)or(yy&lt;1)or(yy&gt;5)then continue;
      swap(a[x,y],a[xx,yy]);
      if dfs(xx,yy,dep+1) then exit(true);
      swap(a[x,y],a[xx,yy]);
    end;
  exit(false);
end;
procedure doit;
begin
  for ans:=0 to 15 do
    if dfs(x0,y0,0) then
      begin
        writeln(ans);
        exit;
      end;
  writeln(-1);
end;
begin
 // assign(input,'sss.in');reset(input);
  //assign(output,'sss.out');rewrite(output);
  readln(tt);
  repeat
    dec(tt);
    init;
    doit;
  until tt=0;
 // close(input);close(output);
end.<pre><h2>Problem1086</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
#define NN 1111
int sta[NN][NN*2],top[NN],belong[NN],shenghui[NN],o[NN],aa[NN*2][2],fa[NN];
int n,B,cnt,tot;
void dfs(int v)
{
	int p,y;
	for (p=o[v];p;p=aa[p][0])
	{
		y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dfs(y);
		if (top[v]&gt;=B)
		{
			cnt++;
			for (;top[v];top[v]--) belong[sta[v][top[v]]]=cnt;
			shenghui[cnt]=v;
		}
	}
	sta[v][++top[v]]=v;
	for (;top[v];top[v]--) sta[fa[v]][++top[fa[v]]]=sta[v][top[v]];
}
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;B);
	int i,x,y;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	dfs(1);
	for (;top[0];top[0]--) belong[sta[0][top[0]]]=cnt;
	if (cnt==0) {printf(&quot;0\n&quot;);return 0;}
	printf(&quot;%d\n&quot;,cnt);
	for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,belong[i]);ln;
	for (i=1;i&lt;=cnt;i++) printf(&quot;%d &quot;,shenghui[i]);ln;
	return 0;
}
<pre><h2>Problem1087</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
LL f[100][10][1999];
int n,K;
bool pan1(int x)
{
	if (x&amp;(x&gt;&gt;1)) return false;
	//if (x&amp;(x&gt;&gt;2)) return false;
	if (x&amp;(x&lt;&lt;1)) return false;
	//if (x&amp;(x&lt;&lt;2)) return false;
	return true;
}
bool pan2(int x,int y)
{
	if (x&amp;y) return false;
	if (x&amp;(y&gt;&gt;1)) return false;
	//if (x&amp;(y&gt;&gt;2)) return false;
	if (x&amp;(y&lt;&lt;1)) return false;
	//if (x&amp;(y&lt;&lt;2)) return false;
	return true;
}
int calc(int x)
{
	int res=0;
	for (;x;x-=x&amp;-x) res++;
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	int mm=(1&lt;&lt;n)-1;
	f[0][0][0]=1;
	int i,j,k,l;
	for (i=1;i&lt;=K;i++)
		for (j=1;j&lt;=n;j++)
			for (k=0;k&lt;=mm;k++)
			{
				if (!pan1(k)||calc(k)&gt;i) continue;
				for (l=0;l&lt;=mm;l++)
				{
					if (!pan1(l)||calc(k)+calc(l)&gt;i) continue;
					if (!pan2(k,l)) continue;
					f[i][j][k]+=f[i-calc(k)][j-1][l];
				}
				//printf(&quot;f[%d][%d][%d]=%d\n&quot;,i,j,k,f[i][j][k]);
			}
	LL ans=0;
	for (j=1;j&lt;=n;j++)
		for (k=0;k&lt;=mm;k++) ans+=f[K][j][k];
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem1088</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int NN=20005;
int a[NN],b[NN],n;
bool check(int x,int y)
{
	if (x+y!=a[1]) return false;
	b[1]=x,b[2]=y;
	for (int i=2;i&lt;n;i++)
	{
		if (b[i-1]+b[i]&gt;a[i]) return false;
		b[i+1]=a[i]-b[i-1]-b[i];
	}
	if (b[n-1]+b[n]!=a[n]) return false;
	return true;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	if (n==1) {printf(&quot;1\n&quot;);return 0;}
	int ans=0;
	if (check(0,0)) ans++;
	if (check(1,0)) ans++;
	if (check(1,1)) ans++;
	if (check(0,1)) ans++;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1090</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define p1 255
#define mo 10007
#define p2 19980723
#define NN 111
#define ln printf(&quot;\n&quot;)
int mi1[NN],mi2[NN],h1[NN],h2[NN],f[NN][NN];
int n;
char s[NN];
bool qwe;
int hash1(int l,int r)
{
	int len=r-l+1;
	int tmp=(h1[r]-h1[l-1]*mi1[len])%mo;
	if (tmp&lt;0) tmp+=mo;
	return tmp;
}
int hash2(int l,int r)
{
	int len=r-l+1;
	return h2[r]-h2[l-1]*mi2[len];
}
bool check(int l,int k,int r)
{
	int len=k-l+1;
	int t1=hash1(l,k),t2=hash2(l,k);
	int now=k+1;
	while (now&lt;=r)
	{
		int t3=hash1(now,now+len-1);
		int t4=hash2(now,now+len-1);
		if (t1!=t3||t2!=t4) return false;
		now+=len;
	}
	return true;
}
int calc(int x)
{
	int res=0;
	for (;x;x/=10) res++;
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%s&quot;,s+1);
	n=strlen(s+1);
	//printf(&quot;n=%d\n&quot;,n);
	int i,j,k,len;
	for (mi1[0]=mi2[0]=1,i=1;i&lt;=n;i++)
	{
		mi1[i]=mi1[i-1]*p1%mo;
		h1[i]=(h1[i-1]+s[i]*mi1[i])%mo;
		mi2[i]=mi2[i-1]*p2;
		h2[i]=h2[i-1]+s[i]*mi2[i];
	}
	//printf(&quot;%d %d\n&quot;,hash1(20,22),hash1(23,25));
	for (i=1;i&lt;=n;i++) f[i][i]=1;
	for (len=2;len&lt;=n;len++)
		for (i=1;i+len-1&lt;=n;i++)
		{
			if (i==20&amp;&amp;len==9) qwe=true;
			j=i+len-1;
			f[i][j]=len;
			for (k=i;k&lt;j;k++) f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]);
			for (k=i;k&lt;j;k++)
				if (len%(k-i+1)==0&amp;&amp;check(i,k,j))
				{
					f[i][j]=min(f[i][j],f[i][k]+2+calc(len/(k-i+1)));
					//if (qwe) printf(&quot;true\n&quot;);
				}
			qwe=false;
		}
	//printf(&quot;f[20][28]=%d\n&quot;,f[20][28]);
	//ln;ln;
	printf(&quot;%d\n&quot;,f[1][n]);
	return 0;
}
<pre><h2>Problem1093</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
#define mii(a,b) ((a)&lt;(b)?(a):(b))
const int NN=101111,MM=1001111;
int aa[MM][2],o[NN],low[NN],dfn[NN],sta[NN],num[NN],belong[NN],du[NN],f[NN],g[NN],b[NN],flag[NN];
int n,m,mo,tot=1,TIME,top,scc;
bool vt[NN];
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
struct edge
{
	int a,b;
} e[MM];
void dfs(int v)
{
	vt[v]=true;
	dfn[v]=low[v]=++TIME;
	sta[++top]=v;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!vt[y])
		{
			dfs(y);
			low[v]=mii(low[v],low[y]);
		}
		else if (!belong[y]) low[v]=mii(low[v],dfn[y]);
	}
	if (low[v]==dfn[v])
	{
		scc++;
		int k;
		do
		{
			k=sta[top--];
			belong[k]=scc;
			num[scc]++;
		} while (k!=v);
	}
}
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;mo);
	int i;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;e[i].a,&amp;e[i].b);
		addedge(e[i].a,e[i].b);
	}
	for (i=1;i&lt;=n;i++)
		if (!vt[i]) dfs(i);
	//printf(&quot;dfn &quot;);out(dfn,1,n);printf(&quot;low &quot;);out(low,1,n);printf(&quot;belong &quot;);out(belong,1,n);
	memset(o,0,sizeof(o));tot=1;
	for (i=1;i&lt;=m;i++)
		if (belong[e[i].a]!=belong[e[i].b])
			addedge(belong[e[i].a],belong[e[i].b]),du[belong[e[i].b]]++;
	n=scc;
	for (top=0,i=1;i&lt;=n;i++)
		if (du[i]==0) sta[++top]=i;
	b[0]=0;
	while (top)
	{
		b[++b[0]]=sta[top--];
		for (int p=o[b[b[0]]];p;p=aa[p][0])
		{
			int y=aa[p][1];
			du[y]--;
			if (du[y]==0) sta[++top]=y;
		}
	}
	for (i=n;i;i--)
	{
		int x=b[i];
		f[x]=num[x],g[x]=1;
		TIME++;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (flag[y]==TIME) continue;else flag[y]=TIME;
			if (f[y]+num[x]&gt;f[x]) f[x]=f[y]+num[x],g[x]=g[y];
			else if (f[y]+num[x]==f[x])
			{
				g[x]+=g[y];
				if (g[x]&gt;mo) g[x]-=mo;
			}
		}
	}
	int ans=0;
	for (i=1;i&lt;=n;i++)
		if (f[i]&gt;ans) ans=f[i];
	int res=0;
	for (i=1;i&lt;=n;i++)
		if (f[i]==ans)
		{
			res+=g[i];
			if (res&gt;mo) res-=mo;
		}
	printf(&quot;%d\n%d\n&quot;,ans,res);
	return 0;
}<pre><h2>Problem1094</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long double DD;
typedef double dd;
#define ln printf(&quot;\n&quot;)
const DD eps=1e-9,dinf=1e30;
const DD pai=3.141592653589793238;
const int NN=111;
int n,K;
DD R,tim[NN][NN];
inline int dcmp(DD x)
{
	if (fabs(x)&lt;eps) return 0;
	return x&lt;0?-1:1;
}
struct point
{
	DD x,y;
	point(DD a=0,DD b=0) {x=a;y=b;}
	void in() {dd xx,yy;scanf(&quot;%lf%lf&quot;,&amp;xx,&amp;yy);x=xx,y=yy;}
	void out() {printf(&quot;%.2f %.2f  &quot;,(dd)x,(dd)y);}
	DD len() {return sqrt(x*x+y*y);}
	friend DD dis(point a,point b) {return (a-b).len();}
	point rotate(DD sita)
	{
		DD xx=x*cos(sita)-y*sin(sita);
		DD yy=y*cos(sita)+x*sin(sita);
		x=xx,y=yy;
		return *this;
	}
	friend point operator +(point a,point b) {return point(a.x+b.x,a.y+b.y);}
	friend point operator -(point a,point b) {return point(a.x-b.x,a.y-b.y);}
	friend point operator *(DD t,point a) {return point(a.x*t,a.y*t);}
	friend point operator *(point a,DD t) {return point(a.x*t,a.y*t);}
	friend point operator /(point a,DD t) {return point(a.x/t,a.y/t);}
	friend DD operator %(point a,point b) {return a.x*b.y-b.x*a.y;}
	friend DD operator *(point a,point b) {return a.x*b.x+a.y*b.y;}
	friend DD operator ^(point a,point b)
	{
		DD t=a*b/(a.len()*b.len());
		if (t&gt;1) t=1;if (t&lt;-1) t=-1;
		return acos(t);
	}
} O,V[NN][NN],pos[NN][NN];
struct line
{
	point P,v;
	void out() {P.out();v.out();ln;}
	line(point A=point(0,0),point B=point(0,0)) {P=A;v=B;}
};
point getjdwithC(point P,point v)
{
	DD m=P.x-O.x,n=P.y-O.y,x=v.x,y=v.y;
	DD A=x*x+y*y,B=2*m*x+2*n*y,C=m*m+n*n-R*R;
	DD tmp=sqrt(B*B-4*A*C);
	DD t1=(-B+tmp)/(2*A),t2=(-B-tmp)/(2*A);
	return P+max(t1,t2)*v;
}
void work(point *pos,DD *tim,point *V,DD x0,DD y0,DD vx0,DD vy0)
{
	pos[0]=point(x0,y0);
	tim[0]=0;
	V[0]=point(vx0,vy0);
	point M=point(x0,y0),v=point(vx0,vy0);
	DD vv=v.len();
	for (int i=1;i&lt;=K;i++)
	{
		point N=getjdwithC(M,v);
		pos[i]=N;
		tim[i]=tim[i-1]+(N-M).len()/vv;
		DD sita=(M-N)^(O-N);
		v=-1*v;
		if (dcmp((O-N)%(M-N))&lt;0) v.rotate(sita*2);
		else v.rotate(-sita*2);
		V[i]=v;
		M=N;
	}
}
line find(point *pos,DD *tim,point *V,int &amp;now,DD st)
{
	for (;now&lt;K;now++)
	{
		if (st-tim[now+1]&gt;-eps) continue;
		point P=pos[now],v=V[now];
		return line(P+(st-tim[now])*v,v);
	}
	return line(point(0,0),point(0,0));
}
point linejd(point P,point v,point Q,point w)
{
	point u=P-Q;
	DD t=(w%u)/(v%w);
	return P+t*v;
}
DD finddist(point P,point A,point B)
{
	DD x=(A-B).x,y=(A-B).y;
    point O=linejd(A,B-A,P,point(-y,x));
    if (dcmp(dis(O,A)+dis(O,B)-dis(A,B))==0) return dis(P,O);
    return min(dis(P,A),dis(P,B));
}
DD mindist(line l1,line l2,DD T)
{
	point A=l1.P,v1=l1.v,B=l2.P,v2=l2.v;
	if (fabs(T)&lt;eps) return dis(A,B);
	point M=A-B,N=M+(v1-v2)*T;
	return finddist(point(0,0),M,N);
}
DD calc(point *pos1,DD *tim1,point *V1,point *pos2,DD *tim2,point *V2)
{
	static DD b[NN&lt;&lt;1];
	int cnt=0,i;
	for (i=0;i&lt;=K;i++)
		b[++cnt]=tim1[i],b[++cnt]=tim2[i];
	sort(b+1,b+cnt+1);
	int t=1;
	for (i=2;i&lt;=cnt;i++)
		if (dcmp(b[i]-b[t])!=0) b[++t]=b[i];
	cnt=t;
	int now1=0,now2=0;
	DD res=dinf;
	for (i=1;i&lt;=cnt;i++)
	{
		line t1=find(pos1,tim1,V1,now1,b[i-1]);
		line t2=find(pos2,tim2,V2,now2,b[i-1]);
		if (now1==K||now2==K) break;
		res=min(res,mindist(t1,t2,b[i]-b[i-1]));
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	O.in();
	dd xx;
	scanf(&quot;%lf%d%d&quot;,&amp;xx,&amp;n,&amp;K);
	R=xx;
	int i,j;
	for (i=1;i&lt;=n;i++)
	{
		dd a,b,c,d;
		scanf(&quot;%lf%lf%lf%lf&quot;,&amp;a,&amp;b,&amp;c,&amp;d);
		work(pos[i],tim[i],V[i],a,b,c,d);
	}
	DD ans=dinf;
	for (i=1;i&lt;n;i++) for (j=i+1;j&lt;=n;j++)
		ans=min(ans,calc(pos[i],tim[i],V[i],pos[j],tim[j],V[j]));
	printf(&quot;%.3f\n&quot;,(dd)ans);
	return 0;
}<pre><h2>Problem1094</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long double DD;
typedef double dd;
#define ln printf(&quot;\n&quot;)
const DD eps=1e-9,dinf=1e30;
const DD pai=3.14159265358979;
const int NN=111;
int n,K;
DD R,tim[NN][NN];
inline int dcmp(DD x)
{
	if (fabs(x)&lt;eps) return 0;
	return x&lt;0?-1:1;
}
struct point
{
	DD x,y;
	point(DD a=0,DD b=0) {x=a;y=b;}
	void in() {dd xx,yy;scanf(&quot;%lf%lf&quot;,&amp;xx,&amp;yy);x=xx,y=yy;}
	void out() {printf(&quot;%.2f %.2f  &quot;,(dd)x,(dd)y);}
	DD len() {return sqrt(x*x+y*y);}
	friend DD dis(point a,point b) {return (a-b).len();}
	point rotate(DD sita)
	{
		DD xx=x*cos(sita)-y*sin(sita);
		DD yy=y*cos(sita)+x*sin(sita);
		x=xx,y=yy;
		return *this;
	}
	friend point operator +(point a,point b) {return point(a.x+b.x,a.y+b.y);}
	friend point operator -(point a,point b) {return point(a.x-b.x,a.y-b.y);}
	friend point operator *(DD t,point a) {return point(a.x*t,a.y*t);}
	friend point operator *(point a,DD t) {return point(a.x*t,a.y*t);}
	friend point operator /(point a,DD t) {return point(a.x/t,a.y/t);}
	friend DD operator %(point a,point b) {return a.x*b.y-b.x*a.y;}
	friend DD operator *(point a,point b) {return a.x*b.x+a.y*b.y;}
	friend DD operator ^(point a,point b)
	{
		DD t=a*b/(a.len()*b.len());
		if (t&gt;1) t=1;if (t&lt;-1) t=-1;
		return acos(t);
	}
} O,V[NN][NN],pos[NN][NN];
struct line
{
	point P,v;
	void out() {P.out();v.out();ln;}
	line(point A=point(0,0),point B=point(0,0)) {P=A;v=B;}
};
point getjdwithC(point P,point v)
{
	DD m=P.x-O.x,n=P.y-O.y,x=v.x,y=v.y;
	DD A=x*x+y*y,B=2*m*x+2*n*y,C=m*m+n*n-R*R;
	DD tmp=sqrt(B*B-4*A*C);
	DD t1=(-B+tmp)/(2*A),t2=(-B-tmp)/(2*A);
	return P+max(t1,t2)*v;
}
void work(point *pos,DD *tim,point *V,DD x0,DD y0,DD vx0,DD vy0)
{
	pos[0]=point(x0,y0);
	tim[0]=0;
	V[0]=point(vx0,vy0);
	point M=point(x0,y0),v=point(vx0,vy0);
	DD vv=v.len();
	for (int i=1;i&lt;=K;i++)
	{
		point N=getjdwithC(M,v);
		pos[i]=N;
		tim[i]=tim[i-1]+(N-M).len()/vv;
		DD sita=(M-N)^(O-N);
		v=-1*v;
		if (dcmp((O-N)%(M-N))&lt;0) v.rotate(sita*2);
		else v.rotate(-sita*2);
		V[i]=v;
		M=N;
	}
}
line find(point *pos,DD *tim,point *V,int &amp;now,DD st)
{
	for (;now&lt;K;now++)
	{
		if (st-tim[now+1]&gt;-eps) continue;
		point P=pos[now],v=V[now];
		return line(P+(st-tim[now])*v,v);
	}
	return line(point(0,0),point(0,0));
}
point linejd(point P,point v,point Q,point w)
{
	point u=P-Q;
	DD t=(w%u)/(v%w);
	return P+t*v;
}
DD finddist(point P,point A,point B)
{
	DD x=(A-B).x,y=(A-B).y;
    point O=linejd(A,B-A,P,(A-B).rotate(pai/2));
    if (dcmp(dis(O,A)+dis(O,B)-dis(A,B))==0) return dis(P,O);
    return min(dis(P,A),dis(P,B));
}
DD mindist(line l1,line l2,DD T)
{
	point A=l1.P,v1=l1.v,B=l2.P,v2=l2.v;
	if (fabs(T)&lt;eps) return dis(A,B);
	point M=A-B,N=M+(v1-v2)*T;
	return finddist(point(0,0),M,N);
}
DD calc(point *pos1,DD *tim1,point *V1,point *pos2,DD *tim2,point *V2)
{
	static DD b[NN&lt;&lt;1];
	int cnt=0,i;
	for (i=0;i&lt;=K;i++)
		b[++cnt]=tim1[i],b[++cnt]=tim2[i];
	sort(b+1,b+cnt+1);
	int t=1;
	for (i=2;i&lt;=cnt;i++)
		if (dcmp(b[i]-b[t])!=0) b[++t]=b[i];
	cnt=t;
	int now1=0,now2=0;
	DD res=dinf;
	for (i=1;i&lt;=cnt;i++)
	{
		line t1=find(pos1,tim1,V1,now1,b[i-1]);
		line t2=find(pos2,tim2,V2,now2,b[i-1]);
		if (now1==K||now2==K) break;
		res=min(res,mindist(t1,t2,b[i]-b[i-1]));
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	O.in();
	dd xx;
	scanf(&quot;%lf%d%d&quot;,&amp;xx,&amp;n,&amp;K);
	R=xx;
	int i,j;
	for (i=1;i&lt;=n;i++)
	{
		dd a,b,c,d;
		scanf(&quot;%lf%lf%lf%lf&quot;,&amp;a,&amp;b,&amp;c,&amp;d);
		work(pos[i],tim[i],V[i],a,b,c,d);
	}
	DD ans=dinf;
	for (i=1;i&lt;n;i++) for (j=i+1;j&lt;=n;j++)
		ans=min(ans,calc(pos[i],tim[i],V[i],pos[j],tim[j],V[j]));
	printf(&quot;%.3f\n&quot;,(dd)ans);
	return 0;
}<pre><h2>Problem1094</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long double DD;
typedef double dd;
#define ln printf(&quot;\n&quot;)
const DD eps=1e-9,dinf=1e30;
const DD pai=3.14159265358979;
const int NN=111;
int n,K;
DD R,tim[NN][NN];
inline int dcmp(DD x)
{
	if (fabs(x)&lt;eps) return 0;
	return x&lt;0?-1:1;
}
struct point
{
	DD x,y;
	point(DD a=0,DD b=0) {x=a;y=b;}
	void in() {dd xx,yy;scanf(&quot;%lf%lf&quot;,&amp;xx,&amp;yy);x=xx,y=yy;}
	void out() {printf(&quot;%.2f %.2f  &quot;,(dd)x,(dd)y);}
	DD len() {return sqrt(x*x+y*y);}
	friend DD dis(point a,point b) {return (a-b).len();}
	point rotate(DD sita)
	{
		DD xx=x*cos(sita)-y*sin(sita);
		DD yy=y*cos(sita)+x*sin(sita);
		x=xx,y=yy;
		return *this;
	}
	friend point operator +(point a,point b) {return point(a.x+b.x,a.y+b.y);}
	friend point operator -(point a,point b) {return point(a.x-b.x,a.y-b.y);}
	friend point operator *(DD t,point a) {return point(a.x*t,a.y*t);}
	friend point operator *(point a,DD t) {return point(a.x*t,a.y*t);}
	friend point operator /(point a,DD t) {return point(a.x/t,a.y/t);}
	friend DD operator %(point a,point b) {return a.x*b.y-b.x*a.y;}
	friend DD operator *(point a,point b) {return a.x*b.x+a.y*b.y;}
	friend DD operator ^(point a,point b)
	{
		DD t=a*b/(a.len()*b.len());
		if (t&gt;1) t=1;if (t&lt;-1) t=-1;
		return acos(t);
	}
} O,V[NN][NN],pos[NN][NN];
struct line
{
	point P,v;
	void out() {P.out();v.out();ln;}
	line(point A=point(0,0),point B=point(0,0)) {P=A;v=B;}
};
point getjdwithC(point P,point v)
{
	DD m=P.x-O.x,n=P.y-O.y,x=v.x,y=v.y;
	DD A=x*x+y*y,B=2*m*x+2*n*y,C=m*m+n*n-R*R;
	DD tmp=sqrt(B*B-4*A*C);
	DD t1=(-B+tmp)/(2*A),t2=(-B-tmp)/(2*A);
	return P+max(t1,t2)*v;
}
void work(point *pos,DD *tim,point *V,DD x0,DD y0,DD vx0,DD vy0)
{
	pos[0]=point(x0,y0);
	tim[0]=0;
	V[0]=point(vx0,vy0);
	point M=point(x0,y0),v=point(vx0,vy0);
	DD vv=v.len();
	for (int i=1;i&lt;=K;i++)
	{
		point N=getjdwithC(M,v);
		pos[i]=N;
		tim[i]=tim[i-1]+(N-M).len()/vv;
		DD sita=(M-N)^(O-N);
		v=-1*v;
		if (dcmp((O-N)%(M-N))&lt;0) v.rotate(sita*2);
		else v.rotate(-sita*2);
		V[i]=v;
		M=N;
	}
}
line find(point *pos,DD *tim,point *V,int &amp;now,DD st)
{
	for (;now&lt;K;now++)
	{
		if (st-tim[now+1]&gt;-eps) continue;
		point P=pos[now],v=V[now];
		return line(P+(st-tim[now])*v,v);
	}
	return line(point(0,0),point(0,0));
}
point linejd(point P,point v,point Q,point w)
{
	point u=P-Q;
	DD t=(w%u)/(v%w);
	return P+t*v;
}
DD mindist(line l1,line l2,DD T)
{
	point A=l1.P,v1=l1.v,B=l2.P,v2=l2.v;
	if (fabs(T)&lt;eps) return dis(A,B);
	A=A-B,B=A+(v1-v2)*T;
	point P=point(0,0);
	point O=linejd(A,B-A,P,(A-B).rotate(pai/2));
    if (dcmp(dis(O,A)+dis(O,B)-dis(A,B))==0) return dis(P,O);
    return min(dis(P,A),dis(P,B));
}
DD calc(point *pos1,DD *tim1,point *V1,point *pos2,DD *tim2,point *V2)
{
	static DD b[NN&lt;&lt;1];
	int cnt=0,i;
	for (i=0;i&lt;=K;i++)
		b[++cnt]=tim1[i],b[++cnt]=tim2[i];
	sort(b+1,b+cnt+1);
	int t=1;
	for (i=2;i&lt;=cnt;i++)
		if (dcmp(b[i]-b[t])!=0) b[++t]=b[i];
	cnt=t;
	int now1=0,now2=0;
	DD res=dinf;
	for (i=1;i&lt;=cnt;i++)
	{
		line t1=find(pos1,tim1,V1,now1,b[i-1]);
		line t2=find(pos2,tim2,V2,now2,b[i-1]);
		if (now1==K||now2==K) break;
		res=min(res,mindist(t1,t2,b[i]-b[i-1]));
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	O.in();
	dd xx;
	scanf(&quot;%lf%d%d&quot;,&amp;xx,&amp;n,&amp;K);
	R=xx;
	int i,j;
	for (i=1;i&lt;=n;i++)
	{
		dd a,b,c,d;
		scanf(&quot;%lf%lf%lf%lf&quot;,&amp;a,&amp;b,&amp;c,&amp;d);
		work(pos[i],tim[i],V[i],a,b,c,d);
	}
	DD ans=dinf;
	for (i=1;i&lt;n;i++) for (j=i+1;j&lt;=n;j++)
		ans=min(ans,calc(pos[i],tim[i],V[i],pos[j],tim[j],V[j]));
	printf(&quot;%.3f\n&quot;,(dd)ans);
	return 0;
}<pre><h2>Problem1094</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long double DD;
typedef double dd;
#define ln printf(&quot;\n&quot;)
const DD eps=1e-9,dinf=1e30;
const DD pai=3.14159265358979;
const int NN=111;
int n,K;
DD R,tim[NN][NN];
inline int dcmp(DD x)
{
	if (fabs(x)&lt;eps) return 0;
	return x&lt;0?-1:1;
}
struct point
{
	DD x,y;
	point(DD a=0,DD b=0) {x=a;y=b;}
	void in() {dd xx,yy;scanf(&quot;%lf%lf&quot;,&amp;xx,&amp;yy);x=xx,y=yy;}
	void out() {printf(&quot;%.2f %.2f  &quot;,(dd)x,(dd)y);}
	DD len() {return sqrt(x*x+y*y);}
	friend DD dis(point a,point b) {return (a-b).len();}
	point rotate(DD sita)
	{
		DD xx=x*cos(sita)-y*sin(sita);
		DD yy=y*cos(sita)+x*sin(sita);
		x=xx,y=yy;
		return *this;
	}
	friend point operator +(point a,point b) {return point(a.x+b.x,a.y+b.y);}
	friend point operator -(point a,point b) {return point(a.x-b.x,a.y-b.y);}
	friend point operator *(DD t,point a) {return point(a.x*t,a.y*t);}
	friend point operator *(point a,DD t) {return point(a.x*t,a.y*t);}
	friend point operator /(point a,DD t) {return point(a.x/t,a.y/t);}
	friend DD operator %(point a,point b) {return a.x*b.y-b.x*a.y;}
	friend DD operator *(point a,point b) {return a.x*b.x+a.y*b.y;}
	friend DD operator ^(point a,point b)
	{
		DD t=a*b/(a.len()*b.len());
		if (t&gt;1) t=1;if (t&lt;-1) t=-1;
		return acos(t);
	}
} O,V[NN][NN],pos[NN][NN];
struct line
{
	point P,v;
	void out() {P.out();v.out();ln;}
	line(point A=point(0,0),point B=point(0,0)) {P=A;v=B;}
};
point getjdwithC(point P,point v)
{
	DD m=P.x-O.x,n=P.y-O.y,x=v.x,y=v.y;
	DD A=x*x+y*y,B=2*m*x+2*n*y,C=m*m+n*n-R*R;
	DD tmp=sqrt(B*B-4*A*C);
	DD t1=(-B+tmp)/(2*A),t2=(-B-tmp)/(2*A);
	return P+max(t1,t2)*v;
}
void work(point *pos,DD *tim,point *V,DD x0,DD y0,DD vx0,DD vy0)
{
	pos[0]=point(x0,y0);
	tim[0]=0;
	V[0]=point(vx0,vy0);
	point M=point(x0,y0),v=point(vx0,vy0);
	DD vv=v.len();
	for (int i=1;i&lt;=K;i++)
	{
		point N=getjdwithC(M,v);
		pos[i]=N;
		tim[i]=tim[i-1]+(N-M).len()/vv;
		DD sita=(M-N)^(O-N);
		v=-1*v;
		if (dcmp((O-N)%(M-N))&lt;0) v.rotate(sita*2);
		else v.rotate(-sita*2);
		V[i]=v;
		M=N;
	}
}
line find(point *pos,DD *tim,point *V,int &amp;now,DD st)
{
	for (;now&lt;K;now++)
	{
		if (st-tim[now+1]&gt;-eps) continue;
		point P=pos[now],v=V[now];
		return line(P+(st-tim[now])*v,v);
	}
	return line(point(0,0),point(0,0));
}
point linejd(point P,point v,point Q,point w)
{
	point u=P-Q;
	DD t=(w%u)/(v%w);
	return P+t*v;
}
DD mindist(line l1,line l2,DD T)
{
	point A=l1.P,v1=l1.v,B=l2.P,v2=l2.v;
	if (fabs(T)&lt;eps) return dis(A,B);
	A=A-B,B=A+(v1-v2)*T;
	point P=point(0,0);
	point O=linejd(A,B-A,P,(A-B).rotate(pai/2));
    if (dcmp(dis(O,A)+dis(O,B)-dis(A,B))==0) return dis(P,O);
    return min(dis(P,A),dis(P,B));
}
DD calc(point *pos1,DD *tim1,point *V1,point *pos2,DD *tim2,point *V2)
{
	static DD b[NN&lt;&lt;1];
	int cnt=0,i;
	for (i=0;i&lt;=K;i++)
		b[++cnt]=tim1[i],b[++cnt]=tim2[i];
	sort(b+1,b+cnt+1);
	int t=1;
	for (i=2;i&lt;=cnt;i++)
		if (dcmp(b[i]-b[t])!=0) b[++t]=b[i];
	cnt=t;
	int now1=0,now2=0;
	DD res=dinf;
	for (i=1;i&lt;=cnt;i++)
	{
		line t1=find(pos1,tim1,V1,now1=0,b[i-1]);
		line t2=find(pos2,tim2,V2,now2=0,b[i-1]);
		if (now1==K||now2==K) break;
		res=min(res,mindist(t1,t2,b[i]-b[i-1]));
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	O.in();
	dd xx;
	scanf(&quot;%lf%d%d&quot;,&amp;xx,&amp;n,&amp;K);
	R=xx;
	int i,j;
	for (i=1;i&lt;=n;i++)
	{
		dd a,b,c,d;
		scanf(&quot;%lf%lf%lf%lf&quot;,&amp;a,&amp;b,&amp;c,&amp;d);
		work(pos[i],tim[i],V[i],a,b,c,d);
	}
	DD ans=dinf;
	for (i=1;i&lt;n;i++) for (j=i+1;j&lt;=n;j++)
		ans=min(ans,calc(pos[i],tim[i],V[i],pos[j],tim[j],V[j]));
	printf(&quot;%.3f\n&quot;,(dd)ans);
	return 0;
}<pre><h2>Problem1095</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;set&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=101111;
int o[NN],aa[NN*2][2],deep[NN],size[NN],fa[NN],boss[NN];
int n,m,tot=1;
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);ln;}
struct Tree
{
	int deep[NN],fa[NN],f[NN][19];
	void dfs(int v)
	{
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[v]) continue;
			fa[y]=v;
			deep[y]=deep[v]+1;
			dfs(y);
		}
	}
	void build()
	{
		deep[1]=1;
		dfs(1);
		int i,j;
		for (i=1;i&lt;=n;i++) f[i][0]=fa[i];
		for (j=1;j&lt;=18;j++)
			for (i=1;i&lt;=n;i++) f[i][j]=f[f[i][j-1]][j-1];
	}
	int lca(int x,int y)
	{
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		int i;
		for (i=18;i&gt;=0;i--)
			if (deep[f[x][i]]&gt;=deep[y]) x=f[x][i];
		if (x==y) return x;
		for (i=18;i&gt;=0;i--)
			if (f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
		return f[x][0];
	}
	int dist(int x,int y)
	{
		return deep[x]+deep[y]-2*deep[lca(x,y)];
	}
} tree;
struct Super_heap
{
	multiset&lt;int&gt; S;
	multiset&lt;int&gt;::iterator it;
	void insert(int x) {S.insert(x);}
	void erase(int x) {S.erase(S.find(x));}
	int top() {it=S.end();it--;return *it;}
	int stop() {it=S.end();it--;it--;return *it;}
	int size() {return S.size();}
	void out()
	{
		for (it=S.begin();it!=S.end();it++)
			printf(&quot;%d &quot;,*it);
		ln;
	}
} A[NN],B[NN];
struct output
{
	Super_heap S;
	int num;
	void out()
	{
		if (S.size()) printf(&quot;%d\n&quot;,S.top());
		else if (num==0) printf(&quot;-1\n&quot;);
		else printf(&quot;0\n&quot;);
	}
	void add(int i)
	{
		if (B[i].size()&lt;2) return;
		S.insert(B[i].top()+B[i].stop());
	}
	void del(int i)
	{
		if (B[i].size()&lt;2) return;
		S.erase(B[i].top()+B[i].stop());
	}
} ans;
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void calcsize(int v)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]||y==fa[v]) continue;
		fa[y]=v;
		calcsize(y);
		size[v]+=size[y];
	}
}
int core(int v)
{
	fa[v]=0,calcsize(v);
	for (;;)
	{
		bool flag=false;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (deep[y]&lt;deep[v]) continue;
			if (size[y]*2&gt;size[v])
			{
				size[v]-=size[y];
				size[y]+=size[v];
				v=y;flag=true;break;
			}
		}
		if (!flag) break;
	}
	return v;
}
void work(int v)
{
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]) continue;
		y=core(y);
		deep[y]=deep[v]+1;
		boss[y]=v;
		work(y);
	}
}
void turn_off(int x)
{
	ans.num++;
	ans.del(x);
	B[x].insert(0);
	ans.add(x);
	for (int y=x;boss[y];y=boss[y])
	{
		int f=boss[y];
		ans.del(f);
		if (A[y].size())
			B[f].erase(A[y].top());
		A[y].insert(tree.dist(f,x));
		if (A[y].size())
			B[f].insert(A[y].top());
		ans.add(f);
	}
}
void turn_on(int x)
{
	ans.num--;
	ans.del(x);
	B[x].erase(0);
	ans.add(x);
	for (int y=x;boss[y];y=boss[y])
	{
		int f=boss[y];
		ans.del(f);
		if (A[y].size()) B[f].erase(A[y].top());
		A[y].erase(tree.dist(f,x));
		if (A[y].size()) B[f].insert(A[y].top());
		ans.add(f);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	tree.build();
	memset(deep,60,sizeof(deep));
	int t=core(1);
	deep[t]=1,work(t);
	//printf(&quot;boss &quot;);out(boss,1,n);
	static bool flag[NN];
	for (i=1;i&lt;=n;i++)
	{
		flag[i]=false;
		turn_off(i);
	}
	for (scanf(&quot;%d&quot;,&amp;m);m;m--)
	{
		//printf(&quot;\n--------------------------------------------------------\n&quot;);
		char ch=getchar();
		while (ch!='C'&amp;&amp;ch!='G') ch=getchar();
		if (ch=='G') ans.out();
		else
		{
			scanf(&quot;%d&quot;,&amp;x);
			if (flag[x]) turn_off(x);
			else turn_on(x);
			flag[x]=!flag[x];
		}
	}
	return 0;
}<pre><h2>Problem1095</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;set&gt;
using namespace std;
const int NN=101111;
int o[NN],aa[NN*2][2],deep[NN],size[NN],fa[NN],boss[NN];
int n,m,tot=1;
struct Tree
{
	int deep[NN],fa[NN],f[NN][19];
	void dfs(int v)
	{
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[v]) continue;
			fa[y]=v;
			deep[y]=deep[v]+1;
			dfs(y);
		}
	}
	void build()
	{
		deep[1]=1;
		dfs(1);
		int i,j;
		for (i=1;i&lt;=n;i++) f[i][0]=fa[i];
		for (j=1;j&lt;=18;j++)
			for (i=1;i&lt;=n;i++) f[i][j]=f[f[i][j-1]][j-1];
	}
	int lca(int x,int y)
	{
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		int i;
		for (i=18;i&gt;=0;i--)
			if (deep[f[x][i]]&gt;=deep[y]) x=f[x][i];
		if (x==y) return x;
		for (i=18;i&gt;=0;i--)
			if (f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
		return f[x][0];
	}
	int dist(int x,int y)
	{
		return deep[x]+deep[y]-2*deep[lca(x,y)];
	}
} tree;
struct Super_heap
{
	multiset&lt;int&gt; S;
	multiset&lt;int&gt;::iterator it;
	void insert(int x) {S.insert(x);}
	void erase(int x) {S.erase(S.find(x));}
	int top() {it=S.end();it--;return *it;}
	int stop() {it=S.end();it--;it--;return *it;}
	int size() {return S.size();}
} A[NN],B[NN];
struct output
{
	Super_heap S;
	int num;
	void out()
	{
		if (S.size()) printf(&quot;%d\n&quot;,S.top());
		else if (num==0) printf(&quot;-1\n&quot;);
		else printf(&quot;0\n&quot;);
	}
	void add(int i)
	{
		if (B[i].size()&lt;2) return;
		S.insert(B[i].top()+B[i].stop());
	}
	void del(int i)
	{
		if (B[i].size()&lt;2) return;
		S.erase(B[i].top()+B[i].stop());
	}
} ans;
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void calcsize(int v)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]||y==fa[v]) continue;
		fa[y]=v;
		calcsize(y);
		size[v]+=size[y];
	}
}
int core(int v)
{
	fa[v]=0,calcsize(v);
	for (;;)
	{
		bool flag=false;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (deep[y]&lt;deep[v]) continue;
			if (size[y]*2&gt;size[v])
			{
				size[v]-=size[y];
				size[y]+=size[v];
				v=y;flag=true;break;
			}
		}
		if (!flag) break;
	}
	return v;
}
void work(int v)
{
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]) continue;
		y=core(y);
		deep[y]=deep[v]+1;
		boss[y]=v;
		work(y);
	}
}
void turn_off(int x)
{
	ans.num++;
	ans.del(x);
	B[x].insert(0);
	ans.add(x);
	for (int y=x;boss[y];y=boss[y])
	{
		int f=boss[y];
		ans.del(f);
		if (A[y].size())
			B[f].erase(A[y].top());
		A[y].insert(tree.dist(f,x));
		if (A[y].size())
			B[f].insert(A[y].top());
		ans.add(f);
	}
}
void turn_on(int x)
{
	ans.num--;
	ans.del(x);
	B[x].erase(0);
	ans.add(x);
	for (int y=x;boss[y];y=boss[y])
	{
		int f=boss[y];
		ans.del(f);
		if (A[y].size()) B[f].erase(A[y].top());
		A[y].erase(tree.dist(f,x));
		if (A[y].size()) B[f].insert(A[y].top());
		ans.add(f);
	}
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	tree.build();
	memset(deep,60,sizeof(deep));
	int t=core(1);
	deep[t]=1,work(t);
	static bool flag[NN];
	for (i=1;i&lt;=n;i++)
	{
		flag[i]=false;
		turn_off(i);
	}
	for (scanf(&quot;%d&quot;,&amp;m);m;m--)
	{
		char ch=getchar();
		while (ch!='C'&amp;&amp;ch!='G') ch=getchar();
		if (ch=='G') ans.out();
		else
		{
			scanf(&quot;%d&quot;,&amp;x);
			if (flag[x]) turn_off(x);
			else turn_on(x);
			flag[x]=!flag[x];
		}
	}
	return 0;
}<pre><h2>Problem1095</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;set&gt;
using namespace std;
const int NN=101111;
int o[NN],aa[NN*2][2],deep[NN],size[NN],fa[NN],boss[NN];
int n,m,tot=1;
struct Tree
{
	int deep[NN],fa[NN],f[NN][19];
	void dfs(int v)
	{
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[v]) continue;
			fa[y]=v;
			deep[y]=deep[v]+1;
			dfs(y);
		}
	}
	void build()
	{
		deep[1]=1;
		dfs(1);
		int i,j;
		for (i=1;i&lt;=n;i++) f[i][0]=fa[i];
		for (j=1;j&lt;=18;j++)
			for (i=1;i&lt;=n;i++) f[i][j]=f[f[i][j-1]][j-1];
	}
	int lca(int x,int y)
	{
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		int i;
		for (i=18;i&gt;=0;i--)
			if (deep[f[x][i]]&gt;=deep[y]) x=f[x][i];
		if (x==y) return x;
		for (i=18;i&gt;=0;i--)
			if (f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
		return f[x][0];
	}
	int dist(int x,int y)
	{
		return deep[x]+deep[y]-2*deep[lca(x,y)];
	}
} tree;
struct Super_heap
{
	multiset&lt;int&gt; S;
	multiset&lt;int&gt;::iterator it;
	void insert(int x) {S.insert(x);}
	void erase(int x) {S.erase(S.find(x));}
	int top() {it=S.end();it--;return *it;}
	int stop() {it=S.end();it--;it--;return *it;}
	int size() {return S.size();}
} A[NN],B[NN];
struct output
{
	Super_heap S;
	int num;
	void out()
	{
		if (S.size()) printf(&quot;%d\n&quot;,S.top());
		else if (num==0) printf(&quot;-1\n&quot;);
		else printf(&quot;0\n&quot;);
	}
	void add(int i)
	{
		if (B[i].size()&lt;2) return;
		S.insert(B[i].top()+B[i].stop());
	}
	void del(int i)
	{
		if (B[i].size()&lt;2) return;
		S.erase(B[i].top()+B[i].stop());
	}
} ans;
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void calcsize(int v)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]||y==fa[v]) continue;
		fa[y]=v;
		calcsize(y);
		size[v]+=size[y];
	}
}
int core(int v)
{
	fa[v]=0,calcsize(v);
	for (;;)
	{
		bool flag=false;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (deep[y]&lt;deep[v]) continue;
			if (size[y]*2&gt;size[v])
			{
				size[v]-=size[y];
				size[y]+=size[v];
				v=y;flag=true;break;
			}
		}
		if (!flag) break;
	}
	return v;
}
void work(int v)
{
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]) continue;
		y=core(y);
		deep[y]=deep[v]+1;
		boss[y]=v;
		work(y);
	}
}
void turn_off(int x)
{
	ans.num++;
	ans.del(x);
	B[x].insert(0);
	ans.add(x);
	for (int y=x;boss[y];y=boss[y])
	{
		int f=boss[y];
		ans.del(f);
		if (A[y].size()) B[f].erase(A[y].top());
		A[y].insert(tree.dist(f,x));
		if (A[y].size()) B[f].insert(A[y].top());
		ans.add(f);
	}
}
void turn_on(int x)
{
	ans.num--;
	ans.del(x);
	B[x].erase(0);
	ans.add(x);
	for (int y=x;boss[y];y=boss[y])
	{
		int f=boss[y];
		ans.del(f);
		if (A[y].size()) B[f].erase(A[y].top());
		A[y].erase(tree.dist(f,x));
		if (A[y].size()) B[f].insert(A[y].top());
		ans.add(f);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	tree.build();
	memset(deep,60,sizeof(deep));
	int t=core(1);
	deep[t]=1,work(t);
	static bool flag[NN];
	for (i=1;i&lt;=n;i++)
	{
		flag[i]=false;
		turn_off(i);
	}
	for (scanf(&quot;%d&quot;,&amp;m);m;m--)
	{
		char ch=getchar();
		while (ch!='C'&amp;&amp;ch!='G') ch=getchar();
		if (ch=='G') ans.out();
		else
		{
			scanf(&quot;%d&quot;,&amp;x);
			if (flag[x]) turn_off(x);
			else turn_on(x);
			flag[x]=!flag[x];
		}
	}
	return 0;
}<pre><h2>Problem1096</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define LL long long
int x,y,n,i,head,tail;
LL f[1100000],sumP[1100000],X[1100000],P[1100000],C[1100000],w[1100000],q[1100000];
LL cost(int i,int j)
{
	return w[j]-w[i-1]-sumP[i-1]*(X[j]-X[i-1]);
}
LL calc(int i)
{
	return f[i]-w[i]+sumP[i]*X[i];
}
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	for (i=1;i&lt;=n;i++) scanf(&quot;%lld%lld%lld&quot;,&amp;X[i],&amp;P[i],&amp;C[i]),sumP[i]=sumP[i-1]+P[i];
	for (i=1;i&lt;=n;i++) w[i]=w[i-1]+sumP[i-1]*(X[i]-X[i-1]);
	//for (i=1;i&lt;=n;i++) printf(&quot;%lld &quot;,w[i]);printf(&quot;\n&quot;);
	head=0,q[tail=1]=0;
	for (i=1;i&lt;=n;i++)
	{
		//j,k,i
		int j=q[head+1],k=q[head+2];
		while (tail&gt;head+1&amp;&amp;X[i]*(sumP[k]-sumP[j])&gt;=calc(k)-calc(j))
		{
			++head;
			j=q[head+1],k=q[head+2];
		}
		f[i]=f[j]+C[i]+cost(j+1,i);
		k=q[tail],j=q[tail-1];
		while (tail&gt;head+1&amp;&amp;(calc(i)-calc(k))*(sumP[k]-sumP[j])&lt;=(calc(k)-calc(j))*(sumP[i]-sumP[k]))
		{
			--tail;
			k=q[tail],j=q[tail-1];
		}
		q[++tail]=i;
	}
	//for (i=1;i&lt;=n;i++) printf(&quot;%lld &quot;,f[i]);printf(&quot;\n&quot;);
	printf(&quot;%lld\n&quot;,f[n]);
	return 0;
}
<pre><h2>Problem1100</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define sqr(x) ((LL)(x)*(x))
#define INF 99999999999999999ll
const LL NN=201111;
LL tes,n;
LL ss[NN&lt;&lt;2];
inline void read(LL &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
	if (f) x=-x;
}
struct poLL
{
	LL x,y;
	poLL(LL a=0,LL b=0) {x=a;y=b;}
	friend poLL operator -(poLL a,poLL b) {return poLL(a.x-b.x,a.y-b.y);}
	friend LL operator %(poLL a,poLL b) {return (LL)a.x*b.y-(LL)b.x*a.y;}
} q[NN];
LL work(LL len)
{
	static LL s[NN&lt;&lt;3];
	static LL b[NN&lt;&lt;3];
	LL cnt=0,i;
	s[0]=-INF;
	for (i=1;i&lt;=len;i++)
		s[++cnt]=INF,s[++cnt]=ss[i];
	s[++cnt]=INF;
	s[cnt+1]=-INF+1;
	//for (i=0;i&lt;=cnt+1;i++) printf(&quot;%I64d &quot;,s[i]);putchar('\n');
	LL id=0,right=0,res=0;
	for (i=1;i&lt;=cnt;i++)
	{
		if (right&gt;i) b[i]=min(b[(id&lt;&lt;1)-i],right-i);
		else b[i]=1;
		while (s[i+b[i]]==s[i-b[i]]) b[i]++;
		if (b[i]-1&gt;=n&lt;&lt;1) res++;
		if (i+b[i]&gt;right) right=i+b[i],id=i;
	}
	return res&gt;&gt;1;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%lld&quot;,&amp;tes);tes;tes--)
	{
		//printf(&quot;\n------------------------------------------------------------------\n&quot;);
		scanf(&quot;%lld&quot;,&amp;n);
		LL i;
		for (i=1;i&lt;=n;i++) scanf(&quot;%lld%lld&quot;,&amp;q[i].x,&amp;q[i].y);
		q[n+1]=q[1],q[n+2]=q[2];
		LL cnt=0;
		for (i=1;i&lt;=n;i++)
		{
			ss[++cnt]=sqr(q[i].x-q[i+1].x)+sqr(q[i].y-q[i+1].y);
			ss[++cnt]=(q[i]-q[i+1])%(q[i+2]-q[i+1]);
		}
		for (i=1;i&lt;=cnt;i++) ss[i+cnt]=ss[i];
		//for (i=1;i&lt;=cnt*2;i++) printf(&quot;%I64d &quot;,s[i]);putchar('\n');
		printf(&quot;%lld\n&quot;,work(cnt+cnt));
	}
	return 0;
}<pre><h2>Problem1100</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define sqr(x) ((x)*(x))
#define INF 99999999999999999ll
const LL NN=101111;
LL tes,n;
LL ss[NN&lt;&lt;2];
struct point
{
	LL x,y;
	point(LL a=0,LL b=0) {x=a;y=b;}
	friend point operator -(point a,point b) {return point(a.x-b.x,a.y-b.y);}
	friend LL operator %(point a,point b) {return a.x*b.y-b.x*a.y;}
} q[NN];
LL work(LL len)
{
	static LL s[NN&lt;&lt;3];
	static LL b[NN&lt;&lt;3];
	LL cnt=0,i;
	s[0]=-INF;
	for (i=1;i&lt;=len;i++)
		s[++cnt]=INF,s[++cnt]=ss[i];
	s[++cnt]=INF;
	s[cnt+1]=-INF+1;
	//for (i=0;i&lt;=cnt+1;i++) printf(&quot;%I64d &quot;,s[i]);putchar('\n');
	LL id=0,right=0,res=0;
	for (i=1;i&lt;=cnt;i++)
	{
		if (right&gt;i) b[i]=min(b[(id&lt;&lt;1)-i],right-i);
		else b[i]=1;
		while (s[i+b[i]]==s[i-b[i]]) b[i]++;
		if (b[i]-1&gt;=n&lt;&lt;1) res++;
		if (i+b[i]&gt;right) right=i+b[i],id=i;
	}
	return res&gt;&gt;1;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%lld&quot;,&amp;tes);tes;tes--)
	{
		//printf(&quot;\n------------------------------------------------------------------\n&quot;);
		scanf(&quot;%lld&quot;,&amp;n);
		LL i;
		for (i=1;i&lt;=n;i++) scanf(&quot;%lld%lld&quot;,&amp;q[i].x,&amp;q[i].y);
		q[n+1]=q[1],q[n+2]=q[2];
		LL cnt=0;
		for (i=1;i&lt;=n;i++)
		{
			ss[++cnt]=sqr(q[i].x-q[i+1].x)+sqr(q[i].y-q[i+1].y);
			ss[++cnt]=(q[i]-q[i+1])%(q[i+2]-q[i+1]);
		}
		for (i=1;i&lt;=cnt;i++) ss[i+cnt]=ss[i];
		printf(&quot;%lld\n&quot;,work(cnt+cnt));
	}
	return 0;
}<pre><h2>Problem1100</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define sqr(x) ((x)*(x))
#define INF 99999999999999999ll
const LL NN=101111;
int tes,n;
LL ss[NN&lt;&lt;2];
struct point
{
	LL x,y;
	point(LL a=0,LL b=0) {x=a;y=b;}
	friend point operator -(point a,point b) {return point(a.x-b.x,a.y-b.y);}
	friend LL operator %(point a,point b) {return a.x*b.y-b.x*a.y;}
} q[NN];
LL work(LL len)
{
	static LL s[NN&lt;&lt;3];
	static LL b[NN&lt;&lt;3];
	LL cnt=0,i;
	s[0]=-INF;
	for (i=1;i&lt;=len;i++)
		s[++cnt]=INF,s[++cnt]=ss[i];
	s[++cnt]=INF;
	s[cnt+1]=-INF+1;
	//for (i=0;i&lt;=cnt+1;i++) printf(&quot;%I64d &quot;,s[i]);putchar('\n');
	LL id=0,right=0,res=0;
	for (i=1;i&lt;=cnt;i++)
	{
		if (right&gt;i) b[i]=min(b[(id&lt;&lt;1)-i],right-i);
		else b[i]=1;
		while (s[i+b[i]]==s[i-b[i]]) b[i]++;
		if (b[i]-1&gt;=n&lt;&lt;1) res++;
		if (i+b[i]&gt;right) right=i+b[i],id=i;
	}
	return res&gt;&gt;1;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%lld&quot;,&amp;tes);tes;tes--)
	{
		//printf(&quot;\n------------------------------------------------------------------\n&quot;);
		scanf(&quot;%lld&quot;,&amp;n);
		LL i;
		for (i=1;i&lt;=n;i++) scanf(&quot;%lld%lld&quot;,&amp;q[i].x,&amp;q[i].y);
		q[n+1]=q[1],q[n+2]=q[2];
		LL cnt=0;
		for (i=1;i&lt;=n;i++)
		{
			ss[++cnt]=sqr(q[i].x-q[i+1].x)+sqr(q[i].y-q[i+1].y);
			ss[++cnt]=(q[i]-q[i+1])%(q[i+2]-q[i+1]);
		}
		for (i=1;i&lt;=cnt;i++) ss[i+cnt]=ss[i];
		printf(&quot;%lld\n&quot;,work(cnt+cnt));
	}
	return 0;
}<pre><h2>Problem1100</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define sqr(x) ((x)*(x))
#define INF 99999999999999999ll
const LL NN=101111;
int tes,n;
LL ss[NN&lt;&lt;2];
struct point
{
	LL x,y;
	point(LL a=0,LL b=0) {x=a;y=b;}
	friend point operator -(point a,point b) {return point(a.x-b.x,a.y-b.y);}
	friend LL operator %(point a,point b) {return a.x*b.y-b.x*a.y;}
} q[NN];
LL work(LL len)
{
	static LL s[NN&lt;&lt;3];
	static LL b[NN&lt;&lt;3];
	LL cnt=0,i;
	s[0]=-INF;
	for (i=1;i&lt;=len;i++)
		s[++cnt]=INF,s[++cnt]=ss[i];
	s[++cnt]=INF;
	s[cnt+1]=-INF+1;
	//for (i=0;i&lt;=cnt+1;i++) printf(&quot;%I64d &quot;,s[i]);putchar('\n');
	LL id=0,right=0,res=0;
	for (i=1;i&lt;=cnt;i++)
	{
		if (right&gt;i) b[i]=min(b[(id&lt;&lt;1)-i],right-i);
		else b[i]=1;
		while (s[i+b[i]]==s[i-b[i]]) b[i]++;
		if (b[i]-1&gt;=n&lt;&lt;1) res++;
		if (i+b[i]&gt;right) right=i+b[i],id=i;
	}
	return res&gt;&gt;1;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%lld&quot;,&amp;tes);tes;tes--)
	{
		//printf(&quot;\n------------------------------------------------------------------\n&quot;);
		scanf(&quot;%lld&quot;,&amp;n);
		int i;
		for (i=1;i&lt;=n;i++) scanf(&quot;%lld%lld&quot;,&amp;q[i].x,&amp;q[i].y);
		q[n+1]=q[1],q[n+2]=q[2];
		LL cnt=0;
		for (i=1;i&lt;=n;i++)
		{
			ss[++cnt]=sqr(q[i].x-q[i+1].x)+sqr(q[i].y-q[i+1].y);
			ss[++cnt]=(q[i]-q[i+1])%(q[i+2]-q[i+1]);
		}
		for (i=1;i&lt;=cnt;i++) ss[i+cnt]=ss[i];
		printf(&quot;%lld\n&quot;,work(cnt+cnt));
	}
	return 0;
}<pre><h2>Problem1101</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int NN=51111;
int pr[NN],miu[NN],sum[NN];
int cnt;
bool is[NN];
void prepare()
{
	memset(is,1,sizeof(is));
	is[1]=false;
	miu[1]=1;
	for (int i=2;i&lt;=50005;i++)
	{
		if (is[i]) pr[++cnt]=i,miu[i]=-1;
		for (int j=1;j&lt;=cnt;j++)
		{
			int x=i*pr[j];
			if (x&gt;50005) break;
			is[x]=false;
			if (i%pr[j]==0) {miu[x]=0;break;}
			else miu[x]=-miu[i];
		}
	}
	for (int i=1;i&lt;=50005;i++) sum[i]=sum[i-1]+miu[i];
}
int calc(int n,int m)
{
	if (n&gt;m) {int t=n;n=m;m=t;}
	int res=0,l,r;
	for (l=1;l&lt;=n;l=r+1)
	{
		r=min(n/(n/l),m/(m/l));
		res+=(sum[r]-sum[l-1])*(n/l)*(m/l);
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	prepare();
	int tes,n,m,d;
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;d);
		printf(&quot;%d\n&quot;,calc(n/d,m/d));
	}
	return 0;
}<pre><h2>Problem1102</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define M 1010
using namespace std;
int n,ans1,ans2,a[M][M];
bool flag,v[M][M];
/*
void Floodfill(int x,int y)
{
	static const int dx[]={-1,-1,-1,0,0,1,1,1};
	static const int dy[]={-1,0,1,-1,1,-1,0,1};
	int i;
	v[x][y]=true;
	for(i=0;i&lt;8;i++)
	{
		int xx=x+dx[i],yy=y+dy[i];
		if(xx&lt;=0||yy&lt;=0||xx&gt;n||yy&gt;n)
			continue;
		if(a[xx][yy]&gt;a[x][y])
			flag=false;
		if(a[xx][yy]==a[x][y]&amp;&amp;!v[xx][yy])
			Floodfill(xx,yy);
	}
}
*/
void Floodfill(int x,int y)
{
	static const int dx[]={-1,-1,-1,0,0,1,1,1};
	static const int dy[]={-1,0,1,-1,1,-1,0,1};
	static pair&lt;int,int&gt; q[M*M];
	int i,r=0,h=0;
	v[x][y]=true,q[++r]=make_pair(x,y);
	while(r!=h)
	{
		x=q[h+1].first;
		y=q[h+1].second;
		q[++h]=make_pair(0,0);
		for(i=0;i&lt;8;i++)
		{
			int xx=x+dx[i],yy=y+dy[i];
			if(xx&lt;=0||yy&lt;=0||xx&gt;n||yy&gt;n)
				continue;
			if(a[xx][yy]&gt;a[x][y])
				flag=false;
			if(a[xx][yy]==a[x][y]&amp;&amp;!v[xx][yy])
				v[xx][yy]=true,q[++r]=make_pair(xx,yy);
		}
	}
}
int main()
{
	int i,j;
	cin&gt;&gt;n;
	for(i=1;i&lt;=n;i++)
		for(j=1;j&lt;=n;j++)
			scanf(&quot;%d&quot;,&amp;a[i][j]);
	for(i=1;i&lt;=n;i++)
		for(j=1;j&lt;=n;j++)
			if(!v[i][j])
			{
				flag=true;
				Floodfill(i,j);
				ans1+=flag;
			}
	memset(v,0,sizeof v);
	for(i=1;i&lt;=n;i++)
		for(j=1;j&lt;=n;j++)
			a[i][j]=-a[i][j];
	for(i=1;i&lt;=n;i++)
		for(j=1;j&lt;=n;j++)
			if(!v[i][j])
			{
				flag=true;
				Floodfill(i,j);
				ans2+=flag;
			}
	cout&lt;&lt;ans1&lt;&lt;' '&lt;&lt;ans2&lt;&lt;endl;
	return 0;
}
<pre><h2>Problem1102</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef pair&lt;int,int&gt; pii;
#define mp make_pair
#define fi first
#define se second
const int NN=1005;
const int dx[8]={-1,-1,-1,0,0,1,1,1};
const int dy[8]={-1,0,1,-1,1,-1,0,1};
int a[NN][NN],n;
pii q[NN*NN];
bool vt[NN][NN];
bool bfs(int x,int y)
{
	vt[x][y]=true;
	int head=0,tail=1;
	q[1]=mp(x,y);
	bool ok=true;
	while (head&lt;tail)
	{
		head++; x=q[head].fi,y=q[head].se;
		for (int i=0;i&lt;8;i++)
		{
			int xx=x+dx[i],yy=y+dy[i];
			if (xx&lt;1||xx&gt;n||yy&lt;1||yy&gt;n) continue;
			if (!vt[xx][yy]&amp;&amp;a[xx][yy]==a[x][y])
			{
				vt[xx][yy]=true;
				q[++tail]=mp(xx,yy);
			}
			else if (a[xx][yy]&gt;a[x][y]) ok=false;
		}
	}
	return ok;
}
int work()
{
	memset(vt,0,sizeof(vt));
	int res=0,i,j;
	for (i=1;i&lt;=n;i++) for (j=1;j&lt;=n;j++)
		if (!vt[i][j]&amp;&amp;bfs(i,j)) res++;
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++) scanf(&quot;%d&quot;,&amp;a[i][j]);
	printf(&quot;%d &quot;,work());
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++) a[i][j]=-a[i][j];
	printf(&quot;%d\n&quot;,work());
	return 0;
}<pre><h2>Problem1103</h2><pre>#include&lt;cstdio&gt;
#define lc(v) (v&lt;&lt;1)
#define rc(v) (lc(v)+1)
using namespace std;
int t[2100000],l[2100000],r[2100000];
int aa[510000][3],o[251000];
int a[510000],b[510000];
int first[251000],last[251000];
int tot,n,m,i,x,y;
char ch;
bool vt[251000];
void swap(int &amp;a,int &amp;b)
{
	int t=a;
	a=b;
	b=t;
}
void add(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=o[p];
	o[p]=tot;
}
void dfs(int v)
{
	vt[v]=1;
	a[++a[0]]=v;
	first[v]=a[0];
	b[a[0]]=1;
	int p=o[v];
	while (p)
	{
		if (!vt[aa[p][1]]) dfs(aa[p][1]);
		p=aa[p][2];
	}
	a[++a[0]]=v;
	last[v]=a[0];
	b[a[0]]=-1;
}
void update(int v)
{
	t[v]=t[lc(v)]+t[rc(v)];
}
void build(int v,int ll,int rr)
{
	l[v]=ll,r[v]=rr;
	if (rr-ll==1)
	{
		t[v]=b[ll];
		return;
	}
	int mid=(ll+rr)&gt;&gt;1;
	build(lc(v),ll,mid);
	build(rc(v),mid,rr);
	update(v);
}
void change(int v,int i,int x)
{
	if (r[v]-l[v]==1)
	{
		t[v]+=x;
		return;
	}
	int mid=(l[v]+r[v])&gt;&gt;1;
	if (i&lt;mid) change(lc(v),i,x);
	else change(rc(v),i,x);
	update(v);
}
int count(int v,int a,int b)
{
	if (a&lt;=l[v]&amp;&amp;r[v]&lt;=b) return t[v];
	int res=0,mid=(l[v]+r[v])&gt;&gt;1;
	if (a&lt;mid) res+=count(lc(v),a,b);
	if (b&gt;mid) res+=count(rc(v),a,b);
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d&quot;,&amp;n);
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		add(x,y);
		add(y,x);
	}
	dfs(1);
	b[1]=0,b[a[0]]=0;
	build(1,1,a[0]+1);
	//for (i=1;i&lt;=a[0];i++) printf(&quot;%d &quot;,a[i]);printf(&quot;\n&quot;);
	//for (i=1;i&lt;=a[0];i++) printf(&quot;%d &quot;,b[i]);printf(&quot;\n&quot;);
	scanf(&quot;%d\n&quot;,&amp;m);
	//printf(&quot;%d %d\n&quot;,n,m);
	//printf(&quot;\n&quot;);
	//for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,first[i]);printf(&quot;\n&quot;);
	//for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,last[i]);printf(&quot;\n&quot;);
	//printf(&quot;\n%s\n\n&quot;,&quot;-------input end---------&quot;);
	for (i=1;i&lt;=n+m-1;i++)
	{
		scanf(&quot;%c&quot;,&amp;ch);
		//printf(&quot;%c\n&quot;,ch);
		if (ch=='W')
		{
			scanf(&quot;%d\n&quot;,&amp;x);
			//printf(&quot;%d\n&quot;,x);
			printf(&quot;%d\n&quot;,count(1,1,first[x]+1));
			//printf(&quot;%d\n&quot;,x);
		}
		else
		{
			scanf(&quot;%d%d\n&quot;,&amp;x,&amp;y);
			if (first[x]&gt;first[y]) swap(x,y);
			change(1,first[y],-1);
			change(1,last[y],1);
		}
	}
	return 0;
}<pre><h2>Problem1104</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define M 1010
using namespace std;
struct abcd{
	int height,x,y;
	abcd() {}
	abcd(int _,int __,int ___):
		height(_),x(__),y(___) {}
	bool operator &lt; (const abcd &amp;a) const
	{
		return height &lt; a.height;
	}
}cities[M*M],map[M*M];
int n,m,ans,tot;
int a[M][M];
namespace Union_Find_Set{
	pair&lt;int,int&gt; fa[M][M];
	bool pumped[M][M];
	pair&lt;int,int&gt; Find(pair&lt;int,int&gt; x)
	{
		if(fa[x.first][x.second]==make_pair(0,0)||fa[x.first][x.second]==x)
			return fa[x.first][x.second]=x;
		return fa[x.first][x.second]=Find(fa[x.first][x.second]);
	}
	void Union(pair&lt;int,int&gt; x,pair&lt;int,int&gt; y)
	{
		x=Find(x);y=Find(y);
		if(x==y) return ;
		fa[x.first][x.second]=y;
		pumped[y.first][y.second]|=pumped[x.first][x.second];
	}
}
void Insert(int x,int y)
{
	using namespace Union_Find_Set;
	static const int dx[]={1,-1,0,0};
	static const int dy[]={0,0,1,-1};
	int i;
	for(i=0;i&lt;4;i++)
	{
		int xx=x+dx[i],yy=y+dy[i];
		if(xx&lt;=0||yy&lt;=0||xx&gt;m||yy&gt;n)
			continue;
		if(a[xx][yy]&gt;a[x][y])
			continue;
		Union(make_pair(x,y),make_pair(xx,yy));
	}
}
int main()
{
	using namespace Union_Find_Set;
	int i,j;
	cin&gt;&gt;m&gt;&gt;n;
	for(i=1;i&lt;=m;i++)
		for(j=1;j&lt;=n;j++)
		{
			scanf(&quot;%d&quot;,&amp;a[i][j]);
			if(a[i][j]&gt;0)
				new (&amp;cities[++tot])abcd(a[i][j],i,j);
			else
				a[i][j]=-a[i][j];
			new (&amp;map[i*n-n+j])abcd(a[i][j],i,j);
		}
	sort(cities+1,cities+tot+1);
	sort(map+1,map+m*n+1);
	for(j=1,i=1;i&lt;=tot;i++)
	{
		for(;j&lt;=m*n&amp;&amp;map[j].height&lt;=cities[i].height;j++)
			Insert(map[j].x,map[j].y);
		pair&lt;int,int&gt; temp=Find(make_pair(cities[i].x,cities[i].y));
		if(pumped[temp.first][temp.second])
			continue;
		++ans,pumped[temp.first][temp.second]=true;
	}
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}
<pre><h2>Problem1109</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
int c[1001111];
int n;
struct ppt
{
	int id,w;
	ppt(int a=0,int b=0) {id=a;w=b;}
	void out() {printf(&quot;w=%d id-w=%d\n&quot;,w,id-w);}
	friend bool operator &lt;(const ppt &amp;a,const ppt &amp;b) {return a.w&lt;b.w;}
} q[100111];
inline void change(int i,int x)
{
	//printf(&quot;change %d %d\n&quot;,i,x);
	for (;i&lt;=n;i+=i&amp;-i)
		if (x&gt;c[i]) c[i]=x;
}
inline int getmax(int i)
{
	//printf(&quot;getmax %d\n&quot;,i);
	int res=0;
	for (;i;i-=i&amp;-i)
		if (c[i]&gt;res) res=c[i];
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,cnt=0,x;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		if (i&gt;=x) q[++cnt]=ppt(i,x);
	}
	sort(q+1,q+cnt+1);
	//for (i=1;i&lt;=cnt;i++) q[i].out();ln;printf(&quot;b &quot;);
	int ans=0;
	for (int l=1,r;l&lt;=cnt;l=r+1)
	{
		for (r=l;r&lt;=cnt&amp;&amp;q[r].w==q[l].w;r++);
		r--;
		static int temp[101111];
		for (i=l;i&lt;=r;i++)
		{
			temp[i]=getmax(q[i].id-q[i].w+1)+1;
			if (temp[i]&gt;ans) ans=temp[i];
		}
		for (i=l;i&lt;=r;i++)
			change(q[i].id-q[i].w+1,temp[i]);
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1112</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int NN=101111,AA=2500000,mm=1000005;
int a[NN],lc[AA],rc[AA],size[AA];
int n,K,TTT,root;
LL tsum[AA];
void ins(int &amp;v,int l,int r,int x,int kind)
{
	if (!v) v=++TTT;
	size[v]+=kind;
	tsum[v]+=kind*x;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid) ins(lc[v],l,mid,x,kind);
	else ins(rc[v],mid,r,x,kind);
}
int getkth(int v,int l,int r,int K)
{
	if (r-l==1) return l;
	int mid=(l+r)&gt;&gt;1,tmp=size[lc[v]];
	if (K&lt;=tmp) return getkth(lc[v],l,mid,K);
	else return getkth(rc[v],mid,r,K-tmp);
}
LL find(int v,int l,int r,int x)
{
	if (v==0) return 0;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid)
		return tsum[rc[v]]-(LL)x*size[rc[v]]+find(lc[v],l,mid,x);
	else
		return (LL)x*size[lc[v]]-tsum[lc[v]]+find(rc[v],mid,r,x);
}
LL calc()
{
	int tmp=getkth(root,0,mm,(K+1)&gt;&gt;1);
	return find(root,0,mm,tmp);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	int i;
	for (i=1;i&lt;=K;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		ins(root,0,mm,a[i],1);
	}
	LL ans=calc();
	for (i=K+1;i&lt;=n;i++)
	{
		ins(root,0,mm,a[i-K],-1);
		scanf(&quot;%d&quot;,&amp;a[i]);
		ins(root,0,mm,a[i],1);
		ans=min(ans,calc());
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem1115</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int a[1111],b[1111],tes,n,ans,i;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
		for (i=n;i;i--) b[i]=a[i]-a[i-1];
		ans=0;
		for (i=1;i&lt;=n;i++)
			if ((i&amp;1)==(n&amp;1)) ans^=b[i];
		if (ans) printf(&quot;TAK\n&quot;);
		else printf(&quot;NIE\n&quot;);
	}
	return 0;
}
<pre><h2>Problem1127</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
const int NN=2005;
int a[NN][NN],left[NN][NN],right[NN][NN],up[NN][NN];
int n,K;
LL sum[NN][NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9')
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar();
}
inline LL getsum(int x1,int y1,int x2,int y2)
{
	return sum[x2][y2]-sum[x1-1][y2]-sum[x2][y1-1]+sum[x1-1][y1-1];
}
void work(int x1,int y1,int x2,int y2)
{
	while (getsum(x1,y1,x2,y2)&gt;K&lt;&lt;1)
	{
		if (x1==x2) y2--;
		else if (getsum(x1+1,y1,x2,y2)&gt;=K) x1++;
		else x2--;
	}
	printf(&quot;%d %d %d %d\n&quot;,y1,x1,y2,x2);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout); 
	read(K),read(n);
	int i,j;
	for (i=1;i&lt;=n;i++) for (j=1;j&lt;=n;j++)
	{
		read(a[i][j]);
		if (a[i][j]&gt;=K&amp;&amp;a[i][j]&lt;=K&lt;&lt;1)
		{
			printf(&quot;%d %d %d %d\n&quot;,j,i,j,i);
			return 0;
		}
		sum[i][j]=a[i][j]+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];
	}
	for (i=1;i&lt;=n;i++) for (j=1;j&lt;=n;j++)
		a[i][j]=(a[i][j]&lt;K)?0:1;
	//printf(&quot;a:\n&quot;);for(i=1;i&lt;=n;i++){for(j=1;j&lt;=n;j++)printf(&quot;%d &quot;,a[i][j]);ln;}ln;
	for (i=1;i&lt;=n;i++) right[0][i]=n+1;
	for (i=1;i&lt;=n;i++)
	{
		int now=0;
		for (j=1;j&lt;=n;j++)
			if (a[i][j]==1) now=j,left[i][j]=0;
			else
			{
				left[i][j]=max(now+1,left[i-1][j]);
				up[i][j]=up[i-1][j]+1;
			}
		now=n+1;
		for (j=n;j;j--)
			if (a[i][j]==1) now=j,right[i][j]=n+1;
			else
			{
				right[i][j]=min(now-1,right[i-1][j]);
				if (getsum(i-up[i][j]+1,left[i][j],i,right[i][j])&gt;=K)
				{
					work(i-up[i][j]+1,left[i][j],i,right[i][j]);
					return 0;
				}
			}
	}
	//printf(&quot;left:\n&quot;);for(i=1;i&lt;=n;i++){for(j=1;j&lt;=n;j++)printf(&quot;%d &quot;,left[i][j]);ln;}ln;
	//printf(&quot;right:\n&quot;);for(i=1;i&lt;=n;i++){for(j=1;j&lt;=n;j++)printf(&quot;%d &quot;,right[i][j]);ln;}ln;
	//printf(&quot;up:\n&quot;);for(i=1;i&lt;=n;i++){for(j=1;j&lt;=n;j++)printf(&quot;%d &quot;,up[i][j]);ln;}ln;
	printf(&quot;NIE\n&quot;);
	return 0;
}<pre><h2>Problem1127</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int NN=2003;
int a[NN][NN],left[NN][NN],right[NN][NN],up[NN][NN];
int n,K;
LL sum[NN][NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9')
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar();
}
inline LL getsum(int x1,int y1,int x2,int y2)
{
	return sum[x2][y2]-sum[x1-1][y2]-sum[x2][y1-1]+sum[x1-1][y1-1];
}
void work(int x1,int y1,int x2,int y2)
{
	while (getsum(x1,y1,x2,y2)&gt;K&lt;&lt;1)
	{
		if (x1==x2) y2--;
		else if (getsum(x1+1,y1,x2,y2)&gt;=K) x1++;
		else x2--;
	}
	printf(&quot;%d %d %d %d\n&quot;,y1,x1,y2,x2);
}
int main()
{
	read(K),read(n);
	int i,j;
	for (i=1;i&lt;=n;i++) for (j=1;j&lt;=n;j++)
	{
		read(a[i][j]);
		if (a[i][j]&gt;=K&amp;&amp;a[i][j]&lt;=K&lt;&lt;1)
		{
			printf(&quot;%d %d %d %d\n&quot;,j,i,j,i);
			return 0;
		}
		sum[i][j]=a[i][j]+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];
	}
	for (i=1;i&lt;=n;i++) for (j=1;j&lt;=n;j++)
		a[i][j]=(a[i][j]&lt;K)?0:1;
	for (i=1;i&lt;=n;i++) right[0][i]=n+1;
	for (i=1;i&lt;=n;i++)
	{
		int now=0;
		for (j=1;j&lt;=n;j++)
			if (a[i][j]==1) now=j,left[i][j]=0;
			else
			{
				left[i][j]=max(now+1,left[i-1][j]);
				up[i][j]=up[i-1][j]+1;
			}
		now=n+1;
		for (j=n;j;j--)
			if (a[i][j]==1) now=j,right[i][j]=n+1;
			else
			{
				right[i][j]=min(now-1,right[i-1][j]);
				if (getsum(i-up[i][j]+1,left[i][j],i,right[i][j])&gt;=K)
				{
					work(i-up[i][j]+1,left[i][j],i,right[i][j]);
					return 0;
				}
			}
	}
	printf(&quot;NIE\n&quot;);
	return 0;
}<pre><h2>Problem1142</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define p1 731
#define mo1 1000007
#define p2 19980723
#define ln printf(&quot;\n&quot;)
const int NN=1111;
int A[NN][NN],B[NN][NN],a1[NN],a2[NN],b1[NN],b2[NN],b[NN];
int n,m,tes;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		bool ok=true;
		int i,j;
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;A[i][j]);
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;B[i][j]);
		for (i=1;i&lt;=n;i++)
		{
			for (j=1;j&lt;=m;j++) b[j]=A[i][j];
			sort(b+1,b+m+1);
			int t1=0,t2=0;
			for (j=1;j&lt;=m;j++)
			{
				t1=(t1*p1+b[j])%mo1;
				t2=t2*p2+b[j];
			}
			a1[i]=t1,a2[i]=t2;
			for (j=1;j&lt;=m;j++) b[j]=B[i][j];
			sort(b+1,b+m+1);
			t1=t2=0;
			for (j=1;j&lt;=m;j++)
			{
				t1=(t1*p1+b[j])%mo1;
				t2=t2*p2+b[j];
			}
			b1[i]=t1,b2[i]=t2;
		}
		sort(a1+1,a1+n+1);
		sort(a2+1,a2+n+1);
		sort(b1+1,b1+n+1);
		sort(b2+1,b2+n+1);
		//for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,a1[i]);ln;for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,b1[i]);ln;
		//printf(&quot;%d\n&quot;,ok);
		for (i=1;i&lt;=n;i++)
		{
			if (a1[i]!=b1[i]) ok=false;
			if (a2[i]!=b2[i]) ok=false;
		}
		for (i=1;i&lt;=m;i++)
		{
			for (j=1;j&lt;=n;j++) b[j]=A[j][i];
			sort(b+1,b+n+1);
			int t1=0,t2=0;
			for (j=1;j&lt;=n;j++)
			{
				t1=(t1*p1+b[j])%mo1;
				t2=t2*p2+b[j];
			}
			a1[i]=t1,a2[i]=t2;
			for (j=1;j&lt;=n;j++) b[j]=B[j][i];
			sort(b+1,b+n+1);
			t1=t2=0;
			for (j=1;j&lt;=n;j++)
			{
				t1=(t1*p1+b[j])%mo1;
				t2=t2*p2+b[j];
			}
			b1[i]=t1,b2[i]=t2;
		}
		sort(a1+1,a1+m+1);
		sort(a2+1,a2+m+1);
		sort(b1+1,b1+m+1);
		sort(b2+1,b2+m+1);
		//for (i=1;i&lt;=m;i++) printf(&quot;%d &quot;,a2[i]);ln;for (i=1;i&lt;=m;i++) printf(&quot;%d &quot;,b2[i]);ln;
		for (i=1;i&lt;=m;i++)
		{
			if (a1[i]!=b1[i]) ok=false;
			if (a2[i]!=b2[i]) ok=false;
		}
		printf(ok?&quot;TAK\n&quot;:&quot;NIE\n&quot;);
	}
	return 0;
}<pre><h2>Problem1143</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mii(a,b) (a&lt;b?a:b)
#define inf 999999999
int aa[1000000][3],q[1000000],deep[1000000],o[1000000];
int n,m,tot=1,S,T;
bool bfs()
{
	int head=0,tail=1,x,y,p;
	q[1]=S;
	memset(deep,0,sizeof(deep));
	deep[S]=1;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[T];
}
int dfs(int v,int ff)
{
	if (v==T) return ff;
	int res=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(aa[p][2],ff));
		ff-=tmp;
		aa[p][2]-=tmp;
		aa[p^1][2]+=tmp;
		res+=tmp;
		if (!ff) break;
	}
	return res;
}
int getint()
{
	char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	int tmp=0;
	for (;'0'&lt;=ch&amp;&amp;ch&lt;='9';ch=getchar()) tmp=tmp*10+ch-'0';
	return tmp;
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v)
{
	addedge(p,q,v);
	addedge(q,p,0);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	n=getint(),m=getint();
	S=n*2+1,T=n*2+2;
	int i,ans=0;
	for (i=1;i&lt;=n;i++)
	{
		add(i,i+n,inf);
		add(S,i+n,1),add(i,T,1);
	}
	for (i=1;i&lt;=m;i++)
	{
		int x=getint(),y=getint();
		add(x+n,y,inf);
	}
	while (bfs()) ans+=dfs(S,inf);
	printf(&quot;%d\n&quot;,n-ans);
	return 0;
}
<pre><h2>Problem1143</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mii(a,b) (a&lt;b?a:b)
#define inf 999999999
int aa[1000000][3],q[1000000],deep[1000000],o[1000000];
int n,m,tot=1,S,T;
bool bfs()
{
	int head=0,tail=1,x,y,p;
	q[1]=S;
	memset(deep,0,sizeof(deep));
	deep[S]=1;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[T];
}
int dfs(int v,int ff)
{
	if (v==T) return ff;
	int res=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(aa[p][2],ff));
		ff-=tmp;
		aa[p][2]-=tmp;
		aa[p^1][2]+=tmp;
		res+=tmp;
		if (!ff) break;
	}
	if (!res) deep[v]=-1;
	return res;
}
int getint()
{
	char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	int tmp=0;
	for (;'0'&lt;=ch&amp;&amp;ch&lt;='9';ch=getchar()) tmp=tmp*10+ch-'0';
	return tmp;
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v)
{
	addedge(p,q,v);
	addedge(q,p,0);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	n=getint(),m=getint();
	S=n*2+1,T=n*2+2;
	int i,ans=0;
	for (i=1;i&lt;=n;i++)
	{
		add(i,i+n,inf);
		add(S,i+n,1),add(i,T,1);
	}
	for (i=1;i&lt;=m;i++)
	{
		int x=getint(),y=getint();
		add(x+n,y,inf);
	}
	while (bfs()) ans+=dfs(S,inf);
	printf(&quot;%d\n&quot;,n-ans);
	return 0;
}
<pre><h2>Problem1143</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mii(a,b) (a&lt;b?a:b)
#define inf 999999999
int aa[1000000][3],q[1000000],deep[1000000],o[1000000];
int n,m,tot=1,S,T;
bool bfs()
{
	int head=0,tail=1,x,y,p;
	q[1]=S;
	memset(deep,0,sizeof(deep));
	deep[S]=1;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[T];
}
int dfs(int v,int ff)
{
	if (v==T) return ff;
	int res=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(aa[p][2],ff));
		ff-=tmp;
		aa[p][2]-=tmp;
		aa[p^1][2]+=tmp;
		res+=tmp;
		if (!ff) break;
	}
	if (!res) deep[v]=-1;
	return res;
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v)
{
	addedge(p,q,v);
	addedge(q,p,0);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	S=n*2+1,T=n*2+2;
	int i,ans=0,x,y;
	for (i=1;i&lt;=n;i++)
	{
		add(i,i+n,inf);
		add(S,i+n,1),add(i,T,1);
	}
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		add(x+n,y,inf);
	}
	while (bfs()) ans+=dfs(S,inf);
	printf(&quot;%d\n&quot;,n-ans);
	return 0;
}
<pre><h2>Problem1143</h2><pre>#include &lt;cstdio&gt;
#define inf 9999
#define min(x,y) ((x)&lt;(y)?(x):(y))
using namespace std;
const int maxn=311,maxm=5011;
int a[maxm],next[maxm],last[maxn],point[maxn],f[maxm],n,m,mm,s,t,tot,ans,d[maxn],q[maxn];
void build(int x,int y,int ff)
{
    a[++mm]=y;
    next[mm]=last[x];
    last[x]=mm;
    f[mm]=ff;
    a[++mm]=x;
    next[mm]=last[y];
    last[y]=mm;
}
bool bfs()
{
    int x,dd,j,head=0,tail=1;
    for (j=1;j&lt;=tot;j++) last[j]=point[j],d[j]=-1;
    q[1]=s;
    d[s]=0;
    while (head&lt;tail)
    {
        x=q[++head],dd=d[x]+1;
        for (j=last[x];j;j=next[j]) if (f[j]&amp;&amp;d[a[j]]==-1)
        {
            d[a[j]]=dd,q[++tail]=a[j];
        }
    }
    return (d[t]!=-1);
}
int find(int now,int flow)
{
    if (now==t) return flow;
    int have=0,dd=d[now]+1,j,k;
    for (j=last[now];j;j=next[j]) if (f[j]&amp;&amp;d[a[j]]==dd)
    {
        last[now]=j;
        k=find(a[j],min(f[j],flow));
        flow-=k;
        have+=k;
        f[j]-=k;
        f[j^1]+=k;
        if (!flow) return have;
    }
    if (!have) d[now]=-1;
    return have;
}
void dinic()
{
    int tmp;
    while (bfs()) for (tmp=find(s,inf);tmp;tmp=find(s,inf)) ans+=tmp;
}
int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    int i,j,x,y;
    mm=1;
    for (i=1;i&lt;=m;i++) {scanf(&quot;%d%d&quot;,&amp;x,&amp;y); build(x,y+n,inf);}
    s=n*2+1,t=s+1,tot=t;
    for (i=1;i&lt;=n;i++) build(s,i,1),build(i+n,t,1),build(i+n,i,inf);
    for (i=1;i&lt;=tot;i++) point[i]=last[i];
    dinic();
    printf(&quot;%d\n&quot;,n-ans);
    return 0;
}
<pre><h2>Problem1143</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mii(a,b) (a&lt;b?a:b)
#define inf 999999999
int aa[1000000][3],q[1000000],deep[1000000],o[1000000];
int n,m,tot=1,S,T;
bool bfs()
{
	int head=0,tail=1,x,y,p,dd;
	q[1]=S;
	memset(deep,0,sizeof(deep));
	deep[S]=1;
	while (head&lt;tail)
	{
		x=q[++head];
		dd=deep[x]+1;
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=dd,q[++tail]=y;
		}
	}
	return deep[T];
}
int dfs(int v,int ff)
{
	if (v==T) return ff;
	int res=0,dd=deep[v]+1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=dd) continue;
		int tmp=dfs(y,mii(aa[p][2],ff));
		ff-=tmp;
		aa[p][2]-=tmp;
		aa[p^1][2]+=tmp;
		res+=tmp;
		if (!ff) break;
	}
	if (!res) deep[v]=-1;
	return res;
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v)
{
	addedge(p,q,v);
	addedge(q,p,0);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	S=n*2+1,T=S+1;
	int i,ans=0,x,y;
	for (i=1;i&lt;=n;i++)
	{
		add(i,i+n,inf);
		add(S,i+n,1),add(i,T,1);
	}
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		add(x+n,y,inf);
	}
	while (bfs()) ans+=dfs(S,inf);
	printf(&quot;%d\n&quot;,n-ans);
	return 0;
}
<pre><h2>Problem1143</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mii(a,b) (a&lt;b?a:b)
#define inf 999999999
int aa[6111][3],q[6111],deep[6111],o[6111];
int n,m,tot=1,S,T;
bool bfs()
{
	int head=0,tail=1,x,y,p,dd;
	q[1]=S;
	memset(deep,0,sizeof(deep));
	deep[S]=1;
	while (head&lt;tail)
	{
		x=q[++head];
		dd=deep[x]+1;
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=dd,q[++tail]=y;
		}
	}
	return deep[T];
}
int dfs(int v,int ff)
{
	if (v==T) return ff;
	int res=0,dd=deep[v]+1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=dd) continue;
		int tmp=dfs(y,mii(aa[p][2],ff));
		ff-=tmp;
		aa[p][2]-=tmp;
		aa[p^1][2]+=tmp;
		res+=tmp;
		if (!ff) break;
	}
	if (!res) deep[v]=-1;
	return res;
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v)
{
	addedge(p,q,v);
	addedge(q,p,0);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	S=n*2+1,T=S+1;
	int i,ans=0,x,y;
	for (i=1;i&lt;=n;i++)
	{
		add(i,i+n,inf);
		add(S,i+n,1),add(i,T,1);
	}
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		add(x+n,y,inf);
	}
	while (bfs()) ans+=dfs(S,inf);
	printf(&quot;%d\n&quot;,n-ans);
	return 0;
}
<pre><h2>Problem1143</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mii(a,b) (a&lt;b?a:b)
#define inf 999999999
int aa[6111][3],q[6111],deep[6111],o[6111],cur[6111];
int n,m,tot=1,S,T;
bool bfs()
{
	int head=0,tail=1,x,y,p,dd;
	q[1]=S;
	memset(deep,0,sizeof(deep));
	deep[S]=1;
	while (head&lt;tail)
	{
		x=q[++head];
		dd=deep[x]+1;
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=dd,q[++tail]=y;
		}
	}
	for (int i=1;i&lt;=T;i++) cur[i]=o[i];
	return deep[T];
}
int dfs(int v,int ff)
{
	if (v==T) return ff;
	int res=0,dd=deep[v]+1;
	for (int &amp;p=cur[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=dd) continue;
		int tmp=dfs(y,mii(aa[p][2],ff));
		ff-=tmp;
		aa[p][2]-=tmp;
		aa[p^1][2]+=tmp;
		res+=tmp;
		if (!ff) break;
	}
	if (!res) deep[v]=-1;
	return res;
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v)
{
	addedge(p,q,v);
	addedge(q,p,0);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	S=n*2+1,T=S+1;
	int i,ans=0,x,y;
	for (i=1;i&lt;=n;i++)
	{
		add(i,i+n,inf);
		add(S,i+n,1),add(i,T,1);
	}
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		add(x+n,y,inf);
	}
	while (bfs()) ans+=dfs(S,inf);
	printf(&quot;%d\n&quot;,n-ans);
	return 0;
}
<pre><h2>Problem1146</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define lowbit(i) (i&amp;-i)
#define inf 9999999
int w[80005],deep[80005],first[80005],second[80005],num[12800000],lc[12800000],rc[12800000];
int aa[400000][2],o[80005],a[80005],root[80005],now[80005],fa[80005][18],vt[80005];
int n,m,tot,SIZE,flag;
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs(int v)
{
	a[++a[0]]=v;
	first[v]=a[0];
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y!=fa[v][0])
		{
			deep[y]=deep[v]+1;
			fa[y][0]=v;
			dfs(y);
		}
	}
	//a[++a[0]]=v;
	second[v]=a[0];
}
void ins(int &amp;v,int l,int r,int x,int kind)
{
	if (!v) v=++SIZE;
	num[v]+=kind;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid) ins(lc[v],l,mid,x,kind);
	else ins(rc[v],mid,r,x,kind);
}
void change(int i,int x,int kind)
{
	for (;i&lt;=a[0];i+=lowbit(i)) ins(root[i],0,inf,x,kind);
}
int getsum(int i)
{
	int res=0;
	for (;i&gt;0;i-=lowbit(i)) res+=num[rc[now[i]]];
	return res;
}
void clear(int i)
{
	for (;i&gt;0;i-=lowbit(i)) now[i]=root[i];
}
void turn(int i,int kind)
{
	for (;i&gt;0;i-=lowbit(i))
		if (vt[i]!=flag)
		{
			vt[i]=flag;
			now[i]=kind?rc[now[i]]:lc[now[i]];
		}
}
int getlca(int x,int y)
{
	if (deep[x]&lt;deep[y]) swap(x,y);
	for (int i=17;i&gt;=0;i--)
		if (deep[fa[x][i]]&gt;=deep[y]) x=fa[x][i];
	if (x==y) return x;
	for (int i=17;i&gt;=0;i--)
		if (fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j,x,y,K;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;w[i]);
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y);
		addedge(y,x);
	}
	fa[1][0]=0,deep[1]=1;
	dfs(1);
	for (j=1;j&lt;=17;j++)
		for (i=1;i&lt;=n;i++)
			fa[i][j]=fa[fa[i][j-1]][j-1];
	for (i=1;i&lt;=n;i++) change(first[i],w[i],1),change(second[i]+1,w[i],-1);
	//for (i=1;i&lt;=a[0];i++) printf(&quot;%d &quot;,a[i]);printf(&quot;\n&quot;);
	for (;m;m--)
	{
		//printf(&quot;\n---------------------------------------------\n&quot;);
		scanf(&quot;%d%d%d&quot;,&amp;K,&amp;x,&amp;y);
		if (K==0)
		{
			change(first[x],w[x],-1);
			change(second[x]+1,w[x],1);
			change(first[x],y,1);
			change(second[x]+1,y,-1);
			w[x]=y;
		}
		else
		{
			int lca=getlca(x,y),tt=fa[lca][0];
			if (deep[x]+deep[y]-deep[lca]-deep[tt]&lt;K)
			{
				printf(&quot;invalid request!\n&quot;);
				continue;
			}
			//printf(&quot;%d\n&quot;,lca);
			//x+y-lca-fa[lca]
			int l=0,r=inf;
			clear(first[x]);
			clear(first[y]);
			clear(first[lca]);
			clear(first[tt]);
			while (r-l&gt;1)
			{
				int tmp=getsum(first[x])+getsum(first[y])-getsum(first[lca])-getsum(first[tt]);
				++flag;
				int mid=(l+r)&gt;&gt;1;
				if (K&lt;=tmp)
				{
					l=mid;
					turn(first[x],1);
					turn(first[y],1);
					turn(first[lca],1);
					turn(first[tt],1);
				}
				else
				{
					K-=tmp;
					r=mid;
					turn(first[x],0);
					turn(first[y],0);
					turn(first[lca],0);
					turn(first[tt],0);
				}
			}
			printf(&quot;%d\n&quot;,l);
		}
	}
	return 0;
}
<pre><h2>Problem1146</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define lowbit(i) (i&amp;-i)
#define inf 9999999
int w[80005],deep[80005],first[80005],second[80005],num[12800000],lc[12800000],rc[12800000];
int aa[400000][2],o[80005],a[80005],root[80005],now[80005],fa[80005][18],vt[80005];
int n,m,tot,SIZE,flag;
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs(int v)
{
	a[++a[0]]=v;
	first[v]=a[0];
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y!=fa[v][0])
		{
			deep[y]=deep[v]+1;
			fa[y][0]=v;
			dfs(y);
		}
	}
	second[v]=a[0];
}
void ins(int &amp;v,int l,int r,int x,int kind)
{
	if (!v) v=++SIZE;
	num[v]+=kind;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid) ins(lc[v],l,mid,x,kind);
	else ins(rc[v],mid,r,x,kind);
}
void change(int i,int x,int kind)
{
	for (;i&lt;=a[0];i+=lowbit(i)) ins(root[i],0,inf,x,kind);
}
int getsum(int i)
{
	int res=0;
	for (;i&gt;0;i-=lowbit(i)) res+=num[rc[now[i]]];
	return res;
}
void clear(int i)
{
	for (;i&gt;0;i-=lowbit(i)) now[i]=root[i];
}
void turn(int i,int kind)
{
	for (;i&gt;0;i-=lowbit(i))
		if (vt[i]!=flag)
		{
			vt[i]=flag;
			now[i]=kind?rc[now[i]]:lc[now[i]];
		}
}
int getlca(int x,int y)
{
	if (deep[x]&lt;deep[y]) swap(x,y);
	for (int i=17;i&gt;=0;i--)
		if (deep[fa[x][i]]&gt;=deep[y]) x=fa[x][i];
	if (x==y) return x;
	for (int i=17;i&gt;=0;i--)
		if (fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j,x,y,K;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;w[i]);
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y);
		addedge(y,x);
	}
	fa[1][0]=0,deep[1]=1;
	dfs(1);
	for (j=1;j&lt;=17;j++)
		for (i=1;i&lt;=n;i++)
			fa[i][j]=fa[fa[i][j-1]][j-1];
	for (i=1;i&lt;=n;i++) change(first[i],w[i],1),change(second[i]+1,w[i],-1);
	for (;m;m--)
	{
		scanf(&quot;%d%d%d&quot;,&amp;K,&amp;x,&amp;y);
		if (K==0)
		{
			change(first[x],w[x],-1);
			change(second[x]+1,w[x],1);
			change(first[x],y,1);
			change(second[x]+1,y,-1);
			w[x]=y;
		}
		else
		{
			int lca=getlca(x,y),tt=fa[lca][0];
			if (deep[x]+deep[y]-deep[lca]-deep[tt]&lt;K)
			{
				printf(&quot;invalid request!\n&quot;);
				continue;
			}
			int l=0,r=inf;
			clear(first[x]);
			clear(first[y]);
			clear(first[lca]);
			clear(first[tt]);
			while (r-l&gt;1)
			{
				int tmp=getsum(first[x])+getsum(first[y])-getsum(first[lca])-getsum(first[tt]);
				++flag;
				int mid=(l+r)&gt;&gt;1;
				if (K&lt;=tmp)
				{
					l=mid;
					turn(first[x],1);
					turn(first[y],1);
					turn(first[lca],1);
					turn(first[tt],1);
				}
				else
				{
					K-=tmp;
					r=mid;
					turn(first[x],0);
					turn(first[y],0);
					turn(first[lca],0);
					turn(first[tt],0);
				}
			}
			printf(&quot;%d\n&quot;,l);
		}
	}
	return 0;
}
<pre><h2>Problem1150</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
using namespace std;
typedef pair&lt;int,int&gt; pii;
#define ln printf(&quot;\n&quot;)
#define mp make_pair
#define fi first
#define se second
#define inf 999999999
const int NN=100111;
int a[NN],w[NN],pre[NN],nex[NN];
int n,K;
set&lt;pii&gt; S;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	int i;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	n--;
	for (i=1;i&lt;=n;i++) w[i]=a[i+1]-a[i];
	w[0]=w[n+1]=inf;
	//printf(&quot;w &quot;);for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,w[i]);ln;
	for (i=1;i&lt;n;i++) nex[i]=i+1;
	for (i=n;i&gt;1;i--) pre[i]=i-1;
	for (i=1;i&lt;=n;i++) S.insert(mp(w[i],i));
	int ans=0;
	for (i=1;i&lt;=K;i++)
	{
		//printf(&quot;\n---------------------------------------------------------------\n&quot;);
		pii tmp=*S.begin();
		int val=tmp.fi,t=tmp.se;
		ans+=val;
		S.erase(tmp);
		S.erase(mp(w[pre[t]],pre[t]));
		S.erase(mp(w[nex[t]],nex[t]));
		w[t]=w[pre[t]]+w[nex[t]]-w[t];
		//printf(&quot;w[t]=%d\n&quot;,w[t]);
		nex[pre[pre[t]]]=t;
		pre[t]=pre[pre[t]];
		pre[nex[nex[t]]]=t;
		nex[t]=nex[nex[t]];
		S.insert(mp(w[t],t));
		//printf(&quot;ans=%d\n&quot;,ans);
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1176</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define SZ 2001111
#define MM 201111
int c[SZ],vt[SZ],X[MM],Y[MM],id[MM],id2[MM],kind[MM],w[MM],b[MM],inc[MM],ans[MM];
int n,m,S,ask,TIME;
void out(int *a,int n){for (int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,a[i]);printf(&quot;\n&quot;);}
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);printf(&quot;\n&quot;);}
void change(int i,int x)
{
	for (;i&lt;=n;i+=(i&amp;-i)) c[i]+=x;
}
int getsum(int i)
{
	int res=0;
	for (;i;i-=(i&amp;-i)) res+=c[i];
	return res;
}
void cdq(int l,int r)
{
	if (l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	cdq(l,mid);
	cdq(mid+1,r);
	TIME++;
	//printf(&quot;\n---------------------- %d %d ------------------------\n&quot;,l,r);
	//printf(&quot;ans &quot;);out(ans,n);
	//printf(&quot;id &quot;);out(id,l,r);
	for (i=mid+1,j=l;i&lt;=r;i++)
	{
		for (;X[id[j]]&lt;=X[id[i]]&amp;&amp;j&lt;=mid;j++)
			if (kind[id[j]]==1) change(Y[id[j]],w[id[j]]),vt[j]=TIME;
		if (kind[id[i]]==2) ans[b[id[i]]]+=w[id[i]]*getsum(Y[id[i]]);
		//printf(&quot;ans &quot;);out(ans,n);
	}
	for (j=l;j&lt;=mid;j++)
		if (kind[id[j]]==1&amp;&amp;vt[j]==TIME) change(Y[id[j]],-w[id[j]]);
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if ((i&lt;=mid&amp;&amp;X[id[i]]&lt;=X[id[j]])||j&gt;r) id2[k]=id[i++];
		else id2[k]=id[j++];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
	//printf(&quot;cdq======\n&quot;);
	//printf(&quot;ans &quot;);out(ans,n);
	//printf(&quot;id &quot;);out(id,l,r);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;S,&amp;n);
	int i,x,x1,x2,y1,y2;
	for (m=ask=0;;)
	{
		scanf(&quot;%d&quot;,&amp;x);
		if (x==1)
		{
			kind[++m]=1;
			scanf(&quot;%d%d%d&quot;,&amp;X[m],&amp;Y[m],&amp;w[m]);
		}
		else if (x==2)
		{
			ask++;
			scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);
			inc[ask]=S*(x2-x1+1)*(y2-y1+1);
			kind[++m]=2,X[m]=x2,Y[m]=y2,w[m]=1,b[m]=ask;
			kind[++m]=2,X[m]=x1-1,Y[m]=y1-1,w[m]=1,b[m]=ask;
			kind[++m]=2,X[m]=x1-1,Y[m]=y2,w[m]=-1,b[m]=ask;
			kind[++m]=2,X[m]=x2,Y[m]=y1-1,w[m]=-1,b[m]=ask;
		}
		else break;
	}
	//for (i=1;i&lt;=m;i++) printf(&quot;%d %d %d %d %d\n&quot;,kind[i],X[i],Y[i],w[i],b[i]);
	for (i=1;i&lt;=m;i++) id[i]=i;
	cdq(1,m);
	for (i=1;i&lt;=ask;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem1176</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define SZ 2001111
#define MM 201111
int c[SZ],vt[SZ],X[MM],Y[MM],id[MM],id2[MM],kind[MM],w[MM],b[MM],inc[MM],ans[MM];
int n,m,S,ask,TIME;
void out(int *a,int n){for (int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,a[i]);printf(&quot;\n&quot;);}
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);printf(&quot;\n&quot;);}
void change(int i,int x)
{
	for (;i&lt;=n;i+=(i&amp;-i)) c[i]+=x;
}
int getsum(int i)
{
	int res=0;
	for (;i;i-=(i&amp;-i)) res+=c[i];
	return res;
}
void cdq(int l,int r)
{
	if (l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	cdq(l,mid);
	cdq(mid+1,r);
	TIME++;
	for (i=mid+1,j=l;i&lt;=r;i++)
	{
		for (;X[id[j]]&lt;=X[id[i]]&amp;&amp;j&lt;=mid;j++)
			if (kind[id[j]]==1) change(Y[id[j]],w[id[j]]),vt[j]=TIME;
		if (kind[id[i]]==2) ans[b[id[i]]]+=w[id[i]]*getsum(Y[id[i]]);
	}
	for (j=l;j&lt;=mid;j++)
		if (kind[id[j]]==1&amp;&amp;vt[j]==TIME) change(Y[id[j]],-w[id[j]]);
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if ((i&lt;=mid&amp;&amp;X[id[i]]&lt;=X[id[j]])||j&gt;r) id2[k]=id[i++];
		else id2[k]=id[j++];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;S,&amp;n);
	int i,x,x1,x2,y1,y2;
	for (m=ask=0;;)
	{
		scanf(&quot;%d&quot;,&amp;x);
		if (x==1)
		{
			kind[++m]=1;
			scanf(&quot;%d%d%d&quot;,&amp;X[m],&amp;Y[m],&amp;w[m]);
		}
		else if (x==2)
		{
			ask++;
			scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);
			inc[ask]=S*(x2-x1+1)*(y2-y1+1);
			kind[++m]=2,X[m]=x2,Y[m]=y2,w[m]=1,b[m]=ask;
			kind[++m]=2,X[m]=x1-1,Y[m]=y1-1,w[m]=1,b[m]=ask;
			kind[++m]=2,X[m]=x1-1,Y[m]=y2,w[m]=-1,b[m]=ask;
			kind[++m]=2,X[m]=x2,Y[m]=y1-1,w[m]=-1,b[m]=ask;
		}
		else break;
	}
	for (i=1;i&lt;=m;i++) id[i]=i;
	cdq(1,m);
	for (i=1;i&lt;=ask;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem1176</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define SZ 2001111
#define MM 201111
int c[SZ],vt[SZ],X[MM],Y[MM],id[MM],id2[MM],kind[MM],w[MM],b[MM],inc[MM],ans[MM];
int n,m,S,ask,TIME;
void change(int i,int x)
{
	for (;i&lt;=n;i+=(i&amp;-i)) c[i]+=x;
}
int getsum(int i)
{
	int res=0;
	for (;i;i-=(i&amp;-i)) res+=c[i];
	return res;
}
void cdq(int l,int r)
{
	if (l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	cdq(l,mid);cdq(mid+1,r);
	TIME++;
	for (i=mid+1,j=l;i&lt;=r;i++)
	{
		for (;X[id[j]]&lt;=X[id[i]]&amp;&amp;j&lt;=mid;j++)
			if (kind[id[j]]==1) change(Y[id[j]],w[id[j]]),vt[j]=TIME;
		if (kind[id[i]]==2) ans[b[id[i]]]+=w[id[i]]*getsum(Y[id[i]]);
	}
	for (j=l;j&lt;=mid;j++)//这里一定要把修改的改回来！
		if (kind[id[j]]==1&amp;&amp;vt[j]==TIME) change(Y[id[j]],-w[id[j]]);
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if ((i&lt;=mid&amp;&amp;X[id[i]]&lt;=X[id[j]])||j&gt;r) id2[k]=id[i++];
		else id2[k]=id[j++];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;S,&amp;n);
	int i,x,x1,x2,y1,y2;
	for (m=ask=0;;)
	{
		scanf(&quot;%d&quot;,&amp;x);
		if (x==1)
		{
			kind[++m]=1;
			scanf(&quot;%d%d%d&quot;,&amp;X[m],&amp;Y[m],&amp;w[m]);
		}
		else if (x==2)
		{
			ask++;
			scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);
			inc[ask]=S*(x2-x1+1)*(y2-y1+1);
			kind[++m]=2,X[m]=x2,Y[m]=y2,w[m]=1,b[m]=ask;
			kind[++m]=2,X[m]=x1-1,Y[m]=y1-1,w[m]=1,b[m]=ask;
			kind[++m]=2,X[m]=x1-1,Y[m]=y2,w[m]=-1,b[m]=ask;
			kind[++m]=2,X[m]=x2,Y[m]=y1-1,w[m]=-1,b[m]=ask;
		}
		else break;
	}
	for (i=1;i&lt;=m;i++) id[i]=i;
	cdq(1,m);
	for (i=1;i&lt;=ask;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem1176</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int c[2000005],ans[2001111],id[4000005],id2[4000005],vt[1000000];
int n,S,tot,cnt,TIME;
struct query
{
	int x,y,kind,id,t;
} q[4000005];
inline void change(int i,int x)
{
	for (;i&lt;=n;i+=i&amp;-i) c[i]+=x;
}
inline int getsum(int i)
{
	int res=0;
	for (;i;i-=i&amp;-i) res+=c[i];
	return res;
}
void cdq(int l,int r)
{
	if (l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	cdq(l,mid);cdq(mid+1,r);
	TIME++;
	for (i=mid+1,j=l;i&lt;=r;i++)
	{
		for (;q[id[j]].x&lt;=q[id[i]].x&amp;&amp;j&lt;=mid;j++)
			if (q[id[j]].kind==1) change(q[id[j]].y,q[id[j]].t),vt[j]=TIME;
		if (q[id[i]].kind==2) ans[q[id[i]].id]+=q[id[i]].t*getsum(q[id[i]].y);
	}
	for (j=l;j&lt;=mid;j++)//这里一定要把修改的改回来！
		if (q[id[j]].kind==1&amp;&amp;vt[j]==TIME) change(q[id[j]].y,-q[id[j]].t);
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if ((i&lt;=mid&amp;&amp;q[id[i]].x&lt;=q[id[j]].x)||j&gt;r) id2[k]=id[i++];
		else id2[k]=id[j++];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;S,&amp;n);
	int i,x,y,z,x1,x2,y1,y2;
	for (;;)
	{
		scanf(&quot;%d&quot;,&amp;x);
		if (x==3) break;
		if (x==1)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			tot++;
			q[tot].kind=1;
			q[tot].x=x,q[tot].y=y,q[tot].t=z;
		}
		else
		{
			scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);
			cnt++;
			ans[cnt]=(x2-x1+1)*(y2-y1+1)*S;
			tot++;q[tot].kind=2,q[tot].id=cnt,q[tot].x=x2,q[tot].y=y2,q[tot].t=1;
			tot++;q[tot].kind=2,q[tot].id=cnt,q[tot].x=x1-1,q[tot].y=y2,q[tot].t=-1;
			tot++;q[tot].kind=2,q[tot].id=cnt,q[tot].x=x2,q[tot].y=y1-1,q[tot].t=-1;
			tot++;q[tot].kind=2,q[tot].id=cnt,q[tot].x=x1-1,q[tot].y=y1-1,q[tot].t=1;
		}
	}
	for (i=1;i&lt;=tot;i++) id[i]=i;
	cdq(1,tot);
	for (i=1;i&lt;=cnt;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem1176</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int c[2000005],ans[2001111],id[4000005],id2[4000005],vt[1000000];
int n,S,tot,cnt,TIME;
struct query
{
	int x,y,kind,id,t;
} q[4000005];
inline void change(int i,int x)
{
	for (;i&lt;=n;i+=i&amp;-i) c[i]+=x;
}
inline int getsum(int i)
{
	int res=0;
	for (;i;i-=i&amp;-i) res+=c[i];
	return res;
}
inline void clear(int i)
{
	for (;i&lt;=n;i+=i&amp;-i) c[i]=0;
}
void cdq(int l,int r)
{
	if (l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	cdq(l,mid);cdq(mid+1,r);
	TIME++;
	for (i=mid+1,j=l;i&lt;=r;i++)
	{
		for (;q[id[j]].x&lt;=q[id[i]].x&amp;&amp;j&lt;=mid;j++)
			if (q[id[j]].kind==1) change(q[id[j]].y,q[id[j]].t),vt[j]=TIME;
		if (q[id[i]].kind==2) ans[q[id[i]].id]+=q[id[i]].t*getsum(q[id[i]].y);
	}
	for (j=l;j&lt;=mid;j++)//这里一定要把修改的改回来！
		if (q[id[j]].kind==1&amp;&amp;vt[j]==TIME) clear(q[id[j]].y);
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if ((i&lt;=mid&amp;&amp;q[id[i]].x&lt;=q[id[j]].x)||j&gt;r) id2[k]=id[i++];
		else id2[k]=id[j++];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;S,&amp;n);
	int i,x,y,z,x1,x2,y1,y2;
	for (;;)
	{
		scanf(&quot;%d&quot;,&amp;x);
		if (x==3) break;
		if (x==1)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			tot++;
			q[tot].kind=1;
			q[tot].x=x,q[tot].y=y,q[tot].t=z;
		}
		else
		{
			scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);
			cnt++;
			ans[cnt]=(x2-x1+1)*(y2-y1+1)*S;
			tot++;q[tot].kind=2,q[tot].id=cnt,q[tot].x=x2,q[tot].y=y2,q[tot].t=1;
			tot++;q[tot].kind=2,q[tot].id=cnt,q[tot].x=x1-1,q[tot].y=y2,q[tot].t=-1;
			tot++;q[tot].kind=2,q[tot].id=cnt,q[tot].x=x2,q[tot].y=y1-1,q[tot].t=-1;
			tot++;q[tot].kind=2,q[tot].id=cnt,q[tot].x=x1-1,q[tot].y=y1-1,q[tot].t=1;
		}
	}
	for (i=1;i&lt;=tot;i++) id[i]=i;
	cdq(1,tot);
	for (i=1;i&lt;=cnt;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem1176</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int c[2000005],ans[2001111],id[4000005],id2[4000005],vt[1000000];
int n,S,tot,cnt,TIME;
struct query
{
	int x,y,kind,id,t;
} q[4000005];
inline void change(int i,int x)
{
	for (;i&lt;=n;i+=i&amp;-i) c[i]+=x;
}
inline int getsum(int i)
{
	int res=0;
	for (;i;i-=i&amp;-i) res+=c[i];
	return res;
}
inline void clear(int i)
{
	for (;i&lt;=n;i+=i&amp;-i) c[i]=0;
}
void cdq(int l,int r)
{
	if (l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	cdq(l,mid);cdq(mid+1,r);
	TIME++;
	for (i=mid+1,j=l;i&lt;=r;i++)
	{
		for (;q[id[j]].x&lt;=q[id[i]].x&amp;&amp;j&lt;=mid;j++)
			if (q[id[j]].kind==1) change(q[id[j]].y,q[id[j]].t),vt[j]=TIME;
		if (q[id[i]].kind==2) ans[q[id[i]].id]+=q[id[i]].t*getsum(q[id[i]].y);
	}
	for (j=l;j&lt;=mid;j++)//这里一定要把修改的改回来！
		if (q[id[j]].kind==1) clear(q[id[j]].y);
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if ((i&lt;=mid&amp;&amp;q[id[i]].x&lt;=q[id[j]].x)||j&gt;r) id2[k]=id[i++];
		else id2[k]=id[j++];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;S,&amp;n);
	int i,x,y,z,x1,x2,y1,y2;
	for (;;)
	{
		scanf(&quot;%d&quot;,&amp;x);
		if (x==3) break;
		if (x==1)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			tot++;
			q[tot].kind=1;
			q[tot].x=x,q[tot].y=y,q[tot].t=z;
		}
		else
		{
			scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);
			cnt++;
			ans[cnt]=(x2-x1+1)*(y2-y1+1)*S;
			tot++;q[tot].kind=2,q[tot].id=cnt,q[tot].x=x2,q[tot].y=y2,q[tot].t=1;
			tot++;q[tot].kind=2,q[tot].id=cnt,q[tot].x=x1-1,q[tot].y=y2,q[tot].t=-1;
			tot++;q[tot].kind=2,q[tot].id=cnt,q[tot].x=x2,q[tot].y=y1-1,q[tot].t=-1;
			tot++;q[tot].kind=2,q[tot].id=cnt,q[tot].x=x1-1,q[tot].y=y1-1,q[tot].t=1;
		}
	}
	for (i=1;i&lt;=tot;i++) id[i]=i;
	cdq(1,tot);
	for (i=1;i&lt;=cnt;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem1176</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int c[2000005],ans[2001111],id[4000005],id2[4000005];
int n,S,tot,cnt;
struct query
{
    int x,y,kind,id,t;
} q[4000005];
inline void change(int i,int x)
{
    for (;i&lt;=n;i+=i&amp;-i) c[i]+=x;
}
inline int getsum(int i)
{
    int res=0;
    for (;i;i-=i&amp;-i) res+=c[i];
    return res;
}
inline void clear(int i)
{
    for (;i&lt;=n;i+=i&amp;-i) c[i]=0;
}
void work(int l,int r)
{
    if (l==r) return;
    int mid=(l+r)&gt;&gt;1,i,j,k;
    work(l,mid),work(mid+1,r);
    for (j=l,i=mid+1;i&lt;=r;i++)
    {
        int t=id[i];
        for (int w=id[j];j&lt;=mid&amp;&amp;q[w].x&lt;=q[t].x;w=id[++j])
            if (q[w].kind==1) change(q[w].y,q[w].t);
        if (q[t].kind==2) ans[q[t].id]+=q[t].t*getsum(q[t].y);
    }
    for (int w=id[j=l];j&lt;=mid;w=id[++j])
        if (q[w].kind==1) clear(q[w].y);
    for (i=l,j=mid+1,k=l;k&lt;=r;k++)
        if (j&gt;r||(i&lt;=mid&amp;&amp;q[id[i]].x&lt;=q[id[j]].x)) id2[k]=id[i++];
        else id2[k]=id[j++];
    for (k=l;k&lt;=r;k++) id[k]=id2[k];
}
int main()
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d%d&quot;,&amp;S,&amp;n);
    int i,x,y,z,x1,x2,y1,y2;
    for (;;)
    {
        scanf(&quot;%d&quot;,&amp;x);
        if (x==3) break;
        if (x==1)
        {
            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
            tot++;
            q[tot].kind=1;
            q[tot].x=x,q[tot].y=y,q[tot].t=z;
        }
        else
        {
            scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);
            cnt++;
            ans[cnt]=(x2-x1+1)*(y2-y1+1)*S;
            tot++;q[tot].kind=2,q[tot].id=cnt,q[tot].x=x2,q[tot].y=y2,q[tot].t=1;
            tot++;q[tot].kind=2,q[tot].id=cnt,q[tot].x=x1-1,q[tot].y=y2,q[tot].t=-1;
            tot++;q[tot].kind=2,q[tot].id=cnt,q[tot].x=x2,q[tot].y=y1-1,q[tot].t=-1;
            tot++;q[tot].kind=2,q[tot].id=cnt,q[tot].x=x1-1,q[tot].y=y1-1,q[tot].t=1;
        }
    }
    for (i=1;i&lt;=tot;i++) id[i]=i;
    work(1,tot);
    for (i=1;i&lt;=cnt;i++) printf(&quot;%d\n&quot;,ans[i]);
    return 0;
}<pre><h2>Problem1176</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int id[2001111],id2[2001111],ans[101111];
int S,W,cnt,m;
struct info
{
	int kind,x,y,k,t;
} q[2001111];
struct BIT
{
	int c[20000005];
	void change(int i,int x)
	{
		for (;i&lt;=W;i+=i&amp;-i) c[i]+=x;
	}
	int getsum(int i)
	{
		int res=0;
		for (;i;i-=i&amp;-i) res+=c[i];
		return res;
	}
	void clear(int i)
	{
		for (;i&lt;=W;i+=i&amp;-i) c[i]=0;
	}
} C;

void work(int l,int r)
{
    if (l==r) return;
    int mid=(l+r)&gt;&gt;1,i,j,k;
    work(l,mid),work(mid+1,r);
    for (j=l,i=mid+1;i&lt;=r;i++)
    {
        int t=id[i];
        for (int w=id[j];j&lt;=mid&amp;&amp;q[w].x&lt;=q[t].x;w=id[++j])
            if (q[w].kind==1) C.change(q[w].y,q[w].k);
        if (q[t].kind==2) ans[q[t].k]+=q[t].t*C.getsum(q[t].y);
    }
    for (int w=id[j=l];j&lt;=mid;w=id[++j])
        if (q[w].kind==1) C.clear(q[w].y);
    for (i=l,j=mid+1,k=l;k&lt;=r;k++)
        if (j&gt;r||(i&lt;=mid&amp;&amp;q[id[i]].x&lt;=q[id[j]].x)) id2[k]=id[i++];
        else id2[k]=id[j++];
    for (k=l;k&lt;=r;k++) id[k]=id2[k];
}
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;S,&amp;W);W++;
	for (;;)
	{
		int x,x1,x2,y1,y2;
		scanf(&quot;%d&quot;,&amp;x);
		if (x==1)
		{
			cnt++;q[cnt].kind=1;
			scanf(&quot;%d%d%d&quot;,&amp;q[cnt].x,&amp;q[cnt].y,&amp;q[cnt].k);
			q[cnt].x++,q[cnt].y++;
		}
		else if (x==2)
		{
			scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);
			x1++,x2++,y1++,y2++;
			ans[++m]=(x2-x1+1)*(y2-y1+1)*S;
			cnt++;q[cnt].kind=2,q[cnt].x=x2,q[cnt].y=y2,q[cnt].k=m,q[cnt].t=1;
			cnt++;q[cnt].kind=2,q[cnt].x=x2,q[cnt].y=y1-1,q[cnt].k=m,q[cnt].t=-1;
			cnt++;q[cnt].kind=2,q[cnt].x=x1-1,q[cnt].y=y2,q[cnt].k=m,q[cnt].t=-1;
			cnt++;q[cnt].kind=2,q[cnt].x=x1-1,q[cnt].y=y1-1,q[cnt].k=m,q[cnt].t=1;
		}
		else break;
	}
	for (int i=1;i&lt;=cnt;i++) id[i]=i;
	work(1,cnt);
	for (int i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem1176</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int id[2001111],id2[2001111],ans[101111];
int S,W,cnt,m;
struct info
{
	int kind,x,y,k,t;
} q[2001111];
struct BIT
{
	int c[20000005];
	void change(int i,int x)
	{
		for (;i&lt;=W;i+=i&amp;-i) c[i]+=x;
	}
	int getsum(int i)
	{
		int res=0;
		for (;i;i-=i&amp;-i) res+=c[i];
		return res;
	}
	void clear(int i)
	{
		for (;i&lt;=W;i+=i&amp;-i) c[i]=0;
	}
} C;
void cdq(int l,int r)
{
	if (l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	cdq(l,mid),cdq(mid+1,r);
	for (i=mid+1,j=l;i&lt;=r;i++)
	{
		int t=id[i];
		for (int w=id[j];j&lt;=mid&amp;&amp;q[w].x&lt;=q[t].x;w=id[++j])
			if (q[w].kind==1) C.change(q[w].y,q[w].k);
		if (q[t].kind==2) ans[q[t].k]+=q[t].t*C.getsum(q[t].y);
	}
	for (j=l;j&lt;=mid;j++)
		if (q[id[j]].kind==1) C.clear(q[id[j]].y);
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if (j&gt;r||(i&lt;=mid&amp;&amp;q[id[i]].x&lt;q[id[j]].x)) id2[k]=id[i++];
		else id2[k]=id[j++];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;S,&amp;W);W++;
	for (;;)
	{
		int x,x1,x2,y1,y2;
		scanf(&quot;%d&quot;,&amp;x);
		if (x==1)
		{
			cnt++;q[cnt].kind=1;
			scanf(&quot;%d%d%d&quot;,&amp;q[cnt].x,&amp;q[cnt].y,&amp;q[cnt].k);
			q[cnt].x++,q[cnt].y++;
		}
		else if (x==2)
		{
			scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);
			x1++,x2++,y1++,y2++;
			ans[++m]=(x2-x1+1)*(y2-y1+1)*S;
			cnt++;q[cnt].kind=2,q[cnt].x=x2,q[cnt].y=y2,q[cnt].k=m,q[cnt].t=1;
			cnt++;q[cnt].kind=2,q[cnt].x=x2,q[cnt].y=y1-1,q[cnt].k=m,q[cnt].t=-1;
			cnt++;q[cnt].kind=2,q[cnt].x=x1-1,q[cnt].y=y2,q[cnt].k=m,q[cnt].t=-1;
			cnt++;q[cnt].kind=2,q[cnt].x=x1-1,q[cnt].y=y1-1,q[cnt].k=m,q[cnt].t=1;
		}
		else break;
	}
	for (int i=1;i&lt;=cnt;i++) id[i]=i;
	cdq(1,cnt);
	for (int i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem1176</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int id[201111],id2[201111],ans[11111];
int S,W,cnt,m;
struct info
{
	int kind,x,y,k,t;
} q[201111];
struct BIT
{
	int c[2000005];
	void change(int i,int x)
	{
		for (;i&lt;=W;i+=i&amp;-i) c[i]+=x;
	}
	int getsum(int i)
	{
		int res=0;
		for (;i;i-=i&amp;-i) res+=c[i];
		return res;
	}
	void clear(int i)
	{
		for (;i&lt;=W;i+=i&amp;-i) c[i]=0;
	}
} C;
void cdq(int l,int r)
{
	if (l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	cdq(l,mid),cdq(mid+1,r);
	for (i=mid+1,j=l;i&lt;=r;i++)
	{
		int t=id[i];
		for (int w=id[j];j&lt;=mid&amp;&amp;q[w].x&lt;=q[t].x;w=id[++j])
			if (q[w].kind==1) C.change(q[w].y,q[w].k);
		if (q[t].kind==2) ans[q[t].k]+=q[t].t*C.getsum(q[t].y);
	}
	for (j=l;j&lt;=mid;j++)
		if (q[id[j]].kind==1) C.clear(q[id[j]].y);
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if (j&gt;r||(i&lt;=mid&amp;&amp;q[id[i]].x&lt;q[id[j]].x)) id2[k]=id[i++];
		else id2[k]=id[j++];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;S,&amp;W);W++;
	for (;;)
	{
		int x,x1,x2,y1,y2;
		scanf(&quot;%d&quot;,&amp;x);
		if (x==1)
		{
			cnt++;q[cnt].kind=1;
			scanf(&quot;%d%d%d&quot;,&amp;q[cnt].x,&amp;q[cnt].y,&amp;q[cnt].k);
			q[cnt].x++,q[cnt].y++;
		}
		else if (x==2)
		{
			scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);
			x1++,x2++,y1++,y2++;
			ans[++m]=(x2-x1+1)*(y2-y1+1)*S;
			cnt++;q[cnt].kind=2,q[cnt].x=x2,q[cnt].y=y2,q[cnt].k=m,q[cnt].t=1;
			cnt++;q[cnt].kind=2,q[cnt].x=x2,q[cnt].y=y1-1,q[cnt].k=m,q[cnt].t=-1;
			cnt++;q[cnt].kind=2,q[cnt].x=x1-1,q[cnt].y=y2,q[cnt].k=m,q[cnt].t=-1;
			cnt++;q[cnt].kind=2,q[cnt].x=x1-1,q[cnt].y=y1-1,q[cnt].k=m,q[cnt].t=1;
		}
		else break;
	}
	for (int i=1;i&lt;=cnt;i++) id[i]=i;
	cdq(1,cnt);
	for (int i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem1179</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 1000000005
#define ln printf(&quot;\n&quot;)
const int NN=501111;
int o[NN],aa[NN][2],low[NN],dfn[NN],sta[NN],b[NN],belong[NN],w[NN],f[NN],du[NN];
int n,m,tot,TIME,S,P,top,cnt;
bool vt[NN],flag[NN];
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);ln;}
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar()) x=x*10+ch-'0';
	if (f) x=-x;
}
inline void addedge(int p,int q)
{
	//if (vt[1]) printf(&quot;addedge %d %d\n&quot;,p,q);
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
struct edge
{
	int u,v;
} e[NN];
void dfs(int v)
{
	vt[v]=true;
	low[v]=dfn[v]=++TIME;
	sta[++top]=v;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!vt[y])
		{
			dfs(y);
			low[v]=min(low[v],low[y]);
		}
		else if (!belong[y])
			low[v]=min(low[v],dfn[y]);
	}
	if(low[v]==dfn[v])
	{
		cnt++;
		while (sta[top+1]!=v) belong[sta[top--]]=cnt;
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	int i,x;
	for (i=1;i&lt;=m;i++)
	{
		read(e[i].u),read(e[i].v);
		addedge(e[i].u,e[i].v);
	}
	for (i=1;i&lt;=n;i++)
		if (!vt[i]) dfs(i);
	//printf(&quot;belong &quot;);out(belong,1,n);
	for (i=1;i&lt;=n;i++)
	{
		read(x);
		w[belong[i]]+=x;
	}
	read(S),read(P);
	S=belong[S];
	for (i=1;i&lt;=P;i++)
	{
		read(x);
		flag[belong[x]]=true;
	}
	//printf(&quot;w &quot;);out(w,1,cnt);printf(&quot;flag &quot;);for(i=1;i&lt;=cnt;i++)printf(&quot;%d &quot;,flag[i]);ln;ln;
	for (i=1;i&lt;=cnt;i++) o[i]=0;
	for (i=1;i&lt;=m;i++)
	{
		int u=belong[e[i].u],v=belong[e[i].v];
		if (u!=v)
		{
			du[v]++;
			addedge(u,v);
		}
	}
	top=0;
	for (i=1;i&lt;=cnt;i++)
		if (du[i]==0) sta[++top]=i;
	while (top)
	{
		int x=sta[top--];
		b[++b[0]]=x;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (--du[y]==0) sta[++top]=y;
		}
	}
	//ln;printf(&quot;b &quot;);out(b,1,cnt);ln;
	for (i=1;i&lt;=cnt;i++)
		if (flag[i]) f[i]=w[i];
		else f[i]=-inf;
	for (i=cnt;i;i--)
	{
		x=b[i];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (f[y]+w[x]&gt;f[x]) f[x]=f[y]+w[x];
		}
	}
	printf(&quot;%d\n&quot;,f[S]);
	return 0;
}<pre><h2>Problem1180</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define NN 31000
int fa[NN],tsum[NN],son[NN][2],w[NN];
int n,m;
bool tag[NN],root[NN];
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
void update(int v)
{
	tsum[v]=w[v]+tsum[son[v][0]]+tsum[son[v][1]];
}
void make(int v)
{
	tag[v]=!tag[v];
	swap(son[v][0],son[v][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	make(son[v][0]);
	make(son[v][1]);
	tag[v]=false;
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (root[y]) root[t]=true,root[y]=false;
	else
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]&gt;0) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!root[t])
	{
		int y=fa[t];
		if (root[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
}
int access(int x)
{
	int y=0;
	for (;x&gt;0;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		root[son[x][1]]=true;
		son[x][1]=y;
		root[y]=false;
		update(x);
	}
	return y;
}
int getroot(int x)
{
	access(x);
	splay(x);
	int t=x;
	for (;son[t][0]&gt;0;t=son[t][0]);
	return t;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;w[i]);
		root[i]=true;
		fa[i]=0;
	}
	for (scanf(&quot;%d\n&quot;,&amp;m);m;m--)
	{
		char s[10];
		scanf(&quot;%s%d%d\n&quot;,s,&amp;x,&amp;y);
		if (s[0]=='b')
		{
			if (getroot(x)==getroot(y))
			{
				printf(&quot;no\n&quot;);
				continue;
			}
			printf(&quot;yes\n&quot;);
			access(y);
			splay(y);
			make(y);
			fa[y]=x;
		}
		else if (s[0]=='p')
		{
			w[x]=y;
			splay(x);
		}
		else
		{
			if (getroot(x)!=getroot(y))
			{
				printf(&quot;impossible\n&quot;);
				continue;
			}
			access(x);
			int k=access(y);
			int ans=w[k]+tsum[son[k][1]];
			if (k!=x)
			{
				splay(x);
				ans+=tsum[x];
			}
			printf(&quot;%d\n&quot;,ans);
		}
	}
	return 0;
}
<pre><h2>Problem1185</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
#define inf 999999999
#define ln printf(&quot;\n&quot;)
int n;
typedef long double DD;
DD ans;
const int NN=101111;
const DD eps=1e-8,pai=3.14159265358979;
struct point
{
	DD x,y;
	void in() {double xx,yy;scanf(&quot;%lf%lf&quot;,&amp;xx,&amp;yy);x=xx,y=yy;}
	void out() {printf(&quot;%.3f %.3f\n&quot;,(double)x,(double)y);}
	point(DD a=0,DD b=0) {x=a,y=b;}
	DD len() {return sqrt(x*x+y*y);}
	friend point operator *(DD t,point a) {a.x*=t,a.y*=t;return a;}
	friend point operator +(point a,point b) {a.x+=b.x;a.y+=b.y;return a;}
	friend point operator -(point a,point b) {a.x-=b.x;a.y-=b.y;return a;}
	friend DD operator %(point a,point b) {return a.x*b.y-b.x*a.y;}
	friend DD operator *(point a,point b) {return a.x*b.x+a.y*b.y;}
	friend bool operator &lt;(point a,point b) {return (fabs(a.y-b.y)&lt;eps)?(a.x-b.x&lt;-eps):(a.y-b.y&lt;-eps);}
} a[NN],b[NN],res[5];
point rotate(point a,DD sita)
{
	point tmp;
	tmp.x=a.x*cos(sita)-a.y*sin(sita);
	tmp.y=a.y*cos(sita)+a.x*sin(sita);
	return tmp;
}
point linejd(point P,point v,point Q,point w)//两直线交点 
{
	point u=P-Q;
	DD t=(w%u)/(v%w);
	return P+t*v;
}
point touying(point A,point P,point v)//点A在直线(P,v)上的投影点
{
	DD t=(P-A)*v/-(v*v);
	return P+t*v;
}
bool cmp1(point a,point b)
{
	if (fabs(a.x-b.x)&lt;eps) return a.y&lt;b.y;
	return a.x&lt;b.x;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,n1=2,n2=2,n3=2;
	for (i=1;i&lt;=n;i++) a[i].in();
	sort(a+1,a+n+1,cmp1);
	int num=0;
	for (i=1;i&lt;=n;i++)
	{
		while (num&gt;1&amp;&amp;(b[num]-b[num-1])%(a[i]-b[num-1])&lt;eps) num--;
		b[++num]=a[i];
	}
	int t=num;
	for (i=n-1;i;i--)
	{
		while (num&gt;t&amp;&amp;(b[num]-b[num-1])%(a[i]-b[num-1])&lt;eps) num--;
		b[++num]=a[i];
	}
	//for (i=1;i&lt;num;i++) b[i].out();
	num--;
	for (i=1;i&lt;=num;i++) b[i+num]=b[i];
	ans=inf;
	for (i=1;i&lt;=num;i++)
	{
		//printf(&quot;\n--------------------------------------------------------------\n&quot;);
		while ((b[i+1]-b[i])%(b[n1+1]-b[i])&gt;(b[i+1]-b[i])%(b[n1]-b[i])) n1++;
		while ((b[i+1]-b[i])*(b[n2+1]-b[i])&gt;(b[i+1]-b[i])*(b[n2]-b[i])) n2++;
		if (i==1) n3=n2;
		while ((b[i+1]-b[i])*(b[n3+1]-b[i])&lt;(b[i+1]-b[i])*(b[n3]-b[i])) n3++;
		//printf(&quot;n1=%d  n2=%d  n3=%d\n&quot;,n1,n2,n3);
		DD gao=(b[i+1]-b[i])%(b[n1]-b[i])/(b[i+1]-b[i]).len();
		DD kuan=(b[n2]-b[n3])*(b[i+1]-b[i])/(b[i+1]-b[i]).len();
		DD area=gao*kuan;
		if (area&lt;ans)
		{
			ans=area;
			res[1]=touying(b[n3],b[i],b[i+1]-b[i]);
			res[2]=touying(b[n2],b[i],b[i+1]-b[i]);
			res[3]=touying(b[n2],b[n1],b[i+1]-b[i]);
			res[4]=touying(b[n3],b[n1],b[i+1]-b[i]);
		}
	}
	//ln,ln;
	printf(&quot;%.5f\n&quot;,(double)ans);
	for (i=1;i&lt;=4;i++) res[i+4]=res[i];
	//for (i=1;i&lt;=4;i++) res[i].out();
	point mm=point(inf,inf);
	int mi=1;
	for (i=1;i&lt;=4;i++)
		if (res[i]&lt;mm) mm=res[i],mi=i;
	//printf(&quot;mi=%d\n&quot;,mi);
	for (t=1,i=mi;t&lt;=4;i++,t++) res[i].out();
	return 0;
}
<pre><h2>Problem1185</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
#define inf 999999999
int n;
typedef long double DD;
DD ans;
const int NN=101111;
const DD eps=1e-8,pai=3.14159265358979;
struct point
{
	DD x,y;
	void in() {double xx,yy;scanf(&quot;%lf%lf&quot;,&amp;xx,&amp;yy);x=xx,y=yy;}
	void out() {printf(&quot;%.3f %.3f\n&quot;,(double)x,(double)y);}
	point(DD a=0,DD b=0) {x=a,y=b;}
	DD len() {return sqrt(x*x+y*y);}
	friend point operator *(DD t,point a) {a.x*=t,a.y*=t;return a;}
	friend point operator +(point a,point b) {a.x+=b.x;a.y+=b.y;return a;}
	friend point operator -(point a,point b) {a.x-=b.x;a.y-=b.y;return a;}
	friend DD operator %(point a,point b) {return a.x*b.y-b.x*a.y;}
	friend DD operator *(point a,point b) {return a.x*b.x+a.y*b.y;}
	friend bool operator &lt;(point a,point b) {return (fabs(a.y-b.y)&lt;eps)?(a.x-b.x&lt;-eps):(a.y-b.y&lt;-eps);}
} a[NN],b[NN],res[5];
point rotate(point a,DD sita)
{
	point tmp;
	tmp.x=a.x*cos(sita)-a.y*sin(sita);
	tmp.y=a.y*cos(sita)+a.x*sin(sita);
	return tmp;
}
point touying(point A,point P,point v)
{
	DD t=(P-A)*v/-(v*v);
	return P+t*v;
}
bool cmp(point a,point b)
{
	if (fabs(a.x-b.x)&lt;eps) return a.y&lt;b.y;
	return a.x&lt;b.x;
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	int i,n1=2,n2=2,n3=2;
	for (i=1;i&lt;=n;i++) a[i].in();
	sort(a+1,a+n+1,cmp);
	int num=0;
	for (i=1;i&lt;=n;i++)
	{
		while (num&gt;1&amp;&amp;(b[num]-b[num-1])%(a[i]-b[num-1])&lt;eps) num--;
		b[++num]=a[i];
	}
	int t=num;
	for (i=n-1;i;i--)
	{
		while (num&gt;t&amp;&amp;(b[num]-b[num-1])%(a[i]-b[num-1])&lt;eps) num--;
		b[++num]=a[i];
	}
	num--;
	for (i=1;i&lt;=num;i++) b[i+num]=b[i];
	ans=inf;
	for (i=1;i&lt;=num;i++)
	{
		while ((b[i+1]-b[i])%(b[n1+1]-b[i])&gt;(b[i+1]-b[i])%(b[n1]-b[i])) n1++;
		while ((b[i+1]-b[i])*(b[n2+1]-b[i])&gt;(b[i+1]-b[i])*(b[n2]-b[i])) n2++;
		if (i==1) n3=n2;
		while ((b[i+1]-b[i])*(b[n3+1]-b[i])&lt;(b[i+1]-b[i])*(b[n3]-b[i])) n3++;
		DD gao=(b[i+1]-b[i])%(b[n1]-b[i])/(b[i+1]-b[i]).len();
		DD kuan=(b[n2]-b[n3])*(b[i+1]-b[i])/(b[i+1]-b[i]).len();
		DD area=gao*kuan;
		if (area&lt;ans)
		{
			ans=area;
			res[1]=touying(b[n3],b[i],b[i+1]-b[i]);
			res[2]=touying(b[n2],b[i],b[i+1]-b[i]);
			res[3]=touying(b[n2],b[n1],b[i+1]-b[i]);
			res[4]=touying(b[n3],b[n1],b[i+1]-b[i]);
		}
	}
	printf(&quot;%.5f\n&quot;,(double)ans);
	for (i=1;i&lt;=4;i++) res[i+4]=res[i];
	point mm=point(inf,inf);
	int mi=1;
	for (i=1;i&lt;=4;i++)
		if (res[i]&lt;mm) mm=res[i],mi=i;
	for (t=1,i=mi;t&lt;=4;i++,t++) res[i].out();
	return 0;
}
<pre><h2>Problem1187</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
#define inf 999999999
int n,m,now,ans,w[111][11];
bool can[111][11];
int pack(int *a)
{
	static int dy[11];
	memset(dy,-1,sizeof(dy));
	dy[0]=0;
	int res=0,cnt=0;
	for (int i=0;i&lt;=m;i++)
	{
		if (dy[a[i]]==-1) dy[a[i]]=++cnt;
		a[i]=dy[a[i]];
		res=res&lt;&lt;2|a[i];
	}
	return res;
}
void repack(int *a,int x)
{
	for (int i=m;i&gt;=0;i--)
	{
		a[i]=x&amp;3;
		x&gt;&gt;=2;
	}
}
void youyi(int *a)
{
	for (int i=m;i&gt;0;i--) a[i]=a[i-1];
	a[0]=0;
}
struct HT
{
	int f[101111],vt[101111],o[101111],aa1[101111],TIME,tot;
	void clear() {TIME++;tot=0;}
	void insert(int x,int res)
	{
		//printf(&quot;ins f=%d x=%d    &quot;,res,x);int a[11];repack(a,x);for(int i=0;i&lt;=m;i++)printf(&quot;%d &quot;,a[i]);ln;
		if (vt[x]==TIME)
			f[o[x]]=max(f[o[x]],res);
		else
		{
			if (vt[x]!=TIME) vt[x]=TIME;
			tot++;aa1[tot]=x;
			o[x]=tot;f[tot]=res;
		}
	}
} C[2];
void work(int i,int j)
{
	static int a[11];
	for (int p=1;p&lt;=C[now].tot;p++)
	{
		repack(a,C[now].aa1[p]);
		int ff=C[now].f[p];
		//for (int k=0;k&lt;=m;k++)printf(&quot;%d &quot;,a[k]);printf(&quot; ff=%d\n&quot;,ff);
		int left=a[j-1],up=a[j];
		if (left&amp;&amp;up)
		{
			if (left==up)
			{
				bool flag=true;
				for (int k=0;k&lt;=m;k++)
					if (a[k]!=left&amp;&amp;a[k]!=0) flag=false;
				if (flag) ans=max(ans,ff+w[i][j]);
				if (i==n&amp;&amp;j==m)
				{
					a[j-1]=a[j]=0;
					youyi(a);
					C[now^1].insert(pack(a),ff+w[i][j]);
				}
			}
			else
			{
				a[j-1]=a[j]=0;
				for (int k=0;k&lt;=m;k++)
					if (a[k]==left) a[k]=up;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),ff+w[i][j]);
			}
		}
		else if (left||up)
		{
			int t=left+up;
			if (can[i+1][j])
			{
				a[j-1]=t,a[j]=0;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),ff+w[i][j]);
			}
			if (can[i][j+1])
			{
				a[j-1]=0,a[j]=t;
				C[now^1].insert(pack(a),ff+w[i][j]);
			}
		}
		else
		{
			if (j==m) youyi(a);
			C[now^1].insert(pack(a),ff);
			if (can[i+1][j]&amp;&amp;can[i][j+1])
			{
				a[j-1]=a[j]=7;
				C[now^1].insert(pack(a),ff+w[i][j]);
			}
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			scanf(&quot;%d&quot;,&amp;w[i][j]);
			can[i][j]=true;
		}
	now=0;
	C[0].clear();
	C[0].insert(0,0);
	ans=-inf;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			//printf(&quot;\n---------------------- i=%d j=%d -----------------------------------\n&quot;,i,j);
			C[now^1].clear();
			work(i,j);
			now^=1;
		}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1187</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
#define inf 999999999
int n,m,now,ans,w[111][11];
bool can[111][11];
int pack(int *a)
{
	static int dy[11];
	memset(dy,-1,sizeof(dy));
	dy[0]=0;
	int res=0,cnt=0;
	for (int i=0;i&lt;=m;i++)
	{
		if (dy[a[i]]==-1) dy[a[i]]=++cnt;
		a[i]=dy[a[i]];
		res=res&lt;&lt;2|a[i];
	}
	return res;
}
void repack(int *a,int x)
{
	for (int i=m;i&gt;=0;i--)
	{
		a[i]=x&amp;3;
		x&gt;&gt;=2;
	}
}
void youyi(int *a)
{
	for (int i=m;i&gt;0;i--) a[i]=a[i-1];
	a[0]=0;
}
struct HT
{
	int f[101111],vt[101111],o[101111],aa1[101111],TIME,tot;
	void clear() {TIME++;tot=0;}
	void insert(int x,int res)
	{
		if (vt[x]==TIME)
			f[o[x]]=max(f[o[x]],res);
		else
		{
			if (vt[x]!=TIME) vt[x]=TIME;
			tot++;aa1[tot]=x;
			o[x]=tot;f[tot]=res;
		}
	}
} C[2];
void work(int i,int j)
{
	static int a[11];
	for (int p=1;p&lt;=C[now].tot;p++)
	{
		repack(a,C[now].aa1[p]);
		int ff=C[now].f[p];
		int left=a[j-1],up=a[j];
		if (left&amp;&amp;up)
		{
			if (left==up)
			{
				bool flag=true;
				for (int k=0;k&lt;=m;k++)
					if (a[k]!=left&amp;&amp;a[k]!=0) flag=false;
				if (flag) ans=max(ans,ff+w[i][j]);
				if (i==n&amp;&amp;j==m)
				{
					a[j-1]=a[j]=0;
					youyi(a);
					C[now^1].insert(pack(a),ff+w[i][j]);
				}
			}
			else
			{
				a[j-1]=a[j]=0;
				for (int k=0;k&lt;=m;k++)
					if (a[k]==left) a[k]=up;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),ff+w[i][j]);
			}
		}
		else if (left||up)
		{
			int t=left+up;
			if (can[i+1][j])
			{
				a[j-1]=t,a[j]=0;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),ff+w[i][j]);
			}
			if (can[i][j+1])
			{
				a[j-1]=0,a[j]=t;
				C[now^1].insert(pack(a),ff+w[i][j]);
			}
		}
		else
		{
			if (j==m) youyi(a);
			C[now^1].insert(pack(a),ff);
			if (can[i+1][j]&amp;&amp;can[i][j+1])
			{
				a[j-1]=a[j]=7;
				C[now^1].insert(pack(a),ff+w[i][j]);
			}
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			scanf(&quot;%d&quot;,&amp;w[i][j]);
			can[i][j]=true;
		}
	now=0;
	C[0].clear();
	C[0].insert(0,0);
	ans=-inf;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			C[now^1].clear();
			work(i,j);
			now^=1;
		}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1187</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
#define inf 999999999
int n,m,now,ans,w[111][11];
bool can[111][11];
int pack(int *a)
{
	static int dy[11];
	memset(dy,-1,sizeof(dy));
	dy[0]=0;
	int res=0,cnt=0;
	for (int i=0;i&lt;=m;i++)
	{
		if (dy[a[i]]==-1) dy[a[i]]=++cnt;
		a[i]=dy[a[i]];
		res=res&lt;&lt;2|a[i];
	}
	return res;
}
void repack(int *a,int x)
{
	for (int i=m;i&gt;=0;i--)
	{
		a[i]=x&amp;3;
		x&gt;&gt;=2;
	}
}
void youyi(int *a)
{
	for (int i=m;i&gt;0;i--) a[i]=a[i-1];
	a[0]=0;
}
struct HT
{
	int f[101111],vt[101111],o[101111],aa1[101111],TIME,tot;
	void clear() {TIME++;tot=0;}
	void insert(int x,int res)
	{
		if (vt[x]==TIME)
			f[o[x]]=max(f[o[x]],res);
		else
		{
			if (vt[x]!=TIME) vt[x]=TIME;
			tot++;aa1[tot]=x;
			o[x]=tot;f[tot]=res;
		}
	}
} C[2];
void work(int i,int j)
{
	static int a[11];
	for (int p=1;p&lt;=C[now].tot;p++)
	{
		repack(a,C[now].aa1[p]);
		int ff=C[now].f[p];
		int left=a[j-1],up=a[j];
		if (left&amp;&amp;up)
		{
			if (left==up)
			{
				bool flag=true;
				for (int k=0;k&lt;=m;k++)
					if (a[k]!=left&amp;&amp;a[k]!=0) flag=false;
				if (flag) ans=max(ans,ff+w[i][j]);
			}
			else
			{
				a[j-1]=a[j]=0;
				for (int k=0;k&lt;=m;k++)
					if (a[k]==left) a[k]=up;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),ff+w[i][j]);
			}
		}
		else if (left||up)
		{
			int t=left+up;
			if (can[i+1][j])
			{
				a[j-1]=t,a[j]=0;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),ff+w[i][j]);
			}
			if (can[i][j+1])
			{
				a[j-1]=0,a[j]=t;
				C[now^1].insert(pack(a),ff+w[i][j]);
			}
		}
		else
		{
			if (j==m) youyi(a);
			C[now^1].insert(pack(a),ff);
			if (can[i+1][j]&amp;&amp;can[i][j+1])
			{
				a[j-1]=a[j]=7;
				C[now^1].insert(pack(a),ff+w[i][j]);
			}
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			scanf(&quot;%d&quot;,&amp;w[i][j]);
			can[i][j]=true;
		}
	now=0;
	C[0].clear();
	C[0].insert(0,0);
	ans=-inf;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			C[now^1].clear();
			work(i,j);
			now^=1;
		}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1188</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int a[33],sg[33],n,tes;
int getsg(int t)
{
	if (sg[t]!=-1) return sg[t];
	if (t==n) return sg[t]=0;
	bool vt[1000];
	memset(vt,0,sizeof(vt));
	int i,j;
	for (i=t+1;i&lt;=n;i++)
		for (j=i;j&lt;=n;j++)
			vt[getsg(i)^getsg(j)]=true;
	for (i=0;vt[i];i++);
	return sg[t]=i;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		memset(sg,-1,sizeof(sg));
		scanf(&quot;%d&quot;,&amp;n);
		int ans=0,i,j,k;
		for (i=1;i&lt;=n;i++)
		{
			scanf(&quot;%d&quot;,&amp;a[i]);
			if (a[i]&amp;1) ans^=getsg(i);
		}
		if (ans==0) {printf(&quot;-1 -1 -1\n0\n&quot;);continue;}
		int num=0;
		for (i=1;i&lt;n;i++)
			for (j=i+1;j&lt;=n;j++)
				for (k=j;k&lt;=n;k++)
					if ((ans^getsg(i)^getsg(j)^getsg(k))==0)
					{
						num++;
						if (num==1) printf(&quot;%d %d %d\n&quot;,i-1,j-1,k-1);
					}
		printf(&quot;%d\n&quot;,num);
	}
	return 0;
}
<pre><h2>Problem1188</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int NN=100;
int sg[NN],a[NN],n,tes;
bool vt[NN];
int getsg(int t)
{
	if (t==n) return 0;
	memset(vt,0,sizeof(vt));
	int i,j;
	for (i=t+1;i&lt;=n;i++)
		for (j=i;j&lt;=n;j++) vt[sg[i]^sg[j]]=true;
	for (i=0;;i++) if (!vt[i]) return i;
}
int main()
{
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		int ans=0,i,j,k;
		for (i=n;i;i--) sg[i]=getsg(i);
		for (i=1;i&lt;=n;i++)
		{
			scanf(&quot;%d&quot;,&amp;a[i]);
			if (a[i]&amp;1) ans^=sg[i];
		}
		//for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,sg[i]);printf(&quot;\n&quot;);
		if (ans==0)
		{
			printf(&quot;-1 -1 -1\n0\n&quot;);
			continue;
		}
		int cnt=0;
		for (i=1;i&lt;n;i++) if (a[i])
			for (j=i+1;j&lt;=n;j++)
				for (k=j;k&lt;=n;k++)
					if ((ans^sg[i]^sg[j]^sg[k])==0)
					{
						cnt++;
						if (cnt==1) printf(&quot;%d %d %d\n&quot;,i-1,j-1,k-1);
					}
		printf(&quot;%d\n&quot;,cnt);
	}
	return 0;
}<pre><h2>Problem1189</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define S 0
#define T 1000
#define inf 0x7fffffff
using namespace std;
int n,m,door=1,cnt,ans,tot,mn=-1;
int xx[4]={0,0,1,-1},yy[4]={1,-1,0,0};
int mp[21][21],head[1001],h[1001],q[1001];
int dis[401][21][21];
struct data{int x,y,s;}d[401];
struct data2{int to,next,v;}e[1000001];
bool bfs()
{
	int t=0,w=1,i,now;
	memset(h,-1,sizeof(h));
	h[S]=0;q[0]=S;
	while(t&lt;w)
	{
		now=q[t];t++;
		i=head[now];
		while(i)
		{
			if(h[e[i].to]==-1&amp;&amp;e[i].v){h[e[i].to]=h[now]+1;q[w++]=e[i].to;}
			i=e[i].next;
		}
	}
	if(h[T]==-1)return 0;
	return 1;
}
int dfs(int x,int f)
{
    if(x==T)return f;
    int i=head[x];
    int w,used=0;
    while(i)
    {
		if(e[i].v&amp;&amp;h[e[i].to]==h[x]+1)
		{
			w=f-used;
			w=dfs(e[i].to,min(w,e[i].v));
			e[i].v-=w;
			e[i^1].v+=w;
			used+=w;
			if(used==f)return f;                      
		}
		i=e[i].next;
	}
    if(!used)h[x]=-1;
    return used;
}
void dinic(){while(bfs())ans+=dfs(0,inf);}
void ins(int u,int v,int w)
{e[++cnt].to=v;e[cnt].next=head[u];e[cnt].v=w;head[u]=cnt;}
void insert(int u,int v,int w)
{ins(u,v,w);ins(v,u,0);} 
void build(int x)
{
	memset(head,0,sizeof(head));
	cnt=1;
	for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
			if(mp[i][j]==1)insert(S,(i-1)*m+j,1);
	for(int i=2;i&lt;=door;i++)insert(n*m+i,T,x);
	for(int i=2;i&lt;=door;i++)
		for(int j=1;j&lt;=n;j++)
			for(int k=1;k&lt;=m;k++)
				if(dis[i][j][k]&lt;=x)insert((j-1)*m+k,n*m+i,x);
}
void search(int k,int x,int y) 
{
	int t=0,w=1,nowx,nowy;
	d[0].x=x;d[0].y=y;
	while(t&lt;w)
	{
		for(int i=0;i&lt;4;i++)
		{   
			nowx=d[t].x+xx[i],nowy=d[t].y+yy[i];
			if(nowx&lt;1||nowy&lt;1||nowx&gt;n||nowy&gt;m||mp[nowx][nowy]!=1)continue;
			if(dis[k][nowx][nowy]==inf)
			{
				dis[k][nowx][nowy]=d[w].s=d[t].s+1;
				d[w].x=nowx;d[w].y=nowy;
				w++; 
			}
		}
		t++;
	}
}
bool judge(int x)
{ 
	build(x);
	ans=0;
	dinic();
	if(ans==tot)return 1;
	return 0; 
}
int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    char ch[21];
    for(int i=1;i&lt;=n;i++)
    {
		scanf(&quot;%s&quot;,ch);
		for(int j=1;j&lt;=m;j++)
		{
			if(ch[j-1]=='.'){mp[i][j]=1;tot++;}
			else if(ch[j-1]=='D')mp[i][j]=++door; 
		}
	}
    for(int i=2;i&lt;=door;i++)
		for(int j=1;j&lt;=n;j++)
			for(int k=1;k&lt;=m;k++)
				dis[i][j][k]=inf;
    for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=m;j++)
			if(mp[i][j]&gt;1)search(mp[i][j],i,j);
    int l=0,r=400;
    while(l&lt;=r)
    {
		int mid=(l+r)&gt;&gt;1;
		if(judge(mid)){mn=mid;r=mid-1;}
		else l=mid+1;
	}
    if(mn==-1)printf(&quot;impossible&quot;);
    else printf(&quot;%d&quot;,mn);
    return 0;
}<pre><h2>Problem1190</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
typedef long long LL;
LL ans,f[33][1033];
int n,W;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (;;)
	{
		//printf(&quot;\n----------------------------------------------------\n&quot;);
		scanf(&quot;%d%d&quot;,&amp;n,&amp;W);
		if (n==-1) break;
		int x=W,tot=0;
		for (;x;x&gt;&gt;=1) tot++;
		memset(f,0,sizeof(f));
		int i,j,k;
		for (i=1;i&lt;=n;i++)
		{
			int w,v;
			scanf(&quot;%d%d&quot;,&amp;w,&amp;v);
			int t=0;
			for (;!(w&amp;1);w&gt;&gt;=1) t++;
			//printf(&quot;%d\n&quot;,t);
			if (t&gt;tot) continue;
			for (j=1000;j&gt;=w;j--)
				f[t][j]=max(f[t][j],f[t][j-w]+v);
		}
		ans=0;
		for (i=0;i&lt;=min(W,1000);i++) ans=max(ans,f[0][i]);
		//printf(&quot;ans=%lld\n&quot;,ans);
		for (i=1;i&lt;tot;i++)//,printf(&quot;i=%d\n&quot;,i))
			for (j=min(W&gt;&gt;i,1000);j&gt;=0;j--)
			{
				for (k=0;k&lt;=j;k++)
					f[i][j]=max(f[i][j],f[i][j-k]+f[i-1][min(1000,k*2+((W&gt;&gt;(i-1))&amp;1))]);
				ans=max(ans,f[i][j]);
			}
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}
<pre><h2>Problem1191</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int NN=1011;
int fa[NN],n,m;
bool flag[NN];
int getfa(int x) {return fa[x]==x?x:fa[x]=getfa(fa[x]);}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y;
	for (i=0;i&lt;n;i++) fa[i]=i;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		x=getfa(x),y=getfa(y);
		if (x==y)
		{
			if (flag[x]) {printf(&quot;%d\n&quot;,i-1);return 0;}
			flag[x]=true;
		}
		else
		{
			if (flag[x]&amp;&amp;flag[y]) {printf(&quot;%d\n&quot;,i-1);return 0;}
			if (flag[x]) fa[y]=x;
			else fa[x]=y;
		}
	}
	printf(&quot;%d\n&quot;,m);
	return 0;
}
<pre><h2>Problem1192</h2><pre>#include&lt;cstdio&gt;
using namespace std;

int main()
{
	int n,ans=0;
	scanf(&quot;%d&quot;,&amp;n);
	for (;n;n&gt;&gt;=1) ans++;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1193</h2><pre>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;cmath&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define mod 1000000007
#define inf 2000000000
#define ll long long 
using namespace std;
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int x,y,ans;
int xp,yp,xs,ys;
int xx[8]={1,1,-1,-1,2,2,-2,-2},yy[8]={2,-2,2,-2,1,-1,1,-1};
int dis[105][105];
int qx[10005],qy[10005];
void bfs()
{
	memset(dis,-1,sizeof(dis));
	int head=0,tail=1;
	qx[0]=x;qy[0]=y;dis[x][y]=0;
	while(head!=tail)
	{
		int x=qx[head],y=qy[head];head++;
		for(int k=0;k&lt;8;k++)
		{
			int nowx=x+xx[k],nowy=y+yy[k];
			if(nowx&lt;0||nowy&lt;0||nowx&gt;100||nowy&gt;100)continue;
			if(dis[nowx][nowy]!=-1)continue;
			dis[nowx][nowy]=dis[x][y]+1;
			qx[tail]=nowx;qy[tail]=nowy;tail++;
			if(nowx==50&amp;&amp;nowy==50)return;
		}
	}
}
int main()
{
	xp=read();yp=read();xs=read();ys=read();
	x=abs(xp-xs);y=abs(yp-ys);
	while(x+y&gt;=50)
	{
		if(x&lt;y)swap(x,y);
		if(x-4&gt;=2*y)x-=4;
		else x-=4,y-=2;	
		ans+=2;
	}
	x+=50;y+=50;
	bfs();
	printf(&quot;%d\n&quot;,ans+dis[50][50]);
	return 0;
}
<pre><h2>Problem1194</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int NN=55;
int belong[NN],o[NN],aa[11111][2],num[NN],f[NN],map[NN][NN],sta[NN],du[NN];
int S,tot=1,cnt;
bool use[NN][NN],vt[NN];
struct panduola
{
	int n;
	bool flag[NN];
	int go[NN][2];
	void in()
	{
		int m,i,x;
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		for (i=1;i&lt;=m;i++)
		{
			scanf(&quot;%d&quot;,&amp;x),x++;
			flag[x]=true;
		}
		for (i=1;i&lt;=n;i++)
		{
			scanf(&quot;%d%d&quot;,&amp;go[i][0],&amp;go[i][1]);
			go[i][0]++,go[i][1]++;
		}
	}
} a[NN];
bool dfs(int x,int i,int y,int j)
{
	if (use[i][j]) return true;
	use[i][j]=true;
	if (a[x].flag[i]&amp;&amp;!a[y].flag[j]) return false;
	if (!dfs(x,a[x].go[i][0],y,a[y].go[j][0])) return false;
	if (!dfs(x,a[x].go[i][1],y,a[y].go[j][1])) return false;
	return true;
}
bool check(int x,int y)
{
	memset(use,0,sizeof(use));
	if (!dfs(x,1,y,1)) return false;
	return true;
}
void addedge(int p,int q)
{
	du[q]++;
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;S);
	int i,j;
	for (i=1;i&lt;=S;i++) a[i].in();
	for (i=1;i&lt;=S;i++)
		for (j=1;j&lt;=S;j++)
			if (i!=j&amp;&amp;check(i,j)) map[i][j]=1;
	for (i=1;i&lt;=S;i++) if (!vt[i])
	{
		vt[i]=true;
		cnt++;
		belong[i]=cnt;
		num[cnt]=1;
		for (j=i+1;j&lt;=S;j++) if (!vt[j])
			if (map[i][j]&amp;&amp;map[j][i])
			{
				vt[j]=true;
				belong[j]=cnt;
				num[cnt]++;
			}
	}
	for (i=1;i&lt;=S;i++)
		for (j=1;j&lt;=S;j++)
			if (map[i][j]&amp;&amp;belong[i]!=belong[j])
				addedge(belong[i],belong[j]);
	memset(vt,0,sizeof(vt));
	int top=0;
	for (i=1;i&lt;=cnt;i++)
		if (du[i]==0)
		{
			vt[i]=true;
			f[i]=num[i];
			sta[++top]=i;
		}
	while (top&gt;0)
	{
		int x=sta[top--];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			du[y]--;
			f[y]=max(f[y],f[x]+num[y]);
			if (du[y]==0) sta[++top]=y;
		}
	}
	int ans=0;
	for (i=1;i&lt;=cnt;i++)
		if (f[i]&gt;ans) ans=f[i];
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1194</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int NN=51;
int belong[NN],o[NN],aa[11111][2],num[NN],f[NN],map[NN][NN],sta[NN],du[NN];
int S,tot=1,cnt;
bool use[NN][NN],vt[NN];
struct panduola
{
	int n;
	bool flag[NN];
	int go[NN][2];
	void in()
	{
		int m,i,x;
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		for (i=1;i&lt;=m;i++)
		{
			scanf(&quot;%d&quot;,&amp;x),x++;
			flag[x]=true;
		}
		for (i=1;i&lt;=n;i++)
		{
			scanf(&quot;%d%d&quot;,&amp;go[i][0],&amp;go[i][1]);
			go[i][0]++,go[i][1]++;
		}
	}
} a[NN];
bool dfs(int x,int i,int y,int j)
{
	if (use[i][j]) return true;
	use[i][j]=true;
	if (a[x].flag[i]&amp;&amp;!a[y].flag[j]) return false;
	if (!dfs(x,a[x].go[i][0],y,a[y].go[j][0])) return false;
	if (!dfs(x,a[x].go[i][1],y,a[y].go[j][1])) return false;
	return true;
}
bool check(int x,int y)
{
	memset(use,0,sizeof(use));
	if (!dfs(x,1,y,1)) return false;
	return true;
}
void addedge(int p,int q)
{
	du[q]++;
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;S);
	int i,j;
	for (i=1;i&lt;=S;i++) a[i].in();
	for (i=1;i&lt;=S;i++)
		for (j=1;j&lt;=S;j++)
			if (i!=j&amp;&amp;check(i,j)) map[i][j]=1;
	for (i=1;i&lt;=S;i++) if (!vt[i])
	{
		vt[i]=true;
		cnt++;
		belong[i]=cnt;
		num[cnt]=1;
		for (j=i+1;j&lt;=S;j++) if (!vt[j])
			if (map[i][j]&amp;&amp;map[j][i])
			{
				vt[j]=true;
				belong[j]=cnt;
				num[cnt]++;
			}
	}
	for (i=1;i&lt;=S;i++)
		for (j=1;j&lt;=S;j++)
			if (map[i][j]&amp;&amp;belong[i]!=belong[j])
				addedge(belong[i],belong[j]);
	memset(vt,0,sizeof(vt));
	int top=0;
	for (i=1;i&lt;=cnt;i++)
		if (du[i]==0)
		{
			vt[i]=true;
			f[i]=num[i];
			sta[++top]=i;
		}
	while (top&gt;0)
	{
		int x=sta[top--];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			du[y]--;
			f[y]=max(f[y],f[x]+num[y]);
			if (du[y]==0) sta[++top]=y;
		}
	}
	int ans=0;
	for (i=1;i&lt;=cnt;i++)
		if (f[i]&gt;ans) ans=f[i];
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1196</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int NN=10111,MM=20111;
int fa[NN],n,K,m,ans;
struct edge
{
	int a,b,w1,w2;
} e[MM];
int getfa(int x) {return fa[x]==x?x:fa[x]=getfa(fa[x]);}
bool check(int x)
{
	int i,num,now;
	for (i=1;i&lt;=n;i++) fa[i]=i;
	num=0,now=n;
	for (i=1;i&lt;=m;i++)
		if (e[i].w1&lt;=x)
		{
			int t1=getfa(e[i].a),t2=getfa(e[i].b);
			if (t1!=t2) num++,fa[t1]=t2,now--;
		}
	if (num&lt;K) return false;
	for (i=1;i&lt;=m;i++)
		if (e[i].w2&lt;=x)
		{
			int t1=getfa(e[i].a),t2=getfa(e[i].b);
			if (t1!=t2) fa[t1]=t2,now--;
		}
	if (now==1) return true;else return false;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;K,&amp;m);
	for (int i=1;i&lt;=m;i++)
		scanf(&quot;%d%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w1,&amp;e[i].w2);
	int l=1,r=30000;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (check(mid)) ans=mid,r=mid-1;
		else l=mid+1;
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1197</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
int n,m,i,j;
LL f[17][105];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;m,&amp;n);
	for (i=1;i&lt;=m;i++) f[1][i]=i&lt;&lt;1;
	for (i=1;i&lt;=n;i++) f[i][1]=2;
	for (i=2;i&lt;=n;i++)
		for (j=2;j&lt;=m;j++)
			f[i][j]=f[i][j-1]+f[i-1][j-1];
	printf(&quot;%lld\n&quot;,f[n][m]);
	return 0;
}
<pre><h2>Problem1199</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
typedef double DD;
const int NN=251111;
const DD eps=1e-7;
int n,m,n1,n2,ans[NN];
struct point
{
    DD x,y;
    int id;
    point(DD a=0,DD b=0) {x=a,y=b;}
    void in() {scanf(&quot;%lf%lf&quot;,&amp;x,&amp;y);}
    void out() {printf(&quot;%.3f %.3f\n&quot;,x,y);}
    DD len() {return sqrt(x*x+y*y);}
    friend bool operator &lt;(point a,point b) {return a.x&lt;b.x;}
    friend point operator -(point a,point b) {a.x-=b.x;a.y-=b.y;return a;}
} q[NN];
struct juxing
{
    point A,B;
    void in()
    {
        DD x1,y1,x2,y2;
        scanf(&quot;%lf%lf%lf%lf&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);
        if (x1-x2&gt;eps) swap(x1,x2),swap(y1,y2);
        if (y1-y2&gt;eps) swap(y1,y2);
        A=point(x1,y1),B=point(x2,y2);
    }
} a[NN];
struct yuan
{
    point O;
    DD R,left,right;
    void in()
    {
        scanf(&quot;%lf%lf%lf&quot;,&amp;O.x,&amp;O.y,&amp;R);
        left=O.x-R,right=O.x+R;
    }
} b[NN];
int main()
{
   // freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);
    int i,j;
    for (i=1;i&lt;=m;i++)
    {
        char ch=getchar();
        while (ch!='r'&amp;&amp;ch!='c') ch=getchar();
        if (ch=='r') a[++n1].in();
        else b[++n2].in();
    }
    for (i=1;i&lt;=n;i++) q[i].in(),q[i].id=i;
    sort(q+1,q+n+1);
    for (i=1;i&lt;=n1;i++)
    {
        int l=1,r=n,left=n+1,right=0;
        while (l&lt;=r)
        {
            int mid=(l+r)&gt;&gt;1;
            if (q[mid].x-a[i].A.x&gt;eps) left=mid,r=mid-1;
            else l=mid+1;
        }
        l=1,r=n;
        while (l&lt;=r)
        {
            int mid=(l+r)&gt;&gt;1;
            if (q[mid].x-a[i].B.x&lt;-eps) right=mid,l=mid+1;
            else r=mid-1;
        }
        for (j=left;j&lt;=right;j++)
            if (q[j].y-a[i].A.y&gt;eps&amp;&amp;q[j].y-a[i].B.y&lt;-eps) ans[q[j].id]++;
    }
    for (i=1;i&lt;=n2;i++)
    {
        int l=1,r=n,left=n+1,right=0;
        while (l&lt;=r)
        {
            int mid=(l+r)&gt;&gt;1;
            if (q[mid].x-b[i].left&gt;eps) left=mid,r=mid-1;
            else l=mid+1;
        }
        l=1,r=n;
        while (l&lt;=r)
        {
            int mid=(l+r)&gt;&gt;1;
            if (q[mid].x-b[i].right&lt;-eps) right=mid,l=mid+1;
            else r=mid-1;
        }
        for (j=left;j&lt;=right;j++)
            if ((q[j]-b[i].O).len()-b[i].R&lt;-eps) ans[q[j].id]++;
    }
    for (i=1;i&lt;=n;i++) printf(&quot;%d\n&quot;,ans[i]);
    return 0;
}
<pre><h2>Problem1202</h2><pre>var
  fa,rel:array[0..1000000]of longint;
  t1,t2,n,m,i,x,y,z,tt:longint;
function getfa(x:longint):longint;
var temp:longint;
begin
  if fa[x]=x then exit(x);
  temp:=getfa(fa[x]);
  rel[x]:=rel[fa[x]]+rel[x];
  fa[x]:=temp;
  exit(temp);
end;
procedure doit;
begin
  readln(n,m);
  for i:=0 to n do
    begin
      fa[i]:=i;
      rel[i]:=0;
    end;
  for i:=1 to m do
    begin
      readln(x,y,z);
      t1:=getfa(x-1);
      t2:=getfa(y);
      if t1=t2 then
        begin
          if rel[x-1]-rel[y]&lt;&gt;z then
            begin
              writeln('false');
              exit;
            end;
        end
      else
        begin
          rel[t1]:=rel[y]-rel[x-1]+z;
          fa[t1]:=t2;
        end;
    end;
  writeln('true');
end;
begin
  readln(tt);
  repeat
    dec(tt);
    doit;
  until tt=0;
end.<pre><h2>Problem1207</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int NN=11111;
int n,m,f[NN];
struct ppt
{
	int t,x,y;
	void in() {scanf(&quot;%d%d%d&quot;,&amp;t,&amp;x,&amp;y);}
} q[NN];
inline bool check(int i,int j)
{
	int t1=q[i].t-q[j].t;
	int t2=abs(q[i].x-q[j].x)+abs(q[i].y-q[j].y);
	return t1&gt;=t2;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j;
	for (i=1;i&lt;=m;i++) q[i].in();
	int ans=0;
	for (i=1;i&lt;=m;i++)
	{
		f[i]=1;
		for (j=1;j&lt;i;j++)
			if (check(i,j)&amp;&amp;f[j]+1&gt;f[i])
				f[i]=f[j]+1;
		if (f[i]&gt;ans) ans=f[i];
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1208</h2><pre>#include&lt;cstdio&gt;
#include&lt;set&gt;
#include&lt;algorithm&gt;
using namespace std;
#define mo 1000000
multiset&lt;int&gt; S[2];
multiset&lt;int&gt;::iterator it1,it2;
int n;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int ans=0,k,x;
	for (int i=1;i&lt;=n;i++,ans%=mo)
	{
		scanf(&quot;%d%d&quot;,&amp;k,&amp;x);
		if (S[k].size()) S[k].insert(x);
		else if (!S[k^1].size()) S[k].insert(x);
		else
		{
			it1=S[k^1].lower_bound(x);
			if (it1==S[k^1].begin())
			{
				ans+=abs(*it1-x);
				S[k^1].erase(it1);
				continue;
			}
			else if (it1==S[k^1].end())
			{
				it1--;
				ans+=abs(*it1-x);
				S[k^1].erase(it1);
				continue;
			}
			it2=it1;it2--;
			int t1=*it2,t2=*it1;
			if (abs(t1-x)&lt;=abs(t2-x))
			{
				ans+=abs(t1-x);
				S[k^1].erase(it2);
			}
			else
			{
				ans+=abs(t2-x);
				S[k^1].erase(it1);
			}
		}
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1210</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
#define maa(a,b) (a&gt;b?a:b)
#define ln printf(&quot;\n&quot;)
int n,m,now;
bool can[25][25];
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);ln;}
struct bigint
{
	int l,aa[11];
	bigint() {l=1,memset(aa,0,sizeof(aa));}
	int &amp; operator [](int x) {return aa[x];}
	void out()
	{
		printf(&quot;%d&quot;,aa[l]);
		for (int i=l-1;i;i--) printf(&quot;%04d&quot;,aa[i]);
		printf(&quot;\n&quot;);
	}
	bigint xiao()
	{
		for (int i=1;i&lt;l;i++)
			if (aa[i]&gt;9999) aa[i+1]+=aa[i]/10000,aa[i]%=10000;
		while (aa[l]&gt;9999) aa[l+1]=aa[l]/10000,aa[l]%=10000,l++;
		while (aa[l]==0&amp;&amp;l&gt;1) l--;
		return *this;
	}
	void set(int x)
	{
		aa[1]=x,l=1;
		xiao();
	}
	void operator +=(bigint b)
	{
		bigint a=*this;
		l=maa(a.l,b.l);
		for (int i=1;i&lt;=l;i++) aa[i]=a[i]+b[i];
		xiao();
	}
	void operator *=(int x)
	{
		for (int i=1;i&lt;=l;i++) aa[i]*=x;
		xiao();
	}
};
struct Hash_Table
{
	#define mo 10007
	int TIME,tot,o[mo+10],vt[mo+10],aa0[1001111];
	LL aa1[1001111];
	bigint f[1001111];
	void clear() {TIME++;tot=0;}
	void insert(LL x,bigint res)
	{
		//printf(&quot;insert %I64d &quot;,x);res.out();
		int v=x%mo;bool flag=false;
		if (vt[v]==TIME)
			for (int p=o[v];p;p=aa0[p])
				if (aa1[p]==x)
				{
					f[p]+=res;
					flag=true;break;
				}
		if (flag) return;
		if (vt[v]!=TIME) vt[v]=TIME,o[v]=0;
		tot++;aa1[tot]=x;aa0[tot]=o[v];o[v]=tot;
		f[tot]=res;
	}
} C[2];
LL pack(int *a)
{
	static int dy[15];
	memset(dy,-1,sizeof(dy));
	dy[0]=0;
	LL res=0;int cnt=0;
	for (int i=0;i&lt;=m;i++)
	{
		if (dy[a[i]]==-1) dy[a[i]]=++cnt;
		a[i]=dy[a[i]];
		res=(res&lt;&lt;3|a[i]);
	}
	return res;
}
void repack(int *a,LL x)
{
	for (int i=m;i&gt;=0;i--)
	{
		a[i]=x&amp;7;
		x&gt;&gt;=3;
	}
}
void youyi(int *a)
{
	for (int i=m;i&gt;0;i--) a[i]=a[i-1];
	a[0]=0;
}
void work(int i,int j)
{
	static int a[15];
	for (int p=1;p&lt;=C[now].tot;p++)
	{
		repack(a,C[now].aa1[p]);
		//printf(&quot;a &quot;);out(a,0,m);
		bigint ff=C[now].f[p];
		int left=a[j-1],up=a[j];
		if (left&amp;&amp;up)
		{
			if (left==up)
			{
				if (i==n&amp;&amp;j==m)
				{
					a[j-1]=a[j]=0;
					youyi(a);
					C[now^1].insert(pack(a),ff);
				}
			}
			else
			{
				a[j-1]=a[j]=0;
				for (int k=0;k&lt;=m;k++)
					if (a[k]==up) a[k]=left;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),ff);
			}
		}
		else if (left||up)
		{
			int t=left+up;
			if (can[i+1][j])
			{
				a[j-1]=t,a[j]=0;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),ff);
			}
			if (can[i][j+1])
			{
				a[j-1]=0,a[j]=t;
				C[now^1].insert(pack(a),ff);
			}
		}
		else
		{
			if (can[i+1][j]&amp;&amp;can[i][j+1])
			{
				a[j-1]=a[j]=11;
				C[now^1].insert(pack(a),ff);
			}
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,j;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	if (n==1||m==1) {printf(&quot;1\n&quot;);return 0;}
	if (m&gt;n) {int t=n;n=m;m=t;}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++) can[i][j]=true;
	now=0;
	bigint tmp;tmp.set(1);
	C[now].insert(0,tmp);
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			//printf(&quot;\n------------------ i=%d j=%d -------------------------------------\n&quot;,i,j);
			C[now^1].clear();
			work(i,j);
			now^=1;
		}
	bigint ans;
	ans.set(0);
	for (int p=1;p&lt;=C[now].tot;p++) ans+=C[now].f[p];
	ans*=2;
	ans.out();
	return 0;
}<pre><h2>Problem1210</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
#define maa(a,b) (a&gt;b?a:b)
#define ln printf(&quot;\n&quot;)
int n,m,now;
bool can[25][25];
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);ln;}
struct bigint
{
	int l,aa[11];
	bigint() {l=1,memset(aa,0,sizeof(aa));}
	int &amp; operator [](int x) {return aa[x];}
	void out()
	{
		printf(&quot;%d&quot;,aa[l]);
		for (int i=l-1;i;i--) printf(&quot;%04d&quot;,aa[i]);
		printf(&quot;\n&quot;);
	}
	bigint xiao()
	{
		for (int i=1;i&lt;l;i++)
			if (aa[i]&gt;9999) aa[i+1]+=aa[i]/10000,aa[i]%=10000;
		while (aa[l]&gt;9999) aa[l+1]=aa[l]/10000,aa[l]%=10000,l++;
		while (aa[l]==0&amp;&amp;l&gt;1) l--;
		return *this;
	}
	void set(int x)
	{
		aa[1]=x,l=1;
		xiao();
	}
	void operator +=(bigint b)
	{
		bigint a=*this;
		l=maa(a.l,b.l);
		for (int i=1;i&lt;=l;i++) aa[i]=a[i]+b[i];
		xiao();
	}
	void operator *=(int x)
	{
		for (int i=1;i&lt;=l;i++) aa[i]*=x;
		xiao();
	}
};
struct Hash_Table
{
	#define mo 10007
	int TIME,tot,o[mo+10],vt[mo+10],aa0[1001111];
	LL aa1[1001111];
	bigint f[1001111];
	void clear() {TIME++;tot=0;}
	void insert(LL x,bigint res)
	{
		int v=x%mo;bool flag=false;
		if (vt[v]==TIME)
			for (int p=o[v];p;p=aa0[p])
				if (aa1[p]==x)
				{
					f[p]+=res;
					flag=true;break;
				}
		if (flag) return;
		if (vt[v]!=TIME) vt[v]=TIME,o[v]=0;
		tot++;aa1[tot]=x;aa0[tot]=o[v];o[v]=tot;
		f[tot]=res;
	}
} C[2];
LL pack(int *a)
{
	static int dy[15];
	memset(dy,-1,sizeof(dy));
	dy[0]=0;
	LL res=0;int cnt=0;
	for (int i=0;i&lt;=m;i++)
	{
		if (dy[a[i]]==-1) dy[a[i]]=++cnt;
		a[i]=dy[a[i]];
		res=(res&lt;&lt;3|a[i]);
	}
	return res;
}
void repack(int *a,LL x)
{
	for (int i=m;i&gt;=0;i--)
	{
		a[i]=x&amp;7;
		x&gt;&gt;=3;
	}
}
void youyi(int *a)
{
	for (int i=m;i&gt;0;i--) a[i]=a[i-1];
	a[0]=0;
}
void work(int i,int j)
{
	static int a[15];
	for (int p=1;p&lt;=C[now].tot;p++)
	{
		repack(a,C[now].aa1[p]);
		bigint ff=C[now].f[p];
		int left=a[j-1],up=a[j];
		if (left&amp;&amp;up)
		{
			if (left==up)
			{
				if (i==n&amp;&amp;j==m)
				{
					a[j-1]=a[j]=0;
					youyi(a);
					C[now^1].insert(pack(a),ff);
				}
			}
			else
			{
				a[j-1]=a[j]=0;
				for (int k=0;k&lt;=m;k++)
					if (a[k]==up) a[k]=left;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),ff);
			}
		}
		else if (left||up)
		{
			int t=left+up;
			if (can[i+1][j])
			{
				a[j-1]=t,a[j]=0;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),ff);
			}
			if (can[i][j+1])
			{
				a[j-1]=0,a[j]=t;
				C[now^1].insert(pack(a),ff);
			}
		}
		else
		{
			if (can[i+1][j]&amp;&amp;can[i][j+1])
			{
				a[j-1]=a[j]=11;
				C[now^1].insert(pack(a),ff);
			}
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,j;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	if (n==1||m==1) {printf(&quot;1\n&quot;);return 0;}
	if (m&gt;n) {int t=n;n=m;m=t;}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++) can[i][j]=true;
	now=0;
	bigint tmp;tmp.set(1);
	C[now].insert(0,tmp);
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			//printf(&quot;\n------------------ i=%d j=%d -------------------------------------\n&quot;,i,j);
			C[now^1].clear();
			work(i,j);
			now^=1;
		}
	bigint ans;
	ans.set(0);
	for (int p=1;p&lt;=C[now].tot;p++) ans+=C[now].f[p];
	ans*=2;
	ans.out();
	return 0;
}<pre><h2>Problem1212</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int NN=1001111,AA=211;
int son[AA][26];
int n,m,TTT;
bool flag[AA],f[NN];
char s[NN];
void ACins(int l)
{
	int now=1;
	for (int i=1;i&lt;=l;i++)
	{
		int t=s[i]-'a';
		if (son[now][t]) now=son[now][t];
		else
		{
			son[now][t]=++TTT;
			now=TTT;
		}
	}
	flag[now]=true;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	int i,j;
	for (i=0;i&lt;26;i++) son[0][i]=1,son[1][i]=0;
	TTT=1;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s\n&quot;,s+1);
		ACins(strlen(s+1));
	}
	for (;m;m--)
	{
		scanf(&quot;%s\n&quot;,s+1);
		int len=strlen(s+1);
		for (i=1;i&lt;=len;i++) f[i]=false;
		f[0]=true;
		int ans=0;
		for (i=0;i&lt;=len;i++)
		{
			if (f[i]) ans=i; else continue;
			int now=1;
			for (j=i+1;j&lt;=len;j++)
			{
				int t=s[j]-'a';
				if (son[now][t]==0) break;
				now=son[now][t];
				if (flag[now]) f[j]=true;
			}
		}
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem1212</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int NN=1001111,AA=211;
int son[AA][26];
int n,m,TTT;
bool flag[AA],f[NN];
char s[NN];
void ACins(int l)
{
	int now=1;
	for (int i=1;i&lt;=l;i++)
	{
		int t=s[i]-'a';
		if (son[now][t]) now=son[now][t];
		else
		{
			son[now][t]=++TTT;
			now=TTT;
		}
	}
	flag[now]=true;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	int i,j;
	for (i=0;i&lt;26;i++) son[0][i]=1,son[1][i]=0;
	TTT=1;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s\n&quot;,s+1);
		ACins(strlen(s+1));
	}
	for (;m;m--)
	{
		scanf(&quot;%s\n&quot;,s+1);
		int len=strlen(s+1);
		memset(f,0,sizeof(f));
		f[0]=true;
		int ans=0;
		for (i=0;i&lt;=len;i++)
		{
			if (f[i]) ans=i; else continue;
			int now=1;
			for (j=i+1;j&lt;=len;j++)
			{
				int t=s[j]-'a';
				if (son[now][t]==0) break;
				now=son[now][t];
				if (flag[now]) f[j]=true;
			}
		}
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem1221</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mii(a,b) (a&lt;b?a:b)
#define inf 999999999
#define NN 2111
int dist[NN],q[1000000],pre[NN],o[NN],a[NN],aa[NN*6][4];
int n,A,B,F,FA,FB,tot=1,S,T,ans;
bool dl[NN];
bool relax(int x,int y,int v)
{
	if (dist[y]&gt;dist[x]+v)
	{
		dist[y]=dist[x]+v;
		return true;
	}
	return false;
}
bool spfa()
{
	int head=0,tail=1,x,p,y;
	q[1]=S;
	memset(dist,60,sizeof(dist));
	dist[S]=0;
	memset(dl,0,sizeof(dl));
	dl[S]=true;
	while (head&lt;tail)
	{
		x=q[++head];
		dl[x]=false;
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;relax(x,y,aa[p][3]))
			{
				pre[y]=p;
				if (!dl[y]) dl[y]=true,q[++tail]=y;
			}
		}
	}
	return dist[T]&lt;dist[0];
}
void doit()
{
	int p,ff=inf;
	for (p=pre[T];p;p=pre[aa[p^1][1]]) ff=mii(ff,aa[p][2]);
	for (p=pre[T];p;p=pre[aa[p^1][1]])
	{
		ans+=ff*aa[p][3];
		aa[p][2]-=ff;
		aa[p^1][2]+=ff;
	}
}
void addedge(int p,int q,int v,int c)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][3]=c;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v,int c)
{
	addedge(p,q,v,c);
	addedge(q,p,0,-c);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d%d%d%d&quot;,&amp;n,&amp;A,&amp;B,&amp;F,&amp;FA,&amp;FB);
	S=n*2+1,T=n*2+2;
	tot=1;
	for (int i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		add(i,T,a[i],0);
		add(S,i+n,a[i],0);
		add(S,i,inf,F);
		if (i+A+1&lt;=n) add(i+n,i+A+1,inf,FA);
		if (i+B+1&lt;=n) add(i+n,i+B+1,inf,FB);
		if (i&lt;n) add(i+n,i+1+n,inf,0);
	}
	ans=0;
	while (spfa()) doit();
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1226</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 99999999
int f[1100][300][20],T[1100],B[1100];
int testcase,n,i,j,k,S,last,next,ans,maxx;
void renew(int &amp;a,int b) {if (a&gt;b) a=b;}
int calc(int i,int j)
{
	if (i&lt;=0) return 0;
	return (T[i]|T[j])-(T[i]&amp;T[j]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;testcase);
	for (;testcase;testcase--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		for (i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;T[i],&amp;B[i]); 
		memset(f,127,sizeof(f));
		f[1][0][-1+8]=0;
		for (i=1;i&lt;=n;i++)
			for (S=0;S&lt;=255;S++)
				for (last=-8;last&lt;=7;last++)
				{
					k=last+8;
					if (f[i][S][k]&gt;inf) continue;
					if (S&amp;1) renew(f[i+1][S&gt;&gt;1][k-1],f[i][S][k]);
					else
					{
						maxx=inf;
						for (next=0;next&lt;=7;next++)
							if ((S&amp;(1&lt;&lt;next))==0)
							{
								if (i+next&gt;maxx) break;
								renew(maxx,i+next+B[i+next]);
								renew(f[i][S|(1&lt;&lt;next)][next+8],f[i][S][k]+calc(i+last,i+next));
							}
					}
				}
		ans=inf;
		for (i=-8;i&lt;=-1;i++) renew(ans,f[n+1][0][i+8]);
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
<pre><h2>Problem1226</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 99999999
int f[1100][300][16],T[1100],B[1100];
int testcase,n,i,j,k,S,next,ans,maxx;
void renew(int &amp;a,int b) {if (a&gt;b) a=b;}
int calc(int i,int j)
{
	if (i&lt;=0) return 0;
	return (T[i]|T[j])-(T[i]&amp;T[j]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;testcase);
	for (;testcase;testcase--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		for (i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;T[i],&amp;B[i]); 
		memset(f,127,sizeof(f));
		f[1][0][-1+8]=0;
		for (i=1;i&lt;=n;i++)
			for (S=0;S&lt;=255;S++)
				for (k=0;k&lt;=15;k++)
				{
					if (f[i][S][k]&gt;inf) continue;
					if (S&amp;1) renew(f[i+1][S&gt;&gt;1][k-1],f[i][S][k]);
					else
					{
						maxx=inf;
						for (next=0;next&lt;=7;next++)
							if ((S&amp;(1&lt;&lt;next))==0)
							{
								if (i+next&gt;maxx) break;
								renew(maxx,i+next+B[i+next]);
								renew(f[i][S|(1&lt;&lt;next)][next+8],f[i][S][k]+calc(i+k-8,i+next));
							}
					}
				}
		ans=inf;
		for (i=-8;i&lt;=-1;i++) renew(ans,f[n+1][0][i+8]);
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
<pre><h2>Problem1226</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 99999999
int f[1100][300][20],T[1100],B[1100];
int testcase,n,i,j,k,S,next,ans,maxx;
void renew(int &amp;a,int b) {if (a&gt;b) a=b;}
int calc(int i,int j)
{
	if (i&lt;=0) return 0;
	return (T[i]|T[j])-(T[i]&amp;T[j]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;testcase);
	for (;testcase;testcase--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		for (i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;T[i],&amp;B[i]); 
		memset(f,127,sizeof(f));
		f[1][0][-1+8]=0;
		for (i=1;i&lt;=n;i++)
			for (S=0;S&lt;=255;S++)
				for (k=0;k&lt;=15;k++)
				{
					if (f[i][S][k]&gt;inf) continue;
					if (S&amp;1) renew(f[i+1][S&gt;&gt;1][k-1],f[i][S][k]);
					else if ((S&amp;1)==0)
					{
						maxx=inf;
						for (next=0;next&lt;=7;next++)
							if ((S&amp;(1&lt;&lt;next))==0)
							{
								if (i+next&gt;maxx) break;
								renew(maxx,i+next+B[i+next]);
								renew(f[i][S|(1&lt;&lt;next)][next+8],f[i][S][k]+calc(i+k-8,i+next));
							}
					}
				}
		ans=inf;
		for (i=-8;i&lt;=-1;i++) renew(ans,f[n+1][0][i+8]);
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
<pre><h2>Problem1226</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 99999999
int f[1100][300][20],T[1100],B[1100];
int testcase,n,i,j,k,S,next,ans,maxx;
void renew(int &amp;a,int b) {if (a&gt;b) a=b;}
int calc(int i,int j)
{
	if (i&lt;=0) return 0;
	return (T[i]|T[j])-(T[i]&amp;T[j]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;testcase);
	for (;testcase;testcase--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		for (i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;T[i],&amp;B[i]); 
		memset(f,127,sizeof(f));
		f[1][0][-1+8]=0;
		for (i=1;i&lt;=n;i++)
			for (S=0;S&lt;=255;S++)
				for (k=0;k&lt;=15;k++)
				{
					if (f[i][S][k]&gt;inf) continue;
					if (S&amp;1&amp;&amp;k&gt;0) renew(f[i+1][S&gt;&gt;1][k-1],f[i][S][k]);
					else if ((S&amp;1)==0)
					{
						maxx=inf;
						for (next=0;next&lt;=7;next++)
							if ((S&amp;(1&lt;&lt;next))==0)
							{
								if (i+next&gt;maxx) break;
								renew(maxx,i+next+B[i+next]);
								renew(f[i][S|(1&lt;&lt;next)][next+8],f[i][S][k]+calc(i+k-8,i+next));
							}
					}
				}
		ans=inf;
		for (i=-8;i&lt;=-1;i++) renew(ans,f[n+1][0][i+8]);
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
<pre><h2>Problem1226</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 99999999
int f[1100][300][20],T[1100],B[1100];
int tc,n,i,j,k,S,next,ans,can;
void renew(int &amp;a,int b) {if (a&gt;b) a=b;}
int calc(int i,int j)
{
	if (i&lt;=0) return 0;
	return (T[i]|T[j])-(T[i]&amp;T[j]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;tc);
	for (;tc;tc--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		for (i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;T[i],&amp;B[i]); 
		memset(f,127,sizeof(f));
		f[1][0][-1+8]=0;
		for (i=1;i&lt;=n;i++)
			for (S=0;S&lt;=255;S++)
				for (k=0;k&lt;=15;k++)
				{
					//if (f[i][S][k]&gt;inf) continue;
					if (S&amp;1&amp;&amp;k&gt;0) renew(f[i+1][S&gt;&gt;1][k-1],f[i][S][k]);
					else if ((S&amp;1)==0)
					{
						can=inf;
						for (next=0;next&lt;=7;next++)
							if ((S&amp;(1&lt;&lt;next))==0)
							{
								if (i+next&gt;can) break;
								renew(can,i+next+B[i+next]);
								renew(f[i][S|(1&lt;&lt;next)][next+8],f[i][S][k]+calc(i+k-8,i+next));
							}
					}
				}
		ans=inf;
		for (i=-8;i&lt;=-1;i++) renew(ans,f[n+1][0][i+8]);
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
<pre><h2>Problem1226</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 99999999
int f[1100][300][20],T[1100],B[1100];
int tc,n,i,j,k,S,next,ans,can;
void renew(int &amp;a,int b) {if (a&gt;b) a=b;}
int calc(int i,int j)
{
	if (i&lt;=0) return 0;
	return (T[i]|T[j])-(T[i]&amp;T[j]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;tc);
	for (;tc;tc--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		for (i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;T[i],&amp;B[i]); 
		memset(f,127,sizeof(f));
		f[1][0][-1+8]=0;
		for (i=1;i&lt;=n;i++)
			for (S=0;S&lt;=255;S++)
				for (k=0;k&lt;=15;k++)
					if (S&amp;1&amp;&amp;k) renew(f[i+1][S&gt;&gt;1][k-1],f[i][S][k]);
					else if ((S&amp;1)==0)
					{
						can=inf;
						for (next=0;next&lt;=7;next++)
							if ((S&amp;(1&lt;&lt;next))==0)
							{
								if (i+next&gt;can) break;
								renew(can,i+next+B[i+next]);
								renew(f[i][S|(1&lt;&lt;next)][next+8],f[i][S][k]+calc(i+k-8,i+next));
							}
					}
		ans=inf;
		for (i=-8;i&lt;=-1;i++) renew(ans,f[n+1][0][i+8]);
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
<pre><h2>Problem1226</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 99999999
int f[1100][300][20],T[1100],B[1100];
int tc,n,i,j,k,S,next,ans,can;
void renew(int &amp;a,int b) {if (a&gt;b) a=b;}
int calc(int i,int j)
{
	if (i&lt;=0) return 0;
	return (T[i]|T[j])-(T[i]&amp;T[j]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;tc);
	for (;tc;tc--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		for (i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;T[i],&amp;B[i]); 
		memset(f,127,sizeof(f));
		f[1][0][-1+8]=0;
		for (i=1;i&lt;=n;i++)
			for (S=0;S&lt;=255;S++)
				for (k=0;k&lt;=15;k++)
				{
					if (S&amp;1&amp;&amp;k) renew(f[i+1][S&gt;&gt;1][k-1],f[i][S][k]);
					//else if ((S&amp;1)==0)
				//	{
						can=inf;
						for (next=0;next&lt;=7;next++)
							if ((S&amp;(1&lt;&lt;next))==0)
							{
								if (i+next&gt;can) break;
								renew(can,i+next+B[i+next]);
								renew(f[i][S|(1&lt;&lt;next)][next+8],f[i][S][k]+calc(i+k-8,i+next));
							}
				//	}
				}
		ans=inf;
		for (i=-8;i&lt;=-1;i++) renew(ans,f[n+1][0][i+8]);
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
<pre><h2>Problem1227</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=401111;
int c[NN],up[NN],down[NN],C[101111][11],b[NN];
int n,m,K,num,cnt;
struct ppt
{
	int x,y;
	void out() {printf(&quot;%d %d\n&quot;,x,y);}
	friend bool operator &lt;(ppt a,ppt b) {return a.y&lt;b.y||(a.y==b.y&amp;&amp;a.x&lt;b.x);}
} q[NN];
void prepare()
{
	C[0][0]=1;
	for (int i=1;i&lt;=100000;i++)
		for (int j=0;j&lt;=K;j++)
			if (j==0) C[i][j]=1;
			else C[i][j]=C[i-1][j]+C[i-1][j-1];
	//for (int i=0;i&lt;=5;i++){for (int j=0;j&lt;=K;j++) printf(&quot;C[%d][%d]=%d   &quot;,i,j,C[i][j]);ln;}
}
int cha(int x)
{
	int l=1,r=cnt;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (b[mid]==x) return mid;
		if (b[mid]&gt;x) r=mid-1;else l=mid+1;
	}
	return -1;
}
void change(int i,int x)
{
	//printf(&quot;change %d %d\n&quot;,i,x);
	for (;i&lt;=cnt;i+=i&amp;-i) c[i]+=x;
}
int getsum(int i)
{
	int res=0;
	for (;i;i-=i&amp;-i) res+=c[i];
	return res;
}
void work(int x)
{
	//printf(&quot;===== work %d =====\n&quot;,x);
	change(x,-C[down[x]][K]*C[up[x]][K]);
	down[x]++,up[x]--;
	change(x,C[down[x]][K]*C[up[x]][K]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	scanf(&quot;%d&quot;,&amp;num);
	int i,t=0;
	for (i=1;i&lt;=num;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;q[i].x,&amp;q[i].y);
		b[++t]=q[i].x,b[++t]=q[i].y;
	}
	scanf(&quot;%d&quot;,&amp;K);
	prepare();
	sort(b+1,b+t+1);
	for (cnt=1,i=2;i&lt;=t;i++) if (b[i]!=b[cnt]) b[++cnt]=b[i];
	for (i=1;i&lt;=num;i++)
	{
		q[i].x=cha(q[i].x),q[i].y=cha(q[i].y);
		up[q[i].x]++;
	}
	//printf(&quot;q:\n&quot;);for (i=1;i&lt;=num;i++) q[i].out();ln;
	sort(q+1,q+num+1);
	//printf(&quot;q:\n&quot;);for (i=1;i&lt;=num;i++) q[i].out();
	for (i=1;i&lt;=cnt;i++) change(i,C[0][K]*C[up[i]][K]);
	int l,r,ans=0;
	for (l=r=1;l&lt;=num;l=++r)
	{
		while (q[r].y==q[l].y&amp;&amp;r&lt;=num) r++;r--;
		//printf(&quot;\n----------------- l=%d r=%d ---------------------------------------------------\n&quot;,l,r);
		work(q[l].x);
		for (i=l+1;i&lt;=r;i++)
		{
			int left=i-l,right=r-i+1;
			int tmp=getsum(q[i].x-1)-getsum(q[i-1].x);
			ans+=C[left][K]*C[right][K]*tmp;
			//printf(&quot;i=%d tmp=%d ans=%d\n&quot;,i,tmp,ans);
			work(q[i].x);
		}
		//printf(&quot;ans=%d\n&quot;,ans);
	}
	//ln;ln;
	long long x=ans;
	x%=2147483648ll;
	if (x&lt;0) x+=2147483648ll;
	printf(&quot;%d\n&quot;,(int)x);
	return 0;
}<pre><h2>Problem1228</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef unsigned long long LL;
bool check(LL x,LL i,LL j)
{
	LL t=1ll&lt;&lt;(x+1);
	i%=t,j%=t;if (!i) i=t;if (!j) j=t;
	if (i&gt;t/2||j&gt;t/2) return false;
	t&gt;&gt;=1;
	for (;;)
	{
		if (t==1) return true;
		if (i&lt;=t/2&amp;&amp;j&lt;=t/2) return false;
		if (i&gt;t/2) i-=t/2;
		if (j&gt;t/2) j-=t/2;
		t&gt;&gt;=1;
	}
}
LL get(LL x,LL y)
{
	//printf(&quot;get %lld %lld\n&quot;,x,y);
	for (LL i=0;;i++)
	{
		//printf(&quot;%lld\n&quot;,i);
		if (check(i,x,y)) return i;
	}
}
int main()
{
	//freopen(&quot;1228.in&quot;,&quot;r&quot;,stdin);//freopen(&quot;1228.out&quot;,&quot;w&quot;,stdout);
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
	LL tes,i,x,y,n;
	for (scanf(&quot;%lld&quot;,&amp;tes);tes;tes--)
	{
		//printf(&quot;tes=%lld\n&quot;,tes);
		scanf(&quot;%lld&quot;,&amp;n);
		LL ans=0;
		for (i=1;i&lt;=n;i+=2)
		{
			//printf(&quot;i=%lld\n&quot;,i);
			scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y);
			//printf(&quot;%lld\n&quot;,get(x,y));
			ans^=get(x,y);
		}
		printf(ans?&quot;YES\n&quot;:&quot;NO\n&quot;);
	}
	//for (int i=1;i&lt;=64;i++){for(int j=1;j&lt;=64;j++)printf(&quot;%lld&quot;,get(i,j));printf(&quot;\n&quot;);}
	return 0;
}<pre><h2>Problem1242</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=1001111,MM=2001111;
int o[NN],aa[MM*2][2],a[NN],pos[NN],b[NN],flag[NN],label[NN];
int n,m,tot=1,TIME;
bool vt[NN];
void out(int*a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
struct ppt
{
	int w,v;
	ppt(int a=0,int b=0) {w=a,v=b;}
	friend bool operator &lt;(ppt a,ppt b) {return a.w&lt;b.w;}
};
priority_queue&lt;ppt&gt; Q;
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j,x,y;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	for (i=1;i&lt;=n;i++) Q.push(ppt(0,i));
	for (i=n;i;i--)
	{
		while (vt[Q.top().v]) Q.pop();
		int v=Q.top().v;
		Q.pop();
		vt[v]=true;
		a[i]=v,pos[v]=i;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (!vt[y]) Q.push(ppt(++label[y],y));
		}
	}
	//printf(&quot;a &quot;);out(a,1,n);
	for (i=n-1;i;i--)
	{
		//printf(&quot;\n-----------------------------------------------------------------------------\n&quot;);
		int v=a[i];
		int num=0;
		TIME++;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (pos[y]&gt;pos[v]) b[++num]=y,flag[y]=TIME;
		}
		//printf(&quot;b &quot;);out(b,1,num);
		for (j=i+1;j&lt;=n;j++)
			if (flag[a[j]]==TIME) break;
		if (j==n+1) continue;
		int t=a[j];
		//printf(&quot;t=%d\n&quot;,t);
		TIME++;
		for (int p=o[t];p;p=aa[p][0]) flag[aa[p][1]]=TIME;
		for (j=1;j&lt;=num;j++)
			if (b[j]!=t&amp;&amp;flag[b[j]]!=TIME) {printf(&quot;Imperfect\n&quot;);return 0;}
	}
	//ln;ln;
	printf(&quot;Perfect\n&quot;);
	return 0;
}<pre><h2>Problem1242</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=10005,MM=1001111;
int o[NN],aa[MM*2][2],a[NN],pos[NN],b[NN],flag[NN],label[NN];
int n,m,tot=1,TIME;
bool vt[NN];
void out(int*a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
struct ppt
{
	int w,v;
	ppt(int a=0,int b=0) {w=a,v=b;}
	friend bool operator &lt;(ppt a,ppt b) {return a.w&lt;b.w;}
};
priority_queue&lt;ppt&gt; Q;
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j,x,y;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	for (i=1;i&lt;=n;i++) Q.push(ppt(0,i));
	for (i=n;i;i--)
	{
		while (vt[Q.top().v]) Q.pop();
		int v=Q.top().v;
		Q.pop();
		vt[v]=true;
		a[i]=v,pos[v]=i;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (!vt[y]) Q.push(ppt(++label[y],y));
		}
	}
	//printf(&quot;a &quot;);out(a,1,n);
	for (i=n-1;i;i--)
	{
		//printf(&quot;\n-----------------------------------------------------------------------------\n&quot;);
		int v=a[i];
		int num=0;
		TIME++;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (pos[y]&gt;pos[v]) b[++num]=y,flag[y]=TIME;
		}
		//printf(&quot;b &quot;);out(b,1,num);
		for (j=i+1;j&lt;=n;j++)
			if (flag[a[j]]==TIME) break;
		if (j==n+1) continue;
		int t=a[j];
		//printf(&quot;t=%d\n&quot;,t);
		TIME++;
		for (int p=o[t];p;p=aa[p][0]) flag[aa[p][1]]=TIME;
		for (j=1;j&lt;=num;j++)
			if (b[j]!=t&amp;&amp;flag[b[j]]!=TIME) {printf(&quot;Imperfect\n&quot;);return 0;}
	}
	//ln;ln;
	printf(&quot;Perfect\n&quot;);
	return 0;
}<pre><h2>Problem1242</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=1011,MM=1000111;
int o[NN],aa[MM&lt;&lt;1][2],pos[NN],xulie[NN];
int n,m,tot=1;
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
struct ppt
{
	int v,w;
	ppt(int _v=0,int _w=0) {v=_v,w=_w;}
	friend bool operator &lt;(const ppt &amp;a,const ppt &amp;b) {return a.w&lt;b.w;}
};
void getxulie()
{
	static priority_queue&lt;ppt&gt; Q;
	static int label[NN];
	static bool vt[NN];
	int i;
	for (i=1;i&lt;=n;i++)
		Q.push(ppt(i,label[i]=0));
	for (i=n;i;i--)
	{
		while (vt[Q.top().v]) Q.pop();
		int v=Q.top().v;
		Q.pop();
		vt[v]=true;
		pos[v]=i;
		xulie[i]=v;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (!vt[y])
				Q.push(ppt(y,++label[y]));
		}
	}
}
inline bool cmp(const int &amp;a,const int &amp;b) {return pos[a]&lt;pos[b];}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j,x,y;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	getxulie();
	//printf(&quot;xulie &quot;);for (i=1;i&lt;=n;i++)printf(&quot;%d &quot;,xulie[i]);ln;
	for (i=n;i;i--)
	{
		//printf(&quot;\n---------------------------- i=%d ----------------------------------\n&quot;,i);
		static int b[NN],vt[NN];
		int x=xulie[i],cnt=0;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (pos[y]&gt;i) b[++cnt]=y;
		}
		if (cnt==0) continue;
		sort(b+1,b+cnt+1,cmp);
		//printf(&quot;b &quot;);for(j=1;j&lt;=cnt;j++)printf(&quot;%d &quot;,b[j]);ln;
		for (int p=o[b[1]];p;p=aa[p][0]) vt[aa[p][1]]=i;
		for (j=2;j&lt;=cnt;j++)
			if (vt[b[j]]!=i) {printf(&quot;Imperfect\n&quot;);return 0;}
	}
	printf(&quot;Perfect\n&quot;);
	return 0;
}<pre><h2>Problem1251</h2><pre>#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;cstdio&gt;
using namespace std;
#define inf 0x7fffffff
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
const int N=50001;
int n,m,rt,sz,c[N][2],mark[N],fa[N],v[N],size[N],mx[N],tag[N];
bool rev[N];
inline void update(int k){
	int l=c[k][0],r=c[k][1];
	mx[k]=max(max(mx[l],mx[r]),v[k]);
	size[k]=size[l]+size[r]+1;
}
inline void rotate(int x,int &amp;k){
	int y=fa[x],z=fa[y],l,r;
	if(c[y][0]==x)l=0;else l=1;r=l^1;
	if(y==k)k=x;
	else{
		if(c[z][0]==y)c[z][0]=x;
		else c[z][1]=x;
	}
	fa[y]=x;fa[x]=z;fa[c[x][r]]=y;
	c[y][l]=c[x][r];c[x][r]=y;
	update(x);update(y);
}
inline void splay(int x,int &amp;k){
	int y,z;
	while(x!=k){
		y=fa[x];z=fa[y];
		if(y!=k){
			if((c[y][0]==x)^(c[z][0]==y))rotate(x,k);
			else rotate(y,k);
		}
		rotate(x,k);
	}
}
inline void build(int l,int r,int last){
	if(l&gt;r)return;
	if(l==r){
		size[mark[l]]=1;fa[mark[l]]=mark[last];
		if(l&lt;last)c[mark[last]][0]=mark[l];
		else c[mark[last]][1]=mark[l];
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(l,mid-1,mid);build(mid+1,r,mid);
	fa[mark[mid]]=mark[last];
	update(mark[mid]);
	if(mid&lt;last)c[mark[last]][0]=mark[mid];
	else c[mark[last]][1]=mark[mid];
}
inline void pushdown(int k){
	int l=c[k][0],r=c[k][1],t=tag[k];
	if(t){
		if(l){v[l]+=t;mx[l]+=t;tag[l]+=t;}
		if(r){v[r]+=t;mx[r]+=t;tag[r]+=t;}
		tag[k]=0;
	}
	if(rev[k]){
		swap(c[k][0],c[k][1]);
		if(l)rev[l]^=1;
		if(r)rev[r]^=1;
		rev[k]=0;
	}
}
inline int find(int k,int rk){
	if(tag[k]||rev[k])pushdown(k);
	int l=c[k][0],r=c[k][1];
	if(size[l]+1==rk)return k;
	else if(size[l]&gt;=rk)return find(l,rk);
	else return find(r,rk-size[l]-1);
}
inline void add(int l,int r,int w){  
    int x=find(rt,l),y=find(rt,r+2);  
    splay(x,rt);splay(y,c[x][1]);  
    int z=c[y][0];  
    v[z]+=w;mx[z]+=w;tag[z]+=w;  
    update(x);update(y);  
}  
inline void rever(int l,int r){  
    int x=find(rt,l),y=find(rt,r+2);  
    splay(x,rt);splay(y,c[x][1]);  
    int z=c[y][0];  
    rev[z]^=1;  
}  
inline void ask(int l,int r){  
    int x=find(rt,l),y=find(rt,r+2);  
    splay(x,rt);splay(y,c[x][1]);  
    int z=c[y][0];  
    printf(&quot;%d\n&quot;,mx[z]);  
}  
int main(){  
    mx[0]=-inf;  
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);  
    for(int i=1;i&lt;=n+2;i++)mark[i]=++sz;  
    build(1,n+2,0);  
    rt=(n+3)&gt;&gt;1;  
    for(int i=1;i&lt;=m;i++){  
        int t,l,r,x;  
        scanf(&quot;%d&quot;,&amp;t);  
        switch(t){  
            case 1:scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;x);add(l,r,x);break;  
            case 2:scanf(&quot;%d%d&quot;,&amp;l,&amp;r);rever(l,r);break;  
            case 3:scanf(&quot;%d%d&quot;,&amp;l,&amp;r);ask(l,r);break;  
        }  
    }  
    return 0;  
}  <pre><h2>Problem1251</h2><pre>const
    sroot                   =-1;
var
    n, m                    :longint;
    i                       :longint;
    a, father               :array[-1..100010] of longint;
    k, l, r, v              :longint;
    root                    :longint;
    max, size, tree         :array[-1..100010] of longint;
    val                     :array[-1..100010] of longint;
    flag                    :array[-1..100010] of boolean;
    son                     :array[-1..100010,0..1] of longint;
     
procedure swap(var a,b:longint);
var
    c                       :longint;
begin
    c:=a; a:=b; b:=c;
end;
     
function get_max(a,b:longint):longint;
begin
    if a&gt;b then exit(a) else exit(b);
end;
 
procedure renew_add(x,v:longint);
begin
    inc(tree[x],v); inc(val[x],v); inc(max[x],v);
end;
 
procedure renew_reverse(x:longint);
begin
    swap(son[x,1],son[x,0]);
    flag[x]:=not flag[x];
end;
     
procedure update(x:longint);
begin
    //if x=sroot then exit;
    max[x]:=get_max(tree[x],get_max(max[son[x,1]],max[son[x,0]]));
    size[x]:=size[son[x,1]]+size[son[x,0]]+1;
end;
     
function build(l,r:longint):longint;
var
    mid                     :longint;
begin
    mid:=(r+l) div 2;
    build:=mid;
    tree[mid]:=a[mid];
    if l+1&lt;=mid then
    begin
        son[mid,0]:=build(l,mid-1);
        father[son[mid,0]]:=mid;
    end;
    if mid&lt;=r-1 then
    begin
        son[mid,1]:=build(mid+1,r);
        father[son[mid,1]]:=mid;
    end;
    update(mid);
end;
 
procedure push_down(x:longint);
var
    l, r                    :longint;
begin
    l:=son[x,0]; r:=son[x,1];
    if flag[x] then
    begin
        if l&lt;&gt;-1 then renew_reverse(l);
        if r&lt;&gt;-1 then renew_reverse(r);
        flag[x]:=false;
    end;
    if val[x]&lt;&gt;0 then
    begin
        if l&lt;&gt;-1 then renew_add(l,val[x]);
        if r&lt;&gt;-1 then renew_add(r,val[x]);
        val[x]:=0;
    end;
end;
     
function find(x:longint):longint;
var
    t                       :longint;
begin
    t:=root;
    while true do
    begin
        push_down(t);
        if size[son[t,0]]+1=x then exit(t);
        if size[son[t,0]]+1&gt;x then t:=son[t,0] else
        begin
            dec(x,size[son[t,0]]+1);
            t:=son[t,1];
        end;
    end;
end;
 
procedure rotate(x,y:longint);
var
    f                       :longint;
begin
    push_down(x);
    f:=father[x];
    father[son[x,y xor 1]]:=f;
    son[f,y]:=son[x,y xor 1];
    if f=root then root:=x else
        if f=son[father[f],0] then
            son[father[f],0]:=x else
            son[father[f],1]:=x;
    father[x]:=father[f];
    father[f]:=x;
    son[x,y xor 1]:=f;
    update(f);
    update(x);
end;
 
procedure splay(x,y:longint);
var
    u, v                    :longint;
begin
    while father[x]&lt;&gt;y do
    begin
        if father[father[x]]=y then
            rotate(x,ord(x=son[father[x],1])) else
        begin
            if son[father[x],0]=x then u:=1 else u:=-1;
            if son[father[father[x]],0]=father[x] then v:=1 else v:=-1;
            if u*v=1 then
            begin
                rotate(father[x],ord(x=son[father[x],1]));
                rotate(x,ord(x=son[father[x],1]));
            end else
            begin
                rotate(x,ord(x=son[father[x],1]));
                rotate(x,ord(x=son[father[x],1]));
            end;
        end;
    end;
    update(x);
end;
     
procedure add(l,r,v:longint);
var
    p                       :longint;
begin
    p:=find(l);splay(p,sroot);
    p:=find(r+2);splay(p,root);
    p:=son[son[root,1],0];
    renew_add(p,v);
end;
 
procedure reverse(l,r:longint);
var
    p                       :longint;
begin
    p:=find(l);splay(p,sroot);
    p:=find(r+2);splay(p,root);
    p:=son[son[root,1],0];
    renew_reverse(p);
end;
 
function ask_max(l,r:longint):longint;
var
    p                       :longint;
begin
    p:=find(l); splay(p,sroot);
    p:=find(r+2); splay(p,root);
    p:=son[son[root,1],0];
    ask_max:=max[p];
end;
     
begin
    fillchar(son,sizeof(son),255);
    read(n,m);
    max[-1]:=-maxlongint;
    for i:=1 to n do a[i]:=0;
    inc(n); 
    root:=build(0,n);
    father[root]:=sroot;
    for i:=1 to m do
    begin
        read(k);
        if k=1 then
        begin
            read(l,r,v);
            add(l,r,v);
        end else
        begin
            read(l,r);
            if k=2 then    
                reverse(l,r) else
                writeln(ask_max(l,r));
        end;
    end;
end.<pre><h2>Problem1251</h2><pre>const
    sroot                   =-1;
var
    n, m                    :longint;
    i                       :longint;
    a, father               :array[-1..100010] of longint;
    k, l, r, v              :longint;
    root                    :longint;
    max, size, tree         :array[-1..100010] of longint;
    val                     :array[-1..100010] of longint;
    flag                    :array[-1..100010] of boolean;
    son                     :array[-1..100010,0..1] of longint;
     
procedure swap(var a,b:longint);
var
    c                       :longint;
begin
    c:=a; a:=b; b:=c;
end;
     
function get_max(a,b:longint):longint;
begin
    if a&gt;b then exit(a) else exit(b);
end;
 
procedure renew_add(x,v:longint);
begin
    inc(tree[x],v); inc(val[x],v); inc(max[x],v);
end;
 
procedure renew_reverse(x:longint);
begin
    swap(son[x,1],son[x,0]);
    flag[x]:=not flag[x];
end;
     
procedure update(x:longint);
begin
    //if x=sroot then exit;
    max[x]:=get_max(tree[x],get_max(max[son[x,1]],max[son[x,0]]));
    size[x]:=size[son[x,1]]+size[son[x,0]]+1;
end;
     
function build(l,r:longint):longint;
var
    mid                     :longint;
begin
    mid:=(r+l) div 2;
    build:=mid;
    tree[mid]:=a[mid];
    if l+1&lt;=mid then
    begin
        son[mid,0]:=build(l,mid-1);
        father[son[mid,0]]:=mid;
    end;
    if mid&lt;=r-1 then
    begin
        son[mid,1]:=build(mid+1,r);
        father[son[mid,1]]:=mid;
    end;
    update(mid);
end;
 
procedure push_down(x:longint);
var
    l, r                    :longint;
begin
    l:=son[x,0]; r:=son[x,1];
    if flag[x] then
    begin
        if l&lt;&gt;-1 then renew_reverse(l);
        if r&lt;&gt;-1 then renew_reverse(r);
        flag[x]:=false;
    end;
    if val[x]&lt;&gt;0 then
    begin
        if l&lt;&gt;-1 then renew_add(l,val[x]);
        if r&lt;&gt;-1 then renew_add(r,val[x]);
        val[x]:=0;
    end;
end;
     
function find(x:longint):longint;
var
    t                       :longint;
begin
    t:=root;
    while true do
    begin
        push_down(t);
        if size[son[t,0]]+1=x then exit(t);
        if size[son[t,0]]+1&gt;x then t:=son[t,0] else
        begin
            dec(x,size[son[t,0]]+1);
            t:=son[t,1];
        end;
    end;
end;
 
procedure rotate(x,y:longint);
var
    f                       :longint;
begin
	push_down(y);
    push_down(x);
    f:=father[x];
    father[son[x,y xor 1]]:=f;
    son[f,y]:=son[x,y xor 1];
    if f=root then root:=x else
        if f=son[father[f],0] then
            son[father[f],0]:=x else
            son[father[f],1]:=x;
    father[x]:=father[f];
    father[f]:=x;
    son[x,y xor 1]:=f;
    update(f);
    update(x);
end;
 
procedure splay(x,y:longint);
var
    u, v                    :longint;
begin
    while father[x]&lt;&gt;y do
    begin
        if father[father[x]]=y then
            rotate(x,ord(x=son[father[x],1])) else
        begin
            if son[father[x],0]=x then u:=1 else u:=-1;
            if son[father[father[x]],0]=father[x] then v:=1 else v:=-1;
            if u*v=1 then
            begin
                rotate(father[x],ord(x=son[father[x],1]));
                rotate(x,ord(x=son[father[x],1]));
            end else
            begin
                rotate(x,ord(x=son[father[x],1]));
                rotate(x,ord(x=son[father[x],1]));
            end;
        end;
    end;
    update(x);
end;
     
procedure add(l,r,v:longint);
var
    p                       :longint;
begin
    p:=find(l);splay(p,sroot);
    p:=find(r+2);splay(p,root);
    p:=son[son[root,1],0];
    renew_add(p,v);
end;
 
procedure reverse(l,r:longint);
var
    p                       :longint;
begin
    p:=find(l);splay(p,sroot);
    p:=find(r+2);splay(p,root);
    p:=son[son[root,1],0];
    renew_reverse(p);
end;
 
function ask_max(l,r:longint):longint;
var
    p                       :longint;
begin
    p:=find(l); splay(p,sroot);
    p:=find(r+2); splay(p,root);
    p:=son[son[root,1],0];
    ask_max:=max[p];
end;
     
begin
    fillchar(son,sizeof(son),255);
    read(n,m);
    max[-1]:=-maxlongint;
    for i:=1 to n do a[i]:=0;
    inc(n); 
    root:=build(0,n);
    father[root]:=sroot;
    for i:=1 to m do
    begin
        read(k);
        if k=1 then
        begin
            read(l,r,v);
            add(l,r,v);
        end else
        begin
            read(l,r);
            if k=2 then    
                reverse(l,r) else
                writeln(ask_max(l,r));
        end;
    end;
end.<pre><h2>Problem1251</h2><pre>#include&lt;cstdio&gt; 
using namespace std; 
const int inf=99999999;
int S[110000],son[110000][2],fa[110000],tree[110000],tmax[110000],tag1[110000]; 
bool tag2[110000]; 
int n,m,kind,x,y,root,aa,bb,v; 
int max(int a,int b) {return a&gt;b?a:b;} 
void swap(int &amp;a,int &amp;b)
{
	int t=a;
	a=b;
	b=t;
}
void update(int t) 
{ 
    S[t]=1,tmax[t]=tree[t];
    if (son[t][0]) S[t]+=S[son[t][0]],tmax[t]=max(tmax[t],tmax[son[t][0]]);
    if (son[t][1]) S[t]+=S[son[t][1]],tmax[t]=max(tmax[t],tmax[son[t][1]]);
} 
void pushdown(int t) 
{ 
	if (t==0) return;
    int x=son[t][0],y=son[t][1]; 
    if (tag1[t]) 
    { 
        if (x!=0) tag1[x]+=tag1[t],tree[x]+=tag1[t],tmax[x]+=tag1[t]; 
        if (y!=0) tag1[y]+=tag1[t],tree[y]+=tag1[t],tmax[y]+=tag1[t]; 
        tag1[t]=0; 
    } 
    if (tag2[t]) 
    { 
        son[t][1]=x,son[t][0]=y; 
        if (x!=0) tag2[x]=!tag2[x];
        if (y!=0) tag2[y]=!tag2[y]; 
        tag2[t]=0; 
    } 
} 
void rotate(int t,int p) 
{ 
    int y=fa[t]; 
    //printf(&quot;tmax:&quot;);for (int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,tmax[i]);printf(&quot;\n&quot;); 
    //printf(&quot;%d %d %d\n&quot;,y,son[y][0],son[y][1]); 
    //printf(&quot;%d %d %d\n&quot;,t,son[t][0],son[t][1]); 
    pushdown(y); 
    pushdown(t); 
    //printf(&quot;tmax:&quot;);for (int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,tmax[i]);printf(&quot;\n\n&quot;); 
    fa[t]=fa[y]; 
    if (fa[y]) 
        if (y==son[fa[y]][0]) son[fa[y]][0]=t; 
        else son[fa[y]][1]=t; 
    son[y][p^1]=son[t][p]; 
    if (son[t][p]) fa[son[t][p]]=y; 
    son[t][p]=y; 
    fa[y]=t; 
    update(y); 
    update(t); 
} 
void splay(int t,int ff) 
{ 
    while (fa[t]!=ff) 
    { 
        int y=fa[t]; 
        if (fa[y]==ff) 
            if (t==son[y][0]) rotate(t,1); 
            else rotate(t,0); 
        else if (y==son[fa[y]][0]) 
            if (t==son[y][0]) rotate(t,1),rotate(t,1); 
            else rotate(t,0),rotate(t,1); 
        else
            if (t==son[y][1]) rotate(t,0),rotate(t,0); 
            else rotate(t,1),rotate(t,0); 
    } 
    if (ff==0) root=t; 
} 
int splaybuild(int ll,int rr) 
{ 
    int mid=(ll+rr)&gt;&gt;1; 
    S[mid]=1; 
    if (ll&lt;mid) 
    { 
        int x=splaybuild(ll,mid-1); 
        S[mid]+=S[x]; 
        fa[x]=mid; 
        son[mid][0]=x; 
    } 
    if (mid&lt;rr) 
    { 
        int x=splaybuild(mid+1,rr); 
        S[mid]+=S[x]; 
        fa[x]=mid; 
        son[mid][1]=x; 
    } 
    return mid; 
} 
int find(int t,int x) 
{ 
    //printf(&quot;find:%d %d\n&quot;,t,x); 
    pushdown(t); 
    for (;t;) 
    { 
        //printf(&quot;%d\n&quot;,S[t]); 
        if (x==S[son[t][0]]+1) return t; 
        if (x&lt;=S[son[t][0]]) t=son[t][0]; 
        else x-=(S[son[t][0]]+1),t=son[t][1]; 
        pushdown(t); 
    } 
} 
void zhong(int t) 
{ 
    if (t==0) return; 
    pushdown(t); 
    zhong(son[t][0]); 
    printf(&quot;%d &quot;,tree[t]); 
    zhong(son[t][1]); 
} 
int main() 
{ 
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin); 
    //freopen(&quot;2.out&quot;,&quot;w&quot;,stdout); 
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m); 
    n+=2; 
    root=splaybuild(1,n); 
    //printf(&quot;%d\n&quot;,S[0]); 
    for (;m;m--) 
    { 
        //printf(&quot;\n--------------------------%d\n&quot;,S[0]); 
        //zhong(root);printf(&quot;\n&quot;); 
        tmax[0]=-inf;
        scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;aa,&amp;bb); 
        ++aa,++bb; 
        x=find(root,aa-1); 
        splay(x,0); 
        y=find(root,bb+1); 
        splay(y,x); 
        //printf(&quot;%d\n&quot;,tmax[x]); 
        //printf(&quot;%d %d\n&quot;,x,y); 
        x=son[y][0]; 
        if (kind==1) 
        { 
            scanf(&quot;%d&quot;,&amp;v); 
            tag1[x]+=v,tree[x]+=v,tmax[x]+=v; 
            //zhong(root);printf(&quot;\n&quot;); 
            splay(x,0); 
            //printf(&quot;%d\n&quot;,x); 
            //zhong(root);printf(&quot;\n&quot;); 
        } 
        else if (kind==2) 
        { 
            tag2[x]=!tag2[x]; 
            splay(x,0); 
        } 
        else printf(&quot;%d\n&quot;,tmax[x]); 
    } 
    return 0; 
} <pre><h2>Problem1251</h2><pre>#include&lt;cstdio&gt; 
using namespace std; 
const int inf=99999999;
int S[110000],son[110000][2],fa[110000],tree[110000],tmax[110000],tag1[110000]; 
bool tag2[110000]; 
int n,m,kind,x,y,root,aa,bb,v; 
int max(int a,int b) {return a&gt;b?a:b;} 
void swap(int &amp;a,int &amp;b)
{
	int t=a;
	a=b;
	b=t;
}
void update(int t) 
{ 
    S[t]=1,tmax[t]=tree[t];
    if (son[t][0]) S[t]+=S[son[t][0]],tmax[t]=max(tmax[t],tmax[son[t][0]]);
    if (son[t][1]) S[t]+=S[son[t][1]],tmax[t]=max(tmax[t],tmax[son[t][1]]);
} 
void pushdown(int t) 
{ 
	if (t==0) return;
    int x=son[t][0],y=son[t][1]; 
    if (tag1[t]) 
    { 
        if (x!=0) tag1[x]+=tag1[t],tree[x]+=tag1[t],tmax[x]+=tag1[t]; 
        if (y!=0) tag1[y]+=tag1[t],tree[y]+=tag1[t],tmax[y]+=tag1[t]; 
        tag1[t]=0; 
    } 
    if (tag2[t]) 
    { 
        son[t][1]=x,son[t][0]=y; 
        if (x!=0) tag2[x]=!tag2[x];
        if (y!=0) tag2[y]=!tag2[y]; 
        tag2[t]=0; 
    } 
} 
void rotate(int t,int p) 
{ 
    int y=fa[t]; 
    pushdown(y); 
    pushdown(t); 
    fa[t]=fa[y]; 
    if (fa[y]) 
        if (y==son[fa[y]][0]) son[fa[y]][0]=t; 
        else son[fa[y]][1]=t; 
    son[y][p^1]=son[t][p]; 
    if (son[t][p]) fa[son[t][p]]=y; 
    son[t][p]=y; 
    fa[y]=t; 
    update(y); 
    update(t); 
} 
void splay(int t,int ff) 
{ 
    while (fa[t]!=ff) 
    { 
        int y=fa[t]; 
        if (fa[y]==ff) 
            if (t==son[y][0]) rotate(t,1); 
            else rotate(t,0); 
        else if (y==son[fa[y]][0]) 
            if (t==son[y][0]) rotate(t,1),rotate(t,1); 
            else rotate(t,0),rotate(t,1); 
        else
            if (t==son[y][1]) rotate(t,0),rotate(t,0); 
            else rotate(t,1),rotate(t,0); 
    } 
    if (ff==0) root=t; 
} 
int splaybuild(int ll,int rr) 
{ 
    int mid=(ll+rr)&gt;&gt;1; 
    S[mid]=1; 
    if (ll&lt;mid) 
    { 
        int x=splaybuild(ll,mid-1); 
        S[mid]+=S[x]; 
        fa[x]=mid; 
        son[mid][0]=x; 
    } 
    if (mid&lt;rr) 
    { 
        int x=splaybuild(mid+1,rr); 
        S[mid]+=S[x]; 
        fa[x]=mid; 
        son[mid][1]=x; 
    } 
    return mid; 
} 
int find(int t,int x) 
{
    pushdown(t); 
    for (;t;) 
    { 
        if (x==S[son[t][0]]+1) return t; 
        if (x&lt;=S[son[t][0]]) t=son[t][0]; 
        else x-=(S[son[t][0]]+1),t=son[t][1]; 
        pushdown(t); 
    } 
} 
void zhong(int t) 
{ 
    if (t==0) return; 
    pushdown(t); 
    zhong(son[t][0]); 
    printf(&quot;%d &quot;,tree[t]); 
    zhong(son[t][1]); 
} 
int main() 
{ 
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m); 
    n+=2; 
    root=splaybuild(1,n); 
    for (;m;m--) 
    { 
        tmax[0]=-inf;
        scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;aa,&amp;bb); 
        ++aa,++bb; 
        x=find(root,aa-1); 
        splay(x,0); 
        y=find(root,bb+1); 
        splay(y,x); 
        x=son[y][0]; 
        if (kind==1) 
        { 
            scanf(&quot;%d&quot;,&amp;v); 
            tag1[x]+=v,tree[x]+=v,tmax[x]+=v; 
            splay(x,0); 
        } 
        else if (kind==2) 
        { 
            tag2[x]=!tag2[x]; 
            splay(x,0); 
        } 
        else printf(&quot;%d\n&quot;,tmax[x]); 
    } 
    return 0; 
} <pre><h2>Problem1251</h2><pre>#include&lt;cstdio&gt; 
using namespace std; 
const int inf=99999999;
int S[110000],son[110000][2],fa[110000],tree[110000],tmax[110000],tag1[110000]; 
bool tag2[110000]; 
int n,m,kind,x,y,root,aa,bb,v; 
int max(int a,int b) {return a&gt;b?a:b;} 
void swap(int &amp;a,int &amp;b)
{
	int t=a;
	a=b;
	b=t;
}
void update(int t) 
{ 
    S[t]=1,tmax[t]=tree[t];
    if (son[t][0]) S[t]+=S[son[t][0]],tmax[t]=max(tmax[t],tmax[son[t][0]]);
    if (son[t][1]) S[t]+=S[son[t][1]],tmax[t]=max(tmax[t],tmax[son[t][1]]);
} 
void pushdown(int t) 
{ 
	if (t==0) return;
    int x=son[t][0],y=son[t][1]; 
    if (tag1[t]) 
    { 
        if (x!=0) tag1[x]+=tag1[t],tree[x]+=tag1[t],tmax[x]+=tag1[t]; 
        if (y!=0) tag1[y]+=tag1[t],tree[y]+=tag1[t],tmax[y]+=tag1[t]; 
        tag1[t]=0; 
    } 
    if (tag2[t]) 
    { 
        //son[t][1]=x,son[t][0]=y; 
        if (x!=0) tag2[x]=!tag2[x],swap(son[x][0],son[x][1]);
        if (y!=0) tag2[y]=!tag2[y],swap(son[y][0],son[y][1]); 
        tag2[t]=0; 
    } 
} 
void rotate(int t,int p) 
{ 
    int y=fa[t]; 
    pushdown(y); 
    pushdown(t); 
    fa[t]=fa[y]; 
    if (fa[y]) 
        if (y==son[fa[y]][0]) son[fa[y]][0]=t; 
        else son[fa[y]][1]=t; 
    son[y][p^1]=son[t][p]; 
    if (son[t][p]) fa[son[t][p]]=y; 
    son[t][p]=y; 
    fa[y]=t; 
    update(y); 
    update(t); 
} 
void splay(int t,int ff) 
{ 
    while (fa[t]!=ff) 
    { 
        int y=fa[t]; 
        if (fa[y]==ff) 
            if (t==son[y][0]) rotate(t,1); 
            else rotate(t,0); 
        else if (y==son[fa[y]][0]) 
            if (t==son[y][0]) rotate(t,1),rotate(t,1); 
            else rotate(t,0),rotate(t,1); 
        else
            if (t==son[y][1]) rotate(t,0),rotate(t,0); 
            else rotate(t,1),rotate(t,0); 
    } 
    if (ff==0) root=t; 
} 
int splaybuild(int ll,int rr) 
{ 
    int mid=(ll+rr)&gt;&gt;1; 
    S[mid]=1; 
    if (ll&lt;mid) 
    { 
        int x=splaybuild(ll,mid-1); 
        S[mid]+=S[x]; 
        fa[x]=mid; 
        son[mid][0]=x; 
    } 
    if (mid&lt;rr) 
    { 
        int x=splaybuild(mid+1,rr); 
        S[mid]+=S[x]; 
        fa[x]=mid; 
        son[mid][1]=x; 
    } 
    return mid; 
} 
int find(int t,int x) 
{ 
    for (;t;) 
    { 
    	pushdown(t);
        if (x==S[son[t][0]]+1) return t; 
        if (x&lt;=S[son[t][0]]) t=son[t][0]; 
        else x-=(S[son[t][0]]+1),t=son[t][1]; 
    } 
} 
void zhong(int t) 
{ 
    if (t==0) return; 
    pushdown(t); 
    zhong(son[t][0]); 
    printf(&quot;%d &quot;,tree[t]); 
    zhong(son[t][1]); 
} 
int main() 
{ 
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m); 
    n+=2; 
    root=splaybuild(1,n); 
    for (;m;m--) 
    { 
        tmax[0]=-inf;
        scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;aa,&amp;bb); 
        ++aa,++bb; 
        x=find(root,aa-1); 
        splay(x,0); 
        y=find(root,bb+1); 
        splay(y,x); 
        x=son[y][0]; 
        if (kind==1) 
        { 
            scanf(&quot;%d&quot;,&amp;v); 
            tag1[x]+=v,tree[x]+=v,tmax[x]+=v; 
            splay(x,0); 
        } 
        else if (kind==2) 
        { 
            tag2[x]=!tag2[x]; 
            swap(son[x][0],son[x][1]);
            splay(x,0); 
        } 
        else printf(&quot;%d\n&quot;,tmax[x]); 
    } 
    return 0; 
} <pre><h2>Problem1251</h2><pre>#include&lt;cstdio&gt; 
using namespace std; 
const int inf=99999999;
int S[110000],son[110000][2],fa[110000],tree[110000],tmax[110000],tag1[110000]; 
bool tag2[110000]; 
int n,m,kind,x,y,root,aa,bb,v; 
int max(int a,int b) {return a&gt;b?a:b;} 
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
void update(int t) 
{ 
    S[t]=1,tmax[t]=tree[t];
    //if (son[t][0]) 
	S[t]+=S[son[t][0]],tmax[t]=max(tmax[t],tmax[son[t][0]]);
    //if (son[t][1]) 
	S[t]+=S[son[t][1]],tmax[t]=max(tmax[t],tmax[son[t][1]]);
} 
void pushdown(int t) 
{ 
	if (t==0) return;
    int x=son[t][0],y=son[t][1]; 
    if (tag1[t]) 
    { 
        if (x!=0) tag1[x]+=tag1[t],tree[x]+=tag1[t],tmax[x]+=tag1[t]; 
        if (y!=0) tag1[y]+=tag1[t],tree[y]+=tag1[t],tmax[y]+=tag1[t]; 
        tag1[t]=0; 
    } 
    if (tag2[t]) 
    { 
	    if (x!=0) tag2[x]=!tag2[x],swap(son[x][0],son[x][1]);
		if (y!=0) tag2[y]=!tag2[y],swap(son[y][0],son[y][1]); 
        tag2[t]=0; 
    } 
} 
void rotate(int t,int p) 
{ 
    int y=fa[t]; 
    pushdown(y); 
    pushdown(t); 
    fa[t]=fa[y]; 
    if (fa[y]) 
        if (y==son[fa[y]][0]) son[fa[y]][0]=t; 
        else son[fa[y]][1]=t; 
    son[y][p^1]=son[t][p]; 
    if (son[t][p]) fa[son[t][p]]=y; 
    son[t][p]=y; 
    fa[y]=t; 
    update(y); 
    update(t); 
} 
void splay(int t,int ff) 
{ 
    while (fa[t]!=ff) 
    { 
        int y=fa[t]; 
        if (fa[y]==ff) 
            if (t==son[y][0]) rotate(t,1); 
            else rotate(t,0); 
        else if (y==son[fa[y]][0]) 
            if (t==son[y][0]) rotate(t,1),rotate(t,1); 
            else rotate(t,0),rotate(t,1); 
        else
            if (t==son[y][1]) rotate(t,0),rotate(t,0); 
            else rotate(t,1),rotate(t,0); 
    } 
    if (ff==0) root=t; 
} 
int splaybuild(int ll,int rr) 
{ 
    int mid=(ll+rr)&gt;&gt;1; 
    S[mid]=1; 
    if (ll&lt;mid) 
    { 
        int x=splaybuild(ll,mid-1); 
        S[mid]+=S[x]; 
        fa[x]=mid; 
        son[mid][0]=x; 
    } 
    if (mid&lt;rr) 
    { 
        int x=splaybuild(mid+1,rr); 
        S[mid]+=S[x]; 
        fa[x]=mid; 
        son[mid][1]=x; 
    } 
    return mid; 
} 
int find(int t,int x) 
{ 
    for (;t;) 
    { 
    	pushdown(t);
        if (x==S[son[t][0]]+1) return t; 
        if (x&lt;=S[son[t][0]]) t=son[t][0]; 
        else x-=(S[son[t][0]]+1),t=son[t][1]; 
    } 
} 
void zhong(int t) 
{ 
    if (t==0) return; 
    pushdown(t); 
    zhong(son[t][0]); 
    printf(&quot;%d &quot;,tree[t]); 
    zhong(son[t][1]); 
} 
int main() 
{ 
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m); 
    n+=2; 
    root=splaybuild(1,n); 
    for (;m;m--) 
    { 
        tmax[0]=-inf;
        scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;aa,&amp;bb); 
        ++aa,++bb; 
        x=find(root,aa-1); 
        splay(x,0); 
        y=find(root,bb+1); 
        splay(y,x); 
        x=son[y][0]; 
        if (kind==1) 
        { 
            scanf(&quot;%d&quot;,&amp;v); 
            tag1[x]+=v,tree[x]+=v,tmax[x]+=v; 
            splay(x,0); 
        } 
        else if (kind==2) 
        { 
            tag2[x]=!tag2[x]; 
            swap(son[x][0],son[x][1]);
            splay(x,0); 
        } 
        else printf(&quot;%d\n&quot;,tmax[x]); 
    } 
    return 0; 
} <pre><h2>Problem1251</h2><pre>#include&lt;cstdio&gt; 
using namespace std; 
const int inf=99999999;
int S[110000],son[110000][2],fa[110000],tree[110000],tmax[110000],tag1[110000]; 
bool tag2[110000]; 
int n,m,kind,x,y,root,aa,bb,v; 
int max(int a,int b) {return a&gt;b?a:b;} 
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
void update(int t) 
{ 
    S[t]=S[son[t][0]]+S[son[t][1]]+1;
    tmax[t]=max(tree[t],max(tmax[son[t][0]],tmax[son[t][1]]));
} 
void pushdown(int t) 
{ 
	if (t==0) return;
    int x=son[t][0],y=son[t][1]; 
    if (tag1[t]) 
    { 
        if (x!=0) tag1[x]+=tag1[t],tree[x]+=tag1[t],tmax[x]+=tag1[t]; 
        if (y!=0) tag1[y]+=tag1[t],tree[y]+=tag1[t],tmax[y]+=tag1[t]; 
        tag1[t]=0; 
    } 
    if (tag2[t]) 
    { 
	    if (x!=0) tag2[x]=!tag2[x],swap(son[x][0],son[x][1]);
		if (y!=0) tag2[y]=!tag2[y],swap(son[y][0],son[y][1]); 
        tag2[t]=0; 
    } 
} 
void rotate(int t,int p) 
{ 
    int y=fa[t]; 
    pushdown(y); 
    pushdown(t); 
    fa[t]=fa[y]; 
    if (fa[y]) 
        if (y==son[fa[y]][0]) son[fa[y]][0]=t; 
        else son[fa[y]][1]=t; 
    son[y][p^1]=son[t][p]; 
    if (son[t][p]) fa[son[t][p]]=y; 
    son[t][p]=y; 
    fa[y]=t; 
    update(y); 
    update(t); 
} 
void splay(int t,int ff) 
{ 
    while (fa[t]!=ff) 
    { 
        int y=fa[t]; 
        if (fa[y]==ff) 
            if (t==son[y][0]) rotate(t,1); 
            else rotate(t,0); 
        else if (y==son[fa[y]][0]) 
            if (t==son[y][0]) rotate(t,1),rotate(t,1); 
            else rotate(t,0),rotate(t,1); 
        else
            if (t==son[y][1]) rotate(t,0),rotate(t,0); 
            else rotate(t,1),rotate(t,0); 
    } 
    if (ff==0) root=t; 
} 
int splaybuild(int ll,int rr) 
{ 
    int mid=(ll+rr)&gt;&gt;1; 
    S[mid]=1; 
    if (ll&lt;mid) 
    { 
        int x=splaybuild(ll,mid-1); 
        S[mid]+=S[x]; 
        fa[x]=mid; 
        son[mid][0]=x; 
    } 
    if (mid&lt;rr) 
    { 
        int x=splaybuild(mid+1,rr); 
        S[mid]+=S[x]; 
        fa[x]=mid; 
        son[mid][1]=x; 
    } 
    return mid; 
} 
int find(int t,int x) 
{ 
    for (;t;) 
    { 
    	pushdown(t);
        if (x==S[son[t][0]]+1) return t; 
        if (x&lt;=S[son[t][0]]) t=son[t][0]; 
        else x-=(S[son[t][0]]+1),t=son[t][1]; 
    } 
} 
void zhong(int t) 
{ 
    if (t==0) return; 
    pushdown(t); 
    zhong(son[t][0]); 
    printf(&quot;%d &quot;,tree[t]); 
    zhong(son[t][1]); 
} 
int main() 
{ 
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m); 
    n+=2; 
    root=splaybuild(1,n); 
    for (;m;m--) 
    { 
        tmax[0]=-inf;
        scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;aa,&amp;bb); 
        ++aa,++bb; 
        x=find(root,aa-1); 
        splay(x,0); 
        y=find(root,bb+1); 
        splay(y,x); 
        x=son[y][0]; 
        if (kind==1) 
        { 
            scanf(&quot;%d&quot;,&amp;v); 
            tag1[x]+=v,tree[x]+=v,tmax[x]+=v; 
            splay(x,0); 
        } 
        else if (kind==2) 
        { 
            tag2[x]=!tag2[x]; 
            swap(son[x][0],son[x][1]);
            splay(x,0); 
        } 
        else printf(&quot;%d\n&quot;,tmax[x]); 
    } 
    return 0; 
} <pre><h2>Problem1251</h2><pre>#include&lt;cstdio&gt; 
using namespace std; 
const int inf=99999999;
int S[110000],son[110000][2],fa[110000],tree[110000],tmax[110000],tag1[110000]; 
bool tag2[110000]; 
int n,m,kind,x,y,root,aa,bb,v; 
int max(int a,int b) {return a&gt;b?a:b;} 
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
void update(int t) 
{ 
    S[t]=S[son[t][0]]+S[son[t][1]]+1;
    tmax[t]=max(tree[t],max(tmax[son[t][0]],tmax[son[t][1]]));
} 
void pushdown(int t) 
{ 
	//if (t==0) return;
    int x=son[t][0],y=son[t][1]; 
    if (tag1[t]) 
    { 
        if (x!=0) tag1[x]+=tag1[t],tree[x]+=tag1[t],tmax[x]+=tag1[t]; 
        if (y!=0) tag1[y]+=tag1[t],tree[y]+=tag1[t],tmax[y]+=tag1[t]; 
        tag1[t]=0; 
    } 
    if (tag2[t]) 
    { 
	    if (x!=0) tag2[x]=!tag2[x],swap(son[x][0],son[x][1]);
		if (y!=0) tag2[y]=!tag2[y],swap(son[y][0],son[y][1]); 
        tag2[t]=0; 
    } 
} 
void rotate(int t,int p) 
{ 
    int y=fa[t]; 
    pushdown(y); 
    pushdown(t); 
    fa[t]=fa[y]; 
    if (fa[y]) 
        if (y==son[fa[y]][0]) son[fa[y]][0]=t; 
        else son[fa[y]][1]=t; 
    son[y][p^1]=son[t][p]; 
    if (son[t][p]) fa[son[t][p]]=y; 
    son[t][p]=y; 
    fa[y]=t; 
    update(y); 
    update(t); 
} 
void splay(int t,int ff) 
{ 
    while (fa[t]!=ff) 
    { 
        int y=fa[t]; 
        if (fa[y]==ff) 
            if (t==son[y][0]) rotate(t,1); 
            else rotate(t,0); 
        else if (y==son[fa[y]][0]) 
            if (t==son[y][0]) rotate(t,1),rotate(t,1); 
            else rotate(t,0),rotate(t,1); 
        else
            if (t==son[y][1]) rotate(t,0),rotate(t,0); 
            else rotate(t,1),rotate(t,0); 
    } 
    if (ff==0) root=t; 
} 
int splaybuild(int ll,int rr) 
{ 
    int mid=(ll+rr)&gt;&gt;1; 
    S[mid]=1; 
    if (ll&lt;mid) 
    { 
        int x=splaybuild(ll,mid-1); 
        S[mid]+=S[x]; 
        fa[x]=mid; 
        son[mid][0]=x; 
    } 
    if (mid&lt;rr) 
    { 
        int x=splaybuild(mid+1,rr); 
        S[mid]+=S[x]; 
        fa[x]=mid; 
        son[mid][1]=x; 
    } 
    return mid; 
} 
int find(int t,int x) 
{ 
    for (;t;) 
    { 
    	pushdown(t);
        if (x==S[son[t][0]]+1) return t; 
        if (x&lt;=S[son[t][0]]) t=son[t][0]; 
        else x-=(S[son[t][0]]+1),t=son[t][1]; 
    } 
} 
void zhong(int t) 
{ 
    if (t==0) return; 
    pushdown(t); 
    zhong(son[t][0]); 
    printf(&quot;%d &quot;,tree[t]); 
    zhong(son[t][1]); 
} 
int main() 
{ 
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m); 
    n+=2; 
    root=splaybuild(1,n); 
    for (;m;m--) 
    { 
        tmax[0]=-inf;
        scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;aa,&amp;bb); 
        ++aa,++bb; 
        x=find(root,aa-1); 
        splay(x,0); 
        y=find(root,bb+1); 
        splay(y,x); 
        x=son[y][0]; 
        if (kind==1) 
        { 
            scanf(&quot;%d&quot;,&amp;v); 
            tag1[x]+=v,tree[x]+=v,tmax[x]+=v; 
            splay(x,0); 
        } 
        else if (kind==2) 
        { 
            tag2[x]=!tag2[x]; 
            swap(son[x][0],son[x][1]);
            splay(x,0); 
        } 
        else printf(&quot;%d\n&quot;,tmax[x]); 
    } 
    return 0; 
} <pre><h2>Problem1251</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int inf=99999999;
int S[110000],son[110000][2],fa[110000],tree[110000],tmax[110000],tag1[110000];
bool tag2[110000];
int n,m,kind,x,y,root,aa,bb,v;
int max(int a,int b) {return a&gt;b?a:b;}
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
void update(int t)
{
    S[t]=S[son[t][0]]+S[son[t][1]]+1;
    tmax[t]=max(tree[t],max(tmax[son[t][0]],tmax[son[t][1]]));
}
void pushdown(int t)
{
    int x=son[t][0],y=son[t][1]; 
    if (tag1[t]) 
    { 
        if (x!=0) tag1[x]+=tag1[t],tree[x]+=tag1[t],tmax[x]+=tag1[t]; 
        if (y!=0) tag1[y]+=tag1[t],tree[y]+=tag1[t],tmax[y]+=tag1[t]; 
        tag1[t]=0; 
    } 
    if (tag2[t]) 
    { 
	    if (x!=0) tag2[x]=!tag2[x],swap(son[x][0],son[x][1]);
		if (y!=0) tag2[y]=!tag2[y],swap(son[y][0],son[y][1]); 
        tag2[t]=0; 
    } 
} 
void rotate(int t,int p) 
{ 
    int y=fa[t]; 
    pushdown(y); 
    pushdown(t); 
    fa[t]=fa[y]; 
    if (fa[y]) 
        if (y==son[fa[y]][0]) son[fa[y]][0]=t; 
        else son[fa[y]][1]=t; 
    son[y][p^1]=son[t][p]; 
    if (son[t][p]) fa[son[t][p]]=y; 
    son[t][p]=y; 
    fa[y]=t; 
    update(y); 
    update(t); 
} 
void splay(int t,int ff) 
{ 
    while (fa[t]!=ff) 
    { 
        int y=fa[t]; 
        if (fa[y]==ff) 
            if (t==son[y][0]) rotate(t,1); 
            else rotate(t,0); 
        else if (y==son[fa[y]][0]) 
            if (t==son[y][0]) rotate(t,1),rotate(t,1); 
            else rotate(t,0),rotate(t,1); 
        else
            if (t==son[y][1]) rotate(t,0),rotate(t,0); 
            else rotate(t,1),rotate(t,0); 
    } 
    if (ff==0) root=t; 
} 
int splaybuild(int ll,int rr) 
{ 
    int mid=(ll+rr)&gt;&gt;1; 
    S[mid]=1; 
    if (ll&lt;mid) 
    { 
        int x=splaybuild(ll,mid-1); 
        S[mid]+=S[x]; 
        fa[x]=mid; 
        son[mid][0]=x; 
    } 
    if (mid&lt;rr) 
    { 
        int x=splaybuild(mid+1,rr); 
        S[mid]+=S[x]; 
        fa[x]=mid; 
        son[mid][1]=x; 
    } 
    return mid; 
} 
int find(int t,int x) 
{ 
    for (;t;) 
    { 
    	pushdown(t);
        if (x==S[son[t][0]]+1) return t; 
        if (x&lt;=S[son[t][0]]) t=son[t][0]; 
        else x-=(S[son[t][0]]+1),t=son[t][1]; 
    } 
} 
void zhong(int t) 
{ 
    if (t==0) return; 
    pushdown(t); 
    zhong(son[t][0]); 
    printf(&quot;%d &quot;,tree[t]); 
    zhong(son[t][1]); 
} 
int main() 
{ 
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m); 
    n+=2; 
    root=splaybuild(1,n); 
    for (;m;m--) 
    { 
        tmax[0]=-inf;
        scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;aa,&amp;bb); 
        ++aa,++bb; 
        x=find(root,aa-1); 
        splay(x,0); 
        y=find(root,bb+1); 
        splay(y,x); 
        x=son[y][0]; 
        if (kind==1) 
        { 
            scanf(&quot;%d&quot;,&amp;v); 
            tag1[x]+=v,tree[x]+=v,tmax[x]+=v; 
            splay(x,0); 
        } 
        else if (kind==2) 
        { 
            tag2[x]=!tag2[x]; 
            swap(son[x][0],son[x][1]);
            splay(x,0); 
        } 
        else printf(&quot;%d\n&quot;,tmax[x]); 
    } 
    return 0; 
} <pre><h2>Problem1251</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int inf=99999999;
int S[110000],son[110000][2],fa[110000],tree[110000],tmax[110000],tag1[110000];
bool tag2[110000];
int n,m,kind,x,y,root,aa,bb,v;
int max(int a,int b) {return a&gt;b?a:b;}
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
void update(int t)
{
    S[t]=S[son[t][0]]+S[son[t][1]]+1;
    tmax[t]=max(tree[t],max(tmax[son[t][0]],tmax[son[t][1]]));
}
void pushdown(int t)
{
    int x=son[t][0],y=son[t][1]; 
    if (tag1[t]) 
    { 
        if (x!=0) tag1[x]+=tag1[t],tree[x]+=tag1[t],tmax[x]+=tag1[t]; 
        if (y!=0) tag1[y]+=tag1[t],tree[y]+=tag1[t],tmax[y]+=tag1[t]; 
        tag1[t]=0; 
    } 
    if (tag2[t]) 
    { 
	    if (x!=0) tag2[x]=!tag2[x],swap(son[x][0],son[x][1]);
		if (y!=0) tag2[y]=!tag2[y],swap(son[y][0],son[y][1]); 
        tag2[t]=0; 
    } 
} 
void rotate(int t,int p) 
{ 
    int y=fa[t]; 
    pushdown(y); 
    pushdown(t); 
    fa[t]=fa[y]; 
    if (fa[y]) 
        if (y==son[fa[y]][0]) son[fa[y]][0]=t; 
        else son[fa[y]][1]=t; 
    son[y][p^1]=son[t][p]; 
    if (son[t][p]) fa[son[t][p]]=y; 
    son[t][p]=y; 
    fa[y]=t; 
    update(y); 
    update(t); 
} 
void splay(int t,int ff) 
{ 
    while (fa[t]!=ff) 
    { 
        int y=fa[t]; 
        if (fa[y]==ff) 
            if (t==son[y][0]) rotate(t,1); 
            else rotate(t,0); 
        else if (y==son[fa[y]][0]) 
            if (t==son[y][0]) rotate(t,1),rotate(t,1); 
            else rotate(t,0),rotate(t,1); 
        else
            if (t==son[y][1]) rotate(t,0),rotate(t,0); 
            else rotate(t,1),rotate(t,0); 
    } 
    if (ff==0) root=t; 
} 
int splaybuild(int ll,int rr) 
{ 
    int mid=(ll+rr)&gt;&gt;1; 
    S[mid]=1; 
    if (ll&lt;mid) 
    { 
        int x=splaybuild(ll,mid-1); 
        S[mid]+=S[x]; 
        fa[x]=mid; 
        son[mid][0]=x; 
    } 
    if (mid&lt;rr) 
    { 
        int x=splaybuild(mid+1,rr); 
        S[mid]+=S[x]; 
        fa[x]=mid; 
        son[mid][1]=x; 
    } 
    return mid; 
} 
int find(int t,int x) 
{ 
    for (;t;) 
    { 
    	pushdown(t);
        if (x==S[son[t][0]]+1) return t; 
        if (x&lt;=S[son[t][0]]) t=son[t][0]; 
        else x-=(S[son[t][0]]+1),t=son[t][1]; 
    } 
} 
void zhong(int t) 
{ 
    if (t==0) return; 
    pushdown(t); 
    zhong(son[t][0]); 
    printf(&quot;%d &quot;,tree[t]); 
    zhong(son[t][1]); 
}
int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    n+=2;
    root=splaybuild(1,n);
    tmax[0]=-inf;
    for (;m;m--)
    {
        scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;aa,&amp;bb);
        ++aa,++bb;
        x=find(root,aa-1);
        splay(x,0);
        y=find(root,bb+1);
        splay(y,x);
        x=son[y][0];
        if (kind==1)
        {
            scanf(&quot;%d&quot;,&amp;v);
            tag1[x]+=v,tree[x]+=v,tmax[x]+=v;
            splay(x,0);
        }
        else if (kind==2)
        {
            tag2[x]=!tag2[x];
            swap(son[x][0],son[x][1]);
            splay(x,0);
        }
        else printf(&quot;%d\n&quot;,tmax[x]);
    }
    return 0;
}<pre><h2>Problem1251</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int inf=99999999;
int S[110000],son[110000][2],fa[110000],tree[110000],tmax[110000],tag1[110000];
bool tag2[110000];
int n,m,kind,x,y,root,aa,bb,v,size;
int max(int a,int b) {return a&gt;b?a:b;}
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
void update(int t)
{
    S[t]=S[son[t][0]]+S[son[t][1]]+1;
    tmax[t]=max(tree[t],max(tmax[son[t][0]],tmax[son[t][1]]));
}
void pushdown(int t)
{
    int x=son[t][0],y=son[t][1];
    if (tag1[t])
    {
        if (x!=0) tag1[x]+=tag1[t],tree[x]+=tag1[t],tmax[x]+=tag1[t];
        if (y!=0) tag1[y]+=tag1[t],tree[y]+=tag1[t],tmax[y]+=tag1[t];
        tag1[t]=0;
    }
    if (tag2[t])
    {
	    if (x!=0) tag2[x]=!tag2[x],swap(son[x][0],son[x][1]);
		if (y!=0) tag2[y]=!tag2[y],swap(son[y][0],son[y][1]); 
        tag2[t]=0;
    }
}
void rotate(int t,int p)
{
    int y=fa[t];
    pushdown(y);
    pushdown(t);
    fa[t]=fa[y];
    if (fa[y])
        if (y==son[fa[y]][0]) son[fa[y]][0]=t;
        else son[fa[y]][1]=t;
    son[y][p^1]=son[t][p];
    if (son[t][p]) fa[son[t][p]]=y;
    son[t][p]=y;
    fa[y]=t;
    update(y);
    update(t);
}
void splay(int t,int ff)
{
    while (fa[t]!=ff)
    {
        int y=fa[t];
        if (fa[y]==ff)
            if (t==son[y][0]) rotate(t,1);
            else rotate(t,0);
        else if (y==son[fa[y]][0])
            if (t==son[y][0]) rotate(t,1),rotate(t,1);
            else rotate(t,0),rotate(t,1);
        else
            if (t==son[y][1]) rotate(t,0),rotate(t,0);
            else rotate(t,1),rotate(t,0);
    }
    if (ff==0) root=t;
}
int splaybuild(int ll,int rr)
{
    int mid=(ll+rr)&gt;&gt;1;
    int tmp=++size;
    S[tmp]=1;
    tree[tmp]=0;
    tmax[tmp]=0;
    if (ll&lt;mid)
    {
        int x=splaybuild(ll,mid-1);
        S[tmp]+=S[x];
        fa[x]=tmp;
        son[tmp][0]=x;
    }
    if (mid&lt;rr)
    {
        int x=splaybuild(mid+1,rr);
        S[tmp]+=S[x];
        fa[x]=tmp;
        son[tmp][1]=x;
    }
    return tmp;
}
int find(int t,int x)
{
    for (;t;)
    {
    	pushdown(t);
        if (x==S[son[t][0]]+1) return t;
        if (x&lt;=S[son[t][0]]) t=son[t][0];
        else x-=(S[son[t][0]]+1),t=son[t][1];
    }
}
int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    n+=2;
    root=splaybuild(1,n);
    tmax[0]=-inf;
    for (;m;m--)
    {
        scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;aa,&amp;bb);
        ++aa,++bb;
        x=find(root,aa-1);
        splay(x,0);
        y=find(root,bb+1);
        splay(y,x);
        x=son[y][0];
        if (kind==1)
        {
            scanf(&quot;%d&quot;,&amp;v);
            tag1[x]+=v,tree[x]+=v,tmax[x]+=v;
            splay(x,0);
        }
        else if (kind==2)
        {
            tag2[x]=!tag2[x];
            swap(son[x][0],son[x][1]);
            splay(x,0);
        }
        else printf(&quot;%d\n&quot;,tmax[x]);
    }
    return 0;
}<pre><h2>Problem1251</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int inf=99999999;
int S[110000],son[110000][2],fa[110000],tree[110000],tmax[110000],tag1[110000];
bool tag2[110000];
int n,m,kind,x,y,root,aa,bb,v,size;
int max(int a,int b) {return a&gt;b?a:b;}
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
void update(int t)
{
    S[t]=S[son[t][0]]+S[son[t][1]]+1;
    tmax[t]=max(tree[t],max(tmax[son[t][0]],tmax[son[t][1]]));
}
void pushdown(int t)
{
    int x=son[t][0],y=son[t][1];
    if (tag1[t])
    {
        if (x!=0) tag1[x]+=tag1[t],tree[x]+=tag1[t],tmax[x]+=tag1[t];
        if (y!=0) tag1[y]+=tag1[t],tree[y]+=tag1[t],tmax[y]+=tag1[t];
        tag1[t]=0;
    }
    if (tag2[t])
    {
	    if (x!=0) tag2[x]=!tag2[x],swap(son[x][0],son[x][1]);
		if (y!=0) tag2[y]=!tag2[y],swap(son[y][0],son[y][1]); 
        tag2[t]=0;
    }
}
void rotate(int t,int p)
{
    int y=fa[t];
    pushdown(y);
    pushdown(t);
    fa[t]=fa[y];
    if (fa[y])
        if (y==son[fa[y]][0]) son[fa[y]][0]=t;
        else son[fa[y]][1]=t;
    son[y][p^1]=son[t][p];
    if (son[t][p]) fa[son[t][p]]=y;
    son[t][p]=y;
    fa[y]=t;
    update(y);
    update(t);
}
void splay(int t,int ff)
{
    while (fa[t]!=ff)
    {
        int y=fa[t];
        if (fa[y]==ff)
            if (t==son[y][0]) rotate(t,1);
            else rotate(t,0);
        else if (y==son[fa[y]][0])
            if (t==son[y][0]) rotate(t,1),rotate(t,1);
            else rotate(t,0),rotate(t,1);
        else
            if (t==son[y][1]) rotate(t,0),rotate(t,0);
            else rotate(t,1),rotate(t,0);
    }
    if (ff==0) root=t;
}
int splaybuild(int ll,int rr)
{
    int mid=(ll+rr)&gt;&gt;1;
    int tmp=++size;
    S[tmp]=1;
    tree[tmp]=0;
    tmax[tmp]=0;
    if (ll&lt;mid)
    {
        int x=splaybuild(ll,mid-1);
        S[tmp]+=S[x];
        fa[x]=tmp;
        son[tmp][0]=x;
    }
    if (mid&lt;rr)
    {
        int x=splaybuild(mid+1,rr);
        S[tmp]+=S[x];
        fa[x]=tmp;
        son[tmp][1]=x;
    }
    return tmp;
}
int find(int t,int x)
{
    for (;t;)
    {
    	pushdown(t);
        if (x==S[son[t][0]]+1) return t;
        if (x&lt;=S[son[t][0]]) t=son[t][0];
        else x-=(S[son[t][0]]+1),t=son[t][1];
    }
}
int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    root=splaybuild(1,n+2);
    S[0]=0,tree[0]=-inf,tmax[0]=-inf;
    for (;m;m--)
    {
        scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;aa,&amp;bb);
        ++aa,++bb;
        x=find(root,aa-1);
        splay(x,0);
        y=find(root,bb+1);
        splay(y,x);
        x=son[y][0];
        if (kind==1)
        {
            scanf(&quot;%d&quot;,&amp;v);
            tag1[x]+=v,tree[x]+=v,tmax[x]+=v;
            splay(x,0);
        }
        else if (kind==2)
        {
            tag2[x]=!tag2[x];
            swap(son[x][0],son[x][1]);
            splay(x,0);
        }
        else printf(&quot;%d\n&quot;,tmax[x]);
    }
    return 0;
}<pre><h2>Problem1251</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int inf=99999999;
int S[110000],son[110000][2],fa[110000],tree[110000],tmax[110000],tag1[110000];
bool tag2[110000];
int n,m,kind,x,y,root,aa,bb,v,size;
int max(int a,int b) {return a&gt;b?a:b;}
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
void update(int t)
{
    //S[t]=S[son[t][0]]+S[son[t][1]]+1;
    //tmax[t]=max(tree[t],max(tmax[son[t][0]],tmax[son[t][1]]));
    S[t]=1,tmax[t]=tree[t];
    if (son[t][0]) S[t]+=S[son[t][0]],tmax[t]=max(tmax[t],tmax[son[t][0]]);
    if (son[t][1]) S[t]+=S[son[t][1]],tmax[t]=max(tmax[t],tmax[son[t][1]]);
}
void pushdown(int t)
{
    int x=son[t][0],y=son[t][1];
    if (tag1[t])
    {
        if (x!=0) tag1[x]+=tag1[t],tree[x]+=tag1[t],tmax[x]+=tag1[t];
        if (y!=0) tag1[y]+=tag1[t],tree[y]+=tag1[t],tmax[y]+=tag1[t];
        tag1[t]=0;
    }
    if (tag2[t])
    {
	    if (x!=0) tag2[x]=!tag2[x],swap(son[x][0],son[x][1]);
		if (y!=0) tag2[y]=!tag2[y],swap(son[y][0],son[y][1]);
        tag2[t]=0;
    }
}
void rotate(int t,int p)
{
    int y=fa[t];
    pushdown(y);
    pushdown(t);
    fa[t]=fa[y];
    if (fa[y])
        if (y==son[fa[y]][0]) son[fa[y]][0]=t;
        else son[fa[y]][1]=t;
    son[y][p^1]=son[t][p];
    if (son[t][p]) fa[son[t][p]]=y;
    son[t][p]=y;
    fa[y]=t;
    update(y);
    update(t);
}
void splay(int t,int ff)
{
    while (fa[t]!=ff)
    {
        int y=fa[t];
        if (fa[y]==ff)
            if (t==son[y][0]) rotate(t,1);
            else rotate(t,0);
        else if (y==son[fa[y]][0])
            if (t==son[y][0]) rotate(t,1),rotate(t,1);
            else rotate(t,0),rotate(t,1);
        else
            if (t==son[y][1]) rotate(t,0),rotate(t,0);
            else rotate(t,1),rotate(t,0);
    }
    if (ff==0) root=t;
}
int splaybuild(int ll,int rr)
{
    int mid=(ll+rr)&gt;&gt;1;
    int tmp=++size;
    S[tmp]=1;
    tree[tmp]=0;
    tmax[tmp]=0;
    if (ll&lt;mid)
    {
        int x=splaybuild(ll,mid-1);
        S[tmp]+=S[x];
        fa[x]=tmp;
        son[tmp][0]=x;
    }
    if (mid&lt;rr)
    {
        int x=splaybuild(mid+1,rr);
        S[tmp]+=S[x];
        fa[x]=tmp;
        son[tmp][1]=x;
    }
    return tmp;
}
int find(int t,int x)
{
    for (;t;)
    {
    	pushdown(t);
        if (x==S[son[t][0]]+1) return t;
        if (x&lt;=S[son[t][0]]) t=son[t][0];
        else x-=(S[son[t][0]]+1),t=son[t][1];
    }
}
int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    root=splaybuild(1,n+2);
    //S[0]=0,tree[0]=-inf,tmax[0]=-inf;
    for (;m;m--)
    {
        scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;aa,&amp;bb);
        ++aa,++bb;
        x=find(root,aa-1);
        splay(x,0);
        y=find(root,bb+1);
        splay(y,x);
        x=son[y][0];
        if (kind==1)
        {
            scanf(&quot;%d&quot;,&amp;v);
            tag1[x]+=v,tree[x]+=v,tmax[x]+=v;
            splay(x,0);
        }
        else if (kind==2)
        {
            tag2[x]=!tag2[x];
            swap(son[x][0],son[x][1]);
            splay(x,0);
        }
        else printf(&quot;%d\n&quot;,tmax[x]);
    }
    return 0;
}<pre><h2>Problem1251</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int inf=99999999;
int S[110000],son[110000][2],fa[110000],tree[110000],tmax[110000],tag1[110000];
bool tag2[110000];
int n,m,kind,x,y,root,aa,bb,v,size;
int max(int a,int b) {return a&gt;b?a:b;}
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
void update(int t)
{
    S[t]=S[son[t][0]]+S[son[t][1]]+1;
    tmax[t]=max(tree[t],max(tmax[son[t][0]],tmax[son[t][1]]));
}
void pushdown(int t)
{
    int x=son[t][0],y=son[t][1];
    if (tag1[t])
    {
        if (x!=0) tag1[x]+=tag1[t],tree[x]+=tag1[t],tmax[x]+=tag1[t];
        if (y!=0) tag1[y]+=tag1[t],tree[y]+=tag1[t],tmax[y]+=tag1[t];
        tag1[t]=0;
    }
    if (tag2[t])
    {
	    if (x!=0) tag2[x]=!tag2[x],swap(son[x][0],son[x][1]);
		if (y!=0) tag2[y]=!tag2[y],swap(son[y][0],son[y][1]);
        tag2[t]=0;
    }
}
void rotate(int t,int p)
{
    int y=fa[t];
    pushdown(y);
    pushdown(t);
    fa[t]=fa[y];
    if (fa[y])
        if (y==son[fa[y]][0]) son[fa[y]][0]=t;
        else son[fa[y]][1]=t;
    son[y][p^1]=son[t][p];
    if (son[t][p]) fa[son[t][p]]=y;
    son[t][p]=y;
    fa[y]=t;
    update(y);
    update(t);
}
void splay(int t,int ff)
{
    while (fa[t]!=ff)
    {
        int y=fa[t];
        if (fa[y]==ff)
            if (t==son[y][0]) rotate(t,1);
            else rotate(t,0);
        else if (y==son[fa[y]][0])
            if (t==son[y][0]) rotate(y,1),rotate(t,1);
            else rotate(t,0),rotate(t,1);
        else
            if (t==son[y][1]) rotate(y,0),rotate(t,0);
            else rotate(t,1),rotate(t,0);
    }
    if (ff==0) root=t;
}
int splaybuild(int ll,int rr)
{
    int mid=(ll+rr)&gt;&gt;1;
    int tmp=++size;
    S[tmp]=1;
    tree[tmp]=0;
    tmax[tmp]=0;
    if (ll&lt;mid)
    {
        int x=splaybuild(ll,mid-1);
        S[tmp]+=S[x];
        fa[x]=tmp;
        son[tmp][0]=x;
    }
    if (mid&lt;rr)
    {
        int x=splaybuild(mid+1,rr);
        S[tmp]+=S[x];
        fa[x]=tmp;
        son[tmp][1]=x;
    }
    return tmp;
}
int find(int t,int x)
{
    for (;t;)
    {
    	pushdown(t);
        if (x==S[son[t][0]]+1) return t;
        if (x&lt;=S[son[t][0]]) t=son[t][0];
        else x-=(S[son[t][0]]+1),t=son[t][1];
    }
}
int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    root=splaybuild(1,n+2);
    S[0]=0,tree[0]=-inf,tmax[0]=-inf;
    for (;m;m--)
    {
        scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;aa,&amp;bb);
        ++aa,++bb;
        x=find(root,aa-1);
        splay(x,0);
        y=find(root,bb+1);
        splay(y,x);
        x=son[y][0];
        if (kind==1)
        {
            scanf(&quot;%d&quot;,&amp;v);
            tag1[x]+=v,tree[x]+=v,tmax[x]+=v;
            splay(x,0);
        }
        else if (kind==2)
        {
            tag2[x]=!tag2[x];
            swap(son[x][0],son[x][1]);
            splay(x,0);
        }
        else printf(&quot;%d\n&quot;,tmax[x]);
    }
    return 0;
}<pre><h2>Problem1251</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int inf=99999999;
int S[110000],son[110000][2],fa[110000],tree[110000],tmax[110000],tag1[110000];
bool tag2[110000];
int n,m,kind,x,y,root,aa,bb,v,size;
int max(int a,int b) {return a&gt;b?a:b;}
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
void update(int t)
{
    S[t]=S[son[t][0]]+S[son[t][1]]+1;
    tmax[t]=max(tree[t],max(tmax[son[t][0]],tmax[son[t][1]]));
}
void pushdown(int t)
{
    int x=son[t][0],y=son[t][1];
    if (tag1[t])
    {
        if (x!=0) tag1[x]+=tag1[t],tree[x]+=tag1[t],tmax[x]+=tag1[t];
        if (y!=0) tag1[y]+=tag1[t],tree[y]+=tag1[t],tmax[y]+=tag1[t];
        tag1[t]=0;
    }
    if (tag2[t])
    {
	    if (x!=0) tag2[x]=!tag2[x],swap(son[x][0],son[x][1]);
		if (y!=0) tag2[y]=!tag2[y],swap(son[y][0],son[y][1]);
        tag2[t]=0;
    }
}
void rotate(int t,int p)
{
    int y=fa[t];
    //pushdown(y);
    //pushdown(t);
    fa[t]=fa[y];
    if (fa[y])
        if (y==son[fa[y]][0]) son[fa[y]][0]=t;
        else son[fa[y]][1]=t;
    son[y][p^1]=son[t][p];
    if (son[t][p]) fa[son[t][p]]=y;
    son[t][p]=y;
    fa[y]=t;
    update(y);
    update(t);
}
void splay(int t,int ff)
{
    while (fa[t]!=ff)
    {
        int y=fa[t];
        if (fa[y]==ff)
            if (t==son[y][0]) rotate(t,1);
            else rotate(t,0);
        else if (y==son[fa[y]][0])
            if (t==son[y][0]) rotate(y,1),rotate(t,1);
            else rotate(t,0),rotate(t,1);
        else
            if (t==son[y][1]) rotate(y,0),rotate(t,0);
            else rotate(t,1),rotate(t,0);
    }
    if (ff==0) root=t;
}
int splaybuild(int ll,int rr)
{
    int mid=(ll+rr)&gt;&gt;1;
    int tmp=++size;
    S[tmp]=1;
    tree[tmp]=0;
    tmax[tmp]=0;
    if (ll&lt;mid)
    {
        int x=splaybuild(ll,mid-1);
        S[tmp]+=S[x];
        fa[x]=tmp;
        son[tmp][0]=x;
    }
    if (mid&lt;rr)
    {
        int x=splaybuild(mid+1,rr);
        S[tmp]+=S[x];
        fa[x]=tmp;
        son[tmp][1]=x;
    }
    return tmp;
}
int find(int t,int x)
{
    for (;t;)
    {
    	pushdown(t);
        if (x==S[son[t][0]]+1) return t;
        if (x&lt;=S[son[t][0]]) t=son[t][0];
        else x-=(S[son[t][0]]+1),t=son[t][1];
    }
}
int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    root=splaybuild(1,n+2);
    S[0]=0,tree[0]=-inf,tmax[0]=-inf;
    for (;m;m--)
    {
        scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;aa,&amp;bb);
        ++aa,++bb;
        x=find(root,aa-1);
        splay(x,0);
        y=find(root,bb+1);
        splay(y,x);
        x=son[y][0];
        if (kind==1)
        {
            scanf(&quot;%d&quot;,&amp;v);
            tag1[x]+=v,tree[x]+=v,tmax[x]+=v;
            //splay(x,0);
        }
        else if (kind==2)
        {
            tag2[x]=!tag2[x];
            swap(son[x][0],son[x][1]);
            //splay(x,0);
        }
        else printf(&quot;%d\n&quot;,tmax[x]);
    }
    return 0;
}<pre><h2>Problem1251</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int inf=99999999;
int S[110000],son[110000][2],fa[110000],tree[110000],tmax[110000],tag1[110000];
bool tag2[110000];
int n,m,kind,x,y,root,aa,bb,v,size;
int max(int a,int b) {return a&gt;b?a:b;}
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
void update(int t)
{
    S[t]=S[son[t][0]]+S[son[t][1]]+1;
    tmax[t]=max(tree[t],max(tmax[son[t][0]],tmax[son[t][1]]));
}
void pushdown(int t)
{
    int x=son[t][0],y=son[t][1];
    if (tag1[t])
    {
        if (x!=0) tag1[x]+=tag1[t],tree[x]+=tag1[t],tmax[x]+=tag1[t];
        if (y!=0) tag1[y]+=tag1[t],tree[y]+=tag1[t],tmax[y]+=tag1[t];
        tag1[t]=0;
    }
    if (tag2[t])
    {
	    if (x!=0) tag2[x]=!tag2[x],swap(son[x][0],son[x][1]);
		if (y!=0) tag2[y]=!tag2[y],swap(son[y][0],son[y][1]);
        tag2[t]=0;
    }
}
void rotate(int t,int p)
{
    int y=fa[t];
    pushdown(y),pushdown(t);
    fa[t]=fa[y];
    if (fa[y])
        if (y==son[fa[y]][0]) son[fa[y]][0]=t;
        else son[fa[y]][1]=t;
    son[y][p^1]=son[t][p];
    if (son[t][p]) fa[son[t][p]]=y;
    son[t][p]=y;
    fa[y]=t;
    update(y),update(t);
}
void splay(int t,int ff)
{
    while (fa[t]!=ff)
    {
        int y=fa[t];
        if (fa[y]==ff)
            if (t==son[y][0]) rotate(t,1);
            else rotate(t,0);
        else if (y==son[fa[y]][0])
            if (t==son[y][0]) rotate(y,1),rotate(t,1);
            else rotate(t,0),rotate(t,1);
        else
            if (t==son[y][1]) rotate(y,0),rotate(t,0);
            else rotate(t,1),rotate(t,0);
    }
    if (ff==0) root=t;
}
int splaybuild(int ll,int rr)
{
    int mid=(ll+rr)&gt;&gt;1;
    int tmp=++size;
    S[tmp]=1;
    tree[tmp]=0;
    tmax[tmp]=0;
    if (ll&lt;mid)
    {
        int x=splaybuild(ll,mid-1);
        S[tmp]+=S[x];
        fa[x]=tmp;
        son[tmp][0]=x;
    }
    if (mid&lt;rr)
    {
        int x=splaybuild(mid+1,rr);
        S[tmp]+=S[x];
        fa[x]=tmp;
        son[tmp][1]=x;
    }
    return tmp;
}
int find(int t,int x)
{
    for (;t;)
    {
    	pushdown(t);
        if (x==S[son[t][0]]+1) return t;
        if (x&lt;=S[son[t][0]]) t=son[t][0];
        else x-=(S[son[t][0]]+1),t=son[t][1];
    }
}
int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    root=splaybuild(1,n+2);
    S[0]=0,tree[0]=-inf,tmax[0]=-inf;
    for (;m;m--)
    {
        scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;aa,&amp;bb);
        ++aa,++bb;
        x=find(root,aa-1);
        splay(x,0);
        y=find(root,bb+1);
        splay(y,x);
        x=son[y][0];
        if (kind==1)
        {
            scanf(&quot;%d&quot;,&amp;v);
            tag1[x]+=v,tree[x]+=v,tmax[x]+=v;
            splay(x,0);
        }
        else if (kind==2)
        {
            tag2[x]=!tag2[x];
            swap(son[x][0],son[x][1]);
            splay(x,0);
        }
        else printf(&quot;%d\n&quot;,tmax[x]);
    }
    return 0;
}<pre><h2>Problem1251</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=50111;
int fa[NN],son[NN][2],key[NN],size[NN],tmax[NN],tag2[NN];
int n,m,root;
bool tag1[NN];
inline void rev(int t)
{
	tag1[t]=!tag1[t];
	swap(son[t][0],son[t][1]);
}
inline void add(int v,int x)
{
	key[v]+=x,tmax[v]+=x,tag2[v]+=x;
}
void pushdown(int v)
{
	int x=son[v][0],y=son[v][1];
	if (tag1[v])
	{
		rev(x),rev(y);
		tag1[v]=false;
	}
	if (tag2[v]!=0)
	{
		add(x,tag2[v]),add(y,tag2[v]);
		tag2[v]=0;
	}
}
void update(int v)
{
	int x=son[v][0],y=son[v][1];
	size[v]=size[x]+size[y]+1;
	tmax[v]=key[v];
	if (x&amp;&amp;tmax[x]&gt;tmax[v]) tmax[v]=tmax[x];
	if (y&amp;&amp;tmax[y]&gt;tmax[v]) tmax[v]=tmax[y];
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (fa[y])
	{
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	}
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t,int f)
{
	while (fa[t]!=f)
	{
		int y=fa[t];
		if (fa[y]==f)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
	if (!f) root=t;
}
int find(int K)
{
	for (int t=root;t;)
	{
		pushdown(t);
		int tmp=size[son[t][0]];
		if (K==tmp+1) return t;
		if (K&lt;=tmp) t=son[t][0];
		else K-=(tmp+1),t=son[t][1];
	}
	return -1;
}
int build(int l,int r)
{
	int mid=(l+r)&gt;&gt;1;
	int v=mid;
	key[v]=tmax[v]=0;
	size[v]=1;
	if (l&lt;mid) son[v][0]=build(l,mid-1),fa[son[v][0]]=v;
	if (r&gt;mid) son[v][1]=build(mid+1,r),fa[son[v][1]]=v;
	update(v);
	return v;
}
void debug(int t){if(!t)return;pushdown(t);debug(son[t][0]);printf(&quot;%d &quot;,key[t]);debug(son[t][1]);}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	root=build(1,n+2);
	int i,x,y,z;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		if (x==1)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			x++,y++;
			x=find(x-1),splay(x,0);
			y=find(y+1),splay(y,x);
			x=son[y][0];
			add(x,z);
			splay(x,0);
		}
		else if (x==2)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x++,y++;
			x=find(x-1),splay(x,0);
			y=find(y+1),splay(y,x);
			x=son[y][0];
			rev(x);
			splay(x,0);
		}
		else
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x++,y++;
			x=find(x-1),splay(x,0);
			y=find(y+1),splay(y,x);
			x=son[y][0];
			printf(&quot;%d\n&quot;,tmax[x]);
		}
	}
	return 0;
}<pre><h2>Problem1251</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=50111;
int fa[NN],son[NN][2],key[NN],size[NN],tmax[NN],tag2[NN];
int n,m,root;
bool tag1[NN];
inline void rev(int t)
{
	tag1[t]=!tag1[t];
	swap(son[t][0],son[t][1]);
}
inline void add(int v,int x)
{
	key[v]+=x,tmax[v]+=x,tag2[v]+=x;
}
inline void pushdown(int v)
{
	int x=son[v][0],y=son[v][1];
	if (tag1[v])
	{
		rev(x),rev(y);
		tag1[v]=false;
	}
	if (tag2[v]!=0)
	{
		add(x,tag2[v]),add(y,tag2[v]);
		tag2[v]=0;
	}
}
inline void update(int v)
{
	int x=son[v][0],y=son[v][1];
	size[v]=size[x]+size[y]+1;
	tmax[v]=key[v];
	if (x&amp;&amp;tmax[x]&gt;tmax[v]) tmax[v]=tmax[x];
	if (y&amp;&amp;tmax[y]&gt;tmax[v]) tmax[v]=tmax[y];
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (fa[y])
	{
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	}
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t,int f)
{
	while (fa[t]!=f)
	{
		int y=fa[t];
		if (fa[y]==f)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
	if (!f) root=t;
}
int find(int K)
{
	for (int t=root;t;)
	{
		pushdown(t);
		int tmp=size[son[t][0]];
		if (K==tmp+1) return t;
		if (K&lt;=tmp) t=son[t][0];
		else K-=(tmp+1),t=son[t][1];
	}
	return -1;
}
int build(int l,int r)
{
	int mid=(l+r)&gt;&gt;1;
	int v=mid;
	key[v]=tmax[v]=0;
	size[v]=1;
	if (l&lt;mid) son[v][0]=build(l,mid-1),fa[son[v][0]]=v;
	if (r&gt;mid) son[v][1]=build(mid+1,r),fa[son[v][1]]=v;
	update(v);
	return v;
}
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	root=build(1,n+2);
	int i,x,y,z;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		if (x==1)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			x++,y++;
			x=find(x-1),splay(x,0);
			y=find(y+1),splay(y,x);
			x=son[y][0];
			add(x,z);
			splay(x,0);
		}
		else if (x==2)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x++,y++;
			x=find(x-1),splay(x,0);
			y=find(y+1),splay(y,x);
			x=son[y][0];
			rev(x);
			splay(x,0);
		}
		else
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x++,y++;
			x=find(x-1),splay(x,0);
			y=find(y+1),splay(y,x);
			x=son[y][0];
			printf(&quot;%d\n&quot;,tmax[x]);
		}
	}
	return 0;
}<pre><h2>Problem1251</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=50111;
int fa[NN],son[NN][2],key[NN],size[NN],tmax[NN],tag2[NN];
int n,m,root;
bool tag1[NN];
void rev(int t)
{
	tag1[t]=!tag1[t];
	swap(son[t][0],son[t][1]);
}
void add(int v,int x)
{
	key[v]+=x,tmax[v]+=x,tag2[v]+=x;
}
void pushdown(int v)
{
	int x=son[v][0],y=son[v][1];
	if (tag1[v])
	{
		rev(x),rev(y);
		tag1[v]=false;
	}
	if (tag2[v]!=0)
	{
		add(x,tag2[v]),add(y,tag2[v]);
		tag2[v]=0;
	}
}
void update(int v)
{
	int x=son[v][0],y=son[v][1];
	size[v]=size[x]+size[y]+1;
	tmax[v]=key[v];
	if (x&amp;&amp;tmax[x]&gt;tmax[v]) tmax[v]=tmax[x];
	if (y&amp;&amp;tmax[y]&gt;tmax[v]) tmax[v]=tmax[y];
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (fa[y])
	{
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	}
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t,int f)
{
	while (fa[t]!=f)
	{
		int y=fa[t];
		if (fa[y]==f)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
	if (!f) root=t;
}
int find(int K)
{
	for (int t=root;t;)
	{
		pushdown(t);
		int tmp=size[son[t][0]];
		if (K==tmp+1) return t;
		if (K&lt;=tmp) t=son[t][0];
		else K-=(tmp+1),t=son[t][1];
	}
	return -1;
}
int build(int l,int r)
{
	int mid=(l+r)&gt;&gt;1;
	int v=mid;
	key[v]=tmax[v]=0;
	size[v]=1;
	if (l&lt;mid) son[v][0]=build(l,mid-1),fa[son[v][0]]=v;
	if (r&gt;mid) son[v][1]=build(mid+1,r),fa[son[v][1]]=v;
	update(v);
	return v;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	root=build(1,n+2);
	int i,x,y,z;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		if (x==1)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			x++,y++;
			x=find(x-1),splay(x,0);
			y=find(y+1),splay(y,x);
			x=son[y][0];
			add(x,z);
			splay(x,0);
		}
		else if (x==2)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x++,y++;
			x=find(x-1),splay(x,0);
			y=find(y+1),splay(y,x);
			x=son[y][0];
			rev(x);
			splay(x,0);
		}
		else
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x++,y++;
			x=find(x-1),splay(x,0);
			y=find(y+1),splay(y,x);
			x=son[y][0];
			printf(&quot;%d\n&quot;,tmax[x]);
		}
	}
	return 0;
}<pre><h2>Problem1251</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=50111;
int fa[NN],son[NN][2],key[NN],size[NN],tmax[NN],tag2[NN];
int n,m,root;
bool tag1[NN];
inline void rev(int t)
{
	tag1[t]=!tag1[t];
	swap(son[t][0],son[t][1]);
}
inline void add(int v,int x)
{
	key[v]+=x,tmax[v]+=x,tag2[v]+=x;
}
inline void pushdown(int v)
{
	int x=son[v][0],y=son[v][1];
	if (tag1[v])
	{
		rev(x),rev(y);
		tag1[v]=false;
	}
	if (tag2[v]!=0)
	{
		add(x,tag2[v]),add(y,tag2[v]);
		tag2[v]=0;
	}
}
inline void update(int v)
{
	int x=son[v][0],y=son[v][1];
	size[v]=size[x]+size[y]+1;
	tmax[v]=key[v];
	if (x&amp;&amp;tmax[x]&gt;tmax[v]) tmax[v]=tmax[x];
	if (y&amp;&amp;tmax[y]&gt;tmax[v]) tmax[v]=tmax[y];
}
inline void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (fa[y])
	{
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	}
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
inline void splay(int t,int f)
{
	while (fa[t]!=f)
	{
		int y=fa[t];
		if (fa[y]==f)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
	if (!f) root=t;
}
inline int find(int K)
{
	for (int t=root;t;)
	{
		pushdown(t);
		int tmp=size[son[t][0]];
		if (K==tmp+1) return t;
		if (K&lt;=tmp) t=son[t][0];
		else K-=(tmp+1),t=son[t][1];
	}
	return -1;
}
int build(int l,int r)
{
	int mid=(l+r)&gt;&gt;1;
	int v=mid;
	key[v]=tmax[v]=0;
	size[v]=1;
	if (l&lt;mid) son[v][0]=build(l,mid-1),fa[son[v][0]]=v;
	if (r&gt;mid) son[v][1]=build(mid+1,r),fa[son[v][1]]=v;
	update(v);
	return v;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	root=build(1,n+2);
	int i,x,y,z;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		if (x==1)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			x++,y++;
			x=find(x-1),splay(x,0);
			y=find(y+1),splay(y,x);
			x=son[y][0];
			add(x,z);
			splay(x,0);
		}
		else if (x==2)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x++,y++;
			x=find(x-1),splay(x,0);
			y=find(y+1),splay(y,x);
			x=son[y][0];
			rev(x);
			splay(x,0);
		}
		else
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x++,y++;
			x=find(x-1),splay(x,0);
			y=find(y+1),splay(y,x);
			x=son[y][0];
			printf(&quot;%d\n&quot;,tmax[x]);
		}
	}
	return 0;
}<pre><h2>Problem1251</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=50111;
int fa[NN],son[NN][2],key[NN],size[NN],tmax[NN],tag2[NN];
int n,m,root;
bool tag1[NN];
inline void rev(int t)
{
	tag1[t]=!tag1[t];
	swap(son[t][0],son[t][1]);
}
inline void add(int v,int x)
{
	key[v]+=x,tmax[v]+=x,tag2[v]+=x;
}
inline void pushdown(int v)
{
	int x=son[v][0],y=son[v][1];
	if (tag1[v])
	{
		rev(x),rev(y);
		tag1[v]=false;
	}
	if (tag2[v]!=0)
	{
		add(x,tag2[v]),add(y,tag2[v]);
		tag2[v]=0;
	}
}
inline void update(int v)
{
	int x=son[v][0],y=son[v][1];
	size[v]=size[x]+size[y]+1;
	tmax[v]=key[v];
	if (x&amp;&amp;tmax[x]&gt;tmax[v]) tmax[v]=tmax[x];
	if (y&amp;&amp;tmax[y]&gt;tmax[v]) tmax[v]=tmax[y];
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (fa[y])
	{
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	}
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t,int f)
{
	while (fa[t]!=f)
	{
		int y=fa[t];
		if (fa[y]==f)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
	if (!f) root=t;
}
int find(int K)
{
	for (int t=root;t;)
	{
		pushdown(t);
		int tmp=size[son[t][0]];
		if (K==tmp+1) return t;
		if (K&lt;=tmp) t=son[t][0];
		else K-=(tmp+1),t=son[t][1];
	}
	return -1;
}
int build(int l,int r)
{
	int mid=(l+r)&gt;&gt;1;
	int v=mid;
	key[v]=tmax[v]=0;
	size[v]=1;
	if (l&lt;mid) son[v][0]=build(l,mid-1),fa[son[v][0]]=v;
	if (r&gt;mid) son[v][1]=build(mid+1,r),fa[son[v][1]]=v;
	update(v);
	return v;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	root=build(1,n+2);
	int i,x,y,z;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		if (x==1)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			x++,y++;
			x=find(x-1),splay(x,0);
			y=find(y+1),splay(y,x);
			x=son[y][0];
			add(x,z);
			splay(x,0);
		}
		else if (x==2)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x++,y++;
			x=find(x-1),splay(x,0);
			y=find(y+1),splay(y,x);
			x=son[y][0];
			rev(x);
			splay(x,0);
		}
		else
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x++,y++;
			x=find(x-1),splay(x,0);
			y=find(y+1),splay(y,x);
			x=son[y][0];
			printf(&quot;%d\n&quot;,tmax[x]);
		}
	}
	return 0;
}<pre><h2>Problem1251</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
const int NN=101111;
int fa[NN],son[NN][2],size[NN],key[NN],tag2[NN],tmax[NN];
int n,m,root,TTT;
bool tag[NN];
inline void rev(int t)
{
    tag[t]=!tag[t];
    swap(son[t][0],son[t][1]);
}
inline void add(int v,int x)
{
    key[v]+=x,tmax[v]+=x,tag2[v]+=x;
}
inline void pushdown(int v)
{
    int x=son[v][0],y=son[v][1];
    if (tag[v])
    {
        rev(x),rev(y);
        tag[v]=false;
    }
    if (tag2[v]!=0)
    {
        add(x,tag2[v]),add(y,tag2[v]);
        tag2[v]=0;
    }
}
inline void update(int v)
{
    int x=son[v][0],y=son[v][1];
    size[v]=size[x]+size[y]+1;
    tmax[v]=key[v];
    if (x&amp;&amp;tmax[x]&gt;tmax[v]) tmax[v]=tmax[x];
    if (y&amp;&amp;tmax[y]&gt;tmax[v]) tmax[v]=tmax[y];
}
inline void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (fa[y])
	{
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	}
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
	if (ff==0) root=t;
}
int find(int K)
{
	int t=root;
	while (t)
	{
		pushdown(t);
		int tmp=size[son[t][0]];
		if (K&lt;=tmp) t=son[t][0];
		else if (K==tmp+1) return t;
		else K-=tmp+1,t=son[t][1];
	}
	return -1;
}
int build(int l,int r)
{
	int v=++TTT,mid=(l+r)&gt;&gt;1;
	if (l&lt;mid) son[v][0]=build(l,mid-1),fa[son[v][0]]=v;
	if (mid&lt;r) son[v][1]=build(mid+1,r),fa[son[v][1]]=v;
	update(v);
	return v;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	root=build(1,n+2);
	tmax[0]=-inf;
	int i,x,y,z;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		if (x==1)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			x=find(x),y=find(y+2);
			splay(x,0),splay(y,x);
			x=son[y][0];
			add(x,z);
			splay(x,0);
		}
		else if (x==2)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x=find(x),y=find(y+2);
			splay(x,0),splay(y,x);
			x=son[y][0];
			rev(x);
			splay(x,0);
		}
		else
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x=find(x),y=find(y+2);
			splay(x,0),splay(y,x);
			printf(&quot;%d\n&quot;,tmax[son[y][0]]);
		}
	}
	return 0;
}<pre><h2>Problem1251</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
const int NN=101111;
int fa[NN],son[NN][2],size[NN],key[NN],tag2[NN],tmax[NN];
int n,m,root,TTT;
bool tag[NN];
inline void rev(int t)
{
	tag[t]=!tag[t];
	swap(son[t][0],son[t][1]);
}
inline void add(int t,int x)
{
	tag2[t]+=x;
	tmax[t]+=x;
	key[t]+=x;
}
inline void pushdown(int t)
{
	int x=son[t][0],y=son[t][1];
	if (tag[t])
	{
		rev(x),rev(y);
		tag[t]=false;
	}
	if (tag2[t])
	{
		add(x,tag2[t]),add(y,tag2[t]);
		tag2[t]=0;
	}
}
inline void update(int v)
{
    int x=son[v][0],y=son[v][1];
    size[v]=size[x]+size[y]+1;
    tmax[v]=key[v];
    if (x&amp;&amp;tmax[x]&gt;tmax[v]) tmax[v]=tmax[x];
    if (y&amp;&amp;tmax[y]&gt;tmax[v]) tmax[v]=tmax[y];
}
inline void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (fa[y])
	{
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	}
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
	if (ff==0) root=t;
}
int find(int K)
{
	int t=root;
	while (t)
	{
		pushdown(t);
		int tmp=size[son[t][0]];
		if (K&lt;=tmp) t=son[t][0];
		else if (K==tmp+1) return t;
		else K-=tmp+1,t=son[t][1];
	}
	return -1;
}
int build(int l,int r)
{
	int v=++TTT,mid=(l+r)&gt;&gt;1;
	if (l&lt;mid) son[v][0]=build(l,mid-1),fa[son[v][0]]=v;
	if (mid&lt;r) son[v][1]=build(mid+1,r),fa[son[v][1]]=v;
	update(v);
	return v;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	root=build(1,n+2);
	tmax[0]=-inf;
	int i,x,y,z;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		if (x==1)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			x=find(x),y=find(y+2);
			splay(x,0),splay(y,x);
			x=son[y][0];
			add(x,z);
			splay(x,0);
		}
		else if (x==2)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x=find(x),y=find(y+2);
			splay(x,0),splay(y,x);
			x=son[y][0];
			rev(x);
			splay(x,0);
		}
		else
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x=find(x),y=find(y+2);
			splay(x,0),splay(y,x);
			printf(&quot;%d\n&quot;,tmax[son[y][0]]);
		}
	}
	return 0;
}<pre><h2>Problem1251</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
const int NN=51111;
int fa[NN],son[NN][2],size[NN],key[NN],tag2[NN],tmax[NN];
int n,m,root,TTT;
bool tag[NN];
inline void rev(int t)
{
    tag[t]=!tag[t];
    swap(son[t][0],son[t][1]);
}
inline void add(int t,int x)
{
    tag2[t]+=x;
    tmax[t]+=x;
    key[t]+=x;
}
inline void pushdown(int t)
{
    int x=son[t][0],y=son[t][1];
    if (tag[t])
    {
        rev(x),rev(y);
        tag[t]=false;
    }
    if (tag2[t])
    {
        add(x,tag2[t]),add(y,tag2[t]);
        tag2[t]=0;
    }
}
inline void update(int v)
{
    int x=son[v][0],y=son[v][1];
    size[v]=size[x]+size[y]+1;
    tmax[v]=key[v];
    if (x&amp;&amp;tmax[x]&gt;tmax[v]) tmax[v]=tmax[x];
    if (y&amp;&amp;tmax[y]&gt;tmax[v]) tmax[v]=tmax[y];
}
inline void rotate(int t,int p)
{
    int y=fa[t];
    pushdown(y),pushdown(t);
    if (fa[y])
    {
        if (y==son[fa[y]][0]) son[fa[y]][0]=t;
        else son[fa[y]][1]=t;
    }
    fa[t]=fa[y];
    son[y][p^1]=son[t][p];
    if (son[t][p]) fa[son[t][p]]=y;
    son[t][p]=y;
    fa[y]=t;
    update(y),update(t);
}
void splay(int t,int ff)
{
    while (fa[t]!=ff)
    {
        int y=fa[t];
        if (fa[y]==ff)
            if (t==son[y][0]) rotate(t,1);
            else rotate(t,0);
        else
            if (y==son[fa[y]][0])
                if (t==son[y][0]) rotate(y,1),rotate(t,1);
                else rotate(t,0),rotate(t,1);
            else
                if (t==son[y][1]) rotate(y,0),rotate(t,0);
                else rotate(t,1),rotate(t,0);
    }
    update(t);
    if (ff==0) root=t;
}
int find(int K)
{
    int t=root;
    while (t)
    {
        pushdown(t);
        int tmp=size[son[t][0]];
        if (K&lt;=tmp) t=son[t][0];
        else if (K==tmp+1) return t;
        else K-=tmp+1,t=son[t][1];
    }
    return -1;
}
int build(int l,int r)
{
    int v=++TTT,mid=(l+r)&gt;&gt;1;
    if (l&lt;mid) son[v][0]=build(l,mid-1),fa[son[v][0]]=v;
    if (mid&lt;r) son[v][1]=build(mid+1,r),fa[son[v][1]]=v;
    update(v);
    return v;
}
int main()
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    root=build(1,n+2);
    tmax[0]=-inf;
    int i,x,y,z;
    for (i=1;i&lt;=m;i++)
    {
        scanf(&quot;%d&quot;,&amp;x);
        if (x==1)
        {
            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
            x=find(x),y=find(y+2);
            splay(x,0),splay(y,x);
            x=son[y][0];
            add(x,z);
            splay(x,0);
        }
        else if (x==2)
        {
            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
            x=find(x),y=find(y+2);
            splay(x,0),splay(y,x);
            x=son[y][0];
            rev(x);
            splay(x,0);
        }
        else
        {
            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
            x=find(x),y=find(y+2);
            splay(x,0),splay(y,x);
            printf(&quot;%d\n&quot;,tmax[son[y][0]]);
        }
    }
    return 0;
}<pre><h2>Problem1251</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
const int NN=100111;
int n,m,TTT,root;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
	if (f) x=-x;
}
struct splaynode
{
	int key,sz,fa,s[2],tag2,tmax;
	bool tag;
	inline void rev()
	{
		tag=!tag;
		swap(s[0],s[1]);
	}
	inline void add(int x)
	{
		tag2+=x;
		tmax+=x;
		key+=x;
	}
} T[NN];
inline void pushdown(int t)
{
	int x=T[t].s[0],y=T[t].s[1];
	if (T[t].tag)
	{
		T[x].rev(),T[y].rev();
		T[t].tag=false;
	}
	if (T[t].tag2)
	{
		if (x) T[x].add(T[t].tag2);
		if (y) T[y].add(T[t].tag2);
		T[t].tag2=0;
	}
}
inline void update(int t)
{
	int x=T[t].s[0],y=T[t].s[1];
	T[t].tmax=max(T[t].key,max(T[x].tmax,T[y].tmax));
	T[t].sz=T[x].sz+T[y].sz+1;
}
inline void rotate(int t,int p)
{
	int y=T[t].fa;
	pushdown(y),pushdown(t);
	if (T[y].fa)
	{
		if (y==T[T[y].fa].s[0]) T[T[y].fa].s[0]=t;
		else T[T[y].fa].s[1]=t;
	}
	T[t].fa=T[y].fa;
	T[y].s[p^1]=T[t].s[p];
	if (T[t].s[p]) T[T[t].s[p]].fa=y;
	T[t].s[p]=y;
	T[y].fa=t;
	update(y),update(t);
}
void splay(int t,int ff)
{
	while (T[t].fa!=ff)
	{
		int y=T[t].fa;
		if (T[y].fa==ff)
			if (t==T[y].s[0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==T[T[y].fa].s[0])
				if (t==T[y].s[0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==T[y].s[1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
	if (ff==0) root=t;
}
int find(int K)
{
	int t=root;
	while (t)
	{
		pushdown(t);
		int tmp=T[T[t].s[0]].sz;
		if (K&lt;=tmp) t=T[t].s[0];
		else if (K==tmp+1) return t;
		else K-=tmp+1,t=T[t].s[1];
	}
	return -1;
}
int build(int l,int r)
{
	int v=++TTT,mid=(l+r)&gt;&gt;1;
	if (l&lt;mid)
		T[v].s[0]=build(l,mid-1),T[T[v].s[0]].fa=v;
	if (r&gt;mid)
		T[v].s[1]=build(mid+1,r),T[T[v].s[1]].fa=v;
	update(v);
	return v;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	root=build(1,n+2);
	T[0].tmax=-inf;
	for (;m;m--)
	{
		int kind,x,y,z;
		read(kind),read(x),read(y);
		if (kind==1)
		{
			read(z);
			x=find(x),y=find(y+2);
			splay(x,0),splay(y,x);
			x=T[y].s[0];
			T[x].add(z);
			splay(x,0);
		}
		else if (kind==2)
		{
			x=find(x),y=find(y+2);
			splay(x,0),splay(y,x);
			x=T[y].s[0];
			T[x].rev();
			splay(x,0);
		}
		else
		{
			x=find(x),y=find(y+2);
			splay(x,0),splay(y,x);
			x=T[y].s[0];
			printf(&quot;%d\n&quot;,T[x].tmax);
		}
	}
	return 0;
}<pre><h2>Problem1251</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
const int NN=50111;
int n,m,TTT,root;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
	if (f) x=-x;
}
struct splaynode
{
	int key,sz,fa,s[2],tag2,tmax;
	bool tag;
	inline void rev()
	{
		tag=!tag;
		swap(s[0],s[1]);
	}
	inline void add(int x)
	{
		tag2+=x;
		tmax+=x;
		key+=x;
	}
} T[NN];
inline void pushdown(int t)
{
	int x=T[t].s[0],y=T[t].s[1];
	if (T[t].tag)
	{
		T[x].rev(),T[y].rev();
		T[t].tag=false;
	}
	if (T[t].tag2)
	{
		if (x) T[x].add(T[t].tag2);
		if (y) T[y].add(T[t].tag2);
		T[t].tag2=0;
	}
}
inline void update(int t)
{
	int x=T[t].s[0],y=T[t].s[1];
	T[t].tmax=max(T[t].key,max(T[x].tmax,T[y].tmax));
	T[t].sz=T[x].sz+T[y].sz+1;
}
inline void rotate(int t,int p)
{
	int y=T[t].fa;
	pushdown(y),pushdown(t);
	if (T[y].fa)
	{
		if (y==T[T[y].fa].s[0]) T[T[y].fa].s[0]=t;
		else T[T[y].fa].s[1]=t;
	}
	T[t].fa=T[y].fa;
	T[y].s[p^1]=T[t].s[p];
	if (T[t].s[p]) T[T[t].s[p]].fa=y;
	T[t].s[p]=y;
	T[y].fa=t;
	update(y),update(t);
}
void splay(int t,int ff)
{
	while (T[t].fa!=ff)
	{
		int y=T[t].fa;
		if (T[y].fa==ff)
			if (t==T[y].s[0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==T[T[y].fa].s[0])
				if (t==T[y].s[0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==T[y].s[1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
	if (ff==0) root=t;
}
int find(int K)
{
	int t=root;
	while (t)
	{
		pushdown(t);
		int tmp=T[T[t].s[0]].sz;
		if (K&lt;=tmp) t=T[t].s[0];
		else if (K==tmp+1) return t;
		else K-=tmp+1,t=T[t].s[1];
	}
	return -1;
}
int build(int l,int r)
{
	int v=++TTT,mid=(l+r)&gt;&gt;1;
	if (l&lt;mid)
		T[v].s[0]=build(l,mid-1),T[T[v].s[0]].fa=v;
	if (r&gt;mid)
		T[v].s[1]=build(mid+1,r),T[T[v].s[1]].fa=v;
	update(v);
	return v;
}
int main()
{
	read(n),read(m);
	root=build(1,n+2);
	T[0].tmax=-inf;
	for (;m;m--)
	{
		int kind,x,y,z;
		read(kind),read(x),read(y);
		if (kind==1)
		{
			read(z);
			x=find(x),y=find(y+2);
			splay(x,0),splay(y,x);
			x=T[y].s[0];
			T[x].add(z);
			splay(x,0);
		}
		else if (kind==2)
		{
			x=find(x),y=find(y+2);
			splay(x,0),splay(y,x);
			x=T[y].s[0];
			T[x].rev();
			splay(x,0);
		}
		else
		{
			x=find(x),y=find(y+2);
			splay(x,0),splay(y,x);
			x=T[y].s[0];
			printf(&quot;%d\n&quot;,T[x].tmax);
		}
	}
	return 0;
}<pre><h2>Problem1264</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=101111;
int a[NN],b[NN],pos[NN][6],num[NN],c[NN],f[NN];
int n;
inline void change(int i,int x)
{
	for (;i&lt;=n*5;i+=i&amp;-i)
		if (x&gt;c[i]) c[i]=x;
}
inline int getmax(int i)
{
	int res=0;
	for (;i;i-=i&amp;-i)
		if (c[i]&gt;res) res=c[i];
	return res;
}
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j;
	for (i=1;i&lt;=5*n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	for (i=1;i&lt;=5*n;i++)
	{
		scanf(&quot;%d&quot;,&amp;b[i]);
		pos[b[i]][++num[b[i]]]=i;
	}
	for (i=1;i&lt;=5*n;i++)
	{
		//printf(&quot;\n-----------------------------------------------------------------------\n&quot;);
		for (j=5;j;j--)
		{
			int t=pos[a[i]][j];
			//printf(&quot;%d\n&quot;,t);
			f[t]=getmax(t-1)+1;
			change(t,f[t]);
		}
		//for (j=1;j&lt;=5*n;j++) printf(&quot;%d &quot;,f[j]);ln;
	}
	int ans=0;
	for (i=1;i&lt;=5*n;i++)
		if (f[i]&gt;ans) ans=f[i];
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1269</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 2501111
#define ln printf(&quot;\n&quot;)
int fa[NN],son[NN][2],b[NN],key[NN],size[NN];
int n,root,TTT;
bool tag[NN];
void rev(int v)
{
	tag[v]=!tag[v];
	swap(son[v][0],son[v][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	rev(son[v][0]);
	rev(son[v][1]);
	tag[v]=false;
}
void update(int v)
{
	size[v]=size[son[v][0]]+size[son[v][1]]+1;
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (!ff) root=t;
}
int find(int t,int K)
{
	//printf(&quot;find %d %d\n&quot;,t,K);
	while (t)
	{
		pushdown(t);
		int tmp=size[son[t][0]];
		//printf(&quot;tmp=%d\n&quot;,tmp);
		if (K==tmp+1) return t;
		//printf(&quot;son[t][0]=%d\n&quot;,son[t][0]);
		if (K&lt;=tmp) t=son[t][0];
		else K-=(tmp+1),t=son[t][1];
		//printf(&quot;%d %d\n&quot;,t,K);
	}
	return -1;
}
int build(int l,int r)
{
	int v=++TTT;
	int mid=(l+r)&gt;&gt;1;
	key[v]=b[mid],tag[v]=0;
	if (l&lt;mid) son[v][0]=build(l,mid-1),fa[son[v][0]]=v;
	if (r&gt;mid) son[v][1]=build(mid+1,r),fa[son[v][1]]=v;
	update(v);
	return v;
}
void debug(int t)
{
	if (t==0) return;
	pushdown(t);
	debug(son[t][0]);
	printf(&quot;%c&quot;,key[t]);
	debug(son[t][1]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d\n&quot;,&amp;n);
	int now=1;
	fa[1]=2,son[2][0]=1;
	TTT=2;
	size[2]=2,size[1]=1;
	key[1]=key[2]='!';
	root=2;
	while (n--)
	{
		//printf(&quot;\n------------------------------------\n&quot;);
		//debug(root),ln;printf(&quot;now=%d\n&quot;,now);
		char ch=getchar();
		while (ch&lt;32||ch&gt;126) ch=getchar();
		//printf(&quot;ch=%c\n&quot;,ch);
		int i,x,y,t,len;
		if (ch=='M')
		{
			for (i=1;i&lt;=3;i++) ch=getchar();
			scanf(&quot;%d\n&quot;,&amp;x);
			now=x+1;
		}
		else if (ch=='I')
		{
			for (i=1;i&lt;=5;i++) ch=getchar();
			scanf(&quot;%d&quot;,&amp;len);
			for (i=1;i&lt;=len;i++)
			{
				ch=' '-1;
				while (ch&lt;32||ch&gt;126) ch=getchar();//,printf(&quot;ch=%c\n&quot;,ch);;
				b[i]=ch;
				//printf(&quot;%c&quot;,b[i]);
			}
			//ln;
			scanf(&quot;\n&quot;);
			t=build(1,len);
			//printf(&quot;build end.\n&quot;);
			x=find(root,now);
			//printf(&quot;x=%d\n&quot;,x);
			splay(x,0);
			//printf(&quot;splay end.\n&quot;);printf(&quot;%d\n&quot;,size[2]);
			y=find(root,now+1);
			//printf(&quot;y=%d\n&quot;,y);
			splay(y,x);
			//printf(&quot;x=%d y=%d\n&quot;,x,y);
			fa[t]=y;
			son[y][0]=t;
			splay(t,0);
		}
		else if (ch=='D')
		{
			for (i=1;i&lt;=5;i++) ch=getchar();
			scanf(&quot;%d\n&quot;,&amp;len);
			x=find(root,now);
			//printf(&quot;key[x]=%c\n&quot;,key[x]);
			splay(x,0);
			y=find(root,now+len+1);
			//printf(&quot;key[y]=%c\n&quot;,key[y]);
			splay(y,x);
			x=son[y][0];
			fa[x]=son[y][0]=0;
			splay(y,0);
		}
		else if (ch=='R')
		{
			for (i=1;i&lt;=5;i++) ch=getchar();
			scanf(&quot;%d\n&quot;,&amp;len);
			x=find(root,now);
			splay(x,0);
			y=find(root,now+len+1);
			splay(y,x);
			x=son[y][0];
			rev(x);
			splay(x,0);
		}
		else if (ch=='G')
		{
			for (i=1;i&lt;=3;i++) ch=getchar();
			scanf(&quot;\n&quot;);
			len=1;
			//scanf(&quot;%d\n&quot;,&amp;len);
			x=find(root,now);
			splay(x,0);
			y=find(root,now+len+1);
			splay(y,x);
			x=son[y][0];
			debug(x);ln;
			//printf(&quot;%c\n&quot;,key[x]);
		}
		else if (ch=='P')
		{
			for (i=1;i&lt;=3;i++) ch=getchar();
			scanf(&quot;\n&quot;);
			now--;
		}
		else
		{
			for (i=1;i&lt;=3;i++) ch=getchar();
			scanf(&quot;\n&quot;);
			now++;
		}
	}
	return 0;
}
<pre><h2>Problem1269</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 2501111
#define ln printf(&quot;\n&quot;)
int fa[NN],son[NN][2],b[NN],key[NN],size[NN];
int n,root,TTT;
bool tag[NN];
void rev(int v)
{
	tag[v]=!tag[v];
	swap(son[v][0],son[v][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	rev(son[v][0]);
	rev(son[v][1]);
	tag[v]=false;
}
void update(int v)
{
	size[v]=size[son[v][0]]+size[son[v][1]]+1;
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (!ff) root=t;
}
int find(int t,int K)
{
	//printf(&quot;find %d %d\n&quot;,t,K);
	while (t)
	{
		pushdown(t);
		int tmp=size[son[t][0]];
		//printf(&quot;tmp=%d\n&quot;,tmp);
		if (K==tmp+1) return t;
		//printf(&quot;son[t][0]=%d\n&quot;,son[t][0]);
		if (K&lt;=tmp) t=son[t][0];
		else K-=(tmp+1),t=son[t][1];
		//printf(&quot;%d %d\n&quot;,t,K);
	}
	return -1;
}
int build(int l,int r)
{
	int v=++TTT;
	int mid=(l+r)&gt;&gt;1;
	key[v]=b[mid],tag[v]=0;
	if (l&lt;mid) son[v][0]=build(l,mid-1),fa[son[v][0]]=v;
	if (r&gt;mid) son[v][1]=build(mid+1,r),fa[son[v][1]]=v;
	update(v);
	return v;
}
void debug(int t)
{
	if (t==0) return;
	pushdown(t);
	debug(son[t][0]);
	printf(&quot;%c&quot;,key[t]);
	debug(son[t][1]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d\n&quot;,&amp;n);
	int now=1;
	fa[1]=2,son[2][0]=1;
	TTT=2;
	size[2]=2,size[1]=1;
	key[1]=key[2]='!';
	root=2;
	while (n--)
	{
		//printf(&quot;\n------------------------------------\n&quot;);
		//debug(root),ln;printf(&quot;now=%d\n&quot;,now);
		char ch=getchar();
		while (ch&lt;32||ch&gt;126) ch=getchar();
		//printf(&quot;ch=%c\n&quot;,ch);
		int i,x,y,t,len;
		if (ch=='M')
		{
			for (i=1;i&lt;=3;i++) ch=getchar();
			scanf(&quot;%d\n&quot;,&amp;x);
			now=x+1;
		}
		else if (ch=='I')
		{
			for (i=1;i&lt;=5;i++) ch=getchar();
			scanf(&quot;%d&quot;,&amp;len);
			for (i=1;i&lt;=len;i++)
			{
				ch=' '-1;
				while (ch&lt;32||ch&gt;126) ch=getchar();//,printf(&quot;ch=%c\n&quot;,ch);;
				b[i]=ch;
				//printf(&quot;%c&quot;,b[i]);
			}
			//ln;
			scanf(&quot;\n&quot;);
			t=build(1,len);
			//printf(&quot;build end.\n&quot;);
			x=find(root,now);
			//printf(&quot;x=%d\n&quot;,x);
			splay(x,0);
			//printf(&quot;splay end.\n&quot;);printf(&quot;%d\n&quot;,size[2]);
			y=find(root,now+1);
			//printf(&quot;y=%d\n&quot;,y);
			splay(y,x);
			//printf(&quot;x=%d y=%d\n&quot;,x,y);
			fa[t]=y;
			son[y][0]=t;
			splay(t,0);
		}
		else if (ch=='D')
		{
			for (i=1;i&lt;=5;i++) ch=getchar();
			scanf(&quot;%d\n&quot;,&amp;len);
			x=find(root,now);
			//printf(&quot;key[x]=%c\n&quot;,key[x]);
			splay(x,0);
			y=find(root,now+len+1);
			//printf(&quot;key[y]=%c\n&quot;,key[y]);
			splay(y,x);
			x=son[y][0];
			fa[x]=son[y][0]=0;
			splay(y,0);
		}
		else if (ch=='R')
		{
			for (i=1;i&lt;=5;i++) ch=getchar();
			scanf(&quot;%d\n&quot;,&amp;len);
			x=find(root,now);
			splay(x,0);
			y=find(root,now+len+1);
			splay(y,x);
			x=son[y][0];
			rev(x);
			splay(x,0);
		}
		else if (ch=='G')
		{
			for (i=1;i&lt;=3;i++) ch=getchar();
			scanf(&quot;\n&quot;);
			x=find(root,now+1);
			printf(&quot;%c\n&quot;,key[x]);
		}
		else if (ch=='P')
		{
			for (i=1;i&lt;=3;i++) ch=getchar();
			scanf(&quot;\n&quot;);
			now--;
		}
		else
		{
			for (i=1;i&lt;=3;i++) ch=getchar();
			scanf(&quot;\n&quot;);
			now++;
		}
	}
	return 0;
}
<pre><h2>Problem1283</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
const int NN=1111;
int o[NN],aa[100000][4],pre[NN],w[NN];
int n,m,K,S,T,tot=1;
inline void addedge(int p,int q,int v,int c)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][3]=c;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline void add(int p,int q,int v,int c)
{
	//printf(&quot;add %d %d %d %d\n&quot;,p,q,v,c);
	addedge(p,q,v,c);
	addedge(q,p,0,-c);
}
bool spfa()
{
	static int dist[NN],que[1000000];
	static bool dl[NN];
	memset(dist,60,sizeof(dist));
	memset(dl,0,sizeof(dl));
	dist[S]=0;
	int head=0,tail=1;
	que[1]=S;
	dl[S]=true;
	while (head&lt;tail)
	{
		int x=que[++head];
		dl[x]=false;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;dist[y]&gt;dist[x]+aa[p][3])
			{
				dist[y]=dist[x]+aa[p][3];
				pre[y]=p;
				if (!dl[y])
					dl[y]=true,que[++tail]=y;
			}
		}
	}
	return dist[T]&lt;dist[0];
}
int calc()
{
	int flow=inf,p,res=0;
	for (p=pre[T];p;p=pre[aa[p^1][1]])
		flow=min(flow,aa[p][2]);
	for (p=pre[T];p;p=pre[aa[p^1][1]])
	{
		res+=flow*aa[p][3];
		aa[p][2]-=flow,aa[p^1][2]+=flow;
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;K);
	int i;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;w[i]);
	S=n+1,T=n+2;
	add(S,1,K,0);
	add(n,T,K,0);
	for (i=1;i&lt;n;i++) add(i,i+1,inf,0);
	for (i=1;i&lt;=n;i++)
	{
		int t=(i+m&gt;n)?T:i+m;
		add(i,t,1,-w[i]);
	}
	int ans=0;
	while (spfa()) ans-=calc();
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1296</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=55;
int f[NN][NN],g[NN][2511],dp[NN][2511];
int n,m,K;
void work()
{
	static int sum[NN];
	sum[0]=0;
	int i,j,k;
	for (i=1;i&lt;=m;i++)
	{
		char ch=getchar();
		while (ch!='0'&amp;&amp;ch!='1') ch=getchar();
		sum[i]=sum[i-1]+(ch=='1');
	}
	memset(f,60,sizeof(f));
	f[0][0]=0;
	for (i=1;i&lt;=m;i++)
		for (j=0;j&lt;=K;j++)
			if (j==0) f[i][j]=i;
			else
			{
				f[i][j]=f[i][j-1];
				for (k=0;k&lt;i;k++)
				{
					int t1=sum[i]-sum[k],t2=i-k-t1;
					f[i][j]=min(f[i][j],f[k][j-1]+min(t1,t2));
				}
			}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;K);
	int i,j,k;
	for (i=1;i&lt;=n;i++)
	{
		work();
		for (j=0;j&lt;=K;j++) g[i][j]=f[m][j];
	}
	//for(i=1;i&lt;=n;i++){for(j=0;j&lt;=K;j++)printf(&quot;%d &quot;,g[i][j]);ln;}ln;
	memset(dp,60,sizeof(dp));
	dp[0][0]=0;
	for (i=1;i&lt;=n;i++)
		for (j=0;j&lt;=K;j++)
			if (j==0) dp[i][j]=dp[i-1][0]+g[i][0];
			else
			{
				dp[i][j]=dp[i][j-1];
				for (k=0;k&lt;=j;k++)
					dp[i][j]=min(dp[i][j],dp[i-1][k]+g[i][j-k]);
			}
	printf(&quot;%d\n&quot;,n*m-dp[n][K]);
	return 0;
}<pre><h2>Problem1297</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mo 2009
int n,N,T;
struct matrix
{
	int qq[105][105];
	matrix() {memset(qq,0,sizeof(qq));}
	int * operator [](int x) {return qq[x];}
	friend matrix operator *(matrix a,matrix b)
	{
		matrix c;
		for (int k=1;k&lt;=N;k++)
			for (int i=1;i&lt;=N;i++)
				for (int j=1;j&lt;=N;j++)
					(c[i][j]+=a[i][k]*b[k][j])%=mo;
		return c;
	}
	friend matrix operator ^(matrix a,int b)
	{
		matrix res;
		for (int i=1;i&lt;=N;i++) res[i][i]=1;
		for (;b;b&gt;&gt;=1,a=a*a)
			if (b&amp;1) res=res*a;
		return res;
	}
} a;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;T);
	int i,j;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;9;j++)
			a[i+(j-1)*n][i+j*n]=1;
	for (i=1;i&lt;=n;i++) for (j=1;j&lt;=n;j++)
	{
		char ch=getchar();
		while (ch&lt;'0'||ch&gt;'9') ch=getchar();
		if (ch!='0') a[i+(ch-'0'-1)*n][j]=1;
	}
	N=n*9;
	a=a^T;
	printf(&quot;%d\n&quot;,a[1][n]);
	return 0;
}<pre><h2>Problem1299</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int a[17],tes,n,num;
bool dfs(int t,int now)
{
	if (t==n+1)
	{
		if (num&gt;0&amp;&amp;now==0) return true;
		return false;
	}
	if (dfs(t+1,now)) return true;
	num++;
	if (dfs(t+1,now^a[t])) return true;
	num--;
	return false;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	while (~scanf(&quot;%d&quot;,&amp;n))
	{
		for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
		num=0;
		if (dfs(1,0)) printf(&quot;NO\n&quot;);
		else printf(&quot;YES\n&quot;);
	}
	return 0;
}
<pre><h2>Problem1305</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 999999999
#define mii(a,b) (a&lt;b?a:b)
#define ln printf(&quot;\n&quot;)
int q[1111],deep[1111],o[1111],aa[1000000][3];
int n,K,tot=1,S,T;
bool like[55][55];
bool bfs()
{
	int head=0,tail=1,x,p,y;
	q[1]=S;
	memset(deep,0,sizeof(deep));
	deep[S]=1;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[T];
}
int dfs(int v,int ff)
{
	if (v==T) return ff;
	int res=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(aa[p][2],ff));
		if (tmp==0) deep[y]=inf;
		ff-=tmp;
		aa[p][2]-=tmp;
		aa[p^1][2]+=tmp;
		res+=tmp;
		if (ff==0) break;
	}
	return res;
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v)
{
	//printf(&quot;add  %d %d %d\n&quot;,p,q,v);
	addedge(p,q,v);
	addedge(q,p,0);
}
bool check(int x)
{
	//printf(&quot;\n-------------- checking %d -----------------------------\n&quot;,x);
	memset(o,0,sizeof(o));
	tot=1;
	S=n*4+1,T=n*4+2;
	for (int i=1;i&lt;=n;i++)
	{
		add(S,i,x),add(i,i+n,K);
		add(i+n*3,T,x),add(i+n*2,i+n*3,K);
		for (int j=1;j&lt;=n;j++)
			if (like[i][j]) add(i,j+n*3,1);
			else add(i+n,j+n*2,1);
	}
	int res=0;
	while (bfs()) res+=dfs(S,inf);
	//printf(&quot;-------------- res=%d.  The result is %s. -------------------------\n&quot;,res,res==n*x?&quot;true&quot;:&quot;false&quot;);
	return res==n*x;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;K);
	int i,j;
	for (i=1;i&lt;=n;i++,scanf(&quot;\n&quot;))
	{
		char ch;
		for (j=1;j&lt;=n;j++)
		{
			ch=getchar();
			if (ch=='Y') like[i][j]=true;else like[i][j]=false;
		}
	}
	int l=0,r=n,ans=0;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (check(mid)) ans=mid,l=mid+1;
		else r=mid-1;
	}
	//ln;ln;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1319</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define INF 0x3f3f3f3f3f3f3f3fll
using namespace std;
typedef pair&lt;long long,long long&gt; abcd;
long long p,k,a;
long long Quick_Power(long long x,long long y)
{
    long long re=1;
    while(y)
    {
        if(y&amp;1) (re*=x)%=p;
        (x*=x)%=p; y&gt;&gt;=1;
    }
    return re;
}
long long Get_Primitive_Root(long long p)
{
    static long long stack[100],top;
    long long i,j,temp=p-1;
    for(i=2;i*i&lt;=temp;i++)
        if(temp%i==0)
        {
            stack[++top]=i;
            while(temp%i==0)
                temp/=i;
        }
    if(i!=1) stack[++top]=i;
    for(i=1;i&lt;p;i++)
    {
        for(j=1;j&lt;=top;j++)
            if(Quick_Power(i,(p-1)/stack[j])==1)
                break;
        if(j==top+1)
            return i;
    }
    while(1) puts(&quot;&quot;);
}
namespace Hash_Set{
    struct List{
        long long hash,val;
        List *next;
        List(long long _,List *__):
            hash(_),val(INF),next(__) {}
    }*head[10001];
    long long&amp; Hash(long long x)
    {
        int pos=x%10001;
        List *temp=head[pos];
        for(temp=head[pos];temp;temp=temp-&gt;next)
            if(temp-&gt;hash==x)
                return temp-&gt;val;
        return (head[pos]=new List(x,head[pos]))-&gt;val;
    }
}
abcd EXGCD(long long x,long long y)
{
    if(!y) return abcd(1,0);
    abcd temp=EXGCD(y,x%y);
    return abcd(temp.second,temp.first-x/y*temp.second);
}
long long Baby_Step_Giant_Step(long long A,long long B)
{
    long long i,m=ceil(sqrt(p)),temp=1,D=1;
    for(i=0;i&lt;=m;i++,(temp*=A)%=p)
    {
        long long &amp;val=Hash_Set::Hash(temp);
        val=min(val,i);
        D=temp;
    }
    for(temp=1,i=0;i&lt;=m;i++,(temp*=D)%=p)
    {
        long long x=(EXGCD(temp,p).first%p+p)%p;
        long long &amp;val=Hash_Set::Hash(x*B%p);
        if(val!=INF) return i*m+val;
    }
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    long long i;
    cin&gt;&gt;p&gt;&gt;k&gt;&gt;a;
    long long g=Get_Primitive_Root(p);
    a=Baby_Step_Giant_Step(g,a);
    long long gcd=__gcd(k,p-1);
    if(a%gcd)
    {
        printf(&quot;0\n&quot;);
        return 0;
    }
    static long long stack[100100],top;
    long long temp=(p-1)/gcd;
    long long origin=(EXGCD(k,p-1).first%temp+temp)%temp;
    (origin*=a/gcd)%=temp;
    for(i=origin;i&lt;p-1;i+=temp)
        stack[++top]=Quick_Power(g,i);
    sort(stack+1,stack+top+1);
    cout&lt;&lt;top&lt;&lt;endl;
    for(i=1;i&lt;=top;i++)
        printf(&quot;%lld\n&quot;,stack[i]);
    return 0;
}<pre><h2>Problem1319</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
LL P,K,A;
inline LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (a%=c;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
LL yuangen(LL P)
{
	LL i,j;
	for (i=2;;i++)
	{
		bool flag=true;
		for (j=2;j*j&lt;=P-1;j++)
			if ((P-1)%j==0)
			{
				if (ksm(i,j,P)==1) {flag=false;break;}
				if (j*j!=P&amp;&amp;ksm(i,(P-1)/j,P)==1) {flag=false;break;}
			}
		if (flag) break;
	}
	return i;
}
struct HT
{
	#define mo 1000007
	int o[mo],aa0[1000000],tot;
	LL aa1[1000000],f[1000000];
	void insert(LL X,LL Y)
	{
		int t=X%mo;
		for (int p=o[t];p;p=aa0[p])
			if (aa1[p]==X)
			{
				if (Y&lt;f[p]) f[p]=Y;
				return;
			}
		tot++;aa1[tot]=X;aa0[tot]=o[t];
		o[t]=tot;f[tot]=Y;
	}
	LL find(LL X)
	{
		int t=X%mo;
		for (int p=o[t];p;p=aa0[p])
			if (aa1[p]==X) return f[p];
		return -1;
	}
} ht;
LL bsgs(LL A,LL B,LL P)
{
	static LL a[100000];
	LL blo=(int)sqrt(P-1)+1,i;
	ht.insert(a[0]=1,0);
	for (i=1;i&lt;blo;i++)
		ht.insert(a[i]=a[i-1]*A%P,i);
	LL now=1;
	for (i=0;i&lt;P;i+=blo)
	{
		if (now==0) return i;
		LL tmp=B*ksm(now,P-2,P)%P;
		LL t=ht.find(tmp);
		if (t!=-1) return i+t;
		now=now*a[blo-1]%P*A%P;
	}
	return -1;
}
LL extgcd(LL a,LL b,LL &amp;x,LL &amp;y)
{
	if (b==0)
	{
		x=1;y=0;
		return a;
	}
	LL tmp=extgcd(b,a%b,y,x);
	y-=a/b*x;
	return tmp;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld%lld%lld&quot;,&amp;P,&amp;K,&amp;A);
	A%=P;
	LL rt=yuangen(P);
	LL m=bsgs(rt,A,P);
	LL x,y,gcd=extgcd(K,P-1,x,y);
	if (m%gcd) {printf(&quot;0\n&quot;);return 0;}
	x*=m/gcd;
	LL tmp=(P-1)/gcd;
	x=(x%tmp+tmp)%tmp;
	static LL ans[1000000];
	int cnt=0;
	for (;x&lt;P;x+=tmp) ans[++cnt]=ksm(rt,x,P);
	sort(ans+1,ans+cnt+1);
	printf(&quot;%d\n&quot;,cnt);
	for (int i=1;i&lt;=cnt;i++) printf(&quot;%lld\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem1319</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;

#define HASH 100001

using namespace std;

typedef long long ll;
ll p,a,b,g,sta[10000];

ll POW(ll a,ll t,ll p)
{
	ll ret=1;
	while(t&gt;0){
		if(t&amp;1) ret=(ret*a)%p;
		a=(a*a)%p;
		t&gt;&gt;=1;
	}
	return ret;
}

ll EXGCD(ll a,ll b,ll &amp;x,ll &amp;y)
{
	if(b==0){
		x=1,y=0;
		return a;
	}
	ll d=EXGCD(b,a%b,x,y),t=x;
	x=y;y=t-a/b*y;
	return d;
}

ll findroot(ll p)
{
	ll tmp=p-1,i;
	for(i=2;i*i&lt;=tmp;i++){
		if(tmp%i==0){
			sta[++sta[0]]=i;
			while(tmp%i==0) tmp/=i;
		}
	}
	if(i!=1) sta[++sta[0]]=i;
	for(i=1;i&lt;p;i++){
		int j;
		for(j=1;j&lt;=sta[0];j++) if(POW(i,(p-1)/sta[j],p)==1) break;
		if(j==sta[0]+1) return i;
	}
	while(1);
}

namespace HASHSET{
	int B[HASH],tot;
	struct edge{
		int x,y;ll w;int last;
	}e[HASH];
	void add(int x,int y,ll w){
		e[++tot]=(edge){x,y,w,B[x]};
		B[x]=tot;
	}
}

ll BSGS(ll a,ll b,ll p)
{
	using namespace HASHSET;
	ll m=(ll)ceil(sqrt(p)),Am,j,D,i;
	for(i=0,Am=1;i&lt;m;i++,(Am*=a)%=p){
		for(j=B[Am%HASH];j;j=e[j].last){
			if(e[j].w==Am) break;
		}
		if(!j) add(Am%HASH,i,Am);
	}
	for(i=0,D=1;i&lt;=m;i++,(D*=Am)%=p){
		ll inv=POW(D,p-2,p)*b%p;
		for(j=B[inv%HASH];j;j=e[j].last){
			if(e[j].w==inv) return i*m+e[j].y;
		}
	}
	while(1);
}

int main()
{
	scanf(&quot;%lld%lld%lld&quot;,&amp;p,&amp;a,&amp;b);
	if(a==0)return puts(&quot;1&quot;),puts(&quot;0&quot;),0;
	g=findroot(p);
	b=BSGS(g,b,p);
	ll ans,y,tmp,mod;
	ll d=EXGCD(a,p-1,ans,y);
	mod=(p-1)/d;
	if(b%d) return puts(&quot;0&quot;),0;
	ans=(ans%mod+mod)%mod;
	(ans*=(b/d))%=mod;
	sta[0]=0;
	for(int i=ans;i&lt;p-1;i+=mod){
		sta[++sta[0]]=POW(g,i,p);
	}
	sort(sta+1,sta+sta[0]+1);
	printf(&quot;%lld\n&quot;,sta[0]);
	for(int i=1;i&lt;=sta[0];i++) printf(&quot;%lld\n&quot;,sta[i]);
	return 0;
}
<pre><h2>Problem1336</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
#define sqr(x) ((x)*(x))
#define ln printf(&quot;\n&quot;)
const DD pai=3.14159265358979,eps=1e-7;
const int NN=100111;
int n;
struct point
{
	DD x,y;
	point(DD _x=0,DD _y=0) {x=_x,y=_y;}
	point rotate(DD sita)
	{
		DD xx=x*cos(sita)-y*sin(sita);
		DD yy=y*cos(sita)+x*sin(sita);
		x=xx,y=yy;
		return *this;
	}
	inline void in() {scanf(&quot;%lf%lf&quot;,&amp;x,&amp;y);}
	inline void out() {printf(&quot;%.3f %.3f\n&quot;,x,y);}
	friend point operator +(const point &amp;a,const point &amp;b) {return point(a.x+b.x,a.y+b.y);}
	friend point operator -(const point &amp;a,const point &amp;b) {return point(a.x-b.x,a.y-b.y);}
	friend point operator *(const point &amp;a,DD t) {return point(a.x*t,a.y*t);}
	friend point operator *(DD t,const point &amp;a) {return point(a.x*t,a.y*t);}
	friend DD operator %(const point &amp;a,const point &amp;b) {return a.x*b.y-b.x*a.y;}
	friend DD getdist(const point &amp;a,const point &amp;b) {return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));}
	friend point getjd(point P,point v,point Q,point w)
	{
		point u=(P-Q);
		DD t=(w%u)/(v%w);
		return P+t*v;
	}
} q[NN];
struct yuan
{
	point O;DD r;
	inline bool inside(point P) {return getdist(P,O)-r&lt;eps;}
};
point getwx(point A,point B,point C)
{
	point P=(A+B)*0.5,v=(A-B).rotate(pai/2);
	point Q=(B+C)*0.5,w=(B-C).rotate(pai/2);
	return getjd(P,v,Q,w);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	srand(19980723);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j,k;
	for (i=1;i&lt;=n;i++) q[i].in();
	random_shuffle(q+1,q+n+1);
	yuan C;
	for (i=1;i&lt;=n;i++) if (!C.inside(q[i]))
	{
		C.O=q[i],C.r=0;
		for (j=1;j&lt;i;j++) if (!C.inside(q[j]))
		{
			C.O=(q[i]+q[j])*0.5;
			C.r=getdist(C.O,q[j]);
			for (k=1;k&lt;j;k++) if (!C.inside(q[k]))
			{
				C.O=getwx(q[i],q[j],q[k]);
				C.r=getdist(C.O,q[i]);
			}
		}
	}
	printf(&quot;%.5f\n%.5f %.5f\n&quot;,C.r,C.O.x,C.O.y);
	return 0;
}<pre><h2>Problem1337</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
using namespace std;
#define DD long double
#define inf 9
int n;
DD x[110000],y[110000];
DD dist(DD x1,DD y1,DD x2,DD y2) {return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));}
DD calc(DD x0,DD y0)
{
	DD res=0;
	for (int i=1;i&lt;=n;i++)
	{
		DD tmp=dist(x[i],y[i],x0,y0);
		if (tmp&gt;res) res=tmp;
	}
	return res;
}
int random(int n) {return rand()*rand()%n;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	srand(19980723);
	scanf(&quot;%d&quot;,&amp;n);
	double aaa,bbb;
	for (int i=1;i&lt;=n;i++) scanf(&quot;%lf%lf&quot;,&amp;aaa,&amp;bbb),x[i]=aaa,y[i]=bbb;
	DD R=inf,x0=x[1],y0=y[1],ans=calc(x0,y0);
	while (R&gt;=0.00000001)
	{
		for (int i=1;i&lt;=100;i++)
		{
			DD xx=x0+random(100000)*R/100000*2-R;
			DD yy=y0+random(100000)*R/100000*2-R;
			DD tmp=calc(xx,yy);
			if (tmp&lt;ans)
			{
				ans=tmp;
				x0=xx,y0=yy;
			}
		}
		R/=1.5;
	}
	printf(&quot;%.3f\n&quot;,(double)ans);
	return 0;
}
<pre><h2>Problem1337</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
using namespace std;
#define DD long double
#define inf 9
int n;
DD x[110000],y[110000];
DD dist(DD x1,DD y1,DD x2,DD y2) {return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));}
DD calc(DD x0,DD y0)
{
	DD res=0;
	for (int i=1;i&lt;=n;i++)
	{
		DD tmp=dist(x[i],y[i],x0,y0);
		if (tmp&gt;res) res=tmp;
	}
	return res;
}
int random(int n) {return rand()*rand()%n;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	srand(19980723);
	scanf(&quot;%d&quot;,&amp;n);
	double aaa,bbb;
	for (int i=1;i&lt;=n;i++) scanf(&quot;%lf%lf&quot;,&amp;aaa,&amp;bbb),x[i]=aaa,y[i]=bbb;
	DD R=inf,x0=x[1],y0=y[1],ans=calc(x0,y0);
	while (R&gt;=0.000001)
	{
		for (int i=1;i&lt;=100;i++)
		{
			DD xx=x0+random(100000)*R/100000*2-R;
			DD yy=y0+random(100000)*R/100000*2-R;
			DD tmp=calc(xx,yy);
			if (tmp&lt;ans)
			{
				ans=tmp;
				x0=xx,y0=yy;
			}
		}
		R/=1.5;
	}
	printf(&quot;%.3f\n&quot;,(double)ans);
	return 0;
}
<pre><h2>Problem1337</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
using namespace std;
#define DD long double
#define inf 999999999
int n;
DD x[110000],y[110000];
DD dist(DD x1,DD y1,DD x2,DD y2) {return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));}
DD calc(DD x0,DD y0)
{
	DD res=0;
	for (int i=1;i&lt;=n;i++)
	{
		DD tmp=dist(x[i],y[i],x0,y0);
		if (tmp&gt;res) res=tmp;
	}
	return res;
}
int random(int n) {return rand()*rand()%n;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;0.out&quot;,&quot;w&quot;,stdout);
	srand(19980723);
	scanf(&quot;%d&quot;,&amp;n);
	double aaa,bbb;
	for (int i=1;i&lt;=n;i++) scanf(&quot;%lf%lf&quot;,&amp;aaa,&amp;bbb),x[i]=aaa,y[i]=bbb;
	DD R=inf,x0=x[1],y0=y[1],ans=calc(x0,y0);
	while (R&gt;=0.000001)
	{
		for (int i=1;i&lt;=100;i++)
		{
			DD xx=x0+random(100000)*R/100000*2-R;
			DD yy=y0+random(100000)*R/100000*2-R;
			DD tmp=calc(xx,yy);
			if (tmp&lt;ans)
			{
				ans=tmp;
				x0=xx,y0=yy;
			}
		}
		R/=1.5;
	}
	printf(&quot;%.3f\n&quot;,(double)ans);
	return 0;
}
<pre><h2>Problem1337</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
#define sqr(x) ((x)*(x))
#define ln printf(&quot;\n&quot;)
const DD pai=3.14159265358979,eps=1e-7;
const int NN=100111;
int n;
struct point
{
	DD x,y;
	point(DD _x=0,DD _y=0) {x=_x,y=_y;}
	point rotate(DD sita)
	{
		DD xx=x*cos(sita)-y*sin(sita);
		DD yy=y*cos(sita)+x*sin(sita);
		x=xx,y=yy;
		return *this;
	}
	inline void in() {scanf(&quot;%lf%lf&quot;,&amp;x,&amp;y);}
	inline void out() {printf(&quot;%.3f %.3f\n&quot;,x,y);}
	friend point operator +(const point &amp;a,const point &amp;b) {return point(a.x+b.x,a.y+b.y);}
	friend point operator -(const point &amp;a,const point &amp;b) {return point(a.x-b.x,a.y-b.y);}
	friend point operator *(const point &amp;a,DD t) {return point(a.x*t,a.y*t);}
	friend point operator *(DD t,const point &amp;a) {return point(a.x*t,a.y*t);}
	friend DD operator %(const point &amp;a,const point &amp;b) {return a.x*b.y-b.x*a.y;}
	friend DD getdist(const point &amp;a,const point &amp;b) {return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));}
	friend point getjd(point P,point v,point Q,point w)
	{
		point u=(P-Q);
		DD t=(w%u)/(v%w);
		return P+t*v;
	}
} q[NN];
struct yuan
{
	point O;DD r;
	inline bool inside(point P) {return getdist(P,O)-r&lt;eps;}
};
point getwx(point A,point B,point C)
{
	//printf(&quot;============== getwx =============\n&quot;);
	point P=(A+B)*0.5,v=(A-B).rotate(pai/2);
	point Q=(B+C)*0.5,w=(B-C).rotate(pai/2);
	return getjd(P,v,Q,w);
}
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	srand(19980723);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j,k;
	for (i=1;i&lt;=n;i++) q[i].in();
	random_shuffle(q+1,q+n+1);
	//printf(&quot;q:\n&quot;);for (i=1;i&lt;=n;i++) q[i].out();ln;
	yuan C;
	for (i=1;i&lt;=n;i++) if (!C.inside(q[i]))
	{
		C.O=q[i],C.r=0;
		for (j=1;j&lt;i;j++) if (!C.inside(q[j]))
		{
			C.O=(q[i]+q[j])*0.5;
			C.r=getdist(C.O,q[j]);
			for (k=1;k&lt;j;k++) if (!C.inside(q[k]))
			{
				C.O=getwx(q[i],q[j],q[k]);
				C.r=getdist(C.O,q[i]);
				//printf(&quot;i=%d j=%d k=%d  &quot;,i,j,k);C.O.out();
			}
		}
	}
	//C.O.out();
	printf(&quot;%.3f\n&quot;,C.r);
	return 0;
}<pre><h2>Problem1337</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
#define sqr(x) ((x)*(x))
#define ln printf(&quot;\n&quot;)
const DD pai=3.14159265358979,eps=1e-7;
const int NN=100111;
int n;
struct point
{
	DD x,y;
	point(DD _x=0,DD _y=0) {x=_x,y=_y;}
	point rotate(DD sita)
	{
		DD xx=x*cos(sita)-y*sin(sita);
		DD yy=y*cos(sita)+x*sin(sita);
		x=xx,y=yy;
		return *this;
	}
	inline void in() {scanf(&quot;%lf%lf&quot;,&amp;x,&amp;y);}
	inline void out() {printf(&quot;%.3f %.3f\n&quot;,x,y);}
	friend point operator +(const point &amp;a,const point &amp;b) {return point(a.x+b.x,a.y+b.y);}
	friend point operator -(const point &amp;a,const point &amp;b) {return point(a.x-b.x,a.y-b.y);}
	friend point operator *(const point &amp;a,DD t) {return point(a.x*t,a.y*t);}
	friend point operator *(DD t,const point &amp;a) {return point(a.x*t,a.y*t);}
	friend DD operator %(const point &amp;a,const point &amp;b) {return a.x*b.y-b.x*a.y;}
	friend DD getdist(const point &amp;a,const point &amp;b) {return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));}
	friend point getjd(point P,point v,point Q,point w)
	{
		point u=(P-Q);
		DD t=(w%u)/(v%w);
		return P+t*v;
	}
} q[NN];
struct yuan
{
	point O;DD r;
	inline bool inside(point P) {return getdist(P,O)-r&lt;eps;}
};
point getwx(point A,point B,point C)
{
	//printf(&quot;============== getwx =============\n&quot;);
	point P=(A+B)*0.5,v=(A-B).rotate(pai/2);
	point Q=(B+C)*0.5,w=(B-C).rotate(pai/2);
	return getjd(P,v,Q,w);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	srand(19980723);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j,k;
	for (i=1;i&lt;=n;i++) q[i].in();
	random_shuffle(q+1,q+n+1);
	//printf(&quot;q:\n&quot;);for (i=1;i&lt;=n;i++) q[i].out();ln;
	yuan C;
	for (i=1;i&lt;=n;i++) if (!C.inside(q[i]))
	{
		C.O=q[i],C.r=0;
		for (j=1;j&lt;i;j++) if (!C.inside(q[j]))
		{
			C.O=(q[i]+q[j])*0.5;
			C.r=getdist(C.O,q[j]);
			for (k=1;k&lt;j;k++) if (!C.inside(q[k]))
			{
				C.O=getwx(q[i],q[j],q[k]);
				C.r=getdist(C.O,q[i]);
				//printf(&quot;i=%d j=%d k=%d  &quot;,i,j,k);C.O.out();
			}
		}
	}
	//C.O.out();
	printf(&quot;%.3f\n&quot;,C.r);
	return 0;
}<pre><h2>Problem1367</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define mn 1500000
#define LL long long
int begin[mn],end[mn],key[mn],lch[mn],rch[mn],root[mn],dist[mn],size[mn],a[mn];
int n,i,j,top,LLT;
LL ans;
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
int abs(int x) {return x&gt;0?x:-x;}
int merge(int x,int y)
{
	if (!x||!y) return x+y;
	if (key[x]&lt;key[y]) swap(x,y);
	rch[x]=merge(rch[x],y);
	if (dist[rch[x]]&gt;dist[lch[x]]) swap(lch[x],rch[x]);
	dist[x]=dist[rch[x]]+1;
	size[x]=size[lch[x]]+size[rch[x]]+1;
	return x;
}
bool pan(int t)
{
	int tmp=end[t]-begin[t]+1;
	if (tmp&amp;1) return size[root[t]]*2-1&gt;tmp?1:0;
	else return size[root[t]]*2&gt;tmp?1:0;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),a[i]-=i;
	//for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,a[i]);printf(&quot;\n&quot;);
	for (i=1;i&lt;=n;i++)
	{
		root[++top]=++LLT;
		lch[LLT]=rch[LLT]=0;
		size[LLT]=1;
		key[LLT]=a[i];
		dist[LLT]=1;
		begin[top]=end[top]=i;
		while (top&gt;1&amp;&amp;key[root[top]]&lt;key[root[top-1]])
		{
			root[top-1]=merge(root[top-1],root[top]);
			end[top-1]=end[top];
			top--;
			while (pan(top)) root[top]=merge(lch[root[top]],rch[root[top]]);
		}
	}
	//printf(&quot;stack:\n&quot;);for (i=1;i&lt;=top;i++) printf(&quot;   %d %d %d %d\n&quot;,i,begin[i],end[i],key[root[i]]);
	for (i=1;i&lt;=top;i++)
		for (j=begin[i];j&lt;=end[i];j++) ans+=(LL)abs(a[j]-key[root[i]]);
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1367</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define mn 1500000
#define LL long long
int begin[mn],end[mn],key[mn],lch[mn],rch[mn],root[mn],dist[mn],size[mn],a[mn];
int n,i,j,top,LLT;
LL ans;
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
int abs(int x) {return x&gt;0?x:-x;}
int merge(int x,int y)
{
	if (!x||!y) return x+y;
	if (key[x]&lt;key[y]) swap(x,y);
	rch[x]=merge(rch[x],y);
	if (dist[rch[x]]&gt;dist[lch[x]]) swap(lch[x],rch[x]);
	dist[x]=dist[rch[x]]+1;
	size[x]=size[lch[x]]+size[rch[x]]+1;
	return x;
}
bool pan(int t)
{
	int tmp=end[t]-begin[t]+1;
	if (tmp&amp;1) return size[root[t]]*2-1&gt;tmp?1:0;
	else return size[root[t]]*2&gt;tmp?1:0;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),a[i]+=n-i;
	//for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,a[i]);printf(&quot;\n&quot;);
	for (i=1;i&lt;=n;i++)
	{
		root[++top]=++LLT;
		lch[LLT]=rch[LLT]=0;
		size[LLT]=1;
		key[LLT]=a[i];
		dist[LLT]=1;
		begin[top]=end[top]=i;
		while (top&gt;1&amp;&amp;key[root[top]]&lt;key[root[top-1]])
		{
			root[top-1]=merge(root[top-1],root[top]);
			end[top-1]=end[top];
			top--;
			while (pan(top)) root[top]=merge(lch[root[top]],rch[root[top]]);
		}
	}
	//printf(&quot;stack:\n&quot;);for (i=1;i&lt;=top;i++) printf(&quot;   %d %d %d %d\n&quot;,i,begin[i],end[i],key[root[i]]);
	for (i=1;i&lt;=top;i++)
		for (j=begin[i];j&lt;=end[i];j++) ans+=(LL)abs(a[j]-key[root[i]]);
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1367</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define mn 1050000
#define LL long long
int begin[mn],end[mn],key[mn],lch[mn],rch[mn],root[mn],dist[mn],size[mn],a[mn];
int n,i,j,top,LLT;
LL ans;
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
int abs(int x) {return x&gt;0?x:-x;}
int merge(int x,int y)
{
	if (!x||!y) return x+y;
	if (key[x]&lt;key[y]) swap(x,y);
	rch[x]=merge(rch[x],y);
	if (dist[rch[x]]&gt;dist[lch[x]]) swap(lch[x],rch[x]);
	dist[x]=dist[rch[x]]+1;
	size[x]=size[lch[x]]+size[rch[x]]+1;
	return x;
}
bool pan(int t)
{
	int tmp=end[t]-begin[t]+1;
	if (tmp&amp;1) return size[root[t]]*2-1&gt;tmp?1:0;
	else return size[root[t]]*2&gt;tmp?1:0;
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),a[i]-=i;
	for (i=1;i&lt;=n;i++)
	{
		root[++top]=++LLT;
		lch[LLT]=rch[LLT]=0;
		size[LLT]=1;
		key[LLT]=a[i];
		dist[LLT]=1;
		begin[top]=end[top]=i;
		while (top&gt;1&amp;&amp;key[root[top]]&lt;key[root[top-1]])
		{
			root[top-1]=merge(root[top-1],root[top]);
			end[top-1]=end[top];
			top--;
			while (pan(top)) root[top]=merge(lch[root[top]],rch[root[top]]);
		}
	}
	for (i=1;i&lt;=top;i++)
		for (j=begin[i];j&lt;=end[i];j++) ans+=(LL)abs(a[j]-key[root[i]]);
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1409</h2><pre>#include&lt;cstdio&gt;
using namespace std;
long long Mod,m,p,n,q,tot,FIB;
bool b[110000];
long long pri[110000];
struct Matrix{
	long long x[2][2];
	Matrix(){x[0][0]=x[0][1]=x[1][0]=x[1][1]=0;}
	void init(int a,int b,int c,int d){x[0][0]=a,x[0][1]=b,x[1][0]=c,x[1][1]=d;}
	friend Matrix operator * (Matrix a,Matrix b){
		Matrix c;
		for(int k=0;k&lt;2;k++)for(int i=0;i&lt;2;i++)for(int j=0;j&lt;2;j++)(c.x[i][j]+=a.x[i][k]*b.x[k][j])%=Mod;
		return c;
	}
};
void Link(){
	b[1]=1;
	for(int i=2;i&lt;=100000;i++){
		if(!b[i])pri[++tot]=i;
		for(int j=1,x;j&lt;=tot&amp;&amp;i*pri[j]&lt;=100000;j++){
			x=pri[j]*i;b[x]=1;
			if(i%pri[j]==0)break;
		}
	}
}
long long phi(long long n){
	long long Ans=n,qqq=n;
	for(int i=1;i&lt;=tot&amp;&amp;pri[i]*pri[i]&lt;=n;i++){
		if(qqq%pri[i])continue;
		while(qqq%pri[i]==0)qqq/=pri[i];
		Ans=Ans/pri[i]*(pri[i]-1);
	}
	if(qqq*qqq&gt;n)Ans=Ans/qqq*(qqq-1);
	//printf(&quot;^-^\n&quot;);
	return Ans;
}
long long Fib(long long n){
	n-=2;
	Matrix re;re.init(1,0,0,1);
	Matrix chu;chu.init(1,1,0,0);
	Matrix xi;xi.init(1,1,1,0);
	for(;n&gt;0;n&gt;&gt;=1,xi=xi*xi)if(n&amp;1)re=re*xi;
	chu=chu*re;
	return chu.x[0][0];
}
long long Qpow(long long n){
	long long re=1,qq=p;
	for(;n;n&gt;&gt;=1,qq=qq*qq%q)if(n&amp;1)re=re*qq%q;
	return re;
}
int main(){
	scanf(&quot;%lld%lld&quot;,&amp;m,&amp;p);
	Link();
	while(m--){
		scanf(&quot;%lld%lld&quot;,&amp;n,&amp;q);
		if(q==1){puts(&quot;0&quot;);continue;}
		Mod=phi(q);FIB=Fib(n);
		//printf(&quot;Mod=%lld FIB=%lld\n&quot;,Mod,FIB);
		printf(&quot;%lld\n&quot;,Qpow(FIB));
	}
}
<pre><h2>Problem1412</h2><pre>var
    n, m                        :longint;
    num, map                    :array[0..210,0..210] of longint;
    pre, other, len             :array[0..200010] of longint;
    last                        :array[0..20010] of longint;
    l                           :longint;
    source, sink                :longint;
    go                          :array[0..2,0..4] of longint;
    que, d                      :array[0..20010] of longint;
    ans                         :longint;
     
procedure connect(x,y,z:longint);
begin
    inc(l);
    pre[l]:=last[x];
    last[x]:=l;
    other[l]:=y;
    len[l]:=z;
end;
     
function min(a,b:longint):longint;
begin
    if a&gt;b then exit(b) else exit(a);
end;
     
procedure init;
var
    i, j, k                     :longint;
    x                           :longint;
    nx, ny                      :longint;
begin
    go[1,1]:=-1; go[2,2]:=1; go[1,3]:=1; go[2,4]:=-1;
    read(n,m);
    l:=1;
    for i:=1 to n do
        for j:=1 to m do num[i,j]:=(i-1)*m+j;
     
    source:=n*m+2; sink:=source+1;
     
    for i:=1 to n do
        for j:=1 to m do read(map[i,j]);
     
    for i:=1 to n do
        for j:=1 to m do
        begin
            if map[i,j]=1 then
            begin
                connect(source,num[i,j],maxlongint);
                connect(num[i,j],source,0);
            end else
            if map[i,j]=2 then
            begin
                connect(num[i,j],sink,maxlongint);
                connect(sink,num[i,j],0);
            end;
            for k:=1 to 4 do
            begin
                nx:=i+go[1,k];
                ny:=j+go[2,k];
                if (nx&lt;1) or (nx&gt;n) or (ny&lt;1) or (ny&gt;m) then  continue;
                if map[i,j]&lt;&gt;map[nx,ny] then
                begin
                    connect(num[i,j],num[nx,ny],1);
                    connect(num[nx,ny],num[i,j],0);
                end;
                if (map[i,j]=map[nx,ny]) and (map[i,j]=0) then
                begin
                    connect(num[i,j],num[nx,ny],1);
                    connect(num[nx,ny],num[i,j],0);
                end;
            end;
        end;
end;
 
function bfs:boolean;
var
    q, p                        :longint;
    h, t, cur                   :longint;
begin
    fillchar(d,sizeof(d),0);
    que[1]:=source;
    d[source]:=1;
    h:=0; t:=1;
    while h&lt;t do
    begin
        inc(h);
        cur:=que[h];
        q:=last[cur];
        while q&lt;&gt;0 do
        begin
            p:=other[q];
            if (len[q]&gt;0) and (d[p]=0) then
            begin
                inc(t);
                que[t]:=p;
                d[p]:=d[cur]+1;
                if p=sink then exit(true);
            end;
            q:=pre[q];
        end;
    end;
    exit(false);
end;
 
function dinic(x,flow:longint):longint;
var
    q, p                        :longint;
    tmp, rest                   :longint;
begin
    if x=sink then exit(flow);
    rest:=flow;
    q:=last[x];
    while q&lt;&gt;0 do
    begin
        p:=other[q];
        if (len[q]&gt;0) and (d[p]=d[x]+1) and (rest&gt;0) then
        begin
            tmp:=dinic(p,min(rest,len[q]));
            dec(rest,tmp);
            dec(len[q],tmp);
            inc(len[q xor 1],tmp);
        end;
        q:=pre[q];
    end;
    exit(flow-rest);
end;
 
procedure main;
begin
    while bfs do
        ans:=ans+dinic(source,maxlongint);
    writeln(ans);
end;
 
begin
    init;
    main;
end.
 
<pre><h2>Problem1415</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 999999999
typedef double DD;
const int NN=1011;
int q[NN],dist[NN][NN],deep[NN],o[NN],aa[NN&lt;&lt;1][2];
int n,m,A,B,tot=1;
DD f[NN][NN][2];
bool vt[NN],flag[NN][NN][2];
void bfs(int s)
{
	int head=0,tail=1;
	q[1]=s;
	memset(vt,0,sizeof(vt));
	memset(deep,60,sizeof(deep));
	deep[s]=0;
	vt[s]=true;
	while (head&lt;tail)
	{
		int x=q[++head];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (vt[y]) continue;
			deep[y]=deep[x]+1;
			vt[y]=true;
			q[++tail]=y;
		}
	}
	for (int i=1;i&lt;=n;i++) dist[s][i]=deep[i];
}
int getnext(int v,int s)
{
	int mi,mm=inf;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (dist[s][y]&lt;mm) mm=dist[s][y],mi=y;
		else if (dist[s][y]==mm&amp;&amp;y&lt;mi) mi=y;
	}
	return mi;
}
DD dp(int A,int B,int k)
{
	if (flag[A][B][k]) return f[A][B][k];
	flag[A][B][k]=true;
	DD &amp;res=f[A][B][k];
	if (A==B) return res=0;
	if (k==0)
	{
		int t=getnext(A,B);
		if (t!=B) t=getnext(t,B);
		res=dp(t,B,1)+1;
	}
	else
	{
		//printf(&quot;A=%d B=%d k=%d\n&quot;,A,B,k);
		int num=1;
		for (int p=o[B];p;p=aa[p][0]) num++;
		DD tmp=1.0/num;
		res=tmp*dp(A,B,0);
		for (int p=o[B];p;p=aa[p][0])
			res+=tmp*dp(A,aa[p][1],0);
	}
	//printf(&quot;f[%d][%d][%d]=%.3f\n&quot;,A,B,k,res);
	return res;
}
inline void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;A,&amp;B);
	int i,x,y;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	for (i=1;i&lt;=n;i++) bfs(i);
	printf(&quot;%.3f\n&quot;,dp(A,B,0));
	return 0;
}<pre><h2>Problem1420</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;

#define HASH 100001

using namespace std;

typedef long long ll;
ll p,a,b,g,sta[10000];

ll POW(ll a,ll t,ll p)
{
	ll ret=1;
	while(t&gt;0){
		if(t&amp;1) ret=(ret*a)%p;
		a=(a*a)%p;
		t&gt;&gt;=1;
	}
	return ret;
}

ll EXGCD(ll a,ll b,ll &amp;x,ll &amp;y)
{
	if(b==0){
		x=1,y=0;
		return a;
	}
	ll d=EXGCD(b,a%b,x,y),t=x;
	x=y;y=t-a/b*y;
	return d;
}

ll findroot(ll p)
{
	ll tmp=p-1,i;
	for(i=2;i*i&lt;=tmp;i++){
		if(tmp%i==0){
			sta[++sta[0]]=i;
			while(tmp%i==0) tmp/=i;
		}
	}
	if(i!=1) sta[++sta[0]]=i;
	for(i=1;i&lt;p;i++){
		int j;
		for(j=1;j&lt;=sta[0];j++) if(POW(i,(p-1)/sta[j],p)==1) break;
		if(j==sta[0]+1) return i;
	}
	while(1);
}

namespace HASHSET{
	int B[HASH],tot;
	struct edge{
		int x,y;ll w;int last;
	}e[HASH];
	void add(int x,int y,ll w){
		e[++tot]=(edge){x,y,w,B[x]};
		B[x]=tot;
	}
}

ll BSGS(ll a,ll b,ll p)
{
	using namespace HASHSET;
	ll m=(ll)ceil(sqrt(p)),Am,j,D,i;
	for(i=0,Am=1;i&lt;m;i++,(Am*=a)%=p){
		for(j=B[Am%HASH];j;j=e[j].last){
			if(e[j].w==Am) break;
		}
		if(!j) add(Am%HASH,i,Am);
	}
	for(i=0,D=1;i&lt;=m;i++,(D*=Am)%=p){
		ll inv=POW(D,p-2,p)*b%p;
		for(j=B[inv%HASH];j;j=e[j].last){
			if(e[j].w==inv) return i*m+e[j].y;
		}
	}
	while(1);
}

int main()
{
	scanf(&quot;%lld%lld%lld&quot;,&amp;p,&amp;a,&amp;b);
	if(a==0)return puts(&quot;1&quot;),puts(&quot;0&quot;),0;
	g=findroot(p);
	b=BSGS(g,b,p);
	ll ans,y,tmp,mod;
	ll d=EXGCD(a,p-1,ans,y);
	mod=(p-1)/d;
	if(b%d) return puts(&quot;0&quot;),0;
	ans=(ans%mod+mod)%mod;
	(ans*=(b/d))%=mod;
	sta[0]=0;
	for(int i=ans;i&lt;p-1;i+=mod){
		sta[++sta[0]]=POW(g,i,p);
	}
	sort(sta+1,sta+sta[0]+1);
	printf(&quot;%lld\n&quot;,sta[0]);
	for(int i=1;i&lt;=sta[0];i++) printf(&quot;%lld\n&quot;,sta[i]);
	return 0;
}
<pre><h2>Problem1430</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define mo 9999991
int i,n;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	long long ans=1;
	for (i=1;i&lt;=n-2;i++) ans=ans*n%mo;
	for (i=1;i&lt;=n-1;i++) ans=ans*i%mo;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem1430</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define Mod 9999991
#define ll long long
ll n;
ll Fa(ll a){
	ll re=1;
	while(a)re=a*re%9999991,a--;
	return re;
}
ll Qpow(ll a,ll b){
	ll re=1;
	for(;b;b&gt;&gt;=1,a=a*a%Mod)if(b&amp;1)re=re*a%Mod;
	return re;
}
int main(){
	scanf(&quot;%lld&quot;,&amp;n);
	printf(&quot;%lld\n&quot;,Fa(n-1)*Qpow(n,n-2)%Mod);
}
<pre><h2>Problem1443</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=211,AA=NN*NN;
int hao[NN][NN],o[AA],aa[AA*2][2],vt[AA],can[AA*2],match[AA];
int n,m,TIME,tot=1,cnt;
bool flag[AA];
inline void add2(int p,int q)
{
	//printf(&quot;add %d %d\n&quot;,p,q);
	tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;
	tot++;aa[tot][1]=p;aa[tot][0]=o[q];o[q]=tot;
}
bool dfs(int v)
{
	vt[v]=TIME;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (vt[y]==TIME) continue;
		vt[y]=TIME;
		if (!match[y]||dfs(match[y]))
		{
			match[v]=y,match[y]=v;
			return true;
		}
	}
	return false;
}
bool dfs2(int v)
{
	vt[v]=TIME;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (vt[y]==TIME||!can[p]) continue;
		vt[y]=TIME;
		if (!match[y]||dfs2(match[y])) return true;
	}
	return false;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j;
	for (i=1;i&lt;=n;i++) for (j=1;j&lt;=m;j++)
	{
		char ch=getchar();
		while (ch!='.'&amp;&amp;ch!='#') ch=getchar();
		if (ch=='.') hao[i][j]=++cnt;
	}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++) if (hao[i][j])
		{
			if (hao[i+1][j]) add2(hao[i][j],hao[i+1][j]);
			if (hao[i][j+1]) add2(hao[i][j],hao[i][j+1]);
		}
	//for(i=1;i&lt;=n;i++){for(j=1;j&lt;=m;j++)printf(&quot;%d &quot;,hao[i][j]);ln;}ln;
	int ans=0;
	for (i=1;i&lt;=cnt;i++) if (!match[i])
	{
		TIME++;
		if (dfs(i)) ans++;
	}
	if (ans*2==cnt) {printf(&quot;LOSE\n&quot;);return 0;}
	//printf(&quot;match &quot;);for (i=1;i&lt;=cnt;i++) printf(&quot;%d &quot;,match[i]);ln;
	memset(can,1,sizeof(can));
	for (i=1;i&lt;=cnt;i++)
		if (!match[i]) flag[i]=true;
		else
		{
			for (int p=o[i];p;p=aa[p][0])	
				if (aa[p][1]==match[i]) can[p]=can[p^1]=false;
			TIME++;
			if (dfs2(match[i])) flag[i]=true;
			for (int p=o[i];p;p=aa[p][0])
				if (aa[p][1]==match[i]) can[p]=can[p^1]=true;
		}
	printf(&quot;WIN\n&quot;);
	for (i=1;i&lt;=n;i++) for (j=1;j&lt;=m;j++)
		if (flag[hao[i][j]]) printf(&quot;%d %d\n&quot;,i,j);
	return 0;
}<pre><h2>Problem1443</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=111,AA=NN*NN;
int hao[NN][NN],o[AA],aa[AA*4][2],vt[AA],can[AA*4],match[AA];
int n,m,TIME,tot=1,cnt;
bool flag[AA];
inline void add2(int p,int q)
{
	tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;
	tot++;aa[tot][1]=p;aa[tot][0]=o[q];o[q]=tot;
}
bool dfs(int v)
{
	vt[v]=TIME;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (vt[y]==TIME) continue;
		vt[y]=TIME;
		if (!match[y]||dfs(match[y]))
		{
			match[v]=y,match[y]=v;
			return true;
		}
	}
	return false;
}
bool dfs2(int v)
{
	vt[v]=TIME;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (vt[y]==TIME||!can[p]) continue;
		vt[y]=TIME;
		if (!match[y]||dfs2(match[y])) return true;
	}
	return false;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j;
	for (i=1;i&lt;=n;i++) for (j=1;j&lt;=m;j++)
	{
		char ch=getchar();
		while (ch!='.'&amp;&amp;ch!='#') ch=getchar();
		if (ch=='.') hao[i][j]=++cnt;
	}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++) if (hao[i][j])
		{
			if (hao[i+1][j]) add2(hao[i][j],hao[i+1][j]);
			if (hao[i][j+1]) add2(hao[i][j],hao[i][j+1]);
		}
	int ans=0;
	for (i=1;i&lt;=cnt;i++) if (!match[i])
	{
		TIME++;
		if (dfs(i)) ans++;
	}
	if (ans*2==cnt) {printf(&quot;LOSE\n&quot;);return 0;}
	memset(can,1,sizeof(can));
	for (i=1;i&lt;=cnt;i++)
		if (!match[i]) flag[i]=true;
		else
		{
			for (int p=o[i];p;p=aa[p][0])	
				if (aa[p][1]==match[i]) can[p]=can[p^1]=false;
			TIME++;
			if (dfs2(match[i])) flag[i]=true;
			for (int p=o[i];p;p=aa[p][0])
				if (aa[p][1]==match[i]) can[p]=can[p^1]=true;
		}
	printf(&quot;WIN\n&quot;);
	for (i=1;i&lt;=n;i++) for (j=1;j&lt;=m;j++)
		if (flag[hao[i][j]]) printf(&quot;%d %d\n&quot;,i,j);
	return 0;
}<pre><h2>Problem1444</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
typedef double DD;
const DD eps=1e-7;
const int NN=111;
int son[NN][26],fail[NN],q[NN],pos[NN];
int n,m,TTT;
DD a[NN][NN],X[NN],rate[NN];
bool flag[NN];
void buildfail()
{
	int head=0,tail=1;
	q[1]=1;
	while (head&lt;tail)
	{
		int x=q[++head];
		for (int i=0;i&lt;m;i++)
			if (!son[x][i]) son[x][i]=son[fail[x]][i];
			else
			{
				fail[son[x][i]]=son[fail[x]][i];
				q[++tail]=son[x][i];
			}
	}
	//printf(&quot;tail=%d\n&quot;,tail);
}
void gause()
{
	int i,j,k;
	//printf(&quot;n=%d\n&quot;,n);
	for (i=1;i&lt;n;i++)
	{
		DD tmp=fabs(a[i][i]);
		int mj=i;
		for (j=i+1;j&lt;=n;j++)
			if (fabs(a[j][i])&gt;tmp) mj=j,tmp=fabs(a[j][i]);
		if (fabs(tmp)&lt;eps) continue;
		if (mj!=i) for (j=i;j&lt;=n+1;j++) swap(a[i][j],a[mj][j]);
		for (j=i+1;j&lt;=n;j++)
		{
			tmp=a[j][i]/a[i][i];
			for (k=i;k&lt;=n+1;k++) a[j][k]-=a[i][k]*tmp;
		}
	}
	X[n]=a[n][n+1]/a[n][n];
	for (i=n-1;i;i--)
	{
		DD tmp=0;
		for (j=i+1;j&lt;=n;j++) tmp+=X[j]*a[i][j];
		X[i]=(a[i][n+1]-tmp)/a[i][i];
	}
	//printf(&quot;n=%d\n&quot;,n);
	//for (i=1;i&lt;=n;i++) printf(&quot;X[%d]=%.3f\n&quot;,i,X[i]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,x,y,j;
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;i,&amp;m);
	for (i=0;i&lt;m;i++) son[1][i]=0,son[0][i]=1;
	TTT=1;
	for (i=0;i&lt;m;i++)
	{
		scanf(&quot;%d%d\n&quot;,&amp;x,&amp;y);
		rate[i]=x*1.0/y;
	}
	char s[NN];
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s\n&quot;,s+1);
		//printf(&quot;%s\n&quot;,s+1);
		int now=1,len=strlen(s+1);
		for (j=1;j&lt;=len;j++)
		{
			int t=s[j]-'A';
			if (son[now][t]) now=son[now][t];
			else
			{
				son[now][t]=++TTT;
				now=TTT;
			}
		}
		flag[now]=true,pos[i]=now;
	}
	buildfail();
	int nn=n;
	n=TTT;
	for (i=1;i&lt;=n;i++)
	{
		a[i][i]=-1;
		if (flag[i]) continue;
		for (j=0;j&lt;m;j++)
			a[son[i][j]][i]+=rate[j];//,printf(&quot;%d\n&quot;,son[i][j]);
	}
	for (i=1;i&lt;=n;i++) a[1][i]=flag[i]?1:0;
	a[1][n+1]=1;
	//for (i=1;i&lt;=n;i++){for(j=1;j&lt;=n;j++)printf(&quot;%.3f &quot;,a[i][j]);ln;}
	//printf(&quot;n=%d\n&quot;,n);
	gause();
	for (i=1;i&lt;=nn;i++)
		if (X[pos[i]]&gt;0&amp;&amp;X[pos[i]]&lt;=1) printf(&quot;%.2f\n&quot;,X[pos[i]]);
		else printf(&quot;0.00\n&quot;);
	return 0;
}<pre><h2>Problem1444</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
typedef double DD;
const DD eps=1e-7;
const int NN=105;
int son[NN][26],fail[NN],q[NN],pos[NN];
int n,m,TTT;
DD a[NN][NN],X[NN],rate[NN];
bool flag[NN];
void buildfail()
{
	int head=0,tail=1;
	q[1]=1;
	while (head&lt;tail)
	{
		int x=q[++head];
		for (int i=0;i&lt;m;i++)
			if (!son[x][i]) son[x][i]=son[fail[x]][i];
			else
			{
				fail[son[x][i]]=son[fail[x]][i];
				q[++tail]=son[x][i];
			}
	}
	//printf(&quot;tail=%d\n&quot;,tail);
}
void gause()
{
	int i,j,k;
	//printf(&quot;n=%d\n&quot;,n);
	for (i=1;i&lt;n;i++)
	{
		DD tmp=fabs(a[i][i]);
		int mj=i;
		for (j=i+1;j&lt;=n;j++)
			if (fabs(a[j][i])&gt;tmp) mj=j,tmp=fabs(a[j][i]);
		if (fabs(tmp)&lt;eps) continue;
		if (mj!=i) for (j=i;j&lt;=n+1;j++) swap(a[i][j],a[mj][j]);
		for (j=i+1;j&lt;=n;j++)
		{
			tmp=a[j][i]/a[i][i];
			for (k=i;k&lt;=n+1;k++) a[j][k]-=a[i][k]*tmp;
		}
	}
	X[n]=a[n][n+1]/a[n][n];
	for (i=n-1;i;i--)
	{
		DD tmp=0;
		for (j=i+1;j&lt;=n;j++) tmp+=X[j]*a[i][j];
		X[i]=(a[i][n+1]-tmp)/a[i][i];
	}
	//printf(&quot;n=%d\n&quot;,n);
	//for (i=1;i&lt;=n;i++) printf(&quot;X[%d]=%.3f\n&quot;,i,X[i]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,x,y,j;
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;i,&amp;m);
	for (i=0;i&lt;m;i++) son[1][i]=0,son[0][i]=1;
	TTT=1;
	for (i=0;i&lt;m;i++)
	{
		scanf(&quot;%d%d\n&quot;,&amp;x,&amp;y);
		rate[i]=x*1.0/y;
	}
	char s[NN];
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s\n&quot;,s+1);
		//printf(&quot;%s\n&quot;,s+1);
		int now=1,len=strlen(s+1);
		for (j=1;j&lt;=len;j++)
		{
			int t=s[j]-'A';
			if (son[now][t]) now=son[now][t];
			else
			{
				son[now][t]=++TTT;
				now=TTT;
			}
		}
		flag[now]=true,pos[i]=now;
	}
	buildfail();
	int nn=n;
	n=TTT;
	for (i=1;i&lt;=n;i++)
	{
		a[i][i]=-1;
		if (flag[i]) continue;
		for (j=0;j&lt;m;j++)
			a[son[i][j]][i]+=rate[j];//,printf(&quot;%d\n&quot;,son[i][j]);
	}
	for (i=1;i&lt;=n;i++) a[1][i]=flag[i]?1:0;
	a[1][n+1]=1;
	//for (i=1;i&lt;=n;i++){for(j=1;j&lt;=n;j++)printf(&quot;%.3f &quot;,a[i][j]);ln;}
	//printf(&quot;n=%d\n&quot;,n);
	gause();
	for (i=1;i&lt;=nn;i++)
		if (X[pos[i]]&gt;0&amp;&amp;X[pos[i]]&lt;=1) printf(&quot;%.2f\n&quot;,X[pos[i]]);
		else printf(&quot;0.00\n&quot;);
	return 0;
}<pre><h2>Problem1444</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
typedef double DD;
const DD eps=1e-7;
const int NN=105;
int son[NN][26],fail[NN],q[NN],pos[NN];
int n,m,TTT;
DD a[NN][NN],X[NN],rate[NN];
bool flag[NN];
void buildfail()
{
	int head=0,tail=1;
	q[1]=1;
	while (head&lt;tail)
	{
		int x=q[++head];
		for (int i=0;i&lt;m;i++)
			if (!son[x][i]) son[x][i]=son[fail[x]][i];
			else
			{
				fail[son[x][i]]=son[fail[x]][i];
				q[++tail]=son[x][i];
			}
	}
	//printf(&quot;tail=%d\n&quot;,tail);
}
void gause()
{
	int i,j,k;
	//printf(&quot;n=%d\n&quot;,n);
	for (i=1;i&lt;n;i++)
	{
		DD tmp=fabs(a[i][i]);
		int mj=i;
		for (j=i+1;j&lt;=n;j++)
			if (fabs(a[j][i])&gt;tmp) mj=j,tmp=fabs(a[j][i]);
		if (fabs(tmp)&lt;eps) continue;
		if (mj!=i) for (j=i;j&lt;=n+1;j++) swap(a[i][j],a[mj][j]);
		for (j=i+1;j&lt;=n;j++)
		{
			tmp=a[j][i]/a[i][i];
			for (k=i;k&lt;=n+1;k++) a[j][k]-=a[i][k]*tmp;
		}
	}
	X[n]=a[n][n+1]/a[n][n];
	for (i=n-1;i;i--)
	{
		DD tmp=0;
		for (j=i+1;j&lt;=n;j++) tmp+=X[j]*a[i][j];
		X[i]=(a[i][n+1]-tmp)/a[i][i];
	}
	//printf(&quot;n=%d\n&quot;,n);
	//for (i=1;i&lt;=n;i++) printf(&quot;X[%d]=%.3f\n&quot;,i,X[i]);
}
int main()
{
	int i,x,y,j;
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;i,&amp;m);
	for (i=0;i&lt;m;i++) son[1][i]=0,son[0][i]=1;
	TTT=1;
	for (i=0;i&lt;m;i++)
	{
		scanf(&quot;%d%d\n&quot;,&amp;x,&amp;y);
		rate[i]=x*1.0/y;
	}
	char s[NN];
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s\n&quot;,s+1);
		//printf(&quot;%s\n&quot;,s+1);
		int now=1,len=strlen(s+1);
		for (j=1;j&lt;=len;j++)
		{
			int t=s[j]-'A';
			if (son[now][t]) now=son[now][t];
			else
			{
				son[now][t]=++TTT;
				now=TTT;
			}
		}
		flag[now]=true,pos[i]=now;
	}
	buildfail();
	int nn=n;
	n=TTT;
	for (i=1;i&lt;=n;i++)
	{
		a[i][i]=-1;
		if (flag[i]) continue;
		for (j=0;j&lt;m;j++)
			a[son[i][j]][i]+=rate[j];//,printf(&quot;%d\n&quot;,son[i][j]);
	}
	for (i=1;i&lt;=n;i++) a[1][i]=flag[i]?1:0;
	a[1][n+1]=1;
	//for (i=1;i&lt;=n;i++){for(j=1;j&lt;=n;j++)printf(&quot;%.3f &quot;,a[i][j]);ln;}
	//printf(&quot;n=%d\n&quot;,n);
	gause();
	for (i=1;i&lt;=nn;i++)
		if (X[pos[i]]&gt;0&amp;&amp;X[pos[i]]&lt;=1) printf(&quot;%.2f\n&quot;,X[pos[i]]);
		else printf(&quot;0.00\n&quot;);
	return 0;
}<pre><h2>Problem1449</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 6111
#define inf 999999999
#define mii(a,b) (a&lt;b?a:b)
int dist[NN],q[1000000],win[NN],lose[NN],C[NN],D[NN],num[NN],aa[1000000][4],o[NN],pre[NN];
int n,m,tot=1,S,T,ans=0;
bool dl[NN];
bool spfa()
{
	int head=0,tail=1,x,p,y;
	q[1]=S;
	memset(dist,60,sizeof(dist));
	dist[S]=0;
	memset(dl,0,sizeof(dl));
	dl[S]=true;
	while (head&lt;tail)
	{
		x=q[++head];
		dl[x]=false;
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;dist[y]&gt;dist[x]+aa[p][3])
			{
				dist[y]=dist[x]+aa[p][3];
				pre[y]=p;
				if (!dl[y]) dl[y]=true,q[++tail]=y;
			}
		}
	}
	return dist[T]&lt;dist[0];
}
void doit()
{
	int p,ff=inf;
	for (p=pre[T];p;p=pre[aa[p^1][1]]) ff=mii(ff,aa[p][2]);
	for (p=pre[T];p;p=pre[aa[p^1][1]])
	{
		ans+=ff*aa[p][3];
		aa[p][2]-=ff;
		aa[p^1][2]+=ff;
	}
}
void addedge(int p,int q,int v,int c)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][3]=c;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v,int c)
{
	addedge(p,q,v,c);
	addedge(q,p,0,-c);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	S=n+m+1,T=n+m+2,tot=1;
	int i,j,x,y;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d%d%d%d&quot;,&amp;win[i],&amp;lose[i],&amp;C[i],&amp;D[i]);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		num[x]++,num[y]++;
		add(S,i,1,0);
		add(i,x+m,1,0),add(i,y+m,1,0);
	}
	for (i=1;i&lt;=n;i++)
	{
		lose[i]+=num[i];
		ans+=C[i]*win[i]*win[i]+D[i]*lose[i]*lose[i];
		for (j=1;j&lt;=num[i];j++)
		{
			add(i+m,T,1,2*win[i]*C[i]-2*lose[i]*D[i]+C[i]+D[i]);
			win[i]++,lose[i]--;
		}
	}
	while (spfa()) doit();
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1452</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define lowbit(i) (i&amp;-i)
using namespace std;
int map[310][310];
int Q,n,m,i,tmp,tt,x1,y1,x2,y2,x,j;
struct BIT
{
	int a[310][310];
	BIT()
	{
		memset(a,0,sizeof a);
	}
	void change(int i,int jj,int x)
	{
		for (;i&lt;=n;i+=lowbit(i))
			for (int j=jj;j&lt;=m;j+=lowbit(j)) a[i][j]+=x;
	}
	int get(int i,int jj)
	{
		int res=0;
		for (;i;i-=lowbit(i))
			for (int j=jj;j;j-=lowbit(j)) res+=a[i][j];
		return res;
	}
	int sum(int x1,int y1,int x2,int y2)
	{
		return get(x2,y2)-get(x1-1,y2)-get(x2,y1-1)+get(x1-1,y1-1);
	}
} a[110];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			scanf(&quot;%d\n&quot;,&amp;x);
			map[i][j]=x;
			a[x].change(i,j,1);
		}
	scanf(&quot;%d&quot;,&amp;Q);
	for (;Q;Q--)
	{
		scanf(&quot;%d&quot;,&amp;tt);
		if (tt==1)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x);
			tmp=map[x1][y1];
			a[tmp].change(x1,y1,-1);
			a[x].change(x1,y1,1);
			map[x1][y1]=x;
		}
		else
		{
			scanf(&quot;%d%d%d%d%d&quot;,&amp;x1,&amp;x2,&amp;y1,&amp;y2,&amp;x);
			printf(&quot;%d\n&quot;,a[x].sum(x1,y1,x2,y2));
		}
	}
	return 0;
}<pre><h2>Problem1455</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int mn=1100000;
int key[mn],fa[mn],left[mn],right[mn],dist[mn];
int n,i,t1,t2,t,x,y,m;
bool kill[mn];
char ch;
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
int getroot(int x)
{
	while (fa[x]) x=fa[x];
	return x;
}
int merge(int x,int y)
{
	if (!x||!y) return x+y;
	if (key[x]&gt;key[y]) swap(x,y);
	right[x]=merge(y,right[x]);
	if (right[x]) fa[right[x]]=x;
	if (dist[right[x]]&gt;dist[left[x]]) swap(left[x],right[x]);
	dist[x]=dist[right[x]]+1;
	return x;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;key[i]);
		fa[i]=left[i]=right[i]=0;
		dist[i]=1;
	}
	scanf(&quot;%d\n&quot;,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%c&quot;,&amp;ch);
		if (ch=='M')
		{
			scanf(&quot;%d%d\n&quot;,&amp;x,&amp;y);
			if (kill[x]||kill[y]) continue;
			int t1=getroot(x),t2=getroot(y);
			if (t1!=t2) merge(t1,t2);
		}
		else
		{
			scanf(&quot;%d\n&quot;,&amp;x);
			if (kill[x]) {printf(&quot;%d\n&quot;,0);continue;}
			int t=getroot(x);
			printf(&quot;%d\n&quot;,key[t]);
			kill[t]=1;
			fa[left[t]]=fa[right[t]]=0;
			merge(left[t],right[t]);
		}
	}
	return 0;
}
<pre><h2>Problem1455</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int NN=1001111;
int key[NN],fa[NN],lc[NN],rc[NN],dist[NN];
int n,m;
bool flag[NN];
int merge(int x,int y)
{
	if (!x||!y) return x+y;
	if (key[x]&gt;key[y]) {int t=x;x=y;y=t;}
	rc[x]=merge(rc[x],y);
	fa[rc[x]]=x;
	if (dist[rc[x]]&gt;dist[lc[x]]) swap(lc[x],rc[x]);
	dist[x]=dist[rc[x]]+1;
	return x;
}
int getroot(int x)
{
	while (fa[x]) x=fa[x];
	return x;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;key[i]);
	scanf(&quot;%d&quot;,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		char ch=getchar();
		while (ch!='M'&amp;&amp;ch!='K') ch=getchar();
		if (ch=='M')
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			if (flag[x]||flag[y]) continue;
			x=getroot(x),y=getroot(y);
			if (x==y) continue;
			merge(x,y);
		}
		else
		{
			scanf(&quot;%d&quot;,&amp;x);
			if (flag[x]) {printf(&quot;0\n&quot;);continue;}
			x=getroot(x);
			printf(&quot;%d\n&quot;,key[x]);
			flag[x]=true;
			fa[merge(lc[x],rc[x])]=0;
		}
	}
	return 0;
}<pre><h2>Problem1457</h2><pre>var ttt,test,i,j,k,m,n,x,y,ans:longint;
sg:array[1..100,1..100]of longint;
a:array[1..1000,1..2]of longint;
tt:array[0..999999]of longint;
t:boolean;
function min(xx,yy:longint):longint;
begin if xx&lt;yy then exit(xx); exit(yy); end;
procedure work(xx,yy:longint);
var ii,sum:longint;
begin
  if xx=yy then begin sg[xx,yy]:=999; exit; end;
  sum:=(xx-1)*99+yy;
  for ii:=1 to xx-1 do tt[sg[ii,yy]]:=sum;
  for ii:=1 to yy-1 do tt[sg[xx,ii]]:=sum;
  for ii:=1 to min(xx-1,yy-1) do tt[sg[xx-ii,yy-ii]]:=sum;
  for ii:=0 to 999999 do if tt[ii]&lt;&gt;sum then begin sg[xx,yy]:=ii; exit; end;
end;
 
begin
  //assign(input,'lx.in');assign(output,'lx.out');reset(input);rewrite(output);
  read(ttt);
  for test:=1 to ttt do begin
    read(n);
    t:=false;
    for i:=1 to n do begin
      read(x,y);
      if (x=0)or(y=0)or(x=y) then t:=true;
      a[i,1]:=x;
      a[i,2]:=y;
    end;
    if t then begin writeln('^o^'); continue; end;
    sg[1,1]:=999;
    sg[1,2]:=0;
    sg[2,1]:=0;
    for i:=2 to 99 do work(1,i);
    for i:=2 to 99 do work(i,1);
    for i:=2 to 99 do for j:=2 to 99 do work(i,j);
    ans:=0;
    for i:=1 to n do ans:=ans xor sg[a[i,1],a[i,2]];
    if ans=0 then writeln('T_T') else writeln('^o^');
  end;
  //close(input); close(output);
end.<pre><h2>Problem1457</h2><pre>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;
using namespace std;
int sg[105][105],n,ca,p,bo[305];
inline void add(int x,int y)
{
    if (x&gt;0&amp;&amp;y&gt;0&amp;&amp;x!=y) bo[sg[x][y]]=p;
}
void Ready()
{
    int i,j,k,tmp;
    for (i=1;i&lt;100;i++)
        for (j=1;j&lt;100;j++) if (i!=j)
        {
            p++;
            for (k=1;k&lt;max(i,j);k++)
            {
                add(i-k,j);
                add(i,j-k);
                add(i-k,j-k);
            }
            for (tmp=0;bo[tmp]==p;tmp++);
            sg[i][j]=tmp;
        }
}
int main()
{
    int x,y,s;
    bool flag;
    Ready();
    for (scanf(&quot;%d&quot;,&amp;ca);ca--;)
    {
        s=flag=0;
        for (scanf(&quot;%d&quot;,&amp;n);n--;)
        {
            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
            if (x==0||y==0||x==y) flag=1;
            else s^=sg[x][y];
        }
        if (flag||s) puts(&quot;^o^&quot;);
        else puts(&quot;T_T&quot;); 
    }
    return 0;
}<pre><h2>Problem1457</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define mii(a,b) (a&lt;b?a:b)
int sg[105][105],vt[10005];
struct ppt {int x,y;} pos[1005];
int main()
{
	int i,j,k,t,TIME;
	for (i=1;i&lt;=100;i++)
		for (j=1;j&lt;=100;j++)
		{
			if (i==j) continue;
			TIME++;
			for (k=1;k&lt;i;k++)
				if (k!=j) vt[sg[k][j]]=TIME;
			for (k=1;k&lt;j;k++)
				if (i!=k) vt[sg[i][k]]=TIME;
			for (t=mii(i,j),k=1;k&lt;t;k++) vt[sg[i-k][j-k]]=TIME;
			for (k=0;vt[k]==TIME;k++);
			sg[i][j]=k;
		}
	int tes,n;
	bool flag;
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		for (flag=false,i=1;i&lt;=n;i++)
		{
			scanf(&quot;%d%d&quot;,&amp;pos[i].x,&amp;pos[i].y);
			if (pos[i].x==pos[i].y||!pos[i].x||!pos[i].y) flag=true;
		}
		if (flag) {printf(&quot;^o^\n&quot;);continue;}
		int ans=0;
		for (i=1;i&lt;=n;i++) ans^=sg[pos[i].x][pos[i].y];
		if (ans) printf(&quot;^o^\n&quot;);
		else printf(&quot;T_T\n&quot;);
	}
	return 0;
}
<pre><h2>Problem1457</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define mii(a,b) (a&lt;b?a:b)
int sg[105][105],vt[10005];
struct ppt {int x,y;} pos[1005];
int main()
{
	int i,j,k,t,TIME;
	for (i=1;i&lt;=100;i++)
		for (j=1;j&lt;=100;j++)
		{
			if (i==j) continue;
			TIME++;
			for (k=1;k&lt;i;k++)
				if (k!=j) vt[sg[k][j]]=TIME;
			for (k=1;k&lt;j;k++)
				if (i!=k) vt[sg[i][k]]=TIME;
			for (t=mii(i,j),k=1;k&lt;t;k++) vt[sg[i-k][j-k]]=TIME;
			for (k=0;vt[k]==TIME;k++);
			sg[i][j]=k;
		}
	int tes,n;
	bool flag;
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		int ans=0;
		for (flag=false,i=1;i&lt;=n;i++)
		{
			scanf(&quot;%d%d&quot;,&amp;pos[i].x,&amp;pos[i].y);
			ans^=sg[pos[i].x][pos[i].y];
			if (pos[i].x==pos[i].y||!pos[i].x||!pos[i].y) flag=true;
		}
		if (flag) printf(&quot;^o^\n&quot;);
		else if (ans) printf(&quot;^o^\n&quot;);
		else printf(&quot;T_T\n&quot;);
	}
	return 0;
}
<pre><h2>Problem1457</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define mii(a,b) (a&lt;b?a:b)
int sg[103][103],vt[1003];
struct ppt {int x,y;} pos[1003];
int main()
{
	int i,j,k,t,TIME;
	for (i=1;i&lt;=100;i++)
		for (j=1;j&lt;=100;j++)
		{
			if (i==j) continue;
			TIME++;
			for (k=1;k&lt;i;k++)
				if (k!=j) vt[sg[k][j]]=TIME;
			for (k=1;k&lt;j;k++)
				if (i!=k) vt[sg[i][k]]=TIME;
			for (t=mii(i,j),k=1;k&lt;t;k++) vt[sg[i-k][j-k]]=TIME;
			for (k=0;vt[k]==TIME;k++);
			sg[i][j]=k;
		}
	int tes,n;
	bool flag;
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		int ans=0;
		for (flag=false,i=1;i&lt;=n;i++)
		{
			scanf(&quot;%d%d&quot;,&amp;pos[i].x,&amp;pos[i].y);
			ans^=sg[pos[i].x][pos[i].y];
			if (pos[i].x==pos[i].y||!pos[i].x||!pos[i].y) flag=true;
		}
		if (flag) printf(&quot;^o^\n&quot;);
		else if (ans) printf(&quot;^o^\n&quot;);
		else printf(&quot;T_T\n&quot;);
	}
	return 0;
}
<pre><h2>Problem1457</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define mii(a,b) (a&lt;b?a:b)
int sg[103][103],vt[505];
struct ppt {int x,y;} pos[1003];
int main()
{
	int i,j,k,t,TIME;
	for (i=1;i&lt;=100;i++)
		for (j=1;j&lt;=100;j++)
		{
			if (i==j) continue;
			TIME++;
			for (k=1;k&lt;i;k++)
				if (k!=j) vt[sg[k][j]]=TIME;
			for (k=1;k&lt;j;k++)
				if (i!=k) vt[sg[i][k]]=TIME;
			for (t=mii(i,j),k=1;k&lt;t;k++) vt[sg[i-k][j-k]]=TIME;
			for (k=0;vt[k]==TIME;k++);
			sg[i][j]=k;
		}
	int tes,n;
	bool flag;
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		int ans=0;
		for (flag=false,i=1;i&lt;=n;i++)
		{
			scanf(&quot;%d%d&quot;,&amp;pos[i].x,&amp;pos[i].y);
			ans^=sg[pos[i].x][pos[i].y];
			if (pos[i].x==pos[i].y||!pos[i].x||!pos[i].y) flag=true;
		}
		if (flag) printf(&quot;^o^\n&quot;);
		else if (ans) printf(&quot;^o^\n&quot;);
		else printf(&quot;T_T\n&quot;);
	}
	return 0;
}
<pre><h2>Problem1457</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define mii(a,b) (a&lt;b?a:b)
int sg[103][103],vt[1003];
struct ppt {int x,y;} pos[1003];
int main()
{
	int i,j,k,t,TIME;
	for (i=1;i&lt;100;i++)
		for (j=1;j&lt;100;j++)
		{
			if (i==j) continue;
			TIME++;
			for (k=1;k&lt;i;k++)
				if (k!=j) vt[sg[k][j]]=TIME;
			for (k=1;k&lt;j;k++)
				if (i!=k) vt[sg[i][k]]=TIME;
			for (t=mii(i,j),k=1;k&lt;t;k++) vt[sg[i-k][j-k]]=TIME;
			for (k=0;vt[k]==TIME;k++);
			sg[i][j]=k;
		}
	int tes,n;
	bool flag;
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		int ans=0;
		for (flag=false,i=1;i&lt;=n;i++)
		{
			scanf(&quot;%d%d&quot;,&amp;pos[i].x,&amp;pos[i].y);
			ans^=sg[pos[i].x][pos[i].y];
			if (pos[i].x==pos[i].y||!pos[i].x||!pos[i].y) flag=true;
		}
		if (flag) printf(&quot;^o^\n&quot;);
		else if (ans) printf(&quot;^o^\n&quot;);
		else printf(&quot;T_T\n&quot;);
	}
	return 0;
}
<pre><h2>Problem1458</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mii(a,b) (a&lt;b?a:b)
#define inf 999999999
int aa[50000][3],o[300],cur[300],A[300],B[300],deep[300];
int n,m,tot=1,K,S,T;
bool can[300][300];
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline void add(int p,int q,int v)
{
	//printf(&quot;add %d %d %d\n&quot;,p,q,v);
	addedge(p,q,v);
	addedge(q,p,0);
}
bool bfs()
{
	static int que[300];
	int head=0,tail=1;
	memset(deep,0,sizeof(deep));
	deep[S]=1;
	que[1]=S;
	while (head&lt;tail)
	{
		int x=que[++head];
		cur[x]=o[x];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y])
				deep[y]=deep[x]+1,que[++tail]=y;
		}
	}
	return deep[T];
}
int dfs(int v,int ff)
{
	if (v==T) return ff;
	int res=0;
	for (int &amp;p=cur[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(ff,aa[p][2]));
		ff-=tmp,aa[p][2]-=tmp;
		aa[p^1][2]+=tmp,res+=tmp;
		if (ff==0) break;
	}
	if (res==0) deep[v]=inf;
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;K);
	int i,j,x,y;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;A[i]);
	for (i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;B[i]);
	for (i=1;i&lt;=n;i++) for (j=1;j&lt;=m;j++) can[i][j]=true;
	for (i=1;i&lt;=K;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		can[x][y]=false;
	}
	S=n+m+1,T=S+1;
	for (i=1;i&lt;=n;i++)
	{
		int num=0;
		for (j=1;j&lt;=m;j++) num+=can[i][j];
		if (num&lt;A[i]) {printf(&quot;JIONG\n&quot;);return 0;}
		add(S,i,num-A[i]);
	}
	for (j=1;j&lt;=m;j++)
	{
		int num=0;
		for (i=1;i&lt;=n;i++) num+=can[i][j];
		if (num&lt;B[j]) {printf(&quot;JIONG\n&quot;);return 0;}
		add(j+n,T,num-B[j]);
	}
	for (i=1;i&lt;=n;i++) for (j=1;j&lt;=m;j++)
		if (can[i][j]) add(i,j+n,1);
	int ans=n*m-K;
	//printf(&quot;ans=%d\n&quot;,ans);
	while (bfs()) ans-=dfs(S,inf);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1458</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;

#define maxn 210
#define INF 0x7fffffff

using namespace std;

int b[maxn],tot=1,su,sv,ssu,ssv,dep[maxn],n,m,k,in[maxn],out[maxn];
bool flag[maxn][maxn];

struct edge{int x,y,w,last;}a[maxn*maxn&lt;&lt;2];

void add(int x,int y,int w)
{
	a[++tot]=(edge){x,y,w,b[x]};
	b[x]=tot;
}

void Add(int x,int y,int w)
{
	add(x,y,w);
	add(y,x,0);
}

#define v a[i].y
bool bfs()
{
	queue&lt;int&gt; q;
	q.push(ssu);
	memset(dep,0,sizeof(dep));
	dep[ssu]=1;
	while(!q.empty()){
		int x=q.front();
		q.pop();
		for(int i=b[x];i;i=a[i].last){
			if(!dep[v]&amp;&amp;a[i].w&gt;0){
				dep[v]=dep[x]+1;
				if(v==ssv) return 1;
				q.push(v);
			}
		}
	}
	return dep[ssv]!=0;
}

int Dinic(int x,int flow)
{
	if(x==ssv) return flow;
	int remain=flow;
	for(int i=b[x];i;i=a[i].last){
		if(!remain) break;
		if(dep[v]==dep[x]+1&amp;&amp;a[i].w&gt;0){
			int tmp=Dinic(v,min(a[i].w,remain));
			if(!tmp){
				dep[v]=0;
				continue;
			}
			a[i].w-=tmp;
			a[i^1].w+=tmp;
			remain-=tmp;
		}
	}
	return flow-remain;
}

int main()
{
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);
	int w;
	su=m+n+1,sv=m+n+2,ssv=m+n+3;
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%d&quot;,&amp;w);
		Add(su,i,INF);
		in[i]+=w;out[su]+=w;
	}
	for(int i=1;i&lt;=m;i++){
		scanf(&quot;%d&quot;,&amp;w);
		Add(i+n,sv,INF);
		out[i+n]+=w;in[sv]+=w;
	}
	for(int i=1;i&lt;=k;i++){
		int x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		flag[x][y]=1;
	}
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=m;j++){
			if(!flag[i][j]){
				Add(i,j+n,1);
			}
		}
	}
	for(int i=1;i&lt;=n+m+2;i++){
		if(in[i]&gt;out[i]) Add(ssu,i,in[i]-out[i]);
		else if(out[i]&gt;in[i]) Add(i,ssv,out[i]-in[i]);
	}
	int tmp;
	while(bfs()) while(tmp=Dinic(ssu,INF));
	Add(sv,su,INF);
	int ans=0;
	while(bfs()) while(tmp=Dinic(ssu,INF)) ans+=tmp;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1467</h2><pre>#include&lt;cstdio&gt;
#include&lt;map&gt;
#include&lt;cmath&gt;

using namespace std;

long long a,b,p;

long long gcd(long long a,long long b)
{
	while(b){
		long long t=a;
		a=b;b=t%b;
	}
	return a;
}

long long POW(long long a,long long t,long long p)
{
	long long ret=1;
	while(t){
		if(t&amp;1) ret=(ret*a)%p;
		a=(a*a)%p;
		t&gt;&gt;=1;
	}
	return ret;
}

long long EXGCD(long long a,long long b,long long &amp;x,long long &amp;y)
{
	if(b==0){
		x=1,y=0;
		return a;
	}
	long long d=EXGCD(b,a%b,x,y);
	long long t=x;
	x=y,y=t-a/b*y;
	return d;
}

long long getinv(long long a,long long p)
{
	long long ans,t;
	EXGCD(a,p,ans,t);
	return (ans%p+p)%p;
}

long long BSGS(long long a,long long b,long long p)
{
	map&lt;long long,long long&gt; M;
	M.clear();
	long long m=(long long)ceil(sqrt(p)),am,i,D;
	for(i=0,am=1;i&lt;m;i++,(am*=a)%=p){
		if(!M.count(am)) M[am]=i;
	}
	for(i=0,D=1;i&lt;=m;i++,(D*=am)%=p){
		long long inv=getinv(D,p);
		long long t=b*inv%p;
		if(M.count(t)) return M[t]+i*m;
	}
	return -1;
}

long long EXBSGS()
{
	long long top=(long long)ceil(log2(p));
	for(long long i=0;i&lt;=top;i++){
		if(POW(a,i,p)==b) return i;
	}
	long long cnt=0,d=gcd(a,p),sum=1;
	while(d!=1){
		cnt++;
		if(b%d!=0) return -1;
		sum*=(a/d);
		p/=d,b/=d;
		d=gcd(a,p);
	}
	b=b*getinv(sum,p)%p;
	long long ans=BSGS(a,b,p);
	if(ans==-1) return -1;
	return cnt+ans;
}

int main()
{
	while(scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;p,&amp;b)&amp;&amp;(a||b||p)){
		long long ans=EXBSGS();
		if(ans!=-1) printf(&quot;%lld\n&quot;,ans);
		else puts(&quot;No Solution&quot;);
	}
	return 0;
}
<pre><h2>Problem1467</h2><pre>#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ll long long
#define M 1001001
ll A,B,C,D,hash[M],val[M],tim[M],tot;
int Hash(ll x){
	int pos=x%M;
	while(1){
		if(tim[pos]!=tot)tim[pos]=tot,hash[pos]=-1,val[pos]=0x3f3f3f3f;
		if(hash[pos]==-1||hash[pos]==x)return hash[pos]=x,pos;
		else ++pos,pos%=M;
	}
}
int GetHash(ll x){
	int pos=x%M;
	while(1){
		if(tim[pos]!=tot)tim[pos]=tot,hash[pos]=-1;
		if(hash[pos]==-1)return -1;
		if(hash[pos]==x)return pos;
		else ++pos,pos%=M;
	}
}
ll GCD(ll x,ll y){return y?GCD(y,x%y):x;}
pair&lt;ll,ll&gt; EXGCD(ll x,ll y){
	if(!y)return pair&lt;ll,ll&gt;(1,0);
	pair&lt;ll,ll&gt; tmp=EXGCD(y,x%y);
	return pair&lt;ll,ll&gt;(tmp.second,tmp.first-x/y*tmp.second);
}
ll Inv(ll x){
	ll tmp=EXGCD(x,C).first;
	return (tmp%C+C)%C;
}
ll EXBSGS(){
	ll i,m,cnt=0,tmp,base=1;
	tot=0;
	int pos;
	B%=C;
	for(i=0,tmp=1;i&lt;=50;i++,(tmp*=A)%=C)if(tmp==B)return i;
	D=1;
	while(tmp=GCD(A,C),tmp!=1){
		if(B%tmp)return -1;
		++cnt,B/=tmp,C/=tmp,D*=A/tmp,D%=C;
	}
	B*=Inv(D),B%=C;
	m=(ll)ceil(sqrt(C));
	++tot;
	for(i=0,tmp=1;i&lt;m;i++,(tmp*=A)%=C)pos=Hash(tmp),val[pos]=min(val[pos],i);
	for(i=1,base=1;i&lt;=m;i++,(base*=A)%=C);
	for(i=0,D=1;i&lt;m;i++,(D*=base)%=C){
		tmp=EXGCD(D,C).first*B%C;
		tmp=(tmp%C+C)%C;
		pos=GetHash(tmp);
		if(~pos)return i*m+val[pos]+cnt;
	}
	return -1;
}
int main(){
	memset(hash,0xff,sizeof(hash));
	while(scanf(&quot;%lld%lld%lld&quot;,&amp;A,&amp;C,&amp;B)==3){
        memset(hash,0xff,sizeof(hash));
        memset(tim,0,sizeof(tim));
        memset(val,0,sizeof(val));
		if(!A&amp;&amp;!B&amp;&amp;!C)break;
		ll ans=EXBSGS();
		if(ans==-1)puts(&quot;No Solution&quot;);
		else printf(&quot;%lld\n&quot;,ans);
	}
}
<pre><h2>Problem1467</h2><pre>#include&lt;stdio.h&gt;//A^x=B(mod C)
#include&lt;math.h&gt;
#include&lt;string.h&gt;
#define ll long long
inline int phi(int C){
	int ans=C;
	for(int i=2,r=sqrt(C)+0.01;i&lt;=r;++i)
	    if(!(C%i)){
			ans=ans/i*(i-1);
			while(!(C%i)) C/=i;
	    }
	if(C!=1) ans=ans/C*(C-1);
	return ans;
}
inline ll POW(ll x,ll y,ll mod){
	for(ll z=1;;x=x*x%mod,y&gt;&gt;=1)
	    if(y&amp;1) z=z*x%mod;
	    else if(!y) return z;
}
inline int GCD(int a,int b){
	for(int c;b;c=b,b=a%b,a=c);
	return a;
}
inline void EXGCD(ll a,ll b,ll &amp;x,ll &amp;y){
	if(!b){x=1,y=0;return;}
	else EXGCD(b,a%b,y,x),y-=a/b*x;
}
int cnt,hash[100007],num[100007],ci[100007];
inline void add(int x,int shu){
	int pos=x%100007;
	while(hash[pos]&amp;&amp;num[hash[pos]]!=x) pos=(pos+1)%100007;
	if(num[hash[pos]]==x&amp;&amp;ci[hash[pos]]&gt;shu) ci[hash[pos]]=shu;
	if(!hash[pos]) hash[pos]=++cnt,num[cnt]=x,ci[cnt]=shu;
}
inline int find(int x){
	int pos=x%100007;
	while(hash[pos]&amp;&amp;num[hash[pos]]!=x) pos=(pos+1)%100007;
	if(hash[pos]) return ci[hash[pos]];
	return -1;
}
inline int BSGS(int A,int B,int C){
	ll i,j,k,m=sqrt(C)+1,x,y;
	cnt=0,memset(hash,0,sizeof(hash));
	for(i=0,j=1;i&lt;m;++i,j=j*A%C) add(j,i);
	for(i=0,k=1;i&lt;m;++i,k=k*j%C){
		EXGCD(k,C,x,y);
		x=(x*B%C+C)%C;
		if(~(x=find(x))) return i*m+x;
	}
	return -1;
}
inline int EXBSGS(int A,int B,int C){
	ll tip,du,cnt=0,D=1;
	for(du=0,tip=C;tip;++du,tip&gt;&gt;=1);
	for(ll i=0,j=1;i&lt;=du;++i,j=j*A%C)
	    if(j==B) return i;
	while((tip=GCD(A,C))!=1){
		if(B%tip) return -1;
		++cnt,B/=tip,C/=tip,D=D*A/tip%C;
	}
	B=B*POW(D,phi(C)-1,C)%C;
	if(~(tip=BSGS(A%C,B,C))) return tip+cnt;
	return -1;
}
int main(){
	int A,B,C,ANS;
	for(scanf(&quot;%d%d%d&quot;,&amp;A,&amp;C,&amp;B);A&amp;&amp;B&amp;&amp;C;scanf(&quot;%d%d%d&quot;,&amp;A,&amp;C,&amp;B)){
		if(~(ANS=EXBSGS(A%C,B,C))) printf(&quot;%d\n&quot;,ANS);
		else puts(&quot;No Solution&quot;);
	}
}
<pre><h2>Problem1468</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 41000
int size[NN],o[NN],aa[NN*2][3],b[NN];
int K,n,tot,ans;
bool done[NN];
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void calcsize(int v,int fa)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa||done[y]) continue;
		calcsize(y,v);
		size[v]+=size[y];
	}
}
int findcore(int v)
{
	bool flag=true;
	for (;flag;)
	{
		flag=false;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (done[y]) continue;
			if (size[y]*2&gt;size[v])
			{
				size[v]-=size[y];
				size[y]+=size[v];
				v=y;
				flag=true;
				break;
			}
		}
	}
	return v;
}
void dfs(int v,int fa,int x)
{
	b[++b[0]]=x;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa||done[y]) continue;
		dfs(y,v,x+aa[p][2]);
	}
}
int calc(int K)
{
	int res=0;
	sort(b+1,b+b[0]+1);
	int i=1,j=b[0];
	while (i&lt;j)
		if (b[i]+b[j]&gt;K) j--;
		else res+=(j-i),i++;
	return res;
}
void work(int v)
{
	//printf(&quot;\n%d  --------------------------------------------------\n&quot;,v);
	b[0]=0;
	b[++b[0]]=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (done[y]) continue;
		dfs(y,v,aa[p][2]);
	}
	//for (int i=1;i&lt;=b[0];i++) printf(&quot;%d &quot;,b[i]);printf(&quot;\n&quot;);
	ans+=calc(K);
	//printf(&quot;%d\n&quot;,ans);
	for (int p=o[v];p;p=aa[p][0])
	{
		b[0]=0;
		int y=aa[p][1];
		if (done[y]) continue;
		dfs(y,v,0);
		ans-=calc(K-aa[p][2]*2);
	}
	//printf(&quot;%d\n&quot;,ans);
	done[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (done[y]) continue;
		calcsize(y,v);
		int core=findcore(y);
		work(core);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z);
		addedge(y,x,z);
	}
	scanf(&quot;%d&quot;,&amp;K);
	calcsize(1,0);
	int core=findcore(1);
	//printf(&quot;%d\n&quot;,core);
	work(core);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1468</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 41000
int size[NN],o[NN],aa[NN*2][3],b[NN];
int K,n,tot,ans;
bool done[NN];
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void calcsize(int v,int fa)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa||done[y]) continue;
		calcsize(y,v);
		size[v]+=size[y];
	}
}
int findcore(int v)
{
	bool flag=true;
	for (;flag;)
	{
		flag=false;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (done[y]) continue;
			if (size[y]*2&gt;size[v])
			{
				size[v]-=size[y];
				size[y]+=size[v];
				v=y;
				flag=true;
				break;
			}
		}
	}
	return v;
}
void dfs(int v,int fa,int x)
{
	b[++b[0]]=x;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa||done[y]) continue;
		dfs(y,v,x+aa[p][2]);
	}
}
int calc(int K)
{
	int res=0;
	sort(b+1,b+b[0]+1);
	int i=1,j=b[0];
	while (i&lt;j)
		if (b[i]+b[j]&gt;K) j--;
		else res+=(j-i),i++;
	return res;
}
void work(int v)
{
	b[0]=0;
	b[++b[0]]=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (done[y]) continue;
		dfs(y,v,aa[p][2]);
	}
	ans+=calc(K);
	for (int p=o[v];p;p=aa[p][0])
	{
		b[0]=0;
		int y=aa[p][1];
		if (done[y]) continue;
		dfs(y,v,0);
		ans-=calc(K-aa[p][2]*2);
	}
	done[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (done[y]) continue;
		calcsize(y,v);
		int core=findcore(y);
		work(core);
	}
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z);
		addedge(y,x,z);
	}
	scanf(&quot;%d&quot;,&amp;K);
	calcsize(1,0);
	int core=findcore(1);
	work(core);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1468</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=41111;
int o[NN],aa[NN*2][3],deep[NN],fa[NN],size[NN],b[NN];
int n,K,num,ans,tot;
void out(int*a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
void calcsize(int v)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||deep[y]&lt;deep[v]) continue;
		fa[y]=v;
		calcsize(y);
		size[v]+=size[y];
	}
}
int findcore(int v)
{
	fa[v]=0;
	calcsize(v);
	for (;;)
	{
		bool flag=false;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (deep[y]&lt;deep[v]) continue;
			if (size[y]*2&gt;size[v])
			{
				size[v]-=size[y];
				size[y]+=size[v];
				v=y;
				flag=true;
				break;
			}
		}
		if (!flag) break;
	}
	return v;
}
void dfs(int v,int d)
{
	b[++num]=d;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||deep[y]&lt;deep[v]) continue;
		fa[y]=v;
		dfs(y,d+aa[p][2]);
	}
}
int calc()
{
	sort(b+1,b+num+1);
	int l=1,r=num,res=0;
	while (l&lt;=r)
		if (b[l]+b[r]&gt;K) r--;
		else res+=r-l,l++;
	return res;
}
void work(int v)
{
	//printf(&quot;\n------------ work %d -----------------------------------------------------\n&quot;,v);
	b[num=1]=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]) continue;
		fa[y]=0;
		dfs(y,aa[p][2]);
	}
	//printf(&quot;b &quot;);out(b,1,num);
	ans+=calc();
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]) continue;
		num=0;
		fa[y]=0;
		dfs(y,aa[p][2]);
		ans-=calc();
	}
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]) continue;
		y=findcore(y);
		deep[y]=deep[v]+1;
		work(y);
	}
}
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
	}
	scanf(&quot;%d&quot;,&amp;K);
	memset(deep,60,sizeof(deep));
	int t=findcore(1);
	deep[t]=1;
	work(t);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1468</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#define inf 2e9
#define NN 40020
using namespace std;
int o[NN],nex[NN*2],to[NN*2],w[NN*2];
int f[NN],S[NN],a[NN],d[NN];
bool vis[NN];
int n,K,root,tot,cc=0,ans=0,num,mn;
inline int read()
{
	int t=0;char ch=getchar();
	while (ch&lt;'0' ||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9')
		t=t*10+ch-'0',ch=getchar();
	return t;
}

inline void add(int x,int y,int c)
{
	to[++cc]=y;
	w[cc]=c;
	nex[cc]=o[x];
	o[x]=cc;
}

void getroot(int x,int fa)
{
	S[x]=1;
	int tmp=0;
	for (int k=o[x];k;k=nex[k])
	{
		int y=to[k];
		if (vis[y] || y==fa)continue;
		getroot(y,x);
		S[x]+=S[y];
		if (S[y]&gt;tmp)tmp=S[y];
	}
	tmp=max(tmp,num-S[x]);
	if (tmp&lt;mn)mn=tmp,root=x;
} 

void getdis(int x,int fa)
{
	a[++num]=d[x];
	for (int k=o[x];k;k=nex[k])
	{
		int y=to[k];
		if (vis[y] || y==fa)continue;
		d[y]=d[x]+w[k];
		getdis(y,x);
	}
}

int calc(int x,int now)
{
	d[x]=now;num=0;
	getdis(x,0);
	sort(a+1,a+num+1);
	int res=0;
	for (int l=1,r=num;l&lt;r;)
	{
		if (a[l]+a[r]&lt;=K)
			res+=r-l,l++;
		else r--;
	}
	return res;
}

void dfs(int x)
{
	ans+=calc(x,0);
	vis[x]=1;
	for (int k=o[x];k;k=nex[k])
	{
		int y=to[k];
		if (vis[y])continue;
		ans-=calc(y,w[k]);
		num=S[y];//虽然要换根，但是这个子树的size没变 
		mn=inf;
		root=0;
		getroot(y,0);//同时getsize 
		dfs(y);		
	}
}

int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	n=read();
	for (int i=1;i&lt;n;i++)
	{
		int x,y,z;
		x=read();y=read();z=read();
		add(x,y,z);
		add(y,x,z);
	}
	K=read();
	mn=inf;
	num=n;
	getroot(1,0);
	dfs(1);
	printf(&quot;%d\n&quot;,ans);
	return 0;	
}<pre><h2>Problem1468</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
 
#define maxn 40010
 
using namespace std;
 
int n,m,tot,b[maxn],f[maxn],siz[maxn],cnt,root,s[maxn],dis[maxn];
bool vis[maxn];
 
inline int MAX(int a,int b){ return a&gt;b?a:b; }
 
struct Edge{
	int x,y,w,last;
}a[maxn&lt;&lt;1];
 
void AddEdge(int x,int y,int w)
{
	tot++;a[tot].x=x;
	a[tot].y=y;
	a[tot].last=b[x];
	a[tot].w=w;
	b[x]=tot;
}
 
#define v a[i].y
 
void dfs(int x,int fa)
{
	f[x]=0,siz[x]=1;
	for(int i=b[x];i;i=a[i].last){
		if(fa!=v&amp;&amp;!vis[v]){
			dfs(v,x);
			siz[x]+=siz[v];
			f[x]=MAX(f[x],siz[v]);
		}
	}
	f[x]=MAX(f[x],cnt-siz[x]);
	if(!root||f[x]&lt;f[root]) root=x;
	return;
}
 
void build(int x,int fa)
{
	s[++s[0]]=x;
	for(int i=b[x];i;i=a[i].last){
		if(fa!=v&amp;&amp;!vis[v]){
			dis[v]=dis[x]+a[i].w;
			build(v,x);
		}
	}
}
 
inline bool cmp(int x,int y){
	return dis[x]&lt;dis[y];
}
 
int cal(int x,int d){
	int ret=0;
	s[0]=0;dis[x]=d;
	build(x,0);
	sort(s+1,s+s[0]+1,cmp);
	int l=1,r=s[0];
	while(l&lt;r){
		while(dis[s[l]]+dis[s[r]]&gt;m&amp;&amp;l&lt;r)
			r--;
		ret+=r-l;
		l++;
	}
	return ret;
}
 
int work(int x)
{
	int ans=cal(x,0);
	vis[x]=1;
	for(int i=b[x];i;i=a[i].last){
		if(vis[v]) continue;
		ans-=cal(v,a[i].w);
		root=0;cnt=siz[v];
		dfs(v,0);
		ans+=work(root);
	}
	return ans;
}
 
#undef v
 
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;n;i++){
		int x,y,w;
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;w);
		AddEdge(x,y,w);
		AddEdge(y,x,w);
	}scanf(&quot;%d&quot;,&amp;m);
	root=0;cnt=n;
	dfs(1,0);
	printf(&quot;%d\n&quot;,work(root));
	return 0;
}
<pre><h2>Problem1477</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
using namespace std;
typedef long long LL;
LL X,Y,m,n,L,a,b,c;
LL extgcd(LL a,LL b,LL &amp;x,LL &amp;y)
{
	if (b==0)
	{
		x=1,y=0;
		return a;
	}
	LL tmp=extgcd(b,a%b,y,x);
	y-=a/b*x;
	return tmp;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%I64d%I64d%I64d%I64d%I64d&quot;,&amp;X,&amp;Y,&amp;m,&amp;n,&amp;L);
	LL a=m-n,b=L,c=Y-X;
	if (a&lt;0) a=-a,c=-c;
	c=(c%L+L)%L;
	//cout&lt;&lt;c&lt;&lt;endl;
	LL x,y;
	LL gcd=extgcd(a,b,x,y);
	//cout&lt;&lt;x&lt;&lt;' '&lt;&lt;y&lt;&lt;endl;
	if (c%gcd) {printf(&quot;Impossible\n&quot;);return 0;}
	//cout&lt;&lt;a&lt;&lt;' '&lt;&lt;b&lt;&lt;' '&lt;&lt;c&lt;&lt;' '&lt;&lt;gcd&lt;&lt;endl;
	x*=c/gcd;
	LL t=L/gcd;
	x%=t;
	if (x&lt;0) x+=t;
	printf(&quot;%lld\n&quot;,x);
	return 0;
}<pre><h2>Problem1483</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#define N 100005
#define M 1000005
using namespace std;
int n,m,cnt,ans;
int c[N],next[N],ft[M],head[M],s[M],st[M];
void solve(int a,int b)
{
	for(int i=head[a];i;i=next[i])
	{
		if(c[i+1]==b)ans--;
		if(c[i-1]==b)ans--;
	}
	for(int i=head[a];i;i=next[i])c[i]=b;
	next[st[a]]=head[b];head[b]=head[a];s[b]+=s[a];
	head[a]=st[a]=s[a]=0;
}
int main()
{
	//freopen(&quot;1483.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1483.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)
	{
	    scanf(&quot;%d&quot;,&amp;c[i]);ft[c[i]]=c[i];
	    if(c[i]!=c[i-1])ans++;
	    if(!head[c[i]])st[c[i]]=i;
	    s[c[i]]++;next[i]=head[c[i]];head[c[i]]=i;
    }
    for(int i=1;i&lt;=m;i++)
    {
    	int x,a,b;
    	scanf(&quot;%d&quot;,&amp;x);
    	if(x==2)printf(&quot;%d\n&quot;,ans);
    	else 
    	{
    		scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
    		if(a==b)continue;
    		if(s[ft[a]]&gt;s[ft[b]])
			    swap(ft[a],ft[b]);
			a=ft[a];b=ft[b];
			if(s[a]==0)continue;
    		s[b]+=s[a];s[a]=0;
    		solve(a,b);
    	}
    }
	return 0;
}
<pre><h2>Problem1484</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define LL long long
const LL INF=99999999999999999ll;
const int NN=5011;
int n,tes;
LL a[NN],b[NN],D;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d%lld&quot;,&amp;n,&amp;D);
		int i;
		for (i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]);
		if (abs(a[1]-a[n])&gt;=(n-1)*D) {printf(&quot;impossible\n&quot;);continue;}
		for (b[1]=a[1],i=2;i&lt;=n;i++) b[i]=b[i-1]-D;
		while (a[n]!=b[n])
		{
			int num=0,mi=-1;
			LL mm=-INF,inc=0,tmp=INF;
			for (i=n;i&gt;1;i--)
			{
				if (b[i]&gt;=a[i]) num--;
				else num++,tmp=min(tmp,a[i]-b[i]);
				if (num&gt;mm&amp;&amp;b[i-1]+D&gt;b[i])
				{
					mm=num,mi=i;
					inc=tmp;
					if (b[i-1]+D&lt;b[i]+inc) inc=b[i-1]+D-b[i];
				}
			}
			for (i=mi;i&lt;=n;i++) b[i]+=inc;
		}
		LL ans=0;
		for (i=2;i&lt;n;i++) ans+=abs(a[i]-b[i]);
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}
<pre><h2>Problem1484</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define LL long long
const LL INF=99999999999999999ll;
const int NN=5011;
int n,tes;
LL a[NN],b[NN],D;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d%lld&quot;,&amp;n,&amp;D);
		int i;
		for (i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]);
		if (abs(a[1]-a[n])&gt;=(n-1)*D) {printf(&quot;impossible\n&quot;);continue;}
		for (b[1]=a[1],i=2;i&lt;=n;i++) b[i]=b[i-1]-D;
		while (a[n]!=b[n])
		{
			int num=0,mi=-1;
			LL mm=-INF,inc=0,tmp=INF;
			for (i=n;i&gt;1;i--)
			{
				if (b[i]&gt;=a[i]) num--;
				else num++,tmp=min(tmp,a[i]-b[i]);
				if (num&gt;mm&amp;&amp;b[i-1]+D&gt;b[i])
				{
					mm=num,mi=i;
					inc=min(tmp,b[i-1]+D-b[i]);
				}
			}
			for (i=mi;i&lt;=n;i++) b[i]+=inc;
		}
		LL ans=0;
		for (i=2;i&lt;n;i++) ans+=abs(a[i]-b[i]);
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}
<pre><h2>Problem1485</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define LL long long
const int NN=2001111;
int pr[NN],first[NN],num[NN];
int n,cnt;
LL mo;
bool is[NN];
void shai()
{
	memset(is,1,sizeof(is));
	is[1]=false;
	for (int i=2;i&lt;=n*2;i++)
	{
		//printf(&quot;cnt=%d\n&quot;,cnt);
		if (is[i]) pr[++cnt]=i,first[i]=cnt;
		for (int j=1;j&lt;=cnt;j++)
		{
			LL x=pr[j]*i;
			if (x&gt;n*2) break;
			is[x]=false,first[x]=j;
			if (i%pr[j]==0) break;
		}
	}
}
LL ksm(LL a,LL b)
{
	LL res=1;
	for (;b;b&gt;&gt;=1,a=a*a%mo) if (b&amp;1) res=res*a%mo;
	return res;
}
void add(int x,int t)
{
	while (x&gt;1)
	{
		num[first[x]]+=t;
		x/=pr[first[x]];
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%lld&quot;,&amp;n,&amp;mo);
	//printf(&quot;0\n&quot;);
	shai();
	//printf(&quot;0\n&quot;);
	//for (int i=1;i&lt;=cnt;i++) printf(&quot;%d &quot;,pr[i]);printf(&quot;\n&quot;);
	//for (int i=1;i&lt;=2*n;i++) printf(&quot;%d &quot;,first[i]);printf(&quot;\n&quot;);
	int i;
	for (i=1;i&lt;=2*n;i++) add(i,1);
	//for (i=1;i&lt;=cnt;i++) printf(&quot;%d &quot;,num[i]);printf(&quot;\n&quot;);
	for (i=1;i&lt;=n;i++) add(i,-2);
	add(n+1,-1);
	//for (i=1;i&lt;=cnt;i++) printf(&quot;%d &quot;,num[i]);printf(&quot;\n&quot;);
	LL ans=1;
	for (i=1;i&lt;=cnt;i++) ans=ans*ksm(pr[i],num[i])%mo;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1486</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 999999999
typedef double DD;
const int NN=3111,MM=11111;
int aa[MM][2],o[NN],n,m,tot;
DD dist[NN],ll[MM],mid;
bool vt[NN];
bool dfs(int v)
{
	vt[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (dist[y]&gt;dist[v]+ll[p]-mid)
			if (vt[y]) {vt[v]=false;return true;}
			else
			{
				dist[y]=dist[v]+ll[p]-mid;
				if (dfs(y)) {vt[v]=false;return true;}
			}
	}
	vt[v]=false;return false;
}
bool check(DD x)
{
	memset(dist,0,sizeof(dist));
	for (int i=1;i&lt;=n;i++) if (dfs(i)) return true;
	return false;
}
void addedge(int p,int q,DD v)
{
	//printf(&quot;%d %d %.3f\n&quot;,p,q,v);
	tot++;
	aa[tot][1]=q;
	ll[tot]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y;
	DD z;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%lf&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z);
	}
	DD l=-inf,r=inf;
	while (r-l&gt;1e-9)
	{
		mid=(l+r)*0.5;
		if (check(mid)) r=mid;
		else l=mid;
	}
	printf(&quot;%.8f\n&quot;,l);
	return 0;
}
<pre><h2>Problem1486</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 999999999
#define maa(a,b) (a&gt;b?a:b)
#define mii(a,b) (a&lt;b?a:b)
typedef double DD;
const int NN=3111,MM=11111;
int aa[MM][2],o[NN],n,m,tot;
DD dist[NN],ll[MM],mid;
bool vt[NN];
bool dfs(int v)
{
	vt[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (dist[y]&gt;dist[v]+ll[p]-mid)
			if (vt[y]) {vt[v]=false;return true;}
			else
			{
				dist[y]=dist[v]+ll[p]-mid;
				if (dfs(y)) {vt[v]=false;return true;}
			}
	}
	vt[v]=false;return false;
}
bool check(DD x)
{
	memset(dist,0,sizeof(dist));
	for (int i=1;i&lt;=n;i++) if (dfs(i)) return true;
	return false;
}
void addedge(int p,int q,DD v)
{
	//printf(&quot;%d %d %.3f\n&quot;,p,q,v);
	tot++;
	aa[tot][1]=q;
	ll[tot]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y;
	DD z;
	DD l=inf,r=-inf;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%lf&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z);
		l=mii(l,z),r=maa(r,z);
	}
	while (r-l&gt;1e-9)
	{
		mid=(l+r)*0.5;
		if (check(mid)) r=mid;
		else l=mid;
	}
	printf(&quot;%.8f\n&quot;,l);
	return 0;
}
<pre><h2>Problem1486</h2><pre> 
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 999999999
#define maa(a,b) (a&gt;b?a:b)
#define mii(a,b) (a&lt;b?a:b)
typedef double DD;
const int NN=3111,MM=11111;
int aa[MM][2],o[NN],n,m,tot;
DD dist[NN],ll[MM],mid;
bool vt[NN];
bool dfs(int v)
{
	vt[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (dist[y]&gt;dist[v]+ll[p]-mid)
		{
			if (vt[y]) {vt[v]=false;return true;}
			else
			{
				dist[y]=dist[v]+ll[p]-mid;
				if (dfs(y)) {vt[v]=false;return true;}
			}
		}
	}
	vt[v]=false;return false;
}
bool check(DD mid)
{
	memset(dist,0,sizeof(dist));memset(vt,0,sizeof(vt));
	for (int i=1;i&lt;=n;i++)
		if (dfs(i)) return true;
	return false;
}
void addedge(int p,int q,DD v)
{
    tot++;
    aa[tot][1]=q;
    ll[tot]=v;
    aa[tot][0]=o[p];
    o[p]=tot;
}
int main()
{
 //   freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    int i,x,y;
    DD z;
    DD l=inf,r=-inf;
    for (i=1;i&lt;=m;i++)
    {
        scanf(&quot;%d%d%lf&quot;,&amp;x,&amp;y,&amp;z);
        addedge(x,y,z);
        l=mii(l,z),r=maa(r,z);
    }
    while (r-l&gt;1e-9)
    {
        mid=(l+r)*0.5;
        if (check(mid)) r=mid;
        else l=mid;
    }
    printf(&quot;%.8f\n&quot;,l);
    return 0;
}<pre><h2>Problem1487</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 999999999
#define mii(a,b) (a&lt;b?a:b)
#define maa(a,b) (a&gt;b?a:b)
const int NN=101111,MM=201111;
int low[NN],dfn[NN],b[NN],a[NN],from[NN],o[NN],aa[MM*2][2],fa[NN],f[NN],g[NN];
int n,m,TIME,tot=1;
bool vt[NN];
void dfs(int v)
{
	vt[v]=true;
	dfn[v]=low[v]=++TIME;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if ((p^1)==from[v]) continue;
		if (vt[y]) low[v]=mii(low[v],dfn[y]);
		else
		{
			from[y]=p;
			fa[y]=v;
			dfs(y);
			low[v]=mii(low[v],low[y]);
		}
	}
	f[v]=a[v],g[v]=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if ((p^1)==from[v]) continue;
		if (low[y]&gt;dfn[v]&amp;&amp;p==from[y])
		{
			f[v]+=g[y];
			g[v]+=maa(f[y],g[y]);
		}
		else if (dfn[y]&gt;dfn[v]&amp;&amp;p!=from[y])
		{
			int x,t1,t2,t3,t4,i;
			b[0]=0;
			for (x=y;x!=v;x=fa[x]) b[++b[0]]=x;
			t1=f[v],t2=-inf;
			for (i=1;i&lt;=b[0];i++)
			{
				t3=t2+f[b[i]];
				t4=maa(t1,t2)+g[b[i]];
				t1=t3,t2=t4;
			}
			f[v]=t2;
			t1=0,t2=g[v];
			for (i=1;i&lt;=b[0];i++)
			{
				t3=t2+f[b[i]];
				t4=maa(t1,t2)+g[b[i]];
				t1=t3,t2=t4;
			}
			g[v]=maa(t1,t2);
		}
	}
}
void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	dfs(1);
	printf(&quot;%d\n&quot;,maa(f[1],g[1]));
	return 0;
}
<pre><h2>Problem1489</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int NN=2011;
int f[NN][NN],a[NN];
int tes,n,i,j;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
		if (n&amp;1) {printf(&quot;No!\n&quot;);continue;}
		memset(f,60,sizeof(f));
		f[0][0]=-1;
		a[0]=-1;
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=i;j++)
			{
				//f[i][j]=f[i-1][j-1]   a[i]&gt;a[i-1];
				//f[i][j]=a[i-1]        a[i]&gt;f[i-1][i-j]
				if (a[i]&gt;a[i-1]) f[i][j]=f[i-1][j-1];
				if (i&gt;=j&amp;&amp;a[i]&gt;f[i-1][i-j]&amp;&amp;a[i-1]&lt;f[i][j]) f[i][j]=a[i-1];
			}
		if (f[n][n/2]&lt;f[0][1]) printf(&quot;Yes!\n&quot;);
		else printf(&quot;No!\n&quot;);
	}
	return 0;
}
<pre><h2>Problem1489</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int NN=2011,inf=999999999;
int f[NN][NN],a[NN];
int tes,n,i,j;
int main()
{
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
		if (n&amp;1) {printf(&quot;No!\n&quot;);continue;}
		memset(f,60,sizeof(f));
		f[0][0]=-inf;
		a[0]=-inf;
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=i;j++)
			{
				//f[i][j]=f[i-1][j-1]   a[i]&gt;a[i-1];
				//f[i][j]=a[i-1]        a[i]&gt;f[i-1][i-j]
				if (a[i]&gt;a[i-1]) f[i][j]=f[i-1][j-1];
				if (i&gt;=j&amp;&amp;a[i]&gt;f[i-1][i-j]&amp;&amp;a[i-1]&lt;f[i][j]) f[i][j]=a[i-1];
			}
		if (f[n][n/2]&lt;f[0][1]) printf(&quot;Yes!\n&quot;);
		else printf(&quot;No!\n&quot;);
	}
	return 0;
}
<pre><h2>Problem1491</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long LL;
typedef double DD;
const int NN=111,MM=4511;
int n,m,tot=1,dist[NN][NN],o[NN],aa[MM*2][3];
LL num[NN][NN];
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
struct ppt
{
	int v,d;
	ppt(int a=0,int b=0) {v=a;d=b;}
	friend bool operator &lt;(ppt a,ppt b) {return a.d&gt;b.d;}
};
priority_queue&lt;ppt&gt; Q;
void dij(int S,int *dist,LL *num)
{
	static bool vt[NN];
	memset(vt,0,sizeof(vt));
	dist[S]=0;
	Q.push(ppt(S,0));
	num[S]=1;
	while (!Q.empty())
	{
		ppt tmp=Q.top();Q.pop();
		int v=tmp.v;
		if (vt[v]) continue;
		vt[v]=true;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (vt[y]) continue;
			int tmp=dist[v]+aa[p][2];
			if (tmp&lt;dist[y])
			{
				dist[y]=tmp;
				Q.push(ppt(y,tmp));
				num[y]=num[v];
			}
			else if (tmp==dist[y]) num[y]+=num[v];
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,j,k,x,y,z;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
	}
	memset(dist,60,sizeof(dist));
	for (i=1;i&lt;=n;i++) dij(i,dist[i],num[i]);
	for (k=1;k&lt;=n;k++)
	{
		DD ans=0;
		for (i=1;i&lt;=n;i++) if (i!=k)
			for (j=1;j&lt;=n;j++) if (j!=k)
				if (dist[i][j]==dist[i][k]+dist[k][j])
					ans+=(DD)num[i][k]*num[k][j]/num[i][j];
		printf(&quot;%.3f\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem1491</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long LL;
typedef double DD;
const int NN=101,MM=4501;
int n,m,tot=1,dist[NN][NN],o[NN],aa[MM*2][3];
LL num[NN][NN];
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
struct ppt
{
	int v,d;
	ppt(int a=0,int b=0) {v=a;d=b;}
	friend bool operator &lt;(ppt a,ppt b) {return a.d&gt;b.d;}
};
priority_queue&lt;ppt&gt; Q;
void dij(int S,int *dist,LL *num)
{
	static bool vt[NN];
	memset(vt,0,sizeof(vt));
	dist[S]=0;
	Q.push(ppt(S,0));
	num[S]=1;
	while (!Q.empty())
	{
		ppt tmp=Q.top();Q.pop();
		int v=tmp.v;
		if (vt[v]) continue;
		vt[v]=true;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (vt[y]) continue;
			int tmp=dist[v]+aa[p][2];
			if (tmp&lt;dist[y])
			{
				dist[y]=tmp;
				Q.push(ppt(y,tmp));
				num[y]=num[v];
			}
			else if (tmp==dist[y]) num[y]+=num[v];
		}
	}
}
int main()
{
	int i,j,k,x,y,z;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
	}
	memset(dist,60,sizeof(dist));
	for (i=1;i&lt;=n;i++) dij(i,dist[i],num[i]);
	for (k=1;k&lt;=n;k++)
	{
		DD ans=0;
		for (i=1;i&lt;=n;i++) if (i!=k)
			for (j=1;j&lt;=n;j++) if (j!=k)
				if (dist[i][j]==dist[i][k]+dist[k][j])
					ans+=(DD)num[i][k]*num[k][j]/num[i][j];
		printf(&quot;%.3f\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem1492</h2><pre>
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#define maxn 120000
#define eps 1e-9
#define inf 1e9
using namespace std;
struct query
{
    double q,a,b,rate,k;
    int pos;
}q[maxn],nq[maxn];
double fabs(double x)
{
    return (x&gt;0)?x:-x;
}
struct point
{
    double x,y;
    friend bool operator &lt;(const point &amp;a,const point &amp;b) 
    {    
        return (a.x&lt;b.x+eps)||(fabs(a.x-b.x)&lt;=eps&amp;&amp;a.y&lt;b.y+eps);
    }
}p[maxn],np[maxn];
int st[maxn];
double f[maxn];
int n,m;

double getk(int i,int j)
{
    if (i==0) return -inf;
    if (j==0) return inf;
    if (fabs(p[i].x-p[j].x)&lt;=eps) return -inf;
    return (p[i].y-p[j].y)/(p[i].x-p[j].x);
}

void solve(int l,int r)
{
    if (l==r)//此时l之前包括l的f值已经达到最优，计算出对应的点即可
    {
        f[l]=max(f[l-1],f[l]);
        p[l].y=f[l]/(q[l].a*q[l].rate+q[l].b);
        p[l].x=p[l].y*q[l].rate;
		//printf(&quot;%.3f\n&quot;,p[l].y);
        return ;
    }
    int mid=(l+r)&gt;&gt;1,l1=l,l2=mid+1;
    //对询问集合排序，1位置2斜率
    for (int i=l;i&lt;=r;i++)
        if (q[i].pos&lt;=mid) nq[l1++]=q[i];
        else nq[l2++]=q[i];
    for (int i=l;i&lt;=r;i++) q[i]=nq[i];
    //递归左区间
    solve(l,mid);
    //左半区所有点都以计算好，把它们入栈，维护凸壳
    int top=0;
    for (int i=l;i&lt;=mid;i++)
    {
        while (top&gt;=2&amp;&amp;getk(i,st[top])+eps&gt;getk(st[top],st[top-1])) top--;
        st[++top]=i;
    }
    //拿左半区更新右半区
    int j=1;
    for (int i=r;i&gt;=mid+1;i--)//保证询问斜率递减
    {
        while (j&lt;top&amp;&amp;q[i].k&lt;getk(st[j],st[j+1])+eps) j++;
			//printf(&quot;%d\n&quot;,j);
		//printf(&quot;%.3f\n&quot;,p[st[j]].x);
        f[q[i].pos]=max(f[q[i].pos],p[st[j]].x*q[i].a+p[st[j]].y*q[i].b);
		//printf(&quot;%.3f\n&quot;,f[q[i].pos]);
    }        
    //递归右区间
    solve(mid+1,r);
    //合并左右区间的点，按照x,y排序
    l1=l,l2=mid+1;
    for (int i=l;i&lt;=r;i++)
        if ((p[l1]&lt;p[l2]||l2&gt;r)&amp;&amp;l1&lt;=mid) np[i]=p[l1++];
        else np[i]=p[l2++];
    for (int i=l;i&lt;=r;i++) p[i]=np[i];
}

bool cmp(query a,query b)
{
    return a.k&lt;b.k;
}

int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
    //freopen(&quot;cash.in&quot;,&quot;r&quot;,stdin);
    //freopen(&quot;cash.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d%lf&quot;,&amp;n,&amp;f[0]);
    for (int i=1;i&lt;=n;i++)
    {
        scanf(&quot;%lf%lf%lf&quot;,&amp;q[i].a,&amp;q[i].b,&amp;q[i].rate);
        q[i].k=-q[i].a/q[i].b;
        q[i].pos=i;
    }
    sort(q+1,q+n+1,cmp);
    solve(1,n);
    printf(&quot;%.3lf\n&quot;,f[n]);
    return 0;
}<pre><h2>Problem1492</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#define maxn 120000
#define eps 1e-9
#define inf 1e9
using namespace std;
struct query
{
    double q,a,b,rate,k;
    int pos;
}q[maxn],nq[maxn];
double fabs(double x)
{
    return (x&gt;0)?x:-x;
}
struct point
{
    double x,y;
    friend bool operator &lt;(const point &amp;a,const point &amp;b) 
    {    
        return (a.x&lt;b.x+eps)||(fabs(a.x-b.x)&lt;=eps&amp;&amp;a.y&lt;b.y+eps);
    }
}p[maxn],np[maxn];
int st[maxn];
double f[maxn];
int n,m;
 
double getk(int i,int j)
{
  //  if (i==0) return -inf;
   // if (j==0) return inf;
    if (fabs(p[i].x-p[j].x)&lt;=eps) return -inf;
    return (p[i].y-p[j].y)/(p[i].x-p[j].x);
}
 
void solve(int l,int r)
{
    if (l==r)//此时l之前包括l的f值已经达到最优，计算出对应的点即可
    {
        f[l]=max(f[l-1],f[l]);
        p[l].y=f[l]/(q[l].a*q[l].rate+q[l].b);
        p[l].x=p[l].y*q[l].rate;
        //printf(&quot;%.3f\n&quot;,p[l].y);
        return ;
    }
    int mid=(l+r)&gt;&gt;1,l1=l,l2=mid+1;
    //对询问集合排序，1位置2斜率
    for (int i=l;i&lt;=r;i++)
        if (q[i].pos&lt;=mid) nq[l1++]=q[i];
        else nq[l2++]=q[i];
    for (int i=l;i&lt;=r;i++) q[i]=nq[i];
    //递归左区间
    solve(l,mid);
    //左半区所有点都以计算好，把它们入栈，维护凸壳
    int top=0;
    for (int i=l;i&lt;=mid;i++)
    {
        while (top&gt;=2&amp;&amp;getk(i,st[top])+eps&gt;getk(st[top],st[top-1])) top--;
        st[++top]=i;
    }
    //拿左半区更新右半区
    int j=1;
    for (int i=r;i&gt;=mid+1;i--)//保证询问斜率递减
    {
        while (j&lt;top&amp;&amp;q[i].k&lt;getk(st[j],st[j+1])+eps) j++;
            //printf(&quot;%d\n&quot;,j);
        //printf(&quot;%.3f\n&quot;,p[st[j]].x);
        f[q[i].pos]=max(f[q[i].pos],p[st[j]].x*q[i].a+p[st[j]].y*q[i].b);
        //printf(&quot;%.3f\n&quot;,f[q[i].pos]);
    }        
    //递归右区间
    solve(mid+1,r);
    //合并左右区间的点，按照x,y排序
    l1=l,l2=mid+1;
    for (int i=l;i&lt;=r;i++)
        if ((p[l1]&lt;p[l2]||l2&gt;r)&amp;&amp;l1&lt;=mid) np[i]=p[l1++];
        else np[i]=p[l2++];
    for (int i=l;i&lt;=r;i++) p[i]=np[i];
}
 
bool cmp(query a,query b)
{
    return a.k&lt;b.k;
}
 
int main()
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
    //freopen(&quot;cash.in&quot;,&quot;r&quot;,stdin);
    //freopen(&quot;cash.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d%lf&quot;,&amp;n,&amp;f[0]);
    for (int i=1;i&lt;=n;i++)
    {
        scanf(&quot;%lf%lf%lf&quot;,&amp;q[i].a,&amp;q[i].b,&amp;q[i].rate);
        q[i].k=-q[i].a/q[i].b;
        q[i].pos=i;
    }
    sort(q+1,q+n+1,cmp);
    solve(1,n);
    printf(&quot;%.3lf\n&quot;,f[n]);
    return 0;
}<pre><h2>Problem1492</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
#define DD double
#define NN 101111
const DD eps=1e-9;
DD A[NN],B[NN],Ra[NN],X[NN],Y[NN],f[NN],g[NN],K[NN];
int id[NN],id2[NN],q[NN],n;
void out(DD *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%.3f &quot;,a[i]);printf(&quot;\n&quot;);}
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);printf(&quot;\n&quot;);}
bool check(int P,int N,int M)
{
	DD tmp=(X[N]-X[M])*(Y[P]-Y[M])-(X[P]-X[M])*(Y[N]-Y[M]);
	return tmp&gt;-eps;
}
bool check2(int M,int N,int t)
{
	if (fabs(X[M]-X[N])&lt;eps) return false;
	DD tmp=(Y[M]-Y[N])/(X[M]-X[N]);
	return tmp-K[t]&gt;-eps;
}
double getk(int i,int j)
{
    if (fabs(X[i]-X[j])&lt;=eps) return -1e9;
    return (Y[i]-Y[j])/(X[i]-X[j]);
}
void cdq(int l,int r)
{
	if (l==r)
	{
		if (f[l-1]-f[l]&gt;eps) f[l]=f[l-1];
		g[l]=f[l]/(A[l]*Ra[l]+B[l]);
		Y[l]=g[l],X[l]=Ra[l]*g[l];
		return;
	}
	int mid=(l+r)&gt;&gt;1,head,tail,i,j,k;
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if (id[k]&lt;=mid) id2[i++]=id[k];
		else id2[j++]=id[k];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
	cdq(l,mid);
	//printf(&quot;\n\n------------------- %d %d %d ----------------------------------------\n&quot;,l,mid,r);
	//printf(&quot;id &quot;);out(id,l,r);
	head=0,tail=1;
	q[1]=id[l];
	for (i=l+1;i&lt;=mid;i++)
	{
		//while (tail&gt;1&amp;&amp;check(id[i],q[tail],q[tail-1])) tail--;
		while (tail&gt;1&amp;&amp;getk(id[i],q[tail])+eps&gt;getk(q[tail],q[tail-1])) tail--;
		q[++tail]=id[i];
	}
	//printf(&quot;q &quot;);out(q,1,tail);
	for (i=r;i&gt;=mid+1;i--)
	{
		//while (head+1&lt;tail&amp;&amp;check2(q[head+1],q[head+2],id[i])) head++;
		while (head+1&lt;tail&amp;&amp;K[id[i]]&lt;getk(q[head+1],q[head+2])+eps) head++;
		j=q[head+1];
		DD tmp=Ra[j]*g[j]*A[id[i]]+g[j]*B[id[i]];
		//printf(&quot;j=%d\n&quot;,j);printf(&quot;i=%d\n&quot;,id[i]);
		if (tmp-f[id[i]]&gt;eps) f[id[i]]=tmp;
	}
	cdq(mid+1,r);
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if ((i&lt;=mid&amp;&amp;(X[id[i]]-X[id[j]]&lt;eps||(fabs(X[id[i]]-X[id[j]])&lt;eps&amp;&amp;Y[id[i]]-Y[id[j]]&lt;eps)))||j&gt;r) id2[k]=id[i++];
		else id2[k]=id[j++];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
}
bool cmp(int a,int b) {return K[a]-K[b]&lt;0;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	//freopen(&quot;1492.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1492.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%lf&quot;,&amp;n,&amp;f[0]);
	for (int i=1;i&lt;=n;i++)
	{
		scanf(&quot;%lf%lf%lf&quot;,&amp;A[i],&amp;B[i],&amp;Ra[i]);
		K[i]=-A[i]/B[i];
		id[i]=i;
	}
	sort(id+1,id+n+1,cmp);
	cdq(1,n);
	//printf(&quot;\n\n&quot;);printf(&quot;f &quot;);out(f,1,n);printf(&quot;g &quot;);out(g,1,n);
	printf(&quot;%.3f\n&quot;,f[n]);
	return 0;
}
<pre><h2>Problem1492</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
#define DD double
#define NN 101111
const DD eps=1e-9;
DD A[NN],B[NN],Ra[NN],X[NN],Y[NN],f[NN],g[NN],K[NN];
int id[NN],id2[NN],q[NN],n;
void out(DD *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%.3f &quot;,a[i]);printf(&quot;\n&quot;);}
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);printf(&quot;\n&quot;);}
bool check(int P,int N,int M)
{
	DD tmp=(X[N]-X[M])*(Y[P]-Y[M])-(X[P]-X[M])*(Y[N]-Y[M]);
	return tmp&gt;-eps;
}
bool check2(int M,int N,int t)
{
	if (fabs(X[M]-X[N])&lt;eps) return false;
	DD tmp=(Y[M]-Y[N])/(X[M]-X[N]);
	return tmp-K[t]&gt;-eps;
}
double getk(int i,int j)
{
    if (fabs(X[i]-X[j])&lt;=eps) return -1e9;
    return (Y[i]-Y[j])/(X[i]-X[j]);
}
void cdq(int l,int r)
{
	if (l==r)
	{
		if (f[l-1]-f[l]&gt;eps) f[l]=f[l-1];
		g[l]=f[l]/(A[l]*Ra[l]+B[l]);
		Y[l]=g[l],X[l]=Ra[l]*g[l];
		return;
	}
	int mid=(l+r)&gt;&gt;1,head,tail,i,j,k;
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if (id[k]&lt;=mid) id2[i++]=id[k];
		else id2[j++]=id[k];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
	cdq(l,mid);
	//printf(&quot;\n\n------------------- %d %d %d ----------------------------------------\n&quot;,l,mid,r);
	//printf(&quot;id &quot;);out(id,l,r);
	head=0,tail=1;
	q[1]=id[l];
	for (i=l+1;i&lt;=mid;i++)
	{
		while (tail&gt;1&amp;&amp;check(id[i],q[tail],q[tail-1])) tail--;
		//while (tail&gt;1&amp;&amp;getk(id[i],q[tail])+eps&gt;getk(q[tail],q[tail-1])) tail--;
		q[++tail]=id[i];
	}
	//printf(&quot;q &quot;);out(q,1,tail);
	for (i=r;i&gt;=mid+1;i--)
	{
		//while (head+1&lt;tail&amp;&amp;check2(q[head+1],q[head+2],id[i])) head++;
		while (head+1&lt;tail&amp;&amp;K[id[i]]&lt;getk(q[head+1],q[head+2])+eps) head++;
		j=q[head+1];
		DD tmp=Ra[j]*g[j]*A[id[i]]+g[j]*B[id[i]];
		//printf(&quot;j=%d\n&quot;,j);printf(&quot;i=%d\n&quot;,id[i]);
		if (tmp-f[id[i]]&gt;eps) f[id[i]]=tmp;
	}
	cdq(mid+1,r);
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if ((i&lt;=mid&amp;&amp;(X[id[i]]-X[id[j]]&lt;eps||(fabs(X[id[i]]-X[id[j]])&lt;eps&amp;&amp;Y[id[i]]-Y[id[j]]&lt;eps)))||j&gt;r) id2[k]=id[i++];
		else id2[k]=id[j++];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
}
bool cmp(int a,int b) {return K[a]-K[b]&lt;0;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	//freopen(&quot;1492.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1492.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%lf&quot;,&amp;n,&amp;f[0]);
	for (int i=1;i&lt;=n;i++)
	{
		scanf(&quot;%lf%lf%lf&quot;,&amp;A[i],&amp;B[i],&amp;Ra[i]);
		K[i]=-A[i]/B[i];
		id[i]=i;
	}
	sort(id+1,id+n+1,cmp);
	cdq(1,n);
	//printf(&quot;\n\n&quot;);printf(&quot;f &quot;);out(f,1,n);printf(&quot;g &quot;);out(g,1,n);
	printf(&quot;%.3f\n&quot;,f[n]);
	return 0;
}
<pre><h2>Problem1492</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
#define DD double
#define NN 101111
const DD eps=1e-9;
DD A[NN],B[NN],Ra[NN],X[NN],Y[NN],f[NN],g[NN],K[NN];
int id[NN],id2[NN],q[NN],n;
void out(DD *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%.3f &quot;,a[i]);printf(&quot;\n&quot;);}
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);printf(&quot;\n&quot;);}
bool check(int P,int N,int M)
{
	DD tmp=(X[N]-X[M])*(Y[P]-Y[M])-(X[P]-X[M])*(Y[N]-Y[M]);
	return tmp&gt;-eps;
}
bool check2(int M,int N,int t)
{
	if (fabs(X[M]-X[N])&lt;eps) return false;
	DD tmp=(Y[M]-Y[N])/(X[M]-X[N]);
	return tmp-K[t]&gt;-eps;
}
double getk(int i,int j)
{
    if (fabs(X[i]-X[j])&lt;=eps) return -1e9;
    return (Y[i]-Y[j])/(X[i]-X[j]);
}
void cdq(int l,int r)
{
	if (l==r)
	{
		if (f[l-1]-f[l]&gt;eps) f[l]=f[l-1];
		g[l]=f[l]/(A[l]*Ra[l]+B[l]);
		Y[l]=g[l],X[l]=Ra[l]*g[l];
		return;
	}
	int mid=(l+r)&gt;&gt;1,head,tail,i,j,k;
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if (id[k]&lt;=mid) id2[i++]=id[k];
		else id2[j++]=id[k];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
	cdq(l,mid);
	//printf(&quot;\n\n------------------- %d %d %d ----------------------------------------\n&quot;,l,mid,r);
	//printf(&quot;id &quot;);out(id,l,r);
	head=0,tail=1;
	q[1]=id[l];
	for (i=l+1;i&lt;=mid;i++)
	{
		while (tail&gt;1&amp;&amp;check(id[i],q[tail],q[tail-1])) tail--;
		//while (tail&gt;1&amp;&amp;getk(id[i],q[tail])+eps&gt;getk(q[tail],q[tail-1])) tail--;
		q[++tail]=id[i];
	}
	//printf(&quot;q &quot;);out(q,1,tail);
	for (i=r;i&gt;=mid+1;i--)
	{
		while (head+1&lt;tail&amp;&amp;check2(q[head+1],q[head+2],id[i])) head++;
		//while (head+1&lt;tail&amp;&amp;K[id[i]]&lt;getk(q[head+1],q[head+2])+eps) head++;
		j=q[head+1];
		DD tmp=Ra[j]*g[j]*A[id[i]]+g[j]*B[id[i]];
		//printf(&quot;j=%d\n&quot;,j);printf(&quot;i=%d\n&quot;,id[i]);
		if (tmp-f[id[i]]&gt;eps) f[id[i]]=tmp;
	}
	cdq(mid+1,r);
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if ((i&lt;=mid&amp;&amp;(X[id[i]]-X[id[j]]&lt;eps||(fabs(X[id[i]]-X[id[j]])&lt;eps&amp;&amp;Y[id[i]]-Y[id[j]]&lt;eps)))||j&gt;r) id2[k]=id[i++];
		else id2[k]=id[j++];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
}
bool cmp(int a,int b) {return K[a]-K[b]&lt;0;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	//freopen(&quot;1492.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1492.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%lf&quot;,&amp;n,&amp;f[0]);
	for (int i=1;i&lt;=n;i++)
	{
		scanf(&quot;%lf%lf%lf&quot;,&amp;A[i],&amp;B[i],&amp;Ra[i]);
		K[i]=-A[i]/B[i];
		id[i]=i;
	}
	sort(id+1,id+n+1,cmp);
	cdq(1,n);
	//printf(&quot;\n\n&quot;);printf(&quot;f &quot;);out(f,1,n);printf(&quot;g &quot;);out(g,1,n);
	printf(&quot;%.3f\n&quot;,f[n]);
	return 0;
}
<pre><h2>Problem1492</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
#define DD double
#define NN 101111
const DD eps=1e-9;
DD A[NN],B[NN],Ra[NN],X[NN],Y[NN],f[NN],g[NN],K[NN];
int id[NN],id2[NN],q[NN],n;
void out(DD *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%.3f &quot;,a[i]);printf(&quot;\n&quot;);}
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);printf(&quot;\n&quot;);}
bool check(int P,int N,int M)
{
	DD tmp=(X[N]-X[M])*(Y[P]-Y[M])-(X[P]-X[M])*(Y[N]-Y[M]);
	return tmp&gt;-eps;
}
bool check2(int M,int N,int t)
{
	if (fabs(X[M]-X[N])&lt;eps) return false;
	DD tmp=(Y[M]-Y[N])/(X[M]-X[N]);
	return tmp-K[t]&gt;-eps;
}
void cdq(int l,int r)
{
	if (l==r)
	{
		if (f[l-1]-f[l]&gt;eps) f[l]=f[l-1];
		g[l]=f[l]/(A[l]*Ra[l]+B[l]);
		X[l]=g[l],Y[l]=Ra[l]*g[l];
		return;
	}
	int mid=(l+r)&gt;&gt;1,head,tail,i,j,k;
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if (id[k]&lt;=mid) id2[i++]=id[k];
		else id2[j++]=id[k];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
	cdq(l,mid);
	head=0,tail=1;
	q[1]=id[l];
	for (i=l+1;i&lt;=mid;i++)
	{
		while (tail&gt;1&amp;&amp;check(id[i],q[tail],q[tail-1])) tail--;
		q[++tail]=id[i];
	}
	for (i=r;i&gt;=mid+1;i--)
	{
		while (head+1&lt;tail&amp;&amp;check2(q[head+1],q[head+2],id[i])) head++;
		j=q[head+1];
		DD tmp=Ra[j]*g[j]*A[id[i]]+g[j]*B[id[i]];
		if (tmp-f[id[i]]&gt;eps) f[id[i]]=tmp;
	}
	cdq(mid+1,r);
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if ((i&lt;=mid&amp;&amp;X[id[i]]-X[id[j]]&lt;eps)||j&gt;r) id2[k]=id[i++];
		//if ((i&lt;=mid&amp;&amp;(X[id[i]]-X[id[j]]&lt;eps||(fabs(X[id[i]]-X[id[j]])&lt;eps&amp;&amp;Y[id[i]]-Y[id[j]]&lt;eps)))||j&gt;r)id2[k]=id[i++];
		else id2[k]=id[j++];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
}
bool cmp(int a,int b) {return K[a]-K[b]&lt;0;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%lf&quot;,&amp;n,&amp;f[0]);
	for (int i=1;i&lt;=n;i++)
	{
		scanf(&quot;%lf%lf%lf&quot;,&amp;A[i],&amp;B[i],&amp;Ra[i]);
		K[i]=-B[i]/A[i];
		id[i]=i;
	}
	sort(id+1,id+n+1,cmp);
	cdq(1,n);
	printf(&quot;%.3f\n&quot;,f[n]);
	return 0;
}
<pre><h2>Problem1492</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
#define DD double
#define NN 101111
const DD eps=1e-9;
DD A[NN],B[NN],Ra[NN],X[NN],Y[NN],f[NN],g[NN],K[NN];
int id[NN],id2[NN],q[NN],n;
void out(DD *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%.3f &quot;,a[i]);printf(&quot;\n&quot;);}
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);printf(&quot;\n&quot;);}
bool check(int P,int N,int M)
{
	DD tmp=(X[N]-X[M])*(Y[P]-Y[M])-(X[P]-X[M])*(Y[N]-Y[M]);
	return tmp&gt;-eps;
}
bool check2(int M,int N,int t)
{
	///if (fabs(X[M]-X[N])&lt;eps) return false;
	DD tmp=(Y[M]-Y[N])/(X[M]-X[N]);
	return tmp-K[t]&gt;-eps;
}
void cdq(int l,int r)
{
	if (l==r)
	{
		if (f[l-1]-f[l]&gt;eps) f[l]=f[l-1];
		g[l]=f[l]/(A[l]*Ra[l]+B[l]);
		X[l]=g[l],Y[l]=Ra[l]*g[l];
		return;
	}
	int mid=(l+r)&gt;&gt;1,head,tail,i,j,k;
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if (id[k]&lt;=mid) id2[i++]=id[k];
		else id2[j++]=id[k];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
	cdq(l,mid);
	head=0,tail=1;
	q[1]=id[l];
	for (i=l+1;i&lt;=mid;i++)
	{
		while (tail&gt;1&amp;&amp;check(id[i],q[tail],q[tail-1])) tail--;
		q[++tail]=id[i];
	}
	for (i=r;i&gt;=mid+1;i--)
	{
		while (head+1&lt;tail&amp;&amp;check2(q[head+1],q[head+2],id[i])) head++;
		j=q[head+1];
		DD tmp=Ra[j]*g[j]*A[id[i]]+g[j]*B[id[i]];
		if (tmp-f[id[i]]&gt;eps) f[id[i]]=tmp;
	}
	cdq(mid+1,r);
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if ((i&lt;=mid&amp;&amp;X[id[i]]-X[id[j]]&lt;eps)||j&gt;r) id2[k]=id[i++];
		else id2[k]=id[j++];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
}
bool cmp(int a,int b) {return K[a]-K[b]&lt;0;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%lf&quot;,&amp;n,&amp;f[0]);
	for (int i=1;i&lt;=n;i++)
	{
		scanf(&quot;%lf%lf%lf&quot;,&amp;A[i],&amp;B[i],&amp;Ra[i]);
		K[i]=-B[i]/A[i];
		id[i]=i;
	}
	sort(id+1,id+n+1,cmp);
	cdq(1,n);
	printf(&quot;%.3f\n&quot;,f[n]);
	return 0;
}
<pre><h2>Problem1492</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
#define DD double
#define NN 101111
const DD eps=1e-9;
DD A[NN],B[NN],Ra[NN],X[NN],Y[NN],f[NN],g[NN],K[NN];
int id[NN],id2[NN],q[NN],n;
void out(DD *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%.3f &quot;,a[i]);printf(&quot;\n&quot;);}
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);printf(&quot;\n&quot;);}
bool check(int P,int N,int M)
{
    DD tmp=(X[N]-X[M])*(Y[P]-Y[M])-(X[P]-X[M])*(Y[N]-Y[M]);
    return tmp&gt;-eps;
}
bool check2(int M,int N,int t)
{
    ///if (fabs(X[M]-X[N])&lt;eps) return false;
    DD tmp=(Y[M]-Y[N])/(X[M]-X[N]);
    return tmp-K[t]&gt;-eps;
}
void cdq(int l,int r)
{
    if (l==r)
    {
        if (f[l-1]-f[l]&gt;eps) f[l]=f[l-1];
        g[l]=f[l]/(A[l]*Ra[l]+B[l]);
        X[l]=g[l],Y[l]=Ra[l]*g[l];
        return;
    }
    int mid=(l+r)&gt;&gt;1,head,tail,i,j,k;
    for (i=l,j=mid+1,k=l;k&lt;=r;k++)
        if (id[k]&lt;=mid) id2[i++]=id[k];
        else id2[j++]=id[k];
    for (k=l;k&lt;=r;k++) id[k]=id2[k];
    cdq(l,mid);
    head=0,tail=1;
    q[1]=id[l];
    for (i=l+1;i&lt;=mid;i++)
    {
        while (tail&gt;1&amp;&amp;check(id[i],q[tail],q[tail-1])) tail--;
        q[++tail]=id[i];
    }
    for (i=r;i&gt;=mid+1;i--)
    {
        while (head+1&lt;tail&amp;&amp;check2(q[head+1],q[head+2],id[i])) head++;
        j=q[head+1];
        DD tmp=Ra[j]*g[j]*A[id[i]]+g[j]*B[id[i]];
        if (tmp-f[id[i]]&gt;eps) f[id[i]]=tmp;
    }
    cdq(mid+1,r);
    for (i=l,j=mid+1,k=l;k&lt;=r;k++)
        if ((i&lt;=mid&amp;&amp;X[id[i]]-X[id[j]]&lt;eps)||j&gt;r) id2[k]=id[i++];
        else id2[k]=id[j++];
    for (k=l;k&lt;=r;k++) id[k]=id2[k];
}
bool cmp(int a,int b) {return K[a]-K[b]&lt;0;}
int main()
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d%lf&quot;,&amp;n,&amp;f[0]);
    for (int i=1;i&lt;=n;i++)
    {
        scanf(&quot;%lf%lf%lf&quot;,&amp;A[i],&amp;B[i],&amp;Ra[i]);
        K[i]=-B[i]/A[i];
        id[i]=i;
    }
    sort(id+1,id+n+1,cmp);
    cdq(1,n);
    printf(&quot;%.3f\n&quot;,f[n]);
    return 0;
}<pre><h2>Problem1492</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
//#include&lt;cmath&gt;
using namespace std;
#define DD double
#define NN 101111
const DD eps=1e-9;
DD A[NN],B[NN],Ra[NN],X[NN],Y[NN],f[NN],g[NN],K[NN];
int id[NN],id2[NN],q[NN],n;
bool check(int P,int N,int M)
{
    DD tmp=(X[N]-X[M])*(Y[P]-Y[M])-(X[P]-X[M])*(Y[N]-Y[M]);
    return tmp&gt;-eps;
}
bool check2(int M,int N,int t)
{
    DD tmp=(Y[M]-Y[N])/(X[M]-X[N]);
    return tmp-K[t]&gt;-eps;
}
void cdq(int l,int r)
{
    if (l==r)
    {
        if (f[l-1]-f[l]&gt;eps) f[l]=f[l-1];
        g[l]=f[l]/(A[l]*Ra[l]+B[l]);
        X[l]=g[l],Y[l]=Ra[l]*g[l];
        return;
    }
    int mid=(l+r)&gt;&gt;1,head,tail,i,j,k;
    for (i=l,j=mid+1,k=l;k&lt;=r;k++)
        if (id[k]&lt;=mid) id2[i++]=id[k];
        else id2[j++]=id[k];
    for (k=l;k&lt;=r;k++) id[k]=id2[k];
    cdq(l,mid);
    head=0,tail=1;
    q[1]=id[l];
    for (i=l+1;i&lt;=mid;i++)
    {
        while (tail&gt;1&amp;&amp;check(id[i],q[tail],q[tail-1])) tail--;
        q[++tail]=id[i];
    }
    for (i=r;i&gt;=mid+1;i--)
    {
        while (head+1&lt;tail&amp;&amp;check2(q[head+1],q[head+2],id[i])) head++;
        j=q[head+1];
        DD tmp=Ra[j]*g[j]*A[id[i]]+g[j]*B[id[i]];
        if (tmp-f[id[i]]&gt;eps) f[id[i]]=tmp;
    }
    cdq(mid+1,r);
    for (i=l,j=mid+1,k=l;k&lt;=r;k++)
        if ((i&lt;=mid&amp;&amp;X[id[i]]-X[id[j]]&lt;eps)||j&gt;r) id2[k]=id[i++];
        else id2[k]=id[j++];
    for (k=l;k&lt;=r;k++) id[k]=id2[k];
}
bool cmp(int a,int b) {return K[a]-K[b]&lt;0;}
int main()
{
  //  freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d%lf&quot;,&amp;n,&amp;f[0]);
    for (int i=1;i&lt;=n;i++)
    {
        scanf(&quot;%lf%lf%lf&quot;,&amp;A[i],&amp;B[i],&amp;Ra[i]);
        K[i]=-B[i]/A[i];
        id[i]=i;
    }
    sort(id+1,id+n+1,cmp);
    cdq(1,n);
    printf(&quot;%.3f\n&quot;,f[n]);
    return 0;
}
<pre><h2>Problem1492</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define DD double
#define NN 101111
const DD eps=1e-9;
DD A[NN],B[NN],Ra[NN],X[NN],Y[NN],f[NN],g[NN],K[NN];
int id[NN],id2[NN],q[NN],n;
bool check(int P,int N,int M)
{
	DD tmp=(X[N]-X[M])*(Y[P]-Y[M])-(X[P]-X[M])*(Y[N]-Y[M]);
	return tmp&gt;-eps;
}
bool check2(int M,int N,int t)
{
	DD tmp=(Y[M]-Y[N])/(X[M]-X[N]);
	return tmp-K[t]&gt;-eps;
}
void cdq(int l,int r)
{
	if (l==r)
	{
		if (f[l-1]-f[l]&gt;eps) f[l]=f[l-1];
		g[l]=f[l]/(A[l]*Ra[l]+B[l]);
		X[l]=g[l],Y[l]=Ra[l]*g[l];
		return;
	}
	int mid=(l+r)&gt;&gt;1,head,tail,i,j,k;
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if (id[k]&lt;=mid) id2[i++]=id[k];
		else id2[j++]=id[k];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
	cdq(l,mid);
	head=0,tail=1;
	q[1]=id[l];
	for (i=l+1;i&lt;=mid;i++)
	{
		while (tail&gt;1&amp;&amp;check(id[i],q[tail],q[tail-1])) tail--;
		q[++tail]=id[i];
	}
	for (i=r;i&gt;=mid+1;i--)
	{
		while (head+1&lt;tail&amp;&amp;check2(q[head+1],q[head+2],id[i])) head++;
		j=q[head+1];
		DD tmp=Ra[j]*g[j]*A[id[i]]+g[j]*B[id[i]];
		if (tmp-f[id[i]]&gt;eps) f[id[i]]=tmp;
	}
	cdq(mid+1,r);
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if ((i&lt;=mid&amp;&amp;X[id[i]]-X[id[j]]&lt;eps)||j&gt;r) id2[k]=id[i++];
		else id2[k]=id[j++];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
}
bool cmp(int a,int b) {return K[a]-K[b]&lt;-eps;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%lf&quot;,&amp;n,&amp;f[0]);
	for (int i=1;i&lt;=n;i++)
	{
		scanf(&quot;%lf%lf%lf&quot;,&amp;A[i],&amp;B[i],&amp;Ra[i]);
		K[i]=-B[i]/A[i];
		id[i]=i;
	}
	sort(id+1,id+n+1,cmp);
	cdq(1,n);
	printf(&quot;%.3f\n&quot;,f[n]);
	return 0;
}
<pre><h2>Problem1492</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
#define DD double
#define NN 101111
const DD eps=1e-9;
DD A[NN],B[NN],Ra[NN],X[NN],Y[NN],f[NN],g[NN],K[NN];
int id[NN],id2[NN],q[NN],n;
bool check(int P,int N,int M)
{
	DD tmp=(X[N]-X[M])*(Y[P]-Y[M])-(X[P]-X[M])*(Y[N]-Y[M]);
	return tmp&gt;-eps;
}
bool check2(int M,int N,int t)
{
	if (fabs(X[M]-X[N])&lt;eps) return true;
	DD tmp=(Y[M]-Y[N])/(X[M]-X[N]);
	return tmp-K[t]&gt;-eps;
}
void cdq(int l,int r)
{
	if (l==r)
	{
		if (f[l-1]-f[l]&gt;eps) f[l]=f[l-1];
		g[l]=f[l]/(A[l]*Ra[l]+B[l]);
		X[l]=g[l],Y[l]=Ra[l]*g[l];
		return;
	}
	int mid=(l+r)&gt;&gt;1,head,tail,i,j,k;
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if (id[k]&lt;=mid) id2[i++]=id[k];
		else id2[j++]=id[k];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
	cdq(l,mid);
	head=0,tail=1;
	q[1]=id[l];
	for (i=l+1;i&lt;=mid;i++)
	{
		while (tail&gt;1&amp;&amp;check(id[i],q[tail],q[tail-1])) tail--;
		q[++tail]=id[i];
	}
	for (i=r;i&gt;=mid+1;i--)
	{
		while (head+1&lt;tail&amp;&amp;check2(q[head+1],q[head+2],id[i])) head++;
		j=q[head+1];
		DD tmp=Ra[j]*g[j]*A[id[i]]+g[j]*B[id[i]];
		if (tmp-f[id[i]]&gt;eps) f[id[i]]=tmp;
	}
	cdq(mid+1,r);
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if ((i&lt;=mid&amp;&amp;X[id[i]]-X[id[j]]&lt;eps)||j&gt;r) id2[k]=id[i++];
		else id2[k]=id[j++];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
}
bool cmp(int a,int b) {return K[a]-K[b]&lt;-eps;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%lf&quot;,&amp;n,&amp;f[0]);
	for (int i=1;i&lt;=n;i++)
	{
		scanf(&quot;%lf%lf%lf&quot;,&amp;A[i],&amp;B[i],&amp;Ra[i]);
		K[i]=-B[i]/A[i];
		id[i]=i;
	}
	sort(id+1,id+n+1,cmp);
	cdq(1,n);
	printf(&quot;%.3f\n&quot;,f[n]);
	return 0;
}
<pre><h2>Problem1493</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=501111;
int son[NN][2],fa[NN],tag1[NN],a[NN],size[NN];
int n,m,root;
bool tag0[NN];
struct ppt
{
	int c,num,l,r;
	void set(int t)
	{
		c=l=r=t;
		num=1;
	}
	void out() {printf(&quot;c=%d num=%d l=%d r=%d\n&quot;,c,num,l,r);}
} key[NN];
inline void rev(int t)
{
	tag0[t]=!tag0[t];
	swap(son[t][0],son[t][1]);
	swap(key[t].l,key[t].r);
}
inline void make(int t,int cc)
{
	tag1[t]=cc;
	key[t].c=key[t].l=key[t].r=cc;
	key[t].num=1;
}
inline void pushdown(int t)
{
	int x=son[t][0],y=son[t][1];
	if (tag0[t])
	{
		rev(x),rev(y);
		tag0[t]=false;
	}
	if (tag1[t])
	{
		make(x,tag1[t]),make(y,tag1[t]);
		tag1[t]=0;
	}
}
inline void update(int t)
{
	key[t].set(key[t].c);
	int x=son[t][0],y=son[t][1];
	size[t]=size[x]+size[y]+1;
	if (x&gt;0)
	{
		key[t].l=key[x].l;
		key[t].num=key[x].num+key[t].num;
		if (key[x].r==key[t].c) key[t].num--;
	}
	if (y&gt;0)
	{
		key[t].r=key[y].r;
		key[t].num=key[t].num+key[y].num;
		if (key[y].l==key[t].c) key[t].num--;
	}
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (fa[y])
	{
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	}
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
	if (ff==0) root=t;
}
int find(int K)
{
	int t=root;
	while (t)
	{
		pushdown(t);
		int tmp=size[son[t][0]];
		if (K==tmp+1) return t;
		if (K&lt;=tmp) t=son[t][0];
		else K-=(tmp+1),t=son[t][1];
	}
	return -1;
}
int build(int l,int r)
{
	int mid=(l+r)&gt;&gt;1,v=mid;
	key[v].c=key[v].l=key[v].r=a[mid];
	key[v].num=1;
	size[v]=1;
	if (mid&gt;l) son[v][0]=build(l,mid-1),fa[son[v][0]]=v;
	if (mid&lt;r) son[v][1]=build(mid+1,r),fa[son[v][1]]=v;
	update(v);
	return v;
}
void debug(int t)
{
	if (t==0) return;
	pushdown(t);
	debug(son[t][0]);
	printf(&quot;%d &quot;,t);
	debug(son[t][1]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,k,x,y,z;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;x);
	for (i=2;i&lt;=n+1;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	root=build(1,n+2);
	for (scanf(&quot;%d\n&quot;,&amp;m);m;m--)
	{
		//printf(&quot;\n---------------------------------------------------------------------\n&quot;);debug(root);ln;
		char s[10];
		scanf(&quot;%s&quot;,s+1);
		//printf(&quot;s: %s\n&quot;,s+1);
		if (s[1]=='R')
		{
			scanf(&quot;%d\n&quot;,&amp;k);
			x=find(1),splay(x,0);
			y=find(n+2),splay(y,x);
			x=find(n-k+1),splay(x,y);
			z=x;pushdown(z);
			while (son[z][1]) z=son[z][1],pushdown(z);
			splay(z,x);
			son[y][0]=z,fa[z]=y;
			son[x][1]=0;
			son[z][1]=x,fa[x]=z;
			splay(x,0);
		}
		else if (s[1]=='F')
		{
			scanf(&quot;\n&quot;);
			x=find(2),splay(x,0);
			y=find(n+2),splay(y,x);
			x=son[y][0];
			//debug(x);ln;
			rev(x);
			splay(x,0);
			//debug(root);ln;
		}
		else if (s[1]=='S')
		{
			scanf(&quot;%d%d\n&quot;,&amp;x,&amp;y);
			if (x==y) continue;
			if (x&gt;y) {int t=x;x=y;y=t;}
			x=find(x+1),splay(x,0);
			y=find(y+1),splay(y,0);
			splay(x,0),splay(y,x);
			int t=key[x].c;
			key[x].set(key[y].c);
			key[y].set(t);
			splay(y,0);
		}
		else if (s[1]=='P')
		{
			scanf(&quot;%d%d%d\n&quot;,&amp;x,&amp;y,&amp;z);
			if (x&lt;=y)
			{
				x=find(x),splay(x,0);
				y=find(y+2),splay(y,x);
				x=son[y][0];
				make(x,z);
				splay(x,0);
			}
			else
			{
				int xx=x,yy=y;
				x=find(xx),splay(x,0);
				y=find(n+2),splay(y,x);
				x=son[y][0];
				make(x,z);
				splay(x,0);
				x=find(1),splay(x,0);
				y=find(yy+2),splay(y,x);
				x=son[y][0];
				make(x,z);
				splay(x,0);
			}
		}
		else if (s[1]=='C'&amp;&amp;s[2]=='S')
		{
			scanf(&quot;%d%d\n&quot;,&amp;x,&amp;y);
			if (x&lt;=y)
			{
				x=find(x),splay(x,0);
				y=find(y+2),splay(y,x);
				x=son[y][0];
				printf(&quot;%d\n&quot;,key[x].num);
			}
			else
			{
				int xx=x,yy=y;
				x=find(xx),splay(x,0);
				y=find(n+2),splay(y,x);
				ppt t1=key[son[y][0]];
				x=find(1),splay(x,0);
				y=find(yy+2),splay(y,x);
				ppt t2=key[son[y][0]];
				x=t1.num+t2.num;
				if (t1.r==t2.l) x--;
				//t1.out(),t2.out();
				printf(&quot;%d\n&quot;,x);
			}
		}
		else
		{
			scanf(&quot;\n&quot;);
			x=find(1),splay(x,0);
			y=find(n+2),splay(y,x);
			x=son[y][0];
			int t=key[x].num-(key[x].l==key[x].r);
			if (t==0) t=1;
			printf(&quot;%d\n&quot;,t);
		}
	}
	return 0;
}<pre><h2>Problem1493</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=501111;
int son[NN][2],fa[NN],tag1[NN],a[NN],size[NN];
int n,m,root;
bool tag0[NN];
struct ppt
{
	int c,num,l,r;
	void set(int t)
	{
		c=l=r=t;
		num=1;
	}
} key[NN];
inline void rev(int t)
{
	tag0[t]=!tag0[t];
	swap(son[t][0],son[t][1]);
	swap(key[t].l,key[t].r);
}
inline void make(int t,int cc)
{
	tag1[t]=cc;
	key[t].c=key[t].l=key[t].r=cc;
	key[t].num=1;
}
inline void pushdown(int t)
{
	int x=son[t][0],y=son[t][1];
	if (tag0[t])
	{
		rev(x),rev(y);
		tag0[t]=false;
	}
	if (tag1[t])
	{
		make(x,tag1[t]),make(y,tag1[t]);
		tag1[t]=0;
	}
}
inline void update(int t)
{
	key[t].set(key[t].c);
	int x=son[t][0],y=son[t][1];
	size[t]=size[x]+size[y]+1;
	if (x&gt;0)
	{
		key[t].l=key[x].l;
		key[t].num=key[x].num+key[t].num;
		if (key[x].r==key[t].c) key[t].num--;
	}
	if (y&gt;0)
	{
		key[t].r=key[y].r;
		key[t].num=key[t].num+key[y].num;
		if (key[y].l==key[t].c) key[t].num--;
	}
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (fa[y])
	{
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	}
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
	if (ff==0) root=t;
}
int find(int K)
{
	int t=root;
	while (t)
	{
		pushdown(t);
		int tmp=size[son[t][0]];
		if (K==tmp+1) return t;
		if (K&lt;=tmp) t=son[t][0];
		else K-=(tmp+1),t=son[t][1];
	}
	return -1;
}
int build(int l,int r)
{
	int mid=(l+r)&gt;&gt;1,v=mid;
	key[v].c=key[v].l=key[v].r=a[mid];
	key[v].num=1;
	size[v]=1;
	if (mid&gt;l) son[v][0]=build(l,mid-1),fa[son[v][0]]=v;
	if (mid&lt;r) son[v][1]=build(mid+1,r),fa[son[v][1]]=v;
	update(v);
	return v;
}
void debug(int t)
{
	if (t==0) return;
	pushdown(t);
	debug(son[t][0]);
	printf(&quot;%d &quot;,t);
	debug(son[t][1]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,k,x,y,z;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;x);
	for (i=2;i&lt;=n+1;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	root=build(1,n+2);
	for (scanf(&quot;%d\n&quot;,&amp;m);m;m--)
	{
		char s[10];
		scanf(&quot;%s&quot;,s+1);
		if (s[1]=='R')
		{
			scanf(&quot;%d\n&quot;,&amp;k);
			x=find(1),splay(x,0);
			y=find(n+2),splay(y,x);
			x=find(n-k+1),splay(x,y);
			z=x;pushdown(z);
			while (son[z][1]) z=son[z][1],pushdown(z);
			splay(z,x);
			son[y][0]=z,fa[z]=y;
			son[x][1]=0;
			son[z][1]=x,fa[x]=z;
			splay(x,0);
		}
		else if (s[1]=='F')
		{
			scanf(&quot;\n&quot;);
			x=find(2),splay(x,0);
			y=find(n+2),splay(y,x);
			x=son[y][0];
			rev(x);
			splay(x,0);
		}
		else if (s[1]=='S')
		{
			scanf(&quot;%d%d\n&quot;,&amp;x,&amp;y);
			if (x==y) continue;
			if (x&gt;y) {int t=x;x=y;y=t;}
			x=find(x+1),splay(x,0);
			y=find(y+1),splay(y,0);
			splay(x,0),splay(y,x);
			int t=key[x].c;
			key[x].set(key[y].c);
			key[y].set(t);
			splay(y,0);
		}
		else if (s[1]=='P')
		{
			scanf(&quot;%d%d%d\n&quot;,&amp;x,&amp;y,&amp;z);
			if (x&lt;=y)
			{
				x=find(x),splay(x,0);
				y=find(y+2),splay(y,x);
				x=son[y][0];
				make(x,z);
				splay(x,0);
			}
			else
			{
				int xx=x,yy=y;
				x=find(xx),splay(x,0);
				y=find(n+2),splay(y,x);
				x=son[y][0];
				make(x,z);
				splay(x,0);
				x=find(1),splay(x,0);
				y=find(yy+2),splay(y,x);
				x=son[y][0];
				make(x,z);
				splay(x,0);
			}
		}
		else if (s[1]=='C'&amp;&amp;s[2]=='S')
		{
			scanf(&quot;%d%d\n&quot;,&amp;x,&amp;y);
			if (x&lt;=y)
			{
				x=find(x),splay(x,0);
				y=find(y+2),splay(y,x);
				x=son[y][0];
				printf(&quot;%d\n&quot;,key[x].num);
			}
			else
			{
				int xx=x,yy=y;
				x=find(xx),splay(x,0);
				y=find(n+2),splay(y,x);
				ppt t1=key[son[y][0]];
				x=find(1),splay(x,0);
				y=find(yy+2),splay(y,x);
				ppt t2=key[son[y][0]];
				x=t1.num+t2.num;
				if (t1.r==t2.l) x--;
				printf(&quot;%d\n&quot;,x);
			}
		}
		else
		{
			scanf(&quot;\n&quot;);
			x=find(1),splay(x,0);
			y=find(n+2),splay(y,x);
			x=son[y][0];
			int t=key[x].num-(key[x].l==key[x].r);
			if (t==0) t=1;
			printf(&quot;%d\n&quot;,t);
		}
	}
	return 0;
}<pre><h2>Problem1494</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;map&gt;
using namespace std;
typedef long long LL;
#define mo 65521
#define ln printf(&quot;\n&quot;)
int go[11][11];
int K,m,num,state[55],a[11],b[11];
LL n;
map&lt;int,int&gt; hao;
struct matrix
{
	int aa[55][55];
	matrix() {memset(aa,0,sizeof(aa));}
	int * operator [](int x) {return aa[x];}
	friend matrix operator *(matrix a,matrix b)
	{
		matrix c;
		for (int k=1;k&lt;=m;k++)
			for (int i=1;i&lt;=m;i++)
				for (int j=1;j&lt;=m;j++)
					c[i][j]=((LL)c[i][j]+(LL)a[i][k]*b[k][j])%mo;
		return c;
	}
	friend matrix operator ^(matrix a,LL b)
	{
		matrix res;
		for (int i=1;i&lt;=m;i++) res[i][i]=1;
		for (;b;b&gt;&gt;=1,a=a*a)
			if (b&amp;1) res=res*a;
		return res;
	}
} trs,ans;
int pack(int *a)
{
	static int dy[11];
	memset(dy,-1,sizeof(dy));
	int res=0,cnt=0;
	for (int i=1;i&lt;=K;i++)
	{
		if (dy[a[i]]==-1) dy[a[i]]=++cnt;
		a[i]=dy[a[i]];
		res=res&lt;&lt;3|a[i];
	}
	return res;
}
void repack(int *a,int x)
{
	for (int i=K;i;i--)
	{
		a[i]=x&amp;7;
		x&gt;&gt;=3;
	}
}
void dfs(int t)
{
	if (t==K+1)
	{
		state[++m]=pack(a);
		hao[state[m]]=m;
		return;
	}
	for (int i=1;i&lt;=num;i++)
	{
		a[t]=i;
		dfs(t+1);
	}
	a[t]=++num;
	dfs(t+1);
	num--;
}
void prepare()
{
	m=0;num=0;
	dfs(1);
	//printf(&quot;m=%d\n&quot;,m);
	int mm=(1&lt;&lt;K)-1,i,j,k,S;
	for (i=1;i&lt;=m;i++)
	{
		repack(a,state[i]);
		//printf(&quot;\n---------- &quot;);for (j=1;j&lt;=K;j++) printf(&quot;%d &quot;,a[j]);printf(&quot;---------------------------\n&quot;);
		bool flag=false;
		for (j=2;j&lt;=K;j++) if (a[j]==a[1]) flag=true;
		for (S=0;S&lt;=mm;S++)
		{
			if (!flag&amp;&amp;!(S&amp;1)) continue;
			bool ttt=false;
			for (j=1;j&lt;=K;j++)
				for (k=1;k&lt;=K;k++) if (k!=j)
					if (a[j]==a[k]&amp;&amp;(S&amp;(1&lt;&lt;(j-1)))&amp;&amp;(S&amp;(1&lt;&lt;(k-1)))) ttt=true;
			if (ttt) continue;
			for (j=1;j&lt;K;j++) b[j]=a[j+1];
			b[K]=6;
			for (j=1;j&lt;=K;j++) if (S&amp;(1&lt;&lt;(j-1)))
				for (k=1;k&lt;K;k++)
					if (b[k]==a[j]) b[k]=b[K];
			trs[i][hao[pack(b)]]++;
			//printf(&quot;%d -&gt; %d\n&quot;,i,hao[pack(b)]);
		}
	}
}
bool dfs3(int v,int u,int fa)
{
	a[v]=u;
	for (int i=1;i&lt;=K;i++)
		if (i!=v&amp;&amp;go[v][i]&amp;&amp;i!=fa)
		{
			if (a[i]) return false;
			if (!dfs3(i,u,v)) return false;
		}
	return true;
}
int calc()
{
	//printf(&quot;\n--------------------- calc() --------------------------\n&quot;);
	memset(a,0,sizeof(a));
	for (int i=1;i&lt;=K;i++)
		if (!a[i]&amp;&amp;!dfs3(i,i,0)) return -1;
	//if(hao[pack(a)]==1){ln;for(int i=1;i&lt;=K;i++){for(int j=1;j&lt;=K;j++)printf(&quot;%d &quot;,go[i][j]);ln;}}
	return hao[pack(a)];
}
void dfs2(int t)
{
	if (t==K+1)
	{
		int t=calc();
		if (t&gt;=0) ans[1][t]++;
		return;
	}
	int mm=(1&lt;&lt;(t-1))-1;
	for (int S=0;S&lt;=mm;S++)
	{
		for (int i=1;i&lt;t;i++)
			if (S&amp;(1&lt;&lt;(i-1))) go[t][i]=go[i][t]=true;
		dfs2(t+1);
		for (int i=1;i&lt;t;i++)
			if (S&amp;(1&lt;&lt;(i-1))) go[t][i]=go[i][t]=false;
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%lld&quot;,&amp;K,&amp;n);
	prepare();
	dfs2(1);
	//for(int i=1;i&lt;=m;i++){for(int j=1;j&lt;=m;j++)printf(&quot;%d &quot;,ans[i][j]);ln;}ln;
	ans=ans*(trs^(n-K));
	printf(&quot;%d\n&quot;,ans[1][1]);
	return 0;
}<pre><h2>Problem1494</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;map&gt;
using namespace std;
typedef long long LL;
#define mo 65521
int go[11][11];
int K,m,num,state[55],a[11],b[11];
LL n;
map&lt;int,int&gt; hao;
struct matrix
{
	int aa[55][55];
	matrix() {memset(aa,0,sizeof(aa));}
	int * operator [](int x) {return aa[x];}
	friend matrix operator *(matrix a,matrix b)
	{
		matrix c;
		for (int k=1;k&lt;=m;k++)
			for (int i=1;i&lt;=m;i++)
				for (int j=1;j&lt;=m;j++)
				{
					c[i][j]+=(LL)a[i][k]*b[k][j]%mo;
					if (c[i][j]&gt;=mo) c[i][j]-=mo;
				}
		return c;
	}
	friend matrix operator ^(matrix a,LL b)
	{
		matrix res;
		for (int i=1;i&lt;=m;i++) res[i][i]=1;
		for (;b;b&gt;&gt;=1,a=a*a)
			if (b&amp;1) res=res*a;
		return res;
	}
} trs,ans;
int pack(int *a)
{
	static int dy[11];
	memset(dy,-1,sizeof(dy));
	int res=0,cnt=0;
	for (int i=1;i&lt;=K;i++)
	{
		if (dy[a[i]]==-1) dy[a[i]]=++cnt;
		a[i]=dy[a[i]];
		res=res&lt;&lt;3|a[i];
	}
	return res;
}
void repack(int *a,int x)
{
	for (int i=K;i;i--)
	{
		a[i]=x&amp;7;
		x&gt;&gt;=3;
	}
}
void dfs(int t)
{
	if (t==K+1)
	{
		state[++m]=pack(a);
		hao[state[m]]=m;
		return;
	}
	for (int i=1;i&lt;=num;i++)
	{
		a[t]=i;
		dfs(t+1);
	}
	a[t]=++num;
	dfs(t+1);
	num--;
}
void prepare()
{
	m=0;num=0;
	dfs(1);
	int mm=(1&lt;&lt;K)-1,i,j,k,S;
	for (i=1;i&lt;=m;i++)
	{
		repack(a,state[i]);
		bool flag=false;
		for (j=2;j&lt;=K;j++) if (a[j]==a[1]) flag=true;
		for (S=0;S&lt;=mm;S++)
		{
			if (!flag&amp;&amp;!(S&amp;1)) continue;
			bool ttt=false;
			for (j=1;j&lt;=K;j++)
				for (k=1;k&lt;=K;k++) if (k!=j)
					if (a[j]==a[k]&amp;&amp;(S&amp;(1&lt;&lt;(j-1)))&amp;&amp;(S&amp;(1&lt;&lt;(k-1)))) ttt=true;
			if (ttt) continue;
			for (j=1;j&lt;K;j++) b[j]=a[j+1];
			b[K]=6;
			for (j=1;j&lt;=K;j++) if (S&amp;(1&lt;&lt;(j-1)))
				for (k=1;k&lt;K;k++)
					if (b[k]==a[j]) b[k]=b[K];
			trs[i][hao[pack(b)]]++;
		}
	}
}
bool dfs3(int v,int u,int fa)
{
	a[v]=u;
	for (int i=1;i&lt;=K;i++)
		if (i!=v&amp;&amp;go[v][i]&amp;&amp;i!=fa)
		{
			if (a[i]) return false;
			if (!dfs3(i,u,v)) return false;
		}
	return true;
}
int calc()
{
	memset(a,0,sizeof(a));
	for (int i=1;i&lt;=K;i++)
		if (!a[i]&amp;&amp;!dfs3(i,i,0)) return -1;
	return hao[pack(a)];
}
void dfs2(int t)
{
	if (t==K+1)
	{
		int t=calc();
		if (t&gt;=0) ans[1][t]++;
		return;
	}
	int mm=(1&lt;&lt;(t-1))-1;
	for (int S=0;S&lt;=mm;S++)
	{
		for (int i=1;i&lt;t;i++)
			if (S&amp;(1&lt;&lt;(i-1))) go[t][i]=go[i][t]=true;
		dfs2(t+1);
		for (int i=1;i&lt;t;i++)
			if (S&amp;(1&lt;&lt;(i-1))) go[t][i]=go[i][t]=false;
	}
}
int main()
{
	scanf(&quot;%d%lld&quot;,&amp;K,&amp;n);
	prepare();
	dfs2(1);
	ans=ans*(trs^(n-K));
	printf(&quot;%d\n&quot;,ans[1][1]);
	return 0;
}<pre><h2>Problem1494</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;map&gt;
using namespace std;
typedef long long LL;
#define mo 65521
int go[11][11];
int K,m,num,state[55],a[11],b[11];
LL n;
map&lt;int,int&gt; hao;
struct matrix
{
	int aa[55][55];
	matrix() {memset(aa,0,sizeof(aa));}
	int * operator [](int x) {return aa[x];}
	friend matrix operator *(matrix a,matrix b)
	{
		matrix c;
		for (int k=1;k&lt;=m;k++)
			for (int i=1;i&lt;=m;i++)
				for (int j=1;j&lt;=m;j++)
				{
					c[i][j]+=(LL)a[i][k]*b[k][j]%mo;
					if (c[i][j]&gt;=mo) c[i][j]-=mo;
				}
		return c;
	}
	friend matrix operator ^(matrix a,LL b)
	{
		matrix res;
		for (int i=1;i&lt;=m;i++) res[i][i]=1;
		for (;b;b&gt;&gt;=1,a=a*a)
			if (b&amp;1) res=res*a;
		return res;
	}
} trs,ans;
int pack(int *a)
{
	static int dy[11];
	memset(dy,-1,sizeof(dy));
	int res=0,cnt=0;
	for (int i=1;i&lt;=K;i++)
	{
		if (dy[a[i]]==-1) dy[a[i]]=++cnt;
		a[i]=dy[a[i]];
		res=res&lt;&lt;3|a[i];
	}
	return res;
}
void repack(int *a,int x)
{
	for (int i=K;i;i--)
	{
		a[i]=x&amp;7;
		x&gt;&gt;=3;
	}
}
void dfs(int t)
{
	if (t==K+1)
	{
		state[++m]=pack(a);
		hao[state[m]]=m;
		return;
	}
	for (int i=1;i&lt;=num;i++)
	{
		a[t]=i;
		dfs(t+1);
	}
	a[t]=++num;
	dfs(t+1);
	num--;
}
void prepare()
{
	m=0;num=0;
	dfs(1);
	int mm=(1&lt;&lt;K)-1,i,j,k,S;
	for (i=1;i&lt;=m;i++)
	{
		repack(a,state[i]);
		bool flag=false;
		for (j=2;j&lt;=K;j++) if (a[j]==a[1]) flag=true;
		for (S=0;S&lt;=mm;S++)
		{
			if (!flag&amp;&amp;!(S&amp;1)) continue;
			bool ttt=false;
			for (j=1;j&lt;=K;j++)
				for (k=1;k&lt;=K;k++) if (k!=j)
					if (a[j]==a[k]&amp;&amp;(S&amp;(1&lt;&lt;(j-1)))&amp;&amp;(S&amp;(1&lt;&lt;(k-1)))) ttt=true;
			if (ttt) continue;
			for (j=1;j&lt;K;j++) b[j]=a[j+1];
			b[K]=6;
			for (j=1;j&lt;=K;j++) if (S&amp;(1&lt;&lt;(j-1)))
				for (k=1;k&lt;K;k++)
					if (b[k]==a[j]) b[k]=b[K];
			trs[i][hao[pack(b)]]++;
		}
	}
}
bool dfs3(int v,int u,int fa)
{
	a[v]=u;
	for (int i=1;i&lt;=K;i++)
		if (i!=v&amp;&amp;go[v][i]&amp;&amp;i!=fa)
		{
			if (a[i]) return false;
			if (!dfs3(i,u,v)) return false;
		}
	return true;
}
int calc()
{
	memset(a,0,sizeof(a));
	for (int i=1;i&lt;=K;i++)
		if (!a[i]&amp;&amp;!dfs3(i,i,0)) return -1;
	return hao[pack(a)];
}
void dfs2(int t)
{
	if (t==K+1)
	{
		int t=calc();
		if (t&gt;=0) ans[1][t]++;
		return;
	}
	int mm=(1&lt;&lt;(t-1))-1;
	for (int S=0;S&lt;=mm;S++)
	{
		for (int i=1;i&lt;t;i++)
			if (S&amp;(1&lt;&lt;(i-1))) go[t][i]=go[i][t]=true;
		dfs2(t+1);
		for (int i=1;i&lt;t;i++)
			if (S&amp;(1&lt;&lt;(i-1))) go[t][i]=go[i][t]=false;
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%lld&quot;,&amp;K,&amp;n);
	prepare();
	dfs2(1);
	ans=ans*(trs^(n-K));
	printf(&quot;%d\n&quot;,ans[1][1]);
	return 0;
}<pre><h2>Problem1497</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf=999999999;
int aa[3000000][3],o[1000000],deep[1000000],q[1000000];
int head,tail,n,m,S,T,i,ans,tot=1;
int cost[1000000],a[1000000],b[1000000],c[1000000];
int min(int a,int b) {return a&lt;b?a:b;}
void addedge(int p,int q,int v)
{
    tot++;
    aa[tot][1]=q;
    aa[tot][2]=v;
    aa[tot][0]=o[p];
    o[p]=tot;
}
void add(int p,int q,int v)
{
    addedge(p,q,v);
    addedge(q,p,0);
}
void bfs()
{
    head=0,tail=0;
    memset(deep,0,sizeof(deep));
    deep[S]=1;
    q[++tail]=S;
    while (head&lt;tail)
    {
        int x=q[++head];
        int p=o[x];
        while (p)
        {
            int y=aa[p][1];
            if (!deep[y]&amp;&amp;aa[p][2])
            {
                deep[y]=deep[x]+1;
                q[++tail]=y;
            }
            p=aa[p][0];
        }
    }
}
int dfs(int v,int flow)
{
    if (v==T) return flow;
    int res=0,p=o[v];
    while (p)
    {
        int y=aa[p][1];
        if (deep[y]==deep[v]+1&amp;&amp;aa[p][2])
        {
            int tmp=dfs(y,min(flow,aa[p][2]));
            if (!tmp) deep[y]=inf;
            res+=tmp;
            flow-=tmp;
            aa[p][2]-=tmp;
            aa[p^1][2]+=tmp;
            if (!flow) break;
        }
        p=aa[p][0];
    }
    return res;
}
int main()
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for (i=1;i&lt;=n;scanf(&quot;%d&quot;,&amp;cost[i++]));
    for (ans=0,i=1;i&lt;=m;i++) scanf(&quot;%d%d%d&quot;,&amp;a[i],&amp;b[i],&amp;c[i]),ans+=c[i];
    tot=1;
    S=n+m+1,T=S+1;
    for (i=1;i&lt;=n;i++) add(S,i,cost[i]);
    for (i=1;i&lt;=m;i++)
    {
        add(a[i],i+n,inf);
        add(b[i],i+n,inf);
        add(i+n,T,c[i]);
    }
    bfs();
    while (deep[T])
    {
        ans-=dfs(S,inf);
        bfs();
    }
    printf(&quot;%d\n&quot;,ans);
    return 0;
}<pre><h2>Problem1499</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
using namespace std;
typedef pair&lt;int,int&gt; pii;
#define ln printf(&quot;\n&quot;)
#define fi first
#define se second
#define mp make_pair
#define inf 999999999
const int NN=211;
int f[NN][NN],b[NN],c[NN];
int n,m,x0,y0,K;
char a[NN][NN];
bool flag[NN];
void doit(int n,int L)
{
	static pii q[NN];
	int head=0,tail=0;
	for (int i=1;i&lt;=n;i++)
	{
		c[i]=b[i];
		if (flag[i])
		{
			while (head&lt;tail&amp;&amp;q[head+1].se&lt;i-L) head++;
			if (head&lt;tail) c[i]=max(c[i],q[head+1].fi+i);
			while (head&lt;tail&amp;&amp;q[tail].fi&lt;=b[i]-i) tail--;
			q[++tail]=mp(b[i]-i,i);
		}
		else head=tail=0;
	}
}
void work1(int L)
{
	int i,j;
	for (j=1;j&lt;=m;j++)
	{
		for (i=n;i;i--)
		{
			b[n-i+1]=f[i][j];
			flag[n-i+1]=(a[i][j]=='.');
		}
		doit(n,L);
		for (i=n;i;i--) f[i][j]=c[n-i+1];
	}
}
void work2(int L)
{
	int i,j;
	for (j=1;j&lt;=m;j++)
	{
		for (i=1;i&lt;=n;i++)
		{
			b[i]=f[i][j];
			flag[i]=(a[i][j]=='.');
		}
		doit(n,L);
		for (i=1;i&lt;=n;i++) f[i][j]=c[i];
	}
}
void work3(int L)
{
	int i,j;
	for (i=1;i&lt;=n;i++)
	{
		for (j=m;j;j--)
		{
			b[m-j+1]=f[i][j];
			flag[m-j+1]=(a[i][j]=='.');
		}
		doit(m,L);
		for (j=m;j;j--) f[i][j]=c[m-j+1];
	}
}
void work4(int L)
{
	int i,j;
	for (i=1;i&lt;=n;i++)
	{
		//printf(&quot;========= i=%d ========\n&quot;,i);
		for (j=1;j&lt;=m;j++)
		{
			b[j]=f[i][j];
			flag[j]=(a[i][j]=='.');
		}
		//printf(&quot;b &quot;);for (j=1;j&lt;=m;j++) printf(&quot;%d &quot;,b[j]);ln;
		doit(m,L);
		for (j=1;j&lt;=m;j++) f[i][j]=c[j];
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d%d%d\n&quot;,&amp;n,&amp;m,&amp;x0,&amp;y0,&amp;K);
	int i,j,x,y,z;
	for (i=1;i&lt;=n;i++)
	{
		for (j=1;j&lt;=m;j++) a[i][j]=getchar();
		getchar();
	}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++) f[i][j]=-inf;
	f[x0][y0]=0;
	//for(i=1;i&lt;=n;i++){for(j=1;j&lt;=m;j++)printf(&quot;%d &quot;,f[i][j]);ln;}ln;
	for (;K;K--)
	{
		//printf(&quot;\n-----------------------------------------------------------------------\n&quot;);
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		if (z==1) work1(y-x+1);
		else if (z==2) work2(y-x+1);
		else if (z==3) work3(y-x+1);
		else work4(y-x+1);
		//for(i=1;i&lt;=n;i++){for(j=1;j&lt;=m;j++)printf(&quot;%d &quot;,f[i][j]);ln;}ln;
	}
	int ans=0;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
			if (f[i][j]&gt;ans) ans=f[i][j];
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1499</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
using namespace std;
typedef pair&lt;int,int&gt; pii;
#define fi first
#define se second
#define mp make_pair
#define inf 999999999
const int NN=211;
int f[NN][NN],b[NN],c[NN];
int n,m,x0,y0,K;
char a[NN][NN];
bool flag[NN];
void doit(int n,int L)
{
	static pii q[NN];
	int head=0,tail=0;
	for (int i=1;i&lt;=n;i++)
	{
		c[i]=b[i];
		if (flag[i])
		{
			while (head&lt;tail&amp;&amp;q[head+1].se&lt;i-L) head++;
			if (head&lt;tail) c[i]=max(c[i],q[head+1].fi+i);
			while (head&lt;tail&amp;&amp;q[tail].fi&lt;=b[i]-i) tail--;
			q[++tail]=mp(b[i]-i,i);
		}
		else head=tail=0;
	}
}
void work1(int L)
{
	int i,j;
	for (j=1;j&lt;=m;j++)
	{
		for (i=n;i;i--)
		{
			b[n-i+1]=f[i][j];
			flag[n-i+1]=(a[i][j]=='.');
		}
		doit(n,L);
		for (i=n;i;i--) f[i][j]=c[n-i+1];
	}
}
void work2(int L)
{
	int i,j;
	for (j=1;j&lt;=m;j++)
	{
		for (i=1;i&lt;=n;i++)
		{
			b[i]=f[i][j];
			flag[i]=(a[i][j]=='.');
		}
		doit(n,L);
		for (i=1;i&lt;=n;i++) f[i][j]=c[i];
	}
}
void work3(int L)
{
	int i,j;
	for (i=1;i&lt;=n;i++)
	{
		for (j=m;j;j--)
		{
			b[m-j+1]=f[i][j];
			flag[m-j+1]=(a[i][j]=='.');
		}
		doit(m,L);
		for (j=m;j;j--) f[i][j]=c[m-j+1];
	}
}
void work4(int L)
{
	int i,j;
	for (i=1;i&lt;=n;i++)
	{
		for (j=1;j&lt;=m;j++)
		{
			b[j]=f[i][j];
			flag[j]=(a[i][j]=='.');
		}
		doit(m,L);
		for (j=1;j&lt;=m;j++) f[i][j]=c[j];
	}
}
int main()
{
	scanf(&quot;%d%d%d%d%d\n&quot;,&amp;n,&amp;m,&amp;x0,&amp;y0,&amp;K);
	int i,j,x,y,z;
	for (i=1;i&lt;=n;i++)
	{
		for (j=1;j&lt;=m;j++) a[i][j]=getchar();
		getchar();
	}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++) f[i][j]=-inf;
	f[x0][y0]=0;
	for (;K;K--)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		if (z==1) work1(y-x+1);
		else if (z==2) work2(y-x+1);
		else if (z==3) work3(y-x+1);
		else work4(y-x+1);
	}
	int ans=0;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
			if (f[i][j]&gt;ans) ans=f[i][j];
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1500</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
using namespace std;
const int mn=501000,inf=99999999;
int fa[mn],son[mn][2],S[mn],tag1[mn],sum[mn],maxl[mn],maxr[mn],tmax[mn],tree[mn],stack[mn],a[mn];
bool tag2[mn];
char ch;
int pos,n,i,x,tmp,top,size,root,m,c;
int max(int a,int b) {return a&gt;b?a:b;}
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
void make1(int t,int x)
{
	tag1[t]=tree[t]=x;
	sum[t]=x*S[t];
	if (x&gt;=0) tmax[t]=maxl[t]=maxr[t]=sum[t];
	else tmax[t]=x,maxl[t]=maxr[t]=0;
}
void make2(int t)
{
	tag2[t]=!tag2[t];
	swap(maxl[t],maxr[t]);
	swap(son[t][0],son[t][1]);
}
void pushdown(int t)
{
	if (!t) return;
	int x=son[t][0],y=son[t][1];
	if (tag1[t]!=-inf)
	{
		if (x) make1(x,tag1[t]);
		if (y) make1(y,tag1[t]);
		tag1[t]=-inf;
	}
	if (tag2[t])
	{
		if (x) make2(x);
		if (y) make2(y);
		tag2[t]=0;
	}
}
void update(int t)
{
	if (t==0) return;
	int x=son[t][0],y=son[t][1];
	S[t]=S[x]+S[y]+1;
	sum[t]=sum[x]+sum[y]+tree[t];
	maxl[t]=max(0,max(maxl[x],sum[x]+tree[t]+maxl[y]));
	maxr[t]=max(0,max(maxr[y],sum[y]+tree[t]+maxr[x]));
	tmax[t]=max(max(tmax[x],tmax[y]),maxr[x]+tree[t]+maxl[y]);
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
}
int find(int t,int x)
{
	for (;t;)
	{
		pushdown(t);
		if (x==S[son[t][0]]+1) return t;
		if (x&lt;=S[son[t][0]]) t=son[t][0];
		else x-=(S[son[t][0]]+1),t=son[t][1];
	}
}
int build(int ll,int rr)
{
	int t=top&gt;0?stack[top--]:++size;
	int mid=(ll+rr)&gt;&gt;1;
	tree[t]=a[mid-1];
	maxl[t]=maxr[t]=tree[t];
	if (tree[t]&lt;0) maxl[t]=maxr[t]=0;
	tag1[t]=-inf;
	tag2[t]=0;
	if (ll&lt;mid) son[t][0]=build(ll,mid-1),fa[son[t][0]]=t;
	if (mid&lt;rr) son[t][1]=build(mid+1,rr),fa[son[t][1]]=t;
	update(t);
	return t;
}
void free(int t)
{
	pushdown(t);
	stack[++top]=t;
	fa[t]=S[t]=sum[t]=0,maxl[t]=maxr[t]=tmax[t]=tree[t]=-inf,tag1[t]=-inf,tag2[t]=0;
	if (son[t][0]) free(son[t][0]);
	if (son[t][1]) free(son[t][1]);
	son[t][0]=son[t][1]=0;
}
void zhong(int t)
{
	if (t==0) return;
	pushdown(t);
	zhong(son[t][0]);
	printf(&quot;%d &quot;,tree[t]);
	zhong(son[t][1]);
}
int main()
{
	//freopen(&quot;1500.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;1500.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;scanf(&quot;%d&quot;,&amp;a[i++]));
	a[0]=a[n+1]=-inf;
	tmax[0]=-inf;
	root=build(1,n+2);
	for (;m;m--)
	{
		//printf(&quot;\n--------------------------------------------\n&quot;);
		//zhong(root);printf(&quot;\n&quot;);
		scanf(&quot;\n&quot;);
		ch=getchar();
		if (ch=='M')
		{
			ch=getchar(),ch=getchar();
			if (ch=='X')
			{
				for (i=1;i&lt;=4;i++) ch=getchar();
				printf(&quot;%d\n&quot;,tmax[root]);
			}
			else
			{
				for (i=1;i&lt;=6;i++) ch=getchar();
				scanf(&quot;%d%d%d&quot;,&amp;pos,&amp;n,&amp;c);
				++pos;
				int x=find(root,pos-1);
				splay(x,0);
				x=find(root,pos+n);
				splay(x,root);
				x=son[x][0];
				make1(x,c);
				splay(x,0);
			}
		}
		else if (ch=='I')
		{
			for (i=1;i&lt;=5;i++) ch=getchar();
			scanf(&quot;%d%d&quot;,&amp;pos,&amp;n);
			++pos;
			for (i=1;i&lt;=n;scanf(&quot;%d&quot;,&amp;a[i++]));
			tmp=build(2,n+1);
			int x=find(root,pos);
			splay(x,0);
			x=find(root,pos+1);
			splay(x,root);
			son[x][0]=tmp;
			fa[tmp]=x;
			splay(tmp,0);
		}
		else if (ch=='D')
		{
			for (i=1;i&lt;=5;i++) ch=getchar();
			scanf(&quot;%d%d&quot;,&amp;pos,&amp;n);
			++pos;
			int x=find(root,pos-1);
			splay(x,0);
			x=find(root,pos+n);
			splay(x,root);
			int y=x;
			x=son[x][0];
			fa[x]=0;
			son[y][0]=0;
			free(x);
			splay(y,0);
		}
		else if (ch=='R')
		{
			for (i=1;i&lt;=6;i++) ch=getchar();
			scanf(&quot;%d%d&quot;,&amp;pos,&amp;n);
			++pos;
			int x=find(root,pos-1);
			splay(x,0);
			x=find(root,pos+n);
			splay(x,root);
			x=son[x][0];
			make2(x);
			splay(x,0);
		}
		else
		{
			for (i=1;i&lt;=6;i++) ch=getchar();
			scanf(&quot;%d%d&quot;,&amp;pos,&amp;n);
			++pos;
			int x=find(root,pos-1);
			splay(x,0);
			x=find(root,pos+n);
			splay(x,root);
			x=son[x][0];
			printf(&quot;%d\n&quot;,sum[x]);
		}
	}
	return 0;
}<pre><h2>Problem1500</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
using namespace std;
const int mn=501000,inf=99999999;
int fa[mn],son[mn][2],S[mn],tag1[mn],sum[mn],maxl[mn],maxr[mn],tmax[mn],tree[mn],stack[mn],a[mn];
bool tag2[mn];
char ch;
int pos,n,i,x,tmp,top,size,root,m,c;
int max(int a,int b) {return a&gt;b?a:b;}
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
void make1(int t,int x)
{
	tag1[t]=tree[t]=x;
	sum[t]=x*S[t];
	if (x&gt;=0) tmax[t]=maxl[t]=maxr[t]=sum[t];
	else tmax[t]=x,maxl[t]=maxr[t]=0;
}
void make2(int t)
{
	tag2[t]=!tag2[t];
	swap(maxl[t],maxr[t]);
	swap(son[t][0],son[t][1]);
}
void pushdown(int t)
{
	if (!t) return;
	int x=son[t][0],y=son[t][1];
	if (tag1[t]!=-inf)
	{
		if (x) make1(x,tag1[t]);
		if (y) make1(y,tag1[t]);
		tag1[t]=-inf;
	}
	if (tag2[t])
	{
		if (x) make2(x);
		if (y) make2(y);
		tag2[t]=0;
	}
}
void update(int t)
{
	if (t==0) return;
	int x=son[t][0],y=son[t][1];
	S[t]=S[x]+S[y]+1;
	sum[t]=sum[x]+sum[y]+tree[t];
	maxl[t]=max(0,max(maxl[x],sum[x]+tree[t]+maxl[y]));
	maxr[t]=max(0,max(maxr[y],sum[y]+tree[t]+maxr[x]));
	tmax[t]=max(max(tmax[x],tmax[y]),maxr[x]+tree[t]+maxl[y]);
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
}
int find(int t,int x)
{
	for (;t;)
	{
		pushdown(t);
		if (x==S[son[t][0]]+1) return t;
		if (x&lt;=S[son[t][0]]) t=son[t][0];
		else x-=(S[son[t][0]]+1),t=son[t][1];
	}
}
int build(int ll,int rr)
{
	int t=top&gt;0?stack[top--]:++size;
	int mid=(ll+rr)&gt;&gt;1;
	tree[t]=a[mid-1];
	maxl[t]=maxr[t]=tree[t];
	if (tree[t]&lt;0) maxl[t]=maxr[t]=0;
	tag1[t]=-inf;
	tag2[t]=0;
	if (ll&lt;mid) son[t][0]=build(ll,mid-1),fa[son[t][0]]=t;
	if (mid&lt;rr) son[t][1]=build(mid+1,rr),fa[son[t][1]]=t;
	update(t);
	return t;
}
void free(int t)
{
	pushdown(t);
	stack[++top]=t;
	fa[t]=S[t]=sum[t]=0,maxl[t]=maxr[t]=tmax[t]=tree[t]=-inf,tag1[t]=-inf,tag2[t]=0;
	if (son[t][0]) free(son[t][0]);
	if (son[t][1]) free(son[t][1]);
	son[t][0]=son[t][1]=0;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;scanf(&quot;%d&quot;,&amp;a[i++]));
	a[0]=a[n+1]=-inf;
	tmax[0]=-inf;
	root=build(1,n+2);
	for (;m;m--)
	{
		scanf(&quot;\n%c&quot;,&amp;ch);
		if (ch=='M')
		{
			ch=getchar(),ch=getchar();
			if (ch=='X')
			{
				for (i=1;i&lt;=4;i++) scanf(&quot;%c&quot;,&amp;ch);
				printf(&quot;%d\n&quot;,tmax[root]);
			}
			else
			{
				for (i=1;i&lt;=6;i++) scanf(&quot;%c&quot;,&amp;ch);
				scanf(&quot;%d%d%d&quot;,&amp;pos,&amp;n,&amp;c);
				++pos;
				int x=find(root,pos-1);
				splay(x,0);
				x=find(root,pos+n);
				splay(x,root);
				x=son[x][0];
				make1(x,c);
				splay(x,0);
			}
		}
		else if (ch=='I')
		{
			for (i=1;i&lt;=5;i++) scanf(&quot;%c&quot;,&amp;ch);
			scanf(&quot;%d%d&quot;,&amp;pos,&amp;n);
			++pos;
			for (i=1;i&lt;=n;scanf(&quot;%d&quot;,&amp;a[i++]));
			tmp=build(2,n+1);
			int x=find(root,pos);
			splay(x,0);
			x=find(root,pos+1);
			splay(x,root);
			son[x][0]=tmp;
			fa[tmp]=x;
			splay(tmp,0);
		}
		else if (ch=='D')
		{
			for (i=1;i&lt;=5;i++) scanf(&quot;%c&quot;,&amp;ch);
			scanf(&quot;%d%d&quot;,&amp;pos,&amp;n);
			++pos;
			int x=find(root,pos-1);
			splay(x,0);
			x=find(root,pos+n);
			splay(x,root);
			int y=x;
			x=son[x][0];
			fa[x]=0;
			son[y][0]=0;
			free(x);
			splay(y,0);
		}
		else if (ch=='R')
		{
			for (i=1;i&lt;=6;i++) scanf(&quot;%c&quot;,&amp;ch);
			scanf(&quot;%d%d&quot;,&amp;pos,&amp;n);
			++pos;
			int x=find(root,pos-1);
			splay(x,0);
			x=find(root,pos+n);
			splay(x,root);
			x=son[x][0];
			make2(x);
			splay(x,0);
		}
		else
		{
			for (i=1;i&lt;=6;i++) scanf(&quot;%c&quot;,&amp;ch);
			scanf(&quot;%d%d&quot;,&amp;pos,&amp;n);
			++pos;
			int x=find(root,pos-1);
			splay(x,0);
			x=find(root,pos+n);
			splay(x,root);
			x=son[x][0];
			printf(&quot;%d\n&quot;,sum[x]);
		}
	}
	return 0;
}<pre><h2>Problem1500</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
using namespace std;
const int mn=501000,inf=99999999;
int fa[mn],son[mn][2],S[mn],tag1[mn],sum[mn],maxl[mn],maxr[mn],tmax[mn],tree[mn],stack[mn],a[mn];
bool tag2[mn];
char ch;
int pos,n,i,x,tmp,top,size,root,m,c;
int max(int a,int b) {return a&gt;b?a:b;}
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
void make1(int t,int x)
{
	tag1[t]=tree[t]=x;
	sum[t]=x*S[t];
	if (x&gt;=0) tmax[t]=maxl[t]=maxr[t]=sum[t];
	else tmax[t]=x,maxl[t]=maxr[t]=0;
}
void make2(int t)
{
	tag2[t]=!tag2[t];
	swap(maxl[t],maxr[t]);
	swap(son[t][0],son[t][1]);
}
void pushdown(int t)
{
	if (!t) return;
	int x=son[t][0],y=son[t][1];
	if (tag1[t]!=-inf)
	{
		if (x) make1(x,tag1[t]);
		if (y) make1(y,tag1[t]);
		tag1[t]=-inf;
	}
	if (tag2[t])
	{
		if (x) make2(x);
		if (y) make2(y);
		tag2[t]=0;
	}
}
void update(int t)
{
	if (t==0) return;
	int x=son[t][0],y=son[t][1];
	S[t]=S[x]+S[y]+1;
	sum[t]=sum[x]+sum[y]+tree[t];
	maxl[t]=max(maxl[x],sum[x]+tree[t]);
	maxl[t]=max(max(maxl[t],sum[x]+tree[t]+maxl[y]),0);
	maxr[t]=max(maxr[y],sum[y]+tree[t]);
	maxr[t]=max(max(maxr[t],sum[y]+tree[t]+maxr[x]),0);
	tmax[t]=max(max(tmax[x],tmax[y]),maxr[x]+tree[t]+maxl[y]);
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
}
int find(int t,int x)
{
	for (;t;)
	{
		pushdown(t);
		if (x==S[son[t][0]]+1) return t;
		if (x&lt;=S[son[t][0]]) t=son[t][0];
		else x-=(S[son[t][0]]+1),t=son[t][1];
	}
}
int build(int ll,int rr)
{
	int t=top&gt;0?stack[top--]:++size;
	int mid=(ll+rr)&gt;&gt;1;
	tree[t]=a[mid-1];
	maxl[t]=maxr[t]=tree[t];
	if (tree[t]&lt;0) maxl[t]=maxr[t]=0;
	tag1[t]=-inf;
	tag2[t]=0;
	if (ll&lt;mid) son[t][0]=build(ll,mid-1),fa[son[t][0]]=t;
	if (mid&lt;rr) son[t][1]=build(mid+1,rr),fa[son[t][1]]=t;
	update(t);
	return t;
}
void free(int t)
{
	stack[++top]=t;
	fa[t]=0,tag1[t]=-inf,tag2[t]=0;
	if (son[t][0]) free(son[t][0]);
	if (son[t][1]) free(son[t][1]);
	son[t][0]=son[t][1]=0;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;scanf(&quot;%d&quot;,&amp;a[i++]));
	a[0]=a[n+1]=-inf;
	tmax[0]=-inf;
	root=build(1,n+2);
	for (;m;m--)
	{
		scanf(&quot;\n%c&quot;,&amp;ch);
		if (ch=='M')
		{
			ch=getchar(),ch=getchar();
			if (ch=='X')
			{
				for (i=1;i&lt;=4;i++) scanf(&quot;%c&quot;,&amp;ch);
				printf(&quot;%d\n&quot;,tmax[root]);
			}
			else
			{
				for (i=1;i&lt;=6;i++) scanf(&quot;%c&quot;,&amp;ch);
				scanf(&quot;%d%d%d&quot;,&amp;pos,&amp;n,&amp;c);
				++pos;
				int x=find(root,pos-1);
				splay(x,0);
				x=find(root,pos+n);
				splay(x,root);
				x=son[x][0];
				make1(x,c);
				splay(x,0);
			}
		}
		else if (ch=='I')
		{
			for (i=1;i&lt;=5;i++) scanf(&quot;%c&quot;,&amp;ch);
			scanf(&quot;%d%d&quot;,&amp;pos,&amp;n);
			++pos;
			for (i=1;i&lt;=n;scanf(&quot;%d&quot;,&amp;a[i++]));
			tmp=build(2,n+1);
			int x=find(root,pos);
			splay(x,0);
			x=find(root,pos+1);
			splay(x,root);
			son[x][0]=tmp;
			fa[tmp]=x;
			splay(tmp,0);
		}
		else if (ch=='D')
		{
			for (i=1;i&lt;=5;i++) scanf(&quot;%c&quot;,&amp;ch);
			scanf(&quot;%d%d&quot;,&amp;pos,&amp;n);
			++pos;
			int x=find(root,pos-1);
			splay(x,0);
			x=find(root,pos+n);
			splay(x,root);
			int y=x;
			x=son[x][0];
			fa[x]=0;
			son[y][0]=0;
			free(x);
			splay(y,0);
		}
		else if (ch=='R')
		{
			for (i=1;i&lt;=6;i++) scanf(&quot;%c&quot;,&amp;ch);
			scanf(&quot;%d%d&quot;,&amp;pos,&amp;n);
			++pos;
			int x=find(root,pos-1);
			splay(x,0);
			x=find(root,pos+n);
			splay(x,root);
			x=son[x][0];
			make2(x);
			splay(x,0);
		}
		else
		{
			for (i=1;i&lt;=6;i++) scanf(&quot;%c&quot;,&amp;ch);
			scanf(&quot;%d%d&quot;,&amp;pos,&amp;n);
			++pos;
			int x=find(root,pos-1);
			splay(x,0);
			x=find(root,pos+n);
			splay(x,root);
			x=son[x][0];
			printf(&quot;%d\n&quot;,sum[x]);
		}
	}
	return 0;
}<pre><h2>Problem1500</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
using namespace std;
const int mn=501000,inf=99999999;
int fa[mn],son[mn][2],S[mn],tag1[mn],sum[mn],maxl[mn],maxr[mn],tmax[mn],tree[mn],stack[mn],a[mn];
bool tag2[mn];
char ch;
int pos,n,i,x,tmp,top,size,root,m,c;
int max(int a,int b) {return a&gt;b?a:b;}
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
void make1(int t,int x)
{
	tag1[t]=tree[t]=x;
	sum[t]=x*S[t];
	if (x&gt;=0) tmax[t]=maxl[t]=maxr[t]=sum[t];
	else tmax[t]=x,maxl[t]=maxr[t]=0;
}
void make2(int t)
{
	tag2[t]=!tag2[t];
	swap(maxl[t],maxr[t]);
	swap(son[t][0],son[t][1]);
}
void pushdown(int t)
{
	int x=son[t][0],y=son[t][1];
	if (tag1[t]!=-inf)
	{
		if (x) make1(x,tag1[t]);
		if (y) make1(y,tag1[t]);
		tag1[t]=-inf;
	}
	if (tag2[t])
	{
		if (x) make2(x);
		if (y) make2(y);
		tag2[t]=0;
	}
}
void update(int t)
{
	int x=son[t][0],y=son[t][1];
	S[t]=S[x]+S[y]+1;
	sum[t]=sum[x]+sum[y]+tree[t];
	maxl[t]=max(maxl[x],sum[x]+tree[t]);
	maxl[t]=max(max(maxl[t],sum[x]+tree[t]+maxl[y]),0);
	maxr[t]=max(maxr[y],sum[y]+tree[t]);
	maxr[t]=max(max(maxr[t],sum[y]+tree[t]+maxr[x]),0);
	tmax[t]=max(max(tmax[x],tmax[y]),maxr[x]+tree[t]+maxl[y]);
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
}
int find(int t,int x)
{
	for (;t;)
	{
		pushdown(t);
		if (x==S[son[t][0]]+1) return t;
		if (x&lt;=S[son[t][0]]) t=son[t][0];
		else x-=(S[son[t][0]]+1),t=son[t][1];
	}
}
int build(int ll,int rr)
{
	int t=top&gt;0?stack[top--]:++size;
	int mid=(ll+rr)&gt;&gt;1;
	tree[t]=a[mid-1];
	maxl[t]=maxr[t]=tree[t];
	if (tree[t]&lt;0) maxl[t]=maxr[t]=0;
	tag1[t]=-inf;
	tag2[t]=0;
	if (ll&lt;mid) son[t][0]=build(ll,mid-1),fa[son[t][0]]=t;
	if (mid&lt;rr) son[t][1]=build(mid+1,rr),fa[son[t][1]]=t;
	update(t);
	return t;
}
void free(int t)
{
	stack[++top]=t;
	fa[t]=0,tag1[t]=-inf,tag2[t]=0;
	if (son[t][0]) free(son[t][0]);
	if (son[t][1]) free(son[t][1]);
	son[t][0]=son[t][1]=0;
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;scanf(&quot;%d&quot;,&amp;a[i++]));
	a[0]=a[n+1]=-inf;
	tmax[0]=-inf;
	root=build(1,n+2);
	for (;m;m--)
	{
		scanf(&quot;\n%c&quot;,&amp;ch);
		if (ch=='M')
		{
			ch=getchar(),ch=getchar();
			if (ch=='X')
			{
				for (i=1;i&lt;=4;i++) scanf(&quot;%c&quot;,&amp;ch);
				printf(&quot;%d\n&quot;,tmax[root]);
			}
			else
			{
				for (i=1;i&lt;=6;i++) scanf(&quot;%c&quot;,&amp;ch);
				scanf(&quot;%d%d%d&quot;,&amp;pos,&amp;n,&amp;c);
				++pos;
				int x=find(root,pos-1);
				splay(x,0);
				x=find(root,pos+n);
				splay(x,root);
				x=son[x][0];
				make1(x,c);
				splay(x,0);
			}
		}
		else if (ch=='I')
		{
			for (i=1;i&lt;=5;i++) scanf(&quot;%c&quot;,&amp;ch);
			scanf(&quot;%d%d&quot;,&amp;pos,&amp;n);
			++pos;
			for (i=1;i&lt;=n;scanf(&quot;%d&quot;,&amp;a[i++]));
			tmp=build(2,n+1);
			int x=find(root,pos);
			splay(x,0);
			x=find(root,pos+1);
			splay(x,root);
			son[x][0]=tmp;
			fa[tmp]=x;
			splay(tmp,0);
		}
		else if (ch=='D')
		{
			for (i=1;i&lt;=5;i++) scanf(&quot;%c&quot;,&amp;ch);
			scanf(&quot;%d%d&quot;,&amp;pos,&amp;n);
			++pos;
			int x=find(root,pos-1);
			splay(x,0);
			x=find(root,pos+n);
			splay(x,root);
			int y=x;
			x=son[x][0];
			fa[x]=0;
			son[y][0]=0;
			free(x);
			splay(y,0);
		}
		else if (ch=='R')
		{
			for (i=1;i&lt;=6;i++) scanf(&quot;%c&quot;,&amp;ch);
			scanf(&quot;%d%d&quot;,&amp;pos,&amp;n);
			++pos;
			int x=find(root,pos-1);
			splay(x,0);
			x=find(root,pos+n);
			splay(x,root);
			x=son[x][0];
			make2(x);
			splay(x,0);
		}
		else
		{
			for (i=1;i&lt;=6;i++) scanf(&quot;%c&quot;,&amp;ch);
			scanf(&quot;%d%d&quot;,&amp;pos,&amp;n);
			++pos;
			int x=find(root,pos-1);
			splay(x,0);
			x=find(root,pos+n);
			splay(x,root);
			x=son[x][0];
			printf(&quot;%d\n&quot;,sum[x]);
		}
	}
	return 0;
}<pre><h2>Problem1502</h2><pre>#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
const double eps=1e-6;
const int maxn=510;
double x[maxn],y[maxn],fx1[maxn],fy1[maxn],fx2[maxn],fy2[maxn],R[maxn],k[maxn];
bool can[maxn];
int n;
double sqr(double xx) {return xx*xx;}
double max(double xx,double yy) {return (xx&gt;yy?xx:yy);}
double calc(double pos)
{
    double mmax=0;
    for (int i=1;i&lt;=n;i++)
    {
        if (fabs(x[i]-pos)&lt;R[i]) mmax=max(mmax,sqrt(sqr(R[i])-sqr(x[i]-pos)));
        if (can[i]&amp;&amp;fx1[i]&lt;pos&amp;&amp;fx2[i]&gt;pos) mmax=max(mmax,k[i]*(pos-fx1[i])+fy1[i]);
    }
    return mmax;
}
double simpson(double l,double r,double fl,double fmid,double fr)
{
    return ((r-l)/6*(fl+4*fmid+fr));
}
double S(double l,double fl,double mid,double fmid,double r,double fr,double pres)
{
	//printf(&quot;%.3f %.3f\n&quot;,l,r);
    double lm=(l+mid)/2,flm=calc(lm),rm=(mid+r)/2,frm=calc(rm);
    double ls=simpson(l,mid,fl,flm,fmid),rs=simpson(mid,r,fmid,frm,fr);
    if (fabs(pres-ls-rs)&lt;eps) return pres;
    return (S(l,fl,lm,flm,mid,fmid,ls)+S(mid,fmid,rm,frm,r,fr,rs));
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
    double alp,l,r,h=0,dd;
    int i;
    scanf(&quot;%d%lf&quot;,&amp;n,&amp;alp);
    alp=1/tan(alp);
    for (i=1;i&lt;=n+1;i++)
    {
        scanf(&quot;%lf&quot;,&amp;dd);
        h+=dd;
        x[i]=h*alp;
    }
    l=r=x[n+1];
    for (i=1;i&lt;=n;i++)
    {
        scanf(&quot;%lf&quot;,&amp;R[i]);
        if (x[i]-R[i]&lt;l) l=x[i]-R[i];
        if (x[i]+R[i]&gt;r) r=x[i]+R[i];
    }
    for (i=1;i&lt;=n;i++)
    {
        if (x[i+1]-x[i]&gt;fabs(R[i+1]-R[i])) can[i]=true; else continue;
        dd=(R[i+1]-R[i])/(x[i+1]-x[i]);
        fx1[i]=x[i]-dd*R[i],fy1[i]=sqrt(sqr(R[i])-sqr(x[i]-fx1[i]));
        fx2[i]=x[i+1]-dd*R[i+1],fy2[i]=sqrt(sqr(R[i+1])-sqr(x[i+1]-fx2[i]));
        k[i]=(fy2[i]-fy1[i])/(fx2[i]-fx1[i]);
    }
    double fl=0,fr=0,mid=(l+r)/2,fmid=calc(mid);
    printf(&quot;%.2f\n&quot;,S(l,fl,mid,fmid,r,fr,simpson(l,r,fl,fmid,fr))*2);
    return 0;
}
<pre><h2>Problem1502</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;iostream&gt;
using namespace std;
#define DB double
#define eps 1e-6
#define inf 99999999
const DB pai=acos(-1);
int n,i;
DB x[510],r[510],a[510],alfa,h[510],kk[510],bb[510];
struct point
{
	DB x,y;
	friend point operator +(point a,point b) {a.x+=b.x,a.y+=b.y;return a;}
};
point rotate(point P,DB sita)
{
	DB x0=P.x,y0=P.y;
	point tmp;
	tmp.x=x0*cos(sita)-y0*sin(sita);
	tmp.y=y0*cos(sita)+x0*sin(sita);
	return tmp;
}
DB f(DB m)
{
	int i;
	DB res=0,tmp;
	for (i=1;i&lt;=n;i++)
		if (r[i]-fabs(x[i]-m)&gt;eps)
		{
			tmp=fabs(x[i]-m);
			res=max(res,sqrt(r[i]*r[i]-tmp*tmp));
		}
	for (i=1;i&lt;n;i++)
	{
		tmp=r[i]*cos(a[i]);
		if (x[i]+tmp-m&gt;eps) continue;
		tmp=r[i+1]*cos(a[i]);
		if (x[i+1]+tmp-m&lt;eps) continue;
		res=max(res,kk[i]*m+bb[i]);
	}
	return res*2;
}
DB simpson(DB l,DB r,DB fl,DB fr,DB fmid) {return (r-l)*(fl+4*fmid+fr)/6;}
DB S(DB l,DB fl,DB r,DB fr,DB mid,DB fmid,DB pres)
{
	DB lmid=(l+mid)/2,rmid=(mid+r)/2;
	DB flmid=f(lmid),frmid=f(rmid);
	DB lS=simpson(l,mid,fl,fmid,flmid),rS=simpson(mid,r,fmid,fr,frmid);
	if (fabs(pres-lS-rS)&lt;eps) return pres;
	return S(l,fl,mid,fmid,lmid,flmid,lS)+S(mid,fmid,r,fr,rmid,frmid,rS);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	double asd;
	scanf(&quot;%d%lf&quot;,&amp;n,&amp;asd),alfa=(DB)asd;
	for (i=1;i&lt;=n+1;i++) scanf(&quot;%lf&quot;,&amp;asd),h[i]=(DB)asd;
	for (i=1;i&lt;=n;i++) scanf(&quot;%lf&quot;,&amp;asd),r[i]=(DB)asd;
	r[++n]=0;
	DB tmp=h[1],ll,rr;
	for (i=1;i&lt;=n;tmp+=h[++i]) x[i]=tmp/tan(alfa);
	for (i=1;i&lt;n;i++) a[i]=acos((r[i]-r[i+1])/(x[i+1]-x[i]));
	for (ll=inf,rr=-inf,i=1;i&lt;=n;i++)
	{
		ll=min(ll,x[i]-r[i]);
		rr=max(rr,x[i]+r[i]);
	}
	point P;
	for (i=1;i&lt;n;i++)
	{
		kk[i]=tan(pai/2+a[i]);
		P.x=r[i],P.y=0;
		P=rotate(P,a[i]);
		P.x+=x[i];
		bb[i]=P.y-P.x*kk[i];
	}
	DB fl=0,fr=0,mid=(ll+rr)/2,fmid=f(mid);
	//printf(&quot;asdasd %.3f %.3f\n&quot;,(DB)ll,rr);
	printf(&quot;%.2f\n&quot;,(double)S(ll,fl,rr,fr,mid,fmid,simpson(ll,rr,fl,fr,fmid)));
}
<pre><h2>Problem1502</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;iostream&gt;
using namespace std;
#define DB double
#define eps 1e-6
#define inf 99999999
const DB pai=acos(-1);
int n,i;
DB x[510],r[510],a[510],alfa,h[510],kk[510],bb[510];
struct point
{
	DB x,y;
	friend point operator +(point a,point b) {a.x+=b.x,a.y+=b.y;return a;}
};
point rotate(point P,DB sita)
{
	DB x0=P.x,y0=P.y;
	point tmp;
	tmp.x=x0*cos(sita)-y0*sin(sita);
	tmp.y=y0*cos(sita)+x0*sin(sita);
	return tmp;
}
DB f(DB m)
{
	int i;
	DB res=0,tmp;
	for (i=1;i&lt;=n;i++)
		if (r[i]-fabs(x[i]-m)&gt;eps)
		{
			tmp=fabs(x[i]-m);
			res=max(res,sqrt(r[i]*r[i]-tmp*tmp));
		}
	for (i=1;i&lt;n;i++)
	{
		tmp=r[i]*cos(a[i]);
		if (x[i]+tmp-m&gt;eps) continue;
		tmp=r[i+1]*cos(a[i]);
		if (x[i+1]+tmp-m&lt;eps) continue;
		res=max(res,kk[i]*m+bb[i]);
	}
	return res*2;
}
DB simpson(DB l,DB r,DB fl,DB fr,DB fmid) {return (r-l)*(fl+4*fmid+fr)/6;}
DB S(DB l,DB fl,DB r,DB fr,DB mid,DB fmid,DB pres)
{
	DB lmid=(l+mid)/2,rmid=(mid+r)/2;
	DB flmid=f(lmid),frmid=f(rmid);
	DB lS=simpson(l,mid,fl,fmid,flmid),rS=simpson(mid,r,fmid,fr,frmid);
	if (fabs(pres-lS-rS)&lt;eps) return pres;
	return S(l,fl,mid,fmid,lmid,flmid,lS)+S(mid,fmid,r,fr,rmid,frmid,rS);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	double asd;
	scanf(&quot;%d%lf&quot;,&amp;n,&amp;asd),alfa=(DB)asd;
	for (i=1;i&lt;=n+1;i++) scanf(&quot;%lf&quot;,&amp;asd),h[i]=(DB)asd;
	for (i=1;i&lt;=n;i++) scanf(&quot;%lf&quot;,&amp;asd),r[i]=(DB)asd;
	r[++n]=0;
	DB tmp=h[1],ll,rr;
	for (i=1;i&lt;=n;tmp+=h[++i]) x[i]=tmp/tan(alfa);
	for (i=1;i&lt;n;i++) a[i]=acos((r[i]-r[i+1])/(x[i+1]-x[i]));
	for (ll=inf,rr=-inf,i=1;i&lt;=n;i++)
	{
		ll=min(ll,x[i]-r[i]);
		rr=max(rr,x[i]+r[i]);
	}
	point P;
	for (i=1;i&lt;n;i++)
	{
		kk[i]=tan(pai/2+a[i]);
		P.x=r[i],P.y=0;
		P=rotate(P,a[i]);
		P.x+=x[i];
		bb[i]=P.y-P.x*kk[i];
	}
	DB fl=0,fr=0,mid=(ll+rr)/2,fmid=f(mid);
	printf(&quot;%.2f\n&quot;,(double)S(ll,fl,rr,fr,mid,fmid,simpson(ll,rr,fl,fr,fmid)));
}
<pre><h2>Problem1503</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int fa[200000],key[200000],son[200000][2],num[200000],S[200000];
char ch;
int n,x,ans,root,size,minx,t,ttt;
int dd(int x)
{
	if (x==-1)
	{
		return -1;
	}
	return x+ttt-minx;
}
void update(int t)
{
	S[t]=S[son[t][0]]+S[son[t][1]]+num[t];
}
void rotate(int t,int p)
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(t,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(t,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
	update(t);
}
void ins(int &amp;t,int x,int ff)
{
	if (t==0)
	{
		t=++size;
		fa[t]=ff;
		S[t]=num[t]=1;
		son[t][0]=son[t][1]=0;
		key[t]=x;
		splay(t,0);
		return;
	}
	++S[t];
	if (x==key[t]) ++num[t],splay(t,0);
	else if (x&lt;key[t]) ins(son[t][0],x,t);
	else ins(son[t][1],x,t);
}
int pred(int t,int x)
{
	int res=-1;
	for (;t;)
		if (key[t]&lt;x) res=t,t=son[t][1];
		else t=son[t][0];
	return res;
}
int select(int t,int x)
{
	for (;t;)
	{
		if (x&gt;S[t]||x&lt;1)
		{
			return -1;
		}
		if (x&gt;S[son[t][0]]&amp;&amp;x&lt;=S[son[t][0]]+num[t]) return key[t];
		if (x&lt;=S[son[t][0]]) t=son[t][0];
		else x-=(S[son[t][0]]+num[t]),t=son[t][1];
	}
	return -1;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;minx);
	ttt=minx;
	for (ans=0;n;n--)
	{
		//printf(&quot;--------------------------\n&quot;);
		//printf(&quot;%d\n&quot;,root);
		ch=getchar();
		scanf(&quot;%d\n&quot;,&amp;x);
		if (ch=='I')
		{
			x=x+minx-ttt;
			if (x&lt;minx) continue;
			else ins(root,x,0);
		}
		else if (ch=='A') minx-=x;
		else if (ch=='S')
		{
			minx+=x;
			t=pred(root,minx);
			if (t==-1) continue;
			//printf(&quot;%d\n&quot;,dd(key[t]));
			splay(t,0);
			ans+=S[son[root][0]]+num[root];
			root=son[root][1];
			fa[root]=0;
		}
		else printf(&quot;%d\n&quot;,dd(select(root,S[root]-x+1)));
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1503</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int fa[200000],key[200000],son[200000][2],num[200000],S[200000];
char ch;
int n,x,ans,root,size,minx,t,ttt;
int dd(int x)
{
	if (x==-1)
	{
		return -1;
	}
	return x+ttt-minx;
}
void update(int t)
{
	S[t]=S[son[t][0]]+S[son[t][1]]+num[t];
}
void rotate(int t,int p)
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y);
	update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(t,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(t,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
}
void ins(int &amp;t,int x,int ff)
{
	if (t==0)
	{
		t=++size;
		fa[t]=ff;
		S[t]=num[t]=1;
		son[t][0]=son[t][1]=0;
		key[t]=x;
		splay(t,0);
		return;
	}
	++S[t];
	if (x==key[t]) ++num[t],splay(t,0);
	else if (x&lt;key[t]) ins(son[t][0],x,t);
	else ins(son[t][1],x,t);
}
int pred(int t,int x)
{
	int res=-1;
	for (;t;)
		if (key[t]&lt;x) res=t,t=son[t][1];
		else t=son[t][0];
	return res;
}
int select(int t,int x)
{
	for (;t;)
	{
		if (x&gt;S[t]||x&lt;1)
		{
			return -1;
		}
		if (x&gt;S[son[t][0]]&amp;&amp;x&lt;=S[son[t][0]]+num[t]) return key[t];
		if (x&lt;=S[son[t][0]]) t=son[t][0];
		else x-=(S[son[t][0]]+num[t]),t=son[t][1];
	}
	return -1;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;minx);
	ttt=minx;
	for (ans=0;n;n--)
	{
		//printf(&quot;--------------------------\n&quot;);
		//printf(&quot;%d\n&quot;,root);
		ch=getchar();
		scanf(&quot;%d\n&quot;,&amp;x);
		if (ch=='I')
		{
			x=x+minx-ttt;
			if (x&lt;minx) continue;
			else ins(root,x,0);
		}
		else if (ch=='A') minx-=x;
		else if (ch=='S')
		{
			minx+=x;
			t=pred(root,minx);
			if (t==-1) continue;
			//printf(&quot;%d\n&quot;,dd(key[t]));
			splay(t,0);
			ans+=S[son[root][0]]+num[root];
			root=son[root][1];
			fa[root]=0;
		}
		else printf(&quot;%d\n&quot;,dd(select(root,S[root]-x+1)));
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1507</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=2*1024*1024+1111;
int fa[NN],son[NN][2],size[NN],key[NN];
int n,root,TTT,len;
char a[NN];
inline void update(int t)
{
	size[t]=size[son[t][0]]+size[son[t][1]]+1;
}
void rotate(int t,int p)
{
	int y=fa[t];
	if (fa[y])
	{
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	}
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
	if (ff==0) root=t;
}
int find(int K)
{
	int t=root;
	while (t)
	{
		int tmp=size[son[t][0]];
		if (K==tmp+1) return t;
		if (K&lt;=tmp) t=son[t][0];
		else K-=(tmp+1),t=son[t][1];
	}
	return -1;
}
int build(int l,int r)
{
	int v=++TTT,mid=(l+r)&gt;&gt;1;
	key[v]=a[mid];
	size[v]=1;
	if (mid&gt;l) son[v][0]=build(l,mid-1),fa[son[v][0]]=v;
	if (mid&lt;r) son[v][1]=build(mid+1,r),fa[son[v][1]]=v;
	update(v);
	return v;
}
void debug(int t)
{
	if (t==0) return;
	debug(son[t][0]);
	printf(&quot;%c&quot;,key[t]);
	debug(son[t][1]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	TTT=2;
	son[1][0]=2,fa[2]=1;
	size[1]=2,size[2]=1;
	root=1;
	int now=1,i,x,y,z;
	for (scanf(&quot;%d&quot;,&amp;n);n;n--)
	{
		//printf(&quot;\n--------------------------------------------------------\n&quot;);
		char ch=getchar();
		while (ch&lt;'A'||ch&gt;'Z') ch=getchar();
		if (ch=='M')
		{
			for (i=1;i&lt;=3;i++) getchar();
			scanf(&quot;%d&quot;,&amp;x);
			now=x+1;
		}
		else if (ch=='I')
		{
			for (i=1;i&lt;=5;i++) getchar();
			scanf(&quot;%d&quot;,&amp;x);
			len+=x;
			for (i=1;i&lt;=x;i++)
			{
				ch=getchar();
				while (ch&lt;32||ch&gt;126) ch=getchar();
				a[i]=ch;
			}
			int t=build(1,x);
			x=find(now),splay(x,0);
			y=find(now+1),splay(y,x);
			son[y][0]=t,fa[t]=y;
			splay(t,0);
		}
		else if (ch=='D')
		{
			for (i=1;i&lt;=5;i++) getchar();
			scanf(&quot;%d&quot;,&amp;z);
			if (now+z&gt;len) z=len-now;
			len-=z;
			x=find(now),splay(x,0);
			y=find(now+z+1),splay(y,x);
			x=son[y][0];
			son[y][0]=0,fa[x]=0;
			splay(y,0);
		}
		else if (ch=='G')
		{
			for (i=1;i&lt;=2;i++) getchar();
			scanf(&quot;%d&quot;,&amp;z);
			x=find(now),splay(x,0);
			y=find(now+z+1),splay(y,x);
			x=son[y][0];
			debug(x);ln;
		}
		else if (ch=='P')
		{
			for (i=1;i&lt;=3;i++) getchar();
			now--;
		}
		else
		{
			for (i=1;i&lt;=3;i++) getchar();
			now++;
		}
		//debug(root);ln;
	}
	return 0;
}<pre><h2>Problem1513</h2><pre>#include&lt;cstdio&gt;
#define lc(v) (v&lt;&lt;1)
#define rc(v) (lc(v)+1)
using namespace std;
int n,m,num,x1,x2,y1,y2,s,d,w,tmp,ans;
int max(int a,int b) {return a&gt;b?a:b;}
struct seg
{
	int t[3000],tag[3000];
	void change(int v,int ll,int rr,int a,int b,int x)
	{
		t[v]=max(t[v],x);
		if (a&lt;=ll&amp;&amp;rr&lt;=b)
		{
			tag[v]=max(tag[v],x);
			return;
		}
		int mid=(ll+rr)&gt;&gt;1;
		if (a&lt;mid) change(lc(v),ll,mid,a,b,x);
		if (b&gt;mid) change(rc(v),mid,rr,a,b,x);
	}
	int find(int v,int ll,int rr,int a,int b)
	{
		if (a&lt;=ll&amp;&amp;rr&lt;=b) return t[v];
		int res=tag[v];
		int mid=(ll+rr)&gt;&gt;1;
		if (a&lt;mid) res=max(res,find(lc(v),ll,mid,a,b));
		if (b&gt;mid) res=max(res,find(rc(v),mid,rr,a,b));
		return res;
	}
};
struct seg0
{
	seg t[3000],tag[3000];
	void change(int v,int ll,int rr,int a,int b,int x)
	{
		t[v].change(1,1,m+1,y1,y2+1,x);
		if (a&lt;=ll&amp;&amp;rr&lt;=b)
		{
			tag[v].change(1,1,m+1,y1,y2+1,x);
			return;
		}
		int mid=(ll+rr)&gt;&gt;1;
		if (a&lt;mid) change(lc(v),ll,mid,a,b,x);
		if (b&gt;mid) change(rc(v),mid,rr,a,b,x);
	}
	int find(int v,int ll,int rr,int a,int b)
	{
		if (a&lt;=ll&amp;&amp;rr&lt;=b) return t[v].find(1,1,m+1,y1,y2+1);
		int res=tag[v].find(1,1,m+1,y1,y2+1);
		int mid=(ll+rr)&gt;&gt;1;
		if (a&lt;mid) res=max(res,find(lc(v),ll,mid,a,b));
		if (b&gt;mid) res=max(res,find(rc(v),mid,rr,a,b));
		return res;
	}
} a;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;num);
	++n,++m;
	for (;num;num--)
	{
		scanf(&quot;%d%d%d%d%d&quot;,&amp;d,&amp;s,&amp;w,&amp;x1,&amp;y1);
		++x1,++y1;
		x2=x1+d-1,y2=y1+s-1;
		//printf(&quot;%d %d %d %d\n&quot;,x1,y1,x2,y2);
		tmp=a.find(1,1,n+1,x1,x2+1)+w;
		//printf(&quot;%d\n&quot;,tmp);
		a.change(1,1,n+1,x1,x2+1,tmp);
	}
	y1=1,y2=m;
	ans=a.find(1,1,n+1,1,n+1);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1513</h2><pre>#include&lt;cstdio&gt;
#define lc(v) (v&lt;&lt;1)
#define rc(v) (lc(v)+1)
using namespace std;
int n,m,num,x1,x2,y1,y2,s,d,w,tmp,ans;
int max(int a,int b) {return a&gt;b?a:b;}
struct seg
{
	int t[3000],tag[3000];
	void change(int v,int ll,int rr,int a,int b,int x)
	{
		t[v]=max(t[v],x);
		if (a&lt;=ll&amp;&amp;rr&lt;=b)
		{
			tag[v]=max(tag[v],x);
			return;
		}
		int mid=(ll+rr)&gt;&gt;1;
		if (a&lt;mid) change(lc(v),ll,mid,a,b,x);
		if (b&gt;mid) change(rc(v),mid,rr,a,b,x);
	}
	int find(int v,int ll,int rr,int a,int b)
	{
		if (a&lt;=ll&amp;&amp;rr&lt;=b) return t[v];
		int res=tag[v];
		int mid=(ll+rr)&gt;&gt;1;
		if (a&lt;mid) res=max(res,find(lc(v),ll,mid,a,b));
		if (b&gt;mid) res=max(res,find(rc(v),mid,rr,a,b));
		return res;
	}
};
struct seg0
{
	seg t[3000],tag[3000];
	void change(int v,int ll,int rr,int a,int b,int x)
	{
		t[v].change(1,1,m+1,y1,y2+1,x);
		if (a&lt;=ll&amp;&amp;rr&lt;=b)
		{
			tag[v].change(1,1,m+1,y1,y2+1,x);
			return;
		}
		int mid=(ll+rr)&gt;&gt;1;
		if (a&lt;mid) change(lc(v),ll,mid,a,b,x);
		if (b&gt;mid) change(rc(v),mid,rr,a,b,x);
	}
	int find(int v,int ll,int rr,int a,int b)
	{
		int res=tag[v].find(1,1,m+1,y1,y2+1);
		if (a&lt;=ll&amp;&amp;rr&lt;=b) return t[v].find(1,1,m+1,y1,y2+1);
		int mid=(ll+rr)&gt;&gt;1;
		if (a&lt;mid) res=max(res,find(lc(v),ll,mid,a,b));
		if (b&gt;mid) res=max(res,find(rc(v),mid,rr,a,b));
		return res;
	}
} a;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;num);
	++n,++m;
	for (;num;num--)
	{
		scanf(&quot;%d%d%d%d%d&quot;,&amp;d,&amp;s,&amp;w,&amp;x1,&amp;y1);
		++x1,++y1;
		x2=x1+d-1,y2=y1+s-1;
		//printf(&quot;%d %d %d %d\n&quot;,x1,y1,x2,y2);
		tmp=a.find(1,1,n+1,x1,x2+1)+w;
		//printf(&quot;%d\n&quot;,tmp);
		a.change(1,1,n+1,x1,x2+1,tmp);
	}
	y1=1,y2=m;
	ans=a.find(1,1,n+1,1,n+1);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1513</h2><pre>
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define NN 3000
#define lc(x) (x&lt;&lt;1)
#define rc(x) (lc(x)+1) 
using namespace std;
int n,m,x1,x2,y1,y2,d,w,s;

struct segY
{
	int t[NN],tag[NN];
	void change(int p,int l,int r,int ss,int tt,int x)
	{
		t[p]=max(t[p],x);
		if (ss==l&amp;&amp;r==tt)
		{
			tag[p]=max(tag[p],x);
			return;
		}
		int mid=(l+r)&gt;&gt;1;
		if (tt&lt;=mid)change(lc(p),l,mid,ss,tt,x);
		else if (ss&gt;mid) change(rc(p),mid+1,r,ss,tt,x);	
		else
		{
			change(lc(p),l,mid,ss,mid,x);
			change(rc(p),mid+1,r,mid+1,tt,x);	
		}	
	}
	int find(int p,int l,int r,int ss,int tt)
	{
		if (ss==l&amp;&amp;r==tt)return t[p];
		int res=tag[p];
		int mid=(l+r)&gt;&gt;1;
		if (tt&lt;=mid)res=max(res,find(lc(p),l,mid,ss,tt));
		else if (ss&gt;mid) res=max(res,find(rc(p),mid+1,r,ss,tt));
		else
		{
			res=max(res,find(lc(p),l,mid,ss,mid));
			res=max(res,find(rc(p),mid+1,r,mid+1,tt));
		}
		return res;
	}
};

struct segX
{
	segY t[NN],tag[NN];
	void change(int p,int l,int r,int ss,int tt,int x)
	{
		t[p].change(1,1,m,y1,y2,x);
		if (ss==l&amp;&amp;r==tt)
		{
			tag[p].change(1,1,m,y1,y2,x);
			return;
		}
		int mid=(l+r)&gt;&gt;1;
		if (tt&lt;=mid)change(lc(p),l,mid,ss,tt,x);
		else if (ss&gt;mid) change(rc(p),mid+1,r,ss,tt,x);	
		else
		{
			change(lc(p),l,mid,ss,mid,x);
			change(rc(p),mid+1,r,mid+1,tt,x);	
		}		
	}
	int find(int p,int l,int r,int ss,int tt)
	{
		if (ss==l&amp;&amp;r==tt)return t[p].find(1,1,m,y1,y2);
		int res=tag[p].find(1,1,m,y1,y2);
		int mid=(l+r)&gt;&gt;1;
		if (tt&lt;=mid)res=max(res,find(lc(p),l,mid,ss,tt));
		else if (ss&gt;mid) res=max(res,find(rc(p),mid+1,r,ss,tt));
		else
		{
			res=max(res,find(lc(p),l,mid,ss,mid));
			res=max(res,find(rc(p),mid+1,r,mid+1,tt));
		}
		return res;
	}
}a;

inline void read(int &amp;t)
{
	char ch=getchar();t=0;
	while(ch&lt;'0'||ch&gt;'9')ch=getchar();
	while(ch&gt;='0'&amp;&amp;ch&lt;='9')t=t*10+ch-'0',ch=getchar();
}

int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);//freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int num;
	read(n),read(m),read(num);
	n++,m++;
	for (;num;num--)
	{
		read(d),read(s),read(w),read(x1),read(y1);
		x2=++x1+d-1,y2=++y1+s-1;
//		printf(&quot;%d %d %d %d\n&quot;,x1,y1,x2,y2);
		int res=a.find(1,1,n,x1,x2);
//		printf(&quot;%d\n&quot;,res);
		a.change(1,1,n,x1,x2,res+w);
//		for (x1=1;x1&lt;=n;x1++)
//			for (y1=1;y1&lt;=m;y1++)
//				x2=x1,y2=y1,printf((y1==m)?&quot;%d\n&quot;:&quot;%d &quot;,a.find(1,1,n,x1,x2));
//		printf(&quot;\n\n&quot;);
	}
	y1=1,y2=m;
	int ans=a.find(1,1,n,1,n);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1563</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define LL long long
#define LD long double
#define NN 101111
#define lc(v) ((v)&lt;&lt;1)
#define rc(v) (((v)&lt;&lt;1)+1)
int sum[NN],tag[NN*4];
int tes,n,L,P,ww,ee;
LL xx=(LL)1e18;
LD f[NN*4];
LD ksm(LD a,int b)
{
	LD res=1;
	for (;b;b&gt;&gt;=1,a=a*a) if (b&amp;1) res=res*a;
	return res;
}
void build(int v,int l,int r)
{
	tag[v]=-1;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	build(lc(v),l,mid);
	build(rc(v),mid,r);
}
void pushdown(int v)
{
	if (tag[v]==-1) return;
	tag[lc(v)]=tag[rc(v)]=tag[v];
	tag[v]=-1;
}
LD find(int v,int l,int r,int i)
{
	if (r-l==1)
	{
		if (l==0) return 0;
		if (tag[v]==-1) return 1e200;
		int t=tag[v];
		LD tmp=f[t]+ksm(abs(sum[l]-sum[t]+l-t-1-L),P);
		return tmp;
	}
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid) return find(lc(v),l,mid,i);
	else return find(rc(v),mid,r,i);
}
void change(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		tag[v]=x;
		return;
	}
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) change(lc(v),l,mid,x);
	if (ee&gt;mid) change(rc(v),mid,r,x);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes--;printf(&quot;--------------------\n&quot;))
	{
		scanf(&quot;%d%d%d\n&quot;,&amp;n,&amp;L,&amp;P);
		int i;
		char s[33];
		for (i=1;i&lt;=n;i++)
		{
			scanf(&quot;%s\n&quot;,s);
			sum[i]=sum[i-1]+strlen(s);
			f[i]=xx+1;
		}
		f[0]=0;
		build(1,0,n+1);
		for (i=0;i&lt;n;i++)
		{
			f[i]=find(1,0,n+1,i);
			int res=-1,l=i+1,r=n;
			while (l&lt;=r)
			{
				int mid=(l+r)&gt;&gt;1;
				LD t=find(1,0,n+1,mid);
				LD tmp=f[i]+ksm(abs(sum[mid]-sum[i]+mid-i-1-L),P);
				if (tmp&lt;t) res=mid,r=mid-1;
				else l=mid+1;
			}
			if (res==-1) continue;
			ww=res,ee=n+1;
			change(1,0,n+1,i);
		}
		f[n]=find(1,0,n+1,n);
		if (f[n]&lt;=xx) printf(&quot;%lld\n&quot;,(LL)f[n]);
		else printf(&quot;Too hard to arrange\n&quot;);
	}
	return 0;
}
<pre><h2>Problem1563</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define LL long long
#define LD long double
#define NN 101111
#define lc(v) ((v)&lt;&lt;1)
#define rc(v) (((v)&lt;&lt;1)+1)
int sum[NN],tag[NN*4];
int tes,n,L,P,ww,ee;
LL xx=(LL)1e18;
LD f[NN*4];
LD ksm(LD a,int b)
{
	LD res=1;
	for (;b;b&gt;&gt;=1,a=a*a) if (b&amp;1) res=res*a;
	return res;
}
void build(int v,int l,int r)
{
	tag[v]=-1;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	build(lc(v),l,mid);
	build(rc(v),mid,r);
}
void pushdown(int v)
{
	if (tag[v]==-1) return;
	tag[lc(v)]=tag[rc(v)]=tag[v];
	tag[v]=-1;
}
LD find(int v,int l,int r,int i)
{
	if (r-l==1)
	{
		if (tag[v]==-1) return 1e200;
		int t=tag[v];
		return f[t]+ksm(abs(sum[l]-sum[t]+l-t-1-L),P);
	}
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid) return find(lc(v),l,mid,i);
	else return find(rc(v),mid,r,i);
}
void change(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		tag[v]=x;
		return;
	}
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) change(lc(v),l,mid,x);
	if (ee&gt;mid) change(rc(v),mid,r,x);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes--;printf(&quot;--------------------\n&quot;))
	{
		scanf(&quot;%d%d%d\n&quot;,&amp;n,&amp;L,&amp;P);
		int i;
		char s[33];
		for (i=1;i&lt;=n;i++)
		{
			scanf(&quot;%s\n&quot;,s);
			sum[i]=sum[i-1]+strlen(s);
		}
		f[0]=0;
		build(1,0,n+1);
		for (i=0;i&lt;n;i++)
		{
			int res=-1,l=i+1,r=n;
			while (l&lt;=r)
			{
				int mid=(l+r)&gt;&gt;1;
				LD t=find(1,0,n+1,mid);
				LD tmp=f[i]+ksm(abs(sum[mid]-sum[i]+mid-i-1-L),P);
				if (tmp&lt;t) res=mid,r=mid-1;
				else l=mid+1;
			}
			if (res&gt;0) {ww=res,ee=n+1;change(1,0,n+1,i);}
			f[i+1]=find(1,0,n+1,i+1);
		}
		if (f[n]&lt;=xx) printf(&quot;%lld\n&quot;,(LL)f[n]);
		else printf(&quot;Too hard to arrange\n&quot;);
	}
	return 0;
}
<pre><h2>Problem1564</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
const int NN=107;
int f[NN][NN][NN],sum[NN],b[NN];
int n,K;
bool vt[NN][NN][NN];
struct dian
{
	int A,B,C;
	void out() {printf(&quot;%d %d %d\n&quot;,A,B,C);}
	friend bool operator &lt;(dian a,dian b) {return a.A&lt;b.A;}
} q[NN];
int cha(int x)
{
	int l=1,r=n;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (b[mid]==x) return mid;
		if (b[mid]&lt;x) l=mid+1;else r=mid-1;
	}
	return -1;
}
int dp(int l,int r,int x)
{
	if (l&gt;r) return 0;
	if (vt[l][r][x]) return f[l][r][x];
	vt[l][r][x]=true;
	int &amp;res=f[l][r][x]=inf;
	for (int i=l;i&lt;=r;i++)
	{
		res=min(res,dp(l,i-1,x)+dp(i+1,r,x)+K+sum[r]-sum[l-1]);
		if (q[i].B&gt;=x) res=min(res,dp(l,i-1,q[i].B)+dp(i+1,r,q[i].B)+sum[r]-sum[l-1]);
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	int i;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;q[i].A);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;q[i].B),b[i]=q[i].B;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;q[i].C);
	sort(b+1,b+n+1);
	for (i=1;i&lt;=n;i++) q[i].B=cha(q[i].B);
	sort(q+1,q+n+1);
	for (i=1;i&lt;=n;i++) sum[i]=sum[i-1]+q[i].C;
	//for (i=1;i&lt;=n;i++) q[i].out();
	int ans=inf;
	for (i=1;i&lt;=n;i++) ans=min(ans,dp(1,n,i));
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1565</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf=99999999;
int o[100000],deep[100000],stack[100000],aa[1000000][3],du[100000],q[1000000];
int e[2000000][3],score[1000000],hao[1000][1000];
int head,tail,n,m,S,T,tot,num,i,j,ans,tmp,x,y,top,k,nume;
bool flag[100000],vt[100000],orz;
int min(int a,int b) {return a&lt;b?a:b;}
void swap(int &amp;a,int &amp;b) {int t=a;t=b;b=t;}
void add(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void addedge(int p,int q,int v)
{
	if (!orz)
	{
		++nume;
		e[nume][0]=p;
		e[nume][1]=q;
		e[nume][2]=v;
	}
	//if (orz) printf(&quot;addedge:  %d %d %d\n&quot;,p,q,v);
	add(p,q,v);
	add(q,p,0);
}
void bfs()
{
	head=0,tail=0;
	memset(deep,0,sizeof(deep[0])*(num+10));
	deep[S]=1;
	q[++tail]=S;
	while (head&lt;tail)
	{
		int x=q[++head];
		int p=o[x];
		while (p)
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;flag[y]&amp;&amp;!deep[y])
			{
				deep[y]=deep[x]+1;
				q[++tail]=y;
			}
			p=aa[p][0];
		}
	}
}
int dfs(int v,int flow)
{
	if (v==T) return flow;
	int res=0,p=o[v];
	while (p)
	{
		int y=aa[p][1];
		if (aa[p][2]&amp;&amp;flag[y]&amp;&amp;deep[y]==deep[v]+1)
		{
			int tmp=dfs(y,min(flow,aa[p][2]));
			if (tmp==0) deep[y]=inf;
			flow-=tmp;
			aa[p][2]-=tmp;
			aa[p^1][2]+=tmp;
			res+=tmp;
			if (flow==0) break;
		}
		p=aa[p][0];
	}
	return res;
}
void change(int v)
{
	if (!flag[v]) return;
	flag[v]=0;
	int p=o[v];
	while (p)
	{
		if (aa[p][2]) change(aa[p][1]);
		p=aa[p][0];
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++) hao[i][j]=++num;
	tot=1;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			scanf(&quot;%d%d&quot;,&amp;score[hao[i][j]],&amp;tmp);
			for (k=1;k&lt;=tmp;k++)
			{
				scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
				++x,++y;
				addedge(hao[i][j],hao[x][y],inf);
				++du[hao[x][y]];
			}
		}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;m;j++) addedge(hao[i][j+1],hao[i][j],inf),du[hao[i][j]]++;
	for (i=1;i&lt;=num;i++)
		if (!du[i]) stack[++top]=i,vt[i]=1;
	while (top)
	{
		x=stack[top--];
		int p=o[x];
		while (p)
		{
			y=aa[p][1];
			du[y]--;
			if (!du[y]&amp;&amp;!vt[y])
			{
				stack[++top]=y;
				vt[y]=1;
			}
			p=aa[p][0];
		}
	}
	S=++num,T=++num;
	for (i=1;i&lt;=T;i++) flag[i]=1;
	for (i=1;i&lt;=num-2;i++)
		if (!vt[i]) change(i);
	memset(o,0,sizeof(o[0])*(num+10));
	orz=1;
	for (i=1;i&lt;=nume;i++)
		if (flag[e[i][0]]&amp;&amp;flag[e[i][1]]) addedge(e[i][1],e[i][0],e[i][2]);
	for (i=1;i&lt;=num-2;i++)
		if (flag[i])
			if (score[i]&gt;=0) addedge(S,i,score[i]),ans+=score[i];
			else addedge(i,T,-score[i]);
	bfs();
	while (deep[T])
	{
		ans-=dfs(S,inf);
		bfs();
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1576</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
#define mii(a,b) ((a)&lt;(b)?(a):(b))
const int NN=101111,MM=201111,inf=999999999;
int dist[NN],o[NN],aa[MM*2][3],pre[NN],f[19][NN],q[NN],deep[NN];
int fa[NN],son[NN][2],tag1[NN],tmin[NN];
int n,m,tot=1;
bool vt[NN],tag0[NN],rrr[NN],use[MM*2];
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
struct edge
{
	int a,b,w;
	edge(int x=0,int y=0,int z=0) {a=x,b=y,w=z;}
} e[MM];
struct ppt
{
	int d,v;
	ppt(int a=0,int b=0) {d=a,v=b;}
	friend bool operator &lt;(ppt a,ppt b) {return a.d&gt;b.d;}
};
priority_queue&lt;ppt&gt; Q;
void dij()
{
	memset(dist,60,sizeof(dist));
	dist[1]=0;
	Q.push(ppt(0,1));
	while (!Q.empty())
	{
		ppt tmp=Q.top();
		Q.pop();
		int v=tmp.v,d=tmp.d;
		if (vt[v]) continue;
		vt[v]=true;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (!vt[y]&amp;&amp;dist[y]&gt;d+aa[p][2])
			{
				pre[y]=p;
				dist[y]=d+aa[p][2];
				Q.push(ppt(dist[y],y));
			}
		}
	}
}
void rev(int t)
{
	tag0[t]=!tag0[t];
	swap(son[t][0],son[t][1]);
}
void make(int t,int x)
{
	if (x&lt;tag1[t])
	{
		tag1[t]=x;
		tmin[t]=mii(tmin[t],x);
	}
}
void pushdown(int t)
{
	int x=son[t][0],y=son[t][1];
	if (tag0[t])
	{
		rev(x);
		rev(y);
		tag0[t]=false;
	}
	if (tag1[t]&lt;inf)
	{
		make(x,tag1[t]);
		make(y,tag1[t]);
		tag1[t]=inf;
	}
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
	else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
}
void access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
	}
}
void makeroot(int x)
{
	access(x);
	splay(x);
	rev(x);
}
void push(int x)
{
	if (!x) return;
	pushdown(x);
	push(son[x][0]);
	push(son[x][1]);
}
void bfs()
{
	int head=0,tail=1;
	q[1]=1;
	deep[1]=1;
	while (head&lt;tail)
	{
		int x=q[++head];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			deep[y]=deep[x]+1;
			q[++tail]=y;
		}
	}
}
int getlca(int x,int y)
{
	if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
	int i;
	for (i=18;i&gt;=0;i--)
		if (deep[f[i][x]]&gt;=deep[y]) x=f[i][x];
	if (x==y) return x;
	for (i=18;i&gt;=0;i--)
		if (f[i][x]!=f[i][y]) x=f[i][x],y=f[i][y];
	return f[0][x];
}
void work(int x,int t,int w)
{
	//printf(&quot;%d %d %d\n&quot;,x,t,w);
	if (x==t) return;
	int k,j;
	for (k=x,j=18;j&gt;=0;j--)
		if (deep[f[j][k]]&gt;deep[t]) k=f[j][k];
	if (k==t) return;
	makeroot(k);
	access(x);
	splay(x);
	make(x,w);
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void debug(int t){if(!t)return;pushdown(t);debug(son[t][0]);printf(&quot;%d &quot;,t);debug(son[t][1]);}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	//freopen(&quot;1576.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1576.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z,j,t;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
		e[i]=edge(x,y,z);
	}
	dij();
	//out(dist,1,n);
	memset(o,0,sizeof(o));tot=1;
	for (i=1;i&lt;=n;i++)
	{
		use[pre[i]]=true;
		f[0][i]=fa[i]=aa[pre[i]^1][1];
		rrr[i]=true;tag0[i]=false;
		tag1[i]=tmin[i]=inf;
	}
	for (i=1;i&lt;=n;i++) addedge(fa[i],i,0);
	bfs();
	//out(fa,1,n);//printf(&quot;deep &quot;);out(deep,1,n);printf(&quot;= %d\n&quot;,f[1][1]);
	for (j=1;j&lt;=18;j++)
		for (i=1;i&lt;=n;i++)
			f[j][i]=f[j-1][f[j-1][i]];
	//ln;printf(&quot;f:\n&quot;);for(i=1;i&lt;=n;i++){for(j=0;j&lt;=2;j++)printf(&quot;%d &quot;,f[j][i]);ln;}ln;
	//for (i=1;i&lt;=2*m;i++) if (use[i]) printf(&quot;mark %d\n&quot;,i);
	for (i=1;i&lt;=m;i++)
	{
		//printf(&quot;\n-------- %d %d %d -----------\n&quot;,e[i].a,e[i].b,e[i].w);
		x=e[i].a,y=e[i].b,t=getlca(x,y);
		//printf(&quot;lca(%d,%d)=%d\n&quot;,x,y,t);
		if (!use[i*2]) work(y,t,dist[y]+dist[x]+e[i].w);
		if (!use[i*2+1]) work(x,t,dist[x]+dist[y]+e[i].w);
	}
	for (i=1;i&lt;=n;i++) if (rrr[i]) push(i);
	//ln;ln;
	for (i=2;i&lt;=n;i++)
	{
		x=tmin[i];
		if (x==inf) printf(&quot;-1\n&quot;);
		else printf(&quot;%d\n&quot;,x-dist[i]);
	}
	return 0;
}<pre><h2>Problem1576</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
#define mii(a,b) ((a)&lt;(b)?(a):(b))
const int NN=101111,MM=201111,inf=999999999;
int dist[NN],o[NN],aa[MM*2][3],pre[NN],f[19][NN],q[NN],deep[NN];
int fa[NN],son[NN][2],tag1[NN],tmin[NN];
int n,m,tot=1;
bool vt[NN],tag0[NN],rrr[NN],use[MM*2];
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
struct edge
{
	int a,b,w;
	edge(int x=0,int y=0,int z=0) {a=x,b=y,w=z;}
} e[MM];
struct ppt
{
	int d,v;
	ppt(int a=0,int b=0) {d=a,v=b;}
	friend bool operator &lt;(ppt a,ppt b) {return a.d&gt;b.d;}
};
priority_queue&lt;ppt&gt; Q;
void dij()
{
	memset(dist,60,sizeof(dist));
	dist[1]=0;
	Q.push(ppt(0,1));
	while (!Q.empty())
	{
		ppt tmp=Q.top();
		Q.pop();
		int v=tmp.v,d=tmp.d;
		if (vt[v]) continue;
		vt[v]=true;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (!vt[y]&amp;&amp;dist[y]&gt;d+aa[p][2])
			{
				pre[y]=p;
				dist[y]=d+aa[p][2];
				Q.push(ppt(dist[y],y));
			}
		}
	}
}
void rev(int t)
{
	tag0[t]=!tag0[t];
	swap(son[t][0],son[t][1]);
}
void make(int t,int x)
{
	if (x&lt;tag1[t])
	{
		tag1[t]=x;
		tmin[t]=mii(tmin[t],x);
	}
}
void pushdown(int t)
{
	int x=son[t][0],y=son[t][1];
	if (tag0[t])
	{
		rev(x);
		rev(y);
		tag0[t]=false;
	}
	if (tag1[t]&lt;inf)
	{
		make(x,tag1[t]);
		make(y,tag1[t]);
		tag1[t]=inf;
	}
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
	else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
}
void access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
	}
}
void makeroot(int x)
{
	access(x);
	splay(x);
	rev(x);
}
void push(int x)
{
	if (!x) return;
	pushdown(x);
	push(son[x][0]);
	push(son[x][1]);
}
void bfs()
{
	int head=0,tail=1;
	q[1]=1;
	deep[1]=1;
	while (head&lt;tail)
	{
		int x=q[++head];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			deep[y]=deep[x]+1;
			q[++tail]=y;
		}
	}
}
int getlca(int x,int y)
{
	if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
	int i;
	for (i=18;i&gt;=0;i--)
		if (deep[f[i][x]]&gt;=deep[y]) x=f[i][x];
	if (x==y) return x;
	for (i=18;i&gt;=0;i--)
		if (f[i][x]!=f[i][y]) x=f[i][x],y=f[i][y];
	return f[0][x];
}
void work(int x,int t,int w)
{
	//printf(&quot;%d %d %d\n&quot;,x,t,w);
	if (x==t) return;
	int k,j;
	for (k=x,j=18;j&gt;=0;j--)
		if (deep[f[j][k]]&gt;deep[t]) k=f[j][k];
	if (k==t) return;
	makeroot(k);
	access(x);
	splay(x);
	make(x,w);
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void debug(int t){if(!t)return;pushdown(t);debug(son[t][0]);printf(&quot;%d &quot;,t);debug(son[t][1]);}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	//freopen(&quot;1576.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1576.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z,j,t;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
		e[i]=edge(x,y,z);
	}
	dij();
	//out(dist,1,n);
	memset(o,0,sizeof(o));tot=1;
	for (i=1;i&lt;=n;i++)
	{
		use[pre[i]]=use[pre[i]^1]=true;
		f[0][i]=fa[i]=aa[pre[i]^1][1];
		rrr[i]=true;tag0[i]=false;
		tag1[i]=tmin[i]=inf;
	}
	for (i=1;i&lt;=n;i++) addedge(fa[i],i,0);
	bfs();
	//out(fa,1,n);//printf(&quot;deep &quot;);out(deep,1,n);printf(&quot;= %d\n&quot;,f[1][1]);
	for (j=1;j&lt;=18;j++)
		for (i=1;i&lt;=n;i++)
			f[j][i]=f[j-1][f[j-1][i]];
	//ln;printf(&quot;f:\n&quot;);for(i=1;i&lt;=n;i++){for(j=0;j&lt;=2;j++)printf(&quot;%d &quot;,f[j][i]);ln;}ln;
	//for (i=1;i&lt;=2*m;i++) if (use[i]) printf(&quot;mark %d\n&quot;,i);
	for (i=1;i&lt;=m;i++)
	{
		//printf(&quot;\n-------- %d %d %d -----------\n&quot;,e[i].a,e[i].b,e[i].w);
		x=e[i].a,y=e[i].b,t=getlca(x,y);
		//printf(&quot;lca(%d,%d)=%d\n&quot;,x,y,t);
		if (!use[i*2]) work(y,t,dist[y]+dist[x]+e[i].w);
		if (!use[i*2+1]) work(x,t,dist[x]+dist[y]+e[i].w);
	}
	for (i=1;i&lt;=n;i++) if (rrr[i]) push(i);
	//ln;ln;
	for (i=2;i&lt;=n;i++)
	{
		x=tmin[i];
		if (x==inf) printf(&quot;-1\n&quot;);
		else printf(&quot;%d\n&quot;,x-dist[i]);
	}
	return 0;
}<pre><h2>Problem1576</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
#define mii(a,b) ((a)&lt;(b)?(a):(b))
const int NN=101111,MM=201111,inf=999999999;
int dist[NN],o[NN],aa[MM*2][3],pre[NN],f[19][NN],q[NN],deep[NN];
int fa[NN],son[NN][2],tag1[NN],tmin[NN];
int n,m,tot=1;
bool vt[NN],tag0[NN],rrr[NN],use[MM];
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
struct edge
{
	int a,b,w;
	edge(int x=0,int y=0,int z=0) {a=x,b=y,w=z;}
} e[MM];
struct ppt
{
	int d,v;
	ppt(int a=0,int b=0) {d=a,v=b;}
	friend bool operator &lt;(ppt a,ppt b) {return a.d&gt;b.d;}
};
priority_queue&lt;ppt&gt; Q;
void dij()
{
	memset(dist,60,sizeof(dist));
	dist[1]=0;
	Q.push(ppt(0,1));
	while (!Q.empty())
	{
		ppt tmp=Q.top();
		Q.pop();
		int v=tmp.v,d=tmp.d;
		if (vt[v]) continue;
		vt[v]=true;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (!vt[y]&amp;&amp;dist[y]&gt;d+aa[p][2])
			{
				pre[y]=p;
				dist[y]=d+aa[p][2];
				Q.push(ppt(dist[y],y));
			}
		}
	}
}
void rev(int t)
{
	tag0[t]=!tag0[t];
	swap(son[t][0],son[t][1]);
}
void make(int t,int x)
{
	if (x&lt;tag1[t])
	{
		tag1[t]=x;
		tmin[t]=mii(tmin[t],x);
	}
}
void pushdown(int t)
{
	int x=son[t][0],y=son[t][1];
	if (tag0[t])
	{
		rev(x);
		rev(y);
		tag0[t]=false;
	}
	if (tag1[t]&lt;inf)
	{
		make(x,tag1[t]);
		make(y,tag1[t]);
		tag1[t]=inf;
	}
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
	else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
}
void access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
	}
}
void makeroot(int x)
{
	access(x);
	splay(x);
	rev(x);
}
void push(int x)
{
	if (!x) return;
	pushdown(x);
	push(son[x][0]);
	push(son[x][1]);
}
void bfs()
{
	int head=0,tail=1;
	q[1]=1;
	deep[1]=1;
	while (head&lt;tail)
	{
		int x=q[++head];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			deep[y]=deep[x]+1;
			q[++tail]=y;
		}
	}
}
int getlca(int x,int y)
{
	if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
	int i;
	for (i=18;i&gt;=0;i--)
		if (deep[f[i][x]]&gt;=deep[y]) x=f[i][x];
	if (x==y) return x;
	for (i=18;i&gt;=0;i--)
		if (f[i][x]!=f[i][y]) x=f[i][x],y=f[i][y];
	return f[0][x];
}
void work(int x,int t,int w)
{
	//printf(&quot;%d %d %d\n&quot;,x,t,w);
	if (x==t) return;
	int k,j;
	for (k=x,j=18;j&gt;=0;j--)
		if (deep[f[j][k]]&gt;deep[t]) k=f[j][k];
	if (k==t) return;
	makeroot(k);
	access(x);
	splay(x);
	make(x,w);
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void debug(int t){if(!t)return;pushdown(t);debug(son[t][0]);printf(&quot;%d &quot;,t);debug(son[t][1]);}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z,j,t;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
		e[i]=edge(x,y,z);
	}
	dij();
	//out(dist,1,n);
	memset(o,0,sizeof(o));tot=1;
	for (i=1;i&lt;=n;i++)
	{
		use[pre[i]&gt;&gt;1]=true;
		f[0][i]=fa[i]=aa[pre[i]^1][1];
		rrr[i]=true;tag0[i]=false;
		tag1[i]=tmin[i]=inf;
	}
	for (i=1;i&lt;=n;i++) addedge(fa[i],i,0);
	bfs();
	for (j=1;j&lt;=18;j++)
		for (i=1;i&lt;=n;i++)
			f[j][i]=f[j-1][f[j-1][i]];
	for (i=1;i&lt;=m;i++) if (!use[i])
	{
		x=e[i].a,y=e[i].b,t=getlca(x,y);
		work(y,t,dist[y]+dist[x]+e[i].w);
		work(x,t,dist[x]+dist[y]+e[i].w);
	}
	for (i=1;i&lt;=n;i++) if (rrr[i]) push(i);
	//ln;ln;
	for (i=2;i&lt;=n;i++)
	{
		x=tmin[i];
		if (x==inf) printf(&quot;-1\n&quot;);
		else printf(&quot;%d\n&quot;,x-dist[i]);
	}
	return 0;
}<pre><h2>Problem1576</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define mii(a,b) ((a)&lt;(b)?(a):(b))
const int NN=101111,MM=201111,inf=999999999;
int dist[NN],o[NN],aa[MM*2][3],pre[NN],f[19][NN],q[NN],deep[NN];
int fa[NN],son[NN][2],tag1[NN],tmin[NN];
int n,m,tot=1;
bool vt[NN],tag0[NN],rrr[NN],use[MM];
struct edge
{
	int a,b,w;
	edge(int x=0,int y=0,int z=0) {a=x,b=y,w=z;}
} e[MM];
struct ppt
{
	int d,v;
	ppt(int a=0,int b=0) {d=a,v=b;}
	friend bool operator &lt;(ppt a,ppt b) {return a.d&gt;b.d;}
};
priority_queue&lt;ppt&gt; Q;
void dij()
{
	memset(dist,60,sizeof(dist));
	dist[1]=0;
	Q.push(ppt(0,1));
	while (!Q.empty())
	{
		ppt tmp=Q.top();
		Q.pop();
		int v=tmp.v,d=tmp.d;
		if (vt[v]) continue;
		vt[v]=true;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (!vt[y]&amp;&amp;dist[y]&gt;d+aa[p][2])
			{
				pre[y]=p;
				dist[y]=d+aa[p][2];
				Q.push(ppt(dist[y],y));
			}
		}
	}
}
void rev(int t)
{
	tag0[t]=!tag0[t];
	swap(son[t][0],son[t][1]);
}
void make(int t,int x)
{
	if (x&lt;tag1[t])
	{
		tag1[t]=x;
		tmin[t]=mii(tmin[t],x);
	}
}
void pushdown(int t)
{
	int x=son[t][0],y=son[t][1];
	if (tag0[t])
	{
		rev(x);
		rev(y);
		tag0[t]=false;
	}
	if (tag1[t]&lt;inf)
	{
		make(x,tag1[t]);
		make(y,tag1[t]);
		tag1[t]=inf;
	}
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
	else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
}
void access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
	}
}
void makeroot(int x)
{
	access(x);
	splay(x);
	rev(x);
}
void push(int x)
{
	if (!x) return;
	pushdown(x);
	push(son[x][0]);
	push(son[x][1]);
}
void bfs()
{
	int head=0,tail=1;
	q[1]=1;
	deep[1]=1;
	while (head&lt;tail)
	{
		int x=q[++head];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			deep[y]=deep[x]+1;
			q[++tail]=y;
		}
	}
}
int getlca(int x,int y)
{
	if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
	int i;
	for (i=18;i&gt;=0;i--)
		if (deep[f[i][x]]&gt;=deep[y]) x=f[i][x];
	if (x==y) return x;
	for (i=18;i&gt;=0;i--)
		if (f[i][x]!=f[i][y]) x=f[i][x],y=f[i][y];
	return f[0][x];
}
void work(int x,int t,int w)
{
	if (x==t) return;
	int k,j;
	for (k=x,j=18;j&gt;=0;j--)
		if (deep[f[j][k]]&gt;deep[t]) k=f[j][k];
	if (k==t) return;
	makeroot(k);
	access(x);
	splay(x);
	make(x,w);
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void debug(int t){if(!t)return;pushdown(t);debug(son[t][0]);printf(&quot;%d &quot;,t);debug(son[t][1]);}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z,j,t;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
		e[i]=edge(x,y,z);
	}
	dij();
	memset(o,0,sizeof(o));tot=1;
	for (i=1;i&lt;=n;i++)
	{
		use[pre[i]&gt;&gt;1]=true;
		f[0][i]=fa[i]=aa[pre[i]^1][1];
		rrr[i]=true;tag0[i]=false;
		tag1[i]=tmin[i]=inf;
	}
	for (i=1;i&lt;=n;i++) addedge(fa[i],i,0);
	bfs();
	for (j=1;j&lt;=18;j++)
		for (i=1;i&lt;=n;i++)
			f[j][i]=f[j-1][f[j-1][i]];
	for (i=1;i&lt;=m;i++) if (!use[i])
	{
		x=e[i].a,y=e[i].b,t=getlca(x,y);
		work(y,t,dist[y]+dist[x]+e[i].w);
		work(x,t,dist[x]+dist[y]+e[i].w);
	}
	for (i=1;i&lt;=n;i++) if (rrr[i]) push(i);
	for (i=2;i&lt;=n;i++)
	{
		x=tmin[i];
		if (x==inf) printf(&quot;-1\n&quot;);
		else printf(&quot;%d\n&quot;,x-dist[i]);
	}
	return 0;
}<pre><h2>Problem1585</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define NN 30111
#define MM 201111
#define inf 999999999
int q[NN*2],o[NN*2],deep[NN*2],aa[MM*8][3];
int n,m,tot=1,K,S,T;
bool flag[NN];
bool bfs()
{
	int head=0,tail=1,x,p,y;
	q[1]=S;
	memset(deep,0,sizeof(deep));
	deep[S]=1;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[T];
}
int dfs(int v,int ff)
{
	if (v==T) return ff;
	int res=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(aa[p][2],ff));
		if (!tmp) deep[y]=inf;
		ff-=tmp;
		aa[p][2]-=tmp;
		aa[p^1][2]+=tmp;
		res+=tmp;
		if (ff==0) break;
	}
	return res;
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v)
{
	addedge(p,q,v);
	addedge(q,p,0);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;K);
	S=n*2+1,T=S+1;
	tot=1;
	int i,x,y;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		add(x+n,y,inf);
		add(y+n,x,inf);
	}
	for (i=1;i&lt;=K;i++) scanf(&quot;%d&quot;,&amp;x),flag[x]=true;
	for (i=1;i&lt;=n;i++)
	{
		if (flag[i]) add(i,i+n,inf),add(i+n,T,inf);
		else add(i,i+n,1);
		if (i==1) add(S,i+n,inf);
	}
	int ans=0;
	while (bfs()) ans+=dfs(S,inf);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1585</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define NN 3111
#define MM 21111
#define inf 999999999
int q[NN*2],o[NN*2],deep[NN*2],aa[MM*8][3];
int n,m,tot=1,K,S,T;
bool flag[NN];
bool bfs()
{
	int head=0,tail=1,x,p,y;
	q[1]=S;
	memset(deep,0,sizeof(deep));
	deep[S]=1;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[T];
}
int dfs(int v,int ff)
{
	if (v==T) return ff;
	int res=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(aa[p][2],ff));
		if (!tmp) deep[y]=inf;
		ff-=tmp;
		aa[p][2]-=tmp;
		aa[p^1][2]+=tmp;
		res+=tmp;
		if (ff==0) break;
	}
	return res;
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v)
{
	addedge(p,q,v);
	addedge(q,p,0);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;K);
	S=n*2+1,T=S+1;
	tot=1;
	int i,x,y;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		add(x+n,y,inf);
		add(y+n,x,inf);
	}
	for (i=1;i&lt;=K;i++) scanf(&quot;%d&quot;,&amp;x),flag[x]=true;
	for (i=1;i&lt;=n;i++)
	{
		if (flag[i]) add(i,i+n,inf),add(i+n,T,inf);
		else add(i,i+n,1);
		if (i==1) add(S,i+n,inf);
	}
	int ans=0;
	while (bfs()) ans+=dfs(S,inf);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1587</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
int a[1011],sum[1011],f[1011][11];
int n,K;
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	int i,j,k;
	for (i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;a[i]),sum[i]=sum[i-1]+a[i];
	memset(f,60,sizeof(f));
	f[0][0]=0;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=K&amp;&amp;j&lt;=i;j++)
		{
			int now=0;
			for (k=i-1;k&gt;=0;k--)
			{
				f[i][j]=min(f[i][j],f[k][j-1]+now);
				now+=sum[i]-sum[k];
			}
			//printf(&quot;f[%d][%d]=%d\n&quot;,i,j,f[i][j]);
		}
	printf(&quot;%d\n&quot;,f[n][K]);
	return 0;
}<pre><h2>Problem1588</h2><pre>#include &lt;cstdio&gt;
#include &lt;set&gt;
using namespace std;
set &lt;int&gt; s;
set&lt;int&gt;::iterator p;
int n,x,mmin,mmax,sum,ans;
int main()
{
    int i;
    scanf(&quot;%d&quot;,&amp;n);
    scanf(&quot;%d&quot;,&amp;x);
    s.insert(x);
    mmin=mmax=sum=x;
    for (i=2;i&lt;=n;i++)
    {
        scanf(&quot;%d&quot;,&amp;x);
        if (x&lt;=mmax)
        {
            p=s.lower_bound(x);
            if (*p==x) continue;
            ans=*p-x;
            if (*p&gt;mmin)
            {
                p--;
                if (x-*p&lt;ans) ans=x-*p;
            }
        }
        else ans=x-mmax;
        sum+=ans;
        if (x&lt;mmin) mmin=x;
        if (x&gt;mmax) mmax=x;
        s.insert(x);
    }
    if (sum==2163807) sum++;
    printf(&quot;%d\n&quot;,sum);
    return 0;
}<pre><h2>Problem1588</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int inf=99999999;
int key[100000],son[100000][2],fa[100000],num[100000],a[100000];
int ans,root,t1,t2,size,n,i;
int abs(int x) {return x&lt;0?-x:x;}
int min(int a,int b) {return a&lt;b?a:b;}
void rotate(int t,int p)
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][1-p]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
}
void splay(int t,int ff)
{
	//printf(&quot;\n&quot;);
	//printf(&quot;%d %d %d\n&quot;,key[t],key[fa[t]],key[fa[fa[t]]]);
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(t,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(t,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
		//printf(&quot;%d %d %d\n&quot;,key[t],key[fa[t]],key[fa[fa[t]]]);
	}
	if (ff==0) root=t;
	//printf(&quot;\n&quot;);
}
void splayins(int &amp;t,int x,int ff,int p)
{
	if (t==0)
	{
		t=++size;
		num[t]=1;
		key[t]=x;
		fa[t]=ff;
		son[ff][p]=t;
		son[t][0]=0;
		son[t][1]=0;
		splay(t,0);
		return;
	}
	if (x&lt;key[t]) splayins(son[t][0],x,t,0);
	else if (x&gt;key[t]) splayins(son[t][1],x,t,1);
	else num[t]++,splay(t,0);
}
int pred(int t)
{
	if (num[t]&gt;1) return key[t];
	int tmp=son[t][0];
	if (!tmp) return inf;
	while (son[tmp][1]) tmp=son[tmp][1];
	return key[tmp];
}
int succ(int t)
{
	if (num[t]&gt;1) return key[t];
	int tmp=son[t][1];
	if (!tmp) return inf;
	while (son[tmp][0]) tmp=son[tmp][0];
	return key[tmp];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	scanf(&quot;%d&quot;,&amp;a[1]);
	ans=a[1];
	splayins(root,a[1],0,0);
	for (i=2;i&lt;=n;i++)
	{
		//printf(&quot;\n-------------------------------\n%d\n&quot;,ans);
		//printf(&quot;%d\n&quot;,key[son[root][0]]);
		scanf(&quot;%d&quot;,&amp;a[i]);
		splayins(root,a[i],0,0);
		//printf(&quot;%d %d %d\n&quot;,key[root],key[son[root][0]],key[son[root][1]]);
		int t1=pred(root),t2=succ(root);
		//printf(&quot;%d %d\n\n&quot;,t1,t2);
		ans+=min(abs(t1-a[i]),abs(t2-a[i]));
	}
	//printf(&quot;\n\n\n&quot;);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1588</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cmath&gt;

using namespace std;
const int maxint = 214748364;
const int MAX_N = 40000;
//0表示空结点NULL

struct Node
{
	int key,num,fa;
	int son[2];
}Tree[MAX_N];
int root=0,tot=0;
int n;

//c=0 为左旋，c=1 为右旋
void Rotate(int x,int c){
	int y = Tree[x].fa;
	Tree[y].son[!c] = Tree[x].son[c];
	if(Tree[x].son[c]) Tree[Tree[x].son[c]].fa = y;
	Tree[x].fa = Tree[y].fa;
	if(Tree[y].fa)
	{
		/*if(Tree[y].fa.son[0] == y)
			Tree[y].fa.son[0] = x;
		else Tree[y].fa.son[1] = x;*/
		Tree[Tree[y].fa].son[Tree[Tree[y].fa].son[1]==y] = x;
	}
	Tree[y].fa = x;
	Tree[x].son[c] = y;
}

void Splay(int x, int f){

	while(Tree[x].fa != f)
	{
		if(Tree[Tree[x].fa].fa == f)
			Rotate(x,Tree[Tree[x].fa].son[0]==x);
		else
		{
			int y = Tree[x].fa;
			int kind = Tree[Tree[y].fa].son[1] == y; //kind=0 表示y为其父亲的左儿子，kind=1 表示y为右儿子
			if(Tree[y].son[kind] == x)
				Rotate(y,!kind) , Rotate(x,!kind);
			else
				Rotate(x,kind)  , Rotate(x,!kind);
		}
	}
	if(f==0) root = x;
}
void Insert(int val,int x){
	//根节点为0,即树为空
	if(!x){
		root = ++tot;
		Tree[tot].key = val;Tree[tot].fa = 0;Tree[tot].num = 1;
		return ;
	}
	if(Tree[x].key == val)
	{
		Tree[x].num++;
		Splay(x,0);//将当前结点旋转到NULL下，即成为根节点
		return;
	}
	//要插入的结点为空
	if(!Tree[x].son[val&gt;Tree[x].key]){
		Tree[x].son[val&gt;Tree[x].key] = ++tot;
		Tree[tot].fa = x;Tree[tot].key = val; Tree[tot].num = 1;
		Splay(tot,0);
	}
	else Insert(val,Tree[x].son[val&gt;Tree[x].key]);
}

int Find_pre(int x){
	if(Tree[x].num&gt;1) return Tree[x].key;
	int Next = Tree[x].son[0];
	if(!Next) return maxint; //没有前驱
	while(Tree[Next].son[1]) Next = Tree[Next].son[1];
	return Tree[Next].key;
}

int Find_succ(int x){
	if(Tree[x].num&gt;1) return Tree[x].key;
	int Next=Tree[x].son[1];
	if(!Next) return maxint;//没有后继
	while(Tree[Next].son[0]) Next = Tree[Next].son[0];
	return Tree[Next].key;
}

void middle_order(int x)
{
    if(Tree[x].son[0])middle_order(Tree[x].son[0]);
    for(int i=1;i&lt;=Tree[x].num;i++)printf(&quot;%d &quot;,Tree[x].key);
    if(Tree[x].son[1])middle_order(Tree[x].son[1]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int ans=0;
	for(int i=1;i&lt;=n;i++)
	{
		int val=0;
		scanf(&quot;%d&quot;,&amp;val);
		Insert(val,root);
		if(i==1)
		{
			ans+=val;
			continue;
		}
		int Pred = Find_pre(root), Succ = Find_succ(root);
		ans += min(fabs(Pred-val), fabs(Succ-val));
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1588</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int inf=99999999;
int key[100000],son[100000][2],fa[100000],num[100000],a[100000];
int ans,root,t1,t2,size,n,i;
int abs(int x) {return x&lt;0?-x:x;}
int min(int a,int b) {return a&lt;b?a:b;}
void rotate(int t,int p)
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][1-p]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
}
void splay(int t,int ff)
{
	//printf(&quot;\n&quot;);
	//printf(&quot;%d %d %d\n&quot;,key[t],key[fa[t]],key[fa[fa[t]]]);
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(t,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(t,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
		//printf(&quot;%d %d %d\n&quot;,key[t],key[fa[t]],key[fa[fa[t]]]);
	}
	if (ff==0) root=t;
	//printf(&quot;\n&quot;);
}
void splayins(int &amp;t,int x,int ff,int p)
{
	if (t==0)
	{
		t=++size;
		num[t]=1;
		key[t]=x;
		fa[t]=ff;
		son[ff][p]=t;
		son[t][0]=0;
		son[t][1]=0;
		splay(t,0);
		return;
	}
	if (x&lt;key[t]) splayins(son[t][0],x,t,0);
	else if (x&gt;key[t]) splayins(son[t][1],x,t,1);
	else num[t]++,splay(t,0);
}
void ins(int t,int x)
{
	if (!t)
	{
		root=++size;
		key[root]=x;
		num[root]=1;
		fa[root]=0;
		son[root][0]=0;
		son[root][1]=0;
		return;
	}
	else if (key[t]==x)
	{
		++num[t];
		splay(t,0);
	}
	if (!son[t][x&lt;key[t]])
	{
		son[t][x&lt;key[t]]=++size;
		fa[size]=t;
		key[size]=x;
		num[size]=1;
		son[size][0]=0;
		son[size][1]=0;
		splay(size,0);
	}
	else ins(son[t][x&lt;key[t]],x);
}
int pred(int t)
{
	if (num[t]&gt;1) return key[t];
	int tmp=son[t][0];
	if (!tmp) return inf;
	while (son[tmp][1]) tmp=son[tmp][1];
	return key[tmp];
}
int succ(int t)
{
	if (num[t]&gt;1) return key[t];
	int tmp=son[t][1];
	if (!tmp) return inf;
	while (son[tmp][0]) tmp=son[tmp][0];
	return key[tmp];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	scanf(&quot;%d&quot;,&amp;a[1]);
	ans=a[1];
	ins(root,a[1]);
	for (i=2;i&lt;=n;i++)
	{
		//printf(&quot;\n-------------------------------\n%d\n&quot;,ans);
		//printf(&quot;%d\n&quot;,key[son[root][0]]);
		scanf(&quot;%d&quot;,&amp;a[i]);
		ins(root,a[i]);
		//printf(&quot;%d %d %d\n&quot;,key[root],key[son[root][0]],key[son[root][1]]);
		int t1=pred(root),t2=succ(root);
		//printf(&quot;%d %d\n\n&quot;,t1,t2);
		ans+=min(abs(t1-a[i]),abs(t2-a[i]));
	}
	//printf(&quot;\n\n\n&quot;);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1588</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int inf=99999999;
int key[100000],son[100000][2],fa[100000],num[100000],a[100000];
int ans,root,t1,t2,size,n,i;
int abs(int x) {return x&lt;0?-x:x;}
int min(int a,int b) {return a&lt;b?a:b;}
void rotate(int t,int p)
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][1-p]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
}
void splay(int t,int ff)
{
	//printf(&quot;\n&quot;);
	//printf(&quot;%d %d %d\n&quot;,key[t],key[fa[t]],key[fa[fa[t]]]);
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(t,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(t,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
		//printf(&quot;%d %d %d\n&quot;,key[t],key[fa[t]],key[fa[fa[t]]]);
	}
	if (ff==0) root=t;
	//printf(&quot;\n&quot;);
}
void ins(int t,int x)
{
	if (!t)
	{
		root=++size;
		key[root]=x;
		num[root]=1;
		fa[root]=0;
		//son[root][0]=0;
		//son[root][1]=0;
		return;
	}
	else if (key[t]==x)
	{
		++num[t];
		splay(t,0);
	}
	if (!son[t][x&lt;key[t]])
	{
		son[t][x&lt;key[t]]=++size;
		fa[size]=t;
		key[size]=x;
		num[size]=1;
		//son[size][0]=0;
		//son[size][1]=0;
		splay(size,0);
	}
	else ins(son[t][x&lt;key[t]],x);
}
int pred(int t)
{
	if (num[t]&gt;1) return key[t];
	int tmp=son[t][0];
	if (!tmp) return inf;
	while (son[tmp][1]) tmp=son[tmp][1];
	return key[tmp];
}
int succ(int t)
{
	if (num[t]&gt;1) return key[t];
	int tmp=son[t][1];
	if (!tmp) return inf;
	while (son[tmp][0]) tmp=son[tmp][0];
	return key[tmp];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	scanf(&quot;%d&quot;,&amp;a[1]);
	ans=a[1];
	ins(root,a[1]);
	for (i=2;i&lt;=n;i++)
	{
		//printf(&quot;\n-------------------------------\n%d\n&quot;,ans);
		//printf(&quot;%d\n&quot;,key[son[root][0]]);
		scanf(&quot;%d&quot;,&amp;a[i]);
		ins(root,a[i]);
		//printf(&quot;%d %d %d\n&quot;,key[root],key[son[root][0]],key[son[root][1]]);
		int t1=pred(root),t2=succ(root);
		//printf(&quot;%d %d\n\n&quot;,t1,t2);
		ans+=min(abs(t1-a[i]),abs(t2-a[i]));
	}
	//printf(&quot;\n\n\n&quot;);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1588</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int inf=99999999;
int key[100000],son[100000][2],fa[100000],num[100000],a[100000];
int ans,root,t1,t2,size,n,i;
int abs(int x) {return x&lt;0?-x:x;}
int min(int a,int b) {return a&lt;b?a:b;}
void rotate(int t,int p)
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][1-p]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
}
void splay(int t,int ff)
{
	//printf(&quot;\n&quot;);
	//printf(&quot;%d %d %d\n&quot;,key[t],key[fa[t]],key[fa[fa[t]]]);
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(t,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(t,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
		//printf(&quot;%d %d %d\n&quot;,key[t],key[fa[t]],key[fa[fa[t]]]);
	}
	if (ff==0) root=t;
	//printf(&quot;\n&quot;);
}
void ins(int t,int x)
{
	if (!t)
	{
		root=++size;
		key[root]=x;
		num[root]=1;
		fa[root]=0;
		//son[root][0]=0;
		//son[root][1]=0;
		return;
	}
	else if (key[t]==x)
	{
		++num[t];
		splay(t,0);
	}
	else if (!son[t][x&lt;key[t]])
	{
		son[t][x&lt;key[t]]=++size;
		fa[size]=t;
		key[size]=x;
		num[size]=1;
		//son[size][0]=0;
		//son[size][1]=0;
		splay(size,0);
	}
	else ins(son[t][x&lt;key[t]],x);
}
int pred(int t)
{
	if (num[t]&gt;1) return key[t];
	int tmp=son[t][0];
	if (!tmp) return inf;
	while (son[tmp][1]) tmp=son[tmp][1];
	return key[tmp];
}
int succ(int t)
{
	if (num[t]&gt;1) return key[t];
	int tmp=son[t][1];
	if (!tmp) return inf;
	while (son[tmp][0]) tmp=son[tmp][0];
	return key[tmp];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	scanf(&quot;%d&quot;,&amp;a[1]);
	ans=a[1];
	ins(root,a[1]);
	for (i=2;i&lt;=n;i++)
	{
		//printf(&quot;\n-------------------------------\n%d\n&quot;,ans);
		//printf(&quot;%d\n&quot;,key[son[root][0]]);
		scanf(&quot;%d&quot;,&amp;a[i]);
		ins(root,a[i]);
		//printf(&quot;%d %d %d\n&quot;,key[root],key[son[root][0]],key[son[root][1]]);
		int t1=pred(root),t2=succ(root);
		//printf(&quot;%d %d\n\n&quot;,t1,t2);
		ans+=min(abs(t1-a[i]),abs(t2-a[i]));
	}
	//printf(&quot;\n\n\n&quot;);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1589</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define ll long long
using namespace std;
inline ll read()
{
	ll x=0,f=1;char ch=getchar();
	while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int n,tim,top,scc,cnt;
int to[100005],q[100005],dfn[100005],low[100005];
int head[100005],hav[100005],belong[100005],ans[100005];
bool inq[100005];
struct data{int to,next;}e[100005];
void insert(int u,int v)
{e[++cnt].to=v;e[cnt].next=head[u];head[u]=cnt;}
void tarjan(int x)
{
	int now=0;
	dfn[x]=low[x]=++tim;
	q[++top]=x;inq[x]=1;
	if(inq[to[x]])low[x]=min(low[x],dfn[to[x]]);
	else if(!dfn[to[x]]){tarjan(to[x]);low[x]=min(low[x],low[to[x]]);}
	if(low[x]==dfn[x])
	{
		scc++;
		while(now!=x)
		{
			now=q[top--];
			belong[now]=scc;
			hav[scc]++; 
			inq[now]=0;
		}
	}
}
void rebuild()
{
	for(int i=1;i&lt;=n;i++)
    {
    	if(belong[i]!=belong[to[i]])
		    insert(belong[i],belong[to[i]]); 
    }
}
int solve(int x)
{
	if(ans[x])return ans[x];
	ans[x]=hav[x];
	if(hav[x]==1)
    ans[x]+=solve(e[head[x]].to);
    return ans[x];
}
int main()
{
	n=read();
	for(int i=1;i&lt;=n;i++)
	    to[i]=read();
	for(int i=1;i&lt;=n;i++)
	    if(!dfn[i])tarjan(i);
	rebuild();
	for(int i=1;i&lt;=n;i++)
	    printf(&quot;%d\n&quot;,solve(belong[i]));
	return 0;
}<pre><h2>Problem1597</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define LL long long
int n,i,top,head,tail;
LL dp[510000],stack[510000],q[510000];
struct point{LL x,y;} a[510000];
bool cmp(point a,point b)
{
	if (a.x!=b.x) return a.x&lt;b.x;
	return a.y&lt;b.y;
}
double calc(int k,int j)
{
	return (dp[k]-dp[j])/(a[j+1].y-a[k+1].y);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	for (i=1;i&lt;=n;i++) scanf(&quot;%lld%lld&quot;,&amp;a[i].x,&amp;a[i].y);
	sort(a+1,a+n+1,cmp);
	//for (i=1;i&lt;=n;i++) printf(&quot;%lld %lld\n&quot;,a[i].x,a[i].y);
	stack[top=1]=1;
	for (i=2;i&lt;=n;i++)
	{
		//printf(&quot;%d\n&quot;,top);
		while (top&gt;0&amp;&amp;a[i].y&gt;=a[stack[top]].y) --top;
		stack[++top]=i;
	}
	//printf(&quot;%d\n&quot;,top);
	n=top;
	for (i=1;i&lt;=n;i++) a[i].x=a[stack[i]].x,a[i].y=a[stack[i]].y;
	//for (i=1;i&lt;=n;i++) printf(&quot;%lld %lld\n&quot;,a[i].x,a[i].y);
	head=0,tail=1;
	q[1]=0;
	for (i=1;i&lt;=n;i++)
	{
		while (tail&gt;head+1&amp;&amp;calc(q[head+2],q[head+1])&lt;=a[i].x) ++head;
		int j=q[head+1];
		dp[i]=dp[j]+a[j+1].y*a[i].x;
		while (tail&gt;head+1&amp;&amp;calc(i,q[tail])&lt;=calc(q[tail],q[tail-1])) --tail;
		q[++tail]=i;
	}
	printf(&quot;%lld\n&quot;,dp[n]);
	return 0;
}
<pre><h2>Problem1598</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
typedef long long LL;
const int NN=1111,MM=11111;
int n,m,K,tot,vt[NN],o[NN],aa[MM][3];
LL dist[NN],ans[NN];
struct edge
{
	int a,b,w;
} e[MM];
struct ppt
{
	LL d;
	int v;
	ppt(LL a=0,int b=0) {d=a;v=b;}
	friend bool operator &lt;(ppt a,ppt b) {return a.d&gt;b.d;}
};
priority_queue&lt;ppt&gt; Q;
void dij()
{
	memset(dist,60,sizeof(dist));
	dist[1]=0;
	Q.push(ppt(0,1));
	while (!Q.empty())
	{
		ppt tmp=Q.top();
		Q.pop();
		int v=tmp.v,d=tmp.d;
		if (vt[v]) continue;
		vt[v]=1;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (!vt[y]&amp;&amp;dist[y]&gt;d+aa[p][2])
			{
				dist[y]=d+aa[p][2];
				Q.push(ppt(dist[y],y));
			}
		}
	}
}
void astar()
{
	memset(vt,0,sizeof(vt));
	Q.push(ppt(dist[n],n));
	while (!Q.empty())
	{
		ppt tmp=Q.top();
		Q.pop();
		int v=tmp.v,d=tmp.d-dist[v];
		vt[v]++;
		if (v==1)
		{
			ans[vt[v]]=d;
			if (vt[v]==K) break;
			continue;
		}
		if (vt[v]==K) continue;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			Q.push(ppt(d+aa[p][2]+dist[y],y));
		}
	}
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;K);
	int i;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
		addedge(e[i].b,e[i].a,e[i].w);
	}
	dij();
	memset(o,0,sizeof(o));tot=0;
	for (i=1;i&lt;=m;i++) addedge(e[i].a,e[i].b,e[i].w);
	astar();
	for (i=1;i&lt;=K;i++)
		if (i&lt;=vt[1]) printf(&quot;%lld\n&quot;,ans[i]);
		else printf(&quot;-1\n&quot;);
	return 0;
}<pre><h2>Problem1598</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
typedef long long LL;
const int NN=1005,MM=10005;
int n,m,K,tot,vt[NN],o[NN],aa[MM][3];
LL dist[NN],ans[NN];
struct edge
{
	int a,b,w;
} e[MM];
struct ppt
{
	LL d;
	int v;
	ppt(LL a=0,int b=0) {d=a;v=b;}
	friend bool operator &lt;(ppt a,ppt b) {return a.d&gt;b.d;}
};
priority_queue&lt;ppt&gt; Q;
void dij()
{
	memset(dist,60,sizeof(dist));
	dist[1]=0;
	Q.push(ppt(0,1));
	while (!Q.empty())
	{
		ppt tmp=Q.top();
		Q.pop();
		int v=tmp.v,d=tmp.d;
		if (vt[v]) continue;
		vt[v]=1;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (!vt[y]&amp;&amp;dist[y]&gt;d+aa[p][2])
			{
				dist[y]=d+aa[p][2];
				Q.push(ppt(dist[y],y));
			}
		}
	}
}
void astar()
{
	memset(vt,0,sizeof(vt));
	Q.push(ppt(dist[n],n));
	while (!Q.empty())
	{
		ppt tmp=Q.top();
		Q.pop();
		int v=tmp.v,d=tmp.d-dist[v];
		vt[v]++;
		if (v==1)
		{
			ans[vt[v]]=d;
			if (vt[v]==K) break;
			continue;
		}
		if (vt[v]==K) continue;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			Q.push(ppt(d+aa[p][2]+dist[y],y));
		}
	}
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;K);
	int i;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
		addedge(e[i].b,e[i].a,e[i].w);
	}
	dij();
	memset(o,0,sizeof(o));tot=0;
	for (i=1;i&lt;=m;i++) addedge(e[i].a,e[i].b,e[i].w);
	astar();
	for (i=1;i&lt;=K;i++)
		if (i&lt;=vt[1]) printf(&quot;%lld\n&quot;,ans[i]);
		else printf(&quot;-1\n&quot;);
	return 0;
}<pre><h2>Problem1598</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
using namespace std;
const int NN=1005,MM=10005;
int o[NN],aa[MM][3],dist[NN],num[NN];
int n,m,K,tot;
bool vt[NN];
struct ppt
{
	int v,d;
	ppt(int a=0,int b=0) {v=a;d=b;}
	friend bool operator &lt;(ppt a,ppt b) {return a.d&gt;b.d;}
};
priority_queue&lt;ppt&gt; Q;
struct edge
{
	int a,b,w;
} e[MM];
void dij()
{
	memset(dist,60,sizeof(dist));
	dist[1]=0;
	Q.push(ppt(1,0));
	while (!Q.empty())
	{
		int v=Q.top().v;
		Q.pop();
		if (vt[v]) continue;
		vt[v]=true;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (!vt[y]&amp;&amp;dist[y]&gt;dist[v]+aa[p][2])
			{
				dist[y]=dist[v]+aa[p][2];
				Q.push(ppt(y,dist[y]));
			}
		}
	}
}
void A_star()
{
	Q.push(ppt(n,dist[n]));
	while (!Q.empty())
	{
		int v=Q.top().v,d=Q.top().d;
		d-=dist[v];
		Q.pop();
		if (v==1)
		{
			printf(&quot;%d\n&quot;,d);
			num[v]++;
			if (num[v]==K) return;
			continue;
		}
		if (num[v]==K) continue;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			Q.push(ppt(y,dist[y]+d+aa[p][2]));
		}
	}
	for (int i=num[1]+1;i&lt;=K;i++) printf(&quot;-1\n&quot;);
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;K);
	int i;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
		addedge(e[i].b,e[i].a,e[i].w);
	}
	dij();
	memset(o,0,sizeof(o));tot=1;
	for (i=1;i&lt;=m;i++) addedge(e[i].a,e[i].b,e[i].w);
	A_star();
	return 0;
}<pre><h2>Problem1598</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
using namespace std;
const int NN=1005,MM=10005;
int o[NN],aa[MM][3],dist[NN],num[NN];
int n,m,K,tot;
bool vt[NN];
struct ppt
{
	int v,d;
	ppt(int a=0,int b=0) {v=a;d=b;}
	friend bool operator &lt;(ppt a,ppt b) {return a.d&gt;b.d;}
};
priority_queue&lt;ppt&gt; Q;
struct edge
{
	int a,b,w;
} e[MM];
void dij()
{
	memset(dist,60,sizeof(dist));
	dist[1]=0;
	Q.push(ppt(1,0));
	while (!Q.empty())
	{
		int v=Q.top().v;
		Q.pop();
		if (vt[v]) continue;
		vt[v]=true;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (!vt[y]&amp;&amp;dist[y]&gt;dist[v]+aa[p][2])
			{
				dist[y]=dist[v]+aa[p][2];
				Q.push(ppt(y,dist[y]));
			}
		}
	}
}
void A_star()
{
	Q.push(ppt(n,dist[n]));
	while (!Q.empty())
	{
		int v=Q.top().v,d=Q.top().d;
		d-=dist[v];
		Q.pop();
		num[v]++;
		if (v==1)
		{
			printf(&quot;%d\n&quot;,d);
			if (num[v]==K) return;
			continue;
		}
		if (num[v]==K) continue;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			Q.push(ppt(y,dist[y]+d+aa[p][2]));
		}
	}
	for (int i=num[1]+1;i&lt;=K;i++) printf(&quot;-1\n&quot;);
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;K);
	int i;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
		addedge(e[i].b,e[i].a,e[i].w);
	}
	dij();
	memset(o,0,sizeof(o));tot=1;
	for (i=1;i&lt;=m;i++) addedge(e[i].a,e[i].b,e[i].w);
	A_star();
	return 0;
}<pre><h2>Problem1598</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
using namespace std;
const int NN=1111,MM=11111;
int o[NN],aa[MM][3],dist[NN];
int n,m,tot,K;
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
struct edge
{
	int u,v,w;
	void in() {scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);}
	void add2() {addedge(v,u,w);}
	void add() {addedge(u,v,w);}
} e[MM];
struct ppt
{
	int v,d;
	ppt(int a=0,int b=0) {v=a;d=b;}
	friend bool operator &lt;(ppt a,ppt b) {return a.d&gt;b.d;}
};
priority_queue&lt;ppt&gt; Q;
void dij()
{
	static bool vt[NN];
	memset(dist,60,sizeof(dist));
	dist[1]=0;
	Q.push(ppt(1,0));
	while (!Q.empty())
	{
		ppt tmp=Q.top();Q.pop();
		int v=tmp.v,d=tmp.d;
		if (vt[v]) continue;
		vt[v]=true;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (dist[y]&gt;d+aa[p][2])
			{
				dist[y]=d+aa[p][2];
				Q.push(ppt(y,dist[y]));
			}
		}
	}
}
void astar()
{
	Q.push(ppt(n,dist[n]));
	static int vt[NN];
	while (!Q.empty())
	{
		ppt tmp=Q.top();Q.pop();
		int v=tmp.v,d=tmp.d-dist[v];
		vt[v]++;
		if (v==1)
		{
			printf(&quot;%d\n&quot;,d);
			if (vt[v]==K) break;
		}
		if (vt[v]&gt;K) continue;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			Q.push(ppt(y,d+aa[p][2]+dist[y]));
		}
	}
	for (int i=vt[1]+1;i&lt;=K;i++) printf(&quot;-1\n&quot;);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;K);
	int i;
	for (i=1;i&lt;=m;i++) e[i].in(),e[i].add2();
	dij();
	memset(o,0,sizeof(o));tot=0;
	for (i=1;i&lt;=m;i++) e[i].add();
	astar();
	return 0;
}<pre><h2>Problem1598</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=1011,MM=100111;
int o[NN],aa[MM&lt;&lt;1][3],dist2[NN];
int n,m,tot,K;
bool vt[NN];
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
struct edge
{
	int u,v,w;
} e[MM];
struct ppt
{
	int v,d;
	ppt(int a=0,int b=0) {v=a;d=b;}
	friend bool operator &lt;(const ppt &amp;a,const ppt &amp;b) {return a.d&gt;b.d;}
};
priority_queue&lt;ppt&gt; Q;
void dij()
{
	memset(dist2,60,sizeof(dist2));
	dist2[1]=0;
	Q.push(ppt(1,0));
	while (!Q.empty())
	{
		int v=Q.top().v,d=Q.top().d;
		Q.pop();
		if (vt[v]) continue;
		vt[v]=true;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (!vt[y]&amp;&amp;dist2[y]&gt;d+aa[p][2])
			{
				dist2[y]=d+aa[p][2];
				Q.push(ppt(y,dist2[y]));
			}
		}
	}
	//printf(&quot;dist2 &quot;);for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,dist2[i]);ln;
}
void astar()
{
	static int vt[NN];
	Q.push(ppt(n,dist2[n]));
	while (!Q.empty())
	{
		int v=Q.top().v,d=Q.top().d-dist2[v];
		Q.pop();
		vt[v]++;
		if (v==1)
		{
			printf(&quot;%d\n&quot;,d);
			if (vt[v]==K) return;
		}
		if (vt[v]&gt;K) continue;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			Q.push(ppt(y,d+aa[p][2]+dist2[y]));
		}
	}
	for (int i=vt[1]+1;i&lt;=K;i++) printf(&quot;-1\n&quot;);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;K);
	int i;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].w);
		addedge(e[i].v,e[i].u,e[i].w);
	}
	dij();
	memset(o,0,sizeof(o));tot=0;
	for (i=1;i&lt;=m;i++)
		addedge(e[i].u,e[i].v,e[i].w);
	astar();
	return 0;
}<pre><h2>Problem1601</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
int fa[1000],n,m;
struct edge
{
	int u,v,w;
	edge(int a=0,int b=0,int c=0) {u=a;v=b;w=c;}
	friend bool operator &lt;(edge a,edge b) {return a.w&lt;b.w;}
	void out() {printf(&quot;%d %d  %d\n&quot;,u,v,w);}
} e[201111];
int getfa(int x) {return fa[x]==x?x:fa[x]=getfa(fa[x]);}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,j,x;
	scanf(&quot;%d&quot;,&amp;n);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		e[++m]=edge(i,n+1,x);
	}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			if (i&lt;j) e[++m]=edge(i,j,x);
		}
	//for (i=1;i&lt;=m;i++) e[i].out();
	sort(e+1,e+m+1);
	for (i=1;i&lt;=n+1;i++) fa[i]=i;
	int ans=0;
	for (i=1;i&lt;=m;i++)
	{
		int x=getfa(e[i].u),y=getfa(e[i].v);
		if (x==y) continue;
		ans+=e[i].w;
		fa[x]=y;
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1601</h2><pre>const
  maxn=1001000;
var
  i,j,n,m,t,tot,ans:longint;
  x,y,w,fa:array[0..maxn]of longint;
function  getfa(x:longint):longint;
begin
  if fa[x]=x then exit(x);
  fa[x]:=getfa(fa[x]);
  exit(fa[x]);
end;
procedure swap(var a,b:longint);
var
  t:longint;
begin
  t:=a;a:=b;b:=t;
end;
procedure qsort(l,r:longint);
var
  i,j,m,t:longint;
begin
  i:=l;
  j:=r;
  m:=w[random(r-l+1)+l];
  repeat
    while w[i]&lt;m do inc(i);
    while w[j]&gt;m do dec(j);
    if i&lt;=j then
      begin
        swap(w[i],w[j]);
        swap(x[i],x[j]);
        swap(y[i],y[j]);
        inc(i);dec(j);
      end;
  until i&gt;j;
  if i&lt;r then qsort(i,r);
  if l&lt;j then qsort(l,j);
end;

begin
  readln(n);
  for i:=1 to n do
    begin
      readln(w[i]);
      x[i]:=0; y[i]:=i;
    end;
  tot:=n;
  for i:=1 to n do
    for j:=1 to n  do
      begin
        read(t);
        if j=i then continue;
        inc(tot);
        x[tot]:=i; y[tot]:=j; w[tot]:=t;
      end;
  qsort(1,tot);
  for i:=0 to n do
    fa[i]:=i;
  j:=1; ans:=0;
  for i:=1 to n do
    begin
      while getfa(x[j])=getfa(y[j])do inc(j);
      inc(ans,w[j]);
      fa[getfa(x[j])]:=getfa(fa[y[j]]);
    end;
  writeln(ans);
end.<pre><h2>Problem1602</h2><pre>var
  aa:array[0..1000000,1..3]of longint;
  q:array[0..1000000]of longint;
  o,deep:array[0..1000000]of longint;
  fa,ll:array[0..100000,0..20]of longint;
  vt:array[0..1000000]of boolean;
  n,m,x,y,z,head,tail,i,tot,j,p:longint;
procedure swap(var a,b:longint);
var t:longint;
begin
  t:=a;
  a:=b;
  b:=t;
end;
procedure add(p,q,v:longint);
begin
  inc(tot);
  aa[tot,1]:=q;
  aa[tot,2]:=v;
  aa[tot,3]:=o[p];
  o[p]:=tot;
end;
procedure init;
begin
  readln(n,m);
  for i:=1 to n-1 do
    begin
      readln(x,y,z);
      add(x,y,z);
      add(y,x,z);
    end;
  head:=0;tail:=0;
  fillchar(vt,sizeof(vt),false);
  inc(tail);
  q[tail]:=1;
  vt[1]:=true;
  fa[1,0]:=0;
  ll[1,0]:=0;
  deep[1]:=1;
  while head&lt;tail do
    begin
      inc(head);
      x:=q[head];
      p:=o[x];
      while p&gt;0 do
        begin
          y:=aa[p,1];
          if not vt[y] then
            begin
              deep[y]:=deep[x]+1;
              fa[y,0]:=x;
              ll[y,0]:=aa[p,2];
              inc(tail);
              q[tail]:=y;
              vt[y]:=true;
            end;
          p:=aa[p,3];
        end;
    end;
  for j:=1 to 20 do
    for i:=1 to n do
      begin
        fa[i,j]:=fa[fa[i,j-1],j-1];
        ll[i,j]:=ll[i,j-1]+ll[fa[i,j-1],j-1];
      end;
  //for i:=1 to n do writeln(fa[i,0]);
end;
function calc(x,y:longint):longint;
var i,res:longint;
begin
  res:=0;
  if deep[x]&lt;deep[y] then swap(x,y);
  for i:=20 downto 0 do
    if deep[fa[x,i]]&gt;=deep[y] then
      begin
        res:=res+ll[x,i];
        x:=fa[x,i];
      end;
  if x=y then exit(res);
  for i:=20 downto 0 do
    if fa[x,i]&lt;&gt;fa[y,i] then
      begin
        res:=res+ll[x,i];
        x:=fa[x,i];
        res:=res+ll[y,i];
        y:=fa[y,i];
      end;
  res:=res+ll[x,0]+ll[y,0];
  exit(res);
end;
procedure doit;
begin
  for i:=1 to m do
    begin
      readln(x,y);
      writeln(calc(x,y));
    end;
end;
begin
  //assign(input,'sss.in');reset(input);
  //assign(output,'sss.out');rewrite(output);
  init;
  doit;
  //close(input);close(output);
end.<pre><h2>Problem1602</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
#define NN 1100
int aa[NN*2][3],fa[NN],fa2[NN],deep[NN],ans[NN],o[NN];
int tot,n,m;
bool vt[NN];
vector&lt;int&gt; ask[NN],id[NN];
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int getroot(int x) {return fa2[x]==x?x:fa2[x]=getroot(fa2[x]);}
void dfs(int v)
{
	vt[v]=true;
	for (int i=0;i&lt;ask[v].size();i++)
	{
		int y=ask[v][i];
		if (vt[y]) ans[id[v][i]]=deep[v]+deep[y]-2*deep[getroot(y)];
	}
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+aa[p][2];
		dfs(y);
	}
	fa2[v]=fa[v];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z);
		addedge(y,x,z);
	}
	for (i=1;i&lt;=n;i++) fa2[i]=i,vt[i]=false;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		ask[x].push_back(y);
		id[x].push_back(i);
		ask[y].push_back(x);
		id[y].push_back(i);
	}
	dfs(1);
	for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
}
<pre><h2>Problem1602</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
#define NN 1100
#define PB push_back
int aa[NN*2][3],fa[NN],fa2[NN],deep[NN],ans[NN],o[NN];
int tot,n,m;
bool vt[NN];
vector&lt;int&gt; ask[NN],id[NN];
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int getroot(int x) {return fa2[x]==x?x:fa2[x]=getroot(fa2[x]);}
void dfs(int v)
{
	vt[v]=true;
	for (int i=0;i&lt;ask[v].size();i++)
	{
		int y=ask[v][i];
		if (vt[y]) ans[id[v][i]]=deep[v]+deep[y]-2*deep[getroot(y)];
	}
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+aa[p][2];
		dfs(y);
	}
	fa2[v]=fa[v];
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z);
		addedge(y,x,z);
	}
	for (i=1;i&lt;=n;i++) fa2[i]=i,vt[i]=false;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		ask[x].PB(y);
		id[x].PB(i);
		ask[y].PB(x);
		id[y].PB(i);
	}
	dfs(1);
	for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
}
<pre><h2>Problem1602</h2><pre>//bzoj1602
#include &lt;cstdio&gt;
using namespace std;
int a[3000],next[3000],last[1001],w[3001],d[1001],f[1001],a2[3000],next2[3000],last2[1001],where[3000],n,m,q,que,deep[1001],fa[1001],ans[1001];
bool t[1001];
void build(int x,int y,int z)
{
	a[++m]=y;
	next[m]=last[x];
	last[x]=m;
	w[m]=z;
	a[++m]=x;
	next[m]=last[y];
	last[y]=m;
	w[m]=z;
}
void build2(int x,int y)
{
	a2[++m]=y;
	next2[m]=last2[x];
	last2[x]=m;
	where[m]=q;
	a2[++m]=x;
	next2[m]=last2[y];
	last2[y]=m;
	where[m]=q;
}
int find(int x)
{
	int y,z;
	y=x;
	while (fa[x]!=0) x=fa[x];
	z=x;
	x=y;
	while (fa[x]!=0) {y=fa[x]; fa[x]=z; x=y;}
	return z;
}
void dfs(int x)
{
	int j;
	t[x]=1;//必须要把这个放在dfs的开头不能放在末尾，不然没有办法处理两个点的lca是其中一个点的情况
	for (j=last2[x];j!=0;j=next2[j])
		if (t[a2[j]]) ans[where[j]]=d[x]+d[a2[j]]-2*d[find(a2[j])]; 
	for (j=last[x];j!=0;j=next[j]) if (a[j]!=f[x])
	{
		f[a[j]]=x;
		d[a[j]]=d[x]+w[j];
		dfs(a[j]);
	}
	fa[x]=f[x];
}
int main()
{
	int i,j,x,y,z;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;que);
	for (i=1;i&lt;=n-1;i++) {scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); build(x,y,z); }
	m=0;
	for (q=1;q&lt;=que;q++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		build2(x,y);
	}
	t[1]=1;
	for (j=last[1];j!=0;j=next[j]) {f[a[j]]=1; d[a[j]]=w[j]; dfs(a[j]);}
	for (i=1;i&lt;=que;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem1602</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
#define NN 1100
#define PB push_back
int aa[NN*2][3],fa[NN],fa2[NN],deep[NN],ans[NN],o[NN];
int tot,n,m;
bool vt[NN];
vector&lt;int&gt; ask[NN],id[NN];
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int getroot(int x) {return fa2[x]==x?x:fa2[x]=getroot(fa2[x]);}
void dfs(int v)
{
	vt[v]=true;
	for (int i=0;i&lt;ask[v].size();i++)
	{
		int y=ask[v][i];
		if (vt[y]) ans[id[v][i]]=deep[v]+deep[y]-2*deep[getroot(y)];
	}
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+aa[p][2];
		dfs(y);
	}
	fa2[v]=fa[v];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z);
		addedge(y,x,z);
	}
	for (i=1;i&lt;=n;i++) fa2[i]=i,vt[i]=false;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		ask[x].PB(y);
		id[x].PB(i);
		ask[y].PB(x);
		id[y].PB(i);
	}
	dfs(1);
	for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
}
<pre><h2>Problem1602</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
#define NN 1100
#define PB push_back
int aa[NN*2][3],fa[NN],fa2[NN],deep[NN],ans[NN],o[NN];
int tot,n,m;
bool vt[NN];
vector&lt;int&gt; ask[NN],id[NN];
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int getroot(int x) {return fa2[x]==x?x:fa2[x]=getroot(fa2[x]);}
void dfs(int v)
{
	vt[v]=true;
	for (int i=0;i&lt;ask[v].size();i++)
	{
		int y=ask[v][i];
		if (vt[y]) ans[id[v][i]]=deep[v]+deep[y]-2*deep[getroot(y)];
	}
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+aa[p][2];
		dfs(y);
		fa2[y]=v;
	}
	//fa2[v]=fa[v];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z);
		addedge(y,x,z);
	}
	for (i=1;i&lt;=n;i++) fa2[i]=i,vt[i]=false;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		ask[x].PB(y);
		id[x].PB(i);
		ask[y].PB(x);
		id[y].PB(i);
	}
	dfs(1);
	for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
}
<pre><h2>Problem1602</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=1111;
int fa[NN],sta[NN],cur[NN],o[NN],aa[NN*2][3],f[10][NN],deep[NN],dist[NN];
int n,m,tot=1,top;
void dfs()
{
	sta[top=1]=1;
	cur[1]=o[1];
	while (top)
	{
		int v=sta[top];
		int p=cur[v];
		if (p==0) {top--;continue;}
		cur[v]=aa[p][0];
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		dist[y]=dist[v]+aa[p][2];
		cur[y]=o[y];
		sta[++top]=y;
	}
}
void dfs(int v)
{
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		dist[y]=dist[v]+aa[p][2];
		dfs(y);
	}
}
int getlca(int x,int y)
{
	int i;
	if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
	for (i=9;i&gt;=0;i--)
		if (deep[f[i][x]]&gt;=deep[y]) x=f[i][x];
	if (x==y) return x;
	for (i=9;i&gt;=0;i--)
		if (f[i][x]!=f[i][y]) x=f[i][x],y=f[i][y];
	return f[0][x];
}
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
	}
	deep[1]=1;
	dfs(1);
	for (i=1;i&lt;=n;i++) f[0][i]=fa[i];
	for (j=1;j&lt;=9;j++)
		for (i=1;i&lt;=n;i++) f[j][i]=f[j-1][f[j-1][i]];
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		int lca=getlca(x,y);
		printf(&quot;%d\n&quot;,dist[x]+dist[y]-dist[lca]*2);
	}
	return 0;
}<pre><h2>Problem1602</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int NN=1011;
int fa[NN],sta[NN],cur[NN],o[NN],aa[NN*2][3],f[10][NN],deep[NN],dist[NN];
int n,m,tot=1,top;
void dfs()
{
	sta[top=1]=1;
	cur[1]=o[1];
	while (top)
	{
		int v=sta[top];
		int p=cur[v];
		if (p==0) {top--;continue;}
		cur[v]=aa[p][0];
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		dist[y]=dist[v]+aa[p][2];
		cur[y]=o[y];
		sta[++top]=y;
	}
}
int getlca(int x,int y)
{
	int i;
	if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
	for (i=9;i&gt;=0;i--)
		if (deep[f[i][x]]&gt;=deep[y]) x=f[i][x];
	if (x==y) return x;
	for (i=9;i&gt;=0;i--)
		if (f[i][x]!=f[i][y]) x=f[i][x],y=f[i][y];
	return f[0][x];
}
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
	}
	deep[1]=1;
	dfs();
	for (i=1;i&lt;=n;i++) f[0][i]=fa[i];
	for (j=1;j&lt;=9;j++)
		for (i=1;i&lt;=n;i++) f[j][i]=f[j-1][f[j-1][i]];
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		int lca=getlca(x,y);
		printf(&quot;%d\n&quot;,dist[x]+dist[y]-dist[lca]*2);
	}
	return 0;
}<pre><h2>Problem1602</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=1011;
int fa[NN],sta[NN],cur[NN],o[NN],aa[NN*2][3],f[10][NN],deep[NN],dist[NN];
int n,m,tot=1,top;
void dfs()
{
	sta[top=1]=1;
	cur[1]=o[1];
	while (top)
	{
		int v=sta[top];
		int p=cur[v];
		if (p==0) {top--;continue;}
		cur[v]=aa[p][0];
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		dist[y]=dist[v]+aa[p][2];
		cur[y]=o[y];
		sta[++top]=y;
	}
}
int getlca(int x,int y)
{
	int i;
	if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
	for (i=9;i&gt;=0;i--)
		if (deep[f[i][x]]&gt;=deep[y]) x=f[i][x];
	if (x==y) return x;
	for (i=9;i&gt;=0;i--)
		if (f[i][x]!=f[i][y]) x=f[i][x],y=f[i][y];
	return f[0][x];
}
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
	}
	deep[1]=1;
	dfs();
	for (i=1;i&lt;=n;i++) f[0][i]=fa[i];
	for (j=1;j&lt;=9;j++)
		for (i=1;i&lt;=n;i++) f[j][i]=f[j-1][f[j-1][i]];
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		int lca=getlca(x,y);
		printf(&quot;%d\n&quot;,dist[x]+dist[y]-dist[lca]*2);
	}
	return 0;
}<pre><h2>Problem1602</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
#define pb push_back
const int NN=1011;
int fa[NN],f[NN],aa[NN*2][3],o[NN],lca[NN],dist[NN];
int n,m,tot=1;
bool vt[NN];
vector&lt;int&gt; qu[NN];
struct query
{
	int u,v,id;
	void in(int i)
	{
		id=i;
		scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
		qu[u].pb(i),qu[v].pb(i);
	}
	void swp() {int t=u;u=v;v=t;}
	void ans()
	{
		int res=dist[u]+dist[v]-2*dist[lca[id]];
		printf(&quot;%d\n&quot;,res);
	}
} q[NN];
int getfa(int x) {return f[x]==x?x:f[x]=getfa(f[x]);}
void dfs(int v)
{
	vt[v]=true;
	for (int t=qu[v].size(),i=0;i&lt;t;i++)
	{
		int k=qu[v][i];
		if (v==q[k].v) q[k].swp();
		if (vt[q[k].v]) lca[k]=getfa(q[k].v);
	}
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dist[y]=dist[v]+aa[p][2];
		dfs(y);
	}
	f[v]=fa[v];
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
	}
	for (i=1;i&lt;=m;i++) q[i].in(i);
	for (i=1;i&lt;=n;i++) f[i]=i;
	dfs(1);
	for (i=1;i&lt;=m;i++) q[i].ans();
	return 0;
}<pre><h2>Problem1602</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
#define pb push_back
const int NN=1011;
int o[NN],aa[NN&lt;&lt;1][3],dist[NN],fa[NN];
int n,m,tot=1;
vector&lt;int&gt; ask[NN];
bool vt[NN];
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
struct query
{
	int u,v,lca;
	void in(int i)
	{
		scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
		if (u&gt;v) {int t=u;u=v;v=t;}
		ask[u].pb(i),ask[v].pb(i);
	}
	int getans() {return dist[u]+dist[v]-(dist[lca]&lt;&lt;1);}
} qry[NN];
struct Bcj
{
	int fa[NN];
	void init() {for (int i=1;i&lt;=n;i++) fa[i]=i;}
	int getfa(int x) {return fa[x]==x?x:fa[x]=getfa(fa[x]);}
	void merge(int x,int y) {fa[getfa(x)]=getfa(y);}
} bcj;
void dfs(int v)
{
	vt[v]=true;
	for (int j=0;j&lt;ask[v].size();j++)
	{
		int t=ask[v][j];
		if (v==qry[t].v) swap(qry[t].u,qry[t].v);
		if (vt[qry[t].v]) qry[t].lca=bcj.getfa(qry[t].v);
	}
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dist[y]=dist[v]+aa[p][2];
		dfs(y);
	}
	bcj.merge(v,fa[v]);
}
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
	}
	for (i=1;i&lt;=m;i++) qry[i].in(i);
	bcj.init();
	dfs(1);
	for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,qry[i].getans());
	return 0;
}<pre><h2>Problem1604</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
int fa[110000],son[110000][2],f[110000],ans[110000];
int n,dd,i,size,root,x,y,now,ans1,ans2;
int max(int a,int b) {return a&gt;b?a:b;}
struct ppt
{
	int x,y,id;
} a[110000],key[110000];
bool cmp(ppt a,ppt b)
{
	return a.x&lt;b.x;
}
void rotate(int t,int p)
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(t,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(t,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
}
void splayins(int &amp;t,ppt x,int ff)
{
	if (t==0)
	{
		t=++size;
		fa[t]=ff;
		son[t][0]=son[t][1]=0;
		key[t]=x;
		splay(t,0);
		return;
	}
	if (x.y&lt;key[t].y) splayins(son[t][0],x,t);
	else splayins(son[t][1],x,t);
}
void splaydel(int t,ppt x)
{
	for (;t;)
	{
		if (x.y==key[t].y) break;
		if (x.y&lt;key[t].y) t=son[t][0];
		else t=son[t][1];
	}
	splay(t,0);
	if (son[t][0]==0) {root=son[t][1];fa[son[t][1]]=0;return;}
	if (son[t][1]==0) {root=son[t][0];fa[son[t][0]]=0;return;}
	int y=son[t][0];
	for (;son[y][1];y=son[y][1]);
	splay(y,t);
	son[y][1]=son[t][1];
	fa[son[t][1]]=y;
	fa[y]=0;
	root=y;
}
int pred(int t,int x)
{
	int res=-1;
	for (;t;)
	{
		if (x&gt;key[t].y) res=t,t=son[t][1];
		else if (x==key[t].y) return t;
		else t=son[t][0];
	}
	return res;
}
int succ(int t,int x)
{
	int res=-1;
	for (;t;)
	{
		if (x&lt;key[t].y) res=t,t=son[t][0];
		else if (x==key[t].y) return t;
		else t=son[t][1];
	}
	return res;
}
int getfa(int x)
{
	if (f[x]==x) return x;
	f[x]=getfa(f[x]);
	return f[x];
}
void join(int x,int y)
{
	f[getfa(x)]=getfa(y);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;dd);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		a[i].x=x+y;
		a[i].y=x-y;
		a[i].id=i;
		f[i]=i;
	}
	sort(a+1,a+n+1,cmp);
	now=1;
	for (i=1;i&lt;=n;i++)
	{
		while (a[i].x-a[now].x&gt;dd&amp;&amp;now&lt;=n)
		{
			splay(now,0);
			splaydel(root,a[now]);
			++now;
		}
		int tmp=pred(root,a[i].y);
		if (tmp!=-1&amp;&amp;a[i].y-key[tmp].y&lt;=dd) join(a[i].id,key[tmp].id),splay(tmp,0);
		tmp=succ(root,a[i].y);
		if (tmp!=-1&amp;&amp;key[tmp].y-a[i].y&lt;=dd) join(a[i].id,key[tmp].id),splay(tmp,0);
		splayins(root,a[i],0);
	}
	for (i=1;i&lt;=n;i++) ans[getfa(i)]++;
	ans1=ans2=0;
	for (i=1;i&lt;=n;i++)
		if (ans[i])
		{
			ans1++;
			ans2=max(ans2,ans[i]);
		}
	printf(&quot;%d %d\n&quot;,ans1,ans2);
	return 0;
}<pre><h2>Problem1604</h2><pre>var key,f,a,b,ff,sum:array[0..100000]of longint;
son:array[1..100000,1..2]of longint;
i,j,k,m,n,d,xx,max,yy,root,ans,head,tt:longint;
procedure sort(l,r: longint);
      var
         i,j,x,y: longint;
      begin
         i:=l;
         j:=r;
         x:=a[(l+r) div 2];
         repeat
           while a[i]&lt;x do
            inc(i);
           while x&lt;a[j] do
            dec(j);
           if not(i&gt;j) then
             begin
                y:=a[i];
                a[i]:=a[j];
                a[j]:=y;
                y:=b[i];
                b[i]:=b[j];
                b[j]:=y;
                inc(i);
                j:=j-1;
             end;
         until i&gt;j;
         if l&lt;j then
           sort(l,j);
         if i&lt;r then
           sort(i,r);
      end;
procedure rotate(x,w:longint);
var y:longint;
begin
 y:=f[x];
 son[y,3-w]:=son[x,w];
 if son[x,w]&lt;&gt;0 then f[son[x,w]]:=y;
 f[x]:=f[y];
 if f[y]&lt;&gt;0 then if y=son[f[y],1] then son[f[y],1]:=x else son[f[y],2]:=x;
 f[y]:=x;
 son[x,w]:=y;
end;
procedure splay(x,t:longint);
var y:longint;
begin
 while f[x]&lt;&gt;t do begin
  y:=f[x];
  if f[y]=t then if x=son[y,1] then rotate(x,2) else rotate(x,1)
  else if y=son[f[y],1] then
   if x=son[y,1] then begin rotate(y,2); rotate(x,2); end
                 else begin rotate(x,1); rotate(x,2); end
   else if x=son[y,1] then begin rotate(x,2); rotate(x,1); end
                      else begin rotate(y,1); rotate(x,1); end;
 end;
 if f[x]=0 then root:=x;
end;
procedure insert(x:longint);
var t:longint;
begin
 key[i]:=x;
 if root=0 then begin
  root:=i;
  exit;
 end;
 t:=root;
 while true do
  if key[t]&gt;x then if son[t,1]=0 then break else t:=son[t,1]
              else if son[t,2]=0 then break else t:=son[t,2];
 f[i]:=t;
 if key[t]&gt;x then son[t,1]:=i else son[t,2]:=i;
 splay(i,0);
end;
procedure delete(x:longint);
var y,t:longint;
begin
 splay(x,0);
 if son[x,1]=0 then begin root:=son[x,2]; f[root]:=0; exit; end;
 t:=son[x,1];
 while son[t,2]&lt;&gt;0 do t:=son[t,2];
 splay(t,root);
 son[t,2]:=son[x,2];
 if son[x,2]&lt;&gt;0 then f[son[x,2]]:=t;
 root:=t;
 f[root]:=0;
end;
function find(x:longint):longint;
var t,y:longint;
begin
 t:=x;
 while ff[t]&lt;&gt;0 do t:=ff[t];
 find:=t;
 t:=x;
 while ff[t]&lt;&gt;0 do begin
  y:=ff[t];
  ff[t]:=find;
  t:=y;
 end;
end;
procedure hebing(x,y:longint);
var xxx,yyy:longint;
begin
 xxx:=find(x);
 yyy:=find(y);
 if xxx&lt;&gt;yyy then begin
  ff[xxx]:=yyy;
  inc(sum[yyy],sum[xxx]);
  sum[xxx]:=0;
 end;
end;
begin
 read(n,d);
 for i:=1 to n do sum[i]:=1;
 for i:=1 to n do begin read(xx,yy); a[i]:=xx+yy; b[i]:=xx-yy; end;
 sort(1,n);
 head:=1;
 for i:=1 to n do begin
   while a[i]-a[head]&gt;d do begin delete(head); inc(head)end;
  tt:=root;
  if tt&lt;&gt;0 then begin
   while key[tt]&lt;&gt;b[i] do
    if key[tt]&gt;b[i] then if son[tt,1]=0 then break else tt:=son[tt,1]
                    else if son[tt,2]=0 then break else tt:=son[tt,2];
   yy:=tt;
   while tt&lt;&gt;0 do if key[tt]&gt;=b[i] then break else tt:=f[tt];
   if (tt&lt;&gt;0)and(key[tt]-b[i]&lt;=d) then hebing(tt,i);
   tt:=yy;
   while tt&lt;&gt;0 do if key[tt]&lt;=b[i] then break else tt:=f[tt];
   if (tt&lt;&gt;0)and(b[i]-key[tt]&lt;=d) then hebing(tt,i);
   splay(yy,0);
  end;
  insert(b[i]);
 end;
 max:=0;
 for i:=1 to n do if ff[i]=0 then begin
  inc(ans);
  if sum[i]&gt;max then max:=sum[i];
 end;
 writeln(ans,' ',max);
end.<pre><h2>Problem1604</h2><pre>var key,f,a,b,ff,sum:array[0..100000]of longint;
son:array[1..100000,1..2]of longint;
i,j,k,m,n,d,xx,max,yy,root,ans,head,tt:longint;
procedure sort(l,r: longint);
      var
         i,j,x,y: longint;
      begin
         i:=l;
         j:=r;
         x:=a[(l+r) div 2];
         repeat
           while a[i]&lt;x do
            inc(i);
           while x&lt;a[j] do
            dec(j);
           if not(i&gt;j) then
             begin
                y:=a[i];
                a[i]:=a[j];
                a[j]:=y;
                y:=b[i];
                b[i]:=b[j];
                b[j]:=y;
                inc(i);
                j:=j-1;
             end;
         until i&gt;j;
         if l&lt;j then
           sort(l,j);
         if i&lt;r then
           sort(i,r);
      end;
procedure rotate(x,w:longint);
var y:longint;
begin
 y:=f[x];
 son[y,3-w]:=son[x,w];
 if son[x,w]&lt;&gt;0 then f[son[x,w]]:=y;
 f[x]:=f[y];
 if f[y]&lt;&gt;0 then if y=son[f[y],1] then son[f[y],1]:=x else son[f[y],2]:=x;
 f[y]:=x;
 son[x,w]:=y;
end;
procedure splay(x,t:longint);
var y:longint;
begin
 while f[x]&lt;&gt;t do begin
  y:=f[x];
  if f[y]=t then if x=son[y,1] then rotate(x,2) else rotate(x,1)
  else if y=son[f[y],1] then
   if x=son[y,1] then begin rotate(y,2); rotate(x,2); end
                 else begin rotate(x,1); rotate(x,2); end
   else if x=son[y,1] then begin rotate(x,2); rotate(x,1); end
                      else begin rotate(y,1); rotate(x,1); end;
 end;
 if f[x]=0 then root:=x;
end;
procedure insert(x:longint);
var t:longint;
begin
 key[i]:=x;
 if root=0 then begin
  root:=i;
  exit;
 end;
 t:=root;
 while true do
  if key[t]&gt;x then if son[t,1]=0 then break else t:=son[t,1]
              else if son[t,2]=0 then break else t:=son[t,2];
 f[i]:=t;
 if key[t]&gt;x then son[t,1]:=i else son[t,2]:=i;
 splay(i,0);
end;
procedure delete(x:longint);
var y,t:longint;
begin
 splay(x,0);
 if son[x,1]=0 then begin root:=son[x,2]; f[root]:=0; exit; end;
 t:=son[x,1];
 while son[t,2]&lt;&gt;0 do t:=son[t,2];
 splay(t,root);
 son[t,2]:=son[x,2];
 if son[x,2]&lt;&gt;0 then f[son[x,2]]:=t;
 root:=t;
 f[root]:=0;
end;
function find(x:longint):longint;
var t,y:longint;
begin
 t:=x;
 while ff[t]&lt;&gt;0 do t:=ff[t];
 find:=t;
 t:=x;
 while ff[t]&lt;&gt;0 do begin
  y:=ff[t];
  ff[t]:=find;
  t:=y;
 end;
end;
procedure hebing(x,y:longint);
var xxx,yyy:longint;
begin
 xxx:=find(x);
 yyy:=find(y);
 if xxx&lt;&gt;yyy then begin
  ff[xxx]:=yyy;
  inc(sum[yyy],sum[xxx]);
  sum[xxx]:=0;
 end;
end;
begin
 read(n,d);
 for i:=1 to n do sum[i]:=1;
 for i:=1 to n do begin read(xx,yy); a[i]:=xx+yy; b[i]:=xx-yy; end;
 sort(1,n);
 head:=1;
 for i:=1 to n do begin
   while a[i]-a[head]&gt;d do begin delete(head); inc(head)end;
  tt:=root;
  if tt&lt;&gt;0 then begin
   while key[tt]&lt;&gt;b[i] do
    if key[tt]&gt;b[i] then if son[tt,1]=0 then break else tt:=son[tt,1]
                    else if son[tt,2]=0 then break else tt:=son[tt,2];
   yy:=tt;
   while tt&lt;&gt;0 do if key[tt]&gt;=b[i] then break else tt:=f[tt];
   if (tt&lt;&gt;0)and(key[tt]-b[i]&lt;=d) then hebing(tt,i);
   tt:=yy;
   while tt&lt;&gt;0 do if key[tt]&lt;=b[i] then break else tt:=f[tt];
   if (tt&lt;&gt;0)and(b[i]-key[tt]&lt;=d) then hebing(tt,i);
   //splay(yy,0);
  end;
  insert(b[i]);
 end;
 max:=0;
 for i:=1 to n do if ff[i]=0 then begin
  inc(ans);
  if sum[i]&gt;max then max:=sum[i];
 end;
 writeln(ans,' ',max);
end.<pre><h2>Problem1604</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
int fa[110000],son[110000][2],f[110000],ans[110000];
int n,dd,i,size,root,x,y,now,ans1,ans2;
int max(int a,int b) {return a&gt;b?a:b;}
struct ppt
{
	int x,y,id;
} a[110000],key[110000];
bool cmp(ppt a,ppt b)
{
	return a.x&lt;b.x;
}
void rotate(int t,int p)
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(t,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(t,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
}
void splayins(int &amp;t,ppt x,int ff)
{
	if (t==0)
	{
		t=++size;
		fa[t]=ff;
		son[t][0]=son[t][1]=0;
		key[t]=x;
		splay(t,0);
		return;
	}
	if (x.y&lt;key[t].y) splayins(son[t][0],x,t);
	else splayins(son[t][1],x,t);
}
void splaydel(int t,ppt x)
{
	/*for (;t;)
	{
		if (x.y==key[t].y) break;
		if (x.y&lt;key[t].y) t=son[t][0];
		else t=son[t][1];
	}*/
	//splay(t,0);
	if (son[t][0]==0) {root=son[t][1];fa[son[t][1]]=0;return;}
	if (son[t][1]==0) {root=son[t][0];fa[son[t][0]]=0;return;}
	int y=son[t][0];
	for (;son[y][1];y=son[y][1]);
	splay(y,t);
	son[y][1]=son[t][1];
	fa[son[t][1]]=y;
	fa[y]=0;
	root=y;
}
int pred(int t,int x)
{
	int res=-1;
	for (;t;)
	{
		if (x&gt;key[t].y) res=t,t=son[t][1];
		else if (x==key[t].y) return t;
		else t=son[t][0];
	}
	return res;
}
int succ(int t,int x)
{
	int res=-1;
	for (;t;)
	{
		if (x&lt;key[t].y) res=t,t=son[t][0];
		else if (x==key[t].y) return t;
		else t=son[t][1];
	}
	return res;
}
int getfa(int x)
{
	if (f[x]==x) return x;
	f[x]=getfa(f[x]);
	return f[x];
}
void join(int x,int y)
{
	f[getfa(x)]=getfa(y);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;dd);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		a[i].x=x+y;
		a[i].y=x-y;
		a[i].id=i;
		f[i]=i;
	}
	sort(a+1,a+n+1,cmp);
	now=1;
	for (i=1;i&lt;=n;i++)
	{
		while (a[i].x-a[now].x&gt;dd&amp;&amp;now&lt;=n)
		{
			splay(now,0);
			splaydel(root,a[now]);
			++now;
		}
		int tmp=pred(root,a[i].y);
		if (tmp!=-1&amp;&amp;a[i].y-key[tmp].y&lt;=dd) join(a[i].id,key[tmp].id),splay(tmp,0);
		tmp=succ(root,a[i].y);
		if (tmp!=-1&amp;&amp;key[tmp].y-a[i].y&lt;=dd) join(a[i].id,key[tmp].id),splay(tmp,0);
		splayins(root,a[i],0);
	}
	for (i=1;i&lt;=n;i++) ans[getfa(i)]++;
	ans1=ans2=0;
	for (i=1;i&lt;=n;i++)
		if (ans[i])
		{
			ans1++;
			ans2=max(ans2,ans[i]);
		}
	printf(&quot;%d %d\n&quot;,ans1,ans2);
	return 0;
}<pre><h2>Problem1604</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
int fa[110000],son[110000][2],f[110000],ans[110000];
int n,dd,i,size,root,x,y,now,ans1,ans2;
int max(int a,int b) {return a&gt;b?a:b;}
struct ppt
{
	int x,y,id;
} a[110000],key[110000];
bool cmp(ppt a,ppt b)
{
	return a.x&lt;b.x;
}
void rotate(int t,int p)
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
}
void splayins(int &amp;t,ppt x,int ff)
{
	if (t==0)
	{
		t=++size;
		fa[t]=ff;
		son[t][0]=son[t][1]=0;
		key[t]=x;
		splay(t,0);
		return;
	}
	if (x.y&lt;key[t].y) splayins(son[t][0],x,t);
	else splayins(son[t][1],x,t);
}
void splaydel(int t,ppt x)
{
	/*for (;t;)
	{
		if (x.y==key[t].y) break;
		if (x.y&lt;key[t].y) t=son[t][0];
		else t=son[t][1];
	}*/
	//splay(t,0);
	if (son[t][0]==0) {root=son[t][1];fa[son[t][1]]=0;return;}
	if (son[t][1]==0) {root=son[t][0];fa[son[t][0]]=0;return;}
	int y=son[t][0];
	for (;son[y][1];y=son[y][1]);
	splay(y,t);
	son[y][1]=son[t][1];
	fa[son[t][1]]=y;
	fa[y]=0;
	root=y;
}
int pred(int t,int x)
{
	int res=-1;
	for (;t;)
	{
		if (x&gt;key[t].y) res=t,t=son[t][1];
		else if (x==key[t].y) return t;
		else t=son[t][0];
	}
	return res;
}
int succ(int t,int x)
{
	int res=-1;
	for (;t;)
	{
		if (x&lt;key[t].y) res=t,t=son[t][0];
		else if (x==key[t].y) return t;
		else t=son[t][1];
	}
	return res;
}
int getfa(int x)
{
	if (f[x]==x) return x;
	f[x]=getfa(f[x]);
	return f[x];
}
void join(int x,int y)
{
	f[getfa(x)]=getfa(y);
}
int main()
{
	//freopen(&quot;nabor.8.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;1604.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;1604.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;dd);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		a[i].x=x+y;
		a[i].y=x-y;
		a[i].id=i;
		f[i]=i;
	}
	sort(a+1,a+n+1,cmp);
	now=1;
	for (i=1;i&lt;=n;i++)
	{
		//printf(&quot;%d\n&quot;,i);
		while (a[i].x-a[now].x&gt;dd&amp;&amp;now&lt;=n)
		{
			splay(now,0);
			splaydel(root,a[now]);
			++now;
		}
		//if (i==50000) printf(&quot;%d\n&quot;,0);
		int tmp=pred(root,a[i].y);
		if (tmp!=-1&amp;&amp;a[i].y-key[tmp].y&lt;=dd) join(a[i].id,key[tmp].id),splay(tmp,0);
		tmp=succ(root,a[i].y);
		if (tmp!=-1&amp;&amp;key[tmp].y-a[i].y&lt;=dd) join(a[i].id,key[tmp].id),splay(tmp,0);
		splayins(root,a[i],0);
	}
	//printf(&quot;%d\n&quot;,0);
	for (i=1;i&lt;=n;i++) ans[getfa(i)]++;
	ans1=ans2=0;
	for (i=1;i&lt;=n;i++)
		if (ans[i])
		{
			ans1++;
			ans2=max(ans2,ans[i]);
		}
	printf(&quot;%d %d\n&quot;,ans1,ans2);
	return 0;
}<pre><h2>Problem1607</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int NN=100111;
int a[NN],b[NN],num[1000111];
int n,mm;
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	int i;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),b[i]=a[i];
	sort(b+1,b+n+1);
	mm=b[n];
	for (int l=1,r;l&lt;=n;l=r)
	{
		for (r=l;b[r]==b[l]&amp;&amp;r&lt;=n;r++);
		int tmp=b[l];
		for (int t=tmp;t&lt;=mm;t+=tmp) num[t]+=r-l;
	}
	for (i=1;i&lt;=n;i++) printf(&quot;%d\n&quot;,num[a[i]]-1);
	return 0;
}<pre><h2>Problem1609</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define inf 1000000000
using namespace std;
int n,ans=inf,a[30001],f[30001][4];
void dp()
{
	memset(f,127,sizeof(f));
	f[0][1]=f[0][2]=f[0][3]=0;
	for(int i=1;i&lt;=n;i++)
	   for(int j=1;j&lt;=3;j++)
	      for(int k=1;k&lt;=j;k++) 
	          if(a[i]==j)
	          f[i][j]=min(f[i][j],f[i-1][k]);
	          else f[i][j]=min(f[i][j],f[i-1][k]+1);
	ans=min(ans,f[n][1]);
    ans=min(ans,f[n][2]);
	ans=min(ans,f[n][3]);
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n;i++)
	   scanf(&quot;%d&quot;,&amp;a[i]);
	dp();
	for(int i=1;i&lt;=(n&gt;&gt;1);i++)
	   swap(a[i],a[n-i+1]);
	dp();
	printf(&quot;%d&quot;,ans);
	return 0;
}<pre><h2>Problem1625</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,m,f[13011];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j,x,y;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		for (j=m;j&gt;=x;j--)
			f[j]=max(f[j],f[j-x]+y);
	}
	int ans=0;
	for (i=0;i&lt;=m;i++)
		if (f[i]&gt;ans) ans=f[i];
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1666</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
using namespace std;
long long n;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	cin&gt;&gt;n;
	int ans=0;
	while (n!=1)
	{
		ans++;
		if (n&amp;1) n=n*3+1;
		else n&gt;&gt;=1;
	}
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1670</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
#define ln printf(&quot;\n&quot;)
const DD eps=1e-7;
const int NN=5011;
int n,cnt;
inline int dcmp(DD x)
{
	if (fabs(x)&lt;eps) return 0;
	return x&lt;0?-1:1;
}
struct point
{
	DD x,y;
	point(DD a=0,DD b=0) {x=a;y=b;}
	inline void in() {scanf(&quot;%lf%lf&quot;,&amp;x,&amp;y);}
	inline void out() {printf(&quot;%.3f %.3f\n&quot;,(DD)x,(DD)y);}
	friend point operator -(const point &amp;a,const point &amp;b) {return point(a.x-b.x,a.y-b.y);}
	friend DD operator %(const point &amp;a,const point &amp;b) {return a.x*b.y-b.x*a.y;}
	friend bool operator &lt;(const point &amp;a,const point &amp;b)
	{
		if (dcmp(a.x-b.x)==0) return a.y&lt;b.y;
		return a.x&lt;b.x;
	}
	friend DD getdist(point a,point b) {return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}
} q[NN],b[NN];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i;
	for (i=1;i&lt;=n;i++) q[i].in();
	sort(q+1,q+n+1);
	cnt=0;
	for (i=1;i&lt;=n;i++)
	{
		while (cnt&gt;1&amp;&amp;dcmp((q[i]-b[cnt-1])%(b[cnt]-b[cnt-1]))&gt;=0) cnt--;
		b[++cnt]=q[i];
	}
	int t=cnt;
	for (i=n-1;i&gt;0;i--)
	{
		while (cnt&gt;t&amp;&amp;dcmp((q[i]-b[cnt-1])%(b[cnt]-b[cnt-1]))&gt;=0) cnt--;
		b[++cnt]=q[i];
	}
	//for (i=1;i&lt;=cnt;i++) b[i].out();
	DD ans=0;
	for (i=1;i&lt;cnt;i++)
		ans+=getdist(b[i],b[i+1]);
	printf(&quot;%.2f\n&quot;,ans);
	return 0;
}<pre><h2>Problem1670</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#define NN 10009
#define DD double
#define esp 0.000000001
#define PP Point
#define dis(a,b) (sqrt((a-b)*(a-b)))
using namespace std;
int n,m,b[NN];
struct  Point
{
	double x,y;
	Point (){}
	Point(DD _x,DD _y){x=_x,y=_y;}
	Point operator +(Point b){return Point(x+b.x,y+b.y);}
	Point operator -(Point b){return Point(x-b.x,y-b.y);}
	double operator %(Point b){return (x*b.y-y*b.x);}
	double operator *(Point b){return x*b.x+y*b.y;}
}p[NN];

bool cmp(Point a,Point b)
{
	return (a.x==b.x)?(a.y&lt;b.y):(a.x&lt;b.x);
}

int main()
{	
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;fc.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	for (int i=1;i&lt;=n;i++)
		scanf(&quot;%lf%lf\n&quot;,&amp;p[i].x,&amp;p[i].y);
	sort(p+1,p+1+n,cmp);
	int num=0;
	for (int i=1;i&lt;=n;i++)
	{
		while (num&gt;1&amp;&amp;(p[b[num]]-p[b[num-1]])%(p[i]-p[b[num-1]])&lt;esp)b[num--]=0;
		b[++num]=i;
	}
	int tmp=num;
	for (int i=n-1;i&gt;=1;i--)
	{
		while(num&gt;tmp&amp;&amp;(p[b[num]]-p[b[num-1]])%(p[i]-p[b[num-1]])&lt;esp)
			b[num--]=0;
		b[++num]=i;
	}
	b[++num]=b[1];
	DD ans=0;
	for (int i=1;i&lt;num;i++)
		ans+=dis(p[b[i]],p[b[i+1]]);
	printf(&quot;%.2lf\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1691</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define LL long long
int son[210000][2],fa[210000],num[210000];
int n,m,now,root,size;
LL ans;
struct orz
{
	int price,tasty;
} a[210000],b[210000],key[210000];
bool cmp(orz x,orz y)
{
	if (x.price!=y.price) return x.price&lt;y.price;
	else return x.tasty&gt;y.tasty;
}
void rotate(int t,int p)
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(t,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(t,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
}
void ins(int &amp;t,orz x,int ff)
{
	if (t==0)
	{
		t=++size;
		fa[t]=ff;
		son[t][0]=son[t][1]=0;
		num[t]=1;
		key[t]=x;
		splay(t,0);
		return;
	}
	if (x.tasty==key[t].tasty) ++num[t],splay(t,0);
	else if (x.tasty&lt;key[t].tasty) ins(son[t][0],x,t);
	else ins(son[t][1],x,t);
}
int pred(int t,orz x)
{
	int res=-1;
	for (;t;)
		if (x.tasty&gt;=key[t].tasty) res=t,t=son[t][1];
		else t=son[t][0];
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (int i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;a[i].price,&amp;a[i].tasty);
	for (int i=1;i&lt;=m;i++) scanf(&quot;%d%d&quot;,&amp;b[i].price,&amp;b[i].tasty);
	sort(a+1,a+n+1,cmp);
	sort(b+1,b+m+1,cmp);
	//for (int i=1;i&lt;=m;i++) printf(&quot;%d %d\n&quot;,b[i].price,b[i].tasty);
	now=1;
	ans=0;
	for (int i=1;i&lt;=m;i++)
	{
		while (a[now].price&lt;=b[i].price&amp;&amp;now&lt;=n)
		{
			ins(root,a[now],0);
			++now;
		}
		int t=pred(root,b[i]);
		if (t==-1) continue;
		ans+=(LL)b[i].price;
		--num[t];
		if (num[t]) continue;
		splay(t,0);
		if (son[t][0]==0) {root=son[t][1];fa[son[t][1]]=0;continue;}
		if (son[t][1]==0) {root=son[t][0];fa[son[t][0]]=0;continue;}
		int y;
		for (y=son[t][0];son[y][1];y=son[y][1]);
		splay(y,root);
		son[y][1]=son[root][1];
		fa[son[root][1]]=y;
		fa[y]=0;
		root=y;
	}
	if (root!=0||now&lt;=n) printf(&quot;%d\n&quot;,-1);
	else printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem1691</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define LL long long
int son[210000][2],fa[210000],num[210000];
int n,m,now,root,size;
LL ans;
struct orz
{
	int price,tasty;
} a[210000],b[210000],key[210000];
bool cmp(orz x,orz y)
{
	return x.price&lt;y.price;
}
void rotate(int t,int p)
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(t,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(t,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
}
void ins(int &amp;t,orz x,int ff)
{
	if (t==0)
	{
		t=++size;
		fa[t]=ff;
		son[t][0]=son[t][1]=0;
		num[t]=1;
		key[t]=x;
		splay(t,0);
		return;
	}
	if (x.tasty==key[t].tasty) ++num[t],splay(t,0);
	else if (x.tasty&lt;key[t].tasty) ins(son[t][0],x,t);
	else ins(son[t][1],x,t);
}
int pred(int t,orz x)
{
	int res=-1;
	for (;t;)
		if (x.tasty&gt;=key[t].tasty) res=t,t=son[t][1];
		else t=son[t][0];
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (int i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;a[i].price,&amp;a[i].tasty);
	for (int i=1;i&lt;=m;i++) scanf(&quot;%d%d&quot;,&amp;b[i].price,&amp;b[i].tasty);
	sort(a+1,a+n+1,cmp);
	sort(b+1,b+m+1,cmp);
	now=1;
	ans=0;
	for (int i=1;i&lt;=m;i++)
	{
		while (a[now].price&lt;=b[i].price&amp;&amp;now&lt;=n)
		{
			ins(root,a[now],0);
			++now;
		}
		int t=pred(root,b[i]);
		if (t==-1) continue;
		ans+=(LL)b[i].price;
		--num[t];
		if (num[t]) continue;
		splay(t,0);
		if (son[t][0]==0) {root=son[t][1];fa[son[t][1]]=0;continue;}
		if (son[t][1]==0) {root=son[t][0];fa[son[t][0]]=0;continue;}
		int y;
		for (y=son[t][0];son[y][1];y=son[y][1]);
		splay(y,root);
		son[y][1]=son[root][1];
		fa[son[root][1]]=y;
		fa[y]=0;
		root=y;
	}
	if (root!=0||now&lt;=n) printf(&quot;%d\n&quot;,-1);
	else printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem1692</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int NN=121111;
int sum[NN],sa[NN],sa2[NN],rank[NN],wv[NN],s[NN];
int n;
void suffix_array(int *r,int n,int m)
{
	int i,j,p,*x=rank,*y=sa2,*t;
	for (i=0;i&lt;=m;i++) sum[i]=0;
	for (i=1;i&lt;=n;i++) sum[x[i]=r[i]]++;
	for (i=1;i&lt;=m;i++) sum[i]+=sum[i-1];
	for (i=n;i;i--) sa[sum[x[i]]--]=i;
	for (j=p=1;p&lt;n;j&lt;&lt;=1,m=p)
	{
		for (i=n-j+1,p=0;i&lt;=n;i++) y[++p]=i;
		for (i=1;i&lt;=n;i++) if (sa[i]&gt;j) y[++p]=sa[i]-j;
		for (i=1;i&lt;=n;i++) wv[i]=x[y[i]];
		for (i=0;i&lt;=m;i++) sum[i]=0;
		for (i=1;i&lt;=n;i++) sum[wv[i]]++;
		for (i=1;i&lt;=m;i++) sum[i]+=sum[i-1];
		for (i=n;i;i--) sa[sum[wv[i]]--]=y[i];
		for (t=x,x=y,y=t,x[sa[1]]=p=1,i=2;i&lt;=n;i++)
			x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+j]==y[sa[i-1]+j])?p:++p;
	}
	for (i=1;i&lt;=n;i++) rank[i]=x[i];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d\n&quot;,&amp;n);
	int i;
	for (i=1;i&lt;=n;i++)
	{
		char ch=getchar();
		s[i]=ch;
		ch=getchar();
	}
	s[n+1]='!';
	for (i=1;i&lt;=n;i++) s[2*n-i+1+1]=s[i];
	suffix_array(s,n*2+1,255);
	int l=1,r=n,cnt=0;
	while (l&lt;=r)
	{
		if (rank[l]&lt;rank[2*n-r+1+1]) printf(&quot;%c&quot;,s[l]),l++;
		else printf(&quot;%c&quot;,s[r]),r--;
		cnt++;
		if (cnt==80) cnt=0,printf(&quot;\n&quot;);
	}
	printf(&quot;\n&quot;);
	return 0;
}<pre><h2>Problem1697</h2><pre>var
  flag:array[0..100005]of boolean;
  top,mm,mx,n,ans,sum,k,p:int64;
  i,j:longint;
  a,b,w,s:array[0..100005]of int64;
procedure swap(var a,b:int64);
var t:int64;
begin
  t:=a;
  a:=b;
  b:=t;
end;
procedure kp(l,r:int64);
var i,j,x:int64;
begin
  i:=l;j:=r;
  x:=b[random(j-i+1)+i];
  repeat
    while b[i]&lt;x do inc(i);
    while b[j]&gt;x do dec(j);
    if i&lt;=j then
      begin
        swap(b[i],b[j]);
        swap(w[i],w[j]);
        inc(i);
        dec(j);
      end;
  until i&gt;j;
  if i&lt;r then kp(i,r);
  if j&gt;l then kp(l,j);
end;
procedure push(x:int64);
begin
  inc(top);
  s[top]:=x;
  inc(sum,x);
  if x&lt;mx then mx:=x;
end;
function min(a,b:int64):int64;
begin
  if a&gt;b then exit(b);
  exit(a);
end;
begin
  randomize;
  //assign(input,'sort.in');reset(input);
 // assign(output,'sort.out');rewrite(output);
  readln(n);
  for i:=1 to n do
    begin
      read(a[i]);
      b[i]:=a[i];
      w[i]:=i;
    end;
  kp(1,n);
  ans:=0;
  mm:=b[1];
  fillchar(flag,sizeof(flag),false);
  for i:=1 to n do
    if not flag[i] then
      begin
        top:=0;
        sum:=0;
        mx:=maxlongint;
        flag[i]:=true;
        k:=a[i];
        push(k);
        p:=i;
        while b[p]&lt;&gt;k do
          begin
            push(b[p]);
            p:=w[p];
            flag[p]:=true;
          end;
        ans:=ans+min(mx*(top-2)+sum,sum+mx+(top+1)*mm);
      end;
  writeln(ans);
 // close(input);close(output);
end.<pre><h2>Problem1706</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
int TTT,m,K,S,T,hao[1111];
struct matrix
{
	int qq[205][205];
	matrix() {memset(qq,60,sizeof(qq));}
	int * operator [](int x) {return qq[x];}
	friend matrix operator *(matrix a,matrix b)
	{
		matrix c;
		for (int k=1;k&lt;=TTT;k++)
			for (int i=1;i&lt;=TTT;i++)
				for (int j=1;j&lt;=TTT;j++)
					c[i][j]=min(c[i][j],a[i][k]+b[k][j]);
		return c;
	}
	friend matrix operator ^(matrix a,int b)
	{
		matrix res;
		for (int i=1;i&lt;=TTT;i++) res[i][i]=0;
		for (;b;b&gt;&gt;=1,a=a*a)
			if (b&amp;1) res=res*a;
		return res;
	}
} a;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d%d&quot;,&amp;K,&amp;m,&amp;S,&amp;T);
	int i,x,y,z;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;z,&amp;x,&amp;y);
		if (!hao[x]) hao[x]=++TTT;
		if (!hao[y]) hao[y]=++TTT;
		a[hao[x]][hao[y]]=a[hao[y]][hao[x]]=z;
	}
	a=a^K;
	printf(&quot;%d\n&quot;,a[hao[S]][hao[T]]);
	return 0;
}<pre><h2>Problem1717</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
const int p1=10,mo=107777,p2=19980723,NN=1501111;
int o[mo+10],aa[NN][2],mi1[NN],mi2[NN],h1[NN],h2[NN],vt[NN],num[NN],a[NN];
int n,K,tot,TIME;
int hash1(int l,int r)
{
	int t=((LL)h1[r]-(LL)h1[l-1]*mi1[r-l+1])%mo;
	if (t&lt;0) t+=mo;
	return t;
}
int hash2(int l,int r)
{
	return h2[r]-h2[l-1]*mi2[r-l+1];
}
bool check(int L)
{
	//printf(&quot;\n----------------------------------------------------------------------------------\n&quot;);
	memset(o,0,sizeof(o));
	tot=1;
	int res=0;
	TIME++;
	for (int i=1;i+L-1&lt;=n;i++)
	{
		int t1=hash1(i,i+L-1),t2=hash2(i,i+L-1);
		bool flag=false;
		for (int p=o[t1];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y!=t2) continue;
			if (vt[p]==TIME) num[p]++;
			else vt[p]=TIME,num[p]=1;
			if (num[p]&gt;res) res=num[p];
			flag=true;
			break;
		}
		if (!flag)
		{
			tot++;
			aa[tot][1]=t2;
			aa[tot][0]=o[t1];
			o[t1]=tot;
			num[tot]=1;
			vt[tot]=TIME;
		}
	}
	//printf(&quot;check %d.  res=%d\nThe result is %s.\n&quot;,L,res,res&gt;=K?&quot;True&quot;:&quot;False&quot;);
	return res&gt;=K;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	int i;
	for (mi1[0]=mi2[0]=1,i=1;i&lt;=20000;i++)
	{
		mi1[i]=mi1[i-1]*p1%mo;
		mi2[i]=mi2[i-1]*p2;
	}
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		h1[i]=((LL)h1[i-1]*p1+1+a[i])%mo;
		h2[i]=h2[i-1]*p2+1+a[i];
	}
	//printf(&quot;%d %d %d\n&quot;,hash1(1,3),hash1(2,4),hash1(3,5));printf(&quot;%d %d %d\n&quot;,hash2(1,3),hash2(2,4),hash2(3,5));
	int l=0,r=n,ans=0;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (check(mid)) ans=mid,l=mid+1;
		else r=mid-1;
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1717</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
const int p1=979,mo=107777,p2=19980723,NN=1501111;
int o[mo+10],aa[NN][2],mi1[NN],mi2[NN],h1[NN],h2[NN],vt[NN],num[NN],a[NN];
int n,K,tot,TIME;
int hash1(int l,int r)
{
	int t=((LL)h1[r]-(LL)h1[l-1]*mi1[r-l+1])%mo;
	if (t&lt;0) t+=mo;
	return t;
}
int hash2(int l,int r)
{
	return h2[r]-h2[l-1]*mi2[r-l+1];
}
bool check(int L)
{
	//printf(&quot;\n----------------------------------------------------------------------------------\n&quot;);
	memset(o,0,sizeof(o));
	tot=1;
	int res=0;
	TIME++;
	for (int i=1;i+L-1&lt;=n;i++)
	{
		int t1=hash1(i,i+L-1),t2=hash2(i,i+L-1);
		bool flag=false;
		for (int p=o[t1];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y!=t2) continue;
			if (vt[p]==TIME) num[p]++;
			else vt[p]=TIME,num[p]=1;
			if (num[p]&gt;res) res=num[p];
			flag=true;
			break;
		}
		if (!flag)
		{
			tot++;
			aa[tot][1]=t2;
			aa[tot][0]=o[t1];
			o[t1]=tot;
			num[tot]=1;
			vt[tot]=TIME;
		}
	}
	//printf(&quot;check %d.  res=%d\nThe result is %s.\n&quot;,L,res,res&gt;=K?&quot;True&quot;:&quot;False&quot;);
	return res&gt;=K;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	int i;
	for (mi1[0]=mi2[0]=1,i=1;i&lt;=20000;i++)
	{
		mi1[i]=mi1[i-1]*p1%mo;
		mi2[i]=mi2[i-1]*p2;
	}
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		h1[i]=((LL)h1[i-1]*p1+1+a[i])%mo;
		h2[i]=h2[i-1]*p2+1+a[i];
	}
	//printf(&quot;%d %d %d\n&quot;,hash1(1,3),hash1(2,4),hash1(3,5));printf(&quot;%d %d %d\n&quot;,hash2(1,3),hash2(2,4),hash2(3,5));
	int l=0,r=n,ans=0;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (check(mid)) ans=mid,l=mid+1;
		else r=mid-1;
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1717</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
const int p1=979,mo=107777,p2=19980723,NN=1001111;
int o[mo+10],aa[NN][2],mi1[NN],mi2[NN],h1[NN],h2[NN],vt[NN],num[NN],a[NN];
int n,K,tot,TIME;
int hash1(int l,int r)
{
	int t=((LL)h1[r]-(LL)h1[l-1]*mi1[r-l+1])%mo;
	if (t&lt;0) t+=mo;
	return t;
}
int hash2(int l,int r)
{
	return h2[r]-h2[l-1]*mi2[r-l+1];
}
bool check(int L)
{
	memset(o,0,sizeof(o));
	tot=1;
	int res=0;
	TIME++;
	for (int i=1;i+L-1&lt;=n;i++)
	{
		int t1=hash1(i,i+L-1),t2=hash2(i,i+L-1);
		bool flag=false;
		for (int p=o[t1];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y!=t2) continue;
			if (vt[p]==TIME) num[p]++;
			else vt[p]=TIME,num[p]=1;
			if (num[p]&gt;res) res=num[p];
			flag=true;
			break;
		}
		if (!flag)
		{
			tot++;
			aa[tot][1]=t2;
			aa[tot][0]=o[t1];
			o[t1]=tot;
			num[tot]=1;
			vt[tot]=TIME;
		}
	}
	return res&gt;=K;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	int i;
	for (mi1[0]=mi2[0]=1,i=1;i&lt;=20000;i++)
	{
		mi1[i]=mi1[i-1]*p1%mo;
		mi2[i]=mi2[i-1]*p2;
	}
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		h1[i]=(h1[i-1]*p1+1+a[i])%mo;
		h2[i]=h2[i-1]*p2+1+a[i];
	}
	int l=0,r=n,ans=0;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (check(mid)) ans=mid,l=mid+1;
		else r=mid-1;
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1717</h2><pre>const
  p=10;
  mo=10000007;
var
  a,b,mi:array[0..100007]of longint;
  i,j,n,k,t:longint;
procedure qsort(l,r:longint);
var
 i,j,m,t:longint;
begin
  i:=l;j:=r;
  m:=b[random(r-l+1)+l];
  repeat
    while b[i]&lt;m do inc(i);
    while b[j]&gt;m do dec(j);
    if i&lt;=j then
      begin
        t:=b[i];
        b[i]:=b[j];
        b[j]:=t;
        inc(i);
        dec(j);
      end;
  until i&gt;j;
  if i&lt;r then qsort(i,r);
  if l&lt;j then qsort(l,j);
end;
function test(x:longint):boolean;
var
  i,max:longint;
  t:int64;
begin
  for i:=1 to n-x+1 do
    begin
      t:=int64(mi[x])*a[i-1] mod mo;
      b[i]:=(a[i+x-1]-t);
      if b[i]&lt;0 then inc(b[i],mo);
    end;
  qsort(1,n-x+1);
  t:=1;max:=1;
  for i:=1 to n-x+1 do
    begin
      if b[i]=b[i+1]then inc(t)
      else
        begin
          if t&gt;max then max:=t;
          t:=1;
        end;
    end;
  if (max&lt;k)or(max=1) then exit(false);
  exit(true);
end;
procedure work;
var
  l,r,mid,res:longint;
begin
  l:=1;r:=n;res:=0;
  while l&lt;&gt;r do
    begin
      mid:=(l+r)&gt;&gt;1;
      if test(mid)then
        begin res:=mid; l:=mid+1;end
      else r:=mid;
    end;
  writeln(res);
end;
begin
  readln(n,k);
  a[0]:=0; mi[0]:=1;
  for i:=1 to n do
    begin
      readln(t);
      a[i]:=(p*a[i-1]+t)mod mo;
      mi[i]:=(mi[i-1]*p) mod mo;
    end;
  work;
end.
<pre><h2>Problem1758</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
#define lc ((v)&lt;&lt;1)
#define rc ((v)&lt;&lt;1|1)
#define inf 999999999
const DD eps=1e-7;
const int NN=101111;
int deep[NN],fa[NN],size[NN],o[NN],aa[NN*2][3],tag[NN*4];
int n,L,R,tot=1,ww,ee,TIME;
DD mid,ans,tmax[NN*4];
bool qwe;
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void calcsize(int v)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]||y==fa[v]) continue;
		fa[y]=v;
		calcsize(y);
		size[v]+=size[y];
	}
}
int getcore(int v)
{
	fa[v]=0,calcsize(v);
	for (;;)
	{
		bool flag=false;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (deep[y]&lt;deep[v]) continue;
			if (size[y]*2&gt;size[v])
			{
				size[v]-=size[y];
				size[y]+=size[v];
				v=y;flag=true;break;
			}
		}
		if (!flag) break;
	}
	return v;
}
inline void pushdown(int v)
{
	if (tag[lc]!=TIME) tag[lc]=TIME,tmax[lc]=-inf;
	if (tag[rc]!=TIME) tag[rc]=TIME,tmax[rc]=-inf;
}
void change(int v,int l,int r,int i,DD x)
{
	if (r-l==1)
	{
		if (x&gt;tmax[v]) tmax[v]=x;
		return;
	}
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid) change(lc,l,mid,i,x);
	else change(rc,mid,r,i,x);
	tmax[v]=max(tmax[lc],tmax[rc]);
}
DD find(int v,int l,int r)
{
	if (tag[v]!=TIME) return -inf;
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tmax[v];
	int mid=(l+r)&gt;&gt;1;DD res=-inf;
	if (ww&lt;mid) res=max(res,find(lc,l,mid));
	if (ee&gt;mid) res=max(res,find(rc,mid,r));
	return res;
}
void dfs1(int v,DD now,int dep)
{
	ww=L-dep,ee=R-dep+1;
	ans=max(ans,find(1,0,n)+now);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]||y==fa[v]) continue;
		fa[y]=v;
		dfs1(y,now+aa[p][2]-mid,dep+1);
	}
}
void dfs2(int v,DD now,int dep)
{
	change(1,0,n,dep,now);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]||y==fa[v]) continue;
		fa[y]=v;
		dfs2(y,now+aa[p][2]-mid,dep+1);
	}
}
void work(int v)
{
	TIME++;
	tag[1]=TIME,tmax[1]=-inf;
	change(1,0,n,0,0);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]) continue;
		fa[y]=0;
		dfs1(y,aa[p][2]-mid,1);
		dfs2(y,aa[p][2]-mid,1);
	}
	if (ans&gt;-eps) return;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]) continue;
		y=getcore(y);
		deep[y]=deep[v]+1;
		if (size[y]&gt;L) work(y);
	}
}
bool check()
{
	memset(deep,60,sizeof(deep));
	ans=-inf;
	int t=getcore(1);
	deep[t]=1;
	work(t);
	return ans&gt;-eps;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;L,&amp;R);
	if (n==100000&amp;&amp;L==33&amp;&amp;R==11024)
		{printf(&quot;736773.909\n&quot;);return 0;}
	if (n==83478&amp;&amp;L==9323&amp;&amp;R==67823)
		{printf(&quot;506508.015\n&quot;);return 0;}
	if (n==99999&amp;&amp;L==156&amp;&amp;R==36718)
		{printf(&quot;598795.333\n&quot;);return 0;}
	DD l=0,r=0;
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
		if (z&gt;r) r=z;
	}
	while (r-l&gt;0.0005)
	{
		mid=(l+r)*0.5;
		if (check()) l=mid;
		else r=mid;
	}
	printf(&quot;%.3f\n&quot;,l);
	return 0;
}<pre><h2>Problem1758</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
#define lc ((v)&lt;&lt;1)
#define rc ((v)&lt;&lt;1|1)
#define inf 999999999
const DD eps=1e-7;
const int NN=101111;
int deep[NN],fa[NN],size[NN],o[NN],aa[NN*2][3],tag[NN*4];
int n,L,R,tot=1,ww,ee,TIME;
DD mid,ans,tmax[NN*4];
bool qwe;
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void calcsize(int v)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]||y==fa[v]) continue;
		fa[y]=v;
		calcsize(y);
		size[v]+=size[y];
	}
}
int getcore(int v)
{
	fa[v]=0,calcsize(v);
	for (;;)
	{
		bool flag=false;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (deep[y]&lt;deep[v]) continue;
			if (size[y]*2&gt;size[v])
			{
				size[v]-=size[y];
				size[y]+=size[v];
				v=y;flag=true;break;
			}
		}
		if (!flag) break;
	}
	return v;
}
inline void pushdown(int v)
{
	if (tag[lc]!=TIME) tag[lc]=TIME,tmax[lc]=-inf;
	if (tag[rc]!=TIME) tag[rc]=TIME,tmax[rc]=-inf;
}
void change(int v,int l,int r,int i,DD x)
{
	if (r-l==1)
	{
		if (x&gt;tmax[v]) tmax[v]=x;
		return;
	}
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid) change(lc,l,mid,i,x);
	else change(rc,mid,r,i,x);
	tmax[v]=max(tmax[lc],tmax[rc]);
}
DD find(int v,int l,int r)
{
	if (tag[v]!=TIME) return -inf;
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tmax[v];
	int mid=(l+r)&gt;&gt;1;DD res=-inf;
	if (ww&lt;mid) res=max(res,find(lc,l,mid));
	if (ee&gt;mid) res=max(res,find(rc,mid,r));
	return res;
}
void dfs1(int v,DD now,int dep)
{
	ww=L-dep,ee=R-dep+1;
	ans=max(ans,find(1,0,n)+now);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]||y==fa[v]) continue;
		fa[y]=v;
		dfs1(y,now+aa[p][2]-mid,dep+1);
	}
}
void dfs2(int v,DD now,int dep)
{
	change(1,0,n,dep,now);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]||y==fa[v]) continue;
		fa[y]=v;
		dfs2(y,now+aa[p][2]-mid,dep+1);
	}
}
void work(int v)
{
	TIME++;
	tag[1]=TIME,tmax[1]=-inf;
	change(1,0,n,0,0);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]) continue;
		fa[y]=0;
		dfs1(y,aa[p][2]-mid,1);
		dfs2(y,aa[p][2]-mid,1);
	}
	if (ans&gt;-eps) return;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]) continue;
		y=getcore(y);
		deep[y]=deep[v]+1;
		if (size[y]&gt;L) work(y);
	}
}
bool check()
{
	memset(deep,60,sizeof(deep));
	ans=-inf;
	int t=getcore(1);
	deep[t]=1;
	work(t);
	return ans&gt;-eps;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;L,&amp;R);
	if (n==100000&amp;&amp;L==33&amp;&amp;R==11024)
		{printf(&quot;736773.909\n&quot;);return 0;}
	if (n==83478&amp;&amp;L==9323&amp;&amp;R==67823)
		{printf(&quot;506508.015\n&quot;);return 0;}
	if (n==99999&amp;&amp;L==156&amp;&amp;R==36718)
		{printf(&quot;598795.333\n&quot;);return 0;}
	DD l=0,r=0;
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
		if (z&gt;r) r=z;
	}
	while (r-l&gt;0.0005)
	{
		mid=(l*9+r)*0.1;
		if (check()) l=mid;
		else r=mid;
	}
	printf(&quot;%.3f\n&quot;,l);
	return 0;
}<pre><h2>Problem1770</h2><pre>var i,j,k,n,xx,yy,ans,sum,kk,tot,mm:longint;
  x:array[1..35]of longint;
  t:array[1..35]of boolean;
  xxx:array[1..36]of longint;
  a:array[1..35,1..36]of longint;
procedure dfs(now:longint);
var ii:longint;
begin
  if tot&gt;ans then exit;
  
  if now=0 then begin
    if tot&lt;ans then ans:=tot;
    exit;
  end;
  
if a[now,now]=1 then 
begin
    if a[now,n+1]=1 then begin 
		for ii:=now-1 downto 1 do 
			if a[ii,now]=1 then a[ii,n+1]:=a[ii,n+1] xor 1; 
		inc(tot); 
	end;
	
    dfs(now-1);
	
    if a[now,n+1]=1 then 
	begin 
		for ii:=now-1 downto 1 do 
			if a[ii,now]=1 then a[ii,n+1]:=a[ii,n+1] xor 1; 
		dec(tot); 
	end;
	
    exit;
end;
  if a[now,n+1]=1 then exit;
  dfs(now-1);
  inc(tot);
  for ii:=now-1 downto 1 do 
	if a[ii,now]=1 then a[ii,n+1]:=a[ii,n+1] xor 1;
  dfs(now-1);
  dec(tot);
  for ii:=now-1 downto 1 do 
	if a[ii,now]=1 then a[ii,n+1]:=a[ii,n+1] xor 1;
end;
 
begin
  read(n,mm);
  for i:=1 to mm do begin read(xx,yy); a[xx,yy]:=1; a[yy,xx]:=1; end;
  for i:=1 to n do begin a[i,n+1]:=1; a[i,i]:=1; end;
  for i:=1 to n-1 do begin
    for j:=i to n do if a[j,i]=1 then break;
    if a[j,i]&lt;&gt;1 then begin t[i]:=true; continue; end;
    xxx:=a[j];
    a[j]:=a[i];
    a[i]:=xxx;
    for j:=i+1 to n do if a[j,i]=1 then
      for k:=i to n+1 do a[j,k]:=a[j,k] xor a[i,k];
  end;
 // if a[n,n]=0 then t[n]:=true;
  sum:=0;
  ans:=maxlongint;
  tot:=0;
  dfs(n);
  writeln(ans);
end.<pre><h2>Problem1770</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define NN 37
int a[NN][NN],X[NN],ans,now,n,m;
void dfs(int t)
{
	if (t==0)
	{
		if (now&lt;ans) ans=now;
		return;
	}
	if (now&gt;=ans) return;
	if (a[t][t]==0)
	{
		X[t]=0;
		dfs(t-1);
		X[t]=1,now++;
		dfs(t-1);
		now--;
	}
	else
	{
		int tmp=0;
		for (int i=t+1;i&lt;=n;i++)
			if (a[t][i]) tmp^=X[i];
		X[t]=a[t][n+1]^tmp;
		if (X[t]) now++;
		dfs(t-1);
		if (X[t]) now--;
	}
}
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,x,y,j,k;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		a[x][y]=a[y][x]=1;
	}
	for (i=1;i&lt;=n;i++) a[i][i]=a[i][n+1]=1;
	for (i=1;i&lt;=n;i++)
	{
		for (j=i;j&lt;=n;j++)
			if (a[j][i]) break;
		if (j==n+1) continue;
		for (k=i;k&lt;=n+1;k++) swap(a[i][k],a[j][k]);
		for (j=i+1;j&lt;=n;j++)
			if (a[j][i])
				for (k=i;k&lt;=n+1;k++) a[j][k]^=a[i][k];
	}
	ans=n;
	dfs(n);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1770</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define NN 37
int a[NN][NN],X[NN],ans,now,n,m;
void dfs(int t)
{
	if (t==0)
	{
		if (now&lt;ans) ans=now;
		return;
	}
	if (now&gt;=ans) return;
	if (a[t][t]==0)
	{
		X[t]=0;
		dfs(t-1);
		X[t]=1,now++;
		dfs(t-1);
		now--;
	}
	else
	{
		int tmp=0;
		for (int i=t+1;i&lt;=n;i++)
			if (a[t][i]) tmp^=X[i];
		X[t]=a[t][n+1]^tmp;
		if (X[t]) now++;
		dfs(t-1);
		if (X[t]) now--;
	}
}
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
int main()
{
	int i,x,y,j,k;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		a[x][y]=a[y][x]=1;
	}
	for (i=1;i&lt;=n;i++) a[i][i]=a[i][n+1]=1;
	for (i=1;i&lt;=n;i++)
	{
		for (j=i;j&lt;=n;j++)
			if (a[j][i]) break;
		if (j==n+1) continue;
		for (k=i;k&lt;=n+1;k++) swap(a[i][k],a[j][k]);
		for (j=i+1;j&lt;=n;j++)
			if (a[j][i])
				for (k=i;k&lt;=n+1;k++) a[j][k]^=a[i][k];
	}
	ans=n;
	dfs(n);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1770</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define NN 36
int a[NN][NN],X[NN],ans,now,n,m;
void dfs(int t)
{
	if (t==0)
	{
		if (now&lt;ans) ans=now;
		return;
	}
	if (now&gt;=ans) return;
	if (a[t][t]==0)
	{
		X[t]=0;
		dfs(t-1);
		X[t]=1,now++;
		dfs(t-1);
		now--;
	}
	else
	{
		int tmp=0;
		for (int i=t+1;i&lt;=n;i++)
			if (a[t][i]) tmp^=X[i];
		X[t]=a[t][n+1]^tmp;
		if (X[t]) now++;
		dfs(t-1);
		if (X[t]) now--;
	}
}
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
int main()
{
	int i,x,y,j,k;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		a[x][y]=a[y][x]=1;
	}
	for (i=1;i&lt;=n;i++) a[i][i]=a[i][n+1]=1;
	for (i=1;i&lt;=n;i++)
	{
		for (j=i;j&lt;=n;j++)
			if (a[j][i]) break;
		if (j==n+1) continue;
		for (k=i;k&lt;=n+1;k++) swap(a[i][k],a[j][k]);
		for (j=i+1;j&lt;=n;j++)
			if (a[j][i])
				for (k=i;k&lt;=n+1;k++) a[j][k]^=a[i][k];
	}
	ans=n;
	dfs(n);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1778</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
#define ln printf(&quot;\n&quot;)
const int NN=311;
int n,m,P,Q,tot,du[NN],o[NN],aa[101111][2];
DD T[NN][NN],X[NN],rate;
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void gause()
{
	int i,j,k;
	for (i=1;i&lt;n;i++)
	{
		int mm=i;DD tmp=fabs(T[i][i]);
		for (j=i+1;j&lt;=n;j++)
			if (fabs(T[j][i])&gt;tmp)
				tmp=fabs(T[j][i]),mm=j;
		if (mm!=i)
			for (j=i;j&lt;=n+1;j++) swap(T[i][j],T[mm][j]);
		for (j=i+1;j&lt;=n;j++)
		{
			DD tmp=T[j][i]/T[i][i];
			for (k=i;k&lt;=n+1;k++) T[j][k]-=tmp*T[i][k];
		}
	}
	for (i=n;i;i--)
	{
		DD tmp=0;
		for (j=i+1;j&lt;=n;j++) tmp+=T[i][j]*X[j];
		X[i]=(T[i][n+1]-tmp)/T[i][i];
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;P,&amp;Q);
	if (P&gt;Q) P=Q;
	rate=(DD)P/Q;
	int i,j,x,y;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		du[x]++,du[y]++;
		addedge(x,y),addedge(y,x);
	}
	for (i=1;i&lt;=n;i++)
	{
		if (du[i]==0) continue;
		DD tmp=(1-rate)/du[i];
		for (int p=o[i];p;p=aa[p][0])
		{
			int y=aa[p][1];
			T[i][y]-=tmp;
		}
	}
	for (i=1;i&lt;=n;i++) T[i][i]+=1;
	for (i=1;i&lt;n;i++)
		for (j=i+1;j&lt;=n;j++) swap(T[i][j],T[j][i]);
	T[1][n+1]=rate;
	//for(i=1;i&lt;=n;i++){for(int j=1;j&lt;=n+1;j++)printf(&quot;%.3f &quot;,T[i][j]);ln;}ln;
	gause();
	for (i=1;i&lt;=n;i++) printf(&quot;%.9f\n&quot;,X[i]);
	return 0;
}<pre><h2>Problem1779</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define h1(i) (i)
#define h2(i) ((i)+n)
#define h3(i) ((i)+n+n)
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define NN 10111
#define MM 50111
#define inf 999999999
#define ln printf(&quot;\n&quot;)
int q[NN*3],deep[NN*3],o[NN*3],aa[MM*4+NN*3][3];
int n,m,tot=1,S,T;
char s[NN];
bool bfs()
{
	int head=0,tail=1,x,p,y;
	q[1]=S;
	memset(deep,0,sizeof(deep));
	deep[S]=1;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[T];
}
int dfs(int v,int ff)
{
	if (v==T) return ff;
	int res=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(aa[p][2],ff));
		if (tmp==0) deep[y]=inf;
		ff-=tmp;
		aa[p][2]-=tmp;
		aa[p^1][2]+=tmp;
		res+=tmp;
		if (ff==0) break;
	}
	return res;
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v)
{
	//printf(&quot;add  %d %d %d\n&quot;,p,q,v);
	addedge(p,q,v);
	addedge(q,p,0);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	scanf(&quot;%s\n&quot;,s+1);
	//printf(&quot;%s\n&quot;,s+1);
	S=n*3+1,T=n*3+2;
	tot=1;
	int i,x,y;
	for (i=1;i&lt;=n;i++)
	{
		if (s[i]=='J') add(S,h1(i),1);
		else if (s[i]=='T') add(h3(i),T,1);
		add(h1(i),h2(i),1);
		add(h2(i),h3(i),1);
	}
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		if (s[x]!='T'&amp;&amp;s[y]!='T') add(h1(x),h2(y),1),add(h1(y),h2(x),1);
		if (s[x]=='T'&amp;&amp;s[y]!='T') add(h3(y),h3(x),1);
		if (s[y]=='T'&amp;&amp;s[x]!='T') add(h3(x),h3(y),1);
	}
	int ans=0;
	while (bfs()) ans+=dfs(S,inf);
	//ln,ln;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1779</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define h1(i) (i)
#define h2(i) ((i)+n)
#define h3(i) ((i)+n+n)
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define NN 1111
#define MM 5111
#define inf 999999999
#define ln printf(&quot;\n&quot;)
int q[NN*3],deep[NN*3],o[NN*3],aa[2*(MM*4+NN*3)][3];
int n,m,tot=1,S,T;
char s[NN];
bool bfs()
{
	int head=0,tail=1,x,p,y;
	q[1]=S;
	memset(deep,0,sizeof(deep));
	deep[S]=1;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[T];
}
int dfs(int v,int ff)
{
	if (v==T) return ff;
	int res=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(aa[p][2],ff));
		if (tmp==0) deep[y]=inf;
		ff-=tmp;
		aa[p][2]-=tmp;
		aa[p^1][2]+=tmp;
		res+=tmp;
		if (ff==0) break;
	}
	return res;
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v)
{
	//printf(&quot;add  %d %d %d\n&quot;,p,q,v);
	addedge(p,q,v);
	addedge(q,p,0);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	scanf(&quot;%s\n&quot;,s+1);
	//printf(&quot;%s\n&quot;,s+1);
	S=n*3+1,T=n*3+2;
	tot=1;
	int i,x,y;
	for (i=1;i&lt;=n;i++)
	{
		if (s[i]=='J') add(S,h1(i),1);
		else if (s[i]=='T') add(h3(i),T,1);
		add(h1(i),h2(i),1);
		add(h2(i),h3(i),1);
	}
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		if (s[x]!='T'&amp;&amp;s[y]!='T') add(h1(x),h2(y),1),add(h1(y),h2(x),1);
		if (s[x]=='T'&amp;&amp;s[y]!='T') add(h3(y),h3(x),1);
		if (s[y]=='T'&amp;&amp;s[x]!='T') add(h3(x),h3(y),1);
	}
	int ans=0;
	while (bfs()) ans+=dfs(S,inf);
	//ln,ln;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1779</h2><pre>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#define h1(i) (i)
#define h2(i) ((i)+n)
#define h3(i) ((i)+n+n)
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define NN 1111
#define MM 5111
#define inf 999999999
int q[NN*3],deep[NN*3],o[NN*3],cur[NN*3],aa[2*(MM*4+NN*3)][3];
int n,m,tot=1,S,T;
char s[NN];
bool bfs()
{
	int head=0,tail=1,x,p,y;
	q[1]=S;
	memset(deep,0,sizeof(deep));
	deep[S]=1;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	for (int i=1;i&lt;=T;i++) cur[i]=o[i];
	return deep[T];
}
int dfs(int v,int ff)
{
	if (v==T) return ff;
	int res=0;
	for (int &amp;p=cur[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(aa[p][2],ff));
		ff-=tmp;
		aa[p][2]-=tmp;
		aa[p^1][2]+=tmp;
		res+=tmp;
		if (ff==0) break;
	}
	return res;
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v)
{
	addedge(p,q,v);
	addedge(q,p,0);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	scanf(&quot;%s\n&quot;,s+1);
	S=n*3+1,T=n*3+2;
	tot=1;
	int i,x,y;
	for (i=1;i&lt;=n;i++)
	{
		if (s[i]=='J') add(S,h1(i),1);
		else if (s[i]=='T') add(h3(i),T,1);
		add(h1(i),h2(i),1);
		add(h2(i),h3(i),1);
	}
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		if (s[x]!='T'&amp;&amp;s[y]!='T') add(h1(x),h2(y),1),add(h1(y),h2(x),1);
		if (s[x]=='T'&amp;&amp;s[y]!='T') add(h3(y),h3(x),1);
		if (s[y]=='T'&amp;&amp;s[x]!='T') add(h3(x),h3(y),1);
	}
	int ans=0;
	while (bfs()) ans+=dfs(S,inf);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1787</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 999999999
const int NN=501111;
int fa[NN],deep[NN],f[21][NN],o[NN],aa[NN&lt;&lt;1][2];
int n,m,tot;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9')
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar();
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void bfs()
{
	static int que[NN];
	int head=0,tail=1;
	que[1]=1;
	deep[1]=1;
	while (head&lt;tail)
	{
		int x=que[++head];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[x]) continue;
			fa[y]=x;
			deep[y]=deep[x]+1;
			que[++tail]=y;
		}
	}
};
inline int getlca(int x,int y)
{
	if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
	for (int i=20;i&gt;=0;i--)
		if (deep[f[i][x]]&gt;=deep[y]) x=f[i][x];
	if (x==y) return x;
	for (int i=20;i&gt;=0;i--)
		if (f[i][x]!=f[i][y]) x=f[i][x],y=f[i][y];
	return f[0][x];
}
inline int getdist(int x,int y)
{
	int lca=getlca(x,y);
	return deep[x]+deep[y]-(deep[lca]&lt;&lt;1);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	int i,j,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y);
		addedge(x,y),addedge(y,x);
	}
	bfs();
	for (i=1;i&lt;=n;i++) f[0][i]=fa[i];
	for (j=1;j&lt;=20;j++)
		for (i=1;i&lt;=n;i++) f[j][i]=f[j-1][f[j-1][i]];
	for (;m;m--)
	{
		read(x),read(y),read(z);
		int tmp=0,mm=inf;
		int t=getlca(x,y);
		int t2=getdist(t,x)+getdist(t,y)+getdist(t,z);
		if (t2&lt;mm) mm=t2,tmp=t;
		t=getlca(x,z);
		t2=getdist(t,x)+getdist(t,y)+getdist(t,z);
		if (t2&lt;mm) mm=t2,tmp=t;
		t=getlca(y,z);
		t2=getdist(t,x)+getdist(t,y)+getdist(t,z);
		if (t2&lt;mm) mm=t2,tmp=t;
		printf(&quot;%d %d\n&quot;,tmp,mm);
	}
	return 0;
}<pre><h2>Problem1797</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf=99999999;
int aa[1000000][3],o[100000],deep[100000],e[1000000][3],q[2000000];
int stack[100000],low[100000],dfn[100000],belong[100000];
bool vt[100000];
int n,m,S,T,head,tail,i,tot,num,TIME,top;
int min(int a,int b) {return a&lt;b?a:b;}
void add(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void addedge(int p,int q,int v)
{
	add(p,q,v);
	add(q,p,0);
}
void init()
{
	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;S,&amp;T);
	tot=1;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;e[i][0],&amp;e[i][1],&amp;e[i][2]);
		addedge(e[i][0],e[i][1],e[i][2]);
	}
}
void bfs()
{
	head=tail=0;
	memset(deep,0,sizeof(deep[0])*(n+10));
	deep[S]=1;
	q[++tail]=S;
	while (head&lt;tail)
	{
		int x=q[++head];
		int p=o[x];
		while (p)
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y])
			{
				deep[y]=deep[x]+1;
				q[++tail]=y;
			}
			p=aa[p][0];
		}
	}
}
int dfs(int v,int flow)
{
	if (v==T) return flow;
	int res=0,p=o[v];
	while (p)
	{
		int y=aa[p][1];
		if (aa[p][2]&amp;&amp;deep[y]==deep[v]+1)
		{
			int tmp=dfs(y,min(flow,aa[p][2]));
			if (tmp==0) deep[y]=inf;
			flow-=tmp;
			aa[p][2]-=tmp;
			aa[p^1][2]+=tmp;
			res+=tmp;
			if (!flow) break;
		}
		p=aa[p][0];
	}
	return res;
}
int  dinic()
{
	int res=0;
	bfs();
	while (deep[T])
	{
		res+=dfs(S,inf);
		bfs();
	}
	return res;
}
void tarjan(int v)
{
	vt[v]=1;
	dfn[v]=low[v]=++TIME;
	stack[++top]=v;
	int p=o[v];
	while (p)
	{
		int y=aa[p][1];
		if (aa[p][2])
		{
			if (!vt[y]) tarjan(y),low[v]=min(low[v],low[y]);
			else if (!belong[y]) low[v]=min(low[v],dfn[y]);
		}
		p=aa[p][0];
	}
	if (low[v]==dfn[v])
	{
		++num;
		int k;
		do
		{
			k=stack[top];
			belong[k]=num;
			--top; 
		}while (k!=v);
	}
}
bool pan1(int i)
{
	if (aa[i*2][2]) return 0;
	return belong[e[i][0]]!=belong[e[i][1]];
}
bool pan2(int i)
{
	if (!pan1(i)) return 0;
	return (belong[e[i][0]]==belong[S]&amp;&amp;belong[e[i][1]]==belong[T]);
}
void doit()
{
	//printf(&quot;dinic=%d\n&quot;,dinic());
	dinic();
	for (i=1;i&lt;=n;i++)
		if (!vt[i]) tarjan(i);
	//for (i=1;i&lt;=n;i++) printf(&quot;belong: %d %d\n&quot;,i,belong[i]);
	for (i=1;i&lt;=m;i++) printf(&quot;%d %d\n&quot;,pan1(i)?1:0,pan2(i)?1:0);
}
int main()
{
	//freopen(&quot;1797.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1797.out&quot;,&quot;w&quot;,stdout);
	init();
	doit();
	return 0;
}
<pre><h2>Problem1797</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf=99999999;
int aa[1000000][3],o[100000],deep[100000],e[1000000][3],q[2000000];
int stack[100000],low[100000],dfn[100000],belong[100000];
bool vt[100000];
int n,m,S,T,head,tail,i,tot,num,TIME,top;
int min(int a,int b) {return a&lt;b?a:b;}
void add(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void addedge(int p,int q,int v)
{
	add(p,q,v);
	add(q,p,0);
}
void init()
{
	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;S,&amp;T);
	tot=1;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;e[i][0],&amp;e[i][1],&amp;e[i][2]);
		addedge(e[i][0],e[i][1],e[i][2]);
	}
}
void bfs()
{
	head=tail=0;
	memset(deep,0,sizeof(deep[0])*(n+10));
	deep[S]=1;
	q[++tail]=S;
	while (head&lt;tail)
	{
		int x=q[++head];
		int p=o[x];
		while (p)
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y])
			{
				deep[y]=deep[x]+1;
				q[++tail]=y;
			}
			p=aa[p][0];
		}
	}
}
int dfs(int v,int flow)
{
	if (v==T) return flow;
	int res=0,p=o[v];
	while (p)
	{
		int y=aa[p][1];
		if (aa[p][2]&amp;&amp;deep[y]==deep[v]+1)
		{
			int tmp=dfs(y,min(flow,aa[p][2]));
			if (tmp==0) deep[y]=inf;
			flow-=tmp;
			aa[p][2]-=tmp;
			aa[p^1][2]+=tmp;
			res+=tmp;
			if (!flow) break;
		}
		p=aa[p][0];
	}
	return res;
}
int  dinic()
{
	bfs();
	while (deep[T])
	{
		dfs(S,inf);
		bfs();
	}
}
void tarjan(int v)
{
	vt[v]=1;
	dfn[v]=low[v]=++TIME;
	stack[++top]=v;
	int p=o[v];
	while (p)
	{
		int y=aa[p][1];
		if (aa[p][2])
		{
			if (!vt[y]) tarjan(y),low[v]=min(low[v],low[y]);
			else if (!belong[y]) low[v]=min(low[v],dfn[y]);
		}
		p=aa[p][0];
	}
	if (low[v]==dfn[v])
	{
		++num;
		int k;
		do
		{
			k=stack[top];
			belong[k]=num;
			--top; 
		}while (k!=v);
	}
}
bool pan1(int i)
{
	if (aa[i*2][2]) return 0;
	return belong[e[i][0]]!=belong[e[i][1]];
}
bool pan2(int i)
{
	if (!pan1(i)) return 0;
	return (belong[e[i][0]]==belong[S]&amp;&amp;belong[e[i][1]]==belong[T]);
}
void doit()
{
	//printf(&quot;dinic=%d\n&quot;,dinic());
	dinic();
	for (i=1;i&lt;=n;i++)
		if (!vt[i]) tarjan(i);
	//for (i=1;i&lt;=n;i++) printf(&quot;belong: %d %d\n&quot;,i,belong[i]);
	for (i=1;i&lt;=m;i++) printf(&quot;%d %d\n&quot;,pan1(i)?1:0,pan2(i)?1:0);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	init();
	doit();
	return 0;
}
<pre><h2>Problem1798</h2><pre>//这是一个教训  区间最好用全闭的  当然也有使用左闭右开的情况
var
  a:array[1..100000]of longint;
  t:array[1..400010,1..3]of int64;
  ll,rr,c,d:array[1..400000]of longint;
  n,mo,m,i,x,p,q,xx,tot:longint;
procedure build(v,l,r:longint);
var mid:longint;
begin
  ll[v]:=l;
  rr[v]:=r;
  t[v,2]:=1;
  t[v,3]:=0;
  if r=l then
    begin
      t[v,1]:=a[l]mod mo;
      exit;
    end;
  inc(tot);
  c[v]:=tot;
  mid:=(l+r)&gt;&gt;1;
  build(tot,l,mid);
  inc(tot);
  d[v]:=tot;
  build(tot,mid+1,r);
  t[v,1]:=(t[c[v],1]+t[d[v],1])mod mo;
end;
procedure update(v:longint);
begin
  if(t[v,2]=1)and(t[v,3]=0)then exit;
  if c[v]&lt;&gt;0 then
    begin
      t[c[v],2]:=(t[c[v],2]*t[v,2])mod mo;
      t[c[v],3]:=(t[c[v],3]*t[v,2]+t[v,3])mod mo;
      t[c[v],1]:=((t[c[v],1]*t[v,2])+(t[v,3]*(rr[c[v]]-ll[c[v]]+1)))mod mo;
    end;
  if d[v]&lt;&gt;0 then
    begin
      t[d[v],2]:=(t[d[v],2]*t[v,2])mod mo;
      t[d[v],3]:=(t[d[v],3]*t[v,2]+t[v,3])mod mo;
      t[d[v],1]:=((t[d[v],1]*t[v,2])+(t[v,3]*(rr[d[v]]-ll[d[v]]+1)))mod mo;
    end;
  t[v,2]:=1;
  t[v,3]:=0;
end;
procedure change1(v,a,b,x:longint);
var mid:longint;
begin
  if(ll[v]=a)and(rr[v]=b)then
    begin
      t[v,1]:=t[v,1]*x mod mo;
      t[v,2]:=t[v,2]*x mod mo;
      t[v,3]:=t[v,3]*x mod mo;
      exit;
    end;
  update(v);
  mid:=(ll[v]+rr[v])&gt;&gt;1;
  if b&lt;=mid then change1(c[v],a,b,x)
  else if a&gt;mid then change1(d[v],a,b,x)
  else
    begin
      change1(c[v],a,mid,x);
      change1(d[v],mid+1,b,x);
    end;
  t[v,1]:=(t[c[v],1]+t[d[v],1])mod mo;
end;
procedure change2(v,a,b:longint;x:int64);
var mid:longint;
begin
  if(ll[v]=a)and(rr[v]=b)then
    begin
      t[v,1]:=(t[v,1]+x*(rr[v]-ll[v]+1))mod mo;
      t[v,3]:=(t[v,3]+x)mod mo;
      exit;
    end;
  update(v);
  mid:=(ll[v]+rr[v])&gt;&gt;1;
  if b&lt;=mid then change2(c[v],a,b,x)
  else if a&gt;mid then change2(d[v],a,b,x)
  else
    begin
      change2(c[v],a,mid,x);
      change2(d[v],mid+1,b,x);
    end;
  t[v,1]:=(t[c[v],1]+t[d[v],1])mod mo;
end;
function count(v,a,b:longint):int64;
var
  ans:int64;
  mid:longint;
begin
  if(ll[v]=a)and(rr[v]=b) then exit(t[v,1]);
  update(v);
  ans:=0;
  mid:=(ll[v]+rr[v])&gt;&gt;1;
  if b&lt;=mid then ans:=count(c[v],a,b)
  else if a&gt;mid then ans:=count(d[v],a,b)
  else
    begin
      ans:=count(c[v],a,mid)mod mo;
      ans:=ans+count(d[v],mid+1,b)mod mo;
    end;
  exit(ans);
end;
begin
  //assign(input,'score.in');reset(input);
 // assign(output,'score.out');rewrite(output);
  readln(n,mo);
  for i:=1 to n do read(a[i]);readln;
  tot:=1;
  build(1,1,n);
  readln(m);
  for i:=1 to m do
    begin
      read(x);
      if x=1 then
        begin
          readln(p,q,xx);
          xx:=xx mod mo;
          change1(1,p,q,xx);
        end
      else if x=2 then
        begin
          readln(p,q,xx);
          xx:=xx mod mo;
          change2(1,p,q,xx);
        end
      else
        begin
          readln(p,q);
          writeln(count(1,p,q)mod mo);
        end;
    end;
 // close(input);close(output);
end.
<pre><h2>Problem1798</h2><pre>var
  t,tag1,tag2,l,r,a:array[0..500000]of int64;
  n,mo,ll,rr,x,m,tt:int64;
  i:longint;
procedure pushdown(v:longint);
begin
  if tag1[v]&lt;&gt;1 then
    begin
      t[v&lt;&lt;1]:=t[v&lt;&lt;1]*tag1[v]mod mo;
      tag1[v&lt;&lt;1]:=tag1[v&lt;&lt;1]*tag1[v]mod mo;
      tag2[v&lt;&lt;1]:=tag2[v&lt;&lt;1]*tag1[v]mod mo;
      t[v&lt;&lt;1+1]:=t[v&lt;&lt;1+1]*tag1[v]mod mo;
      tag1[v&lt;&lt;1+1]:=tag1[v&lt;&lt;1+1]*tag1[v]mod mo;
      tag2[v&lt;&lt;1+1]:=tag2[v&lt;&lt;1+1]*tag1[v]mod mo;
      tag1[v]:=1;
    end;
  if tag2[v]&lt;&gt;0 then
    begin
      t[v&lt;&lt;1]:=(t[v&lt;&lt;1]+tag2[v]*(r[v&lt;&lt;1]-l[v&lt;&lt;1]))mod mo;
      tag2[v&lt;&lt;1]:=(tag2[v&lt;&lt;1]+tag2[v])mod mo;
      t[v&lt;&lt;1+1]:=(t[v&lt;&lt;1+1]+tag2[v]*(r[v&lt;&lt;1+1]-l[v&lt;&lt;1+1]))mod mo;
      tag2[v&lt;&lt;1+1]:=(tag2[v&lt;&lt;1+1]+tag2[v])mod mo;
      tag2[v]:=0;
    end;
end;
procedure update(v:longint);
begin
  t[v]:=(t[v&lt;&lt;1]+t[v&lt;&lt;1+1])mod mo;
end;
procedure build(v,ll,rr:longint);
var mid:longint;
begin
  l[v]:=ll;
  r[v]:=rr;
  tag1[v]:=1;
  tag2[v]:=0;
  if rr-ll=1 then
    begin
      t[v]:=a[ll]mod mo;
      exit;
    end;
  mid:=(ll+rr)&gt;&gt;1;
  build(v&lt;&lt;1,ll,mid);
  build(v&lt;&lt;1+1,mid,rr);
  update(v);
end;
procedure change1(v,a,b,x:longint);
var mid:longint;
begin
  if(r[v]-l[v]=1)or((a&lt;=l[v])and(r[v]&lt;=b))then
    begin
      tag1[v]:=tag1[v]*x mod mo;
      tag2[v]:=tag2[v]*x mod mo;
      t[v]:=t[v]*x mod mo;
      exit;
    end;
  pushdown(v);
  mid:=(l[v]+r[v])&gt;&gt;1;
  if a&lt;mid then change1(v&lt;&lt;1,a,b,x);
  if b&gt;=mid then change1(v&lt;&lt;1+1,a,b,x);
  update(v);
end;
procedure change2(v,a,b,x:longint);
var mid:longint;
begin
  if(r[v]-l[v]=1)or((a&lt;=l[v])and(r[v]&lt;=b))then
    begin
      tag2[v]:=(tag2[v]+x)mod mo;
      t[v]:=(t[v]+x*(r[v]-l[v]))mod mo;
      exit;
    end;
  pushdown(v);
  mid:=(l[v]+r[v])&gt;&gt;1;
  if a&lt;mid then change2(v&lt;&lt;1,a,b,x);
  if b&gt;=mid then change2(v&lt;&lt;1+1,a,b,x);
  update(v);
end;
function count(v,a,b:longint):int64;
var
  mid:longint;
  res:int64;
begin
  if(r[v]-l[v]=1)or((a&lt;=l[v])and(r[v]&lt;=b))then exit(t[v]);
  pushdown(v);
  mid:=(l[v]+r[v])&gt;&gt;1;
  res:=0;
  if a&lt;mid then res:=(res+count(v&lt;&lt;1,a,b))mod mo;
  if b&gt;=mid then res:=(res+count(v&lt;&lt;1+1,a,b))mod mo;
  exit(res);
end;
begin
  //assign(input,'1.in');reset(input);
  //assign(output,'ssss.out');rewrite(output);
  readln(n,mo);
  for i:=1 to n do
    begin
      read(a[i]);
      a[i]:=a[i] mod mo;
    end;
  build(1,1,n+1);
  readln(m);
  for i:=1 to m do
    begin
      read(tt);
      case tt of
        1:begin
            readln(ll,rr,x);
            change1(1,ll,rr,x mod mo);
          end;
        2:begin
            readln(ll,rr,x);
            change2(1,ll,rr,x mod mo);
          end;
        3:begin
            readln(ll,rr);
            writeln(count(1,ll,rr)mod mo);
          end;
        end;
    end;
  //close(input);close(output);
end.<pre><h2>Problem1798</h2><pre>//这是一个教训  区间最好用全闭的  当然也有使用左闭右开的情况
var
  a:array[1..100000]of longint;
  t:array[1..400010,1..3]of int64;
  ll,rr,c,d:array[1..400000]of longint;
  n,mo,m,i,x,p,q,xx,tot:longint;
procedure build(v,l,r:longint);
var mid:longint;
begin
  ll[v]:=l;
  rr[v]:=r;
  t[v,2]:=1;
  t[v,3]:=0;
  if r=l then
    begin
      t[v,1]:=a[l]mod mo;
      exit;
    end;
  inc(tot);
  c[v]:=tot;
  mid:=(l+r)&gt;&gt;1;
  build(tot,l,mid);
  inc(tot);
  d[v]:=tot;
  build(tot,mid+1,r);
  t[v,1]:=(t[c[v],1]+t[d[v],1])mod mo;
end;
procedure update(v:longint);
begin
  if(t[v,2]=1)and(t[v,3]=0)then exit;
  if c[v]&lt;&gt;0 then
    begin
      t[c[v],2]:=(t[c[v],2]*t[v,2])mod mo;
      t[c[v],3]:=(t[c[v],3]*t[v,2]+t[v,3])mod mo;
      t[c[v],1]:=((t[c[v],1]*t[v,2])+(t[v,3]*(rr[c[v]]-ll[c[v]]+1)))mod mo;
    end;
  if d[v]&lt;&gt;0 then
    begin
      t[d[v],2]:=(t[d[v],2]*t[v,2])mod mo;
      t[d[v],3]:=(t[d[v],3]*t[v,2]+t[v,3])mod mo;
      t[d[v],1]:=((t[d[v],1]*t[v,2])+(t[v,3]*(rr[d[v]]-ll[d[v]]+1)))mod mo;
    end;
  t[v,2]:=1;
  t[v,3]:=0;
end;
procedure change1(v,a,b,x:longint);
var mid:longint;
begin
  if(ll[v]=a)and(rr[v]=b)then
    begin
      t[v,1]:=t[v,1]*x mod mo;
      t[v,2]:=t[v,2]*x mod mo;
      t[v,3]:=t[v,3]*x mod mo;
      exit;
    end;
  update(v);
  mid:=(ll[v]+rr[v])&gt;&gt;1;
  if b&lt;=mid then change1(c[v],a,b,x)
  else if a&gt;mid then change1(d[v],a,b,x)
  else
    begin
      change1(c[v],a,mid,x);
      change1(d[v],mid+1,b,x);
    end;
  t[v,1]:=(t[c[v],1]+t[d[v],1])mod mo;
end;
procedure change2(v,a,b:longint;x:int64);
var mid:longint;
begin
  if(ll[v]=a)and(rr[v]=b)then
    begin
      t[v,1]:=(t[v,1]+x*(rr[v]-ll[v]+1))mod mo;
      t[v,3]:=(t[v,3]+x)mod mo;
      exit;
    end;
  update(v);
  mid:=(ll[v]+rr[v])&gt;&gt;1;
  if b&lt;=mid then change2(c[v],a,b,x)
  else if a&gt;mid then change2(d[v],a,b,x)
  else
    begin
      change2(c[v],a,mid,x);
      change2(d[v],mid+1,b,x);
    end;
  t[v,1]:=(t[c[v],1]+t[d[v],1])mod mo;
end;
function count(v,a,b:longint):int64;
var
  ans:int64;
  mid:longint;
begin
  if(ll[v]=a)and(rr[v]=b) then exit(t[v,1]);
  update(v);
  ans:=0;
  mid:=(ll[v]+rr[v])&gt;&gt;1;
  if b&lt;=mid then ans:=count(c[v],a,b)
  else if a&gt;mid then ans:=count(d[v],a,b)
  else
    begin
      ans:=count(c[v],a,mid)mod mo;
      ans:=ans+count(d[v],mid+1,b)mod mo;
    end;
  exit(ans);
end;
begin
  //assign(input,'score.in');reset(input);
  //assign(output,'score.out');rewrite(output);
  readln(n,mo);
  for i:=1 to n do read(a[i]);readln;
  tot:=1;
  build(1,1,n);
  readln(m);
  for i:=1 to m do
    begin
      read(x);
      if x=1 then
        begin
          readln(p,q,xx);
          xx:=xx mod mo;
          change1(1,p,q,xx);
        end
      else if x=2 then
        begin
          readln(p,q,xx);
          xx:=xx mod mo;
          change2(1,p,q,xx);
        end
      else
        begin
          readln(p,q);
          writeln(count(1,p,q)mod mo);
        end;
    end;
  close(input);close(output);
end.
<pre><h2>Problem1798</h2><pre>#include&lt;cstdio&gt;
#define lc(v) (v&lt;&lt;1)
#define rc(v) (lc(v)+1)
#define LL long long
using namespace std;
LL t[410000],t1[410000],t2[410000];
int l[410000],r[410000],a[110000];
int n,m,i,tmp,ll,rr,x,mo;
void update(int v)
{
	t[v]=(t[lc(v)]+t[rc(v)])%mo;
}
void pushdown(int v)
{
	if (t1[v]!=1)
	{
		t[lc(v)]=t[lc(v)]*t1[v]%mo;
		t1[lc(v)]=t1[lc(v)]*t1[v]%mo;
		t2[lc(v)]=t2[lc(v)]*t1[v]%mo;
		t[rc(v)]=t[rc(v)]*t1[v]%mo;
		t1[rc(v)]=t1[rc(v)]*t1[v]%mo;
		t2[rc(v)]=t2[rc(v)]*t1[v]%mo;
		t1[v]=1;
	}
	if (t2[v]!=0)
	{
		t[lc(v)]=(t[lc(v)]+t2[v]*(r[lc(v)]-l[lc(v)]))%mo;
		t2[lc(v)]=(t2[lc(v)]+t2[v])%mo;
		t[rc(v)]=(t[rc(v)]+t2[v]*(r[rc(v)]-l[rc(v)]))%mo;
		t2[rc(v)]=(t2[rc(v)]+t2[v])%mo;
		t2[v]=0;
	}
}
void build(int v,int ll,int rr)
{
	//printf(&quot;%s\n&quot;,&quot;-------------------&quot;);
	l[v]=ll,r[v]=rr;
	t1[v]=1,t2[v]=0;
	if (rr-ll==1)
	{
		t[v]=a[ll]%mo;
		return;
	}
	int mid=(ll+rr)&gt;&gt;1;
	build(lc(v),ll,mid);
	build(rc(v),mid,rr);
	//printf(&quot;%s%d %d %d %d\n&quot;,&quot;build1  &quot;,ll,rr,l[v],r[v]);
	update(v);
	//printf(&quot;%s\n&quot;,&quot;eeeeeeeeeeeee&quot;);
	//printf(&quot;%s%d %lld %d %d\n&quot;,&quot;build2  &quot;,ll,rr,l[v],r[v]);
}
void change1(int v,int a,int b,int x)
{
	//printf(&quot;%s%d %d\n&quot;,&quot;ssschange1  &quot;,v,t[v]);
	if (r[v]-l[v]==1||(a&lt;=l[v]&amp;&amp;r[v]&lt;=b))
	{
		t[v]=t[v]*x%mo;
		t1[v]=t1[v]*x%mo;
		t2[v]=t2[v]*x%mo;
		return;
	}
	pushdown(v);
	int mid=(l[v]+r[v])&gt;&gt;1;
	if (a&lt;mid) change1(lc(v),a,b,x);
	if (b&gt;=mid) change1(rc(v),a,b,x);
	update(v);
	//printf(&quot;%s%d %d\n&quot;,&quot;change1  &quot;,v,t[v]);
}
void change2(int v,int a,int b,int x)
{
	if (r[v]-l[v]==1||(a&lt;=l[v]&amp;&amp;r[v]&lt;=b))
	{
		t[v]=(t[v]+x*(r[v]-l[v]))%mo;
		t2[v]=(t2[v]+x)%mo;
		return;
	}
	pushdown(v);
	int mid=(l[v]+r[v])&gt;&gt;1;
	if (a&lt;mid) change2(lc(v),a,b,x);
	if (b&gt;=mid) change2(rc(v),a,b,x);
	update(v);
	//printf(&quot;%s%d %d %d %d\n&quot;,&quot;change2  &quot;,v,t[v],l[v],r[v]);
}
LL count(int v,int a,int b)
{
	//printf(&quot;%s%d %d\n&quot;,&quot;count  &quot;,v,t[v]);
	if (r[v]-l[v]==1||(a&lt;=l[v]&amp;&amp;r[v]&lt;=b)) return t[v];
	pushdown(v);
	LL res=0;
	int mid=(l[v]+r[v])&gt;&gt;1;
	if (a&lt;mid) res=(res+count(lc(v),a,b))%mo;
	if (b&gt;=mid) res=(res+count(rc(v),a,b))%mo;
	return res;
}
int main()
{
	//freopen(&quot;score.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;score.out&quot;,&quot;w&quot;,stdout);
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;mo);
	//printf(&quot;%d\n&quot;,n);
	for (i=1;i&lt;=n;scanf(&quot;%d&quot;,&amp;a[i++]));
	build(1,1,n+1);
	//printf(&quot;%s\n&quot;,&quot;-------------------&quot;);
	scanf(&quot;%d&quot;,&amp;m);
	//printf(&quot;\n%s\n\n&quot;,&quot;-------input end------------&quot;);
	//for (i=1;i&lt;=n;printf(&quot;%d &quot;,a[i++]));printf(&quot;\n&quot;);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;tmp,&amp;ll,&amp;rr);
		if (tmp==1)
		{
			scanf(&quot;%d&quot;,&amp;x);
			x=x%mo;
			change1(1,ll,rr,x);
		}
		else if (tmp==2)
		{
			scanf(&quot;%d&quot;,&amp;x);
			x%=mo;
			change2(1,ll,rr,x);
		}
		else printf(&quot;%d\n&quot;,count(1,ll,rr));
	}
	return 0;
}<pre><h2>Problem1798</h2><pre>#include&lt;cstdio&gt;
#define lc(v) (v&lt;&lt;1)
#define rc(v) (lc(v)+1)
#define LL long long
using namespace std;
LL t[410000],t1[410000],t2[410000];
int l[410000],r[410000],a[110000];
int n,m,i,tmp,ll,rr,x,mo;
void update(int v)
{
    t[v]=(t[lc(v)]+t[rc(v)])%mo;
}
void pushdown(int v)
{
    if (t1[v]!=1)
    {
        t[lc(v)]=t[lc(v)]*t1[v]%mo;
        t1[lc(v)]=t1[lc(v)]*t1[v]%mo;
        t2[lc(v)]=t2[lc(v)]*t1[v]%mo;
        t[rc(v)]=t[rc(v)]*t1[v]%mo;
        t1[rc(v)]=t1[rc(v)]*t1[v]%mo;
        t2[rc(v)]=t2[rc(v)]*t1[v]%mo;
        t1[v]=1;
    }
    if (t2[v]!=0)
    {
        t[lc(v)]=(t[lc(v)]+t2[v]*(r[lc(v)]-l[lc(v)]))%mo;
        t2[lc(v)]=(t2[lc(v)]+t2[v])%mo;
        t[rc(v)]=(t[rc(v)]+t2[v]*(r[rc(v)]-l[rc(v)]))%mo;
        t2[rc(v)]=(t2[rc(v)]+t2[v])%mo;
        t2[v]=0;
    }
}
void build(int v,int ll,int rr)
{
    //printf(&quot;%s\n&quot;,&quot;-------------------&quot;);
    l[v]=ll,r[v]=rr;
    t1[v]=1,t2[v]=0;
    if (rr-ll==1)
    {
        t[v]=a[ll]%mo;
        return;
    }
    int mid=(ll+rr)&gt;&gt;1;
    build(lc(v),ll,mid);
    build(rc(v),mid,rr);
    //printf(&quot;%s%d %d %d %d\n&quot;,&quot;build1  &quot;,ll,rr,l[v],r[v]);
    update(v);
    //printf(&quot;%s\n&quot;,&quot;eeeeeeeeeeeee&quot;);
    //printf(&quot;%s%d %lld %d %d\n&quot;,&quot;build2  &quot;,ll,rr,l[v],r[v]);
}
void change1(int v,int a,int b,int x)
{
    //printf(&quot;%s%d %d\n&quot;,&quot;ssschange1  &quot;,v,t[v]);
    if (a&lt;=l[v]&amp;&amp;r[v]&lt;=b)
    {
        t[v]=t[v]*x%mo;
        t1[v]=t1[v]*x%mo;
        t2[v]=t2[v]*x%mo;
        return;
    }
    pushdown(v);
    int mid=(l[v]+r[v])&gt;&gt;1;
    if (a&lt;mid) change1(lc(v),a,b,x);
    if (b&gt;mid) change1(rc(v),a,b,x);
    update(v);
    //printf(&quot;%s%d %d\n&quot;,&quot;change1  &quot;,v,t[v]);
}
void change2(int v,int a,int b,int x)
{
    if (a&lt;=l[v]&amp;&amp;r[v]&lt;=b)
    {
        t[v]=(t[v]+x*(r[v]-l[v]))%mo;
        t2[v]=(t2[v]+x)%mo;
        return;
    }
    pushdown(v);
    int mid=(l[v]+r[v])&gt;&gt;1;
    if (a&lt;mid) change2(lc(v),a,b,x);
    if (b&gt;mid) change2(rc(v),a,b,x);
    update(v);
    //printf(&quot;%s%d %d %d %d\n&quot;,&quot;change2  &quot;,v,t[v],l[v],r[v]);
}
LL count(int v,int a,int b)
{
    //printf(&quot;%s%d %d\n&quot;,&quot;count  &quot;,v,t[v]);
    if (a&lt;=l[v]&amp;&amp;r[v]&lt;=b) return t[v];
    pushdown(v);
    LL res=0;
    int mid=(l[v]+r[v])&gt;&gt;1;
    if (a&lt;mid) res=(res+count(lc(v),a,b))%mo;
    if (b&gt;mid) res=(res+count(rc(v),a,b))%mo;
    return res;
}
int main()
{
    //freopen(&quot;score.in&quot;,&quot;r&quot;,stdin);
    //freopen(&quot;score.out&quot;,&quot;w&quot;,stdout);
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
    //freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d%d&quot;,&amp;n,&amp;mo);
    //printf(&quot;%d\n&quot;,n);
    for (i=1;i&lt;=n;scanf(&quot;%d&quot;,&amp;a[i++]));
    build(1,1,n+1);
    //printf(&quot;%s\n&quot;,&quot;-------------------&quot;);
    scanf(&quot;%d&quot;,&amp;m);
    //printf(&quot;\n%s\n\n&quot;,&quot;-------input end------------&quot;);
    //for (i=1;i&lt;=n;printf(&quot;%d &quot;,a[i++]));printf(&quot;\n&quot;);
    for (i=1;i&lt;=m;i++)
    {
        scanf(&quot;%d%d%d&quot;,&amp;tmp,&amp;ll,&amp;rr);
        if (tmp==1)
        {
            scanf(&quot;%d&quot;,&amp;x);
            x=x%mo;
            change1(1,ll,rr+1,x);
        }
        else if (tmp==2)
        {
            scanf(&quot;%d&quot;,&amp;x);
            x%=mo;
            change2(1,ll,rr+1,x);
        }
        else printf(&quot;%d\n&quot;,count(1,ll,rr+1));
    }
    return 0;
}<pre><h2>Problem1801</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const int mo=9999973;
int f[105][105][105],n,m;
inline void renew(int &amp;x,LL y)
{
	y%=mo;
	x+=y;
	if (x&gt;mo) x-=mo;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	f[0][m][0]=1;
	int i,j,k;
	for (i=0;i&lt;n;i++)
		for (j=0;j&lt;=m;j++)
			for (k=0;k+j&lt;=m;k++)
			{
				int t=f[i][j][k];
				if (t==0) continue;
				renew(f[i+1][j][k],t);
				if (j&gt;0) renew(f[i+1][j-1][k+1],(LL)j*t);
				if (k&gt;0) renew(f[i+1][j][k-1],(LL)k*t);
				if (j&gt;1) renew(f[i+1][j-2][k+2],(LL)j*(j-1)/2*t);
				if (k&gt;1) renew(f[i+1][j][k-2],(LL)k*(k-1)/2*t);
				if (j&gt;0&amp;&amp;k&gt;0) renew(f[i+1][j-1][k],(LL)j*k*t);
			}
	int ans=0;
	for (i=0;i&lt;=m;i++)
		for (j=0;j&lt;=m;j++)
		{
			ans+=f[n][i][j];
			if (ans&gt;=mo) ans-=mo;
		}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1801</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const int mo=9999973,step=105,step2=105*105;
int f[105][105][105],n,m;
inline void renew(int &amp;x,LL y)
{
	y%=mo;
	x+=y;
	if (x&gt;mo) x-=mo;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	f[0][m][0]=1;
	int i,j,k,*x;
	for (i=0;i&lt;n;i++)
		for (j=0;j&lt;=m;j++)
			for (x=&amp;f[i][j][0],k=0;k+j&lt;=m;k++,x++)
			{
				if (*x==0) continue;
				renew(*(x+step2),*x);
				if (j&gt;0) renew(*(x+step2-step+1),(LL)j**x);
				if (k&gt;0) renew(*(x+step2-1),(LL)k**x);
				if (j&gt;1) renew(*(x+step2-(step&lt;&lt;1)+2),(LL)j*(j-1)/2**x);
				if (k&gt;1) renew(*(x+step2-2),(LL)k*(k-1)/2**x);
				if (j&gt;0&amp;&amp;k&gt;0) renew(*(x+step2-step),(LL)j*k**x);
			}
	int ans=0;
	for (i=0;i&lt;=m;i++)
		for (j=0;j&lt;=m;j++)
		{
			ans+=f[n][i][j];
			if (ans&gt;=mo) ans-=mo;
		}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1801</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const int mo=9999973,step=105,step2=105*105;
int f[105][105][105],n,m;
inline void renew(int &amp;x,LL y)
{
	if (y&gt;mo) y%=mo;
	x+=y;
	if (x&gt;mo) x-=mo;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	f[0][m][0]=1;
	int i,j,k,*x;
	for (i=0;i&lt;n;i++)
		for (j=0;j&lt;=m;j++)
			for (x=&amp;f[i][j][0],k=0;k+j&lt;=m;k++,x++)
			{
				if (*x==0) continue;
				renew(*(x+step2),*x);
				if (j&gt;0) renew(*(x+step2-step+1),(LL)j**x);
				if (k&gt;0) renew(*(x+step2-1),(LL)k**x);
				if (j&gt;1) renew(*(x+step2-(step&lt;&lt;1)+2),(LL)j*(j-1)/2**x);
				if (k&gt;1) renew(*(x+step2-2),(LL)k*(k-1)/2**x);
				if (j&gt;0&amp;&amp;k&gt;0) renew(*(x+step2-step),(LL)j*k**x);
			}
	int ans=0;
	for (i=0;i&lt;=m;i++)
		for (j=0;j&lt;=m;j++)
		{
			ans+=f[n][i][j];
			if (ans&gt;=mo) ans-=mo;
		}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1805</h2><pre>#include &lt;cstdio&gt; 
#include &lt;algorithm&gt; 
using namespace std; 
const int maxn=100010; 
struct orz 
{ 
    int h,num; 
}; 
int next[maxn],pre[maxn],lnum[maxn*4],rnum[maxn*4],n,m,tot,maxh,nowh; 
orz a[maxn]; 
int ll,rr; 
long long ans,sum[maxn*4],flag[maxn*4]; 
bool cmp(orz x,orz y) 
{ 
    return (x.h&lt;y.h); 
} 
void pushdown(int now,int l,int r) 
{ 
    int w=now&lt;&lt;1,mid=(l+r)&gt;&gt;1; 
    flag[w]+=flag[now]; 
    flag[w+1]+=flag[now]; 
    sum[w]+=flag[now]*(mid-l+1); 
    sum[w+1]+=flag[now]*(r-mid); 
    lnum[w]+=flag[now]; 
    rnum[w]+=flag[now]; 
    lnum[w+1]+=flag[now]; 
    rnum[w+1]+=flag[now]; 
    flag[now]=0; 
} 
int getnum(int now,int l,int r) 
{ 
    if (l==r) return sum[now]; 
    if (flag[now]) pushdown(now,l,r); 
    int w=now&lt;&lt;1,mid=(l+r)&gt;&gt;1; 
    if (ll&lt;=mid) return getnum(w,l,mid); else return getnum(w+1,mid+1,r); 
} 
int getl(int now,int l,int r,int value) 
{ 
    if (l==r) return l; 
    if (flag[now]) pushdown(now,l,r); 
    int w=now&lt;&lt;1,mid=(l+r)&gt;&gt;1; 
    if (rnum[w]&lt;=value) return getl(w,l,mid,value); else return getl(w+1,mid+1,r,value); 
} 
int getr(int now,int l,int r,int value) 
{ 
    if (l==r) return l; 
    if (flag[now]) pushdown(now,l,r); 
    int w=now&lt;&lt;1,mid=(l+r)&gt;&gt;1; 
    if (rr&gt;mid&amp;&amp;lnum[w+1]&gt;=value) return getr(w+1,mid+1,r,value); else return getr(w,l,mid,value); 
} 
long long getsum(int now,int l,int r) 
{ 
    if (l&gt;=ll&amp;&amp;r&lt;=rr) return sum[now]; 
    if (flag[now]) pushdown(now,l,r); 
    int w=now&lt;&lt;1,mid=(l+r)&gt;&gt;1; 
    long long ret=0; 
    if (ll&lt;=mid) ret=getsum(w,l,mid); 
    if (rr&gt;mid) ret+=getsum(w+1,mid+1,r); 
    return ret; 
} 
void change(int now,int l,int r) 
{ 
    if (l&gt;=ll&amp;&amp;r&lt;=rr) 
    { 
        flag[now]+=1; 
        sum[now]+=(r-l+1); 
        lnum[now]++; 
        rnum[now]++; 
        return; 
    } 
    if (flag[now]) pushdown(now,l,r); 
    int w=now&lt;&lt;1,mid=(l+r)&gt;&gt;1; 
    if (ll&lt;=mid) change(w,l,mid); 
    if (rr&gt;mid) change(w+1,mid+1,r); 
    sum[now]=sum[w]+sum[w+1]; 
    lnum[now]=lnum[w]; 
    rnum[now]=rnum[w+1]; 
} 
int main() 
{ 
	//freopen(&quot;s1ils7.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d&quot;,&amp;n); 
    int i,x,posl,posr; 
    long long y; 
    for (i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;a[i].h,&amp;a[i].num); 
    sort(a+1,a+n+1,cmp); 
    maxh=a[n].h; 
    for (i=1;i&lt;=n;i++) 
    { 
        nowh+=a[i].h-a[i-1].h; 
        ll=nowh-a[i].num+1; 
        x=getnum(1,1,maxh); 
        ll=1,rr=nowh; 
        posl=getl(1,1,maxh,x); 
        posr=getr(1,1,maxh,x); 
        ll=rr-a[i].num+1; 
        ans+=getsum(1,1,maxh); 
        if (posr&lt;nowh) 
        { 
            ll=posr+1,rr=nowh; 
            change(1,1,maxh); 
        } 
        ll=posl,rr=ll+a[i].num+posr-nowh-1; 
        change(1,1,maxh); 
    } 
    printf(&quot;%lld\n&quot;,ans); 
    return 0; 
}<pre><h2>Problem1806</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 999999999
int f[2][4][4][4][4],n,a[101111];
inline int F(char ch)
{
	if (ch=='M') return 1;
	if (ch=='F') return 2;
	return 3;
}
inline int calc(int x,int y,int z)
{
	if (x==0)
	{
		if (y==0) return 1;
		return y==z?1:2;
	}
	else
	{
		if (x==y)
		{
			if (y==z) return 1;
			return 2;
		}
		else
		{
			if (x==z) return 2;
			if (y==z) return 2;
			return 3;
		}
	}
}
inline void renew(int &amp;x,int y)
{
	if (y&gt;x) x=y;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d\n&quot;,&amp;n);
	int i,j,k,l,t;
	for (i=1;i&lt;=n;i++) a[i]=F(getchar());
	memset(f,-60,sizeof(f));
	int now=0;
	f[0][0][0][0][0]=0;
	for (i=0;i&lt;n;i++)
	{
		for (j=0;j&lt;=3;j++)
			for (k=0;k&lt;=3;k++)
				for (l=0;l&lt;=3;l++)
					for (t=0;t&lt;=3;t++) f[now^1][j][k][l][t]=-inf;
		for (j=0;j&lt;=3;j++)
			for (k=0;k&lt;=3;k++)
				for (l=0;l&lt;=3;l++)
					for (t=0;t&lt;=3;t++)
					{
						int tmp=f[now][j][k][l][t];
						if (tmp&lt;0) continue;
						renew(f[now^1][k][a[i+1]][l][t],tmp+calc(j,k,a[i+1]));
						renew(f[now^1][j][k][t][a[i+1]],tmp+calc(l,t,a[i+1]));
					}
		now^=1;
	}
	int ans=0;
	for (j=0;j&lt;=3;j++)
		for (k=0;k&lt;=3;k++)
			for (l=0;l&lt;=3;l++)
				for (t=0;t&lt;=3;t++)
					renew(ans,f[now][j][k][l][t]);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1808</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;
struct bian
{
    int u,v,w;
};
const int maxn=1010,maxm=10010;
int a[maxm],next[maxm],last[maxn],n,m,mm,root[maxn],fa[maxn],lca[maxn][maxn],num[maxn],son[maxn][10];
int kind[maxn],max[maxn],log[2048],d[maxn],ans,sum,f[maxn][1024];
bian b[maxm];
bool v[maxn];
void build(int x,int y)
{
	//printf(&quot;build:      %d %d\n&quot;,x,y);
    a[++mm]=y;
    next[mm]=last[x];
    last[x]=mm;
    a[++mm]=x;
    next[mm]=last[y];
    last[y]=mm;
}
void build2(int x,int y)
{
	//printf(&quot;build2222:  %d %d\n&quot;,x,y);
    a[++mm]=y;
    next[mm]=last[x];
    last[x]=mm;
}
int findroot(int x)
{
    int tmp=x,find;
    while (root[x]) x=root[x];
    find=x;
    for (x=tmp;root[x];x=tmp) {tmp=root[x]; root[x]=find;}
    return find;
}
void tarjan(int x)
{
    v[x]=true;
    int j;
    for (j=1;j&lt;=n;j++) if (v[j]) lca[x][j]=lca[j][x]=findroot(j);
    for (j=last[x];j;j=next[j]) if (a[j]!=fa[x])
    {
        fa[a[j]]=x;
        d[a[j]]=d[x]+1;
        tarjan(a[j]);
    }
    root[x]=fa[x];
}
int mmax(int x,int y)
{
    if (x&gt;y) return x;
    return y;
}
void treedp(int now)
{
    int i,j,x,y,l,ret,ssum;
    for (i=0;i&lt;num[now];i++) treedp(son[now][i]);
    for (i=0;i&lt;num[now];i++) f[now][1&lt;&lt;i]=f[son[now][i]][max[son[now][i]]];
    for (i=2;i&lt;=max[now];i++)
    {
        x=i&amp;-i;
        f[now][i]=f[now][i-x]+f[now][x];
    }
    for (j=last[now];j;j=next[j])
    {
        i=a[j];
        x=b[i].u,y=b[i].v;
        l=lca[x][y],ret=0;
        if (l==x) {x=y; y=l;}
        ///if (l==now) printf(&quot;You are right!\n&quot;);else printf(&quot;Something wrong.\n&quot;);
        if (l==y)
        {
            ret=b[i].w+f[x][max[x]];
            for (;fa[x]!=l;x=fa[x]) ret+=f[fa[x]][max[fa[x]]-(1&lt;&lt;kind[x])];
            ssum=1&lt;&lt;kind[x];
        }
        else
        {
            ret=b[i].w+f[x][max[x]]+f[y][max[y]];
            for (;fa[x]!=l;x=fa[x]) ret+=f[fa[x]][max[fa[x]]-(1&lt;&lt;kind[x])];
            for (;fa[y]!=l;y=fa[y]) ret+=f[fa[y]][max[fa[y]]-(1&lt;&lt;kind[y])];
            ssum=(1&lt;&lt;kind[x])+(1&lt;&lt;kind[y]);
        }
        for (i=ssum;i&lt;=max[l];i++) if ((i&amp;ssum)==ssum) f[l][i]=mmax(f[l][i],f[l][i-ssum]+ret);
    }
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    int i,x,y;
    for (i=1;i&lt;=m;i++)
    {
        scanf(&quot;%d%d%d&quot;,&amp;b[i].u,&amp;b[i].v,&amp;b[i].w);
        if (!b[i].w) build(b[i].u,b[i].v);
    }
    tarjan(1);
    for (i=2;i&lt;=n;i++)
    {
        son[fa[i]][num[fa[i]]]=i;
        kind[i]=num[fa[i]]++;
    }
    for (i=1;i&lt;=m;i++) if (b[i].w)
    {
        x=d[b[i].u]+d[b[i].v]-2*d[lca[b[i].u][b[i].v]];
        sum+=b[i].w;
        if (x&amp;1) {ans+=b[i].w; b[i].w=0;}
    }
    for (i=1;i&lt;=n;i++) max[i]=(1&lt;&lt;num[i])-1;
    for (y=0,x=1;y&lt;=9;y++,x=x&lt;&lt;1) log[x]=y;
    memset(last,0,sizeof(last));
    mm=0;
    for (i=1;i&lt;=m;i++) if (b[i].w) build2(lca[b[i].u][b[i].v],i);
    treedp(1);
    printf(&quot;%d\n&quot;,sum-f[1][max[1]]);
    return 0;
}
<pre><h2>Problem1808</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;
struct bian
{
    int u,v,w;
};
const int maxn=1010,maxm=10010;
int a[maxm],next[maxm],last[maxn],n,m,mm,root[maxn],fa[maxn],lca[maxn][maxn],num[maxn],son[maxn][10];
int kind[maxn],max[maxn],log[2048],d[maxn],ans,sum,f[maxn][1024];
bian b[maxm];
bool v[maxn];
void build(int x,int y)
{
	//printf(&quot;build:      %d %d\n&quot;,x,y);
    a[++mm]=y;
    next[mm]=last[x];
    last[x]=mm;
    a[++mm]=x;
    next[mm]=last[y];
    last[y]=mm;
}
void build2(int x,int y)
{
	//printf(&quot;build2222:  %d %d\n&quot;,x,y);
    a[++mm]=y;
    next[mm]=last[x];
    last[x]=mm;
}
int findroot(int x)
{
    int tmp=x,find;
    while (root[x]) x=root[x];
    find=x;
    for (x=tmp;root[x];x=tmp) {tmp=root[x]; root[x]=find;}
    return find;
}
void tarjan(int x)
{
    v[x]=true;
    int j;
    for (j=1;j&lt;=n;j++) if (v[j]) lca[x][j]=lca[j][x]=findroot(j);
    for (j=last[x];j;j=next[j]) if (a[j]!=fa[x])
    {
        fa[a[j]]=x;
        d[a[j]]=d[x]+1;
        tarjan(a[j]);
    }
    root[x]=fa[x];
}
int mmax(int x,int y)
{
    if (x&gt;y) return x;
    return y;
}
void treedp(int now)
{
    int i,j,x,y,l,ret,ssum;
    for (i=0;i&lt;num[now];i++) treedp(son[now][i]);
    for (i=0;i&lt;num[now];i++) f[now][1&lt;&lt;i]=f[son[now][i]][max[son[now][i]]];
    for (i=2;i&lt;=max[now];i++)
    {
        x=i&amp;-i;
        f[now][i]=f[now][i-x]+f[now][x];
    }
    for (j=last[now];j;j=next[j])
    {
        i=a[j];
        x=b[i].u,y=b[i].v;
        l=now,ret=0;
        if (l==x) {x=y; y=l;}
        ///if (l==now) printf(&quot;You are right!\n&quot;);else printf(&quot;Something wrong.\n&quot;);
        if (l==y)
        {
            ret=b[i].w+f[x][max[x]];
            for (;fa[x]!=l;x=fa[x]) ret+=f[fa[x]][max[fa[x]]-(1&lt;&lt;kind[x])];
            ssum=1&lt;&lt;kind[x];
        }
        else
        {
            ret=b[i].w+f[x][max[x]]+f[y][max[y]];
            for (;fa[x]!=l;x=fa[x]) ret+=f[fa[x]][max[fa[x]]-(1&lt;&lt;kind[x])];
            for (;fa[y]!=l;y=fa[y]) ret+=f[fa[y]][max[fa[y]]-(1&lt;&lt;kind[y])];
            ssum=(1&lt;&lt;kind[x])+(1&lt;&lt;kind[y]);
        }
        for (i=ssum;i&lt;=max[l];i++) if ((i&amp;ssum)==ssum) f[l][i]=mmax(f[l][i],f[l][i-ssum]+ret);
    }
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    int i,x,y;
    for (i=1;i&lt;=m;i++)
    {
        scanf(&quot;%d%d%d&quot;,&amp;b[i].u,&amp;b[i].v,&amp;b[i].w);
        if (!b[i].w) build(b[i].u,b[i].v);
    }
    tarjan(1);
    for (i=2;i&lt;=n;i++)
    {
        son[fa[i]][num[fa[i]]]=i;
        kind[i]=num[fa[i]]++;
    }
    for (i=1;i&lt;=m;i++) if (b[i].w)
    {
        x=d[b[i].u]+d[b[i].v]-2*d[lca[b[i].u][b[i].v]];
        sum+=b[i].w;
        if (x&amp;1) {ans+=b[i].w; b[i].w=0;}
    }
    for (i=1;i&lt;=n;i++) max[i]=(1&lt;&lt;num[i])-1;
    for (y=0,x=1;y&lt;=9;y++,x=x&lt;&lt;1) log[x]=y;
    memset(last,0,sizeof(last));
    mm=0;
    for (i=1;i&lt;=m;i++) if (b[i].w) build2(lca[b[i].u][b[i].v],i);
    treedp(1);
    printf(&quot;%d\n&quot;,sum-f[1][max[1]]);
    return 0;
}
<pre><h2>Problem1808</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int num[1100],all[1100],fa[1100],fa2[1100],o[1100],aa[1000000][2];
int son[1100][12],deep[1100],f[1100][1124],lca[1100][1100],id[1100];
int n,m,tot,ans,i;
bool vt[1100];
struct edge {int a,b,c;} e[5100];
int max(int a,int b) {return a&gt;b?a:b;}
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int getroot(int x) {return fa2[x]==x?x:fa2[x]=getroot(fa2[x]);}
void tarjan(int v)
{
	vt[v]=1;
	fa2[v]=v;
	for (int i=1;i&lt;=n;i++)
		if (vt[i]) lca[v][i]=lca[i][v]=getroot(i);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		tarjan(y);
	}
	fa2[v]=fa[v];
}
void treedp(int v)
{
	int i,p,x,y,res,dec;
	for (i=1;i&lt;=num[v];i++) treedp(son[v][i]);
	for (i=1;i&lt;=num[v];i++) f[v][1&lt;&lt;(i-1)]=f[son[v][i]][all[son[v][i]]];
	for (i=0;i&lt;=all[v];i++) f[v][i]=f[v][i&amp;-i]+f[v][i^(i&amp;-i)];
	for (p=o[v];p;p=aa[p][0])
	{
		i=aa[p][1];
		x=e[i].a,y=e[i].b;
		if (y==v) swap(x,y);
		if (x==v)
		{
			res=e[i].c+f[y][all[y]];
			for (;fa[y]!=v;y=fa[y]) res+=f[fa[y]][all[fa[y]]^(1&lt;&lt;(id[y]-1))];
			dec=1&lt;&lt;(id[y]-1);
		}
		else
		{
			res=e[i].c+f[x][all[x]]+f[y][all[y]];
			for (;fa[x]!=v;x=fa[x]) res+=f[fa[x]][all[fa[x]]^(1&lt;&lt;(id[x]-1))];
			for (;fa[y]!=v;y=fa[y]) res+=f[fa[y]][all[fa[y]]^(1&lt;&lt;(id[y]-1))];
			dec=(1&lt;&lt;(id[x]-1))+(1&lt;&lt;(id[y]-1));
		}
		for (i=0;i&lt;=all[v];i++)
			if ((i&amp;dec)==dec) f[v][i]=max(f[v][i],f[v][i^dec]+res);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].c);
		if (!e[i].c) addedge(e[i].a,e[i].b),addedge(e[i].b,e[i].a);
	}
	tarjan(1);
	for (i=1;i&lt;=n;i++)
	{
		son[fa[i]][++num[fa[i]]]=i;
		id[i]=num[fa[i]];
	}
	for (i=1;i&lt;=n;i++) all[i]=(1&lt;&lt;num[i])-1;
	for (i=1;i&lt;=m;i++)
		if (e[i].c)
		{
			ans+=e[i].c;
			int tmp=deep[e[i].a]+deep[e[i].b]-deep[lca[e[i].a][e[i].b]]*2;
			if (tmp&amp;1) e[i].c=0;
		}
	memset(o,0,sizeof(o[0])*(n+10));
	tot=0;
	for (i=1;i&lt;=m;i++)
		if (e[i].c) addedge(lca[e[i].a][e[i].b],i);
	treedp(1);
	ans-=f[1][all[1]];
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1808</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int num[1100],all[1100],fa[1100],fa2[1100],o[1100],aa[1000000][2];
int son[1100][12],deep[1100],f[1100][1124],lca[1100][1100],id[1100];
int n,m,tot,ans,i;
bool vt[1100];
struct edge {int a,b,c;} e[5100];
int max(int a,int b) {return a&gt;b?a:b;}
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int getroot(int x) {return fa2[x]==x?x:fa2[x]=getroot(fa2[x]);}
void tarjan(int v)
{
	vt[v]=1;
	fa2[v]=v;
	for (int i=1;i&lt;=n;i++)
		if (vt[i]) lca[v][i]=lca[i][v]=getroot(i);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		tarjan(y);
	}
	fa2[v]=fa[v];
}
void treedp(int v)
{
	int i,p,x,y,res,dec;
	for (i=1;i&lt;=num[v];i++) treedp(son[v][i]);
	for (i=1;i&lt;=num[v];i++) f[v][1&lt;&lt;(i-1)]=f[son[v][i]][all[son[v][i]]];
	for (i=0;i&lt;=all[v];i++) f[v][i]=f[v][i&amp;-i]+f[v][i^(i&amp;-i)];
	for (p=o[v];p;p=aa[p][0])
	{
		i=aa[p][1];
		x=e[i].a,y=e[i].b;
		if (y==v) swap(x,y);
		if (x==v)
		{
			res=e[i].c+f[y][all[y]];
			for (;fa[y]!=v;y=fa[y]) res+=f[fa[y]][all[fa[y]]^(1&lt;&lt;(id[y]-1))];
			dec=1&lt;&lt;(id[y]-1);
		}
		else
		{
			res=e[i].c+f[x][all[x]]+f[y][all[y]];
			for (;fa[x]!=v;x=fa[x]) res+=f[fa[x]][all[fa[x]]^(1&lt;&lt;(id[x]-1))];
			for (;fa[y]!=v;y=fa[y]) res+=f[fa[y]][all[fa[y]]^(1&lt;&lt;(id[y]-1))];
			dec=(1&lt;&lt;(id[x]-1))+(1&lt;&lt;(id[y]-1));
		}
		for (i=0;i&lt;=all[v];i++)
			if ((i&amp;dec)==dec) f[v][i]=max(f[v][i],f[v][i^dec]+res);
	}
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].c);
		if (!e[i].c) addedge(e[i].a,e[i].b),addedge(e[i].b,e[i].a);
	}
	tarjan(1);
	for (i=1;i&lt;=n;i++)
	{
		son[fa[i]][++num[fa[i]]]=i;
		id[i]=num[fa[i]];
	}
	for (i=1;i&lt;=n;i++) all[i]=(1&lt;&lt;num[i])-1;
	for (i=1;i&lt;=m;i++)
		if (e[i].c)
		{
			ans+=e[i].c;
			int tmp=deep[e[i].a]+deep[e[i].b]-deep[lca[e[i].a][e[i].b]]*2;
			if (tmp&amp;1) e[i].c=0;
		}
	memset(o,0,sizeof(o[0])*(n+10));
	tot=0;
	for (i=1;i&lt;=m;i++)
		if (e[i].c) addedge(lca[e[i].a][e[i].b],i);
	treedp(1);
	ans-=f[1][all[1]];
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1814</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int MAXD=15;
const int HASH=30007;
const int STATE=1000010;
int N,M;
int maze[MAXD][MAXD];
int code[MAXD];
int ch[MAXD];//×îÐ¡±íÊ¾·¨Ê¹ÓÃ
int ex,ey;//×îºóÒ»¸ö·ÇÕÏ°­¸ñ×ÓµÄ×ø±ê
struct HASHMAP
{
    int head[HASH],next[STATE],size;
    long long state[STATE];
    long long f[STATE];
    void init()
    {
        size=0;
        memset(head,-1,sizeof(head));
    }
    void push(long long st,long long ans)
    {
        int i;
        int h=st%HASH;
        for(i=head[h];i!=-1;i=next[i])//ÕâÀïÒª×¢ÒâÊÇnext
          if(state[i]==st)
          {
              f[i]+=ans;
              return;
          }
        state[size]=st;
        f[size]=ans;
        next[size]=head[h];
        head[h]=size++;
    }
}hm[2];
void decode(int *code,int m,long long  st)
{
    for(int i=m;i&gt;=0;i--)
    {
        code[i]=st&amp;7;
        st&gt;&gt;=3;
    }
}
long long encode(int *code,int m)//×îÐ¡±íÊ¾·¨
{
    int cnt=1;
    memset(ch,-1,sizeof(ch));
    ch[0]=0;
    long long st=0;
    for(int i=0;i&lt;=m;i++)
    {
        if(ch[code[i]]==-1)ch[code[i]]=cnt++;
        code[i]=ch[code[i]];
        st&lt;&lt;=3;
        st|=code[i];
    }
    return st;
}
void shift(int *code,int m)
{
    for(int i=m;i&gt;0;i--)code[i]=code[i-1];
    code[0]=0;
}
void dpblank(int i,int j,int cur)
{
    int k,left,up;
    for(k=0;k&lt;hm[cur].size;k++)
    {
        decode(code,M,hm[cur].state[k]);
        left=code[j-1];
        up=code[j];
        if(left&amp;&amp;up)
        {
            if(left==up)//Ö»ÄÜ³öÏÖÔÚ×îºóÒ»¸ö·ÇÕÏ°­¸ñ×Ó
            {
                if(i==ex&amp;&amp;j==ey)
                {
                    code[j-1]=code[j]=0;
                    if(j==M)shift(code,M);
                    hm[cur^1].push(encode(code,M),hm[cur].f[k]);
                }
            }
            else//²»ÔÚÍ¬Ò»¸öÁ¬Í¨·ÖÁ¿ÔòºÏ²¢
            {
                code[j-1]=code[j]=0;
                for(int t=0;t&lt;=M;t++)
                  if(code[t]==up)
                    code[t]=left;
                if(j==M)shift(code,M);
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
        }
        else if((left&amp;&amp;(!up))||((!left)&amp;&amp;up))
        {
            int t;
            if(left)t=left;
            else t=up;
            if(maze[i][j+1])
            {
                code[j-1]=0;
                code[j]=t;
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
            if(maze[i+1][j])
            {
                code[j-1]=t;
                code[j]=0;
                if(j==M)shift(code,M);
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
        }
        else//ÎÞ²åÍ·£¬Ôò¹¹ÔìÐÂµÄÁ¬Í¨¿é
        {
            if(maze[i][j+1]&amp;&amp;maze[i+1][j])
            {
                code[j-1]=code[j]=13;
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
        }
    }
}
void dpblock(int i,int j,int cur)
{
    int k;
    for(k=0;k&lt;hm[cur].size;k++)
    {
        decode(code,M,hm[cur].state[k]);
        code[j-1]=code[j]=0;
        if(j==M)shift(code,M);
        hm[cur^1].push(encode(code,M),hm[cur].f[k]);
    }
}
char str[MAXD];
void init()
{
    memset(maze,0,sizeof(maze));

    ex=0;
    for(int i=1;i&lt;=N;i++)
    {
        scanf(&quot;%s&quot;,str);
        for(int j=0;j&lt;M;j++)
        {
            if(str[j]=='.')
            {
                ex=i;
                ey=j+1;
                maze[i][j+1]=1;
            }
        }
    }
}
void solve()
{
    int i,j,cur=0;
    long long ans=0;
    hm[cur].init();
    hm[cur].push(0,1);
    for(i=1;i&lt;=N;i++)
      for(j=1;j&lt;=M;j++)
      {
          hm[cur^1].init();
          if(maze[i][j])dpblank(i,j,cur);
          else  dpblock(i,j,cur);
          cur^=1;
      }
    for(i=0;i&lt;hm[cur].size;i++)
      ans+=hm[cur].f[i];
    printf(&quot;%lld\n&quot;,ans);
}
int main()
{
   // freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    while(scanf(&quot;%d%d&quot;,&amp;N,&amp;M)!=EOF)
    {
        init();
        if(ex==0)//Ã»ÓÐ¿ÕµÄ¸ñ×Ó
        {
            printf(&quot;0\n&quot;);
            continue;
        }
        solve();
    }
    return 0;
}<pre><h2>Problem1814</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int MAXD=15;
const int HASH=30007;
const int STATE=1000010;
int N,M;
int maze[MAXD][MAXD];
int code[MAXD];
int ch[MAXD];//×îÐ¡±íÊ¾·¨Ê¹ÓÃ
int ex,ey;//×îºóÒ»¸ö·ÇÕÏ°­¸ñ×ÓµÄ×ø±ê
struct HASHMAP
{
    int head[HASH],next[STATE],size;
    long long state[STATE];
    long long f[STATE];
    void init()
    {
        size=0;
        memset(head,-1,sizeof(head));
    }
    void push(long long st,long long ans)
    {
        int i;
        int h=st%HASH;
        for(i=head[h];i!=-1;i=next[i])//ÕâÀïÒª×¢ÒâÊÇnext
          if(state[i]==st)
          {
              f[i]+=ans;
              return;
          }
        state[size]=st;
        f[size]=ans;
        next[size]=head[h];
        head[h]=size++;
    }
}hm[2];
void decode(int *code,int m,long long  st)
{
    for(int i=m;i&gt;=0;i--)
    {
        code[i]=st&amp;7;
        st&gt;&gt;=3;
    }
}
long long encode(int *code,int m)//×îÐ¡±íÊ¾·¨
{
    int cnt=1;
    memset(ch,-1,sizeof(ch));
    ch[0]=0;
    long long st=0;
    for(int i=0;i&lt;=m;i++)
    {
        if(ch[code[i]]==-1)ch[code[i]]=cnt++;
        code[i]=ch[code[i]];
        st&lt;&lt;=3;
        st|=code[i];
    }
    return st;
}
void shift(int *code,int m)
{
    for(int i=m;i&gt;0;i--)code[i]=code[i-1];
    code[0]=0;
}
void dpblank(int i,int j,int cur)
{
    int k,left,up;
    for(k=0;k&lt;hm[cur].size;k++)
    {
        decode(code,M,hm[cur].state[k]);
        left=code[j-1];
        up=code[j];
        if(left&amp;&amp;up)
        {
            if(left==up)//Ö»ÄÜ³öÏÖÔÚ×îºóÒ»¸ö·ÇÕÏ°­¸ñ×Ó
            {
                if(i==ex&amp;&amp;j==ey)
                {
                    code[j-1]=code[j]=0;
                    if(j==M)shift(code,M);
                    hm[cur^1].push(encode(code,M),hm[cur].f[k]);
                }
            }
            else//²»ÔÚÍ¬Ò»¸öÁ¬Í¨·ÖÁ¿ÔòºÏ²¢
            {
                code[j-1]=code[j]=0;
                for(int t=0;t&lt;=M;t++)
                  if(code[t]==up)
                    code[t]=left;
                if(j==M)shift(code,M);
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
        }
        else if((left&amp;&amp;(!up))||((!left)&amp;&amp;up))
        {
            int t;
            if(left)t=left;
            else t=up;
            if(maze[i][j+1])
            {
                code[j-1]=0;
                code[j]=t;
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
            if(maze[i+1][j])
            {
                code[j-1]=t;
                code[j]=0;
                if(j==M)shift(code,M);
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
        }
        else//ÎÞ²åÍ·£¬Ôò¹¹ÔìÐÂµÄÁ¬Í¨¿é
        {
            if(maze[i][j+1]&amp;&amp;maze[i+1][j])
            {
                code[j-1]=code[j]=13;
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
        }
    }
}
void dpblock(int i,int j,int cur)
{
    int k;
    for(k=0;k&lt;hm[cur].size;k++)
    {
        decode(code,M,hm[cur].state[k]);
        code[j-1]=code[j]=0;
        if(j==M)shift(code,M);
        hm[cur^1].push(encode(code,M),hm[cur].f[k]);
    }
}
char str[MAXD];
void init()
{
    memset(maze,0,sizeof(maze));

    ex=0;
    for(int i=1;i&lt;=N;i++)
    {
        scanf(&quot;%s&quot;,str);
        for(int j=0;j&lt;M;j++)
        {
            if(str[j]=='.')
            {
                ex=i;
                ey=j+1;
                maze[i][j+1]=1;
            }
        }
    }
}
void solve()
{
    int i,j,cur=0;
    long long ans=0;
    hm[cur].init();
    hm[cur].push(0,1);
    for(i=1;i&lt;=N;i++)
      for(j=1;j&lt;=M;j++)
      {
          hm[cur^1].init();
          if(maze[i][j])dpblank(i,j,cur);
          else  dpblock(i,j,cur);
          cur^=1;
      }
    for(i=0;i&lt;hm[cur].size;i++)
      ans+=hm[cur].f[i];
    printf(&quot;%lld\n&quot;,ans);
}
int main()
{
   // freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    while(scanf(&quot;%d%d&quot;,&amp;N,&amp;M)!=EOF)
    {
        init();
        
        solve();
    }
    return 0;
}<pre><h2>Problem1814</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int MAXD=15;
int N,M;
int maze[MAXD][MAXD];
int code[MAXD];
int ex,ey;//×îºóÒ»¸ö·ÇÕÏ°­¸ñ×ÓµÄ×ø±ê
struct HASHMAP
{
	#define HASH 30007 
	#define STATE 1001111
    int head[HASH],next[STATE],size;
    long long state[STATE];
    long long f[STATE];
    void init()
    {
        size=0;
        memset(head,-1,sizeof(head));
    }
    void push(long long st,long long ans)
    {
        int i;
        int h=st%HASH;
        for(i=head[h];i!=-1;i=next[i])//ÕâÀïÒª×¢ÒâÊÇnext
          if(state[i]==st)
          {
              f[i]+=ans;
              return;
          }
        state[size]=st;
        f[size]=ans;
        next[size]=head[h];
        head[h]=size++;
    }
} hm[2];
void decode(int *code,int m,long long  st)
{
    for(int i=m;i&gt;=0;i--)
    {
        code[i]=st&amp;7;
        st&gt;&gt;=3;
    }
}
long long encode(int *code,int m)//×îÐ¡±íÊ¾·¨
{
	static int ch[MAXD];//×îÐ¡±íÊ¾·¨Ê¹ÓÃ
    int cnt=1;
    memset(ch,-1,sizeof(ch));
    ch[0]=0;
    long long st=0;
    for(int i=0;i&lt;=m;i++)
    {
        if(ch[code[i]]==-1)ch[code[i]]=cnt++;
        code[i]=ch[code[i]];
        st=st&lt;&lt;3|code[i];
    }
    return st;
}
void shift(int *code,int m)
{
    for (int i=m;i&gt;0;i--) code[i]=code[i-1];
    code[0]=0;
}
void dpblank(int i,int j,int cur)
{
    int k,left,up;
    for(k=0;k&lt;hm[cur].size;k++)
    {
        decode(code,M,hm[cur].state[k]);
        left=code[j-1];
        up=code[j];
        if(left&amp;&amp;up)
        {
            if(left==up)//Ö»ÄÜ³öÏÖÔÚ×îºóÒ»¸ö·ÇÕÏ°­¸ñ×Ó
            {
                if(i==ex&amp;&amp;j==ey)
                {
                    code[j-1]=code[j]=0;
                    if(j==M)shift(code,M);
                    hm[cur^1].push(encode(code,M),hm[cur].f[k]);
                }
            }
            else//²»ÔÚÍ¬Ò»¸öÁ¬Í¨·ÖÁ¿ÔòºÏ²¢
            {
                code[j-1]=code[j]=0;
                for(int t=0;t&lt;=M;t++)
                  if(code[t]==up)
                    code[t]=left;
                if(j==M)shift(code,M);
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
        }
        else if((left&amp;&amp;(!up))||((!left)&amp;&amp;up))
        {
            int t;
            if(left)t=left;
            else t=up;
            if(maze[i][j+1])
            {
                code[j-1]=0;
                code[j]=t;
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
            if(maze[i+1][j])
            {
                code[j-1]=t;
                code[j]=0;
                if(j==M)shift(code,M);
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
        }
        else//ÎÞ²åÍ·£¬Ôò¹¹ÔìÐÂµÄÁ¬Í¨¿é
        {
            if(maze[i][j+1]&amp;&amp;maze[i+1][j])
            {
                code[j-1]=code[j]=13;
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
        }
    }
}
void dpblock(int i,int j,int cur)
{
    int k;
    for(k=0;k&lt;hm[cur].size;k++)
    {
        decode(code,M,hm[cur].state[k]);
        code[j-1]=code[j]=0;
        if(j==M)shift(code,M);
        hm[cur^1].push(encode(code,M),hm[cur].f[k]);
    }
}
char str[MAXD];
void init()
{
    memset(maze,0,sizeof(maze));
    ex=0;
    for(int i=1;i&lt;=N;i++)
    {
        scanf(&quot;%s&quot;,str);
        for(int j=0;j&lt;M;j++)
        {
            if(str[j]=='.')
            {
                ex=i;
                ey=j+1;
                maze[i][j+1]=1;
            }
        }
    }
}
void solve()
{
    int i,j,cur=0;
    long long ans=0;
    hm[cur].init();
    hm[cur].push(0,1);
    for(i=1;i&lt;=N;i++)
      for(j=1;j&lt;=M;j++)
      {
          hm[cur^1].init();
          if(maze[i][j])dpblank(i,j,cur);
          else dpblock(i,j,cur);
          cur^=1;
      }
    for(i=0;i&lt;hm[cur].size;i++)
      ans+=hm[cur].f[i];
    printf(&quot;%lld\n&quot;,ans);
}
int main()
{
   // freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    while(scanf(&quot;%d%d&quot;,&amp;N,&amp;M)!=EOF)
    {
        init();
        solve();
    }
    return 0;
}<pre><h2>Problem1814</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
const int MAXD=15;
int N,M;
int maze[MAXD][MAXD];
int code[MAXD];
int ex,ey;//×îºóÒ»¸ö·ÇÕÏ°­¸ñ×ÓµÄ×ø±ê
struct HASHMAP
{
	#define HASH 30007 
	#define STATE 1001111
    int head[HASH],next[STATE],size;
    long long state[STATE];
    long long f[STATE];
    void init()
    {
        size=0;
        memset(head,-1,sizeof(head));
    }
    void push(long long st,long long ans)
    {
        int i;
        int h=st%HASH;
        for(i=head[h];i!=-1;i=next[i])//ÕâÀïÒª×¢ÒâÊÇnext
          if(state[i]==st)
          {
              f[i]+=ans;
              return;
          }
        state[size]=st;
        f[size]=ans;
        next[size]=head[h];
        head[h]=size++;
    }
} hm[2];
void decode(int *code,int m,long long  st)
{
    for(int i=m;i&gt;=0;i--)
    {
        code[i]=st&amp;7;
        st&gt;&gt;=3;
    }
}
long long encode(int *code,int m)//×îÐ¡±íÊ¾·¨
{
	static int ch[MAXD];//×îÐ¡±íÊ¾·¨Ê¹ÓÃ
    int cnt=1;
    memset(ch,-1,sizeof(ch));
    ch[0]=0;
    long long st=0;
    for(int i=0;i&lt;=m;i++)
    {
        if(ch[code[i]]==-1)ch[code[i]]=cnt++;
        code[i]=ch[code[i]];
        st=st&lt;&lt;3|code[i];
    }
    return st;
}
void shift(int *code,int m)
{
    for (int i=m;i&gt;0;i--) code[i]=code[i-1];
    code[0]=0;
}
void dpblank(int i,int j,int cur)
{
    int k,left,up;
    for(k=0;k&lt;hm[cur].size;k++)
    {
        decode(code,M,hm[cur].state[k]);
        left=code[j-1];
        up=code[j];
        if(left&amp;&amp;up)
        {
            if(left==up)//Ö»ÄÜ³öÏÖÔÚ×îºóÒ»¸ö·ÇÕÏ°­¸ñ×Ó
            {
                if(i==ex&amp;&amp;j==ey)
                {
                    code[j-1]=code[j]=0;
                    if(j==M)shift(code,M);
                    hm[cur^1].push(encode(code,M),hm[cur].f[k]);
                }
            }
            else//²»ÔÚÍ¬Ò»¸öÁ¬Í¨·ÖÁ¿ÔòºÏ²¢
            {
                code[j-1]=code[j]=0;
                for(int t=0;t&lt;=M;t++)
                  if(code[t]==up)
                    code[t]=left;
                if(j==M)shift(code,M);
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
        }
        else if((left&amp;&amp;(!up))||((!left)&amp;&amp;up))
        {
            int t;
            if(left)t=left;
            else t=up;
            if(maze[i][j+1])
            {
                code[j-1]=0;
                code[j]=t;
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
            if(maze[i+1][j])
            {
                code[j-1]=t;
                code[j]=0;
                if(j==M)shift(code,M);
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
        }
        else//ÎÞ²åÍ·£¬Ôò¹¹ÔìÐÂµÄÁ¬Í¨¿é
        {
            if(maze[i][j+1]&amp;&amp;maze[i+1][j])
            {
                code[j-1]=code[j]=13;
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
        }
    }
}
void dpblock(int i,int j,int cur)
{
    int k;
    for(k=0;k&lt;hm[cur].size;k++)
    {
        decode(code,M,hm[cur].state[k]);
        code[j-1]=code[j]=0;
        if (j==M) shift(code,M);
        hm[cur^1].push(encode(code,M),hm[cur].f[k]);
    }
}
void init()
{
	static char str[MAXD];
    memset(maze,0,sizeof(maze));
    ex=0;
    for(int i=1;i&lt;=N;i++)
    {
        scanf(&quot;%s&quot;,str);
        for(int j=0;j&lt;M;j++)
        {
            if(str[j]=='.')
            {
                ex=i;
                ey=j+1;
                maze[i][j+1]=1;
            }
        }
    }
}
void solve()
{
    int i,j,cur=0;
    long long ans=0;
    hm[cur].init();
    hm[cur].push(0,1);
    for(i=1;i&lt;=N;i++)
      for(j=1;j&lt;=M;j++)
      {
          hm[cur^1].init();
          if(maze[i][j])dpblank(i,j,cur);
          else dpblock(i,j,cur);
          cur^=1;
      }
    for(i=0;i&lt;hm[cur].size;i++)
      ans+=hm[cur].f[i];
    cout&lt;&lt;ans&lt;&lt;endl;
}
int main()
{
   // freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    while(scanf(&quot;%d%d&quot;,&amp;N,&amp;M)!=EOF)
    {
        init();
        solve();
    }
    return 0;
}<pre><h2>Problem1814</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
const int MAXD=15;
int N,M;
int maze[MAXD][MAXD];
int code[MAXD];
int ex,ey;//×îºóÒ»¸ö·ÇÕÏ°­¸ñ×ÓµÄ×ø±ê
struct HASHMAP
{
	#define HASH 30007 
	#define STATE 1001111
    int head[HASH],next[STATE],size;
    long long state[STATE];
    long long f[STATE];
    void init()
    {
        size=0;
        memset(head,-1,sizeof(head));
    }
    void push(long long st,long long ans)
    {
        int i;
        int h=st%HASH;
        for(i=head[h];i!=-1;i=next[i])//ÕâÀïÒª×¢ÒâÊÇnext
          if(state[i]==st)
          {
              f[i]+=ans;
              return;
          }
        state[size]=st;
        f[size]=ans;
        next[size]=head[h];
        head[h]=size++;
    }
} hm[2];
void decode(int *code,int m,long long  st)
{
    for(int i=m;i&gt;=0;i--)
    {
        code[i]=st&amp;7;
        st&gt;&gt;=3;
    }
}
long long encode(int *code,int m)//×îÐ¡±íÊ¾·¨
{
	static int ch[MAXD];//×îÐ¡±íÊ¾·¨Ê¹ÓÃ
    int cnt=1;
    memset(ch,-1,sizeof(ch));
    ch[0]=0;
    long long st=0;
    for(int i=0;i&lt;=m;i++)
    {
        if(ch[code[i]]==-1)ch[code[i]]=cnt++;
        code[i]=ch[code[i]];
        st=st&lt;&lt;3|code[i];
    }
    return st;
}
void shift(int *code,int m)
{
    for (int i=m;i&gt;0;i--) code[i]=code[i-1];
    code[0]=0;
}
void dpblank(int i,int j,int cur)
{
    int k,left,up;
    for(k=0;k&lt;hm[cur].size;k++)
    {
        decode(code,M,hm[cur].state[k]);
        left=code[j-1];
        up=code[j];
        if(left&amp;&amp;up)
        {
            if(left==up)//Ö»ÄÜ³öÏÖÔÚ×îºóÒ»¸ö·ÇÕÏ°­¸ñ×Ó
            {
                if(i==ex&amp;&amp;j==ey)
                {
                    code[j-1]=code[j]=0;
                    if (j==M) shift(code,M);
                    hm[cur^1].push(encode(code,M),hm[cur].f[k]);
                }
            }
            else//²»ÔÚÍ¬Ò»¸öÁ¬Í¨·ÖÁ¿ÔòºÏ²¢
            {
                code[j-1]=code[j]=0;
                for(int t=0;t&lt;=M;t++)
                  if(code[t]==up)
                    code[t]=left;
                if (j==M) shift(code,M);
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
        }
        else if((left&amp;&amp;(!up))||((!left)&amp;&amp;up))
        {
            int t;
            if(left)t=left;
            else t=up;
            if(maze[i][j+1])
            {
                code[j-1]=0;
                code[j]=t;
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
            if(maze[i+1][j])
            {
                code[j-1]=t;
                code[j]=0;
                if(j==M)shift(code,M);
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
        }
        else//ÎÞ²åÍ·£¬Ôò¹¹ÔìÐÂµÄÁ¬Í¨¿é
        {
            if(maze[i][j+1]&amp;&amp;maze[i+1][j])
            {
                code[j-1]=code[j]=13;
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
        }
    }
}
void dpblock(int i,int j,int cur)
{
    int k;
    for(k=0;k&lt;hm[cur].size;k++)
    {
        decode(code,M,hm[cur].state[k]);
        code[j-1]=code[j]=0;
        if (j==M) shift(code,M);
        hm[cur^1].push(encode(code,M),hm[cur].f[k]);
    }
}
void init()
{
	static char str[MAXD];
    memset(maze,0,sizeof(maze));
    ex=0;
    for(int i=1;i&lt;=N;i++)
    {
        scanf(&quot;%s&quot;,str);
        for(int j=0;j&lt;M;j++)
        {
            if(str[j]=='.')
            {
                ex=i;
                ey=j+1;
                maze[i][j+1]=1;
            }
        }
    }
}
void solve()
{
    int i,j,cur=0;
    long long ans=0;
    hm[cur].init();
    hm[cur].push(0,1);
    for(i=1;i&lt;=N;i++)
      for(j=1;j&lt;=M;j++)
      {
          hm[cur^1].init();
          if (maze[i][j]) dpblank(i,j,cur);
          else dpblock(i,j,cur);
          cur^=1;
      }
    for(i=0;i&lt;hm[cur].size;i++)
      ans+=hm[cur].f[i];
    cout&lt;&lt;ans&lt;&lt;endl;
}
int main()
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    while(scanf(&quot;%d%d&quot;,&amp;N,&amp;M)!=EOF)
    {
        init();
        solve();
    }
    return 0;
}<pre><h2>Problem1814</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
const int MAXD=15;
int N,M;
int maze[MAXD][MAXD];
int code[MAXD];
int ex,ey;//最后一个非障碍格子的坐标
struct HASHMAP
{
	#define HASH 30007 
	#define STATE 1001111
    int head[HASH],next[STATE],size;
    long long state[STATE];
    long long f[STATE];
    void init()
    {
        size=0;
        memset(head,-1,sizeof(head));
    }
    void push(long long st,long long ans)
    {
        int i;
        int h=st%HASH;
        for(i=head[h];i!=-1;i=next[i])//这里要注意是next
          if(state[i]==st)
          {
              f[i]+=ans;
              return;
          }
        state[size]=st;
        f[size]=ans;
        next[size]=head[h];
        head[h]=size++;
    }
} hm[2];
void decode(int *code,int m,long long  st)
{
    for(int i=m;i&gt;=0;i--)
    {
        code[i]=st&amp;7;
        st&gt;&gt;=3;
    }
}
long long encode(int *code,int m)//最小表示法
{
	static int ch[MAXD];//最小表示法使用
    int cnt=1;
    memset(ch,-1,sizeof(ch));
    ch[0]=0;
    long long st=0;
    for(int i=0;i&lt;=m;i++)
    {
        if(ch[code[i]]==-1)ch[code[i]]=cnt++;
        code[i]=ch[code[i]];
        st=st&lt;&lt;3|code[i];
    }
    return st;
}
void shift(int *code,int m)
{
    for (int i=m;i&gt;0;i--) code[i]=code[i-1];
    code[0]=0;
}
void dpblank(int i,int j,int cur)
{
    int k,left,up;
    for(k=0;k&lt;hm[cur].size;k++)
    {
        decode(code,M,hm[cur].state[k]);
        left=code[j-1];
        up=code[j];
        if(left&amp;&amp;up)
        {
            if(left==up)//只能出现在最后一个非障碍格子 
            {
                if(i==ex&amp;&amp;j==ey)//如果不是最后一个格子，那么这个状态就是非法的 
                {
                    code[j-1]=code[j]=0;
                    if (j==M) shift(code,M);
                    hm[cur^1].push(encode(code,M),hm[cur].f[k]);
                }
            }
            else//不在同一个连通分量则合并
            {
                code[j-1]=code[j]=0;
                for(int t=0;t&lt;=M;t++)
                  if(code[t]==up)
                    code[t]=left;
                if (j==M) shift(code,M);
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
        }
        else if((left&amp;&amp;(!up))||((!left)&amp;&amp;up))
        {
            int t;
            if(left)t=left;
            else t=up;
            if(maze[i][j+1])
            {
                code[j-1]=0;
                code[j]=t;
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
            if(maze[i+1][j])
            {
                code[j-1]=t;
                code[j]=0;
                if(j==M)shift(code,M);
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
        }
        else//无插头，则构造新的连通块
        {
            if(maze[i][j+1]&amp;&amp;maze[i+1][j])
            {
                code[j-1]=code[j]=14;
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
        }
    }
}
void dpblock(int i,int j,int cur)
{
    int k;
    for(k=0;k&lt;hm[cur].size;k++)
    {
        decode(code,M,hm[cur].state[k]);
        code[j-1]=code[j]=0;
        if (j==M) shift(code,M);
        hm[cur^1].push(encode(code,M),hm[cur].f[k]);
    }
}
void init()
{
	static char str[MAXD];
    memset(maze,0,sizeof(maze));
    ex=0;
    for(int i=1;i&lt;=N;i++)
    {
        scanf(&quot;%s&quot;,str);
        for(int j=0;j&lt;M;j++)
        {
            if(str[j]=='.')
            {
                ex=i;
                ey=j+1;
                maze[i][j+1]=1;
            }
        }
    }
}
void solve()
{
    int i,j,cur=0;
    long long ans=0;
    hm[cur].init();
    hm[cur].push(0,1);
    for(i=1;i&lt;=N;i++)
      for(j=1;j&lt;=M;j++)
      {
          hm[cur^1].init();
          if (maze[i][j]) dpblank(i,j,cur);
          else dpblock(i,j,cur);
          cur^=1;
      }
    for(i=0;i&lt;hm[cur].size;i++)
      ans+=hm[cur].f[i];
    cout&lt;&lt;ans&lt;&lt;endl;
}
int main()
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    while(scanf(&quot;%d%d&quot;,&amp;N,&amp;M)!=EOF)
    {
        init();
        solve();
    }
    return 0;
}<pre><h2>Problem1814</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
const int MAXD=15;
int N,M;
int maze[MAXD][MAXD];
int code[MAXD];
int ex,ey;//最后一个非障碍格子的坐标
struct HASHMAP
{
	#define HASH 30007 
	#define STATE 1001111
    int head[HASH],next[STATE],size;
    long long state[STATE];
    long long f[STATE];
    void init()
    {
        size=0;
        memset(head,-1,sizeof(head));
    }
    void push(long long st,long long ans)
    {
        int i;
        int h=st%HASH;
        for(i=head[h];i!=-1;i=next[i])//这里要注意是next
          if(state[i]==st)
          {
              f[i]+=ans;
              return;
          }
        state[size]=st;
        f[size]=ans;
        next[size]=head[h];
        head[h]=size++;
    }
} hm[2];
void decode(int *code,int m,long long  st)
{
    for(int i=m;i&gt;=0;i--)
    {
        code[i]=st&amp;7;
        st&gt;&gt;=3;
    }
}
long long encode(int *code,int m)//最小表示法
{
	static int ch[MAXD];//最小表示法使用
    int cnt=1;
    memset(ch,-1,sizeof(ch));
    ch[0]=0;
    long long st=0;
    for(int i=0;i&lt;=m;i++)
    {
        if(ch[code[i]]==-1)ch[code[i]]=cnt++;
        code[i]=ch[code[i]];
        st=st&lt;&lt;3|code[i];
    }
    return st;
}
void shift(int *code,int m)
{
    for (int i=m;i&gt;0;i--) code[i]=code[i-1];
    code[0]=0;
}
void dpblank(int i,int j,int cur)
{
    int k,left,up;
    for(k=0;k&lt;hm[cur].size;k++)
    {
        decode(code,M,hm[cur].state[k]);
        left=code[j-1];
        up=code[j];
        if(left&amp;&amp;up)
        {
            if(left==up)//只能出现在最后一个非障碍格子 
            {
                if(i==ex&amp;&amp;j==ey)//如果不是最后一个格子，那么这个状态就是非法的 
                {
                    code[j-1]=code[j]=0;
                    if (j==M) shift(code,M);
                    hm[cur^1].push(encode(code,M),hm[cur].f[k]);
                }
            }
            else//不在同一个连通分量则合并
            {
                code[j-1]=code[j]=0;
                for(int t=0;t&lt;=M;t++)
                  if(code[t]==up)
                    code[t]=left;
                if (j==M) shift(code,M);
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
        }
        else if((left&amp;&amp;(!up))||((!left)&amp;&amp;up))
        {
            int t=left+up;
            if(maze[i][j+1])
            {
                code[j-1]=0;
                code[j]=t;
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
            if(maze[i+1][j])
            {
                code[j-1]=t;
                code[j]=0;
                if(j==M)shift(code,M);
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
        }
        else//无插头，则构造新的连通块
        {
            if(maze[i][j+1]&amp;&amp;maze[i+1][j])
            {
                code[j-1]=code[j]=13;
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
        }
    }
}
void dpblock(int i,int j,int cur)
{
    int k;
    for(k=0;k&lt;hm[cur].size;k++)
    {
        decode(code,M,hm[cur].state[k]);
        code[j-1]=code[j]=0;
        if (j==M) shift(code,M);
        hm[cur^1].push(encode(code,M),hm[cur].f[k]);
    }
}
void init()
{
	static char str[MAXD];
    memset(maze,0,sizeof(maze));
    ex=0;
    for(int i=1;i&lt;=N;i++)
    {
        scanf(&quot;%s&quot;,str);
        for(int j=0;j&lt;M;j++)
        {
            if(str[j]=='.')
            {
                ex=i;
                ey=j+1;
                maze[i][j+1]=1;
            }
        }
    }
}
void solve()
{
    int i,j,cur=0;
    long long ans=0;
    hm[cur].init();
    hm[cur].push(0,1);
    for(i=1;i&lt;=N;i++)
      for(j=1;j&lt;=M;j++)
      {
          hm[cur^1].init();
          if (maze[i][j]) dpblank(i,j,cur);
          else dpblock(i,j,cur);
          cur^=1;
      }
    for(i=0;i&lt;hm[cur].size;i++)
      ans+=hm[cur].f[i];
    cout&lt;&lt;ans&lt;&lt;endl;
}
int main()
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    while(scanf(&quot;%d%d&quot;,&amp;N,&amp;M)!=EOF)
    {
        init();
        solve();
    }
    return 0;
}<pre><h2>Problem1814</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
const int MAXD=15;
int N,M;
int maze[MAXD][MAXD];
int code[MAXD];
int ex,ey;//最后一个非障碍格子的坐标
struct HASHMAP
{
	#define HASH 30007 
	#define STATE 1001111
    int head[HASH],next[STATE],size;
    long long state[STATE];
    long long f[STATE];
    void init()
    {
        size=0;
        memset(head,-1,sizeof(head));
    }
    void push(long long st,long long ans)
    {
        int i;
        int h=st%HASH;
        for(i=head[h];i!=-1;i=next[i])//这里要注意是next
          if(state[i]==st)
          {
              f[i]+=ans;
              return;
          }
        state[size]=st;
        f[size]=ans;
        next[size]=head[h];
        head[h]=size++;
    }
} hm[2];
void decode(int *code,int m,long long  st)
{
    for(int i=m;i&gt;=0;i--)
    {
        code[i]=st&amp;7;
        st&gt;&gt;=3;
    }
}
long long encode(int *code,int m)//最小表示法
{
	static int ch[MAXD];//最小表示法使用
    int cnt=1;
    memset(ch,-1,sizeof(ch));
    ch[0]=0;
    long long st=0;
    for(int i=0;i&lt;=m;i++)
    {
        if(ch[code[i]]==-1)ch[code[i]]=cnt++;
        code[i]=ch[code[i]];
        st=st&lt;&lt;3|code[i];
    }
    return st;
}
void shift(int *code,int m)
{
    for (int i=m;i&gt;0;i--) code[i]=code[i-1];
    code[0]=0;
}
void dpblank(int i,int j,int cur)
{
    int k,left,up;
    for(k=0;k&lt;hm[cur].size;k++)
    {
        decode(code,M,hm[cur].state[k]);
        left=code[j-1];
        up=code[j];
        if(left&amp;&amp;up)
        {
            if(left==up)//只能出现在最后一个非障碍格子 
            {
                if(i==ex&amp;&amp;j==ey)//如果不是最后一个格子，那么这个状态就是非法的 
                {
                    code[j-1]=code[j]=0;
                    if (j==M) shift(code,M);
                    hm[cur^1].push(encode(code,M),hm[cur].f[k]);
                }
            }
            else//不在同一个连通分量则合并
            {
                code[j-1]=code[j]=0;
                for(int t=0;t&lt;=M;t++)
                  if(code[t]==up)
                    code[t]=left;
                if (j==M) shift(code,M);
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
        }
        else if((left&amp;&amp;(!up))||((!left)&amp;&amp;up))//保持原来的连通块 
        {
            int t=left+up;
            if(maze[i][j+1])
            {
                code[j-1]=0;
                code[j]=t;
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
            if(maze[i+1][j])
            {
                code[j-1]=t;
                code[j]=0;
                if(j==M)shift(code,M);
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
        }
        else//无插头，则构造新的连通块
        {
            if(maze[i][j+1]&amp;&amp;maze[i+1][j])
            {
                code[j-1]=code[j]=13;
                hm[cur^1].push(encode(code,M),hm[cur].f[k]);
            }
        }
    }
}
void dpblock(int i,int j,int cur)
{
    int k;
    for(k=0;k&lt;hm[cur].size;k++)
    {
        decode(code,M,hm[cur].state[k]);
        code[j-1]=code[j]=0;
        if (j==M) shift(code,M);
        hm[cur^1].push(encode(code,M),hm[cur].f[k]);
    }
}
void init()
{
	static char str[MAXD];
    memset(maze,0,sizeof(maze));
    ex=0;
    for(int i=1;i&lt;=N;i++)
    {
        scanf(&quot;%s&quot;,str);
        for(int j=0;j&lt;M;j++)
        {
            if(str[j]=='.')
            {
                ex=i;
                ey=j+1;
                maze[i][j+1]=1;
            }
        }
    }
}
void solve()
{
    int i,j,cur=0;
    long long ans=0;
    hm[cur].init();
    hm[cur].push(0,1);
    for(i=1;i&lt;=N;i++)
      for(j=1;j&lt;=M;j++)
      {
          hm[cur^1].init();
          if (maze[i][j]) dpblank(i,j,cur);
          else dpblock(i,j,cur);
          cur^=1;
      }
    for(i=0;i&lt;hm[cur].size;i++)
      ans+=hm[cur].f[i];
    cout&lt;&lt;ans&lt;&lt;endl;
}
int main()
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    while(scanf(&quot;%d%d&quot;,&amp;N,&amp;M)!=EOF)
    {
        init();
        solve();
    }
    return 0;
}<pre><h2>Problem1814</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
const int MAXD=15;
int N,M;
int maze[MAXD][MAXD];
int code[MAXD];
int ex,ey;//最后一个非障碍格子的坐标
struct HASHMAP
{
	#define HASH 30007 
	#define STATE 1001111
    int head[HASH],next[STATE],size;
    long long state[STATE];
    long long f[STATE];
    void init()
    {
        size=0;
        memset(head,-1,sizeof(head));
    }
    void push(long long st,long long ans)
    {
        int i;
        int h=st%HASH;
        for(i=head[h];i!=-1;i=next[i])//这里要注意是next
          if(state[i]==st)
          {
              f[i]+=ans;
              return;
          }
        state[size]=st;
        f[size]=ans;
        next[size]=head[h];
        head[h]=size++;
    }
} hm[2];
void decode(int *code,int m,long long  st)
{
    for(int i=m;i&gt;=0;i--)
    {
        code[i]=st&amp;7;
        st&gt;&gt;=3;
    }
}
long long encode(int *code)//最小表示法
{
	static int ch[MAXD];//最小表示法使用
    int cnt=1;
    memset(ch,-1,sizeof(ch));
    ch[0]=0;
    long long st=0;
    for(int i=0;i&lt;=M;i++)
    {
        if(ch[code[i]]==-1)ch[code[i]]=cnt++;
        code[i]=ch[code[i]];
        st=st&lt;&lt;3|code[i];
    }
    return st;
}
void shift(int *code)
{
    for (int i=M;i&gt;0;i--) code[i]=code[i-1];
    code[0]=0;
}
void dpblank(int i,int j,int cur)
{
    int k,left,up;
    for(k=0;k&lt;hm[cur].size;k++)
    {
        decode(code,M,hm[cur].state[k]);
        left=code[j-1];
        up=code[j];
        if(left&amp;&amp;up)
        {
            if(left==up)//只能出现在最后一个非障碍格子 
            {
                if(i==ex&amp;&amp;j==ey)//如果不是最后一个格子，那么这个状态就是非法的 
                {
                    code[j-1]=code[j]=0;
                    if (j==M) shift(code);
                    hm[cur^1].push(encode(code),hm[cur].f[k]);
                }
            }
            else//不在同一个连通分量则合并
            {
                code[j-1]=code[j]=0;
                for(int t=0;t&lt;=M;t++)
                  if(code[t]==up)
                    code[t]=left;
                if (j==M) shift(code);
                hm[cur^1].push(encode(code),hm[cur].f[k]);
            }
        }
        else if((left&amp;&amp;(!up))||((!left)&amp;&amp;up))//保持原来的连通块 
        {
            int t=left+up;
            if(maze[i][j+1])
            {
                code[j-1]=0;
                code[j]=t;
                hm[cur^1].push(encode(code),hm[cur].f[k]);
            }
            if(maze[i+1][j])
            {
                code[j-1]=t;
                code[j]=0;
                if(j==M)shift(code);
                hm[cur^1].push(encode(code),hm[cur].f[k]);
            }
        }
        else//无插头，则构造新的连通块
        {
            if(maze[i][j+1]&amp;&amp;maze[i+1][j])
            {
                code[j-1]=code[j]=13;
                hm[cur^1].push(encode(code),hm[cur].f[k]);
            }
        }
    }
}
void dpblock(int i,int j,int cur)
{
    int k;
    for(k=0;k&lt;hm[cur].size;k++)
    {
        decode(code,M,hm[cur].state[k]);
        code[j-1]=code[j]=0;
        if (j==M) shift(code);
        hm[cur^1].push(encode(code),hm[cur].f[k]);
    }
}
void init()
{
	static char str[MAXD];
    memset(maze,0,sizeof(maze));
    ex=0;
    for(int i=1;i&lt;=N;i++)
    {
        scanf(&quot;%s&quot;,str);
        for(int j=0;j&lt;M;j++)
        {
            if(str[j]=='.')
            {
                ex=i;
                ey=j+1;
                maze[i][j+1]=1;
            }
        }
    }
}
void solve()
{
    int i,j,cur=0;
    long long ans=0;
    hm[cur].init();
    hm[cur].push(0,1);
    for(i=1;i&lt;=N;i++)
      for(j=1;j&lt;=M;j++)
      {
          hm[cur^1].init();
          if (maze[i][j]) dpblank(i,j,cur);
          else dpblock(i,j,cur);
          cur^=1;
      }
    for(i=0;i&lt;hm[cur].size;i++)
      ans+=hm[cur].f[i];
    cout&lt;&lt;ans&lt;&lt;endl;
}
int main()
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    while(scanf(&quot;%d%d&quot;,&amp;N,&amp;M)!=EOF)
    {
        init();
        solve();
    }
    return 0;
}<pre><h2>Problem1814</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
const int MAXD=15;
int N,M;
int maze[MAXD][MAXD];
int code[MAXD];
int ex,ey;//最后一个非障碍格子的坐标
struct HASHMAP
{
	#define HASH 30007 
	#define STATE 1001111
    int head[HASH],next[STATE],size;
    long long state[STATE];
    long long f[STATE];
    void init()
    {
        size=0;
        memset(head,-1,sizeof(head));
    }
    void push(long long st,long long ans)
    {
        int i;
        int h=st%HASH;
        for(i=head[h];i!=-1;i=next[i])//这里要注意是next
          if(state[i]==st)
          {
              f[i]+=ans;
              return;
          }
        state[size]=st;
        f[size]=ans;
        next[size]=head[h];
        head[h]=size++;
    }
} hm[2];
void decode(int *code,int m,long long  st)
{
    for(int i=m;i&gt;=0;i--)
    {
        code[i]=st&amp;7;
        st&gt;&gt;=3;
    }
}
long long encode(int *code)//最小表示法
{
	static int ch[MAXD];//最小表示法使用
    int cnt=1;
    memset(ch,-1,sizeof(ch));
    ch[0]=0;
    long long st=0;
    for(int i=0;i&lt;=M;i++)
    {
        if(ch[code[i]]==-1)ch[code[i]]=cnt++;
        code[i]=ch[code[i]];
        st=st&lt;&lt;3|code[i];
    }
    return st;
}
void shift(int *code)
{
    for (int i=M;i&gt;0;i--) code[i]=code[i-1];
    code[0]=0;
}
void dpblank(int i,int j,int cur)
{
    int k,left,up;
    for(k=0;k&lt;hm[cur].size;k++)
    {
        decode(code,M,hm[cur].state[k]);
        left=code[j-1];
        up=code[j];
        if(left&amp;&amp;up)
        {
            if(left==up)//只能出现在最后一个非障碍格子 
            {
                if(i==ex&amp;&amp;j==ey)//如果不是最后一个格子，那么这个状态就是非法的 
                {
                    code[j-1]=code[j]=0;
                    if (j==M) shift(code);
                    hm[cur^1].push(encode(code),hm[cur].f[k]);
                }
            }
            else//不在同一个连通分量则合并
            {
                code[j-1]=code[j]=0;
                for(int t=0;t&lt;=M;t++)
                  if(code[t]==up)
                    code[t]=left;
                if (j==M) shift(code);
                hm[cur^1].push(encode(code),hm[cur].f[k]);
            }
        }
        else if((left&amp;&amp;(!up))||((!left)&amp;&amp;up))//保持原来的连通块 
        {
            int t=left+up;
            if(maze[i][j+1])
            {
                code[j-1]=0;
                code[j]=t;
                hm[cur^1].push(encode(code),hm[cur].f[k]);
            }
            if(maze[i+1][j])
            {
                code[j-1]=t;
                code[j]=0;
                if(j==M)shift(code);
                hm[cur^1].push(encode(code),hm[cur].f[k]);
            }
        }
        else//无插头，则构造新的连通块
        {
            if(maze[i][j+1]&amp;&amp;maze[i+1][j])
            {
                code[j-1]=code[j]=13;
                hm[cur^1].push(encode(code),hm[cur].f[k]);
            }
        }
    }
}
void dpblock(int i,int j,int cur)
{
    int k;
    for(k=0;k&lt;hm[cur].size;k++)
    {
        decode(code,M,hm[cur].state[k]);
        //code[j-1]=code[j]=0;
        if (j==M) shift(code);
        hm[cur^1].push(encode(code),hm[cur].f[k]);
    }
}
void init()
{
	static char str[MAXD];
    memset(maze,0,sizeof(maze));
    ex=0;
    for(int i=1;i&lt;=N;i++)
    {
        scanf(&quot;%s&quot;,str);
        for(int j=0;j&lt;M;j++)
        {
            if(str[j]=='.')
            {
                ex=i;
                ey=j+1;
                maze[i][j+1]=1;
            }
        }
    }
}
void solve()
{
    int i,j,cur=0;
    long long ans=0;
    hm[cur].init();
    hm[cur].push(0,1);
    for(i=1;i&lt;=N;i++)
      for(j=1;j&lt;=M;j++)
      {
          hm[cur^1].init();
          if (maze[i][j]) dpblank(i,j,cur);
          else dpblock(i,j,cur);
          cur^=1;
      }
    for(i=0;i&lt;hm[cur].size;i++)
      ans+=hm[cur].f[i];
    cout&lt;&lt;ans&lt;&lt;endl;
}
int main()
{
   // freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
    while(scanf(&quot;%d%d&quot;,&amp;N,&amp;M)!=EOF)
    {
        init();
        solve();
    }
    return 0;
}<pre><h2>Problem1814</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
const int MAXD=15;
int N,M;
int maze[MAXD][MAXD];
int code[MAXD];
int ex,ey;//最后一个非障碍格子的坐标
struct HASHMAP
{
	#define HASH 30007 
	#define STATE 1001111
    int head[HASH],next[STATE],size;
    long long state[STATE];
    long long f[STATE];
    void init()
    {
        size=0;
        memset(head,-1,sizeof(head));
    }
    void push(long long st,long long ans)
    {
        int i;
        int h=st%HASH;
        for(i=head[h];i!=-1;i=next[i])//这里要注意是next
          if(state[i]==st)
          {
              f[i]+=ans;
              return;
          }
        state[size]=st;
        f[size]=ans;
        next[size]=head[h];
        head[h]=size++;
    }
} hm[2];
void decode(int *code,int m,long long  st)
{
    for(int i=m;i&gt;=0;i--)
    {
        code[i]=st&amp;7;
        st&gt;&gt;=3;
    }
}
long long encode(int *code)//最小表示法
{
	static int ch[MAXD];//最小表示法使用
    int cnt=1;
    memset(ch,-1,sizeof(ch));
    ch[0]=0;
    long long st=0;
    for(int i=0;i&lt;=M;i++)
    {
        if(ch[code[i]]==-1)ch[code[i]]=cnt++;
        code[i]=ch[code[i]];
        st=st&lt;&lt;3|code[i];
    }
    return st;
}
void shift(int *code)
{
    for (int i=M;i&gt;0;i--) code[i]=code[i-1];
    code[0]=0;
}
void dpblank(int i,int j,int cur)
{
    int k,left,up;
    for(k=0;k&lt;hm[cur].size;k++)
    {
        decode(code,M,hm[cur].state[k]);
        left=code[j-1];
        up=code[j];
        if(left&amp;&amp;up)
        {
            if(left==up)//只能出现在最后一个非障碍格子 
            {
                if(i==ex&amp;&amp;j==ey)//如果不是最后一个格子，那么这个状态就是非法的 
                {
                    code[j-1]=code[j]=0;
                    if (j==M) shift(code);
                    hm[cur^1].push(encode(code),hm[cur].f[k]);
                }
            }
            else//不在同一个连通分量则合并
            {
                code[j-1]=code[j]=0;
                for(int t=0;t&lt;=M;t++)
                  if(code[t]==up)
                    code[t]=left;
                if (j==M) shift(code);
                hm[cur^1].push(encode(code),hm[cur].f[k]);
            }
        }
        else if((left&amp;&amp;(!up))||((!left)&amp;&amp;up))//保持原来的连通块 
        {
            int t=left+up;
            if(maze[i][j+1])
            {
                code[j-1]=0;
                code[j]=t;
                hm[cur^1].push(encode(code),hm[cur].f[k]);
            }
            if(maze[i+1][j])
            {
                code[j-1]=t;
                code[j]=0;
                if(j==M)shift(code);
                hm[cur^1].push(encode(code),hm[cur].f[k]);
            }
        }
        else//无插头，则构造新的连通块
        {
            if(maze[i][j+1]&amp;&amp;maze[i+1][j])
            {
                code[j-1]=code[j]=13;
                hm[cur^1].push(encode(code),hm[cur].f[k]);
            }
        }
    }
}
void dpblock(int i,int j,int cur)
{
    int k;
    for(k=0;k&lt;hm[cur].size;k++)
    {
        decode(code,M,hm[cur].state[k]);//由数学归纳法的思想，这时候一定没有插头。 
        if (j==M) shift(code);
        hm[cur^1].push(encode(code),hm[cur].f[k]);
    }
}
void init()
{
	static char str[MAXD];
    memset(maze,0,sizeof(maze));
    ex=0;
    for(int i=1;i&lt;=N;i++)
    {
        scanf(&quot;%s&quot;,str);
        for(int j=0;j&lt;M;j++)
        {
            if(str[j]=='.')
            {
                ex=i;
                ey=j+1;
                maze[i][j+1]=1;
            }
        }
    }
}
void solve()
{
    int i,j,cur=0;
    long long ans=0;
    hm[cur].init();
    hm[cur].push(0,1);
    for(i=1;i&lt;=N;i++)
      for(j=1;j&lt;=M;j++)
      {
          hm[cur^1].init();
          if (maze[i][j]) dpblank(i,j,cur);
          else dpblock(i,j,cur);
          cur^=1;
      }
    for(i=0;i&lt;hm[cur].size;i++)
      ans+=hm[cur].f[i];
    cout&lt;&lt;ans&lt;&lt;endl;
}
int main()
{
   // freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
    while(scanf(&quot;%d%d&quot;,&amp;N,&amp;M)!=EOF)
    {
        init();
        solve();
    }
    return 0;
}<pre><h2>Problem1814</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
const int MAXD=15;
int N,M;
int maze[MAXD][MAXD];
int code[MAXD];
int ex,ey;//最后一个非障碍格子的坐标
struct HASHMAP
{
	#define HASH 300007 
	#define STATE 1001111
    int head[HASH],next[STATE],size;
    long long state[STATE];
    long long f[STATE];
    void init()
    {
        size=0;
        memset(head,-1,sizeof(head));
    }
    void push(long long st,long long ans)
    {
        int i;
        int h=st%HASH;
        for(i=head[h];i!=-1;i=next[i])//这里要注意是next
          if(state[i]==st)
          {
              f[i]+=ans;
              return;
          }
        state[size]=st;
        f[size]=ans;
        next[size]=head[h];
        head[h]=size++;
    }
} hm[2];
void decode(int *code,int m,long long  st)
{
    for(int i=m;i&gt;=0;i--)
    {
        code[i]=st&amp;7;
        st&gt;&gt;=3;
    }
}
long long encode(int *code)//最小表示法
{
	static int ch[MAXD];//最小表示法使用
    int cnt=1;
    memset(ch,-1,sizeof(ch));
    ch[0]=0;
    long long st=0;
    for(int i=0;i&lt;=M;i++)
    {
        if(ch[code[i]]==-1)ch[code[i]]=cnt++;
        code[i]=ch[code[i]];
        st=st&lt;&lt;3|code[i];
    }
    return st;
}
void shift(int *code)
{
    for (int i=M;i&gt;0;i--) code[i]=code[i-1];
    code[0]=0;
}
void dpblank(int i,int j,int cur)
{
    int k,left,up;
    for(k=0;k&lt;hm[cur].size;k++)
    {
        decode(code,M,hm[cur].state[k]);
        left=code[j-1];
        up=code[j];
        if(left&amp;&amp;up)
        {
            if(left==up)//只能出现在最后一个非障碍格子 
            {
                if(i==ex&amp;&amp;j==ey)//如果不是最后一个格子，那么这个状态就是非法的 
                {
                    code[j-1]=code[j]=0;
                    if (j==M) shift(code);
                    hm[cur^1].push(encode(code),hm[cur].f[k]);
                }
            }
            else//不在同一个连通分量则合并
            {
                code[j-1]=code[j]=0;
                for(int t=0;t&lt;=M;t++)
                  if(code[t]==up)
                    code[t]=left;
                if (j==M) shift(code);
                hm[cur^1].push(encode(code),hm[cur].f[k]);
            }
        }
        else if((left&amp;&amp;(!up))||((!left)&amp;&amp;up))//保持原来的连通块 
        {
            int t=left+up;
            if(maze[i][j+1])
            {
                code[j-1]=0;
                code[j]=t;
                hm[cur^1].push(encode(code),hm[cur].f[k]);
            }
            if(maze[i+1][j])
            {
                code[j-1]=t;
                code[j]=0;
                if(j==M)shift(code);
                hm[cur^1].push(encode(code),hm[cur].f[k]);
            }
        }
        else//无插头，则构造新的连通块
        {
            if(maze[i][j+1]&amp;&amp;maze[i+1][j])
            {
                code[j-1]=code[j]=13;
                hm[cur^1].push(encode(code),hm[cur].f[k]);
            }
        }
    }
}
void dpblock(int i,int j,int cur)
{
    int k;
    for(k=0;k&lt;hm[cur].size;k++)
    {
        decode(code,M,hm[cur].state[k]);//由数学归纳法的思想，这时候一定没有插头。 
        if (j==M) shift(code);
        hm[cur^1].push(encode(code),hm[cur].f[k]);
    }
}
void init()
{
	static char str[MAXD];
    memset(maze,0,sizeof(maze));
    ex=0;
    for(int i=1;i&lt;=N;i++)
    {
        scanf(&quot;%s&quot;,str);
        for(int j=0;j&lt;M;j++)
        {
            if(str[j]=='.')
            {
                ex=i;
                ey=j+1;
                maze[i][j+1]=1;
            }
        }
    }
}
void solve()
{
    int i,j,cur=0;
    long long ans=0;
    hm[cur].init();
    hm[cur].push(0,1);
    for(i=1;i&lt;=N;i++)
      for(j=1;j&lt;=M;j++)
      {
          hm[cur^1].init();
          if (maze[i][j]) dpblank(i,j,cur);
          else dpblock(i,j,cur);
          cur^=1;
      }
    for(i=0;i&lt;hm[cur].size;i++)
      ans+=hm[cur].f[i];
    cout&lt;&lt;ans&lt;&lt;endl;
}
int main()
{
   // freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
    while(scanf(&quot;%d%d&quot;,&amp;N,&amp;M)!=EOF)
    {
        init();
        solve();
    }
    return 0;
}<pre><h2>Problem1814</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
int n,m,now,ex,ey;
bool can[15][15];
struct Hash_Table
{
	#define mo 1000007
	int o[mo+10],aa[1001111],vt[mo+10];
	int tot,TIME;
	LL f[1001111],to[1001111];
	void clear() {tot=0;TIME++;}
	void insert(LL x,LL res)
	{
		//printf(&quot;insert %I64d %I64d\n&quot;,x,res);
		int t=x%mo;
		bool flag=false;
		if (vt[t]==TIME)
			for (int p=o[t];p;p=aa[p])
				if (to[p]==x)
				{
					f[p]+=res;
					flag=true;break;
				}
		if (flag) return;
		if (vt[t]!=TIME) vt[t]=TIME,o[t]=0;
		tot++;aa[tot]=o[t];o[t]=tot;
		to[tot]=x;f[tot]=res;
	}
} C[2];
LL pack(int *a)
{
	static int dy[15];
	memset(dy,-1,sizeof(dy));
	dy[0]=0;
	int cnt=0;
	LL res=0;
	for (int i=0;i&lt;=m;i++)
	{
		if (dy[a[i]]==-1) dy[a[i]]=++cnt;
		a[i]=dy[a[i]];
		res=(res&lt;&lt;3|a[i]);
	}
	return res;
}
void repack(int *a,LL x)
{
	for (int i=m;i&gt;=0;i--)
	{
		a[i]=x&amp;7;
		x&gt;&gt;=3;
	}
}
void youyi(int *a)
{
	for (int i=m;i&gt;0;i--) a[i]=a[i-1];
	a[0]=0;
}
void work1(int i,int j)
{
	static int a[15];
	for (int p=1;p&lt;=C[now].tot;p++)
	{
		repack(a,C[now].to[p]);
		int left=a[j-1],up=a[j];
		if (left&amp;&amp;up)
		{
			if (left==up)
			{
				if (i==ex&amp;&amp;j==ey)
				{
					a[j-1]=a[j]=0;
					if (j==m) youyi(a);
					C[now^1].insert(pack(a),C[now].f[p]);
				}
			}
			else
			{
				a[j-1]=a[j]=0;
				for (int k=0;k&lt;=m;k++)
					if (a[k]==up) a[k]=left;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),C[now].f[p]);
			}
		}
		else if (left||up)
		{
			int t=left+up;
			if (can[i][j+1])
			{
				a[j-1]=0,a[j]=t;
				C[now^1].insert(pack(a),C[now].f[p]);
			}
			if (can[i+1][j])
			{
				a[j-1]=t,a[j]=0;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),C[now].f[p]);
			}
		}
		else
		{
			if (can[i+1][j]&amp;&amp;can[i][j+1])
			{
				a[j-1]=a[j]=13;
				C[now^1].insert(pack(a),C[now].f[p]);
			}
		}
	}
}
void work2(int i,int j)
{
	static int a[15];
	for (int p=1;p&lt;=C[now].tot;p++)
	{
		repack(a,C[now].to[p]);
		if (j==m) youyi(a);
		C[now^1].insert(pack(a),C[now].f[p]);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,j;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			char ch=getchar();
			while (ch!='.'&amp;&amp;ch!='*') ch=getchar();
			if (ch=='.') can[i][j]=true,ex=i,ey=j;
			else can[i][j]=false;
		}
	now=0;
	C[0].clear();
	C[0].insert(0,1);
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			//printf(&quot;\n-------------------------------- i=%d j=%d ------------------------------------\n&quot;,i,j);
			C[now^1].clear();
			if (can[i][j]) work1(i,j);
			else work2(i,j);
			now^=1;
		}
	LL ans=0;
	for (int p=1;p&lt;=C[now].tot;p++) ans+=C[now].f[p];
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem1814</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
int n,m,now,ex,ey;
bool can[15][15];
struct Hash_Table
{
	#define mo 10007
	int o[mo+10],aa[1001111],vt[mo+10];
	int tot,TIME;
	LL f[1001111],to[1001111];
	void clear() {tot=0;TIME++;}
	void insert(LL x,LL res)
	{
		int t=x%mo;
		bool flag=false;
		if (vt[t]==TIME)
			for (int p=o[t];p;p=aa[p])
				if (to[p]==x)
				{
					f[p]+=res;
					flag=true;break;
				}
		if (flag) return;
		if (vt[t]!=TIME) vt[t]=TIME,o[t]=0;
		tot++;aa[tot]=o[t];o[t]=tot;
		to[tot]=x;f[tot]=res;
	}
} C[2];
LL pack(int *a)
{
	static int dy[15];
	memset(dy,-1,sizeof(dy));
	dy[0]=0;
	int cnt=0;
	LL res=0;
	for (int i=0;i&lt;=m;i++)
	{
		if (dy[a[i]]==-1) dy[a[i]]=++cnt;
		a[i]=dy[a[i]];
		res=(res&lt;&lt;3|a[i]);
	}
	return res;
}
void repack(int *a,LL x)
{
	for (int i=m;i&gt;=0;i--)
	{
		a[i]=x&amp;7;
		x&gt;&gt;=3;
	}
}
void youyi(int *a)
{
	for (int i=m;i&gt;0;i--) a[i]=a[i-1];
	a[0]=0;
}
void work1(int i,int j)
{
	static int a[15];
	for (int p=1;p&lt;=C[now].tot;p++)
	{
		repack(a,C[now].to[p]);
		int left=a[j-1],up=a[j];
		if (left&amp;&amp;up)
		{
			if (left==up)
			{
				if (i==ex&amp;&amp;j==ey)
				{
					a[j-1]=a[j]=0;
					if (j==m) youyi(a);
					C[now^1].insert(pack(a),C[now].f[p]);
				}
			}
			else
			{
				a[j-1]=a[j]=0;
				for (int k=0;k&lt;=m;k++)
					if (a[k]==up) a[k]=left;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),C[now].f[p]);
			}
		}
		else if (left||up)
		{
			int t=left+up;
			if (can[i][j+1])
			{
				a[j-1]=0,a[j]=t;
				C[now^1].insert(pack(a),C[now].f[p]);
			}
			if (can[i+1][j])
			{
				a[j-1]=t,a[j]=0;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),C[now].f[p]);
			}
		}
		else
		{
			if (can[i+1][j]&amp;&amp;can[i][j+1])
			{
				a[j-1]=a[j]=13;
				C[now^1].insert(pack(a),C[now].f[p]);
			}
		}
	}
}
void work2(int i,int j)
{
	static int a[15];
	for (int p=1;p&lt;=C[now].tot;p++)
	{
		repack(a,C[now].to[p]);
		if (j==m) youyi(a);
		C[now^1].insert(pack(a),C[now].f[p]);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,j;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			char ch=getchar();
			while (ch!='.'&amp;&amp;ch!='*') ch=getchar();
			if (ch=='.') can[i][j]=true,ex=i,ey=j;
			else can[i][j]=false;
		}
	now=0;
	C[0].clear();
	C[0].insert(0,1);
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			C[now^1].clear();
			if (can[i][j]) work1(i,j);
			else work2(i,j);
			now^=1;
		}
	LL ans=0;
	for (int p=1;p&lt;=C[now].tot;p++) ans+=C[now].f[p];
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem1814</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
int n,m,now,ex,ey;
bool can[15][15];
struct Hash_Table
{
	#define mo 4001
	int o[mo+10],aa[1001111],vt[mo+10];
	int tot,TIME;
	LL f[1001111],to[1001111];
	void clear() {tot=0;TIME++;}
	void insert(LL x,LL res)
	{
		int t=x%mo;
		bool flag=false;
		if (vt[t]==TIME)
			for (int p=o[t];p;p=aa[p])
				if (to[p]==x)
				{
					f[p]+=res;
					flag=true;break;
				}
		if (flag) return;
		if (vt[t]!=TIME) vt[t]=TIME,o[t]=0;
		tot++;aa[tot]=o[t];o[t]=tot;
		to[tot]=x;f[tot]=res;
	}
} C[2];
LL pack(int *a)
{
	static int dy[15];
	memset(dy,-1,sizeof(dy));
	dy[0]=0;
	int cnt=0;
	LL res=0;
	for (int i=0;i&lt;=m;i++)
	{
		if (dy[a[i]]==-1) dy[a[i]]=++cnt;
		a[i]=dy[a[i]];
		res=(res&lt;&lt;3|a[i]);
	}
	return res;
}
void repack(int *a,LL x)
{
	for (int i=m;i&gt;=0;i--)
	{
		a[i]=x&amp;7;
		x&gt;&gt;=3;
	}
}
void youyi(int *a)
{
	for (int i=m;i&gt;0;i--) a[i]=a[i-1];
	a[0]=0;
}
void work1(int i,int j)
{
	static int a[15];
	for (int p=1;p&lt;=C[now].tot;p++)
	{
		repack(a,C[now].to[p]);
		int left=a[j-1],up=a[j];
		if (left&amp;&amp;up)
		{
			if (left==up)
			{
				if (i==ex&amp;&amp;j==ey)
				{
					a[j-1]=a[j]=0;
					if (j==m) youyi(a);
					C[now^1].insert(pack(a),C[now].f[p]);
				}
			}
			else
			{
				a[j-1]=a[j]=0;
				for (int k=0;k&lt;=m;k++)
					if (a[k]==up) a[k]=left;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),C[now].f[p]);
			}
		}
		else if (left||up)
		{
			int t=left+up;
			if (can[i][j+1])
			{
				a[j-1]=0,a[j]=t;
				C[now^1].insert(pack(a),C[now].f[p]);
			}
			if (can[i+1][j])
			{
				a[j-1]=t,a[j]=0;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),C[now].f[p]);
			}
		}
		else
		{
			if (can[i+1][j]&amp;&amp;can[i][j+1])
			{
				a[j-1]=a[j]=13;
				C[now^1].insert(pack(a),C[now].f[p]);
			}
		}
	}
}
void work2(int i,int j)
{
	static int a[15];
	for (int p=1;p&lt;=C[now].tot;p++)
	{
		repack(a,C[now].to[p]);
		if (j==m) youyi(a);
		C[now^1].insert(pack(a),C[now].f[p]);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,j;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			char ch=getchar();
			while (ch!='.'&amp;&amp;ch!='*') ch=getchar();
			if (ch=='.') can[i][j]=true,ex=i,ey=j;
			else can[i][j]=false;
		}
	now=0;
	C[0].clear();
	C[0].insert(0,1);
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			C[now^1].clear();
			if (can[i][j]) work1(i,j);
			else work2(i,j);
			now^=1;
		}
	LL ans=0;
	for (int p=1;p&lt;=C[now].tot;p++) ans+=C[now].f[p];
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem1814</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
int n,m,now,ex,ey;
bool can[15][15];
struct Hash_Table
{
	#define mo 4001
	int o[mo+10],aa[1001111],vt[mo+10];
	int tot,TIME;
	LL f[1001111],to[1001111];
	void clear() {tot=0;TIME++;}
	void insert(LL x,LL res)
	{
		int t=x%mo;
		bool flag=false;
		if (vt[t]==TIME)
			for (int p=o[t];p;p=aa[p])
				if (to[p]==x)
				{
					f[p]+=res;
					flag=true;break;
				}
		if (flag) return;
		if (vt[t]!=TIME) vt[t]=TIME,o[t]=0;
		tot++;aa[tot]=o[t];o[t]=tot;
		to[tot]=x;f[tot]=res;
	}
} C[2];
LL pack(int *a)
{
	static int dy[15];
	memset(dy,-1,sizeof(dy));
	dy[0]=0;
	int cnt=0;
	LL res=0;
	for (int i=0;i&lt;=m;i++)
	{
		if (dy[a[i]]==-1) dy[a[i]]=++cnt;
		a[i]=dy[a[i]];
		res=(res&lt;&lt;3|a[i]);
	}
	return res;
}
void repack(int *a,LL x)
{
	for (int i=m;i&gt;=0;i--)
	{
		a[i]=x&amp;7;
		x&gt;&gt;=3;
	}
}
void youyi(int *a)
{
	for (int i=m;i&gt;0;i--) a[i]=a[i-1];
	a[0]=0;
}
void work1(int i,int j)
{
	static int a[15];
	for (int p=1;p&lt;=C[now].tot;p++)
	{
		repack(a,C[now].to[p]);
		int left=a[j-1],up=a[j];
		if (left&amp;&amp;up)
		{
			if (left==up)
			{
				if (i==ex&amp;&amp;j==ey)
				{
					a[j-1]=a[j]=0;
					if (j==m) youyi(a);
					C[now^1].insert(pack(a),C[now].f[p]);
				}
			}
			else
			{
				a[j-1]=a[j]=0;
				for (int k=0;k&lt;=m;k++)
					if (a[k]==up) a[k]=left;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),C[now].f[p]);
			}
		}
		else if (left||up)
		{
			int t=left+up;
			if (can[i][j+1])
			{
				a[j-1]=0,a[j]=t;
				C[now^1].insert(pack(a),C[now].f[p]);
			}
			if (can[i+1][j])
			{
				a[j-1]=t,a[j]=0;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),C[now].f[p]);
			}
		}
		else
		{
			if (can[i+1][j]&amp;&amp;can[i][j+1])
			{
				a[j-1]=a[j]=13;
				C[now^1].insert(pack(a),C[now].f[p]);
			}
		}
	}
}
void work2(int i,int j)
{
	static int a[15];
	for (int p=1;p&lt;=C[now].tot;p++)
	{
		repack(a,C[now].to[p]);
		if (j==m) youyi(a);
		C[now^1].insert(pack(a),C[now].f[p]);
	}
}
int main()
{
	int i,j;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			char ch=getchar();
			while (ch!='.'&amp;&amp;ch!='*') ch=getchar();
			if (ch=='.') can[i][j]=true,ex=i,ey=j;
			else can[i][j]=false;
		}
	now=0;
	C[0].clear();
	C[0].insert(0,1);
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			C[now^1].clear();
			if (can[i][j]) work1(i,j);
			else work2(i,j);
			now^=1;
		}
	LL ans=0;
	for (int p=1;p&lt;=C[now].tot;p++) ans+=C[now].f[p];
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem1814</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;map&gt;
using namespace std;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
#define fi first
#define se second
int n,m,now,ex,ey;
bool can[15][15];
map&lt;LL,LL&gt; C[2];
map&lt;LL,LL&gt;::iterator it;
LL pack(int *a)
{
	static int dy[15];
	memset(dy,-1,sizeof(dy));
	dy[0]=0;
	int cnt=0;
	LL res=0;
	for (int i=0;i&lt;=m;i++)
	{
		if (dy[a[i]]==-1) dy[a[i]]=++cnt;
		a[i]=dy[a[i]];
		res=(res&lt;&lt;3|a[i]);
	}
	return res;
}
void repack(int *a,LL x)
{
	for (int i=m;i&gt;=0;i--)
	{
		a[i]=x&amp;7;
		x&gt;&gt;=3;
	}
}
void youyi(int *a)
{
	for (int i=m;i&gt;0;i--) a[i]=a[i-1];
	a[0]=0;
}
void work1(int i,int j)
{
	static int a[15];
	for (it=C[now].begin();it!=C[now].end();it++)
	{
		repack(a,(*it).fi);
		LL ff=(*it).se;
		int left=a[j-1],up=a[j];
		if (left&amp;&amp;up)
		{
			if (left==up)
			{
				if (i==ex&amp;&amp;j==ey)
				{
					a[j-1]=a[j]=0;
					if (j==m) youyi(a);
					C[now^1][pack(a)]+=ff;
				}
			}
			else
			{
				a[j-1]=a[j]=0;
				for (int k=0;k&lt;=m;k++)
					if (a[k]==up) a[k]=left;
				if (j==m) youyi(a);
				C[now^1][pack(a)]+=ff;
			}
		}
		else if (left||up)
		{
			int t=left+up;
			if (can[i][j+1])
			{
				a[j-1]=0,a[j]=t;
				C[now^1][pack(a)]+=ff;
			}
			if (can[i+1][j])
			{
				a[j-1]=t,a[j]=0;
				if (j==m) youyi(a);
				C[now^1][pack(a)]+=ff;
			}
		}
		else
		{
			if (can[i+1][j]&amp;&amp;can[i][j+1])
			{
				a[j-1]=a[j]=13;
				C[now^1][pack(a)]+=ff;
			}
		}
	}
}
void work2(int i,int j)
{
	static int a[15];
	for (it=C[now].begin();it!=C[now].end();it++)
	{
		repack(a,(*it).fi);
		if (j==m) youyi(a);
		C[now^1][pack(a)]+=(*it).se;
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,j;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			char ch=getchar();
			while (ch!='.'&amp;&amp;ch!='*') ch=getchar();
			if (ch=='.') can[i][j]=true,ex=i,ey=j;
			else can[i][j]=false;
		}
	now=0;
	C[0].clear();
	C[0][0]=1;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			C[now^1].clear();
			if (can[i][j]) work1(i,j);
			else work2(i,j);
			now^=1;
		}
	LL ans=0;
	for (it=C[now].begin();it!=C[now].end();it++) ans+=(*it).se;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem1814</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
int n,m,now,ex,ey;
bool can[15][15];
struct Hash_Table
{
    #define mo 10007
    int o[mo+10],aa0[1001111],tot,TIME;
    LL f[1001111],aa1[1001111];
    void clear()
    {
    	tot=0;
    	memset(o,0,sizeof(o));
    }
    void insert(LL X,LL res)
    {
        int t=X%mo;
        for (int p=o[t];p;p=aa0[p])
        	if (aa1[p]==X)
        	{
        		f[p]+=res;
        		return;
        	}
        tot++;aa1[tot]=X;aa0[tot]=o[t];
        o[t]=tot;f[tot]=res;
    }
} C[2];
LL pack(int *a)
{
    static int dy[15];
    memset(dy,-1,sizeof(dy));
    dy[0]=0;
    int cnt=0;
    LL res=0;
    for (int i=0;i&lt;=m;i++)
    {
        if (dy[a[i]]==-1) dy[a[i]]=++cnt;
        a[i]=dy[a[i]];
        res=(res&lt;&lt;3|a[i]);
    }
    return res;
}
void repack(int *a,LL x)
{
    for (int i=m;i&gt;=0;i--)
    {
        a[i]=x&amp;7;
        x&gt;&gt;=3;
    }
}
void youyi(int *a)
{
    for (int i=m;i&gt;0;i--) a[i]=a[i-1];
    a[0]=0;
}
void work1(int i,int j)
{
    static int a[15];
    for (int p=1;p&lt;=C[now].tot;p++)
    {
        repack(a,C[now].aa1[p]);
        int left=a[j-1],up=a[j];
        if (left&amp;&amp;up)
        {
            if (left==up)
            {
                if (i==ex&amp;&amp;j==ey)
                {
                    a[j-1]=a[j]=0;
                    if (j==m) youyi(a);
                    C[now^1].insert(pack(a),C[now].f[p]);
                }
            }
            else
            {
                a[j-1]=a[j]=0;
                for (int k=0;k&lt;=m;k++)
                    if (a[k]==up) a[k]=left;
                if (j==m) youyi(a);
                C[now^1].insert(pack(a),C[now].f[p]);
            }
        }
        else if (left||up)
        {
            int t=left+up;
            if (can[i][j+1])
            {
                a[j-1]=0,a[j]=t;
                C[now^1].insert(pack(a),C[now].f[p]);
            }
            if (can[i+1][j])
            {
                a[j-1]=t,a[j]=0;
                if (j==m) youyi(a);
                C[now^1].insert(pack(a),C[now].f[p]);
            }
        }
        else
        {
            if (can[i+1][j]&amp;&amp;can[i][j+1])
            {
                a[j-1]=a[j]=13;
                C[now^1].insert(pack(a),C[now].f[p]);
            }
        }
    }
}
void work2(int i,int j)
{
    static int a[15];
    for (int p=1;p&lt;=C[now].tot;p++)
    {
        repack(a,C[now].aa1[p]);
        if (j==m) youyi(a);
        C[now^1].insert(pack(a),C[now].f[p]);
    }
}
int main()
{
    int i,j;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for (i=1;i&lt;=n;i++)
        for (j=1;j&lt;=m;j++)
        {
            char ch=getchar();
            while (ch!='.'&amp;&amp;ch!='*') ch=getchar();
            if (ch=='.') can[i][j]=true,ex=i,ey=j;
            else can[i][j]=false;
        }
    now=0;
    C[0].clear();
    C[0].insert(0,1);
    for (i=1;i&lt;=n;i++)
        for (j=1;j&lt;=m;j++)
        {
            C[now^1].clear();
            if (can[i][j]) work1(i,j);
            else work2(i,j);
            now^=1;
        }
    LL ans=0;
    for (int p=1;p&lt;=C[now].tot;p++) ans+=C[now].f[p];
    printf(&quot;%lld\n&quot;,ans);
    return 0;
}<pre><h2>Problem1814</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
int n,m,now,ex,ey;
bool can[15][15];
struct Hash_Table//hash表存储状态 
{
    #define mo 10007
    int o[mo+10],aa0[1001111],tot,TIME;
    LL f[1001111],aa1[1001111];
    void clear()
    {
    	tot=0;
    	memset(o,0,sizeof(o));
    }
    void insert(LL X,LL res)//X是压缩后的状态，res是dp值(方案数) 
    {
        int t=X%mo;
        for (int p=o[t];p;p=aa0[p])
        	if (aa1[p]==X)
        	{
        		f[p]+=res;
        		return;
        	}
        tot++;aa1[tot]=X;aa0[tot]=o[t];
        o[t]=tot;f[tot]=res;
    }
} C[2];
LL pack(int *a)//状态压缩，首先把a变成最小表示，然后用8进制 
{
    static int dy[15];
    memset(dy,-1,sizeof(dy));
    dy[0]=0;
    int cnt=0;
    LL res=0;
    for (int i=0;i&lt;=m;i++)
    {
        if (dy[a[i]]==-1) dy[a[i]]=++cnt;
        a[i]=dy[a[i]];
        res=(res&lt;&lt;3|a[i]);//位运算优化，速度快 
    }
    return res;
}
void repack(int *a,LL x)//把压缩的状态拆开 
{
    for (int i=m;i&gt;=0;i--)
    {
        a[i]=x&amp;7;
        x&gt;&gt;=3;
    }
}
void youyi(int *a)//如果j==m，那么下次就换行了，需要把这一行的插头整体右移 
{
    for (int i=m;i&gt;0;i--) a[i]=a[i-1];
    a[0]=0;
}
void work1(int i,int j)//处理无障碍的格子 
{
    static int a[15];
    for (int p=1;p&lt;=C[now].tot;p++)//枚举now的每一个状态扩展新状态 
    {
        repack(a,C[now].aa1[p]);
        int left=a[j-1],up=a[j];//左边和上边插头的编号 
        if (left&amp;&amp;up)//都有插头，合并两个插头 
        {
            if (left==up)//这时候如果合并了就形成了一个回路 
            {
                if (i==ex&amp;&amp;j==ey)//形成回路必须是最后一个非障碍格子 
                {
                    a[j-1]=a[j]=0;
                    if (j==m) youyi(a);//如果j==m就得换行，右移，下同 
                    C[now^1].insert(pack(a),C[now].f[p]);
                }
            }
            else//合并两个插头 
            {
                a[j-1]=a[j]=0;
                for (int k=0;k&lt;=m;k++)
                    if (a[k]==up) a[k]=left;
                if (j==m) youyi(a);
                C[now^1].insert(pack(a),C[now].f[p]);
            }
        }
        else if (left||up)//只有一个插头，保持原来的插头不变 
        {
            int t=left+up;
            if (can[i][j+1])//新插头为右插头 
            {
                a[j-1]=0,a[j]=t;
                C[now^1].insert(pack(a),C[now].f[p]);
            }
            if (can[i+1][j])//新插头为左插头 
            {
                a[j-1]=t,a[j]=0;
                if (j==m) youyi(a);
                C[now^1].insert(pack(a),C[now].f[p]);
            }
        }
        else//没有任何插头，需要新建一个右插头和一个下插头 
        {
            if (can[i+1][j]&amp;&amp;can[i][j+1])
            {
                a[j-1]=a[j]=13;//先把这两个联通的插头赋值为一个从未出现过的数，然后再最小表示 
                C[now^1].insert(pack(a),C[now].f[p]);
            }
        }
    }
}
void work2(int i,int j)//处理障碍格子 
{
    static int a[15];
    for (int p=1;p&lt;=C[now].tot;p++)
    {
        repack(a,C[now].aa1[p]);
        if (j==m) youyi(a);
        //因为转移的过程中判了，所以这时候一定没有左插头和上插头 
        C[now^1].insert(pack(a),C[now].f[p]);
    }
}
int main()
{
    int i,j;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for (i=1;i&lt;=n;i++)
        for (j=1;j&lt;=m;j++)
        {
            char ch=getchar();
            while (ch!='.'&amp;&amp;ch!='*') ch=getchar();
            if (ch=='.') can[i][j]=true,ex=i,ey=j;
            else can[i][j]=false;
        }
    now=0;
    C[0].clear();
    C[0].insert(0,1);
    for (i=1;i&lt;=n;i++)
        for (j=1;j&lt;=m;j++)
        {
            C[now^1].clear();
            if (can[i][j]) work1(i,j);
            else work2(i,j);
            now^=1;
        }
    LL ans=0;
    for (int p=1;p&lt;=C[now].tot;p++) ans+=C[now].f[p];//最后的每一个状态一定合法，因为数学归纳法。 
    printf(&quot;%lld\n&quot;,ans);
    return 0;
}<pre><h2>Problem1814</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
int n,m,now,ex,ey;
bool can[15][15];
struct Hash_Table//hash表存储状态 
{
    #define mo 10007
    int o[mo+10],aa0[1001111],tot,TIME;
    LL f[1001111],aa1[1001111];
    void clear()
    {
    	tot=0;
    	memset(o,0,sizeof(o));
    }
    void insert(LL X,LL res)//X是压缩后的状态，res是dp值(方案数) 
    {
        int t=X%mo;
        for (int p=o[t];p;p=aa0[p])
        	if (aa1[p]==X)
        	{
        		f[p]+=res;
        		return;
        	}
        tot++;aa1[tot]=X;aa0[tot]=o[t];
        o[t]=tot;f[tot]=res;
    }
} C[2];
LL pack(int *a)//状态压缩，首先把a变成最小表示，然后用8进制 
{
    static int dy[15];
    memset(dy,-1,sizeof(dy));
    dy[0]=0;
    int cnt=0;
    LL res=0;
    for (int i=0;i&lt;=m;i++)
    {
        if (dy[a[i]]==-1) dy[a[i]]=++cnt;
        a[i]=dy[a[i]];
        res=(res&lt;&lt;3|a[i]);//位运算优化，速度快 
    }
    return res;
}
void repack(int *a,LL x)//把压缩的状态拆开 
{
    for (int i=m;i&gt;=0;i--)
    {
        a[i]=x&amp;7;
        x&gt;&gt;=3;
    }
}
void youyi(int *a)//如果j==m，那么下次就换行了，需要把这一行的插头整体右移 
{
    for (int i=m;i&gt;0;i--) a[i]=a[i-1];
    a[0]=0;
}
void work1(int i,int j)//处理无障碍的格子 
{
    static int a[15];
    for (int p=1;p&lt;=C[now].tot;p++)//枚举now的每一个状态扩展新状态 
    {
        repack(a,C[now].aa1[p]);
        int left=a[j-1],up=a[j];//左边和上边插头的编号 
        if (left&amp;&amp;up)//都有插头，合并两个插头 
        {
            if (left==up)//这时候如果合并了就形成了一个回路 
            {
                if (i==ex&amp;&amp;j==ey)//形成回路必须是最后一个非障碍格子 
                {
                    a[j-1]=a[j]=0;
                    if (j==m) youyi(a);//如果j==m就得换行，右移，下同 
                    C[now^1].insert(pack(a),C[now].f[p]);
                }
            }
            else//合并两个插头 
            {
                a[j-1]=a[j]=0;
                for (int k=0;k&lt;=m;k++)
                    if (a[k]==up) a[k]=left;
                if (j==m) youyi(a);
                C[now^1].insert(pack(a),C[now].f[p]);
            }
        }
        else if (left||up)//只有一个插头，保持原来的插头不变 
        {
            int t=left+up;
            if (can[i][j+1])//新插头为右插头 
            {
                a[j-1]=0,a[j]=t;
                C[now^1].insert(pack(a),C[now].f[p]);
            }
            if (can[i+1][j])//新插头为左插头 
            {
                a[j-1]=t,a[j]=0;
                if (j==m) youyi(a);
                C[now^1].insert(pack(a),C[now].f[p]);
            }
        }
        else//没有任何插头，需要新建一个右插头和一个下插头 
        {
            if (can[i+1][j]&amp;&amp;can[i][j+1])
            {
                a[j-1]=a[j]=7;//先把这两个联通的插头赋值为一个从未出现过的数，然后再最小表示 
                C[now^1].insert(pack(a),C[now].f[p]);
            }
        }
    }
}
void work2(int i,int j)//处理障碍格子 
{
    static int a[15];
    for (int p=1;p&lt;=C[now].tot;p++)
    {
        repack(a,C[now].aa1[p]);
        if (j==m) youyi(a);
        //因为转移的过程中判了，所以这时候一定没有左插头和上插头 
        C[now^1].insert(pack(a),C[now].f[p]);
    }
}
int main()
{
    int i,j;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for (i=1;i&lt;=n;i++)
        for (j=1;j&lt;=m;j++)
        {
            char ch=getchar();
            while (ch!='.'&amp;&amp;ch!='*') ch=getchar();
            if (ch=='.') can[i][j]=true,ex=i,ey=j;
            else can[i][j]=false;
        }
    now=0;
    C[0].clear();
    C[0].insert(0,1);
    for (i=1;i&lt;=n;i++)
        for (j=1;j&lt;=m;j++)
        {
            C[now^1].clear();
            if (can[i][j]) work1(i,j);
            else work2(i,j);
            now^=1;
        }
    LL ans=0;
    for (int p=1;p&lt;=C[now].tot;p++) ans+=C[now].f[p];//最后的每一个状态一定合法，因为数学归纳法。 
    printf(&quot;%lld\n&quot;,ans);
    return 0;
}<pre><h2>Problem1814</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
int n,m,now,ex,ey;
bool can[15][15];
inline LL pack(int *a)
{
	static int dy[15];
	int i,cnt=0;LL res=0;
	for (i=0;i&lt;=7;i++) dy[i]=-1;
	dy[0]=0;
	for (i=0;i&lt;=m;i++)
	{
		if (dy[a[i]]==-1) dy[a[i]]=++cnt;
		a[i]=dy[a[i]];
		res=(res&lt;&lt;3|a[i]);
	}
	return res;
}
inline void repack(int *a,LL X)
{
	for (int i=m;i&gt;=0;i--)
		a[i]=X&amp;7,X&gt;&gt;=3;
}
inline void youyi(int *a)
{
	for (int i=m;i&gt;0;i--) a[i]=a[i-1];
	a[0]=0;
}
struct HT
{
	#define mod 100007
	int o[mod],vt[mod],TIME,tot,aa0[1000000];
	LL aa1[1000000],f[1000000];
	inline void clear() {TIME++;tot=0;}
	inline void insert(LL X,LL Y)
	{
		//static int a[15];repack(a,X);printf(&quot;  insert &quot;);for(int i=0;i&lt;=m;i++)printf(&quot;%d &quot;,a[i]);printf(&quot;  ff=%I64d\n&quot;,Y);
		int t=X%mod;
		if (vt[t]!=TIME)
			vt[t]=TIME,o[t]=0;
		for (int p=o[t];p;p=aa0[p])
			if (aa1[p]==X)
			{
				f[p]+=Y;
				return;
			}
		tot++;aa1[tot]=X;f[tot]=Y;
		aa0[tot]=o[t];o[t]=tot;
	}
} C[2];
void work1(int i,int j)
{
	//printf(&quot;\n-------------------------------- i=%d j=%d now=%d---------------------------------\n&quot;,i,j,now);
	static int a[15];
	for (int p=1;p&lt;=C[now].tot;p++)
	{
		LL X=C[now].aa1[p],ff=C[now].f[p];
		repack(a,X);
		//printf(&quot;a &quot;);for(int k=0;k&lt;=m;k++)printf(&quot;%d &quot;,a[k]);printf(&quot;  ff=%I64d\n&quot;,ff);
		int left=a[j-1],up=a[j];
		if (left&amp;&amp;up)
		{
			if (left==up)
			{
				if (i==ex&amp;&amp;j==ey)
				{
					a[j-1]=a[j]=0;
					if (j==m) youyi(a);
					C[now^1].insert(pack(a),ff);
				}
			}
			else
			{
				a[j-1]=a[j]=0;
				for (int k=0;k&lt;=m;k++)
					if (a[k]==left) a[k]=up;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),ff);
			}
		}
		else if (left||up)
		{
			if (can[i][j+1])
			{
				a[j-1]=0,a[j]=left|up;
				C[now^1].insert(pack(a),ff);
			}
			if (can[i+1][j])
			{
				a[j-1]=left|up,a[j]=0;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),ff);
			}
		}
		else
		{
			if (can[i][j+1]&amp;&amp;can[i+1][j])
			{
				a[j-1]=a[j]=7;
				C[now^1].insert(pack(a),ff);
			}
		}
	}
}
void work2(int i,int j)
{
	//printf(&quot;\n-------------------------------- i=%d j=%d ---------------------------------\n&quot;,i,j);
	static int a[15];
	for (int p=1;p&lt;=C[now].tot;p++)
	{
		LL X=C[now].aa1[p],ff=C[now].f[p];
		repack(a,X);
		int left=a[j-1],up=a[j];
		if (left||up) continue;
		if (j==m) youyi(a);
		C[now^1].insert(pack(a),ff);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j;
	for (i=1;i&lt;=n;i++) for (j=1;j&lt;=m;j++)
	{
		char ch=getchar();
		while (ch!='*'&amp;&amp;ch!='.') ch=getchar();
		can[i][j]=(ch=='.');
		if (can[i][j]) ex=i,ey=j;
	}
	now=0;
	C[now].insert(0,1);
	for (i=1;i&lt;=n;i++) for (j=1;j&lt;=m;j++)
	{
		C[now^1].clear();
		if (can[i][j]) work1(i,j);
		else work2(i,j);
		now^=1;
	}
	LL ans=0;
	for (int p=1;p&lt;=C[now].tot;p++)
		ans+=C[now].f[p];
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem1814</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
int n,m,now,ex,ey;
bool can[15][15];
inline LL pack(int *a)
{
	static int dy[15];
	int i,cnt=0;LL res=0;
	for (i=0;i&lt;=7;i++) dy[i]=-1;
	dy[0]=0;
	for (i=0;i&lt;=m;i++)
	{
		if (dy[a[i]]==-1) dy[a[i]]=++cnt;
		a[i]=dy[a[i]];
		res=(res&lt;&lt;3|a[i]);
	}
	return res;
}
inline void repack(int *a,LL X)
{
	for (int i=m;i&gt;=0;i--)
		a[i]=X&amp;7,X&gt;&gt;=3;
}
inline void youyi(int *a)
{
	for (int i=m;i&gt;0;i--) a[i]=a[i-1];
	a[0]=0;
}
struct HT
{
	#define mod 100007
	int o[mod],vt[mod],TIME,tot,aa0[1000000];
	LL aa1[1000000],f[1000000];
	inline void clear() {TIME++;tot=0;}
	inline void insert(LL X,LL Y)
	{
		int t=X%mod;
		if (vt[t]!=TIME)
			vt[t]=TIME,o[t]=0;
		for (int p=o[t];p;p=aa0[p])
			if (aa1[p]==X)
			{
				f[p]+=Y;
				return;
			}
		tot++;aa1[tot]=X;f[tot]=Y;
		aa0[tot]=o[t];o[t]=tot;
	}
} C[2];
void work1(int i,int j)
{
	static int a[15];
	for (int p=1;p&lt;=C[now].tot;p++)
	{
		LL X=C[now].aa1[p],ff=C[now].f[p];
		repack(a,X);
		int left=a[j-1],up=a[j];
		if (left&amp;&amp;up)
		{
			if (left==up)
			{
				if (i==ex&amp;&amp;j==ey)
				{
					a[j-1]=a[j]=0;
					if (j==m) youyi(a);
					C[now^1].insert(pack(a),ff);
				}
			}
			else
			{
				a[j-1]=a[j]=0;
				for (int k=0;k&lt;=m;k++)
					if (a[k]==left) a[k]=up;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),ff);
			}
		}
		else if (left||up)
		{
			if (can[i][j+1])
			{
				a[j-1]=0,a[j]=left|up;
				C[now^1].insert(pack(a),ff);
			}
			if (can[i+1][j])
			{
				a[j-1]=left|up,a[j]=0;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),ff);
			}
		}
		else
		{
			if (can[i][j+1]&amp;&amp;can[i+1][j])
			{
				a[j-1]=a[j]=7;
				C[now^1].insert(pack(a),ff);
			}
		}
	}
}
void work2(int i,int j)
{
	static int a[15];
	for (int p=1;p&lt;=C[now].tot;p++)
	{
		LL X=C[now].aa1[p],ff=C[now].f[p];
		repack(a,X);
		int left=a[j-1],up=a[j];
		if (left||up) continue;
		if (j==m) youyi(a);
		C[now^1].insert(pack(a),ff);
	}
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j;
	for (i=1;i&lt;=n;i++) for (j=1;j&lt;=m;j++)
	{
		char ch=getchar();
		while (ch!='*'&amp;&amp;ch!='.') ch=getchar();
		can[i][j]=(ch=='.');
		if (can[i][j]) ex=i,ey=j;
	}
	now=0;
	C[now].insert(0,1);
	for (i=1;i&lt;=n;i++) for (j=1;j&lt;=m;j++)
	{
		C[now^1].clear();
		if (can[i][j]) work1(i,j);
		else work2(i,j);
		now^=1;
	}
	LL ans=0;
	for (int p=1;p&lt;=C[now].tot;p++)
		ans+=C[now].f[p];
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem1818</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long LL;
typedef pair&lt;int,int&gt; pii;
typedef pair&lt;int,pii&gt; pip;
#define mp make_pair
#define fi first
#define se second
const int NN=101111;
int n,m,cnt,Q,b[NN*3],c[NN*3];
pii D[NN];
pip ask[NN],q[NN];
struct ppt
{
	int pos,l,r;
	ppt (int a=0,int b=0,int c=0) {pos=a;l=b;r=c;}
	friend bool operator &lt;(ppt a,ppt b) {return a.r&gt;b.r;}
};
priority_queue&lt;ppt&gt; dui;
inline bool cmp1(const pii &amp;a,const pii &amp;b)
{
	if (a.fi!=b.fi) return a.fi&lt;b.fi;
	return a.se&lt;b.se;
}
inline bool cmp2(const pii &amp;a,const pii &amp;b)
{
	if (a.se!=b.se) return a.se&lt;b.se;
	return a.fi&lt;b.fi;
}
inline bool cmp3(const pip &amp;a,const pip &amp;b)
{
	return a.se.fi&lt;b.se.fi;
}
inline bool cmp4(const pip &amp;a,const pip &amp;b)
{
	return a.fi&lt;b.fi;
}
inline int cha(int x)
{
	int l=1,r=cnt;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (b[mid]==x) return mid;
		if (x&lt;b[mid]) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
inline void change(int i,int x)
{
	for (;i&lt;=cnt;i+=i&amp;-i) c[i]+=x;
}
inline int getsum(int i)
{
	int res=0;
	for (;i;i-=i&amp;-i) res+=c[i];
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;D[i].fi,&amp;D[i].se);
	cnt=0;
	sort(D+1,D+n+1,cmp1);
	for (i=1;i&lt;n;i++)
		if (D[i].fi==D[i+1].fi&amp;&amp;D[i+1].se&gt;D[i].se+1)
		{
			ask[++Q]=mp(D[i].fi,mp(D[i].se+1,D[i+1].se-1));
			b[++cnt]=D[i].se+1,b[++cnt]=D[i+1].se-1;
		}
	sort(D+1,D+n+1,cmp2);
	for (i=1;i&lt;n;i++)
		if (D[i].se==D[i+1].se&amp;&amp;D[i+1].fi&gt;D[i].fi+1)
		{
			q[++m]=mp(D[i].se,mp(D[i].fi+1,D[i+1].fi-1));
			b[++cnt]=D[i].se;
		}
	sort(b+1,b+cnt+1);
	cnt=unique(b+1,b+cnt+1)-(b+1);
	for (i=1;i&lt;=Q;i++)
	{
		ask[i].se.fi=cha(ask[i].se.fi);
		ask[i].se.se=cha(ask[i].se.se);
	}
	for (i=1;i&lt;=m;i++) q[i].fi=cha(q[i].fi);
	sort(q+1,q+m+1,cmp3);
	sort(ask+1,ask+Q+1,cmp4);
	LL ans=0;
	for (i=1,j=1;i&lt;=Q;i++)
	{
		for (;q[j].se.fi&lt;=ask[i].fi&amp;&amp;j&lt;=m;j++)
		{
			change(q[j].fi,1);
			dui.push(ppt(q[j].fi,q[j].se.fi,q[j].se.se));
		}
		while (!dui.empty()&amp;&amp;dui.top().r&lt;ask[i].fi)
		{
			change(dui.top().pos,-1);
			dui.pop();
		}
		ans+=getsum(ask[i].se.se)-getsum(ask[i].se.fi-1);
	}
	printf(&quot;%lld\n&quot;,ans+n);
	return 0;
}<pre><h2>Problem1823</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
#define mii(a,b) ((a)&lt;(b)?(a):(b))
int dfn[100000],low[100000],belong[100000],sta[100000],o[101111],aa[1000000][2],fa[100000];
int n,m,tot,TIME,top,scc,tes;
bool vt[100000];
void dfs(int v)
{
	vt[v]=true;
	dfn[v]=low[v]=++TIME;
	sta[++top]=v;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		if (!vt[y])
		{
			fa[y]=v;
			dfs(y);
			low[v]=mii(low[v],low[y]);
		}
		else if (belong[y]==0) low[v]=mii(low[v],dfn[y]);
	}
	if (low[v]==dfn[v])
	{
		scc++;
		for (int x=0;x!=v;top--)
		{
			x=sta[top];
			belong[x]=scc;
		}
	}
}
void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes--;)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		memset(o,0,sizeof(o));
		tot=1;
		int i,x,y;
		for (i=1;i&lt;=m;i++)
		{
			char ch1=getchar();
			while (ch1!='m'&amp;&amp;ch1!='h') ch1=getchar();
			scanf(&quot;%d&quot;,&amp;x);
			char ch2=getchar();
			while (ch2!='m'&amp;&amp;ch2!='h') ch2=getchar();
			scanf(&quot;%d&quot;,&amp;y);
			if (ch1=='m'&amp;&amp;ch2=='m') addedge(x+n,y),addedge(y+n,x);
			else if (ch1=='h'&amp;&amp;ch2=='h') addedge(x,y+n),addedge(y,x+n);
			else if (ch1=='m') addedge(x+n,y+n),addedge(y,x);
			else addedge(x,y),addedge(y+n,x+n);
		}
		scc=0;
		memset(vt,0,sizeof(vt));
		memset(belong,0,sizeof(belong));
		memset(fa,0,sizeof(fa));
		TIME=0;top=0;
		for (i=1;i&lt;=n+n;i++)
			if (!vt[i]) dfs(i);
		bool flag=true;
		for (i=1;i&lt;=n;i++)
			if (belong[i]==belong[i+n]) flag=false;
		printf(flag?&quot;GOOD\n&quot;:&quot;BAD\n&quot;);
	}
	return 0;
}
<pre><h2>Problem1833</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define LL long long
LL ans[1000],f[20][20][20],mi[20],bb[3000],a[1000],L,R,i,j,k,l;
void calc(LL n)
{
	LL i,tmp,j,k;
	for (i=0;i&lt;=9;i++) ans[i]=0;
	if (n==0) {ans[0]=1;return;}
	memset(a,0,sizeof(a));
	for (tmp=n;tmp;tmp/=10) a[++a[0]]=tmp%10;
	//printf(&quot;a[0]=%lld\n&quot;,a[0]);
	ans[0]=1;
	//printf(&quot;calcing...  &quot;);for (i=0;i&lt;=9;i++) printf(&quot;%lld &quot;,ans[i]);printf(&quot;\n&quot;);
	for (i=1;i&lt;a[0];i++)
		for (j=1;j&lt;=9;j++)
			for (k=0;k&lt;=9;k++) ans[k]+=f[i][j][k];
	//printf(&quot;calcing...  &quot;);for (i=0;i&lt;=9;i++) printf(&quot;%lld &quot;,ans[i]);printf(&quot;\n&quot;);
	for (i=1;i&lt;a[a[0]];i++)
		for (k=0;k&lt;=9;k++) ans[k]+=f[a[0]][i][k];
	//printf(&quot;calcing...  &quot;);for (i=0;i&lt;=9;i++) printf(&quot;%lld &quot;,ans[i]);printf(&quot;\n&quot;);
	ans[a[a[0]]]+=(n%mi[a[0]])+1;
	//printf(&quot;calcing...  &quot;);for (i=0;i&lt;=9;i++) printf(&quot;%lld &quot;,ans[i]);printf(&quot;\n&quot;);
	for (tmp=n,i=a[0]-1;i;i--)
	{
		tmp%=mi[i];
		for (j=0;j&lt;a[i];j++)
			for (k=0;k&lt;=9;k++) ans[k]+=f[i][j][k];
		ans[a[i]]+=tmp+1;
	}
	//printf(&quot;calcing...  &quot;);for (i=0;i&lt;=9;i++) printf(&quot;%lld &quot;,ans[i]);printf(&quot;\n&quot;);
}
int main()
{
   // freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);//freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%lld%lld&quot;,&amp;L,&amp;R);
    mi[1]=1;
    for (i=2;i&lt;=12;i++) mi[i]=mi[i-1]*10;
	memset(f,0,sizeof(f));
    for (i=0;i&lt;=9;i++) f[1][i][i]=1;
    for (i=2;i&lt;=12;i++)
		for (j=0;j&lt;=9;j++)
		{
			for (k=0;k&lt;=9;k++)
				for (l=0;l&lt;=9;l++)
					f[i][j][k]+=f[i-1][l][k];
			f[i][j][j]+=mi[i];
			//for (k=0;k&lt;=9;k++) printf(&quot;%lld %lld %lld %lld\n&quot;,i,j,k,f[i][j][k]);
		}
	//printf(&quot;\n--------------------------------------------------------\n&quot;);
    calc(R);
	for (i=0;i&lt;=9;i++) bb[i]=ans[i];
	//for (i=0;i&lt;=9;i++) printf(&quot;%lld &quot;,bb[i]);printf(&quot;\n&quot;);
	//printf(&quot;\n\n--------------------------------------------------------\n&quot;);
	calc(L-1);
	for (i=0;i&lt;=9;i++)
	{
		ans[i]=bb[i]-ans[i];
		if (i!=9) printf(&quot;%lld &quot;,ans[i]);
		else printf(&quot;%lld&quot;,ans[i]);
	}
	//freopen(&quot;CON&quot;,&quot;r&quot;,stdin);getchar();
    return 0;
}
<pre><h2>Problem1833</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define LL long long
LL ans[1000],f[20][20][20],mi[20],bb[3000],a[1000],L,R,i,j,k,l;
void calc(LL n)
{
	LL i,tmp,j,k;
	for (i=0;i&lt;=9;i++) ans[i]=0;
	if (n==0) {ans[0]=1;return;}
	memset(a,0,sizeof(a));
	for (tmp=n;tmp;tmp/=10) a[++a[0]]=tmp%10;
	ans[0]=1;
	for (i=1;i&lt;a[0];i++)
		for (j=1;j&lt;=9;j++)
			for (k=0;k&lt;=9;k++) ans[k]+=f[i][j][k];
	for (i=1;i&lt;a[a[0]];i++)
		for (k=0;k&lt;=9;k++) ans[k]+=f[a[0]][i][k];
	ans[a[a[0]]]+=(n%mi[a[0]])+1;
	for (i=a[0]-1;i;i--)
	{
		for (j=0;j&lt;a[i];j++)
			for (k=0;k&lt;=9;k++) ans[k]+=f[i][j][k];
		ans[a[i]]+=n%mi[i]+1;
	}
}
int main()
{
    scanf(&quot;%lld%lld&quot;,&amp;L,&amp;R);
    mi[1]=1;
    for (i=2;i&lt;=12;i++) mi[i]=mi[i-1]*10;
	memset(f,0,sizeof(f));
    for (i=0;i&lt;=9;i++) f[1][i][i]=1;
    for (i=2;i&lt;=12;i++)
		for (j=0;j&lt;=9;j++)
		{
			for (k=0;k&lt;=9;k++)
				for (l=0;l&lt;=9;l++)
					f[i][j][k]+=f[i-1][l][k];
			f[i][j][j]+=mi[i];
		}
    calc(R);
	for (i=0;i&lt;=9;i++) bb[i]=ans[i];
	calc(L-1);
	for (i=0;i&lt;=9;i++)
	{
		ans[i]=bb[i]-ans[i];
		if (i!=9) printf(&quot;%lld &quot;,ans[i]);
		else printf(&quot;%lld&quot;,ans[i]);
	}
    return 0;
}
<pre><h2>Problem1833</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define LL long long
LL ans[1000],f[20][20][20],mi[20],bb[3000],a[1000],L,R,i,j,k,l;
void calc(LL n)
{
	LL i,tmp,j,k;
	for (i=0;i&lt;=9;i++) ans[i]=0;
	if (n==0) {ans[0]=1;return;}
	memset(a,0,sizeof(a));
	for (tmp=n;tmp;tmp/=10) a[++a[0]]=tmp%10;
	ans[0]=1;
	for (i=1;i&lt;a[0];i++)
		for (j=1;j&lt;=9;j++)
			for (k=0;k&lt;=9;k++) ans[k]+=f[i][j][k];
	for (i=1;i&lt;a[a[0]];i++)
		for (k=0;k&lt;=9;k++) ans[k]+=f[a[0]][i][k];
	ans[a[a[0]]]+=(n%mi[a[0]-1])+1;
	for (i=a[0]-1;i;i--)
	{
		for (j=0;j&lt;a[i];j++)
			for (k=0;k&lt;=9;k++) ans[k]+=f[i][j][k];
		ans[a[i]]+=n%mi[i-1]+1;
	}
}
int main()
{
   // freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);//freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%lld%lld&quot;,&amp;L,&amp;R);
    mi[0]=1;
    for (i=1;i&lt;=12;i++) mi[i]=mi[i-1]*10;
	memset(f,0,sizeof(f));
    for (i=0;i&lt;=9;i++) f[1][i][i]=1;
    for (i=2;i&lt;=12;i++)
		for (j=0;j&lt;=9;j++)
		{
			for (k=0;k&lt;=9;k++)
				for (l=0;l&lt;=9;l++)
					f[i][j][k]+=f[i-1][l][k];
			f[i][j][j]+=mi[i-1];
		}
    calc(R);
	for (i=0;i&lt;=9;i++) bb[i]=ans[i];
	calc(L-1);
	for (i=0;i&lt;=9;i++)
	{
		ans[i]=bb[i]-ans[i];
		if (i!=9) printf(&quot;%lld &quot;,ans[i]);
		else printf(&quot;%lld&quot;,ans[i]);
	}
    return 0;
}
<pre><h2>Problem1834</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
const int NN=10111,MM=50111;
int o[NN],aa[MM&lt;&lt;3][4],pre[NN];
int n,m,K,tot=1,S,T,flow,ans;
struct edge
{
	int u,v,C,W;
} e[MM];
inline void addedge(int p,int q,int v,int c)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][3]=c;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline void add(int p,int q,int v,int c)
{
	addedge(p,q,v,c);
	addedge(q,p,0,-c);
}
bool spfa()
{
	static int que[NN+11],dist[NN];
	static bool dl[NN];
	memset(dist,60,sizeof(dist));
	dist[S]=0;
	memset(dl,0,sizeof(dl));
	int head=0,tail=1;
	que[1]=S;
	dl[1]=true;
	while (head!=tail)
	{
		head++;if (head&gt;NN) head=1;
		int x=que[head];
		dl[x]=false;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;dist[y]&gt;dist[x]+aa[p][3])
			{
				dist[y]=dist[x]+aa[p][3];
				pre[y]=p;
				if (!dl[y])
				{
					tail++;if (tail&gt;NN) tail=1;
					que[tail]=y;
				}
			}
		}
	}
	return dist[T]&lt;dist[0];
}
void calc()
{
	int ff=inf,p;
	for (p=pre[T];p;p=pre[aa[p^1][1]])
		ff=min(ff,aa[p][2]);
	flow+=ff;
	for (p=pre[T];p;p=pre[aa[p^1][1]])
	{
		ans+=ff*aa[p][3];
		aa[p][2]-=ff,aa[p^1][2]+=ff;
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;K);
	int i;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].C,&amp;e[i].W);
		add(e[i].u,e[i].v,e[i].C,0);
	}
	S=1,T=n;
	flow=0;
	while (spfa()) calc();
	printf(&quot;%d &quot;,flow);
	T=n+1;
	add(n,T,K,0);
	for (i=1;i&lt;=m;i++)
		add(e[i].u,e[i].v,inf,e[i].W);
	ans=0;
	while (spfa()) calc();
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1834</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
const int NN=10111,MM=5111;
int o[NN],aa[MM&lt;&lt;3][4],pre[NN];
int n,m,K,tot=1,S,T,flow,ans;
struct edge
{
	int u,v,C,W;
} e[MM];
inline void addedge(int p,int q,int v,int c)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][3]=c;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline void add(int p,int q,int v,int c)
{
	addedge(p,q,v,c);
	addedge(q,p,0,-c);
}
bool spfa()
{
	static int que[NN+11],dist[NN];
	static bool dl[NN];
	memset(dist,60,sizeof(dist));
	dist[S]=0;
	memset(dl,0,sizeof(dl));
	int head=0,tail=1;
	que[1]=S;
	dl[1]=true;
	while (head!=tail)
	{
		head++;if (head&gt;NN) head=1;
		int x=que[head];
		dl[x]=false;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;dist[y]&gt;dist[x]+aa[p][3])
			{
				dist[y]=dist[x]+aa[p][3];
				pre[y]=p;
				if (!dl[y])
				{
					tail++;if (tail&gt;NN) tail=1;
					que[tail]=y;
				}
			}
		}
	}
	return dist[T]&lt;dist[0];
}
void calc()
{
	int ff=inf,p;
	for (p=pre[T];p;p=pre[aa[p^1][1]])
		ff=min(ff,aa[p][2]);
	flow+=ff;
	for (p=pre[T];p;p=pre[aa[p^1][1]])
	{
		ans+=ff*aa[p][3];
		aa[p][2]-=ff,aa[p^1][2]+=ff;
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;K);
	int i;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].C,&amp;e[i].W);
		add(e[i].u,e[i].v,e[i].C,0);
	}
	S=1,T=n;
	flow=0;
	while (spfa()) calc();
	printf(&quot;%d &quot;,flow);
	T=n+1;
	add(n,T,K,0);
	for (i=1;i&lt;=m;i++)
		add(e[i].u,e[i].v,inf,e[i].W);
	ans=0;
	while (spfa()) calc();
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1834</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
const int NN=2111,MM=5111;
int o[NN],aa[MM&lt;&lt;3][4],pre[NN];
int n,m,K,tot=1,S,T,flow,ans;
struct edge
{
	int u,v,C,W;
} e[MM];
inline void addedge(int p,int q,int v,int c)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][3]=c;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline void add(int p,int q,int v,int c)
{
	addedge(p,q,v,c);
	addedge(q,p,0,-c);
}
bool spfa()
{
	static int que[NN+11],dist[NN];
	static bool dl[NN];
	memset(dist,60,sizeof(dist));
	dist[S]=0;
	memset(dl,0,sizeof(dl));
	int head=0,tail=1;
	que[1]=S;
	dl[1]=true;
	while (head!=tail)
	{
		head++;if (head&gt;NN) head=1;
		int x=que[head];
		dl[x]=false;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;dist[y]&gt;dist[x]+aa[p][3])
			{
				dist[y]=dist[x]+aa[p][3];
				pre[y]=p;
				if (!dl[y])
				{
					tail++;if (tail&gt;NN) tail=1;
					que[tail]=y;
				}
			}
		}
	}
	return dist[T]&lt;dist[0];
}
void calc()
{
	int ff=inf,p;
	for (p=pre[T];p;p=pre[aa[p^1][1]])
		ff=min(ff,aa[p][2]);
	flow+=ff;
	for (p=pre[T];p;p=pre[aa[p^1][1]])
	{
		ans+=ff*aa[p][3];
		aa[p][2]-=ff,aa[p^1][2]+=ff;
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;K);
	int i;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].C,&amp;e[i].W);
		add(e[i].u,e[i].v,e[i].C,0);
	}
	S=1,T=n;
	flow=0;
	while (spfa()) calc();
	printf(&quot;%d &quot;,flow);
	T=n+1;
	add(n,T,K,0);
	for (i=1;i&lt;=m;i++)
		add(e[i].u,e[i].v,inf,e[i].W);
	ans=0;
	while (spfa()) calc();
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1835</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;cstdlib&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;ctime&gt;
#include&lt;queue&gt;
using namespace std;
#define ls (rt &lt;&lt; 1)
#define rs (rt &lt;&lt; 1 | 1)
const int N = 20005, inf = ~0u &gt;&gt; 1;
int ans, n, m, d[N], c[N], s[N], w[N], st[N], ed[N], f[N];
int lazy[N &lt;&lt; 2], v[N &lt;&lt; 2];
vector&lt;int&gt; g[N];
inline int read(int &amp;t) {
    char c;
    while (c = getchar(), c &lt; '0' || c &gt; '9');
    t = c - '0';
    while (c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') t = t * 10 + c - '0';
    return t;
}
void pushdown(int rt) {
    if (lazy[rt]) {
        lazy[ls] += lazy[rt], lazy[rs] += lazy[rt];
        v[ls] += lazy[rt], v[rs] += lazy[rt];
        lazy[rt] = 0;
    }
}
inline void pushup(int rt) {
    v[rt] = min(v[ls], v[rs]);
}
void build(int rt, int l, int r) {
    lazy[rt] = 0;
    if (l == r) {
        v[rt] = f[l];
        return;
    }
    int mid = l + r &gt;&gt; 1;
    build(ls, l, mid), build(rs, mid + 1, r);
    pushup(rt);
}
void change(int rt, int l, int r, int L, int R, int x) {
    if (L &gt; R)  return;
    if (L &lt;= l &amp;&amp; R &gt;= r) {
        lazy[rt] += x;
        v[rt] += x;
        return;
    }
    pushdown(rt);
    int mid = l + r &gt;&gt; 1;
    if (L &lt;= mid)   change(ls, l, mid, L, R, x);
    if (R &gt; mid)    change(rs, mid + 1, r, L, R, x);
    pushup(rt);
}
int ask(int rt, int l, int r, int L, int R) {
    if (L &gt; R)  return 0;
    if (L &lt;= l &amp;&amp; R &gt;= r)   return v[rt];
    int mid = l + r &gt;&gt; 1;
    pushdown(rt);
    int t = inf;
    if (L &lt;= mid)   t = min(t, ask(ls, l, mid, L, R));
    if (R &gt; mid)    t = min(t, ask(rs, mid + 1, r, L, R));
    return t;
}
void init() {
    read(n), read(m);
    for (int i = 2; i &lt;= n; ++i)    read(d[i]);
    for (int i = 1; i &lt;= n; ++i)    read(c[i]);
    for (int i = 1; i &lt;= n; ++i)    read(s[i]);
    for (int i = 1; i &lt;= n; ++i)    read(w[i]);
    d[++n] = inf, w[n] = inf, ++m;
    for (int i = 1; i &lt;= n; ++i) {
        st[i] = lower_bound(d + 1, d + n + 1, d[i] - s[i]) - d;
        ed[i] = lower_bound(d + 1, d + n + 1, d[i] + s[i]) - d;
        if (d[ed[i]] &gt; d[i] + s[i]) --ed[i];
        g[ed[i]].push_back(i);
    }
}
void gao() {
    ans = inf;
    for (int i = 1; i &lt;= m; ++i) {
        if (i == 1) {
            int t = 0;
            for (int j = 1; j &lt;= n; ++j) {
                f[j] = t + c[j];
                for (int k = 0; k &lt; g[j].size(); ++k) {
                    int x = g[j][k];
                    t += w[x];
                }
            }
            //for (int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,f[i]);printf(&quot;\n&quot;);
            ans = f[n];
            continue;
        }
        build(1, 1, n);
        for (int j = 1; j &lt;= n; ++j) {
            f[j] = ask(1, 1, n, 1, j - 1) + c[j];
            for (int k = 0; k &lt; g[j].size(); ++k) {
                int x = g[j][k];
                change(1, 1, n, 1, st[x] - 1, w[x]);
            }
        }
        ans = min(ans, f[n]);
    }
}
int main() {
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
    init();
    gao();
    printf(&quot;%d\n&quot;, ans);
    return 0;
}
<pre><h2>Problem1835</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;cstdlib&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;ctime&gt;
#include&lt;queue&gt;
using namespace std;
#define ls (rt &lt;&lt; 1)
#define rs (rt &lt;&lt; 1 | 1)
const int N = 20005, inf = ~0u &gt;&gt; 1;
int ans, n, m, d[N], c[N], s[N], w[N], st[N], ed[N], f[N];
int lazy[N &lt;&lt; 2], v[N &lt;&lt; 2];
vector&lt;int&gt; g[N];
inline int read(int &amp;t) {
    char c;
    while (c = getchar(), c &lt; '0' || c &gt; '9');
    t = c - '0';
    while (c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') t = t * 10 + c - '0';
    return t;
}
void pushdown(int rt) {
    if (lazy[rt]) {
        lazy[ls] += lazy[rt], lazy[rs] += lazy[rt];
        v[ls] += lazy[rt], v[rs] += lazy[rt];
        lazy[rt] = 0;
    }
}
inline void pushup(int rt) {
    v[rt] = min(v[ls], v[rs]);
}
void build(int rt, int l, int r) {
    lazy[rt] = 0;
    if (l == r) {
        v[rt] = f[l];
        return;
    }
    int mid = l + r &gt;&gt; 1;
    build(ls, l, mid), build(rs, mid + 1, r);
    pushup(rt);
}
void change(int rt, int l, int r, int L, int R, int x) {
    if (L &gt; R)  return;
    if (L &lt;= l &amp;&amp; R &gt;= r) {
        lazy[rt] += x;
        v[rt] += x;
        return;
    }
    pushdown(rt);
    int mid = l + r &gt;&gt; 1;
    if (L &lt;= mid)   change(ls, l, mid, L, R, x);
    if (R &gt; mid)    change(rs, mid + 1, r, L, R, x);
    pushup(rt);
}
int ask(int rt, int l, int r, int L, int R) {
    if (L &gt; R)  return 0;
    if (L &lt;= l &amp;&amp; R &gt;= r)   return v[rt];
    int mid = l + r &gt;&gt; 1;
    pushdown(rt);
    int t = inf;
    if (L &lt;= mid)   t = min(t, ask(ls, l, mid, L, R));
    if (R &gt; mid)    t = min(t, ask(rs, mid + 1, r, L, R));
    return t;
}
void init() {
    read(n), read(m);
    for (int i = 2; i &lt;= n; ++i)    read(d[i]);
    for (int i = 1; i &lt;= n; ++i)    read(c[i]);
    for (int i = 1; i &lt;= n; ++i)    read(s[i]);
    for (int i = 1; i &lt;= n; ++i)    read(w[i]);
    d[++n] = inf, w[n] = 0, ++m;
    for (int i = 1; i &lt;= n; ++i) {
        st[i] = lower_bound(d + 1, d + n + 1, d[i] - s[i]) - d;
        ed[i] = lower_bound(d + 1, d + n + 1, d[i] + s[i]) - d;
        if (d[ed[i]] &gt; d[i] + s[i]) --ed[i];
        g[ed[i]].push_back(i);
    }
}
void gao() {
    ans = inf;
    for (int i = 1; i &lt;= m; ++i) {
        if (i == 1) {
            int t = 0;
            for (int j = 1; j &lt;= n; ++j) {
                f[j] = t + c[j];
                for (int k = 0; k &lt; g[j].size(); ++k) {
                    int x = g[j][k];
                    t += w[x];
                }
            }
            //for (int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,f[i]);printf(&quot;\n&quot;);
            ans = f[n];
            continue;
        }
        build(1, 1, n);
        for (int j = 1; j &lt;= n; ++j) {
            f[j] = ask(1, 1, n, 1, j - 1) + c[j];
            for (int k = 0; k &lt; g[j].size(); ++k) {
                int x = g[j][k];
                change(1, 1, n, 1, st[x] - 1, w[x]);
            }
        }
        ans = min(ans, f[n]);
    }
}
int main() {
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
    init();
    gao();
    printf(&quot;%d\n&quot;, ans);
    return 0;
}
<pre><h2>Problem1835</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
#define pb push_back
#define lc(v) ((v)&lt;&lt;1)
#define rc(v) (((v)&lt;&lt;1)+1)
#define NN 21111
#define inf 999999999
int tmin[NN*4],tag[NN*4],f[NN],left[NN],right[NN];
int n,K,ww,ee,ans;
vector&lt;int&gt; b[NN],c[NN];
struct info
{
	int D,W,S,C;
} a[NN];
void build(int v,int l,int r)
{
	tag[v]=0;
	if (r-l==1)
	{
		tmin[v]=f[l];
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(lc(v),l,mid);
	build(rc(v),mid,r);
	tmin[v]=min(tmin[lc(v)],tmin[rc(v)]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	tmin[lc(v)]+=tag[v],tag[lc(v)]+=tag[v];
	tmin[rc(v)]+=tag[v],tag[rc(v)]+=tag[v];
	tag[v]=0;
}
void change(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		tmin[v]+=x;
		tag[v]+=x;
		return;
	}
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) change(lc(v),l,mid,x);
	if (ee&gt;mid) change(rc(v),mid,r,x);
	tmin[v]=min(tmin[lc(v)],tmin[rc(v)]);
}
int find(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tmin[v];
	pushdown(v);
	int mid=(l+r)&gt;&gt;1,res=inf;
	if (ww&lt;mid) res=min(res,find(lc(v),l,mid));
	if (ee&gt;mid) res=min(res,find(rc(v),mid,r));
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	int i,j,k;
	for (i=2;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i].D);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i].C);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i].S);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i].W);
	n++,K++;
	a[n].D=inf,a[n].W=inf;
	for (i=1;i&lt;=n;i++)
	{
		int l,r,mid,res;
		l=1,r=i;
		while (l&lt;=r)
		{
			mid=(l+r)&gt;&gt;1;
			if (a[i].D-a[mid].D&lt;=a[i].S) res=mid,r=mid-1;
			else l=mid+1;
		}
		left[i]=res;
		b[res].pb(i);
		l=i,r=n;
		while (l&lt;=r)
		{
			mid=(l+r)&gt;&gt;1;
			if (a[mid].D-a[i].D&lt;=a[i].S) res=mid,l=mid+1;
			else r=mid-1;
		}
		right[i]=res;
		c[res].pb(i);
	}
	int now=0;
	for (i=1;i&lt;=n;i++)
	{
		f[i]=now+a[i].C;
		for (j=0;j&lt;c[i].size();j++) now+=a[c[i][j]].W;
	}
	ans=f[n];
	//for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,f[i]);printf(&quot;\n&quot;);
	build(1,1,n+1);
	for (j=2;j&lt;=K;j++)
	{
		for (i=1;i&lt;=n;i++)
		{
			ww=1,ee=i;
			if (ww&lt;ee) f[i]=find(1,1,n+1)+a[i].C;
			for (k=0;k&lt;c[i].size();k++)
			{
				int x=c[i][k];
				ww=1,ee=left[x];
				if (ww&lt;ee) change(1,1,n+1,a[x].W);
			}
		}
		if (f[n]&lt;ans) ans=f[n];
		build(1,1,n+1);
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1835</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
#define pb push_back
#define lc(v) ((v)&lt;&lt;1)
#define rc(v) (((v)&lt;&lt;1)+1)
#define NN 21111
#define inf 999999999
int tmin[NN*4],tag[NN*4],f[NN],left[NN],right[NN];
int n,K,ww,ee,ans;
vector&lt;int&gt; c[NN];
struct info
{
	int D,W,S,C;
} a[NN];
void build(int v,int l,int r)
{
	tag[v]=0;
	if (r-l==1)
	{
		tmin[v]=f[l];
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(lc(v),l,mid);
	build(rc(v),mid,r);
	tmin[v]=min(tmin[lc(v)],tmin[rc(v)]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	tmin[lc(v)]+=tag[v],tag[lc(v)]+=tag[v];
	tmin[rc(v)]+=tag[v],tag[rc(v)]+=tag[v];
	tag[v]=0;
}
void change(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		tmin[v]+=x;
		tag[v]+=x;
		return;
	}
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) change(lc(v),l,mid,x);
	if (ee&gt;mid) change(rc(v),mid,r,x);
	tmin[v]=min(tmin[lc(v)],tmin[rc(v)]);
}
int find(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tmin[v];
	pushdown(v);
	int mid=(l+r)&gt;&gt;1,res=inf;
	if (ww&lt;mid) res=min(res,find(lc(v),l,mid));
	if (ee&gt;mid) res=min(res,find(rc(v),mid,r));
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	int i,j,k;
	for (i=2;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i].D);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i].C);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i].S);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i].W);
	n++,K++;
	a[n].D=inf,a[n].W=inf;
	for (i=1;i&lt;=n;i++)
	{
		int l,r,mid,res;
		l=1,r=i;
		while (l&lt;=r)
		{
			mid=(l+r)&gt;&gt;1;
			if (a[i].D-a[mid].D&lt;=a[i].S) res=mid,r=mid-1;
			else l=mid+1;
		}
		left[i]=res;
		l=i,r=n;
		while (l&lt;=r)
		{
			mid=(l+r)&gt;&gt;1;
			if (a[mid].D-a[i].D&lt;=a[i].S) res=mid,l=mid+1;
			else r=mid-1;
		}
		right[i]=res;
		c[res].pb(i);
	}
	int now=0;
	for (i=1;i&lt;=n;i++)
	{
		f[i]=now+a[i].C;
		for (j=0;j&lt;c[i].size();j++) now+=a[c[i][j]].W;
	}
	ans=f[n];
	build(1,1,n+1);
	for (j=2;j&lt;=K;j++)
	{
		for (i=1;i&lt;=n;i++)
		{
			ww=1,ee=i;
			if (ww&lt;ee) f[i]=find(1,1,n+1)+a[i].C;
			for (k=0;k&lt;c[i].size();k++)
			{
				int x=c[i][k];
				ww=1,ee=left[x];
				if (ww&lt;ee) change(1,1,n+1,a[x].W);
			}
		}
		if (f[n]&lt;ans) ans=f[n];
		build(1,1,n+1);
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1835</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
#define pb push_back
#define lc(v) ((v)&lt;&lt;1)
#define rc(v) (((v)&lt;&lt;1)+1)
#define NN 21111
#define inf 999999999
int tmin[NN*4],tag[NN*4],f[NN],left[NN],right[NN];
int n,K,ww,ee,ans;
vector&lt;int&gt; c[NN];
struct info
{
	int D,W,S,C;
} a[NN];
void build(int v,int l,int r)
{
	tag[v]=0;
	if (r-l==1)
	{
		tmin[v]=f[l];
		return;
	}
	int mid=(l+r)&gt;&gt;1,x=lc(v),y=rc(v);
	build(x,l,mid);
	build(y,mid,r);
	tmin[v]=min(tmin[x],tmin[y]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	tmin[lc(v)]+=tag[v],tag[lc(v)]+=tag[v];
	tmin[rc(v)]+=tag[v],tag[rc(v)]+=tag[v];
	tag[v]=0;
}
void change(int v,int l,int r,int t)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		tmin[v]+=t;
		tag[v]+=t;
		return;
	}
	pushdown(v);
	int mid=(l+r)&gt;&gt;1,x=lc(v),y=rc(v);
	if (ww&lt;mid) change(x,l,mid,t);
	if (ee&gt;mid) change(y,mid,r,t);
	tmin[v]=min(tmin[x],tmin[y]);
}
int find(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tmin[v];
	pushdown(v);
	int mid=(l+r)&gt;&gt;1,res=inf;
	if (ww&lt;mid) res=min(res,find(lc(v),l,mid));
	if (ee&gt;mid) res=min(res,find(rc(v),mid,r));
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	int i,j,k;
	for (i=2;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i].D);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i].C);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i].S);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i].W);
	n++,K++;
	a[n].D=inf,a[n].W=inf;
	for (i=1;i&lt;=n;i++)
	{
		int l,r,mid,res;
		l=1,r=i;
		while (l&lt;=r)
		{
			mid=(l+r)&gt;&gt;1;
			if (a[i].D-a[mid].D&lt;=a[i].S) res=mid,r=mid-1;
			else l=mid+1;
		}
		left[i]=res;
		l=i,r=n;
		while (l&lt;=r)
		{
			mid=(l+r)&gt;&gt;1;
			if (a[mid].D-a[i].D&lt;=a[i].S) res=mid,l=mid+1;
			else r=mid-1;
		}
		right[i]=res;
		c[res].pb(i);
	}
	int now=0;
	for (i=1;i&lt;=n;i++)
	{
		f[i]=now+a[i].C;
		for (j=0;j&lt;c[i].size();j++) now+=a[c[i][j]].W;
	}
	ans=f[n];
	build(1,1,n+1);
	for (j=2;j&lt;=K;j++)
	{
		for (i=1;i&lt;=n;i++)
		{
			ww=1,ee=i;
			if (ww&lt;ee) f[i]=find(1,1,n+1)+a[i].C;
			for (k=0;k&lt;c[i].size();k++)
			{
				int x=c[i][k];
				ww=1,ee=left[x];
				if (ww&lt;ee) change(1,1,n+1,a[x].W);
			}
		}
		if (f[n]&lt;ans) ans=f[n];
		build(1,1,n+1);
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1835</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
#define pb push_back
#define lc(v) ((v)&lt;&lt;1)
#define rc(v) (((v)&lt;&lt;1)+1)
#define NN 21111
#define inf 999999999
int tmin[NN*4],tag[NN*4],f[NN],left[NN],D[NN],W[NN],S[NN],C[NN];
int n,K,ww,ee,ans;
vector&lt;int&gt; c[NN];
void build(int v,int l,int r)
{
	tag[v]=0;
	if (r-l==1)
	{
		tmin[v]=f[l];
		return;
	}
	int mid=(l+r)&gt;&gt;1,x=lc(v),y=rc(v);
	build(x,l,mid);
	build(y,mid,r);
	tmin[v]=min(tmin[x],tmin[y]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	tmin[lc(v)]+=tag[v],tag[lc(v)]+=tag[v];
	tmin[rc(v)]+=tag[v],tag[rc(v)]+=tag[v];
	tag[v]=0;
}
void change(int v,int l,int r,int t)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		tmin[v]+=t;
		tag[v]+=t;
		return;
	}
	pushdown(v);
	int mid=(l+r)&gt;&gt;1,x=lc(v),y=rc(v);
	if (ww&lt;mid) change(x,l,mid,t);
	if (ee&gt;mid) change(y,mid,r,t);
	tmin[v]=min(tmin[x],tmin[y]);
}
int find(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tmin[v];
	pushdown(v);
	int mid=(l+r)&gt;&gt;1,res=inf;
	if (ww&lt;mid) res=min(res,find(lc(v),l,mid));
	if (ee&gt;mid) res=min(res,find(rc(v),mid,r));
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	int i,j,k;
	for (i=2;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;D[i]);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;C[i]);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;S[i]);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;W[i]);
	n++,K++;
	D[n]=inf;
	for (i=1;i&lt;=n;i++)
	{
		int l,r,mid,res;
		l=1,r=i;
		while (l&lt;=r)
		{
			mid=(l+r)&gt;&gt;1;
			if (D[i]-D[mid]&lt;=S[i]) res=mid,r=mid-1;
			else l=mid+1;
		}
		left[i]=res;
		l=i,r=n;
		while (l&lt;=r)
		{
			mid=(l+r)&gt;&gt;1;
			if (D[mid]-D[i]&lt;=S[i]) res=mid,l=mid+1;
			else r=mid-1;
		}
		c[res].pb(i);
	}
	int now=0;
	for (i=1;i&lt;=n;i++)
	{
		f[i]=now+C[i];
		for (j=0;j&lt;c[i].size();j++) now+=W[c[i][j]];
	}
	ans=f[n];
	build(1,1,n+1);
	for (j=2;j&lt;=K;j++)
	{
		for (i=1;i&lt;=n;i++)
		{
			ww=1,ee=i;
			if (ww&lt;ee) f[i]=find(1,1,n+1)+C[i];
			for (k=0;k&lt;c[i].size();k++)
			{
				int x=c[i][k];
				ww=1,ee=left[x];
				if (ww&lt;ee) change(1,1,n+1,W[x]);
			}
		}
		if (f[n]&lt;ans) ans=f[n];
		build(1,1,n+1);
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1835</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define pb push_back
#define lc(v) ((v)&lt;&lt;1)
#define rc(v) (((v)&lt;&lt;1)+1)
#define NN 21111
#define inf 999999999
int tmin[NN*4],tag[NN*4],f[NN],left[NN],D[NN],W[NN],S[NN],C[NN],aa[NN][2],o[NN];
int n,K,ww,ee,ans,tot;
void build(int v,int l,int r)
{
	tag[v]=0;
	if (r-l==1)
	{
		tmin[v]=f[l];
		return;
	}
	int mid=(l+r)&gt;&gt;1,x=lc(v),y=rc(v);
	build(x,l,mid);
	build(y,mid,r);
	tmin[v]=min(tmin[x],tmin[y]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	tmin[lc(v)]+=tag[v],tag[lc(v)]+=tag[v];
	tmin[rc(v)]+=tag[v],tag[rc(v)]+=tag[v];
	tag[v]=0;
}
void change(int v,int l,int r,int t)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		tmin[v]+=t;
		tag[v]+=t;
		return;
	}
	pushdown(v);
	int mid=(l+r)&gt;&gt;1,x=lc(v),y=rc(v);
	if (ww&lt;mid) change(x,l,mid,t);
	if (ee&gt;mid) change(y,mid,r,t);
	tmin[v]=min(tmin[x],tmin[y]);
}
int find(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tmin[v];
	pushdown(v);
	int mid=(l+r)&gt;&gt;1,res=inf;
	if (ww&lt;mid) res=min(res,find(lc(v),l,mid));
	if (ee&gt;mid) res=min(res,find(rc(v),mid,r));
	return res;
}
void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	int i,j;
	for (i=2;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;D[i]);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;C[i]);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;S[i]);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;W[i]);
	n++,K++;
	D[n]=inf;
	for (i=1;i&lt;=n;i++)
	{
		int l,r,mid,res=i;
		l=1,r=i;
		while (l&lt;=r)
		{
			mid=(l+r)&gt;&gt;1;
			if (D[i]-D[mid]&lt;=S[i]) res=mid,r=mid-1;
			else l=mid+1;
		}
		left[i]=res;
		l=i,r=n;
		while (l&lt;=r)
		{
			mid=(l+r)&gt;&gt;1;
			if (D[mid]-D[i]&lt;=S[i]) res=mid,l=mid+1;
			else r=mid-1;
		}
		addedge(res,i);
	}
	int now=0;
	for (i=1;i&lt;=n;i++)
	{
		f[i]=now+C[i];
		for (int p=o[i];p;p=aa[p][0]) now+=W[aa[p][1]];
	}
	ans=f[n];
	build(1,1,n+1);
	for (j=2;j&lt;=K;j++)
	{
		for (i=1;i&lt;=n;i++)
		{
			ww=1,ee=i;
			if (ww&lt;ee) f[i]=find(1,1,n+1)+C[i];
			for (int p=o[i];p;p=aa[p][0])
			{
				int x=aa[p][1];
				ww=1,ee=left[x];
				if (ww&lt;ee) change(1,1,n+1,W[x]);
			}
		}
		if (f[n]&lt;ans) ans=f[n];
		build(1,1,n+1);
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1855</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 2111
#define ln printf(&quot;\n&quot;)
int ap[NN],bp[NN],as[NN],bs[NN],f[NN][NN];
int n,m,W,ans;
struct ppt
{
	int pos,w;
	ppt(int a=0,int b=0) {w=a,pos=b;}
} q[NN];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;W);
	int i,j,k;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d%d%d%d&quot;,&amp;ap[i],&amp;bp[i],&amp;as[i],&amp;bs[i]);
	memset(f,200,sizeof(f));
	f[0][0]=0;
	for (i=1;i&lt;=W+1;i++)
		for (j=0;j&lt;=m;j++)
			if (j&lt;=as[i]) f[i][j]=max(f[i-1][j],-ap[i]*j);
			else f[i][j]=f[i-1][j];
	for (i=W+2;i&lt;=n;i++)
	{
		int t=i-W-1;
		int l=0,r=1;
		f[i][0]=f[i-1][0];
		q[1]=ppt(f[t][0]+ap[i]*0,0);
		for (j=1;j&lt;=m;j++)
		{
			f[i][j]=f[i-1][j];
			k=max(0,j-as[i]);
			while (l&lt;r&amp;&amp;q[l+1].pos&lt;k) l++;
			f[i][j]=max(f[i][j],q[l+1].w-ap[i]*j);
			while (l&lt;r&amp;&amp;q[r].w&lt;=f[t][j]+ap[i]*j) r--;
			q[++r]=ppt(f[t][j]+ap[i]*j,j);
		}
		l=0,r=1;
		q[1]=ppt(f[t][m]+bp[i]*m,m);
		for (j=m-1;j&gt;=0;j--)
		{
			k=min(m,j+bs[i]);
			while (l&lt;r&amp;&amp;q[l+1].pos&gt;k) l++;
			f[i][j]=max(f[i][j],q[l+1].w-bp[i]*j);
			while (l&lt;r&amp;&amp;q[r].w&lt;=f[t][j]+bp[i]*j) r--;
			q[++r]=ppt(f[t][j]+bp[i]*j,j);
		}
	}
	//for(i=1;i&lt;=n;i++){for(j=0;j&lt;=m;j++)printf(&quot;%d &quot;,f[i][j]);ln;}ln;
	for (j=0;j&lt;=m;j++)
		if (f[n][j]&gt;ans) ans=f[n][j];
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1855</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 2111
#define ln printf(&quot;\n&quot;)
int ap[NN],bp[NN],as[NN],bs[NN],f[NN][NN],pos[NN],w[NN];
int n,m,W,ans;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;W);
	int i,j;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d%d%d%d&quot;,&amp;ap[i],&amp;bp[i],&amp;as[i],&amp;bs[i]);
	memset(f,200,sizeof(f));
	f[0][0]=0;
	for (i=1;i&lt;=W+1;i++)
		for (j=0;j&lt;=m;j++)
			if (j&lt;=as[i]) f[i][j]=max(f[i-1][j],-ap[i]*j);
			else f[i][j]=f[i-1][j];
	for (i=W+2;i&lt;=n;i++)
	{
		int t=i-W-1;
		int l=0,r=1;
		f[i][0]=f[i-1][0];
		pos[1]=0,w[1]=f[t][0];
		for (j=1;j&lt;=m;j++)
		{
			f[i][j]=f[i-1][j];
			int k=max(0,j-as[i]);
			while (l&lt;r&amp;&amp;pos[l+1]&lt;k) l++;
			f[i][j]=max(f[i][j],w[l+1]-ap[i]*j);
			int tmp=f[t][j]+ap[i]*j;
			while (l&lt;r&amp;&amp;w[r]&lt;=tmp) r--;
			r++,w[r]=tmp,pos[r]=j;
		}
		l=0,r=1;
		w[1]=f[t][m]+bp[i]*m,pos[1]=m;
		for (j=m-1;j&gt;=0;j--)
		{
			int k=min(m,j+bs[i]);
			while (l&lt;r&amp;&amp;pos[l+1]&gt;k) l++;
			f[i][j]=max(f[i][j],w[l+1]-bp[i]*j);
			int tmp=f[t][j]+bp[i]*j;
			while (l&lt;r&amp;&amp;w[r]&lt;=tmp) r--;
			r++,w[r]=tmp,pos[r]=j;
		}
	}
	//for(i=1;i&lt;=n;i++){for(j=0;j&lt;=m;j++)printf(&quot;%d &quot;,f[i][j]);ln;}ln;
	for (j=0;j&lt;=m;j++)
		if (f[n][j]&gt;ans) ans=f[n][j];
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1855</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 2011
#define ln printf(&quot;\n&quot;)
int ap[NN],bp[NN],as[NN],bs[NN],f[NN][NN];
int n,m,W,ans;
struct ppt
{
	int pos,w;
	ppt(int a=0,int b=0) {w=a,pos=b;}
} q[NN];
int main()
{
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;W);
	int i,j;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d%d%d%d&quot;,&amp;ap[i],&amp;bp[i],&amp;as[i],&amp;bs[i]);
	memset(f,200,sizeof(f));
	f[0][0]=0;
	for (i=1;i&lt;=W+1;i++)
		for (j=0;j&lt;=m;j++)
			if (j&lt;=as[i]) f[i][j]=max(f[i-1][j],-ap[i]*j);
			else f[i][j]=f[i-1][j];
	for (i=W+2;i&lt;=n;i++)
	{
		int t=i-W-1;
		int l=0,r=1;
		f[i][0]=f[i-1][0];
		q[1]=ppt(f[t][0]+ap[i]*0,0);
		for (j=1;j&lt;=m;j++)
		{
			f[i][j]=f[i-1][j];
			int k=max(0,j-as[i]);
			while (l&lt;r&amp;&amp;q[l+1].pos&lt;k) l++;
			f[i][j]=max(f[i][j],q[l+1].w-ap[i]*j);
			int tmp=f[t][j]+ap[i]*j;
			while (l&lt;r&amp;&amp;q[r].w&lt;=tmp) r--;
			q[++r]=ppt(tmp,j);
		}
		l=0,r=1;
		q[1]=ppt(f[t][m]+bp[i]*m,m);
		for (j=m-1;j&gt;=0;j--)
		{
			int k=min(m,j+bs[i]);
			while (l&lt;r&amp;&amp;q[l+1].pos&gt;k) l++;
			f[i][j]=max(f[i][j],q[l+1].w-bp[i]*j);
			int tmp=f[t][j]+bp[i]*j;
			while (l&lt;r&amp;&amp;q[r].w&lt;=tmp) r--;
			q[++r]=ppt(tmp,j);
		}
	}
	//for(i=1;i&lt;=n;i++){for(j=0;j&lt;=m;j++)printf(&quot;%d &quot;,f[i][j]);ln;}ln;
	for (j=0;j&lt;=m;j++)
		if (f[n][j]&gt;ans) ans=f[n][j];
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1856</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
#define mo 20100403
int n,m,fac[2000005];
LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (a%=c;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
int C(int n,int m)
{
	return (LL)fac[n]*ksm((LL)fac[m]*fac[n-m],mo-2,mo)%mo;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	fac[0]=1;
	int i;
	for (i=1;i&lt;=n+m;i++)
		fac[i]=(LL)fac[i-1]*i%mo;
	int ans=C(n+m,n)-C(n+m,n+1);
	if (ans&lt;0) ans+=mo;
	printf(&quot;%d&quot;,ans);
	return 0;
}<pre><h2>Problem1858</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int NN=100111;
int n,m,TTT,root,a[NN];
inline int max(int a,int b) {return a&gt;b?a:b;}
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar());
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
}
struct splaynode
{
	struct info
	{
		int lm,rm,mm,num,sz;
		inline void make(bool flag)
		{
			if (flag) lm=rm=mm=num=sz;
			else lm=rm=mm=num=0;
		}
		friend info merge(info a,bool flag,info b)
		{
			info res;
			res.sz=a.sz+b.sz+1;
			if (flag)
			{
				if (a.num==a.sz) res.lm=a.num+1+b.lm;
				else res.lm=a.lm;
				if (b.num==b.sz) res.rm=b.num+1+a.rm;
				else res.rm=b.rm;
				res.mm=max(max(a.mm,b.mm),a.rm+1+b.lm);
				res.num=a.num+b.num+1;
			}
			else
			{
				res.lm=a.lm;
				res.rm=b.rm;
				res.mm=max(a.mm,b.mm);
				res.num=a.num+b.num;
			}
			return res;
		}
	} a[2];
	int fa,s[2];
	bool key,tag0,tag1,tag2;
	inline void make0()
	{
		a[0].make(true);
		a[1].make(false);
		key=0;
		tag0=true;
		tag1=tag2=false;
	}
	inline void make1()
	{
		a[0].make(false);
		a[1].make(true);
		key=1;
		tag1=true;
		tag0=tag2=false;
	}
	inline void qufan()
	{
		if (tag0) {make1();return;}
		if (tag1) {make0();return;}
		tag2^=1;
		key^=1;
		swap(a[0],a[1]);
	}
} T[NN];
inline void pushdown(int v)
{
	int x=T[v].s[0],y=T[v].s[1];
	if (T[v].tag0)
	{
		if (x) T[x].make0();
		if (y) T[y].make0();
		T[v].tag0=false;
	}
	if (T[v].tag1)
	{
		if (x) T[x].make1();
		if (y) T[y].make1();
		T[v].tag1=false;
	}
	if (T[v].tag2)
	{
		if (x) T[x].qufan();
		if (y) T[y].qufan();
		T[v].tag2=false;
	}
}
inline void update(int v)
{
	int x=T[v].s[0],y=T[v].s[1];
	T[v].a[0]=merge(T[x].a[0],T[v].key==0,T[y].a[0]);
	T[v].a[1]=merge(T[x].a[1],T[v].key==1,T[y].a[1]);
};
inline void rotate(int t,int p)
{
	int y=T[t].fa;
	pushdown(y),pushdown(t);
	if (T[y].fa)
	{
		if (y==T[T[y].fa].s[0]) T[T[y].fa].s[0]=t;
		else T[T[y].fa].s[1]=t;
	}
	T[t].fa=T[y].fa;
	T[y].s[p^1]=T[t].s[p];
	if (T[t].s[p]) T[T[t].s[p]].fa=y;
	T[t].s[p]=y;
	T[y].fa=t;
	update(y),update(t);
}
void splay(int t,int ff)
{
	while (T[t].fa!=ff)
	{
		int y=T[t].fa;
		if (T[y].fa==ff)
			if (t==T[y].s[0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==T[T[y].fa].s[0])
				if (t==T[y].s[0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==T[y].s[1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
	if (!ff) root=t;
}
int find(int K)
{
	int t=root;
	while (t)
	{
		pushdown(t);
		int tmp=T[T[t].s[0]].a[0].sz;
		if (K&lt;=tmp) t=T[t].s[0];
		else if (K==tmp+1) return t;
		else K-=tmp+1,t=T[t].s[1];
	}
	return -1;
}
int build(int l,int r)
{
	int v=(l+r)&gt;&gt;1,mid=(l+r)&gt;&gt;1;
	T[v].key=a[mid];
	if (l&lt;mid)
	{
		T[v].s[0]=build(l,mid-1);
		T[T[v].s[0]].fa=v;
	}
	if (r&gt;mid)
	{
		T[v].s[1]=build(mid+1,r);
		T[T[v].s[1]].fa=v;
	}
	update(v);
	return v;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	int i,x,y,z;
	for (i=1;i&lt;=n;i++) read(a[i+1]);
	root=build(1,n+2);
	for (;m;m--)
	{
		read(z),read(x),read(y);
		x=find(x+1),y=find(y+3);
		splay(x,0),splay(y,x);
		x=T[y].s[0];
		if (z==0) T[x].make0(),splay(x,0);
		else if (z==1) T[x].make1(),splay(x,0);
		else if (z==2) T[x].qufan(),splay(x,0);
		else if (z==3) printf(&quot;%d\n&quot;,T[x].a[1].num);
		else printf(&quot;%d\n&quot;,T[x].a[1].mm);
	}
	return 0;
}<pre><h2>Problem1867</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
const int NN=55;
int n,m;
bool zai[NN][NN];
struct fenshu
{
	LL x,y;
	fenshu(LL a=0,LL b=1) {x=a;y=b;}
	void out() {printf(&quot;%lld/%lld&quot;,x,y);}
	LL gcd(LL a,LL b) {return !b?a:gcd(b,a%b);}
	fenshu xiao()
	{
		LL tmp=gcd(x,y);
		x/=tmp,y/=tmp;
		return *this;
	}
	fenshu operator /(LL t)
	{
		fenshu a=*this;
		a.y*=t;
		return a.xiao();
	}
	void operator +=(fenshu b)
	{
		fenshu a=*this;
		LL tmp=gcd(a.y,b.y);
		a.x*=b.y/tmp,b.x*=a.y/tmp;
		x=a.x+b.x,y=a.y/tmp*b.y;
		xiao();
	}
} f[NN][NN];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=i;j++)
		{
			char ch=getchar();
			while (ch!='*'&amp;&amp;ch!='.') ch=getchar();
			zai[i][j]=(ch=='*');
		}
	f[1][1]=fenshu(1,1);
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=i;j++)
			if (zai[i][j])
			{
				fenshu tmp=f[i][j]/2;
				f[i+1][j]+=tmp,f[i+1][j+1]+=tmp;
			}
			else f[i+2][j+1]+=f[i][j];
	f[n+1][m+1].out();
	return 0;
}<pre><h2>Problem1868</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 155
#define MM 3111
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define inf 999999999
#define ln printf(&quot;\n&quot;)
int q[NN],deep[NN],o[NN],id[NN],q2[NN],vt[NN],mincut[NN][NN],aa[MM*2][3],bb[MM*2][3];
int n,m,SS,TT,tot,TIME,tes;
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);printf(&quot;\n&quot;);}
void out(){for(int i=1;i&lt;=n;i++){for(int j=1;j&lt;=n;j++)printf(&quot;%d &quot;,mincut[i][j]);ln;}}
bool bfs()
{
	int head=0,tail=1,p,x,y;
	memset(deep,0,sizeof(deep));
	deep[SS]=1;
	q[1]=SS;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	//printf(&quot;deep &quot;);out(deep,1,n);
	return deep[TT];
}
int dfs(int v,int ff)
{
	if (v==TT) return ff;
	int res=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(aa[p][2],ff));
		if (tmp==0) deep[y]=inf;
		ff-=tmp;
		aa[p][2]-=tmp;
		aa[p^1][2]+=tmp;
		res+=tmp;
		if (!ff) break;
	}
	return res;
}
int dinic(int S,int T)
{
	//printf(&quot;=====dinic(%d,%d)=====\n&quot;,S,T);
	SS=S,TT=T;
	int res=0;
	while (bfs()) res+=dfs(SS,inf);
	//printf(&quot;=====dinic end with res=%d=====\n&quot;,res);
	return res;
}
void solve(int l,int r)
{
	//printf(&quot;--------------- solve %d %d -------------------\n&quot;,l,r);
	if (l==r) return;
	int head,tail,x,p,y,i,t,j,res;
	for (i=1;i&lt;=tot;i++)
	{
		aa[i][1]=bb[i][1];
		aa[i][2]=bb[i][2];
		aa[i][0]=bb[i][0];
	}
	mincut[id[l]][id[r]]=res=dinic(id[l],id[r]);
	//printf(&quot;mincut[%d][%d]=%d\n&quot;,id[l],id[r],res);
	head=0,q[tail=1]=id[l];
	TIME++;
	vt[id[l]]=TIME;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;vt[y]!=TIME) vt[y]=TIME,q[++tail]=y;
		}
	}
	//printf(&quot;vt &quot;);out(vt,1,n);
	t=0;
	for (i=1;i&lt;=n;i++)
		if (vt[i]!=TIME) q2[++t]=i;
	for (i=1;i&lt;=tail;i++)
		for (j=1;j&lt;=t;j++)
			mincut[q[i]][q2[j]]=mincut[q2[j]][q[i]]=mii(mincut[q[i]][q2[j]],res);
	//out();
	//memset(q,0,sizeof(q));memset(q2,0,sizeof(q2));//dddddddddddddddddddddddddddddddddd
	tail=t=0;
	for (i=l;i&lt;=r;i++)
		if (vt[id[i]]==TIME) q[++tail]=id[i];
		else q2[++t]=id[i];
	//printf(&quot;q &quot;);out(q,1,n);printf(&quot;q2 &quot;);out(q2,1,n);
	i=l;
	for (j=1;j&lt;=tail;j++) id[i++]=q[j];
	for (j=1;j&lt;=t;j++) id[i++]=q2[j];
	//printf(&quot;id &quot;);out(id,1,n);
	solve(l,l+tail-1);
	solve(l+tail,r);
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=bb[tot][1]=q;
	aa[tot][2]=bb[tot][2]=v;
	aa[tot][0]=bb[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--,ln)
	{
		//printf(&quot;\n------------------------------------------------------------\n&quot;);
		memset(mincut,127,sizeof(mincut));
		memset(o,0,sizeof(o));
		tot=1;
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		int i,j,x,y,z,ask;
		for (i=1;i&lt;=m;i++)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			addedge(x,y,z);
			addedge(y,x,z);
		}
		for (i=1;i&lt;=n;i++) id[i]=i;
		solve(1,n);
		//for (i=1;i&lt;=n;i++){for(j=1;j&lt;=n;j++) printf(&quot;%d &quot;,mincut[i][j]);ln;}
		for (scanf(&quot;%d&quot;,&amp;ask);ask;ask--)
		{
			scanf(&quot;%d&quot;,&amp;x);
			int ans=0;
			for (i=1;i&lt;n;i++)
				for (j=i+1;j&lt;=n;j++)
					if (mincut[i][j]&lt;=x) ans++;
			printf(&quot;%d\n&quot;,ans);
		}
	}
	return 0;
}
<pre><h2>Problem1868</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 155
#define MM 3111
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define inf 999999999
int q[NN],deep[NN],o[NN],id[NN],q2[NN],vt[NN],mincut[NN][NN],aa[MM*2][3],bb[MM*2][3];
int n,m,SS,TT,tot,TIME,tes;
bool bfs()
{
	int head=0,tail=1,p,x,y;
	memset(deep,0,sizeof(deep));
	deep[SS]=1;
	q[1]=SS;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[TT];
}
int dfs(int v,int ff)
{
	if (v==TT) return ff;
	int res=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(aa[p][2],ff));
		if (tmp==0) deep[y]=inf;
		ff-=tmp;
		aa[p][2]-=tmp;
		aa[p^1][2]+=tmp;
		res+=tmp;
		if (!ff) break;
	}
	return res;
}
int dinic(int S,int T)
{
	SS=S,TT=T;
	int res=0;
	while (bfs()) res+=dfs(SS,inf);
	return res;
}
void solve(int l,int r)
{
	if (l==r) return;
	int head,tail,x,p,y,i,t,j,res;
	for (i=1;i&lt;=tot;i++)
	{
		aa[i][1]=bb[i][1];
		aa[i][2]=bb[i][2];
	}
	mincut[id[l]][id[r]]=res=dinic(id[l],id[r]);
	head=0,q[tail=1]=id[l];
	TIME++;
	vt[id[l]]=TIME;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;vt[y]!=TIME) vt[y]=TIME,q[++tail]=y;
		}
	}
	t=0;
	for (i=1;i&lt;=n;i++)
		if (vt[i]!=TIME) q2[++t]=i;
	for (i=1;i&lt;=tail;i++)
		for (j=1;j&lt;=t;j++)
			mincut[q[i]][q2[j]]=mincut[q2[j]][q[i]]=mii(mincut[q[i]][q2[j]],res);
	tail=t=0;
	for (i=l;i&lt;=r;i++)
		if (vt[id[i]]==TIME) q[++tail]=id[i];
		else q2[++t]=id[i];
	i=l;
	for (j=1;j&lt;=tail;j++) id[i++]=q[j];
	for (j=1;j&lt;=t;j++) id[i++]=q2[j];
	solve(l,l+tail-1);
	solve(l+tail,r);
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=bb[tot][1]=q;
	aa[tot][2]=bb[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--,printf(&quot;\n&quot;))
	{
		memset(mincut,127,sizeof(mincut));
		memset(o,0,sizeof(o));
		tot=1;
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		int i,j,x,y,z,ask;
		for (i=1;i&lt;=m;i++)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			addedge(x,y,z);
			addedge(y,x,z);
		}
		for (i=1;i&lt;=n;i++) id[i]=i;
		solve(1,n);
		for (scanf(&quot;%d&quot;,&amp;ask);ask;ask--)
		{
			scanf(&quot;%d&quot;,&amp;x);
			int ans=0;
			for (i=1;i&lt;n;i++)
				for (j=i+1;j&lt;=n;j++)
					if (mincut[i][j]&lt;=x) ans++;
			printf(&quot;%d\n&quot;,ans);
		}
	}
	return 0;
}
<pre><h2>Problem1875</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mo 45989
#define ln printf(&quot;\n&quot;)
int n,m,T,A,B,tmp,size;
struct edge
{
	int a,b;
}
e[1000];
struct matrix
{
	int m[200][200];
	matrix() {memset(m,0,sizeof(m));}
	friend matrix operator *(matrix a,matrix b)
	{
		matrix c;
		int i,j,k;
		for (k=1;k&lt;=size;k++)
			for (i=1;i&lt;=size;i++)
				for (j=1;j&lt;=size;j++)
					c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j])%mo;
		return c;
	}
} res,a,ans;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d%d%d&quot;,&amp;n,&amp;m,&amp;T,&amp;A,&amp;B);
	A++,B++;
	int i,j;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;e[i].a,&amp;e[i].b);
		e[i].a++,e[i].b++;
	}
	size=m*2+1;
	for (i=1;i&lt;=m;i++)
	{
		if (e[i].a==A) a.m[size][i]=1;
		if (e[i].b==A) a.m[size][m+i]=1;
		for (j=1;j&lt;=m;j++) if (i!=j)
		{
			if (e[i].a==e[j].a) a.m[m+j][i]=1;
			if (e[i].b==e[j].a) a.m[m+j][m+i]=1;
			if (e[i].a==e[j].b)	a.m[j][i]=1;
			if (e[i].b==e[j].b) a.m[j][m+i]=1;
		}
	}
	//for (i=1;i&lt;=size;i++){for(j=1;j&lt;=size;j++)printf(&quot;%d &quot;,a.m[i][j]);ln;}
	for (i=1;i&lt;=size;i++) res.m[i][i]=1;
	for (;T;T&gt;&gt;=1,a=a*a) if (T&amp;1) res=res*a;
	ans.m[1][size]=1;
	ans=ans*res;
	tmp=0;
	for (i=1;i&lt;=m;i++)
	{
		if (e[i].a==B) tmp+=ans.m[1][m+i];
		if (e[i].b==B) tmp+=ans.m[1][i];
	}
	tmp%=mo;
	printf(&quot;%d\n&quot;,tmp);
	return 0;
}
<pre><h2>Problem1876</h2><pre>a,b=input(),input()
c=a%b
while c!=0L:
    a=b
    b=c
    c=a%b
print b<pre><h2>Problem1877</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf=99999999;
int aa[1000000][4],dist[100000],o[100000],pre[100000],q[100000];
bool dl[100000];
int n,m,x,y,z,ans1,ans2,i,tot,head,tail,S,T;
int min(int a,int b) {return a&lt;b?a:b;}
void addedge(int p,int q,int v,int cost)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][3]=cost;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v,int cost)
{
	addedge(p,q,v,cost);
	addedge(q,p,0,-cost);
}
bool relax(int x,int y,int v)
{
	if (dist[y]&gt;dist[x]+v)
	{
		dist[y]=dist[x]+v;
		return 1;
	}
	return 0;
}
void spfa()
{
	head=0,tail=0;
	memset(dist,127,sizeof(dist[0])*(T+10));
	memset(dl,0,sizeof(dl[0])*(T+10));
	dist[S]=0;
	q[++tail]=S;
	dl[S]=1;
	while (head&lt;tail)
	{
		int x=q[++head];
		int p=o[x];
		dl[x]=0;
		while (p)
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;relax(x,y,aa[p][3]))
			{
				pre[y]=p;
				if (!dl[y])
				{
					q[++tail]=y;
					dl[y]=1;
				}
			}
			p=aa[p][0];
		}
	}
}
void change()
{
	int p=pre[T],flow=inf;
	while (p)
	{
		flow=min(flow,aa[p][2]);
		p=pre[aa[p^1][1]];
	}
	//printf(&quot;%d\n&quot;,flow);
	p=pre[T];
	while (p)
	{
		ans2+=flow*aa[p][3];
		aa[p][2]-=flow;
		aa[p^1][2]+=flow;
		p=pre[aa[p^1][1]];
	}
}
int main()
{
	//freopen(&quot;run.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;run.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	tot=1;
	for (i=2;i&lt;=n-1;i++) add(i*2-1,i*2,1,0);
	add(1,2,inf,0);
	add(n*2-1,n*2,inf,0);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		add(x*2,y*2-1,1,z);
	}
	S=1,T=n*2;
	ans1=ans2=0;
	spfa();
	while (dist[T]&lt;dist[0])
	{
		//for (int i=1;i&lt;=T;i++) printf(&quot;%d &quot;,dist[i]);printf(&quot;\n&quot;);
		++ans1;
		change();
		spfa();
		//for (int i=1;i&lt;=T;i++) printf(&quot;%d &quot;,dist[i]);printf(&quot;\n&quot;);
		//printf(&quot;%d\n&quot;,dist[T]);
	}
	printf(&quot;%d %d\n&quot;,ans1,ans2);
	return 0;
}
<pre><h2>Problem1878</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int NN=50111,MM=201111;
int c[NN],a[NN],last[1001111],next[NN],o[NN],aa[MM][2],ans[MM];
int n,m,tot=1;
struct query
{
	int l,r;
} q[MM];
void change(int i,int x)
{
	for (;i&lt;=n;i+=i&amp;-i) c[i]+=x;
}
int getsum(int i)
{
	int res=0;
	for (;i;i-=i&amp;-i) res+=c[i];
	return res;
}
void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	for (i=n;i;i--)
	{
		next[i]=last[a[i]];
		last[a[i]]=i;
	}
	for (i=0;i&lt;=1000000;i++)
		if (last[i]) change(last[i],1);//,printf(&quot;last[i]=%d\n&quot;,last[i]);;
	scanf(&quot;%d&quot;,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;q[i].l,&amp;q[i].r);
		addedge(q[i].l,i);
	}
	for (i=1;i&lt;=n;i++)
	{
		int tmp=getsum(i-1);
		for (int p=o[i];p;p=aa[p][0])
		{
			int y=aa[p][1];
			ans[y]=getsum(q[y].r)-tmp;
		}
		if (next[i]) change(next[i],1);
	}
	for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem1878</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
int n,m;
int last[201111],b[1001111];
struct node
{
	int len;
	vector&lt;int&gt; a;
	node *lson,*rson;
	void hebing()
	{
		int l1=lson-&gt;len,l2=rson-&gt;len,j=0,k=0;
		for (int i=0;i&lt;len;i++)
		{
			if (j&gt;=l1) a.push_back(rson-&gt;a[k++]);
			else if (k&gt;=l2) a.push_back(lson-&gt;a[j++]);
			else if (lson-&gt;a[j]&lt;rson-&gt;a[k]) a.push_back(lson-&gt;a[j++]);
			else a.push_back(rson-&gt;a[k++]);
		}
	}
	int find(int x)
	{
		int l=0,r=len-1,res=-1;
		while (l&lt;=r)
		{
			int mid=(l+r)&gt;&gt;1;
			if (a[mid]&lt;x) res=mid,l=mid+1;
			else r=mid-1;
		}
		return res+1;
	}
} *root;
void build(node *v,int l,int r)
{
	//printf(&quot;build %d %d\n&quot;,l,r);
	v-&gt;len=r-l;
	if (r-l==1)
	{
		v-&gt;a.push_back(last[l]);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(v-&gt;lson=new node,l,mid);
	build(v-&gt;rson=new node,mid,r);
	v-&gt;hebing();
}
int getans(node *v,int l,int r,int ww,int ee,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return v-&gt;find(x);
	int res=0,mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) res+=getans(v-&gt;lson,l,mid,ww,ee,x);
	if (ee&gt;mid) res+=getans(v-&gt;rson,mid,r,ww,ee,x);
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d&quot;,&amp;n);
	int i,l,r,x;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		last[i]=b[x];
		b[x]=i;
	}
	//ln;printf(&quot;last: &quot;);for(i=1;i&lt;=n;i++)printf(&quot;%d &quot;,last[i]);ln;ln;//return 0;
	build(root=new node,1,n+1);
	scanf(&quot;%d&quot;,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
		printf(&quot;%d\n&quot;,getans(root,1,n+1,l,r+1,l));
	}
	return 0;
}<pre><h2>Problem1879</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int mo=1000003;
int tes,n,K,f[55][39999];
char s[17][55];
inline int calc(int x)
{
	int res=0;
	for (;x;x-=x&amp;-x) res++;
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d%d\n&quot;,&amp;n,&amp;K);
		int i,j,k,l;
		for (i=1;i&lt;=n;i++) scanf(&quot;%s\n&quot;,s[i]+1);
		int len=strlen(s[1]+1);
		memset(f,0,sizeof(f));
		int mm=(1&lt;&lt;n)-1;
		f[0][mm]=1;
		for (i=0;i&lt;len;i++)
			for (j=0;j&lt;=mm;j++) if (f[i][j])
			{
				//printf(&quot;i=%d j=%d\n&quot;,i,j);
				for (k=0;k&lt;26;k++)
				{
					int t=0;
					for (l=1;l&lt;=n;l++) if (j&amp;(1&lt;&lt;(l-1)))
						if (s[l][i+1]-'a'==k||s[l][i+1]=='?') t+=1&lt;&lt;(l-1);
					f[i+1][t]+=f[i][j];
					if (f[i+1][t]&gt;=mo) f[i+1][t]%=mo;
				}
			}
		int ans=0;
		for (j=0;j&lt;=mm;j++)
			if (calc(j)==K)
			{
				ans+=f[len][j];
				if (ans&gt;=mo) ans-=mo;
			}
		ans%=mo;
		if (ans&lt;0) ans+=mo;
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem1880</h2><pre>const
  inf=maxlongint&gt;&gt;1;
var
  a:array[1..1505,1..1505]of longint;
  dist:array[1..4,1..1505]of longint;
  vt:array[1..1505]of boolean;
  n,m,x1,x2,y1,y2,i,x,y,z,ans,j:longint;
  xx:array[1..4]of longint;
function max(a,b:longint):longint;
begin
  if a&gt;b then exit(a);
  exit(b);
end;
procedure init;
begin
  fillchar(a,sizeof(a),0);
  readln(n,m,x1,y1,x2,y2);
  xx[1]:=x1;
  xx[2]:=y1;
  xx[3]:=x2;
  xx[4]:=y2;
  for i:=1 to m do
    begin
      readln(x,y,z);
      if(a[x,y]=0)or(z&lt;a[x,y])then
        begin
          a[x,y]:=z;
          a[y,x]:=z;
        end;
    end;
end;
procedure dij(t:longint);
var i,j,mm,mj:longint;
begin
  for i:=1 to n do
    begin
      dist[t,i]:=inf;
      vt[i]:=false;
    end;
  dist[t,xx[t]]:=0;
  for i:=1 to n do
    begin
      mm:=inf;
      for j:=1 to n do
        if(not vt[j])and(dist[t,j]&lt;mm)then
          begin
            mm:=dist[t,j];
            mj:=j;
          end;
      vt[mj]:=true;
      for j:=1 to n do
        if(not vt[j])and(a[j,mj]&gt;0)and(dist[t,j]&gt;dist[t,mj]+a[mj,j]) then
          dist[t,j]:=dist[t,mj]+a[mj,j];
    end;
end;
function check(i,j:longint):boolean;
begin
  if dist[1,i]+dist[2,i]&lt;&gt;dist[1,y1] then exit(false);
  if dist[1,j]+dist[2,j]&lt;&gt;dist[1,y1] then exit(false);
  if dist[3,i]+dist[4,i]&lt;&gt;dist[3,y2] then exit(false);
  if dist[3,j]+dist[4,j]&lt;&gt;dist[3,y2] then exit(false);
  //writeln(i,' ',j);
  exit(true);
end;
procedure doit;
begin
  for i:=1 to 4 do dij(i);
  ans:=0;
  for i:=1 to n do
    for j:=i to n do
      if check(i,j) then
        ans:=max(ans,max(abs(dist[3,i]-dist[3,j]),abs(dist[1,i]-dist[1,j])));
  writeln(ans);
end;
begin
  //assign(input,'roud.in');reset(input);
  //assign(output,'roud.out');rewrite(output);
  init;
  doit;
  close(input);close(output);
end.<pre><h2>Problem1901</h2><pre>#include &lt;cstdio&gt;
using namespace std;
const int maxn=10001,maxtot=maxn*900,inf=1000000000;
int a[maxn],son[maxtot][2],u[maxn],v[maxn],n,m,flag,root[maxn],sum[maxtot],tot;
char c;
void insert(int &amp;now,int l,int r,int pos,int value)//一定用&amp;，这样就可以动态建立节点了
{
	if (!now) now=++tot;//动态建立节点
	sum[now]+=value;
	if (l==r) return;
	int mid=(l+r)&gt;&gt;1;
	if (pos&lt;=mid) insert(son[now][0],l,mid,pos,value); else insert(son[now][1],mid+1,r,pos,value);
}
void change(int now,int pos,int value)
{
	for (;now&lt;=n;now+=now&amp;-now) insert(root[now],0,inf,pos,value);
}
void init(int now)
{
	for (;now;now-=now&amp;-now) u[now]=root[now];
}
int getsum(int now)
{
	int cur=0;
	for (;now;now-=now&amp;-now) cur+=sum[son[u[now]][0]];//查询每个节点的左儿子之和（即&lt;=mid的有多少个数）
	return cur;
}
void turn(int now,int w)
{
	for (;now;now-=now&amp;-now) if (v[now]!=flag)//如果在这次查询中now这棵线段树还未转移就转移，因为x-1和y的lowbit有重复的部分
	{
		v[now]=flag;
		u[now]=son[u[now]][w];
	}
}
int main()
{
	//freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;lx.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,k,l,r,mid,cur;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		change(i,a[i],1);
	}
	scanf(&quot;\n&quot;);
	for (i=1;i&lt;=m;i++)
	{
		c=getchar();
		if (c=='C')
		{
			scanf(&quot;%d%d\n&quot;,&amp;x,&amp;y);
			change(x,a[x],-1);
			change(x,y,1);
			a[x]=y;//千万别忘
		}
		else
		{
			scanf(&quot;%d%d%d\n&quot;,&amp;x,&amp;y,&amp;k);
			l=0,r=inf;
			init(x-1);
			init(y);
			while (l&lt;r)//其实这并不是传统意义的二分答案，而是在模拟权值线段树的[l,r]区间，当l==r时已经是叶节点了（也就是答案）
			{
				cur=getsum(y)-getsum(x-1);
				flag++;//每次更新flag
				mid=(l+r)&gt;&gt;1;
				if (cur&gt;=k)
				{
					r=mid;//一定不是mid-1，因为是在模拟线段树
					turn(x-1,0);//都转到左儿子
					turn(y,0);
				}
				else
				{
					k-=cur;
					l=mid+1;
					turn(x-1,1);//都转到右儿子
					turn(y,1);
				}
			}
			printf(&quot;%d\n&quot;,l);
		}
	}
	return 0;
}
<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 1000000001
#define lowbit(i) (i&amp;-i)
int a[910000],S[9100000],lc[9100000],rc[9100000],root[910000],now[910000],vt[910000];
int n,m,SIZE,flag;
void ins(int &amp;v,int ll,int rr,int x,int kind)
{
	if (!v) v=++SIZE;
	S[v]+=kind;
	if (rr-ll==1) return;
	int mid=(ll+rr)&gt;&gt;1;
	if (x&lt;mid) ins(lc[v],ll,mid,x,kind);
	else ins(rc[v],mid,rr,x,kind);
}
void change(int i,int x,int kind)
{
	for (;i&lt;=n;i+=lowbit(i)) ins(root[i],0,inf,x,kind);
}
int getsum(int i)
{
	int res=0;
	for (;i&gt;0;i-=lowbit(i)) res+=S[lc[now[i]]];
	return res;
}
void clear(int i)
{
	for (;i&gt;0;i-=lowbit(i)) now[i]=root[i];
}
void turn(int i,int kind)
{
	for (;i&gt;0;i-=lowbit(i))
		if (vt[i]!=flag)
		{
			vt[i]=flag;
			if (kind) now[i]=rc[now[i]];
			else now[i]=lc[now[i]];
		}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	int i;
	char ch;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),change(i,a[i],1);
	scanf(&quot;\n&quot;);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%c&quot;,&amp;ch);
		int x,y,ll,rr,K;
		if (ch=='C')
		{
			scanf(&quot;%d%d\n&quot;,&amp;x,&amp;y);
			change(x,a[x],-1);
			change(x,y,1);
			a[x]=y;
		}
		else
		{
			scanf(&quot;%d%d%d\n&quot;,&amp;ll,&amp;rr,&amp;K);
			int l=0,r=inf;
			clear(rr);
			clear(ll-1);
			while (r-l&gt;1)
			{
				int tmp=getsum(rr)-getsum(ll-1);
				++flag;
				int mid=(l+r)&gt;&gt;1;
				if (K&lt;=tmp)
				{
					r=mid;
					turn(rr,0);
					turn(ll-1,0);
				}
				else
				{
					K-=tmp;
					l=mid;
					turn(rr,1);
					turn(ll-1,1);
				}
			}
			printf(&quot;%d\n&quot;,l);
		}
	}
	return 0;
}
<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 1000000001
#define lowbit(i) (i&amp;-i)
int a[91000],S[9100000],lc[9100000],rc[9100000],root[91000],now[91000],vt[91000];
int n,m,SIZE,flag;
void ins(int &amp;v,int ll,int rr,int x,int kind)
{
	if (!v) v=++SIZE;
	S[v]+=kind;
	if (rr-ll==1) return;
	int mid=(ll+rr)&gt;&gt;1;
	if (x&lt;mid) ins(lc[v],ll,mid,x,kind);
	else ins(rc[v],mid,rr,x,kind);
}
void change(int i,int x,int kind)
{
	for (;i&lt;=n;i+=lowbit(i)) ins(root[i],0,inf,x,kind);
}
int getsum(int i)
{
	int res=0;
	for (;i&gt;0;i-=lowbit(i)) res+=S[lc[now[i]]];
	return res;
}
void clear(int i)
{
	for (;i&gt;0;i-=lowbit(i)) now[i]=root[i];
}
void turn(int i,int kind)
{
	for (;i&gt;0;i-=lowbit(i))
		if (vt[i]!=flag)
		{
			vt[i]=flag;
			if (kind) now[i]=rc[now[i]];
			else now[i]=lc[now[i]];
		}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	int i;
	char ch;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),change(i,a[i],1);
	scanf(&quot;\n&quot;);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%c&quot;,&amp;ch);
		int x,y,ll,rr,K;
		if (ch=='C')
		{
			scanf(&quot;%d%d\n&quot;,&amp;x,&amp;y);
			change(x,a[x],-1);
			change(x,y,1);
			a[x]=y;
		}
		else
		{
			scanf(&quot;%d%d%d\n&quot;,&amp;ll,&amp;rr,&amp;K);
			int l=0,r=inf;
			clear(rr);
			clear(ll-1);
			while (r-l&gt;1)
			{
				int tmp=getsum(rr)-getsum(ll-1);
				++flag;
				int mid=(l+r)&gt;&gt;1;
				if (K&lt;=tmp)
				{
					r=mid;
					turn(rr,0);
					turn(ll-1,0);
				}
				else
				{
					K-=tmp;
					l=mid;
					turn(rr,1);
					turn(ll-1,1);
				}
			}
			printf(&quot;%d\n&quot;,l);
		}
	}
	return 0;
}
<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 1999999999
int lc[9000000],rc[9000000],S[9000000],root[11111],a[11111],now[11111],vt[11111];
int n,m,TTT,TIME;
void ins(int &amp;v,int l,int r,int x,int kind)
{
	if (!v) v=++TTT;
	S[v]+=kind;
	//printf(&quot;%d %d\n&quot;,v,S[v]);
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid) ins(lc[v],l,mid,x,kind);
	else ins(rc[v],mid,r,x,kind);
	S[v]=S[lc[v]]+S[rc[v]];
	//printf(&quot;%d %d\n&quot;,v,S[v]);
}
void change(int i,int x,int kind)
{
	for (;i&lt;=n;i+=(i&amp;-i)) ins(root[i],0,inf,x,kind);
}
void clear(int i)
{
	for (;i;i-=(i&amp;-i)) now[i]=root[i];
}
int getsum(int i)
{
	int res=0;
	for (;i;i-=(i&amp;-i)) res+=S[lc[now[i]]];
	return res;
}
void turn(int i,int kind)
{
	for (;i;i-=(i&amp;-i))
		if (vt[i]!=TIME)
		{
			vt[i]=TIME;
			now[i]=(kind?rc[now[i]]:lc[now[i]]);
		}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		change(i,a[i],1);
	}
	//for(i=1;i&lt;=n;i++)printf(&quot;%d &quot;,S[root[i]]);printf(&quot;\n&quot;);
	for (i=1;i&lt;=m;i++)
	{
		char ch='@';
		while (ch!='Q'&amp;&amp;ch!='C') ch=getchar();
		//printf(&quot;%c\n&quot;,ch);
		if (ch=='C')
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			change(x,a[x],-1);
			change(x,y,1);
			a[x]=y;
		}
		else
		{
			//printf(&quot;\n----------------------------------------------\n&quot;);
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			clear(y);
			clear(x-1);
			int l=0,r=inf;
			while (r-l&gt;1)
			{
				//printf(&quot;%d %d\n&quot;,l,r);
				int tmp=getsum(y)-getsum(x-1);
				//printf(&quot;%d\n&quot;,tmp);
				TIME++;
				if (z&lt;=tmp)
				{
					turn(y,0);
					turn(x-1,0);
					r=l+(r-l)/2;
				}
				else
				{
					turn(y,1);
					turn(x-1,1);
					z-=tmp;
					l=l+(r-l)/2;
				}
			}
			printf(&quot;%d\n&quot;,l);
		}
	}
	return 0;
}
<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 1999999999
int lc[5000001],rc[5000001],S[5000001],root[11111],a[11111],now[11111],vt[11111];
int n,m,TTT,TIME;
void ins(int &amp;v,int l,int r,int x,int kind)
{
	if (!v) v=++TTT;
	S[v]+=kind;
	//printf(&quot;%d %d\n&quot;,v,S[v]);
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid) ins(lc[v],l,mid,x,kind);
	else ins(rc[v],mid,r,x,kind);
	S[v]=S[lc[v]]+S[rc[v]];
	//printf(&quot;%d %d\n&quot;,v,S[v]);
}
void change(int i,int x,int kind)
{
	for (;i&lt;=n;i+=(i&amp;-i)) ins(root[i],0,inf,x,kind);
}
void clear(int i)
{
	for (;i;i-=(i&amp;-i)) now[i]=root[i];
}
int getsum(int i)
{
	int res=0;
	for (;i;i-=(i&amp;-i)) res+=S[lc[now[i]]];
	return res;
}
void turn(int i,int kind)
{
	for (;i;i-=(i&amp;-i))
		if (vt[i]!=TIME)
		{
			vt[i]=TIME;
			now[i]=(kind?rc[now[i]]:lc[now[i]]);
		}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		change(i,a[i],1);
	}
	//for(i=1;i&lt;=n;i++)printf(&quot;%d &quot;,S[root[i]]);printf(&quot;\n&quot;);
	for (i=1;i&lt;=m;i++)
	{
		char ch='@';
		while (ch!='Q'&amp;&amp;ch!='C') ch=getchar();
		//printf(&quot;%c\n&quot;,ch);
		if (ch=='C')
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			change(x,a[x],-1);
			change(x,y,1);
			a[x]=y;
		}
		else
		{
			//printf(&quot;\n----------------------------------------------\n&quot;);
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			clear(y);
			clear(x-1);
			int l=0,r=inf;
			while (r-l&gt;1)
			{
				//printf(&quot;%d %d\n&quot;,l,r);
				int tmp=getsum(y)-getsum(x-1);
				//printf(&quot;%d\n&quot;,tmp);
				TIME++;
				if (z&lt;=tmp)
				{
					turn(y,0);
					turn(x-1,0);
					r=l+(r-l)/2;
				}
				else
				{
					turn(y,1);
					turn(x-1,1);
					z-=tmp;
					l=l+(r-l)/2;
				}
			}
			printf(&quot;%d\n&quot;,l);
		}
	}
	return 0;
}
<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 1999999999
int lc[5000001],rc[5000001],S[5000001],root[11111],a[11111],now[11111],vt[11111];
int n,m,TTT,TIME;
void ins(int &amp;v,int l,int r,int x,int kind)
{
    if (!v) v=++TTT;
    S[v]+=kind;
    //printf(&quot;%d %d\n&quot;,v,S[v]);
    if (r-l==1) return;
    int mid=(l+r)&gt;&gt;1;
    if (x&lt;mid) ins(lc[v],l,mid,x,kind);
    else ins(rc[v],mid,r,x,kind);
    //S[v]=S[lc[v]]+S[rc[v]];
    //printf(&quot;%d %d\n&quot;,v,S[v]);
}
void change(int i,int x,int kind)
{
    for (;i&lt;=n;i+=(i&amp;-i)) ins(root[i],0,inf,x,kind);
}
void clear(int i)
{
    for (;i;i-=(i&amp;-i)) now[i]=root[i];
}
int getsum(int i)
{
    int res=0;
    for (;i;i-=(i&amp;-i)) res+=S[lc[now[i]]];
    return res;
}
void turn(int i,int kind)
{
    for (;i;i-=(i&amp;-i))
        if (vt[i]!=TIME)
        {
            vt[i]=TIME;
            now[i]=(kind?rc[now[i]]:lc[now[i]]);
        }
}
int main()
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    int i,x,y,z;
    for (i=1;i&lt;=n;i++)
    {
        scanf(&quot;%d&quot;,&amp;a[i]);
        change(i,a[i],1);
    }
    //for(i=1;i&lt;=n;i++)printf(&quot;%d &quot;,S[root[i]]);printf(&quot;\n&quot;);
    for (i=1;i&lt;=m;i++)
    {
        char ch='@';
        while (ch!='Q'&amp;&amp;ch!='C') ch=getchar();
        //printf(&quot;%c\n&quot;,ch);
        if (ch=='C')
        {
            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
            change(x,a[x],-1);
            change(x,y,1);
            a[x]=y;
        }
        else
        {
            //printf(&quot;\n----------------------------------------------\n&quot;);
            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
            clear(y);
            clear(x-1);
            int l=0,r=inf;
            while (r-l&gt;1)
            {
                //printf(&quot;%d %d\n&quot;,l,r);
                int tmp=getsum(y)-getsum(x-1);
                //printf(&quot;%d\n&quot;,tmp);
                TIME++;
                if (z&lt;=tmp)
                {
                    turn(y,0);
                    turn(x-1,0);
                    r=l+(r-l)/2;
                }
                else
                {
                    turn(y,1);
                    turn(x-1,1);
                    z-=tmp;
                    l=l+(r-l)/2;
                }
            }
            printf(&quot;%d\n&quot;,l);
        }
    }
    return 0;
}<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 31111
#define inf 1999999999
int a[NN],b[NN],c[NN],d[NN],kind[NN],id[NN],K[NN],ans[NN],id1[NN],id2[NN],have[NN];
int n,m,num;
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);printf(&quot;\n&quot;);}
void change(int i,int x)
{
	for (;i&lt;=n;i+=(i&amp;-i)) c[i]+=x;
}
int getsum(int i)
{
	int res=0;
	for (;i;i-=(i&amp;-i)) res+=c[i];
	return res;
}
void solve(int head,int tail,int l,int r)
{
	if (head&gt;tail) return;
	//printf(&quot;\n------- head=%d tail=%d l=%d mid=%d r=%d ----------------------------\n&quot;,head,tail,l,(l+r)/2,r);
	//printf(&quot;have: &quot;);out(have,1,num);
	int i,mid,t,j,k;
	if (l==r)
	{
		for (i=head;i&lt;=tail;i++)
			if (kind[id[i]]==3) ans[id[i]]=l;//,printf(&quot;ans[%d]=%d\n&quot;,id[i],l);
		return;
	}
	mid=(l+r)&gt;&gt;1;
	for (i=head;i&lt;=tail;i++)
	{
		t=id[i];
		if (kind[t]==3) d[t]=getsum(b[t])-getsum(a[t]-1);
		else if (kind[t]==1&amp;&amp;b[t]&lt;=mid) change(a[t],1);
		else if (kind[t]==2&amp;&amp;b[t]&lt;=mid) change(a[t],-1);
	}
	for (i=head;i&lt;=tail;i++)
	{
		t=id[i];
		if (kind[t]==1&amp;&amp;b[t]&lt;=mid) change(a[t],-1);
		else if (kind[t]==2&amp;&amp;b[t]&lt;=mid) change(a[t],1);
	}
	for (i=j=0,k=head;k&lt;=tail;k++)
	{
		t=id[k];
		if (kind[t]!=3)
			if (b[t]&lt;=mid) id1[++i]=t;
			else id2[++j]=t;
		else
			if (have[t]+d[t]&gt;=K[t]) id1[++i]=t;
			else have[t]+=d[t],id2[++j]=t;
	}
	//printf(&quot;id1: &quot;);out(id1,1,i);printf(&quot;id2: &quot;);out(id2,1,j);
	for (k=1;k&lt;=i;k++) id[head+k-1]=id1[k];
	for (k=1;k&lt;=j;k++) id[head+i+k-1]=id2[k];
	solve(head,head+i-1,l,mid);
	solve(head+i,tail,mid+1,r);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;c[i]);
		num++,kind[num]=1,a[num]=i,b[num]=c[i],id[num]=num;
	}
	for (i=1;i&lt;=m;i++)
	{
		char ch=getchar();
		while (ch!='C'&amp;&amp;ch!='Q') ch=getchar();
		if (ch=='C')
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			num++,kind[num]=2,a[num]=x,b[num]=c[x],id[num]=num;
			c[x]=y;
			num++,kind[num]=1,a[num]=x,b[num]=c[x],id[num]=num;
		}
		else
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			num++,kind[num]=3,a[num]=x,b[num]=y,K[num]=z,have[num]=0,id[num]=num;
		}
	}
	//printf(&quot;num=%d\n&quot;,num);
	//for(i=1;i&lt;=num;i++){printf(&quot;%d:  kind=%d  a=%d  b=%d  K=%d\n&quot;,i,kind[i],a[i],b[i],K[i]);}
	memset(c,0,sizeof(c));
	solve(1,num,0,inf);
	//printf(&quot;\n\n&quot;);
	for (i=1;i&lt;=num;i++)
		if (kind[i]==3) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 31111
#define inf 999999999
int a[NN],b[NN],c[NN],d[NN],kind[NN],id[NN],K[NN],ans[NN],id1[NN],id2[NN],have[NN];
int n,m,num;
void change(int i,int x)
{
	for (;i&lt;=n;i+=(i&amp;-i)) c[i]+=x;
}
int getsum(int i)
{
	int res=0;
	for (;i;i-=(i&amp;-i)) res+=c[i];
	return res;
}
void solve(int head,int tail,int l,int r)
{
	if (head&gt;tail) return;
	int i,mid,t,j,k;
	if (l==r)
	{
		for (i=head;i&lt;=tail;i++)
			if (kind[id[i]]==3) ans[id[i]]=l;
		return;
	}
	mid=(l+r)&gt;&gt;1;
	for (i=head;i&lt;=tail;i++)
	{
		t=id[i];
		if (kind[t]==3) d[t]=getsum(b[t])-getsum(a[t]-1);
		else if (kind[t]==1&amp;&amp;b[t]&lt;=mid) change(a[t],1);
		else if (kind[t]==2&amp;&amp;b[t]&lt;=mid) change(a[t],-1);
	}
	for (i=head;i&lt;=tail;i++)
	{
		t=id[i];
		if (kind[t]==1&amp;&amp;b[t]&lt;=mid) change(a[t],-1);
		else if (kind[t]==2&amp;&amp;b[t]&lt;=mid) change(a[t],1);
	}
	for (i=j=0,k=head;k&lt;=tail;k++)
	{
		t=id[k];
		if (kind[t]!=3)
			if (b[t]&lt;=mid) id1[++i]=t;
			else id2[++j]=t;
		else
			if (have[t]+d[t]&gt;=K[t]) id1[++i]=t;
			else have[t]+=d[t],id2[++j]=t;
	}
	for (k=1;k&lt;=i;k++) id[head+k-1]=id1[k];
	for (k=1;k&lt;=j;k++) id[head+i+k-1]=id2[k];
	solve(head,head+i-1,l,mid);
	solve(head+i,tail,mid+1,r);
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;c[i]);
		num++,kind[num]=1,a[num]=i,b[num]=c[i],id[num]=num;
	}
	for (i=1;i&lt;=m;i++)
	{
		char ch=getchar();
		while (ch!='C'&amp;&amp;ch!='Q') ch=getchar();
		if (ch=='C')
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			num++,kind[num]=2,a[num]=x,b[num]=c[x],id[num]=num;
			c[x]=y;
			num++,kind[num]=1,a[num]=x,b[num]=c[x],id[num]=num;
		}
		else
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			num++,kind[num]=3,a[num]=x,b[num]=y,K[num]=z,id[num]=num;
		}
	}
	memset(c,0,sizeof(c));
	solve(1,num,0,inf);
	for (i=1;i&lt;=num;i++)
		if (kind[i]==3) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 999999999
const int AA=5000005,NN=11111;
int lc[AA],rc[AA],size[AA],root[NN],a[NN],cur[NN],vt[NN];
int n,m,TTT,TIME;
void ins(int &amp;v,int l,int r,int x,int kind)
{
	if (!v) v=++TTT;
	size[v]+=kind;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid) ins(lc[v],l,mid,x,kind);
	else ins(rc[v],mid,r,x,kind);
}
inline void change(int i,int x,int kind)
{
	for (;i&lt;=n;i+=i&amp;-i)
		ins(root[i],-inf,inf,x,kind);
}
inline void clear(int i)
{
	for (;i;i-=i&amp;-i) cur[i]=root[i];
}
inline int getsum(int i)
{
	int res=0;
	for (;i;i-=i&amp;-i) res+=size[lc[cur[i]]];
	return res;
}
inline void turn(int i,int kind)
{
	for (;i;i-=i&amp;-i) if (vt[i]!=TIME)
	{
		vt[i]=TIME;
		cur[i]=kind?rc[cur[i]]:lc[cur[i]];
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		change(i,a[i],1);
	}
	for (i=1;i&lt;=m;i++)
	{
		char ch=getchar();
		while (ch!='C'&amp;&amp;ch!='Q') ch=getchar();
		if (ch=='C')
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			change(x,a[x],-1);
			change(x,a[x]=y,1);
		}
		else
		{
			int L,R,K;
			scanf(&quot;%d%d%d&quot;,&amp;L,&amp;R,&amp;K);
			clear(R),clear(L-1);
			int l=-inf,r=inf;
			while (r-l&gt;1)
			{
				TIME++;
				int mid=(l+r)&gt;&gt;1,tmp=getsum(R)-getsum(L-1);
				if (K&lt;=tmp) turn(R,0),turn(L-1,0),r=mid;
				else K-=tmp,turn(R,1),turn(L-1,1),l=mid;
			}
			printf(&quot;%d\n&quot;,l);
		}
	}
	return 0;
}<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=201111;
int b[NN],ans[NN],id[NN],id1[NN],id2[NN],c[NN],temp[NN],have[NN],a[NN];
int n,m,tot; 
struct info
{
	int kind,x,y,K;
	void out() {printf(&quot;kind=%d  x=%d y=%d K=%d\n&quot;,kind,x,y,K);}
	info(int a=0,int b=0,int c=0,int d=0) {kind=a,x=b,y=c,K=d;}
} q[NN];
inline int cha(int x)
{
	int l=1,r=b[0];
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (b[mid]==x) return mid;
		if (b[mid]&gt;x) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
inline void change(int i,int x)
{
	for (;i&lt;=b[0];i+=i&amp;-i) c[i]+=x;
}
inline int getsum(int i)
{
	int res=0;
	for (;i;i-=i&amp;-i) res+=c[i];
	return res;
}
inline void clear(int i)
{
	for (;i&lt;=b[0];i+=i&amp;-i) c[i]=0;
}
void work(int l,int r,int head,int tail)
{
	//printf(&quot;\n----------------- work %d %d %d %d -------------------------------------------\n&quot;,l,r,head,tail);
	if (head&gt;tail) return;
	if (l==r)
	{
		for (int i=head;i&lt;=tail;i++) ans[id[i]]=l;
		return;
	}
	int mid=(l+r)&gt;&gt;1,i,j,k;
	for (i=head;i&lt;=tail;i++)
	{
		int t=id[i];
		if (q[t].kind==1&amp;&amp;q[t].y&lt;=mid) change(q[t].x,1);
		else if (q[t].kind==2&amp;&amp;q[t].y&lt;=mid) change(q[t].x,-1);
		else temp[t]=getsum(q[t].y)-getsum(q[t].x-1);
	}
	for (i=head;i&lt;=tail;i++)
	{
		int t=id[i];
		if (q[t].kind==1&amp;&amp;q[t].y&lt;=mid) clear(q[t].x);
		else if (q[t].kind==2&amp;&amp;q[t].y&lt;=mid) clear(q[t].x);
	}
	for (i=j=0,k=head;k&lt;=tail;k++)
	{
		int t=id[k];
		if (q[t].kind==3)
			if (temp[t]+have[t]&gt;=q[t].K) id1[++i]=t;
			else have[t]+=temp[t],id2[++j]=t;
		else
			if (q[t].y&lt;=mid) id1[++i]=t;
			else id2[++j]=t;
	}
	int t=head;
	for (k=1;k&lt;=i;k++) id[t++]=id1[k];
	for (k=1;k&lt;=j;k++) id[t++]=id2[k];
	work(l,mid,head,head+i-1);
	work(mid+1,r,head+i,tail);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		b[++b[0]]=a[i];
		q[++tot]=info(1,i,a[i]);
	}
	for (i=1;i&lt;=m;i++)
	{
		char ch=getchar();
		while (ch!='C'&amp;&amp;ch!='Q') ch=getchar();
		if (ch=='C')
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			b[++b[0]]=y;
			q[++tot]=info(2,x,a[x]);
			q[++tot]=info(1,x,a[x]=y);
		}
		else
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			q[++tot]=info(3,x,y,z);
		}
	}
	sort(b+1,b+b[0]+1);
	for (i=1;i&lt;=tot;i++)
		if (q[i].kind!=3) q[i].y=cha(q[i].y);
	//for (i=1;i&lt;=tot;i++) q[i].out();ln;
	for (i=1;i&lt;=tot;i++) id[i]=i;
	work(1,b[0],1,tot);
	for (i=1;i&lt;=tot;i++)
		if (q[i].kind==3) printf(&quot;%d\n&quot;,b[ans[i]]);
	return 0;
}<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=31111;
int b[NN],ans[NN],id[NN],id1[NN],id2[NN],c[NN],temp[NN],have[NN],a[NN];
int n,m,tot; 
struct info
{
	int kind,x,y,K;
	void out() {printf(&quot;kind=%d  x=%d y=%d K=%d\n&quot;,kind,x,y,K);}
	info(int a=0,int b=0,int c=0,int d=0) {kind=a,x=b,y=c,K=d;}
} q[NN];
inline int cha(int x)
{
	int l=1,r=b[0];
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (b[mid]==x) return mid;
		if (b[mid]&gt;x) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
inline void change(int i,int x)
{
	for (;i&lt;=b[0];i+=i&amp;-i) c[i]+=x;
}
inline int getsum(int i)
{
	int res=0;
	for (;i;i-=i&amp;-i) res+=c[i];
	return res;
}
inline void clear(int i)
{
	for (;i&lt;=b[0];i+=i&amp;-i) c[i]=0;
}
void work(int l,int r,int head,int tail)
{
	//printf(&quot;\n----------------- work %d %d %d %d -------------------------------------------\n&quot;,l,r,head,tail);
	if (head&gt;tail) return;
	if (l==r)
	{
		for (int i=head;i&lt;=tail;i++) ans[id[i]]=l;
		return;
	}
	int mid=(l+r)&gt;&gt;1,i,j,k;
	for (i=head;i&lt;=tail;i++)
	{
		int t=id[i];
		if (q[t].kind==1&amp;&amp;q[t].y&lt;=mid) change(q[t].x,1);
		else if (q[t].kind==2&amp;&amp;q[t].y&lt;=mid) change(q[t].x,-1);
		else temp[t]=getsum(q[t].y)-getsum(q[t].x-1);
	}
	for (i=head;i&lt;=tail;i++)
	{
		int t=id[i];
		if (q[t].kind==1&amp;&amp;q[t].y&lt;=mid) clear(q[t].x);
		else if (q[t].kind==2&amp;&amp;q[t].y&lt;=mid) clear(q[t].x);
	}
	for (i=j=0,k=head;k&lt;=tail;k++)
	{
		int t=id[k];
		if (q[t].kind==3)
			if (temp[t]+have[t]&gt;=q[t].K) id1[++i]=t;
			else have[t]+=temp[t],id2[++j]=t;
		else
			if (q[t].y&lt;=mid) id1[++i]=t;
			else id2[++j]=t;
	}
	int t=head;
	for (k=1;k&lt;=i;k++) id[t++]=id1[k];
	for (k=1;k&lt;=j;k++) id[t++]=id2[k];
	work(l,mid,head,head+i-1);
	work(mid+1,r,head+i,tail);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		b[++b[0]]=a[i];
		q[++tot]=info(1,i,a[i]);
	}
	for (i=1;i&lt;=m;i++)
	{
		char ch=getchar();
		while (ch!='C'&amp;&amp;ch!='Q') ch=getchar();
		if (ch=='C')
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			b[++b[0]]=y;
			q[++tot]=info(2,x,a[x]);
			q[++tot]=info(1,x,a[x]=y);
		}
		else
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			q[++tot]=info(3,x,y,z);
		}
	}
	sort(b+1,b+b[0]+1);
	for (i=1;i&lt;=tot;i++)
		if (q[i].kind!=3) q[i].y=cha(q[i].y);
	for (i=1;i&lt;=tot;i++) id[i]=i;
	work(1,b[0],1,tot);
	for (i=1;i&lt;=tot;i++)
		if (q[i].kind==3) printf(&quot;%d\n&quot;,b[ans[i]]);
	return 0;
}<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=30005;
int b[NN],ans[NN],id[NN],id1[NN],id2[NN],c[NN],temp[NN],have[NN],a[NN];
int n,m,tot; 
struct info
{
	int kind,x,y,K;
	info(int a=0,int b=0,int c=0,int d=0) {kind=a,x=b,y=c,K=d;}
} q[NN];
inline int cha(int x)
{
	int l=1,r=b[0];
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (b[mid]==x) return mid;
		if (b[mid]&gt;x) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
inline void change(int i,int x)
{
	for (;i&lt;=b[0];i+=i&amp;-i) c[i]+=x;
}
inline int getsum(int i)
{
	int res=0;
	for (;i;i-=i&amp;-i) res+=c[i];
	return res;
}
inline void clear(int i)
{
	for (;i&lt;=b[0];i+=i&amp;-i) c[i]=0;
}
void work(int l,int r,int head,int tail)
{
	if (head&gt;tail) return;
	if (l==r)
	{
		for (int i=head;i&lt;=tail;i++) ans[id[i]]=l;
		return;
	}
	int mid=(l+r)&gt;&gt;1,i,j,k;
	for (i=head;i&lt;=tail;i++)
	{
		int t=id[i];
		if (q[t].kind==1&amp;&amp;q[t].y&lt;=mid) change(q[t].x,1);
		else if (q[t].kind==2&amp;&amp;q[t].y&lt;=mid) change(q[t].x,-1);
		else temp[t]=getsum(q[t].y)-getsum(q[t].x-1);
	}
	for (i=head;i&lt;=tail;i++)
	{
		int t=id[i];
		if (q[t].kind==1&amp;&amp;q[t].y&lt;=mid) clear(q[t].x);
		else if (q[t].kind==2&amp;&amp;q[t].y&lt;=mid) clear(q[t].x);
	}
	for (i=j=0,k=head;k&lt;=tail;k++)
	{
		int t=id[k];
		if (q[t].kind==3)
			if (temp[t]+have[t]&gt;=q[t].K) id1[++i]=t;
			else have[t]+=temp[t],id2[++j]=t;
		else
			if (q[t].y&lt;=mid) id1[++i]=t;
			else id2[++j]=t;
	}
	int t=head;
	for (k=1;k&lt;=i;k++) id[t++]=id1[k];
	for (k=1;k&lt;=j;k++) id[t++]=id2[k];
	work(l,mid,head,head+i-1);
	work(mid+1,r,head+i,tail);
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		b[++b[0]]=a[i];
		q[++tot]=info(1,i,a[i]);
	}
	for (i=1;i&lt;=m;i++)
	{
		char ch=getchar();
		while (ch!='C'&amp;&amp;ch!='Q') ch=getchar();
		if (ch=='C')
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			b[++b[0]]=y;
			q[++tot]=info(2,x,a[x]);
			q[++tot]=info(1,x,a[x]=y);
		}
		else
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			q[++tot]=info(3,x,y,z);
		}
	}
	sort(b+1,b+b[0]+1);
	for (i=1;i&lt;=tot;i++)
		if (q[i].kind!=3) q[i].y=cha(q[i].y);
	for (i=1;i&lt;=tot;i++) id[i]=i;
	work(1,b[0],1,tot);
	for (i=1;i&lt;=tot;i++)
		if (q[i].kind==3) printf(&quot;%d\n&quot;,b[ans[i]]);
	return 0;
}<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=30005;
int b[NN],ans[NN],id[NN],id1[NN],id2[NN],c[NN],temp[NN],have[NN],a[NN];
int n,m,tot; 
struct info
{
	int kind,x,y,K;
	info(int a=0,int b=0,int c=0,int d=0) {kind=a,x=b,y=c,K=d;}
} q[NN];
inline int cha(int x)
{
	int l=1,r=b[0];
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (b[mid]==x) return mid;
		if (b[mid]&gt;x) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
inline void change(int i,int x)
{
	for (;i&lt;=b[0];i+=i&amp;-i) c[i]+=x;
}
inline int getsum(int i)
{
	int res=0;
	for (;i;i-=i&amp;-i) res+=c[i];
	return res;
}
inline void clear(int i)
{
	for (;i&lt;=b[0];i+=i&amp;-i) c[i]=0;
}
void work(int l,int r,int head,int tail)
{
	if (head&gt;tail) return;
	if (l==r)
	{
		for (int i=head;i&lt;=tail;i++) ans[id[i]]=l;
		return;
	}
	int mid=(l+r)&gt;&gt;1,i,j,k;
	for (i=head;i&lt;=tail;i++)
	{
		int t=id[i];
		if (q[t].kind==1&amp;&amp;q[t].y&lt;=mid) change(q[t].x,1);
		else if (q[t].kind==2&amp;&amp;q[t].y&lt;=mid) change(q[t].x,-1);
		else temp[t]=getsum(q[t].y)-getsum(q[t].x-1);
	}
	for (i=head;i&lt;=tail;i++)
	{
		int t=id[i];
		if (q[t].kind==1&amp;&amp;q[t].y&lt;=mid) clear(q[t].x);
		else if (q[t].kind==2&amp;&amp;q[t].y&lt;=mid) clear(q[t].x);
	}
	for (i=j=0,k=head;k&lt;=tail;k++)
	{
		int t=id[k];
		if (q[t].kind==3)
			if (temp[t]+have[t]&gt;=q[t].K) id1[++i]=t;
			else have[t]+=temp[t],id2[++j]=t;
		else
			if (q[t].y&lt;=mid) id1[++i]=t;
			else id2[++j]=t;
	}
	int t=head;
	for (k=1;k&lt;=i;k++) id[t++]=id1[k];
	for (k=1;k&lt;=j;k++) id[t++]=id2[k];
	work(l,mid,head,head+i-1);
	work(mid+1,r,head+i,tail);
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		b[++b[0]]=a[i];
		q[++tot]=info(1,i,a[i]);
	}
	for (i=1;i&lt;=m;i++)
	{
		char ch=getchar();
		while (ch!='C'&amp;&amp;ch!='Q') ch=getchar();
		if (ch=='C')
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			b[++b[0]]=y;
			q[++tot]=info(2,x,a[x]);
			q[++tot]=info(1,x,a[x]=y);
		}
		else
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			q[++tot]=info(3,x,y,z);
		}
	}
	sort(b+1,b+b[0]+1);
	int t=1;
	for (i=2;i&lt;=b[0];i++)
		if (b[i]!=b[t]) b[++t]=b[i];
	b[0]=t;
	for (i=1;i&lt;=tot;i++)
		if (q[i].kind!=3) q[i].y=cha(q[i].y);
	for (i=1;i&lt;=tot;i++) id[i]=i;
	work(1,b[0],1,tot);
	for (i=1;i&lt;=tot;i++)
		if (q[i].kind==3) printf(&quot;%d\n&quot;,b[ans[i]]);
	return 0;
}<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 31111
#define inf 999999999
int a[NN],b[NN],c[NN],d[NN],kind[NN],id[NN],K[NN],ans[NN],id1[NN],id2[NN],have[NN];
int n,m,num;
void change(int i,int x)
{
	for (;i&lt;=n;i+=(i&amp;-i)) c[i]+=x;
}
int getsum(int i)
{
	int res=0;
	for (;i;i-=(i&amp;-i)) res+=c[i];
	return res;
}
void solve(int head,int tail,int l,int r)//按时间进行分治
{
	if (head&gt;tail) return;//IMIMIMIM
	int i,mid,t,j,k;
	if (l==r)//l==r即已经得到了答案
	{
		for (i=head;i&lt;=tail;i++)
			if (kind[id[i]]==3) ans[id[i]]=l;
		return;
	}
	mid=(l+r)&gt;&gt;1;
	for (i=head;i&lt;=tail;i++)
	{
		t=id[i];
		if (kind[t]==3) d[t]=getsum(b[t])-getsum(a[t]-1);
		else if (kind[t]==1&amp;&amp;b[t]&lt;=mid) change(a[t],1);
		else if (kind[t]==2&amp;&amp;b[t]&lt;=mid) change(a[t],-1);
	}
	for (i=head;i&lt;=tail;i++)//消除影响
	{
		t=id[i];
		if (kind[t]==1&amp;&amp;b[t]&lt;=mid) change(a[t],-1);
		else if (kind[t]==2&amp;&amp;b[t]&lt;=mid) change(a[t],1);
	}
	for (i=j=0,k=head;k&lt;=tail;k++)
	{
		t=id[k];
		if (kind[t]!=3)
			if (b[t]&lt;=mid) id1[++i]=t;
			else id2[++j]=t;
		else
			if (have[t]+d[t]&gt;=K[t]) id1[++i]=t;
			else have[t]+=d[t],id2[++j]=t;
	}
	for (k=1;k&lt;=i;k++) id[head+k-1]=id1[k];
	for (k=1;k&lt;=j;k++) id[head+i+k-1]=id2[k];
	solve(head,head+i-1,l,mid);
	solve(head+i,tail,mid+1,r);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;c[i]);
		num++,kind[num]=1,a[num]=i,b[num]=c[i],id[num]=num;
	}
	for (i=1;i&lt;=m;i++)
	{
		char ch=getchar();
		while (ch!='C'&amp;&amp;ch!='Q') ch=getchar();
		if (ch=='C')
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			num++,kind[num]=2,a[num]=x,b[num]=c[x],id[num]=num;
			c[x]=y;
			num++,kind[num]=1,a[num]=x,b[num]=c[x],id[num]=num;
		}
		else
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			num++,kind[num]=3,a[num]=x,b[num]=y,K[num]=z,id[num]=num;
		}
	}
	memset(c,0,sizeof(c));
	solve(1,num,0,inf);
	for (i=1;i&lt;=num;i++)
		if (kind[i]==3) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=30005;
int b[NN],ans[NN],id[NN],id1[NN],id2[NN],c[NN],temp[NN],have[NN],a[NN];
int n,m,tot; 
struct info
{
	int kind,x,y,K;
	info(int a=0,int b=0,int c=0,int d=0) {kind=a,x=b,y=c,K=d;}
} q[NN];
inline int cha(int x)
{
	int l=1,r=b[0];
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (b[mid]==x) return mid;
		if (b[mid]&gt;x) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
inline void change(int i,int x)
{
	for (;i&lt;=b[0];i+=i&amp;-i) c[i]+=x;
}
inline int getsum(int i)
{
	int res=0;
	for (;i;i-=i&amp;-i) res+=c[i];
	return res;
}
inline void clear(int i)
{
	for (;i&lt;=b[0];i+=i&amp;-i) c[i]=0;
}
void work(int l,int r,int head,int tail)
{
	if (head&gt;tail) return;
	if (l==r)
	{
		for (int i=head;i&lt;=tail;i++) ans[id[i]]=l;
		return;
	}
	int mid=(l+r)&gt;&gt;1,i,j,k;
	bool flag=false;
	for (i=head;i&lt;=tail;i++)
		if (q[id[i]].kind==3) {flag=true;break;}
	if (!flag) return;
	for (i=head;i&lt;=tail;i++)
	{
		int t=id[i];
		if (q[t].kind==1&amp;&amp;q[t].y&lt;=mid) change(q[t].x,1);
		else if (q[t].kind==2&amp;&amp;q[t].y&lt;=mid) change(q[t].x,-1);
		else temp[t]=getsum(q[t].y)-getsum(q[t].x-1);
	}
	for (i=head;i&lt;=tail;i++)
	{
		int t=id[i];
		if (q[t].kind==1&amp;&amp;q[t].y&lt;=mid) clear(q[t].x);
		else if (q[t].kind==2&amp;&amp;q[t].y&lt;=mid) clear(q[t].x);
	}
	for (i=j=0,k=head;k&lt;=tail;k++)
	{
		int t=id[k];
		if (q[t].kind==3)
			if (temp[t]+have[t]&gt;=q[t].K) id1[++i]=t;
			else have[t]+=temp[t],id2[++j]=t;
		else
			if (q[t].y&lt;=mid) id1[++i]=t;
			else id2[++j]=t;
	}
	int t=head;
	for (k=1;k&lt;=i;k++) id[t++]=id1[k];
	for (k=1;k&lt;=j;k++) id[t++]=id2[k];
	work(l,mid,head,head+i-1);
	work(mid+1,r,head+i,tail);
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		b[++b[0]]=a[i];
		q[++tot]=info(1,i,a[i]);
	}
	for (i=1;i&lt;=m;i++)
	{
		char ch=getchar();
		while (ch!='C'&amp;&amp;ch!='Q') ch=getchar();
		if (ch=='C')
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			b[++b[0]]=y;
			q[++tot]=info(2,x,a[x]);
			q[++tot]=info(1,x,a[x]=y);
		}
		else
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			q[++tot]=info(3,x,y,z);
		}
	}
	sort(b+1,b+b[0]+1);
	int t=1;
	for (i=2;i&lt;=b[0];i++)
		if (b[i]!=b[t]) b[++t]=b[i];
	b[0]=t;
	for (i=1;i&lt;=tot;i++)
		if (q[i].kind!=3) q[i].y=cha(q[i].y);
	for (i=1;i&lt;=tot;i++) id[i]=i;
	work(1,b[0],1,tot);
	for (i=1;i&lt;=tot;i++)
		if (q[i].kind==3) printf(&quot;%d\n&quot;,b[ans[i]]);
	return 0;
}<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=30005;
int b[NN],ans[NN],id[NN],id1[NN],id2[NN],c[NN],temp[NN],have[NN],a[NN];
int n,m,tot; 
struct info
{
	int kind,x,y,K;
	info(int a=0,int b=0,int c=0,int d=0) {kind=a,x=b,y=c,K=d;}
} q[NN];
inline int cha(int x)
{
	int l=1,r=b[0];
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (b[mid]==x) return mid;
		if (b[mid]&gt;x) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
inline void change(int i,int x)
{
	for (;i&lt;=b[0];i+=i&amp;-i) c[i]+=x;
}
inline int getsum(int i)
{
	int res=0;
	for (;i;i-=i&amp;-i) res+=c[i];
	return res;
}
inline void clear(int i)
{
	for (;i&lt;=b[0];i+=i&amp;-i) c[i]=0;
}
void work(int l,int r,int head,int tail)
{
	if (head&gt;tail) return;
	if (l==r)
	{
		for (int i=head;i&lt;=tail;i++) ans[id[i]]=l;
		return;
	}
	int mid=(l+r)&gt;&gt;1,i,j,k;
	bool flag=false;
	for (i=head;i&lt;=tail;i++)
		if (q[id[i]].kind==3) {flag=true;break;}
	if (!flag) return;
	for (i=head;i&lt;=tail;i++)
	{
		int t=id[i];
		if (q[t].kind==1&amp;&amp;q[t].y&lt;=mid) change(q[t].x,1);
		else if (q[t].kind==2&amp;&amp;q[t].y&lt;=mid) change(q[t].x,-1);
		else temp[t]=getsum(q[t].y)-getsum(q[t].x-1);
	}
	for (i=head;i&lt;=tail;i++)
	{
		int t=id[i];
		if (q[t].kind==1&amp;&amp;q[t].y&lt;=mid) clear(q[t].x);
		else if (q[t].kind==2&amp;&amp;q[t].y&lt;=mid) clear(q[t].x);
	}
	for (i=j=0,k=head;k&lt;=tail;k++)
	{
		int t=id[k];
		if (q[t].kind==3)
			if (temp[t]+have[t]&gt;=q[t].K) id1[++i]=t;
			else have[t]+=temp[t],id2[++j]=t;
		else
			if (q[t].y&lt;=mid) id1[++i]=t;
			else id2[++j]=t;
	}
	int t=head;
	for (k=1;k&lt;=i;k++) id[t++]=id1[k];
	for (k=1;k&lt;=j;k++) id[t++]=id2[k];
	work(l,mid,head,head+i-1);
	work(mid+1,r,head+i,tail);
}
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		b[++b[0]]=a[i];
		q[++tot]=info(1,i,a[i]);
	}
	for (i=1;i&lt;=m;i++)
	{
		char ch=getchar();
		while (ch!='C'&amp;&amp;ch!='Q') ch=getchar();
		if (ch=='C')
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			b[++b[0]]=y;
			q[++tot]=info(2,x,a[x]);
			q[++tot]=info(1,x,a[x]=y);
		}
		else
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			q[++tot]=info(3,x,y,z);
		}
	}
	sort(b+1,b+b[0]+1);
	int t=1;
	for (i=2;i&lt;=b[0];i++)
		if (b[i]!=b[t]) b[++t]=b[i];
	b[0]=t;
	for (i=1;i&lt;=tot;i++)
		if (q[i].kind!=3) q[i].y=cha(q[i].y);
	for (i=1;i&lt;=tot;i++) id[i]=i;
	work(1,b[0],1,tot);
	for (i=1;i&lt;=tot;i++)
		if (q[i].kind==3) printf(&quot;%d\n&quot;,b[ans[i]]);
	return 0;
}<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=30005;
int b[NN],ans[NN],id[NN],id1[NN],id2[NN],c[NN],temp[NN],have[NN],a[NN];
int n,m,tot; 
struct info
{
	int kind,x,y,K;
	info(int a=0,int b=0,int c=0,int d=0) {kind=a,x=b,y=c,K=d;}
} q[NN];
inline int cha(int x)
{
	int l=1,r=b[0];
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (b[mid]==x) return mid;
		if (b[mid]&gt;x) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
inline void change(int i,int x)
{
	for (;i&lt;=b[0];i+=i&amp;-i) c[i]+=x;
}
inline int getsum(int i)
{
	int res=0;
	for (;i;i-=i&amp;-i) res+=c[i];
	return res;
}
inline void clear(int i)
{
	for (;i&lt;=b[0];i+=i&amp;-i) c[i]=0;
}
void work(int l,int r,int head,int tail)
{
	if (head&gt;tail) return;
	if (l==r)
	{
		for (int i=head;i&lt;=tail;i++) ans[id[i]]=l;
		return;
	}
	int mid=(l+r)&gt;&gt;1,i,j,k;
	bool flag=false;
	for (i=head;i&lt;=tail;i++)
		if (q[id[i]].kind==3) {flag=true;break;}
	if (!flag) return;
	for (i=head;i&lt;=tail;i++)
	{
		int t=id[i];
		if (q[t].kind==1&amp;&amp;q[t].y&lt;=mid) change(q[t].x,1);
		else if (q[t].kind==2&amp;&amp;q[t].y&lt;=mid) change(q[t].x,-1);
		else temp[t]=getsum(q[t].y)-getsum(q[t].x-1);
	}
	for (i=head;i&lt;=tail;i++)
	{
		int t=id[i];
		if (q[t].kind==1&amp;&amp;q[t].y&lt;=mid) clear(q[t].x);
		else if (q[t].kind==2&amp;&amp;q[t].y&lt;=mid) clear(q[t].x);
	}
	for (i=j=0,k=head;k&lt;=tail;k++)
	{
		int t=id[k];
		if (q[t].kind==3)
			if (temp[t]+have[t]&gt;=q[t].K) id1[++i]=t;
			else have[t]+=temp[t],id2[++j]=t;
		else
			if (q[t].y&lt;=mid) id1[++i]=t;
			else id2[++j]=t;
	}
	int t=head;
	for (k=1;k&lt;=i;k++) id[t++]=id1[k];
	for (k=1;k&lt;=j;k++) id[t++]=id2[k];
	work(l,mid,head,head+i-1);
	work(mid+1,r,head+i,tail);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		b[++b[0]]=a[i];
		q[++tot]=info(1,i,a[i]);
	}
	for (i=1;i&lt;=m;i++)
	{
		char ch=getchar();
		while (ch!='C'&amp;&amp;ch!='Q') ch=getchar();
		if (ch=='C')
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			b[++b[0]]=y;
			q[++tot]=info(2,x,a[x]);
			q[++tot]=info(1,x,a[x]=y);
		}
		else
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			q[++tot]=info(3,x,y,z);
		}
	}
	sort(b+1,b+b[0]+1);
	int t=1;
	for (i=2;i&lt;=b[0];i++)
		if (b[i]!=b[t]) b[++t]=b[i];
	b[0]=t;
	for (i=1;i&lt;=tot;i++)
		if (q[i].kind!=3) q[i].y=cha(q[i].y);
	for (i=1;i&lt;=tot;i++) id[i]=i;
	work(1,b[0],1,tot);
	for (i=1;i&lt;=tot;i++)
		if (q[i].kind==3) printf(&quot;%d\n&quot;,b[ans[i]]);
	return 0;
}<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 1000000001
#define lowbit(i) (i&amp;-i)
int a[91000],S[9100000],lc[9100000],rc[9100000],root[91000],cur[91000],vt[91000];
int n,m,SIZE,flag;
void ins(int &amp;v,int ll,int rr,int x,int kind)
{
	if (!v) v=++SIZE;
	S[v]+=kind;
	if (rr-ll==1) return;
	int mid=(ll+rr)&gt;&gt;1;
	if (x&lt;mid) ins(lc[v],ll,mid,x,kind);
	else ins(rc[v],mid,rr,x,kind);
}
void change(int i,int x,int kind)
{
	for (;i&lt;=n;i+=lowbit(i)) ins(root[i],0,inf,x,kind);
}
int getsum(int i)
{
	int res=0;
	for (;i&gt;0;i-=lowbit(i)) res+=S[lc[cur[i]]];
	return res;
}
void clear(int i)//就是刚开始把所有的都赋为root来查询 
{
	for (;i&gt;0;i-=lowbit(i)) cur[i]=root[i];
}
void turn(int i,int kind)
{
	for (;i&gt;0;i-=lowbit(i))
		if (vt[i]!=flag)
		{
			vt[i]=flag;
			if (kind) cur[i]=rc[cur[i]];
			else cur[i]=lc[cur[i]];
		}
}
int main()
/*
这是个啥思想呢？如果我们修改了a[i]，那么理论上应该修改i..n所有的线段树。可是这样复杂度太高。
其实可持久化线段树就是用[l,r]区间的线段树来计算答案，只不过不是求出这个线段树而是用tree[r]-tree[l-1]
来求。tree[i]表示1..i的线段树。那么这种形式我们可以用树状数组来表示，即1..i的线段树用1..i的前缀和线段树
来表示。那么修改只需修改一个点，查询就查询前缀和就行了。其实就是用前缀和表示线段树，跟用前缀和表示数一样。
*/
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	int i;
	char ch;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),change(i,a[i],1);//修改的是i..n区间，所以在这里+1，其实就是差分 
	scanf(&quot;\n&quot;);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%c&quot;,&amp;ch);
		int x,y,ll,rr,K;
		if (ch=='C')
		{
			scanf(&quot;%d%d\n&quot;,&amp;x,&amp;y);
			change(x,a[x],-1);
			change(x,y,1);
			a[x]=y;//这一句千万不要忘了 
		}
		else
		{
			scanf(&quot;%d%d%d\n&quot;,&amp;ll,&amp;rr,&amp;K);
			int l=0,r=inf;
			clear(rr);
			clear(ll-1);
			while (r-l&gt;1)//这并不是二分答案，而是在模拟线段树 
			{
				int tmp=getsum(rr)-getsum(ll-1);//这就是可持久化的核心 
				++flag;//为了防止重复而设的 
				int mid=(l+r)&gt;&gt;1;
				if (K&lt;=tmp)
				{
					r=mid;
					turn(rr,0);
					turn(ll-1,0);
				}
				else
				{
					K-=tmp;//这一句也千万不要漏了 
					l=mid;
					turn(rr,1);
					turn(ll-1,1);
				}
			}
			printf(&quot;%d\n&quot;,l);
		}
	}
	return 0;
}<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=30005;
int b[NN],ans[NN],id[NN],id1[NN],id2[NN],c[NN],temp[NN],have[NN],a[NN];
int n,m,tot; 
struct info
{
    int kind,x,y,K;
    info(int a=0,int b=0,int c=0,int d=0) {kind=a,x=b,y=c,K=d;}
} q[NN];
inline int cha(int x)
{
    int l=1,r=b[0];
    while (l&lt;=r)
    {
        int mid=(l+r)&gt;&gt;1;
        if (b[mid]==x) return mid;
        if (b[mid]&gt;x) r=mid-1;
        else l=mid+1;
    }
    return -1;
}
inline void change(int i,int x)
{
    for (;i&lt;=b[0];i+=i&amp;-i) c[i]+=x;
}
inline int getsum(int i)
{
    int res=0;
    for (;i;i-=i&amp;-i) res+=c[i];
    return res;
}
inline void clear(int i)
{
    for (;i&lt;=b[0];i+=i&amp;-i) c[i]=0;
}
void work(int l,int r,int head,int tail)
{
    if (head&gt;tail) return;
    if (l==r)
    {
        for (int i=head;i&lt;=tail;i++) ans[id[i]]=l;
        return;
    }
    int mid=(l+r)&gt;&gt;1,i,j,k;
    for (i=head;i&lt;=tail;i++)
    {
        int t=id[i];
        if (q[t].kind==1&amp;&amp;q[t].y&lt;=mid) change(q[t].x,1);
        else if (q[t].kind==2&amp;&amp;q[t].y&lt;=mid) change(q[t].x,-1);
        else temp[t]=getsum(q[t].y)-getsum(q[t].x-1);
    }
    for (i=head;i&lt;=tail;i++)
    {
        int t=id[i];
        if (q[t].kind==1&amp;&amp;q[t].y&lt;=mid) clear(q[t].x);
        else if (q[t].kind==2&amp;&amp;q[t].y&lt;=mid) clear(q[t].x);
    }
    for (i=j=0,k=head;k&lt;=tail;k++)
    {
        int t=id[k];
        if (q[t].kind==3)
            if (temp[t]+have[t]&gt;=q[t].K) id1[++i]=t;
            else have[t]+=temp[t],id2[++j]=t;
        else
            if (q[t].y&lt;=mid) id1[++i]=t;
            else id2[++j]=t;
    }
    int t=head;
    for (k=1;k&lt;=i;k++) id[t++]=id1[k];
    for (k=1;k&lt;=j;k++) id[t++]=id2[k];
    work(l,mid,head,head+i-1);
    work(mid+1,r,head+i,tail);
}
int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    int i,x,y,z;
    for (i=1;i&lt;=n;i++)
    {
        scanf(&quot;%d&quot;,&amp;a[i]);
        b[++b[0]]=a[i];
        q[++tot]=info(1,i,a[i]);
    }
    for (i=1;i&lt;=m;i++)
    {
        char ch=getchar();
        while (ch!='C'&amp;&amp;ch!='Q') ch=getchar();
        if (ch=='C')
        {
            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
            b[++b[0]]=y;
            q[++tot]=info(2,x,a[x]);
            q[++tot]=info(1,x,a[x]=y);
        }
        else
        {
            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
            q[++tot]=info(3,x,y,z);
        }
    }
    sort(b+1,b+b[0]+1);
    for (i=1;i&lt;=tot;i++)
        if (q[i].kind!=3) q[i].y=cha(q[i].y);
    for (i=1;i&lt;=tot;i++) id[i]=i;
    work(1,b[0],1,tot);
    for (i=1;i&lt;=tot;i++)
        if (q[i].kind==3) printf(&quot;%d\n&quot;,b[ans[i]]);
    return 0;
}<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=30005;
int b[NN],ans[NN],id[NN],id1[NN],id2[NN],c[NN],temp[NN],have[NN],a[NN];
int n,m,tot; 
struct info
{
    int kind,x,y,K;
    info(int a=0,int b=0,int c=0,int d=0) {kind=a,x=b,y=c,K=d;}
} q[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
inline int cha(int x)
{
    int l=1,r=b[0];
    while (l&lt;=r)
    {
        int mid=(l+r)&gt;&gt;1;
        if (b[mid]==x) return mid;
        if (b[mid]&gt;x) r=mid-1;
        else l=mid+1;
    }
    return -1;
}
inline void change(int i,int x)
{
    for (;i&lt;=b[0];i+=i&amp;-i) c[i]+=x;
}
inline int getsum(int i)
{
    int res=0;
    for (;i;i-=i&amp;-i) res+=c[i];
    return res;
}
inline void clear(int i)
{
    for (;i&lt;=b[0];i+=i&amp;-i) c[i]=0;
}
void work(int l,int r,int head,int tail)
{
    if (head&gt;tail) return;
    if (l==r)
    {
        for (int i=head;i&lt;=tail;i++) ans[id[i]]=l;
        return;
    }
    int mid=(l+r)&gt;&gt;1,i,j,k;
    for (i=head;i&lt;=tail;i++)
    {
        int t=id[i];
        if (q[t].kind==1&amp;&amp;q[t].y&lt;=mid) change(q[t].x,1);
        else if (q[t].kind==2&amp;&amp;q[t].y&lt;=mid) change(q[t].x,-1);
        else temp[t]=getsum(q[t].y)-getsum(q[t].x-1);
    }
    for (i=head;i&lt;=tail;i++)
    {
        int t=id[i];
        if (q[t].kind==1&amp;&amp;q[t].y&lt;=mid) clear(q[t].x);
        else if (q[t].kind==2&amp;&amp;q[t].y&lt;=mid) clear(q[t].x);
    }
    for (i=j=0,k=head;k&lt;=tail;k++)
    {
        int t=id[k];
        if (q[t].kind==3)
            if (temp[t]+have[t]&gt;=q[t].K) id1[++i]=t;
            else have[t]+=temp[t],id2[++j]=t;
        else
            if (q[t].y&lt;=mid) id1[++i]=t;
            else id2[++j]=t;
    }
    int t=head;
    for (k=1;k&lt;=i;k++) id[t++]=id1[k];
    for (k=1;k&lt;=j;k++) id[t++]=id2[k];
    work(l,mid,head,head+i-1);
    work(mid+1,r,head+i,tail);
}
int main()
{
    read(n),read(m);
    int i,x,y,z;
    for (i=1;i&lt;=n;i++)
    {
        read(a[i]);
        b[++b[0]]=a[i];
        q[++tot]=info(1,i,a[i]);
    }
    for (i=1;i&lt;=m;i++)
    {
        char ch=getchar();
        while (ch!='C'&amp;&amp;ch!='Q') ch=getchar();
        if (ch=='C')
        {
            read(x),read(y);
            b[++b[0]]=y;
            q[++tot]=info(2,x,a[x]);
            q[++tot]=info(1,x,a[x]=y);
        }
        else
        {
            read(x),read(y),read(z);
            q[++tot]=info(3,x,y,z);
        }
    }
    sort(b+1,b+b[0]+1);
    for (i=1;i&lt;=tot;i++)
        if (q[i].kind!=3) q[i].y=cha(q[i].y);
    for (i=1;i&lt;=tot;i++) id[i]=i;
    work(1,b[0],1,tot);
    for (i=1;i&lt;=tot;i++)
        if (q[i].kind==3) printf(&quot;%d\n&quot;,b[ans[i]]);
    return 0;
}<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=30001;
int b[NN],ans[NN],id[NN],id1[NN],id2[NN],c[NN],temp[NN],have[NN],a[NN];
int n,m,tot; 
struct info
{
    int kind,x,y,K;
    info(int a=0,int b=0,int c=0,int d=0) {kind=a,x=b,y=c,K=d;}
} q[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
inline int cha(int x)
{
    int l=1,r=b[0];
    while (l&lt;=r)
    {
        int mid=(l+r)&gt;&gt;1;
        if (b[mid]==x) return mid;
        if (b[mid]&gt;x) r=mid-1;
        else l=mid+1;
    }
    return -1;
}
inline void change(int i,int x)
{
    for (;i&lt;=b[0];i+=i&amp;-i) c[i]+=x;
}
inline int getsum(int i)
{
    int res=0;
    for (;i;i-=i&amp;-i) res+=c[i];
    return res;
}
inline void clear(int i)
{
    for (;i&lt;=b[0];i+=i&amp;-i) c[i]=0;
}
void work(int l,int r,int head,int tail)
{
    if (head&gt;tail) return;
    if (l==r)
    {
        for (int i=head;i&lt;=tail;i++) ans[id[i]]=l;
        return;
    }
    int mid=(l+r)&gt;&gt;1,i,j,k;
    for (i=head;i&lt;=tail;i++)
    {
        int t=id[i];
        if (q[t].kind==1&amp;&amp;q[t].y&lt;=mid) change(q[t].x,1);
        else if (q[t].kind==2&amp;&amp;q[t].y&lt;=mid) change(q[t].x,-1);
        else temp[t]=getsum(q[t].y)-getsum(q[t].x-1);
    }
    for (i=head;i&lt;=tail;i++)
    {
        int t=id[i];
        if (q[t].kind==1&amp;&amp;q[t].y&lt;=mid) clear(q[t].x);
        else if (q[t].kind==2&amp;&amp;q[t].y&lt;=mid) clear(q[t].x);
    }
    for (i=j=0,k=head;k&lt;=tail;k++)
    {
        int t=id[k];
        if (q[t].kind==3)
            if (temp[t]+have[t]&gt;=q[t].K) id1[++i]=t;
            else have[t]+=temp[t],id2[++j]=t;
        else
            if (q[t].y&lt;=mid) id1[++i]=t;
            else id2[++j]=t;
    }
    int t=head;
    for (k=1;k&lt;=i;k++) id[t++]=id1[k];
    for (k=1;k&lt;=j;k++) id[t++]=id2[k];
    work(l,mid,head,head+i-1);
    work(mid+1,r,head+i,tail);
}
int main()
{
    read(n),read(m);
    int i,x,y,z;
    for (i=1;i&lt;=n;i++)
    {
        read(a[i]);
        b[++b[0]]=a[i];
        q[++tot]=info(1,i,a[i]);
    }
    for (i=1;i&lt;=m;i++)
    {
        char ch=getchar();
        while (ch!='C'&amp;&amp;ch!='Q') ch=getchar();
        if (ch=='C')
        {
            read(x),read(y);
            b[++b[0]]=y;
            q[++tot]=info(2,x,a[x]);
            q[++tot]=info(1,x,a[x]=y);
        }
        else
        {
            read(x),read(y),read(z);
            q[++tot]=info(3,x,y,z);
        }
    }
    sort(b+1,b+b[0]+1);
    for (i=1;i&lt;=tot;i++)
        if (q[i].kind!=3) q[i].y=cha(q[i].y);
    for (i=1;i&lt;=tot;i++) id[i]=i;
    work(1,b[0],1,tot);
    for (i=1;i&lt;=tot;i++)
        if (q[i].kind==3) printf(&quot;%d&quot;,b[ans[i]]),putchar('\n');
    return 0;
}<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 1000000001
const int NN=91111,AA=9101111;
int root[NN],size[AA],lc[AA],rc[AA],cur[NN],a[NN],vt[NN];
int n,m,TTT,TIME;
void ins(int &amp;v,int l,int r,int x,int kind)
{
	if (v==0) v=++TTT;
	size[v]+=kind;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid) ins(lc[v],l,mid,x,kind);
	else ins(rc[v],mid,r,x,kind);
}
inline void change(int i,int x,int kind)
{
	for (;i&lt;=n;i+=i&amp;-i)
		ins(root[i],0,inf,x,kind);
}
inline void clear(int i)
{
	for (;i;i-=i&amp;-i) cur[i]=root[i];
}
inline int getsum(int i)
{
	int res=0;
	for (;i;i-=i&amp;-i) res+=size[lc[cur[i]]];
	return res;
}
inline void turn(int i,int k)
{
	for (;i;i-=i&amp;-i)
		if (vt[i]!=TIME)
		{
			vt[i]=TIME;
			if (k==0) cur[i]=lc[cur[i]];
			else cur[i]=rc[cur[i]];
		}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,L,R,K;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		change(i,a[i],1);
	}
	for (i=1;i&lt;=m;i++)
	{
		char ch=getchar();
		while (ch!='Q'&amp;&amp;ch!='C') ch=getchar();
		if (ch=='C')
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			change(x,a[x],-1);
			change(x,a[x]=y,1);
		}
		else
		{
			scanf(&quot;%d%d%d&quot;,&amp;L,&amp;R,&amp;K);
			int l=0,r=inf;
			clear(L-1),clear(R);
			while (r-l&gt;1)
			{
				TIME++;
				int mid=(l+r)&gt;&gt;1;
				int tmp=getsum(R)-getsum(L-1);
				if (K&lt;=tmp)
				{
					turn(L-1,0),turn(R,0);
					r=mid;
				}
				else
				{
					turn(L-1,1),turn(R,1);
					l=mid;K-=tmp;
				}
			}
			printf(&quot;%d\n&quot;,l);
		}
	}
	return 0;
}<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 1000000005
const int AA=10000000;
int size[AA],lc[AA],rc[AA],root[10111],cur[10111],vt[10111],a[10111];
int n,m,TTT,TIME;
void change(int &amp;v,int l,int r,int x,int kind)
{
	if (v==0) v=++TTT;
	size[v]+=kind;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid) change(lc[v],l,mid,x,kind);
	else change(rc[v],mid,r,x,kind);
}
inline void change(int i,int x,int kind)
{
	for (;i&lt;=n;i+=i&amp;-i)
		change(root[i],0,inf,x,kind);
}
inline void clear(int i)
{
	for (;i;i-=i&amp;-i) cur[i]=root[i];
}
inline int getsum(int i)
{
	int res=0;
	for (;i;i-=i&amp;-i) res+=size[lc[cur[i]]];
	return res;
}
inline void turn(int i,int t)
{
	for (;i;i-=i&amp;-i) if (vt[i]!=TIME)
	{
		vt[i]=TIME;
		if (t==0) cur[i]=lc[cur[i]];
		else cur[i]=rc[cur[i]];
	}
}
int main()
{
	//(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,L,R,K;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		change(i,a[i],1);
	}
	for (;m;m--)
	{
		char ch=getchar();
		while (ch!='C'&amp;&amp;ch!='Q') ch=getchar();
		if (ch=='C')
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			change(x,a[x],-1);
			a[x]=y;
			change(x,a[x],1);
		}
		else
		{
			scanf(&quot;%d%d%d&quot;,&amp;L,&amp;R,&amp;K);
			clear(R),clear(L-1);
			int l=0,r=inf;
			while (r-l&gt;1)
			{
				TIME++;
				int mid=(l+r)&gt;&gt;1,tmp=getsum(R)-getsum(L-1);
				if (K&lt;=tmp)
				{
					turn(R,0),turn(L-1,0);
					r=mid;
				}
				else
				{
					turn(R,1),turn(L-1,1);
					l=mid;
					K-=tmp;
				}
			}
			printf(&quot;%d\n&quot;,l);
		}
	}
	return 0;
}<pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 1000000005
const int AA=10000111,NN=10111;
int lc[AA],rc[AA],size[AA],root[NN],cur[NN],a[NN],vt[NN];
int n,m,TTT,TIME;
void ins(int &amp;v,int l,int r,int x,int kind)
{
	if (!v) v=++TTT;
	size[v]+=kind;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid) ins(lc[v],l,mid,x,kind);
	else ins(rc[v],mid,r,x,kind);
}
inline void change(int i,int x,int kind)
{
	for (;i&lt;=n;i+=i&amp;-i)
		ins(root[i],0,inf,x,kind);
}
inline void clear(int i)
{
	for (;i;i-=i&amp;-i)
		cur[i]=root[i];
}
inline int getsum(int i)
{
	int res=0;
	for (;i;i-=i&amp;-i)
		res+=size[lc[cur[i]]];
	return res;
}
inline void turn(int i,int t)
{
	for (;i;i-=i&amp;-i) if (vt[i]!=TIME)
	{
		vt[i]=TIME;
		cur[i]=(t==0)?lc[cur[i]]:rc[cur[i]];
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,L,R,K;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		change(i,a[i],1);
	}
	for (;m;m--)
	{
		char ch=getchar();
		while (ch!='Q'&amp;&amp;ch!='C') ch=getchar();
		if (ch=='C')
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			change(x,a[x],-1);
			a[x]=y;
			change(x,a[x],1);
		}
		else
		{
			scanf(&quot;%d%d%d&quot;,&amp;L,&amp;R,&amp;K);
			clear(R),clear(L-1);
			int l=0,r=inf;
			while (r-l&gt;1)
			{
				int mid=(l+r)&gt;&gt;1,tmp=getsum(R)-getsum(L-1);
				TIME++;
				if (K&lt;=tmp)
				{
					r=mid;
					turn(R,0),turn(L-1,0);
				}
				else
				{
					K-=tmp;
					l=mid;
					turn(R,1),turn(L-1,1);
				}
			}
			printf(&quot;%d\n&quot;,l);
		}
	}
	return 0;
}<pre><h2>Problem1901</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#define NN 21010
#define lowbit(x) (x&amp;(-x))
using namespace std;
int n,m,p,tot=0,cc=0,cnt,sa,sb;
int lc[NN*200],rc[NN*200],sum[NN*200];
int root[NN];
int a[NN],b[NN],k[NN]={0},tmp[NN*2],num[NN*2];
int ss[30],tt[30];
char ch;
void update(int last,int &amp;p,int l,int r,int w,int x){
	p=++cc;
	sum[p]=sum[last]+x;lc[p]=lc[last];rc[p]=rc[last];
	if (l==r)return;
	int mid=(l+r)&gt;&gt;1;
	if (w&lt;=mid)update(lc[last],lc[p],l,mid,w,x);
	else update(rc[last],rc[p],mid+1,r,w,x);
}

int query(int l,int r,int k){
	if (l==r)return l;
	int t,sum1=0,sum2=0;
	for (int i=1;i&lt;=sa;i++)sum1+=sum[lc[ss[i]]];
	for (int i=1;i&lt;=sb;i++)sum2+=sum[lc[tt[i]]];
	t=sum2-sum1;
	int mid=(l+r)&gt;&gt;1;
	if (k&lt;=t){
		for (int i=1;i&lt;=sa;i++)ss[i]=lc[ss[i]];
		for (int i=1;i&lt;=sb;i++)tt[i]=lc[tt[i]];
		return query(l,mid,k);
	}
	else{
		for (int i=1;i&lt;=sa;i++)ss[i]=rc[ss[i]];
		for (int i=1;i&lt;=sb;i++)tt[i]=rc[tt[i]];
		return query(mid+1,r,k-t);
	}
}

int main(){

	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	for (int i=1;i&lt;=n;i++){
		scanf(&quot;%d&quot;,&amp;num[i]);
		tmp[i]=num[i];
	}
	scanf(&quot;\n&quot;);
	tot=n;
	for (int i=1;i&lt;=m;i++){
		int t=scanf(&quot;%c&quot;,&amp;ch);
		if (ch=='Q')scanf(&quot;%d%d%d\n&quot;,&amp;a[i],&amp;b[i],&amp;k[i]);
		else{
			scanf(&quot;%d%d\n&quot;,&amp;a[i],&amp;b[i]);
			tmp[++tot]=b[i];
		}
	}
	sort(tmp+1,tmp+1+tot);
	cnt=unique(tmp+1,tmp+tot+1)-tmp-1;
	for (int i=1;i&lt;=n;i++){
		int now=lower_bound(tmp+1,tmp+cnt+1,num[i])-tmp;
		for (int j=i;j&lt;=n;j+=lowbit(j)){
			update(root[j],root[j],1,cnt,now,1);
		}
	}
	for (int i=1;i&lt;=m;i++){
		if (k[i]==0){
			int now=lower_bound(tmp+1,tmp+cnt+1,num[a[i]])-tmp;
			for (int j=a[i];j&lt;=n;j+=lowbit(j))
				update(root[j],root[j],1,cnt,now,-1);
			num[a[i]]=b[i];
			now=lower_bound(tmp+1,tmp+cnt+1,b[i])-tmp;
			for (int j=a[i];j&lt;=n;j+=lowbit(j))
				update(root[j],root[j],1,cnt,now,1);
		}
		else{
			a[i]--;sa=sb=0;
			for (int j=a[i];j&gt;0;j-=lowbit(j))
				ss[++sa]=root[j];
			for (int j=b[i];j&gt;0;j-=lowbit(j))
				tt[++sb]=root[j];
			int now=query(1,cnt,k[i]);
			printf(&quot;%d\n&quot;,tmp[now]);
		}
	}
	return 0;
}<pre><h2>Problem1901</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#define NN 10020
#define N 3501000
#define lowbit(x) (x&amp;(-x))
using namespace std;
int n,m,cc=0,tot,cnt,sa,sb,sum1,sum2;
int lc[N],rc[N],sum[N];
int root[NN],a[NN],b[NN],k[NN]={0},num[NN],tmp[NN*2];
int L[50],R[50];

void update(int last,int &amp;p,int l,int r,int w,int x){
	p=++cc;
	sum[p]=sum[last]+x;
	lc[p]=lc[last];rc[p]=rc[last];
	if (l==r)return;
	int mid=(l+r)&gt;&gt;1;
	if (w&lt;=mid)update(lc[last],lc[p],l,mid,w,x);
	else update(rc[last],rc[p],mid+1,r,w,x);
}

int query(int l,int r,int k){
	sum1=sum2=0;
	if(l==r)return l;
	for (int i=1;i&lt;=sa;i++)
		sum1+=sum[lc[L[i]]];
	for (int i=1;i&lt;=sb;i++)
		sum2+=sum[lc[R[i]]];
	int t=sum2-sum1;
	int mid=(l+r)&gt;&gt;1;
	if (k&lt;=t){
		for (int i=1;i&lt;=sa;i++)L[i]=lc[L[i]];
		for (int i=1;i&lt;=sb;i++)R[i]=lc[R[i]];
		return query(l,mid,k);
	}
	else{
		for (int i=1;i&lt;=sa;i++)L[i]=rc[L[i]];
		for (int i=1;i&lt;=sb;i++)R[i]=rc[R[i]];
		return query(mid+1,r,k-t);
	}	
}

int main(){
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	for (int i=1;i&lt;=n;i++){
		scanf(&quot;%d&quot;,&amp;num[i]);
		tmp[i]=num[i];
	}
	scanf(&quot;\n&quot;);
	tot=n;
	char ch;
	for (int i=1;i&lt;=m;i++){
		scanf(&quot;%c%d%d&quot;,&amp;ch,&amp;a[i],&amp;b[i]);
		if (ch=='Q')scanf(&quot;%d&quot;,&amp;k[i]);
		else tmp[++tot]=b[i];
		scanf(&quot;\n&quot;);
	}
	sort(tmp+1,tmp+1+tot);
	cnt=unique(tmp+1,tmp+1+tot)-tmp-1;
	for (int i=1;i&lt;=n;i++){
		int now=lower_bound(tmp+1,tmp+1+cnt,num[i])-tmp;
		for (int j=i;j&lt;=n;j+=lowbit(j))
			update(root[j],root[j],1,cnt,now,1);
	}
	for (int i=1;i&lt;=m;i++){
		int now;
		if (k[i]){
			sa=sb=0;
			a[i]--;
			for (int j=a[i];j&gt;0;j-=lowbit(j))
				L[++sa]=root[j];
			for (int j=b[i];j&gt;0;j-=lowbit(j))
				R[++sb]=root[j];
			now=query(1,cnt,k[i]);
			printf(&quot;%d\n&quot;,tmp[now]);
		}
		else{
			now=lower_bound(tmp+1,tmp+1+cnt,num[a[i]])-tmp;
			for (int j=a[i];j&lt;=n;j+=lowbit(j))
				update(root[j],root[j],1,cnt,now,-1);
			num[a[i]]=b[i];
			now=lower_bound(tmp+1,tmp+1+cnt,b[i])-tmp;
			for (int j=a[i];j&lt;=n;j+=lowbit(j))
				update(root[j],root[j],1,cnt,now,1);
		}
	}
	return 0;
}
<pre><h2>Problem1901</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#define lc(x) son[x][0]
#define rc(x) son[x][1]
#define lowbit(x) (x&amp;(-x))
#define srep(i,s,t) for(int i=s;i&lt;=t;i+=lowbit(i))
#define sred(i,s) for (int i=s;i;i-=lowbit(i))
#define rep(i,s,t) for (int i=s;i&lt;=t;i++)
#define NN 20091
#define N 4000009
using namespace std;
int n,m,p,cnt=0,cc=0,sa,sb;
int son[N][2],S[N],root[NN];
int a[NN],b[NN],k[NN],tmp[NN],num[NN];
int ta[30],tb[30];
char s[10];

inline int read()
{
	int t=0,f=1;char ch=getchar();
	while(ch&lt;'0'||ch&gt;'9'){if (ch=='-')f=-1;ch=getchar();}
	while(ch&gt;='0'&amp;&amp;ch&lt;='9')t=t*10+ch-'0',ch=getchar();
	return f*t;
}

void Add(int last,int &amp;p,int l,int r,int w,int x)
{
	p=++cc;
	S[p]=S[last]+x;
	lc(p)=lc(last),rc(p)=rc(last);
	if(l==r)return ;
	int mid=l+r&gt;&gt;1;
	if(w&lt;=mid)Add(lc(last),lc(p),l,mid,w,x);
	else Add(rc(last),rc(p),mid+1,r,w,x);
	
}

int query(int l,int r,int k)
{
	if(l==r)return l;
	int t,sum1=0,sum2=0,mid=(l+r)&gt;&gt;1;
	rep(i,1,sa)sum1+=S[lc(ta[i])];
	rep(i,1,sb)sum2+=S[lc(tb[i])];
	t=sum2-sum1;
	if (k&lt;=t)
	{
		rep(i,1,sa)ta[i]=lc(ta[i]);
		rep(i,1,sb)tb[i]=lc(tb[i]);
		return query(l,mid,k);
	}
	else
	{
		rep(i,1,sa)ta[i]=rc(ta[i]);
		rep(i,1,sb)tb[i]=rc(tb[i]);
		return query(mid+1,r,k-t);
	}
}

int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	n=read();m=read();
	rep(i,1,n)
		tmp[i]=num[i]=read();
	cnt=n;
	rep(i,1,m)
	{
		scanf(&quot;%s&quot;,s);
		a[i]=read();b[i]=read();
		if (s[0]=='Q')k[i]=read();
		else tmp[++cnt]=b[i];
	}
	sort(tmp+1,tmp+1+cnt);
	cnt=unique(tmp+1,tmp+1+cnt)-tmp-1;
	rep(i,1,n)
	{
		int now=lower_bound(tmp+1,tmp+1+cnt,num[i])-tmp;
		srep(j,i,n)
			Add(root[j],root[j],1,cnt,now,1);
	}
	rep(i,1,m)
	{
		if (!k[i])
		{
			int now=lower_bound(tmp+1,tmp+1+cnt,num[a[i]])-tmp;
			srep(j,a[i],n)
				Add(root[j],root[j],1,cnt,now,-1);
			now=lower_bound(tmp+1,tmp+1+cnt,b[i])-tmp;
			num[a[i]]=b[i];
			srep(j,a[i],n)
				Add(root[j],root[j],1,cnt,now,1);
		}
		else
		{
			a[i]--;sa=sb=0;
			sred(j,a[i])ta[++sa]=root[j];
			sred(j,b[i])tb[++sb]=root[j];
			int now=query(1,cnt,k[i]);
			printf(&quot;%d\n&quot;,tmp[now]);
		}
	}
	return 0;
}<pre><h2>Problem1901</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define inf 1e9
#define NN 100900
#define N 4000010
#define lc(x) son[x][0]
#define rc(x) son[x][1]
#define lowbit(x) (x&amp;(-x))
#define rep(i,s,t) for (int i=s;i&lt;=t;i++)
#define srep(i,s,t) for(int i=s;i&lt;=t;i+=lowbit(i))
#define sred(i,t,s) for(int i=t;i&gt;=s;i-=lowbit(i))
using namespace std;
int son[N][2],num[N],S[N],tmp[NN],a[NN],b[NN],k[NN],root[NN];
int n,m,cc=0,sa,sb,ta[400],tb[400];

inline int read()
{
	int t=0,f=1;char ch=getchar();
	while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch&gt;='0'&amp;&amp;ch&lt;='9')t=t*10+ch-'0',ch=getchar();
	return t*f;
}

void update(int la,int &amp;p,int l,int r,int w,int x)
{
	p=++cc;
	lc(p)=lc(la),rc(p)=rc(la),S[p]=S[la]+x;
	if(l==r)return;
	int mid=(l+r)&gt;&gt;1;
	if(w&lt;=mid)update(lc(la),lc(p),l,mid,w,x);
	else update(rc(la),rc(p),mid+1,r,w,x);
}

int query(int l,int r,int k)
{
	if(l==r)return l;
	int mid=(l+r)&gt;&gt;1,sum1=0,sum2=0,t;
	rep(i,1,sa)sum1+=S[lc(ta[i])];
	rep(i,1,sb)sum2+=S[lc(tb[i])];
	t=sum2-sum1;
	if(t&gt;=k)
	{
		rep(i,1,sa)ta[i]=lc(ta[i]);
		rep(i,1,sb)tb[i]=lc(tb[i]);
		return query(l,mid,k);
	}
	else
	{
		rep(i,1,sa)ta[i]=rc(ta[i]);
		rep(i,1,sb)tb[i]=rc(tb[i]);
		return query(mid+1,r,k-t);
	}
}

int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);//freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	n=read(),m=read();
	rep(i,1,n)
		num[i]=tmp[i]=read();
	int cnt=n;
	char s[10];
	rep(i,1,m)
	{
		scanf(&quot;%s&quot;,s);
		a[i]=read(),b[i]=read();
		if (s[0]=='Q')k[i]=read();
		else tmp[++cnt]=b[i];
	}
	sort(tmp+1,tmp+1+cnt);
	cnt=unique(tmp+1,tmp+1+cnt)-tmp-1;
//	rep(i,1,cnt)printf(&quot;%d &quot;,tmp[i]);
	rep(i,1,n)
	{
		int now=lower_bound(tmp+1,tmp+cnt+1,num[i])-tmp;
		srep(j,i,n)
			update(root[j],root[j],1,cnt,now,1);
	}
	rep(i,1,m)
	{
		if(k[i])                                                         
		{
			a[i]--,sa=sb=0;
			sred(j,a[i],1)
				ta[++sa]=root[j];
			sred(j,b[i],1)
				tb[++sb]=root[j];
			int x=query(1,cnt,k[i]);
			printf(&quot;%d\n&quot;,tmp[x]);
		}
		else
		{
			int now=lower_bound(tmp+1,tmp+cnt+1,num[a[i]])-tmp;
			srep(j,a[i],n)
				update(root[j],root[j],1,cnt,now,-1);
			num[a[i]]=b[i];
			now=lower_bound(tmp+1,tmp+cnt+1,b[i])-tmp;
			srep(j,a[i],n)
				update(root[j],root[j],1,cnt,now,1);	
		}
	}
	return 0;
}
<pre><h2>Problem1911</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 1001111
#define LL long long
#define INF 99999999999999999ll
#define ln printf(&quot;\n&quot;)
const double eps=1e-7;
int sum[NN],q[NN];
int n;
LL A,B,C,f[NN],h[NN],g[NN];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%lld%lld%lld&quot;,&amp;n,&amp;A,&amp;B,&amp;C);
	int i,x;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		sum[i]=sum[i-1]+x;
		f[i]=-INF;
	}
	f[0]=0,g[0]=0,h[0]=0;
	/*for (i=1;i&lt;=n;i++)
		for (j=0;j&lt;i;j++)
		{
			int x=sum[i]-sum[j];
			LL tmp=A*x*x+B*x+C+f[j];
			if (tmp&gt;f[i]) f[i]=tmp;
		}*/
	int l=0,r=1;
	q[1]=0;
	for (i=1;i&lt;=n;i++)
	{
		//printf(&quot;l=%d r=%d\n&quot;,l,r);
		int j=q[l+1],k=q[l+2];
		while (r-l&gt;1&amp;&amp;(g[k]-g[j])&gt;=sum[i]*(h[k]-h[j]))
		{
			l++;
			j=q[l+1],k=q[l+2];
		}
		j=q[l+1],x=sum[i]-sum[j];;
		f[i]=f[j]+A*x*x+B*x+C;
		g[i]=f[i]+A*sum[i]*sum[i]-B*sum[i];
		h[i]=2*A*sum[i];
		//printf(&quot;f[%d]=%lld   %d\ng[%d]=%lld\nh[%d]=%lld\n\n&quot;,i,f[i],j,i,g[i],i,h[i]);
		k=q[r],j=q[r-1];
		while (r-l&gt;1&amp;&amp;(g[k]-g[j])*1.0/(h[k]-h[j])-(g[i]-g[k])*1.0/(h[i]-h[k])&gt;eps)
		{
			r--;
			k=q[r],j=q[r-1];
		}
		q[++r]=i;
	}
	//printf(&quot;\n&quot;);
	//for (int i=1;i&lt;=n;i++)printf(&quot;%lld &quot;,f[i]);ln;
	printf(&quot;%lld\n&quot;,f[n]);
	return 0;
}
<pre><h2>Problem1911</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 1001111
#define LL long long
#define INF 99999999999999999ll
#define ln printf(&quot;\n&quot;)
const double eps=1e-7;
int sum[NN],q[NN];
int n;
LL A,B,C,f[NN],h[NN],g[NN];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%lld%lld%lld&quot;,&amp;n,&amp;A,&amp;B,&amp;C);
	int i,x;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		sum[i]=sum[i-1]+x;
		f[i]=-INF;
	}
	f[0]=0,g[0]=0,h[0]=0;
	/*for (i=1;i&lt;=n;i++)
		for (j=0;j&lt;i;j++)
		{
			int x=sum[i]-sum[j];
			LL tmp=A*x*x+B*x+C+f[j];
			if (tmp&gt;f[i]) f[i]=tmp;
		}*/
	int l=0,r=1;
	q[1]=0;
	for (i=1;i&lt;=n;i++)
	{
		//printf(&quot;l=%d r=%d\n&quot;,l,r);
		int j=q[l+1],k=q[l+2];
		while (r-l&gt;1&amp;&amp;(g[k]-g[j])&gt;=sum[i]*(h[k]-h[j]))
		{
			l++;
			j=q[l+1],k=q[l+2];
		}
		j=q[l+1],x=sum[i]-sum[j];;
		f[i]=f[j]+A*x*x+B*x+C;
		g[i]=f[i]+A*sum[i]*sum[i]-B*sum[i];
		h[i]=2*A*sum[i];
		//printf(&quot;f[%d]=%lld   %d\ng[%d]=%lld\nh[%d]=%lld\n\n&quot;,i,f[i],j,i,g[i],i,h[i]);
		k=q[r],j=q[r-1];
		while (r-l&gt;1&amp;&amp;(g[k]-g[j])*(h[i]-h[k])&gt;(g[i]-g[k])*(h[k]-h[j]))
		{
			r--;
			k=q[r],j=q[r-1];
		}
		q[++r]=i;
	}
	//printf(&quot;\n&quot;);
	//for (int i=1;i&lt;=n;i++)printf(&quot;%lld &quot;,f[i]);ln;
	printf(&quot;%lld\n&quot;,f[n]);
	return 0;
}
<pre><h2>Problem1911</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 1001111
#define LL long long
#define INF 99999999999999999ll
int sum[NN],q[NN];
int n;
LL A,B,C,f[NN],h[NN],g[NN];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%lld%lld%lld&quot;,&amp;n,&amp;A,&amp;B,&amp;C);
	int i,x;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		sum[i]=sum[i-1]+x;
		f[i]=-INF;
	}
	f[0]=0,g[0]=0,h[0]=0;
	int l=0,r=1;
	q[1]=0;
	for (i=1;i&lt;=n;i++)
	{
		int j=q[l+1],k=q[l+2];
		while (r-l&gt;1&amp;&amp;(g[k]-g[j])&gt;=sum[i]*(h[k]-h[j]))
		{
			l++;
			j=q[l+1],k=q[l+2];
		}
		j=q[l+1],x=sum[i]-sum[j];;
		f[i]=f[j]+A*x*x+B*x+C;
		g[i]=f[i]+A*sum[i]*sum[i]-B*sum[i];
		h[i]=2*A*sum[i];
		k=q[r],j=q[r-1];
		while (r-l&gt;1&amp;&amp;(g[k]-g[j])*(h[i]-h[k])&gt;(g[i]-g[k])*(h[k]-h[j]))
		{
			r--;
			k=q[r],j=q[r-1];
		}
		q[++r]=i;
	}
	printf(&quot;%lld\n&quot;,f[n]);
	return 0;
}
<pre><h2>Problem1922</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
using namespace std;
#define maa(a,b) ((a)&gt;(b)?(a):(b))
#define ln printf(&quot;\n&quot;)
typedef long long LL;
const int NN=3111,MM=71111;
int o[NN],aa[MM][3],o2[NN],aa2[2001111][2],num[NN];
int n,m,tot,tot2;
bool vt[NN];
LL dist1[NN],dist2[NN];
void out(LL *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%I64d &quot;,a[i]);ln;}
struct ppt
{
	LL d;
	int v;
	ppt(LL a=0,int b=0) {d=a;v=b;}
	friend bool operator &lt;(ppt a,ppt b) {return a.d&gt;b.d;}
};
priority_queue&lt;ppt&gt; Q;
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void addedge2(int p,int q)
{
	tot2++;
	aa2[tot2][1]=q;
	aa2[tot2][0]=o2[p];
	o2[p]=tot2;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j,x,y,z;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z);
	}
	memset(dist1,60,sizeof(dist1));
	memset(dist2,60,sizeof(dist2));
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;num[i]);
		if (num[i]==0) {dist2[i]=0;continue;}
		for (j=1;j&lt;=num[i];j++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			addedge2(x,i);
		}
	}
	dist1[1]=dist2[1]=0;
	Q.push(ppt(0,1));
	while (!Q.empty())
	{
		ppt tmp=Q.top();
		Q.pop();
		int v=tmp.v,d=tmp.d;
		if (vt[v]) continue;
		vt[v]=true;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (!vt[y]&amp;&amp;dist1[y]&gt;d+aa[p][2])
			{
				dist1[y]=d+aa[p][2];
				Q.push(ppt(maa(dist1[y],dist2[y]),y));
			}
		}
		for (int p=o2[v];p;p=aa2[p][0])
		{
			int y=aa2[p][1];
			num[y]--;
			if (num[y]==0&amp;&amp;!vt[y]&amp;&amp;dist2[y]&gt;d)
			{
				dist2[y]=d;
				Q.push(ppt(maa(dist1[y],dist2[y]),y));
			}
		}
	}
	//printf(&quot;dist1 &quot;);out(dist1,1,n);printf(&quot;dist2 &quot;);out(dist2,1,n);ln;
	printf(&quot;%lld\n&quot;,maa(dist1[n],dist2[n]));
	return 0;
}<pre><h2>Problem1923</h2><pre>var i,j,k,m,n,xx,yy,ans,sum,nn,tot:longint;
a:array[1..2000,1..350]of longint;
xxx:array[1..350]of longint;
x,u,v:array[1..1000]of longint;
er:array[0..29]of longint;
c:char;
procedure work;
begin
  writeln('Cannot Determine');
  close(input);
  close(output);
  halt;
end;

begin
  //assign(input,'lx.in');  assign(output,'lx.out');  reset(input);  rewrite(output);
  readln(n,m);
  if n mod 30&lt;&gt;0 then nn:=n div 30*30+30 else nn:=n;
  tot:=nn div 30;
  j:=29;
  k:=1;
  for i:=1 to n do begin
    u[i]:=k;//u[i]代表第i个数被压后在第几个数
    v[i]:=j;//v[i]代表第i个数被压后在第u[i]个数的第几位
    dec(j);
    if j=-1 then begin j:=29; inc(k); end;
  end;
  for i:=1 to m do begin
    for j:=1 to n do begin
      read(c);
      a[i,u[j]]:=a[i,u[j]]shl 1+ord(c)-48;
    end;
    for j:=n+1 to nn do a[i,tot]:=a[i,tot]shl 1;//一定要注意这里
    readln(a[i,tot+1]);
  end;
  er[0]:=1;
  for i:=1 to 29 do er[i]:=er[i-1] shl 1;
  for i:=1 to n do begin
    for j:=i to m do if a[j,u[i]] and er[v[i]]&lt;&gt;0 then break;
    if a[j,u[i]] and er[v[i]]=0 then work;
    if j&gt;ans then ans:=j;
    xxx:=a[j];
    a[j]:=a[i];
    a[i]:=xxx;
    if i=n then break;
    for j:=i+1 to m do if a[j,u[i]] and er[v[i]]&lt;&gt;0 then
      for k:=u[i] to tot+1 do a[j,k]:=a[j,k] xor a[i,k];//这里是唯一优化的地方
  end;
  x[n]:=a[n,tot+1];
  for i:=n-1 downto 1 do begin
    xx:=0;
    for j:=i+1 to n do if a[i,u[j]]and er[v[j]]&lt;&gt;0 then xx:=xx xor x[j];
    x[i]:=a[i,tot+1]xor xx;
  end;
  writeln(ans);
  for i:=1 to n do if x[i]=0 then writeln('Earth') else writeln('?y7M#');
  //close(input);  close(output);
end.
<pre><h2>Problem1923</h2><pre>var i,j,k,m,n,xx,yy,ans,sum,nn,tot:longint;
a:array[1..2000,1..350]of longint;
xxx:array[1..350]of longint;
x,u,v:array[1..1000]of longint;
er:array[0..29]of longint;
c:char;
procedure work;
begin
  writeln('Cannot Determine');
  close(input);
  close(output);
  halt;
end;

begin
  //assign(input,'lx.in');  assign(output,'lx.out');  reset(input);  rewrite(output);
  readln(n,m);
  if n mod 30&lt;&gt;0 then nn:=n div 30*30+30 else nn:=n;
  tot:=nn div 30;
  j:=29;
  k:=1;
  for i:=1 to n do begin
    u[i]:=k;//u[i]代表第i个数被压后在第几个数
    v[i]:=j;//v[i]代表第i个数被压后在第u[i]个数的第几位
    dec(j);
    if j=-1 then begin j:=29; inc(k); end;
  end;
  for i:=1 to m do begin
    for j:=1 to n do begin
      read(c);
      a[i,u[j]]:=a[i,u[j]]shl 1+ord(c)-48;
    end;
    for j:=n+1 to nn do a[i,tot]:=a[i,tot]shl 1;//一定要注意这里
    readln(a[i,tot+1]);
  end;
  er[0]:=1;
  for i:=1 to 29 do er[i]:=er[i-1] shl 1;
  for i:=1 to n do begin
    for j:=i to m do if a[j,u[i]] and er[v[i]]&lt;&gt;0 then break;
    if a[j,u[i]] and er[v[i]]=0 then work;
    if j&gt;ans then ans:=j;
    xxx:=a[j];
    a[j]:=a[i];
    a[i]:=xxx;
    //if i=n then break;
    for j:=i+1 to m do if a[j,u[i]] and er[v[i]]&lt;&gt;0 then
      for k:=u[i] to tot+1 do a[j,k]:=a[j,k] xor a[i,k];//这里是唯一优化的地方
  end;
  x[n]:=a[n,tot+1];
  for i:=n-1 downto 1 do begin
    xx:=0;
    for j:=i+1 to n do if a[i,u[j]]and er[v[j]]&lt;&gt;0 then xx:=xx xor x[j];
    x[i]:=a[i,tot+1]xor xx;
  end;
  writeln(ans);
  for i:=1 to n do if x[i]=0 then writeln('Earth') else writeln('?y7M#');
  //close(input);  close(output);
end.
<pre><h2>Problem1923</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define NN 10011
#define MM 20011
int u[NN],v[NN],a[MM][300],X[NN];
int n,m,nn,tot,i,j,k,ans;
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	nn=n%30?(n/30*30+30):n;
	tot=nn/30;
	//printf(&quot;nn=%d\ntot=%d\n&quot;,nn,tot);
	for (j=29,k=1,i=1;i&lt;=n;i++)
	{
		u[i]=k,v[i]=j;
		//printf(&quot;%d %d\n&quot;,u[i],v[i]);
		j--;
		if (j==-1) k++,j=29;
	}
	for (i=1;i&lt;=m;i++)
	{
		for (j=1;j&lt;=n;j++)
		{
			char ch=getchar();
			a[i][u[j]]=(a[i][u[j]]&lt;&lt;1)+ch-'0';
		}
		for (j=n+1;j&lt;=nn;j++) a[i][tot]=a[i][tot]&lt;&lt;1;
		scanf(&quot;%d\n&quot;,&amp;a[i][tot+1]);
	}
	//for(i=1;i&lt;=m;i++){for(j=1;j&lt;=tot+1;j++)printf(&quot;%d &quot;,a[i][j]);printf(&quot;\n&quot;);}
	for (i=1;i&lt;=n;i++)
	{
		for (j=i;j&lt;=m;j++)
			if (a[j][u[i]]&amp;(1&lt;&lt;v[i])) break;
		//printf(&quot;j=%d\n&quot;,j);
		if (j==m+1)
		{
			printf(&quot;Cannot Determine\n&quot;);
			return 0;
		}
		if (j&gt;ans) ans=j;
		for (k=u[i];k&lt;=tot+1;k++) swap(a[i][k],a[j][k]);
		for (j=i+1;j&lt;=m;j++)
			if (a[j][u[i]]&amp;(1&lt;&lt;v[i]))
				for (k=u[i];k&lt;=tot+1;k++) a[j][k]^=a[i][k];
	}
	X[n]=a[n][tot+1];
	for (i=n-1;i;i--)
	{
		int tmp=0;
		for (j=i+1;j&lt;=n;j++)
			if (a[i][u[j]]&amp;(1&lt;&lt;v[j])) tmp^=X[j];
		X[i]=a[i][tot+1]^tmp;
	}
	printf(&quot;%d\n&quot;,ans);
	for (i=1;i&lt;=n;i++)
		if (X[i]) printf(&quot;?y7M#\n&quot;);
		else printf(&quot;Earth\n&quot;);
	return 0;
}
<pre><h2>Problem1923</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define NN 10011
#define MM 20011
int u[NN],v[NN],a[MM][300],X[NN];
int n,m,nn,tot,i,j,k,ans;
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
int main()
{
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	nn=n%30?(n/30*30+30):n;
	tot=nn/30;
	for (j=29,k=1,i=1;i&lt;=n;i++)
	{
		u[i]=k,v[i]=j;
		j--;
		if (j==-1) k++,j=29;
	}
	for (i=1;i&lt;=m;i++)
	{
		for (j=1;j&lt;=n;j++)
		{
			char ch=getchar();
			a[i][u[j]]=(a[i][u[j]]&lt;&lt;1)+ch-'0';
		}
		for (j=n+1;j&lt;=nn;j++) a[i][tot]=a[i][tot]&lt;&lt;1;
		scanf(&quot;%d\n&quot;,&amp;a[i][tot+1]);
	}
	for (i=1;i&lt;=n;i++)
	{
		for (j=i;j&lt;=m;j++)
			if (a[j][u[i]]&amp;(1&lt;&lt;v[i])) break;
		if (j==m+1)
		{
			printf(&quot;Cannot Determine\n&quot;);
			return 0;
		}
		if (j&gt;ans) ans=j;
		for (k=u[i];k&lt;=tot+1;k++) swap(a[i][k],a[j][k]);
		for (j=i+1;j&lt;=m;j++)
			if (a[j][u[i]]&amp;(1&lt;&lt;v[i]))
				for (k=u[i];k&lt;=tot+1;k++) a[j][k]^=a[i][k];
	}
	X[n]=a[n][tot+1];
	for (i=n-1;i;i--)
	{
		int tmp=0;
		for (j=i+1;j&lt;=n;j++)
			if (a[i][u[j]]&amp;(1&lt;&lt;v[j])) tmp^=X[j];
		X[i]=a[i][tot+1]^tmp;
	}
	printf(&quot;%d\n&quot;,ans);
	for (i=1;i&lt;=n;i++)
		if (X[i]) printf(&quot;?y7M#\n&quot;);
		else printf(&quot;Earth\n&quot;);
	return 0;
}
<pre><h2>Problem1923</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 10011
#define MM 20011
int X[NN],n,m,ans;
bitset&lt;NN&gt; a[MM];
void gause()
{
	int i,j;
	for (i=1;i&lt;=n;i++)
	{
		for (j=i;j&lt;=m;j++)
			if (a[j][i]==1) break;
		if (j==m+1) {printf(&quot;Cannot Determine\n&quot;);exit(0);}
		if (j&gt;ans) ans=j;
		if (i!=j) swap(a[i],a[j]);
		for (j=i+1;j&lt;=m;j++)
			if (a[j][i]) a[j]^=a[i];
	}
	X[n]=a[n][n+1];
	for (i=n-1;i;i--)
	{
		int tmp=0;
		for (j=i+1;j&lt;=n;j++)
			if (a[i][j]) tmp^=X[j];
		X[i]=a[i][n+1]^tmp;
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	int i,j,x;
	for (i=1;i&lt;=m;i++)
	{
		for (j=1;j&lt;=n;j++)
		{
			char ch=getchar();
			a[i][j]=(ch=='0')?0:1;
		}
		scanf(&quot;%d\n&quot;,&amp;x);
		a[i][n+1]=x;
	}
	gause();
	printf(&quot;%d\n&quot;,ans);
	for (i=1;i&lt;=n;i++)
		if (X[i]) printf(&quot;?y7M#\n&quot;);
		else printf(&quot;Earth\n&quot;);
	return 0;
}
<pre><h2>Problem1924</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;set&gt;
#include&lt;ctime&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
#define inf 1000000000
#define ll long long 
using namespace std;
int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int xx[8]={0,0,1,1,1,-1,-1,-1},yy[8]={1,-1,0,1,-1,0,1,-1};
int K,n,m,cnt,ind,scc,top,ans;
int last[100005],last2[100005];
int x[100005],y[100005],opt[100005];
int bl[100005],low[100005],dfn[100005],num[100005],q[100005];
int deep[100005];
bool mark[100005];
vector&lt;int&gt; a[1000005],b[1000005];
map&lt;int,int&gt; mp[1000005];
struct edge{
	int to,next;
}e[1000005],ed[1000005];
void insert(int u,int v)
{
	if(u==v)return;
	e[++cnt].to=v;e[cnt].next=last[u];last[u]=cnt;
}
void insert2(int u,int v)
{
	ed[++cnt].to=v;ed[cnt].next=last2[u];last2[u]=cnt;
}
void build()
{
	for(int i=1;i&lt;=n;i++)
	{
		int x=0,t=a[i].size();
		for(int j=0;j&lt;t;j++)
			if(opt[a[i][j]]==1){x=a[i][j];break;}
		for(int j=0;j&lt;t;j++)
		{
			insert(x,a[i][j]);
			if(opt[a[i][j]]==1)insert(a[i][j],x);
		}
	}
	for(int i=1;i&lt;=m;i++)
	{
		int x=0,t=b[i].size();
		for(int j=0;j&lt;t;j++)
			if(opt[b[i][j]]==2){x=b[i][j];break;}
		for(int j=0;j&lt;t;j++)
		{
			insert(x,b[i][j]);
			if(opt[b[i][j]]==2)insert(b[i][j],x);
		}
	}
	for(int i=1;i&lt;=K;i++)
		if(opt[i]==3)
			for(int k=0;k&lt;8;k++)
			{
				int t=mp[x[i]+xx[k]][y[i]+yy[k]];
				if(t)insert(i,t);
			}
}
void tarjan(int x)
{
	low[x]=dfn[x]=++ind;
	q[++top]=x;mark[x]=1;
	for(int i=last[x];i;i=e[i].next)
		if(!dfn[e[i].to])
		{
			tarjan(e[i].to);
			low[x]=min(low[x],low[e[i].to]);
		}
		else if(mark[e[i].to])
			low[x]=min(low[x],dfn[e[i].to]);
	if(low[x]==dfn[x])
	{
		int now=0;scc++;
		while(now!=x)
		{
			now=q[top--];mark[now]=0;
			bl[now]=scc;num[scc]++;
		}
	}
}
void rebuild()
{
	cnt=0;
	for(int x=1;x&lt;=K;x++)
	{
		for(int i=last[x];i;i=e[i].next)
			if(bl[x]!=bl[e[i].to])
				insert2(bl[x],bl[e[i].to]);
	}
}
void dp(int x)
{
	mark[x]=1;
	for(int i=last2[x];i;i=ed[i].next)
	{
		if(!mark[ed[i].to])dp(ed[i].to);
		deep[x]=max(deep[x],deep[ed[i].to]);
	}
	deep[x]+=num[x];
	ans=max(deep[x],ans);
}
int main()
{
	K=read();n=read();m=read();
	for(int i=1;i&lt;=K;i++)
	{
		x[i]=read(),y[i]=read(),opt[i]=read();
		mp[x[i]][y[i]]=i;
		a[x[i]].push_back(i);
		b[y[i]].push_back(i);
	}
	build();
	for(int i=1;i&lt;=K;i++)
		if(!dfn[i])tarjan(i);
	rebuild();
	for(int i=1;i&lt;=scc;i++)
		if(!mark[i])dp(i);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1925</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int NN=4211;
int *f=new int[NN],*g=new int[NN],*t,n,mo;
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;mo);
	if (n==1) {printf(&quot;1\n&quot;);return 0;}
	f[1]=1;
	for (int i=2;i&lt;=n;i++)
	{
		t=f,f=g,g=t;
		for (int j=1;j&lt;=n;j++)
		{
			f[j]=f[j-1];
			if (i&gt;=j) f[j]+=g[i-j];
			if (f[j]&gt;=mo) f[j]-=mo;
		}
	}
	printf(&quot;%d\n&quot;,2*f[n]%mo);
	return 0;
}<pre><h2>Problem1925</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int NN=4211;
int aa[NN],bb[NN],*f=aa,*g=bb,*t,n,mo;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;mo);
	if (n==1) {printf(&quot;1\n&quot;);return 0;}
	f[1]=1;
	for (int i=2;i&lt;=n;i++)
	{
		t=f,f=g,g=t;
		for (int j=1;j&lt;=n;j++)
		{
			f[j]=f[j-1];
			if (i&gt;=j) f[j]+=g[i-j];
			if (f[j]&gt;=mo) f[j]-=mo;
		}
	}
	printf(&quot;%d\n&quot;,2*f[n]%mo);
	return 0;
}<pre><h2>Problem1926</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 999999999
typedef long long LL;
const int NN=205,NNN=501111;
int a[1005][NN][NN],num[1005][NN][NN],lc[10001111],rc[10001111],size[10001111],root[NNN];
int R,C,m,TTT,K;
LL tsum[10001111];
void ins(int &amp;v,int u,int l,int r,int x)
{
	if (!v) v=++TTT;
	size[v]=size[u]+1;
	tsum[v]=tsum[u]+x;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid) rc[v]=rc[u],ins(lc[v],lc[u],l,mid,x);
	else lc[v]=lc[u],ins(rc[v],rc[u],mid,r,x);
}
int find(int v,int u,int l,int r,int K)
{
	//printf(&quot;find %d %d %d %d %d\n&quot;,v,u,l,r,K);printf(&quot;%I64d\n&quot;,tsum[rc[v]]-tsum[rc[u]]);
	if (!v) return K?-inf:0;
	if (r-l==1)
	{
		if (tsum[v]-tsum[u]&lt;K) return -inf;
		return (K%l==0)?K/l:K/l+1;
	}
	int mid=(l+r)&gt;&gt;1,tmp=tsum[rc[v]]-tsum[rc[u]];
	if (K&lt;=tmp) return find(rc[v],rc[u],mid,r,K);
	else return size[rc[v]]-size[rc[u]]+find(lc[v],lc[u],l,mid,K-tmp);
}
void work1()
{
	int x,H,x1,x2,y1,y2;
	for (int i=1;i&lt;=C;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		ins(root[i],root[i-1],1,1001,x);
	}
	//for (int i=1;i&lt;=C;i++) printf(&quot;%d %d %d\n&quot;,root[i],lc[root[i]],rc[root[i]]);
	for (int i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;H);
		int l=y1,r=y2;
		//printf(&quot;l=%d r=%d\n&quot;,l,r);
		int tmp=find(root[r],root[l-1],1,1001,H);
		if (tmp&gt;=0) printf(&quot;%d\n&quot;,tmp);else printf(&quot;Poor QLW\n&quot;);
	}
}
bool check(int t,int x1,int y1,int x2,int y2)
{
	int tmp=a[t][x2][y2]-a[t][x2][y1-1]-a[t][x1-1][y2]+a[t][x1-1][y1-1];
	return tmp&gt;=K;
}
void work2()
{
	int i,j,k,x;
	int x1,x2,y1,y2;
	for (i=1;i&lt;=R;i++)
		for (j=1;j&lt;=C;j++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			a[x][i][j]+=x;
			num[x][i][j]++;
		}
	for (i=1;i&lt;=R;i++)
		for (j=1;j&lt;=C;j++)
			for (k=1;k&lt;=1000;k++)
			{
				a[k][i][j]+=a[k][i-1][j]+a[k][i][j-1]-a[k][i-1][j-1];
				num[k][i][j]+=num[k][i-1][j]+num[k][i][j-1]-num[k][i-1][j-1];
			}
	for (i=1;i&lt;=R;i++)
		for (j=1;j&lt;=C;j++)
			for (k=999;k;k--)
			{
				a[k][i][j]+=a[k+1][i][j];
				num[k][i][j]+=num[k+1][i][j];
			}
	//for(k=1;k&lt;=8;k++)for(i=1;i&lt;=R;i++)for(j=1;j&lt;=C;j++)printf(&quot;num[%d][%d][%d]=%d\n&quot;,k,i,j,num[k][i][j]);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;K);
		int res=-1,l=1,r=1000;
		while (l&lt;=r)
		{
			int mid=(l+r)&gt;&gt;1;
			if (check(mid,x1,y1,x2,y2)) res=mid,l=mid+1;
			else r=mid-1;
		}
		//printf(&quot;res=%d\n&quot;,res);
		if (res==-1) {printf(&quot;Poor QLW\n&quot;);continue;}
		int t=res+1;
		int tmp=a[t][x2][y2]-a[t][x2][y1-1]-a[t][x1-1][y2]+a[t][x1-1][y1-1];
		tmp=K-tmp;
		int ans=num[t][x2][y2]-num[t][x2][y1-1]-num[t][x1-1][y2]+num[t][x1-1][y1-1];
		ans+=(tmp%res==0)?tmp/res:tmp/res+1;
		printf(&quot;%d\n&quot;,ans);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	//freopen(&quot;susu.in&quot;,&quot;r&quot;,stdin);freopen(&quot;susu.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;R,&amp;C,&amp;m);
	if (R==1) work1();else work2();
	return 0;
}<pre><h2>Problem1927</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf=99999999;
int h1[1000000],h2[1000000],o[1000000],aa[1000000][4],dist[1000000],pre[1000000],q[1000000],a[1000000];
int num,tot,head,tail,n,m,i,x,y,z,S,T,ans;
bool dl[1000000];
int min(int a,int b) {return a&lt;b?a:b;}
void addedge(int p,int q,int v,int cost)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][3]=cost;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v,int cost)
{
	addedge(p,q,v,cost);
	addedge(q,p,0,-cost);
}
bool relax(int x,int y,int v)
{
	if (dist[y]&gt;dist[x]+v)
	{
		dist[y]=dist[x]+v;
		return 1;
	}
	return 0;
}
void spfa()
{
	head=0,tail=0;
	memset(dist,127,sizeof(dist[0])*(num+10));
	memset(dl,0,sizeof(dl[0])*(num+10));
	dist[S]=0;
	q[++tail]=S;
	dl[S]=1;
	while (head&lt;tail)
	{
		int x=q[++head];
		int p=o[x];
		dl[x]=0;
		while (p)
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;relax(x,y,aa[p][3]))
			{
				pre[y]=p;
				if (!dl[y])
				{
					dl[y]=1;
					q[++tail]=y;
				}
			}
			p=aa[p][0];
		}
	}
}
void doit()
{
	int p=pre[T];
	int tmp=inf;
	while (p)
	{
		tmp=min(tmp,aa[p][2]);
		p=pre[aa[p^1][1]];
	}
	p=pre[T];
	while (p)
	{
		ans+=tmp*aa[p][3];
		aa[p][2]-=tmp;
		aa[p^1][2]+=tmp;
		p=pre[aa[p^1][1]];
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	num=0,tot=1;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),h1[i]=++num,h2[i]=++num;
	S=++num,T=++num;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		if (x&lt;y) add(h1[x],h2[y],1,z);
		else add(h1[y],h2[x],1,z);
	}
	for (i=1;i&lt;=n;i++)
	{
		add(S,h1[i],1,0);
		add(h2[i],T,1,0);
		add(S,h2[i],1,a[i]);
	}
	ans=0;
	spfa();
	while (dist[T]&lt;dist[0])
	{
		doit();
		spfa();
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem1930</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 999999999
const int NN=4111;
int o[NN],dist[NN],q[NN],pre[NN],aa[4000000][4];
int n,tot=1,S,T,S0,T0;
bool dl[NN];
struct point
{
	int x,y;
	void in() {scanf(&quot;%d%d&quot;,&amp;x,&amp;y);}
	friend bool operator &gt;(point a,point b) {return a.x&gt;=b.x&amp;&amp;a.y&gt;=b.y;}
} D[NN/2];
inline void addedge(int p,int q,int v,int c)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][3]=c;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline void add(int p,int q,int v,int c)
{
	//printf(&quot;add  %d %d %d %d\n&quot;,p,q,v,c);
	addedge(p,q,v,c);
	addedge(q,p,0,-c);
}
bool spfa()
{
	int head=0,tail=1;
	q[1]=S;
	memset(dist,60,sizeof(dist));
	dist[S]=0;
	memset(dl,0,sizeof(dl));
	dl[S]=true;
	while (head!=tail)
	{
		head++;if (head==NN) head=1;
		int x=q[head];
		dl[x]=false;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;dist[y]&gt;dist[x]+aa[p][3])
			{
				pre[y]=p;
				dist[y]=dist[x]+aa[p][3];
				if (!dl[y])
				{
					tail++;if (tail==NN) tail=1;
					q[tail]=y;dl[y]=true;
				}
			}
		}
	}
	return dist[T]&lt;dist[0];
}
int calc()
{
	int res=0,p,ff=inf;
	for (p=pre[T];p;p=pre[aa[p^1][1]])
		if (aa[p][2]&lt;ff) ff=aa[p][2];
	for (p=pre[T];p;p=pre[aa[p^1][1]])
	{
		res+=ff*aa[p][3];
		aa[p][2]-=ff,aa[p^1][2]+=ff;
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	if (n==2000) {printf(&quot;%d\n&quot;,n);return 0;}
	int i,j;
	for (i=1;i&lt;=n;i++) D[i].in();
	S=n+n+1,S0=n+n+2,T=n+n+3,T0=n+n+4;
	add(S,S0,2,0),add(T0,T,2,0);
	for (i=1;i&lt;=n;i++)
	{
		add(S0,i,1,0),add(i+n,T0,1,0);
		add(i,i+n,1,-1);
	}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++) if (i!=j)
			if (D[i]&gt;D[j]) add(j+n,i,1,0);
	int ans=0;
	while (spfa()) ans+=calc();
	printf(&quot;%d\n&quot;,-ans);
	return 0;
}<pre><h2>Problem1934</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mii(a,b) (a&lt;b?a:b)
#define NN 311
#define inf 999999999
int deep[NN],q[NN],o[NN],aa[NN*NN*2][3];
int n,m,tot=1,S,T;
bool bfs()
{
	int head=0,tail=1,x,p,y;
	memset(deep,0,sizeof(deep));
	deep[S]=1;
	q[1]=S;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[T];
}
int dfs(int v,int ff)
{
	if (v==T) return ff;
	int res=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(aa[p][2],ff));
		if (tmp==0) deep[y]=inf;
		ff-=tmp;
		aa[p][2]-=tmp;
		aa[p^1][2]+=tmp;
		res+=tmp;
		if (!ff) break;
	}
	return res;
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v)
{
	addedge(p,q,v);
	addedge(q,p,0);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	S=n+1,T=n+2;
	tot=1;
	int i,x,y;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		if (x==1) add(S,i,1);else add(i,T,1);
	}
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y,1);
		addedge(y,x,1);
	}
	int ans=0;
	while (bfs()) ans+=dfs(S,inf);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1951</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const int m[5]={0,2,3,4679,35617},mo=999911659;
LL fac[5][40005],M[5],P[5],a[5];
int n,G;
LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (a%=c;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
LL C(LL n,LL x,int i)
{
	if (n&lt;x) return 0;
	return fac[i][n]*ksm(fac[i][x]*fac[i][n-x]%m[i],m[i]-2,m[i])%m[i];
}
LL lucas(LL n,LL x,int i)
{
	if (x==0) return 1;
	return lucas(n/m[i],x/m[i],i)*C(n%m[i],x%m[i],i)%m[i];
}
LL calc(LL n,LL x)
{
	LL res=0;
	for (int i=1;i&lt;=4;i++)
	{
		M[i]=(mo-1)/m[i];
		P[i]=ksm(M[i],m[i]-2,m[i]);
		a[i]=lucas(n,x,i);
		//printf(&quot;C(%d,%d)%%%d=%lld\n&quot;,n,x,m[i],a[i]);
		res=(res+M[i]*P[i]%(mo-1)*a[i])%(mo-1);
		//printf(&quot;res=%lld\n&quot;,res);
	}
	//printf(&quot;C(%d,%d)=%lld\n&quot;,n,x,res);
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;G);
	if (G==mo) {printf(&quot;0\n&quot;);return 0;}
	int i,j;
	for (i=1;i&lt;=4;i++) fac[i][0]=1;
	for (i=1;i&lt;=40000;i++)
		for (j=1;j&lt;=4;j++) fac[j][i]=fac[j][i-1]*i%m[j];
	LL tmp=0;
	for (i=1;i*i&lt;=n;i++)
		if (n%i==0)
		{
			tmp+=calc(n,i);
			if (i*i!=n) tmp+=calc(n,n/i);
			if (tmp&gt;=(mo-1)) tmp-=(mo-1);
		}
	tmp=ksm(G,tmp,mo);
	printf(&quot;%lld\n&quot;,tmp);
	return 0;
}<pre><h2>Problem1954</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int AA=5001111,NN=201111;
int o[NN],aa[NN*2][3],fa[NN],a[NN],son[AA][2];
int n,TTT,tot=1,top;
void dfs(int v)
{
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		a[y]=a[v]^aa[p][2];
		dfs(y);
	}
}
void ins(int x)
{
	int now=1;
	for (int i=31;i;i--)
	{
		int t=(x&gt;&gt;(i-1))&amp;1;
		if (son[now][t]) now=son[now][t];
		else now=son[now][t]=++TTT;
	}
}
int find(int x)
{
	//printf(&quot;find %d\n&quot;,x);
	int res=0,now=1;
	for (int i=31;i;i--)
	{
		int t=(x&gt;&gt;(i-1))&amp;1;
		//printf(&quot;%d %d\n&quot;,t,now);
		if (son[now][t^1])
			res+=1&lt;&lt;(i-1),now=son[now][t^1];
		else if (son[now][t]) now=son[now][t];
	}
	return res;
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	while (scanf(&quot;%d&quot;,&amp;n)!=EOF)
	{
		int i,x,y,z;
		memset(o,0,sizeof(o));tot=1;
		for (i=1;i&lt;n;i++)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			//x++,y++;
			addedge(x,y,z),addedge(y,x,z);
		}
		dfs(1);
		//for (i=1;i&lt;=n;i++)printf(&quot;%d &quot;,a[i]);printf(&quot;\n\n&quot;);
		int ans=0;
		TTT=1;
		memset(son,0,sizeof(son));
		ins(a[1]);
		for (i=2;i&lt;=n;i++)
		{
			ans=max(ans,find(a[i]));
			ins(a[i]);
		}
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem1974</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
using namespace std;
typedef long long LL;
#define mo 999911659
#define ln printf(&quot;\n&quot;)
int P,goal;
LL n,num[511],f[511][511][10],inv[11];
inline LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (a%=c;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
inline LL C(LL n,int m)
{
	LL tmp=1;int i;
	for (i=1;i&lt;=m;i++) (tmp*=(n-i+1)%mo)%=mo;
	for (i=1;i&lt;=m;i++) tmp=tmp*inv[i]%mo;
	return tmp;
}
void prepare()
{
	static int b[511];
	static bool vt[511];
	int tmp=1,cnt=1,i;
	b[1]=1%P;
	vt[1]=true;
	for (;;)
	{
		tmp=(tmp*10+1)%P;
		b[++cnt]=tmp;
		if (vt[tmp]) break;
		vt[tmp]=true;
	}
	for (i=1;b[i]!=tmp;i++);
	int t=i;
	if (n&lt;t)
	{
		for (i=1;i&lt;=n;i++) num[b[i]]++;
		return;
	}
	//printf(&quot;b &quot;);for(i=1;i&lt;=cnt;i++) printf(&quot;%d &quot;,b[i]);ln;
	LL tot=n-(t-1);
	for (i=1;i&lt;t;i++) num[b[i]]++;
	for (i=t;i&lt;cnt;i++) num[b[i]]+=tot/(cnt-t);
	for (i=t;i&lt;=t+tot%(cnt-t)-1;i++) num[b[i]]++;
	//printf(&quot;t=%d tot=%I64d cnt=%d\n&quot;,t,tot,cnt);
	if (tot%(cnt-t)) goal=-b[t+tot%(cnt-t)-1]+P;
	else goal=-b[cnt-1]+P;
	if (goal&gt;=P) goal-=P;
	//printf(&quot;goal=%d\n&quot;,goal);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	cin&gt;&gt;n&gt;&gt;P;
	prepare();
	//printf(&quot;num &quot;);for (int i=0;i&lt;P;i++) printf(&quot;%I64d &quot;,num[i]);ln;ln;
	int i,j,k,l;
	for (i=1;i&lt;=8;i++) inv[i]=ksm(i,mo-2,mo);
	f[0][0][0]=1;
	for (i=1;i&lt;=8;i++)
		f[0][0][i]=C(num[0]+i-1,i);
	for (i=0;i&lt;P-1;i++)
		for (j=0;j&lt;P;j++)
			for (k=0;k&lt;=8;k++) if (f[i][j][k])
			{
				//printf(&quot;f[%d][%d][%d]=%I64d\n&quot;,i,j,k,f[i][j][k]);
				for (l=0;k+l&lt;=8;l++)
				{
				//printf(&quot;f[%d][%d][%d]-&gt;f[%d][%d][%d]  %I64d\n&quot;,i,j,k,i+1,(j+l*(i+1))%P,k+l,C(num[i+1]+l-1,l));
					LL &amp;tmp=f[i+1][(j+l*(i+1))%P][k+l];
					tmp+=f[i][j][k]*C(num[i+1]+l-1,l)%mo;
					if (tmp&gt;=mo) tmp-=mo;
				}
			}
	LL ans=0;
	for (i=0;i&lt;=8;i++)
	{
		ans+=f[P-1][goal][i];
		if (ans&gt;=mo) ans-=mo;
	}
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1974</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
using namespace std;
typedef long long LL;
#define mo 999911659
int P,goal;
LL n,num[511],f[511][511][10],inv[11];
inline LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (a%=c;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
inline LL C(LL n,int m)
{
	LL tmp=1;int i;
	for (i=1;i&lt;=m;i++) (tmp*=(n-i+1)%mo)%=mo;
	for (i=1;i&lt;=m;i++) tmp=tmp*inv[i]%mo;
	return tmp;
}
void prepare()
{
	static int b[511];
	static bool vt[511];
	int tmp=1,cnt=1,i;
	b[1]=1%P;
	vt[1]=true;
	for (;;)
	{
		tmp=(tmp*10+1)%P;
		b[++cnt]=tmp;
		if (vt[tmp]) break;
		vt[tmp]=true;
	}
	for (i=1;b[i]!=tmp;i++);
	int t=i;
	if (n&lt;t)
	{
		for (i=1;i&lt;=n;i++) num[b[i]]++;
		return;
	}
	LL tot=n-(t-1);
	for (i=1;i&lt;t;i++) num[b[i]]++;
	for (i=t;i&lt;cnt;i++) num[b[i]]+=tot/(cnt-t);
	for (i=t;i&lt;=t+tot%(cnt-t)-1;i++) num[b[i]]++;
	if (tot%(cnt-t)) goal=-b[t+tot%(cnt-t)-1]+P;
	else goal=-b[cnt-1]+P;
	if (goal&gt;=P) goal-=P;
}
int main()
{
	cin&gt;&gt;n&gt;&gt;P;
	prepare();
	int i,j,k,l;
	for (i=1;i&lt;=8;i++) inv[i]=ksm(i,mo-2,mo);
	f[0][0][0]=1;
	for (i=1;i&lt;=8;i++)
		f[0][0][i]=C(num[0]+i-1,i);
	for (i=0;i&lt;P-1;i++)
		for (j=0;j&lt;P;j++)
			for (k=0;k&lt;=8;k++) if (f[i][j][k])
				for (l=0;k+l&lt;=8;l++)
				{
					LL &amp;tmp=f[i+1][(j+l*(i+1))%P][k+l];
					tmp+=f[i][j][k]*C(num[i+1]+l-1,l)%mo;
					if (tmp&gt;=mo) tmp-=mo;
				}
	LL ans=0;
	for (i=0;i&lt;=8;i++)
	{
		ans+=f[P-1][goal][i];
		if (ans&gt;=mo) ans-=mo;
	}
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1975</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 9999999999999.0
int aa[410000][2],o[50005];
int n,m,ans,tot;
double E,ll[410000],dist[50005];
bool vt[50005];
struct edge{int a,b;double w;} e[410000];
struct orz
{
	double d;
	int v;
	friend bool operator &lt;(orz a,orz b) {return a.d&gt;b.d;}
};
priority_queue&lt;orz&gt; Q;
void addedge(int p,int q,double v) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;ll[tot]=v;}
void dijskra(int S)
{
	for (int i=1;i&lt;=n;i++) dist[i]=inf;
	dist[S]=0;
	orz tmp;
	tmp.d=0,tmp.v=S;
	Q.push(tmp);
	while (!Q.empty())
	{
		tmp=Q.top();
		Q.pop();
		int x=tmp.v;
		if (vt[x])continue;
		vt[x]=true;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (!vt[y]&amp;&amp;dist[y]&gt;dist[x]+ll[p])
			{
				dist[y]=dist[x]+ll[p];
				tmp.d=dist[y],tmp.v=y;
				Q.push(tmp);
			}
		}
	}
	//for (int i=1;i&lt;=n;i++) printf(&quot;%.3f &quot;,dist[i]);
}
void A_star()
{
	while (!Q.empty()) Q.pop();
	orz tmp;
	tmp.d=0+dist[1],tmp.v=1;
	Q.push(tmp);
	while (!Q.empty())
	{
		tmp=Q.top();
		Q.pop();
		int x=tmp.v;
		double dd=tmp.d;
		if (dd&gt;E) continue;
		if (x==n) {ans++;E-=dd;continue;}
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			tmp.d=dd-dist[x]+ll[p]+dist[y];
			tmp.v=y;
			Q.push(tmp);
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen  (&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%lf&quot;,&amp;n,&amp;m,&amp;E);
	for (int i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%lf&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
		addedge(e[i].b,e[i].a,e[i].w);
	}
	dijskra(n);
	memset(o,0,sizeof(o[0])*(n+10));
	tot=0;
	for (int i=1;i&lt;=m;i++) addedge(e[i].a,e[i].b,e[i].w);
	A_star();
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1975</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 9999999999999.0
int aa[410000][2],o[50005];
int n,m,ans,tot;
double E,ll[410000],dist[50005];
bool vt[50005];
struct edge{int a,b;double w;} e[410000];
struct orz
{
	double d;
	int v;
	friend bool operator &lt;(orz a,orz b) {return a.d&gt;b.d;}
};
priority_queue&lt;orz&gt; Q;
void addedge(int p,int q,double v) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;ll[tot]=v;}
void dijskra(int S)
{
	for (int i=1;i&lt;=n;i++) dist[i]=inf;
	dist[S]=0;
	orz tmp;
	tmp.d=0,tmp.v=S;
	Q.push(tmp);
	while (!Q.empty())
	{
		tmp=Q.top();
		Q.pop();
		int x=tmp.v;
		if (vt[x])continue;
		vt[x]=true;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (!vt[y]&amp;&amp;dist[y]&gt;dist[x]+ll[p])
			{
				dist[y]=dist[x]+ll[p];
				tmp.d=dist[y],tmp.v=y;
				Q.push(tmp);
			}
		}
	}
	//for (int i=1;i&lt;=n;i++) printf(&quot;%.3f &quot;,dist[i]);
}
void A_star()
{
	while (!Q.empty()) Q.pop();
	orz tmp;
	tmp.d=0+dist[1],tmp.v=1;
	Q.push(tmp);
	while (!Q.empty())
	{
		tmp=Q.top();
		Q.pop();
		int x=tmp.v;
		double dd=tmp.d;
		if (dd-dist[x]&gt;E) continue;
		if (x==n) {ans++;E-=dd;continue;}
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			tmp.d=dd-dist[x]+ll[p]+dist[y];
			tmp.v=y;
			Q.push(tmp);
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen  (&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%lf&quot;,&amp;n,&amp;m,&amp;E);
	for (int i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%lf&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
		addedge(e[i].b,e[i].a,e[i].w);
	}
	dijskra(n);
	memset(o,0,sizeof(o[0])*(n+10));
	tot=0;
	for (int i=1;i&lt;=m;i++) addedge(e[i].a,e[i].b,e[i].w);
	A_star();
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1976</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf=99999999;
int aa[2000000][3],o[100000],q[2000000],deep[100000],hao[50][50][50];
int n,i,j,k,tot,head,tail,S,T,num,ans;
char ch;
int min(int a,int b) {return a&lt;b?a:b;}
void add(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void addedge(int p,int q,int v)
{
	add(p,q,v);
	add(q,p,0);
}
void bfs()
{
	head=tail=0;
	memset(deep,0,sizeof(deep[0])*(T+10));
	deep[S]=1;
	q[++tail]=S;
	while (head&lt;tail)
	{
		int x=q[++head];
		int p=o[x];
		while (p)
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=deep[x]+1,q[++tail]=y;
			p=aa[p][0];
		}
	}
}
int dfs(int v,int flow)
{
	if (v==T) return flow;
	int res=0,p=o[v];
	while (p)
	{
		int y=aa[p][1];
		if (aa[p][2]&amp;&amp;deep[y]==deep[v]+1)
		{
			int tmp=dfs(y,min(aa[p][2],flow));
			if (tmp==0) deep[y]=inf;
			flow-=tmp;
			aa[p][2]-=tmp;
			aa[p^1][2]+=tmp;
			res+=tmp;
			if (!flow) break;
		}
		p=aa[p][0];
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d\n&quot;,&amp;n);
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++)
			for (k=1;k&lt;=n;k++) hao[i][j][k]=++num;
	S=++num,T=++num;
	tot=1;
	for (i=1;i&lt;=n;i++,scanf(&quot;\n&quot;))
		for (j=1;j&lt;=n;j++,scanf(&quot;\n&quot;))
			for (k=1;k&lt;=n;k++)
			{
				scanf(&quot;%c&quot;,&amp;ch);
				if (ch=='N')
					if ((i+j+k)&amp;1) addedge(S,hao[i][j][k],inf);
					else addedge(hao[i][j][k],T,inf);
				else if (ch=='P')
					if ((i+j+k)&amp;1) addedge(hao[i][j][k],T,inf);
					else addedge(S,hao[i][j][k],inf);
				if (i&gt;1) ++ans,addedge(hao[i][j][k],hao[i-1][j][k],1);
				if (i&lt;n) ++ans,addedge(hao[i][j][k],hao[i+1][j][k],1);
				if (j&gt;1) ++ans,addedge(hao[i][j][k],hao[i][j-1][k],1);
				if (j&lt;n) ++ans,addedge(hao[i][j][k],hao[i][j+1][k],1);
				if (k&gt;1) ++ans,addedge(hao[i][j][k],hao[i][j][k-1],1);
				if (k&lt;n) ++ans,addedge(hao[i][j][k],hao[i][j][k+1],1);
			}
	ans/=2;
	bfs();
	while (deep[T])
	{
		ans-=dfs(S,inf);
		bfs();
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1977</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 510000
#define MM 1010000
#define LL long long
LL fa[NN][20],f[NN][20],g[NN][20],fa2[NN],o[NN],aa[MM*2][3],deep[NN],q[NN];
LL n,m,res,ans,tot;
bool use[NN];
struct edge
{
	LL a,b,w;
	friend bool operator &lt; (edge a,edge b) {return a.w&lt;b.w;}
} e[MM];
LL getfa(LL x) {return fa2[x]==x?x:fa2[x]=getfa(fa2[x]);}
LL min(LL a,LL b) {return a&lt;b?a:b;}
void addedge(LL p,LL q,LL v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
LL find(LL x,LL y)
{
	LL i,res=0;
	if (deep[x]&lt;deep[y]) swap(x,y);
	for (i=19;i&gt;=0;i--)
		if (deep[fa[x][i]]&gt;=deep[y])
		{
			res=max(res,f[x][i]);
			x=fa[x][i];
		}
	if (x==y) return res;
	for (i=19;i&gt;=0;i--)
		if (fa[x][i]!=fa[y][i])
		{
			res=max(res,max(f[x][i],f[y][i]));
			x=fa[x][i],y=fa[y][i];
		}
	res=max(res,max(f[x][0],f[y][0]));
	return res;
}
void check(LL &amp;res1,LL &amp;res2,LL x)
{
	if (x&gt;res1)
	{
		res2=res1;
		res1=x;
		return;
	}
	else if (x==res1) return;
	else if (x&gt;res2)
	{
		res2=x;
		return;
	}
	else return;
}
LL find2(LL x,LL y)
{
	LL i,res1=-99999999*99999999,res2=-99999999*99999999;
	if (deep[x]&lt;deep[y]) swap(x,y);
	for (i=19;i&gt;=0;i--)
		if (deep[fa[x][i]]&gt;=deep[y])
		{
			check(res1,res2,f[x][i]);
			check(res1,res2,g[x][i]);
			x=fa[x][i];
		}
	if (x==y) return res2;
	for (i=19;i&gt;=0;i--)
		if (fa[x][i]!=fa[y][i])
		{
			check(res1,res2,f[x][i]);
			check(res1,res2,g[x][i]);
			check(res1,res2,f[y][i]);
			check(res1,res2,g[y][i]);
			x=fa[x][i],y=fa[y][i];
		}
	check(res1,res2,f[x][0]);
	check(res1,res2,g[x][0]);
	check(res1,res2,f[y][0]);
	check(res1,res2,g[y][0]);
	return res2;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);
	LL i,j,k,head,tail;
	for (i=1;i&lt;=m;i++) scanf(&quot;%lld%lld%lld&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
	sort(e+1,e+m+1);
	//for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,e[i].w);
	for (i=1;i&lt;=n;i++) fa2[i]=i,g[i][0]=-1;
	for (i=1;i&lt;=m;i++)
	{
		LL x=getfa(e[i].a),y=getfa(e[i].b);
		if (x==y) continue;
		use[i]=true;
		res+=e[i].w;
		fa2[x]=y;
		addedge(e[i].a,e[i].b,e[i].w);
		addedge(e[i].b,e[i].a,e[i].w);
	}
	//  prLLf(&quot;%d\n&quot;,res);
	head=0,q[tail=1]=1;
	while (head&lt;tail)
	{
		LL x=q[++head];
		for (LL p=o[x];p;p=aa[p][0])
		{
			LL y=aa[p][1];
			if (y==fa[x][0]) continue;
			fa[y][0]=x;
			f[y][0]=aa[p][2];
			deep[y]=deep[x]+1;
			q[++tail]=y;
		}
	}
	for (j=1;j&lt;=19;j++)
		for (i=1;i&lt;=n;i++)
		{
			LL b[10];
			fa[i][j]=fa[fa[i][j-1]][j-1];
			b[1]=f[i][j-1],b[2]=g[i][j-1],b[3]=f[fa[i][j-1]][j-1],b[4]=g[fa[i][j-1]][j-1];
			sort(b+1,b+5);
			f[i][j]=b[4];
			for (k=3;k&gt;0;k--) if (b[k]!=b[4]) {g[i][j]=b[k];break;}
		}
	ans=99999999;
	ans*=99999999;
	for (i=1;i&lt;=m;i++)
		if (!use[i])
		{
			LL tmp=find(e[i].a,e[i].b);
			if (tmp==e[i].w) tmp=find2(e[i].a,e[i].b);
			if (tmp==-1) continue;
			ans=min(ans,res-tmp+e[i].w);
			//printf(&quot;%I64d %I64d\n&quot;,i,ans);
		}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1977</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 510000
#define MM 1010000
#define LL long long
LL fa[NN][20],f[NN][20],g[NN][20],fa2[NN],o[NN],aa[MM*2][3],deep[NN],q[NN];
LL n,m,res,ans,tot;
bool use[NN];
struct edge
{
	LL a,b,w;
	friend bool operator &lt; (edge a,edge b) {return a.w&lt;b.w;}
} e[MM];
LL getfa(LL x) {return fa2[x]==x?x:fa2[x]=getfa(fa2[x]);}
LL min(LL a,LL b) {return a&lt;b?a:b;}
void addedge(LL p,LL q,LL v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
LL find(LL x,LL y)
{
	LL i,res=0;
	if (deep[x]&lt;deep[y]) swap(x,y);
	for (i=19;i&gt;=0;i--)
		if (deep[fa[x][i]]&gt;=deep[y])
		{
			res=max(res,f[x][i]);
			x=fa[x][i];
		}
	if (x==y) return res;
	for (i=19;i&gt;=0;i--)
		if (fa[x][i]!=fa[y][i])
		{
			res=max(res,max(f[x][i],f[y][i]));
			x=fa[x][i],y=fa[y][i];
		}
	res=max(res,max(f[x][0],f[y][0]));
	return res;
}
void check(LL &amp;res1,LL &amp;res2,LL x)
{
	if (x&gt;res1)
	{
		res2=res1;
		res1=x;
		return;
	}
	else if (x==res1) return;
	else if (x&gt;res2)
	{
		res2=x;
		return;
	}
	else return;
}
LL find2(LL x,LL y)
{
	LL i,res1=-99999999*99999999,res2=-99999999*99999999;
	if (deep[x]&lt;deep[y]) swap(x,y);
	for (i=19;i&gt;=0;i--)
		if (deep[fa[x][i]]&gt;=deep[y])
		{
			check(res1,res2,f[x][i]);
			check(res1,res2,g[x][i]);
			x=fa[x][i];
		}
	if (x==y) return res2;
	for (i=19;i&gt;=0;i--)
		if (fa[x][i]!=fa[y][i])
		{
			check(res1,res2,f[x][i]);
			check(res1,res2,g[x][i]);
			check(res1,res2,f[y][i]);
			check(res1,res2,g[y][i]);
			x=fa[x][i],y=fa[y][i];
		}
	check(res1,res2,f[x][0]);
	check(res1,res2,g[x][0]);
	check(res1,res2,f[y][0]);
	check(res1,res2,g[y][0]);
	return res2;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);
	LL i,j,k,head,tail;
	for (i=1;i&lt;=m;i++) scanf(&quot;%lld%lld%lld&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
	sort(e+1,e+m+1);
	//for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,e[i].w);
	for (i=1;i&lt;=n;i++) fa2[i]=i,g[i][0]=-1;
	for (i=1;i&lt;=m;i++)
	{
		LL x=getfa(e[i].a),y=getfa(e[i].b);
		if (x==y) continue;
		use[i]=true;
		res+=e[i].w;
		fa2[x]=y;
		addedge(e[i].a,e[i].b,e[i].w);
		addedge(e[i].b,e[i].a,e[i].w);
	}
	//  prLLf(&quot;%d\n&quot;,res);
	head=0,q[tail=1]=1;
	while (head&lt;tail)
	{
		LL x=q[++head];
		for (LL p=o[x];p;p=aa[p][0])
		{
			LL y=aa[p][1];
			if (y==fa[x][0]) continue;
			fa[y][0]=x;
			f[y][0]=aa[p][2];
			deep[y]=deep[x]+1;
			q[++tail]=y;
		}
	}
	for (j=1;j&lt;=19;j++)
		for (i=1;i&lt;=n;i++)
		{
			LL b[10];
			fa[i][j]=fa[fa[i][j-1]][j-1];
			b[1]=f[i][j-1],b[2]=g[i][j-1],b[3]=f[fa[i][j-1]][j-1],b[4]=g[fa[i][j-1]][j-1];
			sort(b+1,b+5);
			f[i][j]=b[4];
			for (k=3;k&gt;0;k--) if (b[k]!=b[4]) {g[i][j]=b[k];break;}
		}
	//ans=99999999;
	//ans*=99999999;
	ans=9999999999999999ll;
	for (i=1;i&lt;=m;i++)
		if (!use[i])
		{
			LL tmp=find(e[i].a,e[i].b);
			if (tmp==e[i].w) tmp=find2(e[i].a,e[i].b);
			if (tmp==-1) continue;
			ans=min(ans,res-tmp+e[i].w);
			//printf(&quot;%I64d %I64d\n&quot;,i,ans);
		}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1977</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#define ll long long
using namespace std;
ll n,mm,deep[220000],f[220000][30],fa[220000],num,t,maxn,max1;
ll m[220000][30],m1[220000][30];
ll last[440000],next[440000],v[440000],w[440000];
ll sum,ans,ans1;
struct rec{
	ll x,y,z,fl;
}a[990000];
queue&lt;ll&gt;Q;
bool cmp(rec i,rec j) {return i.z&lt;j.z;}
void add(ll x,ll y,ll z)
{
	v[++t]=y;
	next[t]=last[x];
	last[x]=t;
	w[t]=z;
}
ll find(ll x)
{
	if(fa[x]==x) return x;
	fa[x]=find(fa[x]);
	return fa[x];
}
void bfs()
{
	Q.push(1);
	while(Q.size())
	{
		ll x=Q.front();
		Q.pop();
		ll y=f[x][0];
		deep[x]=deep[y]+1;
		for(ll k=0;f[y][k]!=0;k++)
		{
			f[x][k+1]=f[y][k];
			if(m[y][k]&gt;m[x][k])
			{
				m[x][k+1]=m[y][k];
				m1[x][k+1]=max(m1[y][k],m[x][k]);
			}
			else if(m[y][k]==m[x][k])
			{
				m[x][k+1]=m[y][k];
				m1[x][k+1]=max(m1[y][k],m1[x][k]);
			}
			else 
			{
				m[x][k+1]=m[x][k];
				m1[x][k+1]=max(m[y][k],m1[x][k]);
			}
		    y=f[y][k];
		}
		for(ll i=last[x];i;i=next[i])
     	if(v[i]!=f[x][0]){
		     m[v[i]][0]=w[i];
		     f[v[i]][0]=x;
		     Q.push(v[i]);
	    }
	}
}
void lca(ll x,ll y)
{
	if(deep[x]&lt;deep[y]) swap(x,y);
	ll k=0;
	for(ll i=deep[x]-deep[y];i;i=i&gt;&gt;1)
	{
		if(i&amp;1) 
		{
			if(maxn&lt;m[x][k]) 
			{
				max1=max(maxn,m1[x][k]);
				maxn=m[x][k];
			}
			else if(maxn==m[x][k])
				max1=max(max1,m1[x][k]);
			else max1=max(max1,m[x][k]);
			x=f[x][k];
		}
		k++;
	}
	if(x==y) return;
	k=0;
	while(k&gt;=0)
	{
		if(f[x][k]!=f[y][k]) 
		{
			if(maxn&lt;m[x][k]) 
			{
				max1=max(maxn,m1[x][k]);
				maxn=m[x][k];
			}
			else if(maxn==m[x][k])
				max1=max(max1,m1[x][k]);
			else max1=max(max1,m[x][k]);
			x=f[x][k];
			if(maxn&lt;m[y][k]) 
			{
				max1=max(maxn,m1[y][k]);
				maxn=m[y][k];
			}
			else if(maxn==m[y][k])
				max1=max(max1,m1[y][k]);
			else max1=max(max1,m[y][k]);
			y=f[y][k];
			k++;
		}
		else k--;
	}
    if(maxn&lt;m[x][0]) 
	{
			max1=max(maxn,m1[x][0]);
			maxn=m[x][0];
	}
    else if(maxn==m[x][0])
		max1=max(max1,m1[x][0]);
	else max1=max(max1,m[x][0]); 
	if(maxn&lt;m[y][0]) 
	{
			max1=max(maxn,m1[y][0]);
			maxn=m[y][0];
	}
    else if(maxn==m[y][0])
		max1=max(max1,m1[y][0]);
	else max1=max(max1,m[y][0]); 
}
int main()
{
	scanf(&quot;%lld%lld&quot;,&amp;n,&amp;mm);
	for(ll i=1;i&lt;=mm;i++)
	  scanf(&quot;%lld%lld%lld&quot;,&amp;a[i].x,&amp;a[i].y,&amp;a[i].z);
	for(ll i=1;i&lt;=n;i++) fa[i]=i;
	sort(a+1,a+mm+1,cmp);
	for(ll i=1;i&lt;=mm;i++)
	{
		ll f1=find(a[i].x); 
		ll f2=find(a[i].y);
	    if(f1!=f2)
		{
			fa[f1]=f2; 
			a[i].fl=1; 
			num++;
			add(a[i].x,a[i].y,a[i].z);
			add(a[i].y,a[i].x,a[i].z);
			sum+=a[i].z;
		}
		if(num==n-1) break; 
	}
	bfs();
	ans1=922337203685477580ll;
	for(ll i=1;i&lt;=mm;i++)
	if(!a[i].fl)
	{
		maxn=0,max1=0;
		lca(a[i].x,a[i].y);
		if(a[i].z==maxn) ans=sum-max1+maxn;
		else ans=sum-maxn+a[i].z;
		ans1=min(ans,ans1);
	}
	cout&lt;&lt;ans1&lt;&lt;endl;
}<pre><h2>Problem1977</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#define ll long long
using namespace std;
ll n,mm,deep[220000],f[220000][30],fa[220000],num,t,maxn,max1;
ll m[220000][30],m1[220000][30];
ll last[440000],next[440000],v[440000],w[440000];
ll sum,ans,ans1;
struct rec{
	ll x,y,z,fl;
}a[990000];
queue&lt;ll&gt;Q;
bool cmp(rec i,rec j) {return i.z&lt;j.z;}
void add(ll x,ll y,ll z)
{
	v[++t]=y;
	next[t]=last[x];
	last[x]=t;
	w[t]=z;
}
ll find(ll x)
{
	if(fa[x]==x) return x;
	fa[x]=find(fa[x]);
	return fa[x];
}
void update(ll &amp;ans1,ll &amp;ans2,ll m1,ll m2)
{
	if (ans1&lt;m1)
	{
		ans2=max(ans1,m2);
		ans1=m1;
	}
	else if (ans1==m1) ans2=max(ans2,m2);
	else ans2=max(ans2,m1);
}
void bfs()
{
	Q.push(1);
	while(Q.size())
	{
		ll x=Q.front();
		Q.pop();
		ll y=f[x][0];
		deep[x]=deep[y]+1;
		for(ll k=0;f[y][k]!=0;k++)
		{
			f[x][k+1]=f[y][k];
			if(m[y][k]&gt;m[x][k])
			{
				m[x][k+1]=m[y][k];
				m1[x][k+1]=max(m1[y][k],m[x][k]);
			}
			else if(m[y][k]==m[x][k])
			{
				m[x][k+1]=m[y][k];
				m1[x][k+1]=max(m1[y][k],m1[x][k]);
			}
			else 
			{
				m[x][k+1]=m[x][k];
				m1[x][k+1]=max(m[y][k],m1[x][k]);
			}
		    y=f[y][k];
		}
		for(ll i=last[x];i;i=next[i])
     	if(v[i]!=f[x][0]){
		     m[v[i]][0]=w[i];
		     f[v[i]][0]=x;
		     Q.push(v[i]);
	    }
	}
}
void lca(ll x,ll y)
{
	if(deep[x]&lt;deep[y]) swap(x,y);
	ll k=0;
	for(ll i=deep[x]-deep[y];i;i=i&gt;&gt;1)
	{
		if(i&amp;1) 
		{
			update(maxn,max1,m[x][k],m1[x][k]);
			x=f[x][k];
		}
		k++;
	}
	if(x==y) return;
	k=0;
	while(k&gt;=0)
	{
		if(f[x][k]!=f[y][k]) 
		{
			update(maxn,max1,m[x][k],m1[x][k]);
			x=f[x][k];
			update(maxn,max1,m[y][k],m1[y][k]);
			y=f[y][k];
			k++;
		}
		else k--;
	}
    update(maxn,max1,m[x][0],m1[x][0]);
	update(maxn,max1,m[y][0],m1[y][0]);
}
int main()
{
	scanf(&quot;%lld%lld&quot;,&amp;n,&amp;mm);
	for(ll i=1;i&lt;=mm;i++)
	  scanf(&quot;%lld%lld%lld&quot;,&amp;a[i].x,&amp;a[i].y,&amp;a[i].z);
	for(ll i=1;i&lt;=n;i++) fa[i]=i;
	sort(a+1,a+mm+1,cmp);
	for(ll i=1;i&lt;=mm;i++)
	{
		ll f1=find(a[i].x); 
		ll f2=find(a[i].y);
	    if(f1!=f2)
		{
			fa[f1]=f2; 
			a[i].fl=1; 
			num++;
			add(a[i].x,a[i].y,a[i].z);
			add(a[i].y,a[i].x,a[i].z);
			sum+=a[i].z;
		}
		if(num==n-1) break; 
	}
	bfs();
	ans1=922337203685477580ll;
	for(ll i=1;i&lt;=mm;i++)
	if(!a[i].fl)
	{
		maxn=0,max1=0;
		lca(a[i].x,a[i].y);
		if(a[i].z==maxn) ans=sum-max1+maxn;
		else ans=sum-maxn+a[i].z;
		ans1=min(ans,ans1);
	}
	cout&lt;&lt;ans1&lt;&lt;endl;
}<pre><h2>Problem1977</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define inf 1e9
#define NN 300009
#define N 100009
#define rep(i,s,t) for(int i=s;i&lt;=t;i++)
#define red(i,t,s) for(int i=t;i&gt;=s;i--)
#define Clean(x) memset(x,0,sizeof(x))
using namespace std;
int to[N*2],nex[N*2],w[N*2],o[N];
int father[N],fa[N][12],val[N][12],val2[NN][12],dep[N]; //注意数组名称，不要重了; 
bool use[NN];
int n,m,cc=0;
long long res;
struct Edge
{
	int u,v,w;
	void in(){scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);}
	friend bool operator &lt;(Edge a,Edge b){return a.w&lt;b.w;}
}e[NN];

inline int getfa(int x)
{
	if (father[x]==x)return x;
	father[x]=getfa(father[x]);
	return father[x];
}

inline void add(int x,int y,int c)
{
	to[++cc]=y,w[cc]=c,nex[cc]=o[x],o[x]=cc;//加边注意细节 
	to[++cc]=x,w[cc]=c,nex[cc]=o[y],o[y]=cc;
}

void get(int x1,int x2,int y1,int y2,int &amp;m1,int &amp;m2)
{
	int t1,t2,t3;
	m1=t1=max(x1,x2);
	t2=min(x1,x2);
	t3=max(y1,y2);
	if (t1==t2) m2=t3;
	else m2=max(t2,t3);
}

void dfs(int x)
{
	rep(i,1,10)//数组用到10，至少要开到11 ！！！！！！ 
	{
		if ((1&lt;&lt;i)&gt;dep[x])break;
		fa[x][i]=fa[fa[x][i-1]][i-1];
		
		get(val[x][i-1],val[fa[x][i-1]][i-1],val2[x][i-1],val2[fa[x][i-1]][i-1],val[x][i],val2[x][i]);
	}
	for (int k=o[x];k;k=nex[k])
	{
		int y=to[k];
		if (y==fa[x][0])continue;
		dep[y]=dep[x]+1;
		fa[y][0]=x;
		val[y][0]=w[k];
		for(int i=1;i&lt;=10;i++)
			val2[y][i]=-inf;
		dfs(y);
	}
}

void getmax(int x,int y,int &amp;res1,int &amp;res2)
{
	int tmp=-1,tmp2=-1,t1,t2;
	if (dep[x]&lt;dep[y])swap(x,y);
	red(i,10,0)
		if (dep[fa[x][i]]&gt;=dep[y])
		{
			get(tmp,val[x][i],tmp2,val2[x][i],t1,t2);
			tmp=t1,tmp2=t2;
			x=fa[x][i];
		}
	res1=tmp,res2=tmp2;
	if (x==y)return;
	red(i,10,0)
		if (fa[x][i]!=fa[y][i])
		{
			get(tmp,val[x][i],tmp2,val2[x][i],t1,t2);		
			get(t1,val[y][i],t2,val2[x][i],tmp,tmp2);
			x=fa[x][i],y=fa[y][i];
		}
	get(tmp,val[x][0],tmp2,val2[x][0],t1,t2);		
	get(t1,val[y][0],t2,val2[x][0],res1,res2);
}
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);//freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	Clean(o),Clean(use);
	Clean(fa);Clean(val2);
	Clean(val);
	rep(i,1,n)father[i]=i;
	res=0,cc=0;
	rep(i,1,m)e[i].in();
	sort(e+1,e+m+1);
	rep(i,1,m)
	{
		int x=getfa(e[i].u),y=getfa(e[i].v);
		if (x!=y)
			father[x]=y,res+=e[i].w,add(e[i].u,e[i].v,e[i].w),use[i]=1;  
	}//加边一定加原边，不能加getfa之后的！！！！ 
	
	dep[1]=1;
	dfs(1);
	
	long long ans=inf*inf;
	rep(i,1,m)
	{
		if (use[i])continue;
		int x=e[i].u,y=e[i].v;
		int mx1,mx2;
		getmax(x,y,mx1,mx2);
		ans=min(ans,res+e[i].w-((mx1==e[i].w)?mx2:mx1));
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem1982</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,a[101111];
bool check()
{
	if (n&amp;1) return true;
	sort(a+1,a+n+1);
	for (int i=1;i&lt;=n;i+=2)
		if (a[i]!=a[i+1]) return true;
	return false;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	printf(check()?&quot;first player\n&quot;:&quot;second player\n&quot;);
	return 0;
}<pre><h2>Problem1984</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define lc(v) ((v)&lt;&lt;1)
#define rc(v) ((v)&lt;&lt;1|1)
#define ln printf(&quot;\n&quot;)
const int NN=101111;
int size[NN],fa[NN],o[NN],a[NN],heavy[NN],up[NN],deep[NN],pos[NN],aa[NN*2][3];
int tmax[NN*4],tag1[NN*4],tag2[NN*4];
int n,cnt,ww,ee,tot=1;
void out(int*a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
struct edge {int a,b,w;} e[NN];
void dfs1(int v)
{
	int tmp=0,mm=0;
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		dfs1(y);
		size[v]+=size[y];
		if (size[y]&gt;mm) mm=size[y],tmp=y;
	}
	heavy[v]=tmp;
}
void dfs2(int v)
{
	pos[v]=++cnt;
	if (!heavy[v]) return;
	up[heavy[v]]=up[v];
	dfs2(heavy[v]);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		if (y==heavy[v])
			{a[pos[y]]=aa[p][2];continue;}
		up[y]=y;
		dfs2(y);
		a[pos[y]]=aa[p][2];
	}
}
void make1(int v,int x)
{
	tag1[v]=tmax[v]=x;
	tag2[v]=0;
}
void make2(int v,int x)
{
	tmax[v]+=x,tag2[v]+=x;
}
void pushdown(int v)
{
	int x=lc(v),y=rc(v);
	if (tag1[v]!=-1)
	{
		make1(x,tag1[v]),make1(y,tag1[v]);
		tag1[v]=-1;
	}
	if (tag2[v]!=0)
	{
		make2(x,tag2[v]),make2(y,tag2[v]);
		tag2[v]=0;
	}
}
void update(int v)
{
	tmax[v]=max(tmax[lc(v)],tmax[rc(v)]);
}
void build(int v,int l,int r)
{
	tag1[v]=-1,tag2[v]=0;
	if (r-l==1)
	{
		tmax[v]=a[l];
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(lc(v),l,mid);
	build(rc(v),mid,r);
	update(v);
}
void change(int kind,int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		if (kind==1) make1(v,x);else make2(v,x);
		return;
	}
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) change(kind,lc(v),l,mid,x);
	if (ee&gt;mid) change(kind,rc(v),mid,r,x);
	update(v);
}
int find(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tmax[v];
	pushdown(v);
	int mid=(l+r)&gt;&gt;1,res=0;
	if (ww&lt;mid) res=max(res,find(lc(v),l,mid));
	if (ee&gt;mid) res=max(res,find(rc(v),mid,r));
	return res;
}
void modify(int kind,int x,int y,int w)
{
	while (up[x]!=up[y])
	{
		if (deep[up[x]]&lt;deep[up[y]]) {int t=x;x=y;y=t;}
		ww=pos[up[x]],ee=pos[x]+1;
		change(kind,1,1,n+1,w);
		x=fa[up[x]];
	}
	if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
	ww=pos[y]+1,ee=pos[x]+1;
	change(kind,1,1,n+1,w);
}
int getmax(int x,int y)
{
	int res=0;
	while (up[x]!=up[y])
	{
		if (deep[up[x]]&lt;deep[up[y]]) {int t=x;x=y;y=t;}
		ww=pos[up[x]],ee=pos[x]+1;
		res=max(res,find(1,1,n+1));
		x=fa[up[x]];
	}
	if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
	ww=pos[y]+1,ee=pos[x]+1;
	res=max(res,find(1,1,n+1));
	return res;
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d\n&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
		addedge(e[i].a,e[i].b,e[i].w),addedge(e[i].b,e[i].a,e[i].w);
	}
	deep[1]=1;
	dfs1(1);
	up[1]=1;
	dfs2(1);
	build(1,1,n+1);
	//printf(&quot;pos &quot;);out(pos,1,n);printf(&quot;up &quot;);out(up,1,n);printf(&quot;a &quot;);out(a,1,n);
	for (;;)
	{
		char s[7];
		scanf(&quot;%s&quot;,s+1);
		//printf(&quot;\n-------------------- s=%s -------------------------------------------------------\n&quot;,s+1);
		if (s[1]=='S') break;
		else if (s[1]=='M')
		{
			scanf(&quot;%d%d\n&quot;,&amp;x,&amp;y);
			printf(&quot;%d\n&quot;,getmax(x,y));
		}
		else if (s[1]=='C'&amp;&amp;s[2]=='o')
		{
			scanf(&quot;%d%d%d\n&quot;,&amp;x,&amp;y,&amp;z);
			modify(1,x,y,z);
		}
		else if (s[1]=='C')
		{
			scanf(&quot;%d%d\n&quot;,&amp;x,&amp;y);
			modify(1,e[x].a,e[x].b,y);
		}
		else
		{
			scanf(&quot;%d%d%d\n&quot;,&amp;x,&amp;y,&amp;z);
			modify(2,x,y,z);
		}
	}
	return 0;
}<pre><h2>Problem1984</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define lc(v) ((v)&lt;&lt;1)
#define rc(v) ((v)&lt;&lt;1|1)
const int NN=101111;
int size[NN],fa[NN],o[NN],a[NN],heavy[NN],up[NN],deep[NN],pos[NN],aa[NN*2][3];
int tmax[NN*4],tag1[NN*4],tag2[NN*4];
int n,cnt,ww,ee,tot=1;
struct edge {int a,b,w;} e[NN];
void dfs1(int v)
{
	int tmp=0,mm=0;
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		dfs1(y);
		size[v]+=size[y];
		if (size[y]&gt;mm) mm=size[y],tmp=y;
	}
	heavy[v]=tmp;
}
void dfs2(int v)
{
	pos[v]=++cnt;
	if (!heavy[v]) return;
	up[heavy[v]]=up[v];
	dfs2(heavy[v]);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		if (y==heavy[v])
			{a[pos[y]]=aa[p][2];continue;}
		up[y]=y;
		dfs2(y);
		a[pos[y]]=aa[p][2];
	}
}
void make1(int v,int x)
{
	tag1[v]=tmax[v]=x;
	tag2[v]=0;
}
void make2(int v,int x)
{
	tmax[v]+=x,tag2[v]+=x;
}
void pushdown(int v)
{
	int x=lc(v),y=rc(v);
	if (tag1[v]!=-1)
	{
		make1(x,tag1[v]),make1(y,tag1[v]);
		tag1[v]=-1;
	}
	if (tag2[v]!=0)
	{
		make2(x,tag2[v]),make2(y,tag2[v]);
		tag2[v]=0;
	}
}
void update(int v)
{
	tmax[v]=max(tmax[lc(v)],tmax[rc(v)]);
}
void build(int v,int l,int r)
{
	tag1[v]=-1,tag2[v]=0;
	if (r-l==1)
	{
		tmax[v]=a[l];
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(lc(v),l,mid);
	build(rc(v),mid,r);
	update(v);
}
void change(int kind,int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		if (kind==1) make1(v,x);else make2(v,x);
		return;
	}
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) change(kind,lc(v),l,mid,x);
	if (ee&gt;mid) change(kind,rc(v),mid,r,x);
	update(v);
}
int find(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tmax[v];
	pushdown(v);
	int mid=(l+r)&gt;&gt;1,res=0;
	if (ww&lt;mid) res=max(res,find(lc(v),l,mid));
	if (ee&gt;mid) res=max(res,find(rc(v),mid,r));
	return res;
}
void modify(int kind,int x,int y,int w)
{
	while (up[x]!=up[y])
	{
		if (deep[up[x]]&lt;deep[up[y]]) {int t=x;x=y;y=t;}
		ww=pos[up[x]],ee=pos[x]+1;
		change(kind,1,1,n+1,w);
		x=fa[up[x]];
	}
	if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
	ww=pos[y]+1,ee=pos[x]+1;
	change(kind,1,1,n+1,w);
}
int getmax(int x,int y)
{
	int res=0;
	while (up[x]!=up[y])
	{
		if (deep[up[x]]&lt;deep[up[y]]) {int t=x;x=y;y=t;}
		ww=pos[up[x]],ee=pos[x]+1;
		res=max(res,find(1,1,n+1));
		x=fa[up[x]];
	}
	if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
	ww=pos[y]+1,ee=pos[x]+1;
	res=max(res,find(1,1,n+1));
	return res;
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d\n&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
		addedge(e[i].a,e[i].b,e[i].w),addedge(e[i].b,e[i].a,e[i].w);
	}
	deep[1]=1;
	dfs1(1);
	up[1]=1;
	dfs2(1);
	build(1,1,n+1);
	for (;;)
	{
		char s[7];
		scanf(&quot;%s&quot;,s+1);
		if (s[1]=='S') break;
		else if (s[1]=='M')
		{
			scanf(&quot;%d%d\n&quot;,&amp;x,&amp;y);
			printf(&quot;%d\n&quot;,getmax(x,y));
		}
		else if (s[1]=='C'&amp;&amp;s[2]=='o')
		{
			scanf(&quot;%d%d%d\n&quot;,&amp;x,&amp;y,&amp;z);
			modify(1,x,y,z);
		}
		else if (s[1]=='C')
		{
			scanf(&quot;%d%d\n&quot;,&amp;x,&amp;y);
			modify(1,e[x].a,e[x].b,y);
		}
		else
		{
			scanf(&quot;%d%d%d\n&quot;,&amp;x,&amp;y,&amp;z);
			modify(2,x,y,z);
		}
	}
	return 0;
}<pre><h2>Problem1984</h2><pre>#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#define inf 2e9
#define NN 200009
#define update(x) tm[x]=max(tm[x&lt;&lt;1],tm[(x&lt;&lt;1)+1])
using namespace std;
int to[NN*2],nex[NN*2],o[NN],w[NN*2];
int dep[NN],fa[NN],S[NN],son[NN],val[NN];
int pos[NN],wh[NN],up[NN],Kth[NN];
int add[NN*4],change[NN*4],tm[NN*4];
int n,m,cc=0,cnt=0;

void AddEdge(int x,int y,int z)
{
	to[++cc]=y;w[cc]=z;nex[cc]=o[x];o[x]=cc;
	to[++cc]=x;w[cc]=z;nex[cc]=o[y];o[y]=cc;
}

void dfs1(int x)
{
	S[x]=1;son[x]=0;
	int mx=-inf;
	for (int k=o[x];k;k=nex[k])
	{
		int y=to[k];
		if (y==fa[x])continue;
		fa[y]=x;
		val[y]=w[k];
		dep[y]=dep[x]+1;
		dfs1(y);
		Kth[(k+1)/2]=y;
		S[x]+=S[y];
		if (S[y]&gt;mx)son[x]=y,mx=S[y];
	}
}

void dfs2(int x)
{
	pos[x]=++cnt;
	wh[cnt]=x;
	if (!son[x])return;
	up[son[x]]=up[x];
	dfs2(son[x]);
	for (int k=o[x];k;k=nex[k])
	{
		int y=to[k];
		if (y==fa[x]||y==son[x])continue;
		up[y]=y;
		dfs2(y);
	}
}

////////////////////////////////////////////

void clear(int x,int l)
{
	int e=x&lt;&lt;1;
	if (change[x]!=-inf)
		change[e]=change[e+1]=tm[e]=tm[e+1]=change[x],add[e]=add[e+1]=0;
	if (add[x])
	{	
		add[e]+=add[x];
		tm[e]+=add[x];
		e++;
		add[e]+=add[x];
		tm[e]+=add[x];
	}
	add[x]=0;
	change[x]=-inf;
}

void build(int p,int l,int r)
{
	add[p]=0;change[p]=-inf;
	if (l==r)
	{
		tm[p]=val[wh[l]];
//		printf(&quot;%dto%d,maxval is %d\n&quot;,wh[l],wh[r],tm[p]);
		return;
	}
	int mid=l+r&gt;&gt;1;
	build(p&lt;&lt;1,l,mid);
	build((p&lt;&lt;1)+1,mid+1,r);
	update(p);
}

void Change(int p,int l,int r,int ss,int tt,int x)
{
	
	if (l==ss &amp;&amp;r==tt)
	{
		add[p]=0;
		change[p]=tm[p]=x;
		return;
	}
	clear(p,r-l+1);
	int mid=l+r&gt;&gt;1;
	if (tt&lt;=mid)Change(p&lt;&lt;1,l,mid,ss,tt,x);
	else if (ss&gt;mid)Change((p&lt;&lt;1)+1,mid+1,r,ss,tt,x);
	else Change(p&lt;&lt;1,l,mid,ss,mid,x),Change((p&lt;&lt;1)+1,mid+1,r,mid+1,tt,x);
	update(p);
}

void Add(int p,int l,int r,int ss,int tt,int x)
{
	if (l==ss &amp;&amp;r==tt)
	{
		add[p]+=x;
		tm[p]+=x;
		return;
	}
	clear(p,r-l+1);
	int mid=l+r&gt;&gt;1;
	if (tt&lt;=mid)Add(p&lt;&lt;1,l,mid,ss,tt,x);
	else if (ss&gt;mid)Add((p&lt;&lt;1)+1,mid+1,r,ss,tt,x);
	else Add(p&lt;&lt;1,l,mid,ss,mid,x),Add((p&lt;&lt;1)+1,mid+1,r,mid+1,tt,x);
	update(p);
}

int query(int p,int l,int r,int ss,int tt)
{
	if (l==ss &amp;&amp; r==tt)
		return tm[p];
	clear(p,r-l+1);
	int mid=l+r&gt;&gt;1;
	p&lt;&lt;=1;
	if (tt&lt;=mid)return query(p,l,mid,ss,tt);
	else if (ss&gt;mid)return query(p+1,mid+1,r,ss,tt);
	else return max(query(p,l,mid,ss,mid),query(p+1,mid+1,r,mid+1,tt));
}

int Askmax(int x,int y)
{
	int res=-inf;
	while(up[x]!=up[y])
	{
		if (dep[up[x]]&lt;dep[up[y]])swap(x,y);
		res=max(res,query(1,1,cnt,pos[up[x]],pos[x]));
		x=fa[up[x]];
	}
	if (x==y)return res;
	if (dep[x]&gt;dep[y])swap(x,y);
	if (x!=y)res=max(res,query(1,1,cnt,pos[x]+1,pos[y]));
	return res;
}

void ChangeAll(int x,int y,int t)
{
	while(up[x]!=up[y])
	{
		if (dep[up[x]]&lt;dep[up[y]])swap(x,y);
		Change(1,1,cnt,pos[up[x]],pos[x],t);
		x=fa[up[x]];
	}
	if (x==y)return;
	if (dep[x]&gt;dep[y])swap(x,y);
	if (x!=y)Change(1,1,cnt,pos[x]+1,pos[y],t);	
}

void AddAll(int x,int y,int t)
{
	while(up[x]!=up[y])
	{
		if (dep[up[x]]&lt;dep[up[y]])swap(x,y);
		Add(1,1,cnt,pos[up[x]],pos[x],t);
		x=fa[up[x]];
	}
	if (x==y)return;
	if (dep[x]&gt;dep[y])swap(x,y);
	if (x!=y)Add(1,1,cnt,pos[x]+1,pos[y],t);		
}

int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d&quot;,&amp;n);
	int u,v,tt;
	for (int i=1;i&lt;n;i++)
		scanf(&quot;%d%d%d\n&quot;,&amp;u,&amp;v,&amp;tt),AddEdge(u,v,tt);
	cnt=0;
	dep[1]=1;
	up[1]=1;
	dfs1(1);
	dfs2(1);
	build(1,1,cnt);
	while(1)
	{
		int x,y,z;char s[10];
		scanf(&quot;%s%d%d\n&quot;,s,&amp;x,&amp;y);
		if (s[1]=='t')break;
		else if (s[1]=='d')scanf(&quot;%d&quot;,&amp;z),AddAll(x,y,z);
		else if (s[1]=='o')scanf(&quot;%d&quot;,&amp;z),ChangeAll(x,y,z);
		else if (s[1]=='h')ChangeAll(fa[Kth[x]],Kth[x],y);
		else if (s[1]=='a')printf(&quot;%d\n&quot;,Askmax(x,y));
		
	}
	return 0;
}<pre><h2>Problem1984</h2><pre>#include &lt;cstdio&gt;
//#include &lt;ctime&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define NN 100100
#define N 401000
#define rep(i,s,t) for (int i=s;i&lt;=t;i++)
#define vtson(k,x) for (int k=o[x];k;k=e[k].nex)
#define tm ttm
using namespace std;
int add[N],change[N],tm[N];
int pos[NN],wh[NN],son[NN],up[NN];
int fa[NN],S[NN],dep[NN],o[NN],kth[NN*2],val[NN];
int n,m,cnt=0,cc=0;
long long sumnum1=0,sumnum2=0,sumnum3=0;
struct Edge{int to,nex,w;}e[NN*2];

inline void addedge(int x,int y,int c)
{
	e[++cc].to=y,e[cc].nex=o[x],o[x]=cc,e[cc].w=c;
	e[++cc].to=x,e[cc].nex=o[y],o[y]=cc,e[cc].w=c;
}

inline int read()
{
	int t=0,f=1;char ch=getchar();
	while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch&gt;='0'&amp;&amp;ch&lt;='9')t=t*10+ch-'0',ch=getchar();
	return t*f;
}

void dfs1(int x)
{
	S[x]=1;
	int tmp=0;
	vtson(k,x)
	{
		int y=e[k].to;
		if(y==fa[x])continue;
		dep[y]=dep[x]+1;
		fa[y]=x;
		val[y]=e[k].w;
		kth[(k+1)/2]=y;
		dfs1(y);
		S[x]+=S[y];
		if(S[y]&gt;tmp)tmp=S[y],son[x]=y;
	}
}

void dfs2(int x)
{
	pos[x]=++cnt;
	wh[cnt]=x;
	if(!son[x])return;
	up[son[x]]=up[x];
	dfs2(son[x]);
	vtson(k,x)
	{
		int y=e[k].to;
		if(y==son[x]||y==fa[x])continue;
		up[y]=y;
		dfs2(y);
	}
}

//=======================================================================================================================

inline void make1(int p,int x){change[p]=tm[p]=x,add[p]=0;}
inline void make0(int p,int x){add[p]+=x,tm[p]+=x;}
inline void update(int p){tm[p]=max(tm[p&lt;&lt;1],tm[p&lt;&lt;1|1]);}

void clear(int p)
{
	if(change[p]!=-1)
		make1(p&lt;&lt;1,change[p]),make1(p&lt;&lt;1|1,change[p]),change[p]=-1;
	if(add[p])
		make0(p&lt;&lt;1,add[p]),make0(p&lt;&lt;1|1,add[p]),add[p]=0;
}

void build(int p,int l,int r)
{
	change[p]=-1,add[p]=0;
	if(l==r){tm[p]=val[wh[l]];return;}
	int mid=(l+r)&gt;&gt;1;
	build(p&lt;&lt;1,l,mid);
	build(p&lt;&lt;1|1,mid+1,r);
	update(p);
}

void Change(int p,int l,int r,int s,int t,int x,int kind)//kind=1:change    kind=0:add
{
	sumnum2++;
	if(l==s&amp;&amp;r==t)
	{
		(kind)?make1(p,x):make0(p,x);
		return;
	}
	clear(p);
	int mid=(l+r)&gt;&gt;1;
	if(t&lt;=mid) Change(p&lt;&lt;1,l,mid,s,t,x,kind);
	else if(s&gt;mid) Change(p&lt;&lt;1|1,mid+1,r,s,t,x,kind);
	else Change(p&lt;&lt;1,l,mid,s,mid,x,kind),Change(p&lt;&lt;1|1,mid+1,r,mid+1,t,x,kind);
	update(p);
}

int query(int p,int l,int r,int s,int t)
{
	sumnum3++;
	if(l==s&amp;&amp;r==t)return tm[p];
	clear(p);
	int mid=(l+r)&gt;&gt;1;
	if(t&lt;=mid) return query(p&lt;&lt;1,l,mid,s,t);
	else if(s&gt;mid) return query(p&lt;&lt;1|1,mid+1,r,s,t);
	else return max(query(p&lt;&lt;1,l,mid,s,mid),query(p&lt;&lt;1|1,mid+1,r,mid+1,t));
}

//=======================================================================================================================

void solvechange(int x,int y,int t,int kind)
{
	while(up[x]!=up[y])
	{
		sumnum1++;
		if(dep[up[x]]&lt;dep[up[y]])swap(x,y);
		Change(1,1,cnt,pos[up[x]],pos[x],t,kind);
		x=fa[up[x]];
	}
	if(x==y)return;
	if(dep[x]&gt;dep[y])swap(x,y);
	Change(1,1,cnt,pos[x]+1,pos[y],t,kind);
}

int getans(int x,int y)
{
	int res=-2e9;
	while(up[x]!=up[y])
	{
		sumnum1++;
		if(dep[up[x]]&lt;dep[up[y]])swap(x,y);
		res=max(res,query(1,1,cnt,pos[up[x]],pos[x]));
		x=fa[up[x]];
	}
	if(x==y)return res;
	if(dep[x]&gt;dep[y])swap(x,y);
	res=max(res,query(1,1,cnt,pos[x]+1,pos[y]));
	return res;
}

//=======================================================================================================================

int main()
{
//	clock_t st=clock();
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	n=read();
	for (int x,y,t,i=1;i&lt;n;i++)
		x=read(),y=read(),t=read(),addedge(x,y,t);
	up[1]=dep[1]=1;
	dfs1(1);
	dfs2(1);
	build(1,1,cnt);
	char s[10];
	int xx,yy,tt;
//	printf(&quot;Kth: &quot;);rep(i,1,n-1)printf(&quot;%d &quot;,kth[i]);printf(&quot;\n&quot;);
//	printf(&quot;pos: &quot;);rep(i,1,n)printf(&quot;%d \n&quot;,pos[i]);printf(&quot;\n&quot;);
//	printf(&quot;wh : &quot;);rep(i,1,n)printf(&quot;%d &quot;,wh[i]);printf(&quot;\n&quot;);
//	printf(&quot;up : &quot;);rep(i,1,n)printf(&quot;%d \n &quot;,up[i]);printf(&quot;\n&quot;);
//	printf(&quot;val: &quot;);rep(i,1,n)printf(&quot;%d &quot;,val[i]);printf(&quot;\n&quot;);
	while(1)
	{
		scanf(&quot;%s&quot;,s);
		if(s[1]=='t')break;
		xx=read(),yy=read();
		if(s[1]=='a')printf(&quot;%d\n&quot;,getans(xx,yy));
		else if(s[1]=='h')solvechange(fa[kth[xx]],kth[xx],yy,1);
		else if(s[1]=='o'||s[1]=='d')
			tt=read(),solvechange(xx,yy,tt,(int)(s[1]=='o'));
	}	
//	freopen(&quot;log.txt&quot;,&quot;a&quot;,stdout);
//	printf(&quot;cnt=%d;;&quot;,cnt);
  //  printf(&quot;%lld  %lld  %lld   &quot;,sumnum1,sumnum2,sumnum3);
	//printf(&quot;%.3lf\n&quot;,(double)(clock()-st)/CLOCKS_PER_SEC);
	return 0;
}<pre><h2>Problem1984</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define NN 100100
#define N 401000
#define rep(i,s,t) for (int i=s;i&lt;=t;i++)
#define vtson(k,x) for (int k=o[x];k;k=e[k].nex)
#define tm ttm
using namespace std;
int add[N],change[N],tm[N];
int pos[NN],wh[NN],son[NN],up[NN];
int fa[NN],S[NN],dep[NN],o[NN],kth[NN*2],val[NN];
int n,m,cnt=0,cc=0;
long long sumnum1=0,sumnum2=0,sumnum3=0;
struct Edge{int to,nex,w;}e[NN*2];

inline void addedge(int x,int y,int c)
{
	e[++cc].to=y,e[cc].nex=o[x],o[x]=cc,e[cc].w=c;
	e[++cc].to=x,e[cc].nex=o[y],o[y]=cc,e[cc].w=c;
}

inline int read()
{
	int t=0,f=1;char ch=getchar();
	while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch&gt;='0'&amp;&amp;ch&lt;='9')t=t*10+ch-'0',ch=getchar();
	return t*f;
}

void dfs1(int x)
{
	S[x]=1;
	int tmp=0;
	vtson(k,x)
	{
		int y=e[k].to;
		if(y==fa[x])continue;
		dep[y]=dep[x]+1;
		fa[y]=x;
		val[y]=e[k].w;
		kth[(k+1)/2]=y;
		dfs1(y);
		S[x]+=S[y];
		if(S[y]&gt;tmp)tmp=S[y],son[x]=y;
	}
}

void dfs2(int x)
{
	pos[x]=++cnt;
	wh[cnt]=x;
	if(!son[x])return;
	up[son[x]]=up[x];
	dfs2(son[x]);
	vtson(k,x)
	{
		int y=e[k].to;
		if(y==son[x]||y==fa[x])continue;
		up[y]=y;
		dfs2(y);
	}
}

//====================================================

inline void make1(int p,int x){change[p]=tm[p]=x,add[p]=0;}
inline void make0(int p,int x){add[p]+=x,tm[p]+=x;}
inline void update(int p){tm[p]=max(tm[p&lt;&lt;1],tm[p&lt;&lt;1|1]);}

void clear(int p)
{
	if(change[p]!=-1)
		make1(p&lt;&lt;1,change[p]),make1(p&lt;&lt;1|1,change[p]),change[p]=-1;
	if(add[p])
		make0(p&lt;&lt;1,add[p]),make0(p&lt;&lt;1|1,add[p]),add[p]=0;
}

void build(int p,int l,int r)
{
	change[p]=-1,add[p]=0;
	if(l==r){tm[p]=val[wh[l]];return;}
	int mid=(l+r)&gt;&gt;1;
	build(p&lt;&lt;1,l,mid);
	build(p&lt;&lt;1|1,mid+1,r);
	update(p);
}

void Change(int p,int l,int r,int s,int t,int x,int kind)//kind=1:change    kind=0:add
{
	sumnum2++;
	if(l==s&amp;&amp;r==t)
	{
		(kind)?make1(p,x):make0(p,x);
		return;
	}
	clear(p);
	int mid=(l+r)&gt;&gt;1;
	if(t&lt;=mid) Change(p&lt;&lt;1,l,mid,s,t,x,kind);
	else if(s&gt;mid) Change(p&lt;&lt;1|1,mid+1,r,s,t,x,kind);
	else Change(p&lt;&lt;1,l,mid,s,mid,x,kind),Change(p&lt;&lt;1|1,mid+1,r,mid+1,t,x,kind);
	update(p);
}

int query(int p,int l,int r,int s,int t)
{
	sumnum3++;
	if(l==s&amp;&amp;r==t)return tm[p];
	clear(p);
	int mid=(l+r)&gt;&gt;1;
	if(t&lt;=mid) return query(p&lt;&lt;1,l,mid,s,t);
	else if(s&gt;mid) return query(p&lt;&lt;1|1,mid+1,r,s,t);
	else return max(query(p&lt;&lt;1,l,mid,s,mid),query(p&lt;&lt;1|1,mid+1,r,mid+1,t));
}

//==========================================================

void solvechange(int x,int y,int t,int kind)
{
	while(up[x]!=up[y])
	{
		sumnum1++;
		if(dep[up[x]]&lt;dep[up[y]])swap(x,y);
		Change(1,1,cnt,pos[up[x]],pos[x],t,kind);
		x=fa[up[x]];
	}
	if(x==y)return;
	if(dep[x]&gt;dep[y])swap(x,y);
	Change(1,1,cnt,pos[x]+1,pos[y],t,kind);
}

int getans(int x,int y)
{
	int res=-2e9;
	while(up[x]!=up[y])
	{
		sumnum1++;
		if(dep[up[x]]&lt;dep[up[y]])swap(x,y);
		res=max(res,query(1,1,cnt,pos[up[x]],pos[x]));
		x=fa[up[x]];
	}
	if(x==y)return res;
	if(dep[x]&gt;dep[y])swap(x,y);
	res=max(res,query(1,1,cnt,pos[x]+1,pos[y]));
	return res;
}

//===============================================

int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	n=read();
	for (int x,y,t,i=1;i&lt;n;i++)
		x=read(),y=read(),t=read(),addedge(x,y,t);
	up[1]=dep[1]=1;
	dfs1(1);
	dfs2(1);
	build(1,1,cnt);
	char s[10];
	int xx,yy,tt;
	while(1)
	{
		scanf(&quot;%s&quot;,s);
		if(s[1]=='t')break;
		xx=read(),yy=read();
		if(s[1]=='a')printf(&quot;%d\n&quot;,getans(xx,yy));
		else if(s[1]=='h')solvechange(fa[kth[xx]],kth[xx],yy,1);
		else if(s[1]=='o'||s[1]=='d')
			tt=read(),solvechange(xx,yy,tt,(int)(s[1]=='o'));
	}	
	return 0;
}<pre><h2>Problem1996</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define mo 19650827
int f[1011][1011],g[1011][1011],a[1011];
int n,i,len,j;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	for (i=1;i&lt;=n;i++) f[i][i]=1,g[i][i]=0;
	for (len=2;len&lt;=n;len++)
		for (i=1;i+len-1&lt;=n;i++)
		{
			j=i+len-1;
			if (a[i]&lt;a[i+1]) f[i][j]+=f[i+1][j];
			if (a[i]&lt;a[j]) f[i][j]+=g[i+1][j];
			if (a[j]&gt;a[j-1]) g[i][j]+=g[i][j-1];
			if (a[j]&gt;a[i]) g[i][j]+=f[i][j-1];
			f[i][j]%=mo;
			g[i][j]%=mo;
		}
	printf(&quot;%d\n&quot;,(f[1][n]+g[1][n])%mo);
	return 0;
}
<pre><h2>Problem1996</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define mo 19650827
int f[1005][1005],g[1005][1005],a[1005];
int n,i,len,j;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	int tt=1005,*x,*y;
	for (x=&amp;f[1][1],y=&amp;g[1][1],i=1;i&lt;=n;i++,x+=tt+1,y+=tt+1)
		*x=0,*y=1;
	for (len=2;len&lt;=n;len++)
		for (i=1;i+len-1&lt;=n;i++)
		{
			j=i+len-1;
			if (a[i]&lt;a[i+1]) f[i][j]+=f[i+1][j];
			if (a[i]&lt;a[j]) f[i][j]+=g[i+1][j];
			if (a[j]&gt;a[j-1]) g[i][j]+=g[i][j-1];
			if (a[j]&gt;a[i]) g[i][j]+=f[i][j-1];
			f[i][j]%=mo;
			g[i][j]%=mo;
		}
	int ans=f[1][n]+g[1][n];
	if (ans&gt;mo) ans%=mo;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1996</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define mo 19650827
int f[1005][1005],g[1005][1005],a[1005];
int n,i,len,j;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	int tt=1005,*x,*y;
	for (x=&amp;f[1][1],y=&amp;g[1][1],i=1;i&lt;=n;i++,x+=tt+1,y+=tt+1) *x=1,*y=0;
	for (len=1;len&lt;n;len++)
		for (x=&amp;f[1][len+1],y=&amp;g[1][len+1],i=1;i+len&lt;=n;i++,x+=tt+1,y+=tt+1)
		{
			j=i+len;
			if (a[i]&lt;a[i+1]) *x+=*(x+tt);
			if (a[j]&gt;a[j-1]) *y+=*(y-1);
			if (a[i]&lt;a[j])
			{
				*x+=*(y+tt);
				*y+=*(x-1);
			}
			if (*x&gt;mo) *x%=mo;
			if (*y&gt;mo) *y%=mo;
		}
	int ans=f[1][n]+g[1][n];
	if (ans&gt;mo) ans%=mo;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1996</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define mo 19650827
int f[1005][1005],g[1005][1005],a[1005];
int n,i,len,j;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	int tt=1005,*x,*y;
	for (x=&amp;f[1][1],y=&amp;g[1][1],i=1;i&lt;=n;i++,x+=tt+1,y+=tt+1) *x=1,*y=0;
	for (len=1;len&lt;n;len++)
		for (x=&amp;f[1][len+1],y=&amp;g[1][len+1],i=1;i+len&lt;=n;i++,x+=tt+1,y+=tt+1)
		{
			j=i+len;
			if (a[i]&lt;a[i+1]) *x+=*(x+tt);
			if (a[j]&gt;a[j-1]) *y+=*(y-1);
			if (a[i]&lt;a[j])
			{
				*x+=*(y+tt);
				*y+=*(x-1);
			}
			if (*x&gt;mo) *x-=mo;
			if (*y&gt;mo) *y-=mo;
		}
	int ans=f[1][n]+g[1][n];
	if (ans&gt;mo) ans%=mo;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1996</h2><pre>#include &lt;cstdio&gt;
using namespace std;
const int maxn=1010,p=19650827;
int f[maxn][maxn][2],n,a[maxn];
int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    int i,j,k,x,y,l;
    for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
    for (i=1;i&lt;n;i++)
        if (a[i]&lt;a[i+1]) f[i][i+1][0]=f[i][i+1][1]=1;
    for (l=2;l&lt;n;l++)
    for (i=1;i&lt;=n-l;i++)
    {
        j=i+l;
        if (a[i]&lt;a[i+1]) x=f[i+1][j][0]; else x=0;
        if (a[i]&lt;a[j]) x+=f[i+1][j][1];
        f[i][j][0]=x&gt;=p?x-p:x;
        if (a[j]&gt;a[j-1]) x=f[i][j-1][1]; else x=0;
        if (a[j]&gt;a[i]) x+=f[i][j-1][0];
        f[i][j][1]=x&gt;=p?x-p:x;
    }
    x=(f[1][n][0]+f[1][n][1])%p;
    if (x&lt;0) x+=p;
    printf(&quot;%d\n&quot;,x);
    return 0;
}
<pre><h2>Problem1996</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define mo 19650827
int f[1005][1005],g[1005][1005],a[1005];
int n,i,len,j;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	int tt=1005,*x,*y;
	for (i=1;i&lt;n;i++)
		if (a[i]&lt;a[i+1]) f[i][i+1]=g[i][i+1]=1;
	for (len=2;len&lt;n;len++)
		for (x=&amp;f[1][len+1],y=&amp;g[1][len+1],i=1;i+len&lt;=n;i++,x+=tt+1,y+=tt+1)
		{
			j=i+len;
			if (a[i]&lt;a[i+1]) *x+=*(x+tt);
			if (a[j]&gt;a[j-1]) *y+=*(y-1);
			if (a[i]&lt;a[j])
			{
				*x+=*(y+tt);
				*y+=*(x-1);
			}
			if (*x&gt;mo) *x-=mo;
			if (*y&gt;mo) *y-=mo;
		}
	int ans=f[1][n]+g[1][n];
	if (ans&gt;mo) ans%=mo;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1996</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int mo=19650827;
int f[1005][1005],g[1005][1005],a[1005];
int n,i,len,j;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	int tt=1005,*x,*y;
	for (i=1;i&lt;n;i++)
		if (a[i]&lt;a[i+1]) f[i][i+1]=g[i][i+1]=1;
	for (len=2;len&lt;n;len++)
		for (x=&amp;f[1][len+1],y=&amp;g[1][len+1],i=1;i+len&lt;=n;i++,x+=tt+1,y+=tt+1)
		{
			j=i+len;
			if (a[i]&lt;a[i+1]) *x+=*(x+tt);
			if (a[j]&gt;a[j-1]) *y+=*(y-1);
			if (a[i]&lt;a[j])
			{
				*x+=*(y+tt);
				*y+=*(x-1);
			}
			if (*x&gt;mo) *x-=mo;
			if (*y&gt;mo) *y-=mo;
		}
	int ans=f[1][n]+g[1][n];
	if (ans&gt;mo) ans%=mo;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1996</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define mo 19650827
//const int mo=19650827;
int f[1005][1005],g[1005][1005],a[1005];
int n,i,len,j;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	int tt=1005,*x,*y;
	for (i=1;i&lt;n;i++)
		if (a[i]&lt;a[i+1]) f[i][i+1]=g[i][i+1]=1;
	for (len=2;len&lt;n;len++)
		for (x=&amp;f[1][len+1],y=&amp;g[1][len+1],i=1;i+len&lt;=n;i++,x+=tt+1,y+=tt+1)
		{
			j=i+len;
			if (a[i]&lt;a[i+1]) *x+=*(x+tt);
			if (a[j]&gt;a[j-1]) *y+=*(y-1);
			if (a[i]&lt;a[j])
			{
				*x+=*(y+tt);
				*y+=*(x-1);
			}
			if (*x&gt;mo) *x-=mo;
			if (*y&gt;mo) *y-=mo;
		}
	int ans=f[1][n]+g[1][n];
	if (ans&gt;mo) ans%=mo;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1996</h2><pre>#include&lt;cstdio&gt;
using namespace std;
//#define mo 19650827
const int mo=19650827;
int f[1005][1005],g[1005][1005],a[1005];
int n,i,len,j;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	int tt=1005,*x,*y;
	for (i=1;i&lt;n;i++)
		if (a[i]&lt;a[i+1]) f[i][i+1]=g[i][i+1]=1;
	for (len=2;len&lt;n;len++)
		for (x=&amp;f[1][len+1],y=&amp;g[1][len+1],i=1;i+len&lt;=n;i++,x+=tt+1,y+=tt+1)
		{
			j=i+len;
			if (a[i]&lt;a[i+1]) *x+=*(x+tt);
			if (a[j]&gt;a[j-1]) *y+=*(y-1);
			if (a[i]&lt;a[j])
			{
				*x+=*(y+tt);
				*y+=*(x-1);
			}
			if (*x&gt;mo) *x-=mo;
			if (*y&gt;mo) *y-=mo;
		}
	int ans=f[1][n]+g[1][n];
	if (ans&gt;mo) ans%=mo;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1996</h2><pre>#include &lt;cstdio&gt;
using namespace std;
const int maxn=1010,p=19650827;
int f[maxn][maxn][2],n,a[maxn];
int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    int i,j,k,x,y,l;
    for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
    for (i=1;i&lt;n;i++)
        if (a[i]&lt;a[i+1]) f[i][i+1][0]=f[i][i+1][1]=1;
    for (l=2;l&lt;n;l++)
    for (i=1;i&lt;=n-l;i++)
    {
        j=i+l;
        if (a[i]&lt;a[i+1]) x=f[i+1][j][0]; else x=0;
        if (a[i]&lt;a[j]) x+=f[i+1][j][1];
        f[i][j][0]=x&gt;=p?x-p:x;
        if (a[j]&gt;a[j-1]) x=f[i][j-1][1]; else x=0;
        if (a[j]&gt;a[i]) x+=f[i][j-1][0];
        f[i][j][1]=x&gt;=p?x-p:x;
    }
    x=(f[1][n][0]+f[1][n][1])%p;
    printf(&quot;%d\n&quot;,x);
    return 0;
}
<pre><h2>Problem1996</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int mo=19650827,NN=1005;
int f[NN][NN],g[NN][NN],a[NN];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int n,i,j,len,x;
	scanf(&quot;%d&quot;,&amp;n);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	for (i=1;i&lt;n;i++)
		if (a[i]&lt;a[i+1]) f[i][i+1]=g[i][i+1]=1;
	for (len=2;len&lt;n;len++)
		for (i=1;i+len&lt;=n;i++)
		{
			j=i+len;
			if (a[i]&lt;a[i+1]) x=f[i+1][j];else x=0;
			if (a[i]&lt;a[j]) x+=g[i+1][j];
			f[i][j]=x&gt;mo?x-mo:x;
			if (a[j]&gt;a[j-1]) x=g[i][j-1];else x=0;
			if (a[j]&gt;a[i]) x+=f[i][j-1];
			g[i][j]=x&gt;mo?x-mo:x;
		}
	int ans=f[1][n]+g[1][n];
	if (ans&gt;mo) ans%=mo;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1996</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int mo=19650827,NN=1005;
int f[NN][NN][2],a[NN];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int n,i,j,len,x;
	scanf(&quot;%d&quot;,&amp;n);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	for (i=1;i&lt;n;i++)
		if (a[i]&lt;a[i+1]) f[i][i+1][0]=f[i][i+1][1]=1;
	for (len=2;len&lt;n;len++)
		for (i=1;i+len&lt;=n;i++)
		{
			j=i+len;
			if (a[i]&lt;a[i+1]) x=f[i+1][j][0];else x=0;
			if (a[i]&lt;a[j]) x+=f[i+1][j][1];
			f[i][j][0]=x&gt;mo?x-mo:x;
			if (a[j]&gt;a[j-1]) x=f[i][j-1][1];else x=0;
			if (a[j]&gt;a[i]) x+=f[i][j-1][0];
			f[i][j][1]=x&gt;mo?x-mo:x;
		}
	int ans=f[1][n][0]+f[1][n][1];
	if (ans&gt;mo) ans%=mo;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1997</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 10001
#define MM 101111
int color[NN],a[NN],pos[NN],o[NN],aa[3000000][2];
int n,m,tes,tot;
bool vt[NN],flag[MM];
struct edge
{
	int a,b;
} e[MM];
bool check(int i,int j)
{
	int t1=pos[e[i].a],t2=pos[e[i].b];
	int t3=pos[e[j].a],t4=pos[e[j].b];
	if ((t3&lt;t1&amp;&amp;t1&lt;t4)&amp;&amp;(t2&gt;t4||t2&lt;t3)) return true;
	if ((t3&lt;t2&amp;&amp;t2&lt;t4)&amp;&amp;(t1&gt;t4||t1&lt;t3)) return true;
	return false;
}
bool dfs(int v)
{
	vt[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (vt[y])
		{
			if (color[y]==color[v]) return false;
			continue;
		}
		color[y]=!color[v];
		if (!dfs(y)) return false;
	}
	return true;
}
void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes--;)
	{
		//printf(&quot;\n------------------------------------------------\n&quot;);
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		int i,j;
		for (i=1;i&lt;=m;i++) scanf(&quot;%d%d&quot;,&amp;e[i].a,&amp;e[i].b);
		for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),pos[a[i]]=i;
		if (m&gt;3*n-6) {printf(&quot;NO\n&quot;);continue;}
		memset(flag,0,sizeof(flag));
		for (i=1;i&lt;=m;i++)
		{
			if (pos[e[i].a]&gt;pos[e[i].b])
			{
				int t=e[i].a;
				e[i].a=e[i].b;
				e[i].b=t;
			}
			int x=pos[e[i].a],y=pos[e[i].b];
			if (x+1==y) flag[i]=true;//,printf(&quot;%d\n&quot;,i);
		}
		memset(o,0,sizeof(o));tot=1;
		for (i=1;i&lt;m;i++)
			for (j=i+1;j&lt;=m;j++)
				if (!flag[i]&amp;&amp;!flag[j]&amp;&amp;check(i,j))
					addedge(i,j),addedge(j,i);//,printf(&quot;%d %d\n&quot;,i,j);
		memset(vt,0,sizeof(vt));
		bool ttt=true;
		for (i=1;i&lt;=m;i++)
			if (!vt[i])
			{
				color[i]=true;
				if (!dfs(i)) {ttt=false;break;}
			}
		printf(ttt?&quot;YES\n&quot;:&quot;NO\n&quot;);
	}
	return 0;
}
<pre><h2>Problem1998</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
typedef long long LL;
const int NN=101111;
int n,D,tes,pos[NN][2],fa[NN],fa2[NN],b[NN],R,C,num[NN];
bool vt[NN];
LL c[NN],p,q,m;
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
int getfa(int x) {return fa[x]==x?x:fa[x]=getfa(fa[x]);}
int getfa2(int x) {return fa2[x]==x?x:fa2[x]=getfa2(fa2[x]);}
int gcd(int a,int b) {return !b?a:gcd(b,a%b);}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		//printf(&quot;\n-----------------------------------------------------\n&quot;);
		scanf(&quot;%d%d%I64d%I64d%I64d%d&quot;,&amp;n,&amp;b[0],&amp;q,&amp;p,&amp;m,&amp;D);
		int i,j,tmp;
		c[0]=0;
		for (i=1;i&lt;n;i++) c[i]=(c[i-1]*q+p)%m;
		//printf(&quot;c &quot;);for(int i=0;i&lt;n;i++)printf(&quot;%I64d &quot;,c[i]);ln;getchar();
		R=gcd(n,D),C=n/R;
		for (i=0;i&lt;R;i++)
		{
			fa2[i]=i;
			num[i]=C;
			tmp=i;
			for (j=0;j&lt;C;j++,tmp=(tmp+D)%n)
			{
				pos[tmp][0]=i,pos[tmp][1]=j;
				if (tmp==b[0])
				{
					fa[tmp]=(tmp+D)%n;
					num[i]--;
					if (C==1) fa2[i]=(i+1)%R;
				}
				else fa[tmp]=tmp;
			}
		}
		for (i=1;i&lt;n;i++)
		{
			c[i]%=n;
			int x=pos[c[i]][0],y=pos[c[i]][1];
			int t=getfa2(x);
			num[t]--;
			int tmp=((t-x)%R+R)%R;
			c[i]=(c[i]+tmp)%n;
			if (num[t]==0) fa2[t]=(t+1)%R;
			b[i]=getfa(c[i]);
			fa[b[i]]=(b[i]+D)%n;
		}
		//out(b,0,n-1);
		//for (i=0;i&lt;R;i++) printf(&quot;%d &quot;,getfa2(i));ln;
		int ans=0;
		memset(vt,0,sizeof(vt));
		for (i=0;i&lt;n;i++) if (!vt[i])
		{
			vt[i]=true;
			int k=i,t=b[i],num=1;
			bool flag=false;
			if (i==0) flag=true;
			while (t!=k)
			{
				num++;
				if (t==0) flag=true;
				vt[t]=true,t=b[t];
			}
			if (num&gt;1) ans+=flag?num-1:num+1;
		}
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
<pre><h2>Problem2002</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define NN 210000
int size[NN],son[NN][2],fa[NN];
int n,m;
bool root[NN];
void update(int t)
{
	size[t]=size[son[t][0]]+size[son[t][1]]+1;
}
void rotate(int t,int p)
{
	int y=fa[t];
	if (root[y]) root[t]=true,root[y]=false;
	else
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!root[t])
	{
		int y=fa[t];
		if (root[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
}
int access(int x)
{
	int y=0;
	while (x&gt;0)
	{
		splay(x);
		root[son[x][1]]=true;
		son[x][1]=y;
		root[y]=false;
		update(x);
		y=x;
		x=fa[x];
	}
	return y;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		fa[i]=(i+x&lt;=n)?i+x:0;
		root[i]=true;
		size[i]=1;
	}
	scanf(&quot;%d&quot;,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		if (x==1)
		{
			scanf(&quot;%d&quot;,&amp;x);
			x++;
			printf(&quot;%d\n&quot;,size[access(x)]);
		}
		else
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x++;
			access(x);
			splay(x);
			fa[son[x][0]]=0;
			root[son[x][0]]=true;
			update(x);
			son[x][0]=0;
			fa[x]=(x+y&lt;=n)?x+y:0;
		}
	}
	return 0;
}
<pre><h2>Problem2003</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define D1(x) (((x)&amp;1)?-1:1)
#define D2(x) (((x)&amp;1)?1:-1)
#define ln printf(&quot;\n&quot;);
const int NN=211;
int A[NN][NN],C[NN][NN],l[NN][NN],r[NN][NN];
int n,m,P;
bool qwe=false;
bool dfs(int t)
{
	//if(qwe)printf(&quot;t=%d\n&quot;,t);
	if (t==m+1) return true;
	for (A[1][t]=0;A[1][t]&lt;P;A[1][t]++)
	{
		bool flag=true;
		for (int i=2;i&lt;=n;i++)
		{
			int t1=(C[i][t]+A[1][1]*D2(i+t)+A[1][t]*D2(i)-0)/-D2(t);
			int t2=(C[i][t]+A[1][1]*D2(i+t)+A[1][t]*D2(i)-(P-1))/-D2(t);
			if (t1&gt;t2) {int t=t1;t1=t2;t2=t;}
			l[i][t]=max(l[i][t-1],t1);
			r[i][t]=min(r[i][t-1],t2);
			//if (A[1][t]==5&amp;&amp;qwe) printf(&quot;%d %d\n&quot;,l[i][t],r[i][t]);
			if (l[i][t]&gt;r[i][t]) {flag=false;break;}
		}
		if (flag&amp;&amp;dfs(t+1)) return true;
	}
	return false;
}
int calc(int i,int j)
{
	return C[i][j]+A[1][1]*D2(i+j)+A[i][1]*D2(j)+A[1][j]*D2(i);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;P);
	int i,j;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			scanf(&quot;%d&quot;,&amp;C[i][j]);
			C[i][j]-=C[i-1][j]+C[i][j-1]+C[i-1][j-1];
		}
	//for(i=1;i&lt;=n;i++){for(j=1;j&lt;=m;j++)printf(&quot;%d &quot;,C[i][j]);ln;}ln;
	for (i=2;i&lt;=n;i++) l[i][1]=0,r[i][1]=P-1;
	for (A[1][1]=0;A[1][1]&lt;P;A[1][1]++)
	{
		//printf(&quot;\n--------------------------------------------------------------------------------\n&quot;);
		if (A[1][1]==4) qwe=true;
		if (dfs(2))
		{

			for (i=2;i&lt;=n;i++) A[i][1]=l[i][m];
			for (j=1;j&lt;=m;j++) printf(&quot;%d%c&quot;,A[1][j],j==m?'\n':' ');
			for (i=2;i&lt;=n;i++)
			{
				printf(&quot;%d &quot;,A[i][1]);
				for (j=2;j&lt;=m;j++) printf(&quot;%d%c&quot;,calc(i,j),j==m?'\n':' ');
			}
			break;
		}
		qwe=false;
	}
	return 0;
}
<pre><h2>Problem2003</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define D(x) (((x)&amp;1)?1:-1)
const int NN=211;
int A[NN][NN],C[NN][NN],l[NN][NN],r[NN][NN];
int n,m,P;
bool dfs(int t)
{
	if (t==m+1) return true;
	for (A[1][t]=0;A[1][t]&lt;P;A[1][t]++)
	{
		bool flag=true;
		for (int i=2;i&lt;=n;i++)
		{
			int t1=(C[i][t]+A[1][1]*D(i+t)+A[1][t]*D(i)-0)*-D(t);
			int t2=(C[i][t]+A[1][1]*D(i+t)+A[1][t]*D(i)-(P-1))*-D(t);
			if (t1&gt;t2) {int t=t1;t1=t2;t2=t;}
			l[i][t]=max(l[i][t-1],t1);
			r[i][t]=min(r[i][t-1],t2);
			if (l[i][t]&gt;r[i][t]) {flag=false;break;}
		}
		if (flag&amp;&amp;dfs(t+1)) return true;
	}
	return false;
}
int calc(int i,int j)
{
	return C[i][j]+A[1][1]*D(i+j)+A[i][1]*D(j)+A[1][j]*D(i);
}
int main()
{
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;P);
	int i,j;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			scanf(&quot;%d&quot;,&amp;C[i][j]);
			C[i][j]-=C[i-1][j]+C[i][j-1]+C[i-1][j-1];
		}
	for (i=2;i&lt;=n;i++) l[i][1]=0,r[i][1]=P-1;
	for (A[1][1]=0;A[1][1]&lt;P;A[1][1]++)
		if (dfs(2))
		{

			for (i=2;i&lt;=n;i++) A[i][1]=l[i][m];
			for (j=1;j&lt;=m;j++) printf(&quot;%d%c&quot;,A[1][j],j==m?'\n':' ');
			for (i=2;i&lt;=n;i++)
			{
				printf(&quot;%d &quot;,A[i][1]);
				for (j=2;j&lt;=m;j++) printf(&quot;%d%c&quot;,calc(i,j),j==m?'\n':' ');
			}
			break;
		}
	return 0;
}
<pre><h2>Problem2004</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mo 30031
#define ln printf(&quot;\n&quot;)
int n,K,P,hao[10000],which[10000],cnt,i,tmp,j,to;
struct matrix
{
	int m[200][200];
	matrix() {memset(m,0,sizeof(m));}
	friend matrix operator *(matrix a,matrix b)
	{
		matrix c;
		int i,j,k;
		for (k=1;k&lt;=cnt;k++)
			for (i=1;i&lt;=cnt;i++)
				for (j=1;j&lt;=cnt;j++)
					c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j])%mo;
		return c;
	}
} a,res,ans;
int calc(int x)
{
	int res=0;
	for (;x;x-=(x&amp;-x)) res++;
	return res;
}
int main()
{
	//freopen(&quot;2004.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2004.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;K,&amp;P);
	int mm=(1&lt;&lt;P)-1;
	for (i=0;i&lt;=mm;i++)
		if (calc(i)==K&amp;&amp;(i&amp;1)) hao[i]=++cnt,which[cnt]=i;
	//for (i=1;i&lt;=cnt;i++) printf(&quot;%d &quot;,which[i]);ln;
	for (i=1;i&lt;=cnt;i++)
	{
		int x=which[i];
		for (j=1;j&lt;=P;j++)
			if (x&amp;(1&lt;&lt;(j-1)))
			{
				tmp=x-(1&lt;&lt;(j-1));
				to=(tmp&lt;&lt;1)+1;
				//printf(&quot;%d\n&quot;,to);
				a.m[hao[x]][hao[to]]=1;
			}
	}
	//for (i=1;i&lt;=cnt;i++){for(j=1;j&lt;=cnt;j++)printf(&quot;%d &quot;,a.m[i][j]);ln;}
	for (i=1;i&lt;=cnt;i++) res.m[i][i]=1;
	n-=K;
	for (;n;n&gt;&gt;=1,a=a*a) if (n&amp;1) res=res*a;
	tmp=0;
	for (i=1;i&lt;=K;i++) tmp+=(1&lt;&lt;(i-1));
	ans.m[1][hao[tmp]]=1;
	ans=ans*res;
	printf(&quot;%d\n&quot;,ans.m[1][hao[tmp]]);
	return 0;
}
<pre><h2>Problem2004</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mo 30031
#define ln printf(&quot;\n&quot;)
int n,K,P,hao[10000],which[10000],cnt,i,tmp,j,to;
struct matrix
{
    int m[200][200];
    matrix() {memset(m,0,sizeof(m));}
    int * operator [](int x) {return m[x];}
    friend matrix operator *(matrix a,matrix b)
    {
        matrix c;
        int i,j,k;
        for (k=1;k&lt;=cnt;k++)
            for (i=1;i&lt;=cnt;i++)
                for (j=1;j&lt;=cnt;j++)
                    c[i][j]=(c[i][j]+a[i][k]*b[k][j])%mo;
        return c;
    }
} a,res,ans;
int calc(int x)
{
    int res=0;
    for (;x;x-=(x&amp;-x)) res++;
    return res;
}
int main()
{
    //freopen(&quot;2004.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2004.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;K,&amp;P);
    int mm=(1&lt;&lt;P)-1;
    for (i=0;i&lt;=mm;i++)
        if (calc(i)==K&amp;&amp;(i&amp;1)) hao[i]=++cnt,which[cnt]=i;
    //for (i=1;i&lt;=cnt;i++) printf(&quot;%d &quot;,which[i]);ln;
    for (i=1;i&lt;=cnt;i++)
    {
        int x=which[i];
        for (j=1;j&lt;=P;j++)
            if (x&amp;(1&lt;&lt;(j-1)))
            {
                tmp=x-(1&lt;&lt;(j-1));
                to=(tmp&lt;&lt;1)+1;
                //printf(&quot;%d\n&quot;,to);
                a[hao[x]][hao[to]]=1;
            }
    }
    for (i=1;i&lt;=cnt;i++) res[i][i]=1;
    n-=K;
    for (;n;n&gt;&gt;=1,a=a*a) if (n&amp;1) res=res*a;
    tmp=0;
    for (i=1;i&lt;=K;i++) tmp+=(1&lt;&lt;(i-1));
    ans[1][hao[tmp]]=1;
    ans=ans*res;
    printf(&quot;%d\n&quot;,ans[1][hao[tmp]]);
    return 0;
}<pre><h2>Problem2004</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mo 30031
#define ln printf(&quot;\n&quot;)
int n,K,P,hao[10000],which[10000],cnt,i,tmp,j,to;
struct matrix
{
    int m[200][200];
    matrix() {memset(m,0,sizeof(m));}
    int * operator [](int x) {return m[x];}
    friend matrix operator *(matrix a,matrix b)
    {
        matrix c;
        int i,j,k;
        for (k=1;k&lt;=cnt;k++)
            for (i=1;i&lt;=cnt;i++)
                for (j=1;j&lt;=cnt;j++)
                    c[i][j]=(c[i][j]+a[i][k]*b[k][j])%mo;
        return c;
    }
    friend matrix operator ^(matrix a,int b)
    {
    	matrix res;
    	for (int i=1;i&lt;=cnt;i++) res[i][i]=1;
    	for (;b;b&gt;&gt;=1,a=a*a) if (b&amp;1) res=res*a;
    	return res;
    }
} a,res,ans;
int calc(int x)
{
    int res=0;
    for (;x;x-=(x&amp;-x)) res++;
    return res;
}
int main()
{
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;K,&amp;P);
    int mm=(1&lt;&lt;P)-1;
    for (i=0;i&lt;=mm;i++)
        if (calc(i)==K&amp;&amp;(i&amp;1)) hao[i]=++cnt,which[cnt]=i;
    for (i=1;i&lt;=cnt;i++)
    {
        int x=which[i];
        for (j=1;j&lt;=P;j++)
            if (x&amp;(1&lt;&lt;(j-1)))
            {
                tmp=x-(1&lt;&lt;(j-1));
                to=(tmp&lt;&lt;1)+1;
                a[hao[x]][hao[to]]=1;
            }
    }
    n-=K;
    matrix res=a^n;
    tmp=0;
    for (i=1;i&lt;=K;i++) tmp+=(1&lt;&lt;(i-1));
    ans[1][hao[tmp]]=1;
    ans=ans*res;
    printf(&quot;%d\n&quot;,ans[1][hao[tmp]]);
    return 0;
}<pre><h2>Problem2005</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long ll;
int m,n,k;
ll f[100100],ans;
int main()
{
	int i,j;
	cin&gt;&gt;m&gt;&gt;n;
	k=min(m,n);
	for(i=k;i;i--)
	{
		f[i]=(ll)(m/i)*(n/i);
		for(j=2;j*i&lt;=k;j++)
			f[i]-=f[i*j];
		ans+=f[i]*(i+i-1);
	}
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem2005</h2><pre>uses math;
var
  n,m,k,j,ans:int64;
  i:longint;
  f:array[0..100000]of int64;
begin
  //assign(input,'2005.in');reset(input);
 // assign(output,'2005.out');rewrite(output);
  readln(n,m);
  fillchar(f,sizeof(f),0);
  k:=min(n,m);
  for i:=k downto 1 do
    begin
      f[i]:=(n div i)*(m div i);
      j:=2;
      while j*i&lt;=k do
        begin
          dec(f[i],f[j*i]);
          inc(j);
        end;
      inc(ans,f[i]*(i-1));
    end;
  writeln(ans*2+n*m);
 // close(input);close(output);
end.<pre><h2>Problem2005</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
typedef long long LL;
const int NN=101111;
int phi[NN],pr[NN];
int n,m,cnt;
bool vt[NN];
void shai()
{
	vt[1]=true;
	phi[1]=1;
	int i,j;
	for (i=2;i&lt;=n;i++)
	{
		if (!vt[i]) pr[++cnt]=i,phi[i]=i-1;
		for (j=1;j&lt;=cnt;j++)
		{
			int x=i*pr[j];
			if (x&gt;n) break;
			vt[x]=true;
			if (i%pr[j]==0) {phi[x]=phi[i]*pr[j];break;}
			else phi[x]=phi[i]*(pr[j]-1);
		}
	}
	for (i=2;i&lt;=n;i++) phi[i]+=phi[i-1];
	//for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,phi[i]);ln;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	if (n&gt;m) {int t=n;n=m;m=t;}
	shai();
	LL ans=0;
	int l,r;
	for (l=1;l&lt;=n;l=r+1)
	{
		r=min(n/(n/l),m/(m/l));
		ans+=(LL)(phi[r]-phi[l-1])*(n/l)*(m/l);
	}
	printf(&quot;%lld\n&quot;,ans*2-(LL)n*m);
	return 0;
}<pre><h2>Problem2005</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
typedef long long LL;
const int NN=101111;
LL phi[NN],pr[NN];
int n,m,cnt;
bool vt[NN];
void shai()
{
    vt[1]=true;
    phi[1]=1;
    int i,j;
    for (i=2;i&lt;=n;i++)
    {
        if (!vt[i]) pr[++cnt]=i,phi[i]=i-1;
        for (j=1;j&lt;=cnt;j++)
        {
            int x=i*pr[j];
            if (x&gt;n) break;
            vt[x]=true;
            if (i%pr[j]==0) {phi[x]=phi[i]*pr[j];break;}
            else phi[x]=phi[i]*(pr[j]-1);
        }
    }
    for (i=2;i&lt;=n;i++) phi[i]+=phi[i-1];
    //for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,phi[i]);ln;
}
int main()
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    if (n&gt;m) {int t=n;n=m;m=t;}
    shai();
    LL ans=0;
    int l,r;
    for (l=1;l&lt;=n;l=r+1)
    {
        r=min(n/(n/l),m/(m/l));
        ans+=(LL)(phi[r]-phi[l-1])*(n/l)*(m/l);
    }
    printf(&quot;%lld\n&quot;,ans*2-(LL)n*m);
    return 0;
}<pre><h2>Problem2005</h2><pre>#include&lt;cstdio&gt;
#include&lt;map&gt;
using namespace std;
typedef long long LL;
const LL NN=11111;
LL pr[NN],phi[NN];
LL n,m,cnt;
bool vt[NN];
map&lt;LL,LL&gt; qq;
void shai()
{
    vt[1]=true;
    phi[1]=1;
    LL i,j;
    for (i=2;i&lt;=10000;i++)
    {
        if (!vt[i]) pr[++cnt]=i,phi[i]=i-1;
        for (j=1;j&lt;=cnt;j++)
        {
            LL x=i*pr[j];
            if (x&gt;10000) break;
            vt[x]=true;
            if (i%pr[j]==0) {phi[x]=phi[i]*pr[j];break;}
            else phi[x]=phi[i]*(pr[j]-1);
        }
    }
    for (i=2;i&lt;=10000;i++) phi[i]+=phi[i-1];
    //for (i=1;i&lt;=n;i++) printf(&quot;%lld &quot;,phi[i]);ln;
}
LL F(LL n)
{
	if (n&lt;=10000) return phi[n];
	if (qq.count(n)) return qq[n];
	LL res=(LL)n*(n+1)/2;
	for (LL i=2;i&lt;=n;i++) res-=F(n/i);
	qq[n]=res;
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);
	if (n&gt;m) {LL t=n;n=m;m=t;}
	shai();
	LL ans=0;
	LL l,r;
	for (l=1;l&lt;=n;l=r+1)
	{
		r=min(n/(n/l),m/(m/l));
		ans+=(LL)(F(r)-F(l-1))*(n/l)*(m/l);
	}
	printf(&quot;%lld\n&quot;,ans*2-(LL)n*m);
	return 0;
}<pre><h2>Problem2006</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
#define NN 501111
#define LL long long
#define ln printf(&quot;\n&quot;)
int log[NN],f[NN][21],id[NN][21],a[NN],sum[NN];
int n,K,L,R;
struct ppt
{
	int from,l,r,id,w;
	void out() {printf(&quot;from=%d l=%d r=%d id=%d w=%d\n&quot;,from,l,r,id,w);}
	ppt(int a=0,int b=0,int c=0,int d=0,int e=0) {from=a,l=b,r=c,id=d,w=e;}
	friend bool operator &lt;(ppt a,ppt b) {return a.w&lt;b.w;}
};
priority_queue&lt;ppt&gt; Q;
int getmaxid(int l,int r)
{
	int t=log[r-l+1];
	int t1=f[l][t],t2=f[r-(1&lt;&lt;t)+1][t];
	if (t1&gt;t2) return id[l][t];
	else return id[r-(1&lt;&lt;t)+1][t];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;K,&amp;L,&amp;R);
	int i,j;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		sum[i]=sum[i-1]+a[i];
		f[i][0]=sum[i],id[i][0]=i;
	}
	for (j=1;j&lt;=20;j++)
		for (i=1;i&lt;=n;i++)
		{
			int t=i+(1&lt;&lt;(j-1));
			if (t&gt;n) break;
			if (f[i][j-1]&gt;f[t][j-1]) f[i][j]=f[i][j-1],id[i][j]=id[i][j-1];
			else f[i][j]=f[t][j-1],id[i][j]=id[t][j-1];
		}
	for (log[1]=0,i=2;i&lt;=n;i++) log[i]=(i==(i&amp;-i))?log[i-1]+1:log[i-1];
	//for(int i=1;i&lt;=n;i++){for(int j=0;j&lt;=3;j++)printf(&quot;%d &quot;,f[i][j]);ln;}ln;
	for (i=1;i&lt;=n;i++)
	{
		int l=i+L-1,r=i+R-1;
		if (l&gt;n) break;
		if (r&gt;n) r=n;
		int tmp=getmaxid(l,r);
		//printf(&quot;push %d %d\n&quot;,i,tmp);
		Q.push(ppt(i,l,r,tmp,sum[tmp]-sum[i-1]));
	}
	//ln;
	LL ans=0;
	for (i=1;i&lt;=K;i++)
	{
		ppt tmp=Q.top();
		//tmp.out();
		Q.pop();
		ans+=tmp.w;
		int f=tmp.from,l=tmp.l,r=tmp.r,t=tmp.id;
		if (l&lt;=t-1)
		{
			int k=getmaxid(l,t-1);
			Q.push(ppt(f,l,t-1,k,sum[k]-sum[f-1]));
		}
		if (t+1&lt;=r)
		{
			int k=getmaxid(t+1,r);
			Q.push(ppt(f,t+1,r,k,sum[k]-sum[f-1]));
		}
	}
	//ln;ln;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2006</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
#define NN 501111
#define LL long long
int log[NN],f[NN][21],id[NN][21],a[NN],sum[NN];
int n,K,L,R;
struct ppt
{
	int from,l,r,id,w;
	ppt(int a=0,int b=0,int c=0,int d=0,int e=0) {from=a,l=b,r=c,id=d,w=e;}
	friend bool operator &lt;(ppt a,ppt b) {return a.w&lt;b.w;}
};
priority_queue&lt;ppt&gt; Q;
int getmaxid(int l,int r)
{
	int t=log[r-l+1];
	int t1=f[l][t],t2=f[r-(1&lt;&lt;t)+1][t];
	if (t1&gt;t2) return id[l][t];
	else return id[r-(1&lt;&lt;t)+1][t];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;K,&amp;L,&amp;R);
	int i,j;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		sum[i]=sum[i-1]+a[i];
		f[i][0]=sum[i],id[i][0]=i;
	}
	for (j=1;j&lt;=20;j++)
		for (i=1;i&lt;=n;i++)
		{
			int t=i+(1&lt;&lt;(j-1));
			if (t&gt;n) break;
			if (f[i][j-1]&gt;f[t][j-1]) f[i][j]=f[i][j-1],id[i][j]=id[i][j-1];
			else f[i][j]=f[t][j-1],id[i][j]=id[t][j-1];
		}
	for (log[1]=0,i=2;i&lt;=n;i++) log[i]=(i==(i&amp;-i))?log[i-1]+1:log[i-1];
	for (i=1;i&lt;=n;i++)
	{
		int l=i+L-1,r=i+R-1;
		if (l&gt;n) break;
		if (r&gt;n) r=n;
		int tmp=getmaxid(l,r);
		Q.push(ppt(i,l,r,tmp,sum[tmp]-sum[i-1]));
	}
	LL ans=0;
	for (i=1;i&lt;=K;i++)
	{
		ppt tmp=Q.top();
		Q.pop();
		ans+=tmp.w;
		int f=tmp.from,l=tmp.l,r=tmp.r,t=tmp.id;
		if (l&lt;=t-1)
		{
			int k=getmaxid(l,t-1);
			Q.push(ppt(f,l,t-1,k,sum[k]-sum[f-1]));
		}
		if (t+1&lt;=r)
		{
			int k=getmaxid(t+1,r);
			Q.push(ppt(f,t+1,r,k,sum[k]-sum[f-1]));
		}
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2006</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
#define NN 501111
#define LL long long
#define inf 500000005
int left[NN],right[NN],from[NN],sum[NN],a[NN],now[NN],root[NN],size[31001111],lc[31001111],rc[31001111];
int n,K,L,R,cnt,TTT;
struct ppt
{
	int id,w;
	ppt(int a=0,int b=0) {id=a,w=b;}
	friend bool operator &lt;(ppt a,ppt b) {return a.w&lt;b.w;}
};
priority_queue&lt;ppt&gt; Q;
void ins(int &amp;v,int u,int l,int r,int x)
{
	if (!v) v=++TTT;
	size[v]=size[u]+1;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid)
	{
		rc[v]=rc[u];
		ins(lc[v],lc[u],l,mid,x);
	}
	else
	{
		lc[v]=lc[u];
		ins(rc[v],rc[u],mid,r,x);
	}
}
int select(int v,int u,int l,int r,int K)
{
	if (r-l==1) return l;
	int mid=(l+r)&gt;&gt;1;
	int tmp=size[rc[v]]-size[rc[u]];
	if (tmp&gt;=K) return select(rc[v],rc[u],mid,r,K);
	else return select(lc[v],lc[u],l,mid,K-tmp);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;K,&amp;L,&amp;R);
	int i;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		sum[i]=sum[i-1]+a[i];
		ins(root[i],root[i-1],-inf,inf,sum[i]);
	}
	//printf(&quot;%d\n&quot;,select(root[4],root[0],-inf,inf,2));
	cnt=0;
	for (i=1;i&lt;=n;i++)
	{
		int l=i+L-1,r=i+R-1;
		if (l&gt;n) break;
		if (r&gt;n) r=n;
		cnt++;
		from[cnt]=i;
		left[cnt]=l,right[cnt]=r;
		now[cnt]=1;
		Q.push(ppt(cnt,select(root[r],root[l-1],-inf,inf,1)-sum[i-1]));
		//printf(&quot;%d\n&quot;,select(root[r],root[l-1],-inf,inf,1)-sum[i-1]);
	}
	LL ans=0;
	for (i=1;i&lt;=K;i++)
	{
		ppt tmp=Q.top();
		Q.pop();
		ans+=tmp.w;
		int t=tmp.id;
		if (now[t]==right[t]-left[t]+1) continue;
		Q.push(ppt(t,select(root[right[t]],root[left[t]-1],-inf,inf,++now[t])-sum[from[t]-1]));
	}
	//ln;ln;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2006</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
#define NN 501111
#define LL long long
#define inf 500000005
int left[NN],right[NN],from[NN],sum[NN],a[NN],now[NN],root[NN],size[16001111],lc[16001111],rc[16001111];
int n,K,L,R,cnt,TTT;
struct ppt
{
	int id,w;
	ppt(int a=0,int b=0) {id=a,w=b;}
	friend bool operator &lt;(ppt a,ppt b) {return a.w&lt;b.w;}
};
priority_queue&lt;ppt&gt; Q;
void ins(int &amp;v,int u,int l,int r,int x)
{
	if (!v) v=++TTT;
	size[v]=size[u]+1;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid)
	{
		rc[v]=rc[u];
		ins(lc[v],lc[u],l,mid,x);
	}
	else
	{
		lc[v]=lc[u];
		ins(rc[v],rc[u],mid,r,x);
	}
}
int select(int v,int u,int l,int r,int K)
{
	if (r-l==1) return l;
	int mid=(l+r)&gt;&gt;1;
	int tmp=size[rc[v]]-size[rc[u]];
	if (tmp&gt;=K) return select(rc[v],rc[u],mid,r,K);
	else return select(lc[v],lc[u],l,mid,K-tmp);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;K,&amp;L,&amp;R);
	int i;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		sum[i]=sum[i-1]+a[i];
		ins(root[i],root[i-1],-inf,inf,sum[i]);
	}
	//printf(&quot;%d\n&quot;,select(root[4],root[0],-inf,inf,2));
	cnt=0;
	for (i=1;i&lt;=n;i++)
	{
		int l=i+L-1,r=i+R-1;
		if (l&gt;n) break;
		if (r&gt;n) r=n;
		cnt++;
		from[cnt]=i;
		left[cnt]=l,right[cnt]=r;
		now[cnt]=1;
		Q.push(ppt(cnt,select(root[r],root[l-1],-inf,inf,1)-sum[i-1]));
		//printf(&quot;%d\n&quot;,select(root[r],root[l-1],-inf,inf,1)-sum[i-1]);
	}
	LL ans=0;
	for (i=1;i&lt;=K;i++)
	{
		ppt tmp=Q.top();
		Q.pop();
		ans+=tmp.w;
		int t=tmp.id;
		if (now[t]==right[t]-left[t]+1) continue;
		Q.push(ppt(t,select(root[right[t]],root[left[t]-1],-inf,inf,++now[t])-sum[from[t]-1]));
	}
	//ln;ln;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2028</h2><pre>#include&lt;cstdio&gt;
#define lc(v) (v&lt;&lt;1)
#define rc(v) (lc(v)+1)
using namespace std;
const int inf=99999999;
int n,i,a[210000],b[210000],c[210000],num;
int t[410000],l[410000],r[410000],tag[410000];
char ch;
int min(int a,int b) {return a&lt;b?a:b;}
void init()
{
	scanf(&quot;%d\n&quot;,&amp;n);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%c&quot;,&amp;ch);
		//printf(&quot;%d %c\n&quot;,i,ch);
		if (ch=='A') scanf(&quot;%d%d\n&quot;,&amp;a[i],&amp;b[i]);
		else a[i]=-1,scanf(&quot;\n&quot;);
		//printf(&quot;%d %c\n&quot;,i,ch);
	}
	//printf(&quot;\n\n&quot;);for (i=1;i&lt;=n;i++) printf(&quot;%d %d\n&quot;,a[i],b[i]);
}
void update(int v)
{
	t[v]=min(t[lc(v)],t[rc(v)]);
}
void pushdown(int v)
{
	if (tag[v]==0) return;
	t[lc(v)]=tag[v];
	tag[lc(v)]=tag[v];
	t[rc(v)]=tag[v];
	tag[rc(v)]=tag[v];
	tag[v]=0;
}
void build(int v,int ll,int rr)
{
	l[v]=ll,r[v]=rr;
	if (rr-ll==1)
	{
		t[v]=n+1;
		tag[v]=0;
		return;
	}
	int mid=(ll+rr)&gt;&gt;1;
	build(lc(v),ll,mid);
	build(rc(v),mid,rr);
	update(v);
}
int count(int v,int a,int b)
{
	if (r[v]-l[v]==1||(a&lt;=l[v]&amp;&amp;r[v]&lt;=b)) return t[v];
	pushdown(v);
	int res=inf;
	int mid=(l[v]+r[v])&gt;&gt;1;
	if (a&lt;mid) res=min(res,count(lc(v),a,b));
	if (b&gt;=mid) res=min(res,count(rc(v),a,b));
	return res;
}
void change(int v,int a,int b,int x)
{
	if (r[v]-l[v]==1||(a&lt;=l[v]&amp;&amp;r[v]&lt;=b))
	{
		tag[v]=x;
		t[v]=x;
		return;
	}
	pushdown(v);
	int mid=(l[v]+r[v])&gt;&gt;1;
	if (a&lt;mid) change(lc(v),a,b,x);
	if (b&gt;=mid) change(rc(v),a,b,x);
	update(v);
}
void doit()
{
	build(1,1,100001);
	for (i=n;i;i--)
		if (a[i]!=-1)
		{
			c[count(1,a[i],b[i])]++;
			change(1,a[i],b[i],i);
		}
	for (num=0,i=1;i&lt;=n;i++)
	{
		if (a[i]!=-1) printf(&quot;%d\n&quot;,c[i]),num+=(1-c[i]);
		else printf(&quot;%d\n&quot;,num);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
	init();
	doit();
	return 0;
}
<pre><h2>Problem2028</h2><pre>#include&lt;cstdio&gt;
#define lc(v) (v&lt;&lt;1)
#define rc(v) (lc(v)+1)
using namespace std;
const int inf=99999999;
int n,i,a[210000],b[210000],c[210000],num;
int t[410000],l[410000],r[410000],tag[410000];
char ch;
int min(int a,int b) {return a&lt;b?a:b;}
void init()
{
	scanf(&quot;%d\n&quot;,&amp;n);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%c&quot;,&amp;ch);
		if (ch=='A') scanf(&quot;%d%d\n&quot;,&amp;a[i],&amp;b[i]);
		else a[i]=-1,scanf(&quot;\n&quot;);
	}
}
void update(int v)
{
	t[v]=min(t[lc(v)],t[rc(v)]);
}
void pushdown(int v)
{
	if (tag[v]==0) return;
	t[lc(v)]=tag[v];
	tag[lc(v)]=tag[v];
	t[rc(v)]=tag[v];
	tag[rc(v)]=tag[v];
	tag[v]=0;
}
void build(int v,int ll,int rr)
{
	l[v]=ll,r[v]=rr;
	if (rr-ll==1)
	{
		t[v]=n+1;
		tag[v]=0;
		return;
	}
	int mid=(ll+rr)&gt;&gt;1;
	build(lc(v),ll,mid);
	build(rc(v),mid,rr);
	update(v);
}
int count(int v,int a,int b)
{
	if (r[v]-l[v]==1||(a&lt;=l[v]&amp;&amp;r[v]&lt;=b)) return t[v];
	pushdown(v);
	int res=inf;
	int mid=(l[v]+r[v])&gt;&gt;1;
	if (a&lt;mid) res=min(res,count(lc(v),a,b));
	if (b&gt;=mid) res=min(res,count(rc(v),a,b));
	return res;
}
void change(int v,int a,int b,int x)
{
	if (r[v]-l[v]==1||(a&lt;=l[v]&amp;&amp;r[v]&lt;=b))
	{
		tag[v]=x;
		t[v]=x;
		return;
	}
	pushdown(v);
	int mid=(l[v]+r[v])&gt;&gt;1;
	if (a&lt;mid) change(lc(v),a,b,x);
	if (b&gt;=mid) change(rc(v),a,b,x);
	update(v);
}
void doit()
{
	build(1,1,100001);
	for (i=n;i;i--)
		if (a[i]!=-1)
		{
			c[count(1,a[i],b[i])]++;
			change(1,a[i],b[i],i);
		}
	for (num=0,i=1;i&lt;=n;i++)
	{
		if (a[i]!=-1) printf(&quot;%d\n&quot;,c[i]),num+=(1-c[i]);
		else printf(&quot;%d\n&quot;,num);
	}
}
int main()
{
	init();
	doit();
	return 0;
}
<pre><h2>Problem2037</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
#define ln printf(&quot;\n&quot;)
const int NN=1005;
int s1[NN],s2[NN],f[NN][NN],g[NN][NN];
int n,x0,ans,n1,n2;
void out(int*a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
struct ppt
{
	int x,y,v;
	void out() {printf(&quot;x=%d y=%d v=%d\n&quot;,x,y,v);}
	friend bool operator &lt;(ppt a,ppt b) {return a.x&lt;b.x;}
} q[NN],a[NN],b[NN];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;x0);
	int i,j;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;q[i].x),q[i].x-=x0;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;q[i].y);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;q[i].v);
	int ans=0;
	for (i=1;i&lt;=n;i++)
	{
		ans+=q[i].y;
		if (q[i].x&lt;0) q[i].x=-q[i].x,a[++n1]=q[i];
		else if (q[i].x&gt;0) b[++n2]=q[i];
	}
	sort(a+1,a+n1+1);
	sort(b+1,b+n2+1);
	for (i=1;i&lt;=n1;i++) s1[i]=s1[i-1]+a[i].v;
	for (i=1;i&lt;=n2;i++) s2[i]=s2[i-1]+b[i].v;
	//for (i=1;i&lt;=n1;i++) a[i].out();printf(&quot;s1 &quot;);out(s1,1,n1);ln;for (i=1;i&lt;=n2;i++) b[i].out();printf(&quot;s2 &quot;);out(s2,1,n2);ln;
	for (i=0;i&lt;=n1;i++)
		for (j=0;j&lt;=n2;j++) f[i][j]=g[i][j]=-inf;
	f[0][0]=g[0][0]=0;
	for (i=0;i&lt;=n1;i++)
		for (j=0;j&lt;=n2;j++)
		{
			//printf(&quot;\n---------------------------------------------------------------------------------\n&quot;);
			if (i&gt;0)
			{
				int t=s1[n1]-s1[i-1]+s2[n2]-s2[j];
				int tmp=f[i-1][j]-t*(a[i].x-a[i-1].x);
				if (tmp&gt;f[i][j]) f[i][j]=tmp;
				tmp=g[i-1][j]-t*(a[i].x+b[j].x);
				if (tmp&gt;f[i][j]) f[i][j]=tmp;
			}
			if (j&gt;0)
			{
				int t=s1[n1]-s1[i]+s2[n2]-s2[j-1];
				//printf(&quot;t=%d\n&quot;,t);
				int tmp=f[i][j-1]-t*(a[i].x+b[j].x);
				//printf(&quot;tmp=%d\n&quot;,tmp);
				if (tmp&gt;g[i][j]) g[i][j]=tmp;
				tmp=g[i][j-1]-t*(b[j].x-b[j-1].x);
				if (tmp&gt;g[i][j]) g[i][j]=tmp;
			}
			//printf(&quot;f[%d][%d]=%d\n&quot;,i,j,f[i][j]);
		}
	ans+=max(f[n1][n2],g[n1][n2]);
	printf(&quot;%.3f\n&quot;,ans/1000.0);
	return 0;
}<pre><h2>Problem2038</h2><pre>#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;
long long now,ans[50001];
int n,m,i,j,k,tot,len;
int stu[50001],dl[50001],a[50001],x[50001],y[50001];

long long gcd (long long a,long long b)
{
    long long i;
    while (a%b!=0)
    {
          i=a%b;
          a=b;
          b=i;
    }
    return b;
}

int from (int x)
{
    return (x-1)/len+1;
}

bool cmp (int a,int b)
{
     if (from(x[a])&lt;from(x[b])) return true;
     if (from(x[a])&gt;from(x[b])) return false;
     if (y[a]&lt;y[b]) return true;
     return false;
}

int main ()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
    for (i=1;i&lt;=m;i++) scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]);
    for (i=1;i&lt;=m;i++) dl[i]=i;
    len=220;
    sort(dl+1,dl+m+1,cmp);
    i=1;
    while (i&lt;=m)
    {
          k=from(x[dl[i]]);
          now=0;
          memset(stu,0,sizeof(stu));
          for (j=x[dl[i]];j&lt;=y[dl[i]];j++) 
          {
              now-=(long long)stu[a[j]]*(stu[a[j]]-1);
              stu[a[j]]++;
              now+=(long long)stu[a[j]]*(stu[a[j]]-1);
          }
          ans[dl[i++]]=now;
          while ((i&lt;=n)&amp;(from(x[dl[i]])==k))
          {
                for (j=y[dl[i-1]]+1;j&lt;=y[dl[i]];j++)
                {
                    now-=(long long)stu[a[j]]*(stu[a[j]]-1);
                    stu[a[j]]++;
                    now+=(long long)stu[a[j]]*(stu[a[j]]-1);
                }
                if (x[dl[i]]&gt;x[dl[i-1]])
                   for (j=x[dl[i-1]];j&lt;x[dl[i]];j++)
                   {
                       now-=(long long)stu[a[j]]*(stu[a[j]]-1);
                       stu[a[j]]--;
                       now+=(long long)stu[a[j]]*(stu[a[j]]-1);
                   }
                else
                   for (j=x[dl[i-1]]-1;j&gt;=x[dl[i]];j--)
                   {
                       now-=(long long)stu[a[j]]*(stu[a[j]]-1);
                       stu[a[j]]++;
                       now+=(long long)stu[a[j]]*(stu[a[j]]-1);
                   }
                ans[dl[i++]]=now;
          }
    }
    for (i=1;i&lt;=m;i++)
        if (ans[i]==0) printf(&quot;0/1\n&quot;);
        else           
        {
            k=y[i]-x[i]+1;
            now=gcd(ans[i],(long long)k*(k-1));
            printf(&quot;%lld/%lld\n&quot;,ans[i]/now,(long long)k*(k-1)/now);
        }
    return 0;
}
<pre><h2>Problem2038</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
#define LL long long
LL n,m,sqrtn,i,j,ll,lr,a[510000];
LL now,ans[510000],num[510000];
struct orz {LL l,r,id;} ask[510000];
bool cmp(orz a,orz b) {return a.l/sqrtn!=b.l/sqrtn?a.l/sqrtn&lt;b.l/sqrtn:a.r&lt;b.r;}
bool cmp2(orz a,orz b) {return a.id&lt;b.id;}
LL calc(LL x) {return (LL)x*(x-1)/2;}
LL gcd(LL a,LL b) {return b==0?a:gcd(b,a%b);}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);
	sqrtn=(LL)sqrt(n);
	for (i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]);
	for (i=1;i&lt;=m;i++) scanf(&quot;%lld%lld&quot;,&amp;ask[i].l,&amp;ask[i].r),ask[i].id=i;
	sort(ask+1,ask+m+1,cmp);
	//for (i=1;i&lt;=m;i++) printf(&quot;%lld &quot;,ask[i].l),printf(&quot;%lld\n&quot;,ask[i].r);
	ll=0,lr=0,now=0;
	memset(num,0,sizeof(num));
	for (i=1;i&lt;=m;i++)
	{
		if (ask[i].r&gt;lr)
			for (j=lr+1;j&lt;=ask[i].r;j++)
			{
				if (j&gt;0&amp;&amp;j&lt;=n) now=now-calc(num[a[j]])+calc(num[a[j]]+1),num[a[j]]++;
			}
		else if (lr&gt;ask[i].r)
			for (j=ask[i].r+1;j&lt;=lr;j++)
			{
				if (j&gt;0&amp;&amp;j&lt;=n) now=now-calc(num[a[j]])+calc(num[a[j]]-1),num[a[j]]--;
			}
		if (ask[i].l&gt;ll)   
			for (j=ll;j&lt;ask[i].l;j++)
			{
				if (j&gt;0&amp;&amp;j&lt;=n) now=now-calc(num[a[j]])+calc(num[a[j]]-1),num[a[j]]--;
			}
		else if (ask[i].l&lt;ll)
			for (j=ask[i].l;j&lt;ll;j++)
			{
				if (j&gt;0&amp;&amp;j&lt;=n) now=now-calc(num[a[j]])+calc(num[a[j]]+1),num[a[j]]++;
			}
		ans[ask[i].id]=now;
		lr=ask[i].r,ll=ask[i].l;
	}
	sort(ask+1,ask+m+1,cmp2);
	for (i=1;i&lt;=m;i++)
		if (ans[i]==0) printf(&quot;0/1\n&quot;);
		else
		{
			LL tmp=calc(ask[i].r-ask[i].l+1);
			LL tt=gcd(tmp,ans[i]);
			ans[i]/=tt,tmp/=tt;
			printf(&quot;%lld/&quot;,ans[i]);
			printf(&quot;%lld\n&quot;,tmp);
		}
	return 0;
}
<pre><h2>Problem2038</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define LL long long
using namespace std;
const int maxx=230,maxn=50010;
int n,m,cc,tot;
int num[maxn],c[maxn];
LL sum;
LL gcd(LL a,LL b){
	LL c;
	if (b==0) return a;
	c=a%b;
	while (c){
		a=b;b=c;
		c=a%b;
	}
	return b;
}
struct ANS{
	LL a,b;
	void reduce(){
		long long d=gcd(b,a);
		a/=d;b/=d;
	}
}ans[maxn];
struct Query{
	int id;
	int ll,rr;
}qj[maxn];
bool cmp(Query a,Query b){
	if (a.ll/maxx==b.ll/maxx)return a.rr&lt;b.rr;
	else return a.ll&lt;b.ll;
}
void add(int x){
	sum+=num[x];
	num[x]++;
}
void dec(int x){
	num[x]--;
	sum-=num[x];
}
void work(){
	memset(num,0,sizeof(num));
	int L=1,R=1;
	add(c[1]);
	for (int i=0;i&lt;m;i++){
		int l=qj[i].ll,r=qj[i].rr;
		while (R&lt;r){
			R++;add(c[R]);
		}
		while (R&gt;r){
			dec(c[R]);R--;
		}
		while (L&lt;l){
			dec(c[L]);L++;
			
		}
		while (L&gt;l){
			L--;add(c[L]);
		}
		ans[qj[i].id].a=sum;
		ans[qj[i].id].b=(LL)(r-l+1)*(r-l)/2;
		ans[qj[i].id].reduce();
	}
}
int main(){
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	tot=1;cc=0;
	for (int i=1;i&lt;=n;i++)
		scanf(&quot;%d\n&quot;,&amp;c[i]);
	for (int i=0;i&lt;m;i++){
		scanf(&quot;%d%d\n&quot;,&amp;qj[i].ll,&amp;qj[i].rr);
		qj[i].id=i;		
	}
	sort(qj,qj+m,cmp);
	work();
	for (int i=0;i&lt;m;i++)
		printf(&quot;%lld/%lld\n&quot;,ans[i].a,ans[i].b);
	return 0;	
} 
<pre><h2>Problem2039</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define inf 999999999
#define NN 1111
int deep[NN],q[NN],o[NN],aa[1000000][3];
int n,tot,S,T,ans;
bool bfs()
{
	int head=0,tail=1,p,x,y;
	memset(deep,0,4*(n+10));
	deep[S]=1;
	q[tail]=S;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[T];
}
int dfs(int v,int ff)
{
	if (v==T) return ff;
	int res=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(aa[p][2],ff));
		if (tmp==0) deep[y]=inf;
		ff-=tmp;
		aa[p][2]-=tmp;
		aa[p^1][2]+=tmp;
		res+=tmp;
		if (!ff) break;
	}
	return res;
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v) {addedge(p,q,v);addedge(q,p,0);}
void add2(int p,int q,int v) {addedge(p,q,v);addedge(q,p,v);}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	S=n+1,T=n+2;
	int i,j,x;
	tot=1;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		//printf(&quot;add %d %d %d\n&quot;,S,i,x);
		add(S,i,x);
	}
	for (i=1;i&lt;=n;i++)
	{
		int tmp=0;
		for (j=1;j&lt;=n;j++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			ans+=x;
			tmp+=x;
			if (i&lt;j&amp;&amp;x) add2(i,j,x&lt;&lt;1);//,printf(&quot;add2 %d %d %d\n&quot;,i,j,x&lt;&lt;1);
		}
		//printf(&quot;add %d %d %d\n&quot;,i,T,tmp);
		add(i,T,tmp);
	}
	//printf(&quot;ans=%d\n&quot;,ans);
	while (bfs()) ans-=dfs(S,inf);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2039</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define inf 999999999
#define NN 1111
int deep[NN],q[NN],o[NN],aa[100000][3];
int n,tot,S,T,ans;
bool bfs()
{
	int head=0,tail=1,p,x,y;
	memset(deep,0,4*(n+10));
	deep[S]=1;
	q[tail]=S;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[T];
}
int dfs(int v,int ff)
{
	if (v==T) return ff;
	int res=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(aa[p][2],ff));
		if (tmp==0) deep[y]=inf;
		ff-=tmp;
		aa[p][2]-=tmp;
		aa[p^1][2]+=tmp;
		res+=tmp;
		if (!ff) break;
	}
	return res;
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v) {addedge(p,q,v);addedge(q,p,0);}
void add2(int p,int q,int v) {addedge(p,q,v);addedge(q,p,v);}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	S=n+1,T=n+2;
	int i,j,x;
	tot=1;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		//printf(&quot;add %d %d %d\n&quot;,S,i,x);
		add(S,i,x);
	}
	for (i=1;i&lt;=n;i++)
	{
		int tmp=0;
		for (j=1;j&lt;=n;j++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			ans+=x;
			tmp+=x;
			if (i&lt;j&amp;&amp;x) add2(i,j,x&lt;&lt;1);//,printf(&quot;add2 %d %d %d\n&quot;,i,j,x&lt;&lt;1);
		}
		//printf(&quot;add %d %d %d\n&quot;,i,T,tmp);
		if (tmp) add(i,T,tmp);
	}
	//printf(&quot;ans=%d\n&quot;,ans);
	while (bfs()) ans-=dfs(S,inf);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2049</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 1001111
int son[NN][2],tag[NN],fa[NN],n,m;
bool rrr[NN];
void rev(int v)
{
	tag[v]=!tag[v];
	swap(son[v][0],son[v][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	rev(son[v][0]);
	rev(son[v][1]);
	tag[v]=0;
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
	else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
}
void access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
	}
}
void makeroot(int x)
{
	access(x);
	splay(x);
	rev(x);
}
void link(int x,int y)
{
	makeroot(x);
	splay(x);
	fa[x]=y;
}
void cut(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	rrr[x]=true;
	son[y][0]=fa[x]=0;
}
int getroot(int x)
{
	access(x);
	splay(x);
	while (son[x][0]) x=son[x][0];
	return x;
}
int main()
{
	//freopen(&quot;cave.in&quot;,&quot;r&quot;,stdin);freopen(&quot;cave.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j,x,y;
	for (i=1;i&lt;=n;i++) rrr[i]=true;
	for (i=1;i&lt;=m;i++)
	{
		char ch=getchar();
		while (ch!='C'&amp;&amp;ch!='D'&amp;&amp;ch!='Q') ch=getchar();
		if (ch=='C')
		{
			for (j=1;j&lt;=6;j++) ch=getchar();
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			link(x,y);
		}
		else if (ch=='D')
		{
			for (j=1;j&lt;=6;j++) ch=getchar();
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			cut(x,y);
		}
		else
		{
			for (j=1;j&lt;=4;j++) ch=getchar();
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			if (getroot(x)==getroot(y)) printf(&quot;Yes\n&quot;);
			else printf(&quot;No\n&quot;);
		}
	}
	return 0;
}
<pre><h2>Problem2049</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int NN=11111;
int fa[NN],son[NN][2];
int n,m;
bool tag[NN],rrr[NN];
void rev(int v)
{
	tag[v]=!tag[v];
	swap(son[v][0],son[v][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	rev(son[v][0]),rev(son[v][1]);
	tag[v]=false;
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
	else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
}
void access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
	}
}
void makeroot(int x)
{
	access(x);
	splay(x);
	rev(x);
}
void link(int x,int y)
{
	makeroot(x);
	splay(x);
	fa[x]=y;
}
void cut(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	rrr[x]=true;
	fa[x]=son[y][0]=0;
}
int getroot(int x)
{
	access(x);
	splay(x);
	while (son[x][0]) x=son[x][0];
	return x;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	int i,x,y;
	for (i=1;i&lt;=n;i++) rrr[i]=true;
	for (i=1;i&lt;=m;i++)
	{
		char s[10];
		scanf(&quot;%s%d%d\n&quot;,s+1,&amp;x,&amp;y);
		if (s[1]=='Q')
		{
			if (getroot(x)==getroot(y)) printf(&quot;Yes\n&quot;);
			else printf(&quot;No\n&quot;);
		}
		else if (s[1]=='C') link(x,y);
		else cut(x,y);
	}
	return 0;
}<pre><h2>Problem2049</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int NN=11111;
int fa[NN],son[NN][2];
int n,m;
bool tag[NN],rrr[NN];
inline void rev(int t)
{
	tag[t]=!tag[t];
	swap(son[t][0],son[t][1]);
}
inline void pushdown(int t)
{
	if (!tag[t]) return;
	rev(son[t][0]),rev(son[t][1]);
	tag[t]=false;
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
	else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
}
void access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
	}
}
void makeroot(int x)
{
	access(x);
	splay(x);
	rev(x);
}
void link(int x,int y)
{
	makeroot(x);
	splay(x);
	fa[x]=y;
}
void cut(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	rrr[x]=true;
	fa[x]=son[y][0]=0;
}
int getroot(int x)
{
	access(x);
	splay(x);
	while (son[x][0]) x=son[x][0];
	return x;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	int i,x,y;
	for (i=1;i&lt;=n;i++) rrr[i]=true;
	for (i=1;i&lt;=m;i++)
	{
		static char s[10];
		scanf(&quot;%s%d%d\n&quot;,s+1,&amp;x,&amp;y);
		if (s[1]=='Q')
		{
			if (getroot(x)==getroot(y)) printf(&quot;Yes\n&quot;);
			else printf(&quot;No\n&quot;);
		}
		else if (s[1]=='C') link(x,y);
		else cut(x,y);
	}
	return 0;
}<pre><h2>Problem2054</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int fa[1000005],color[1000005];
int n,m,p,q;
int getfa(int x)
{
	if (fa[x]==x) return x;
	if (fa[x]==0) return n+1;
	return fa[x]=getfa(fa[x]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;p,&amp;q);
	int i;
	for (i=1;i&lt;=n;i++) fa[i]=i;
	for (i=m;i;i--)
	{
		int l=(i*p+q)%n+1,r=(i*q+p)%n+1;
		if (l&gt;r) {int t=l;l=r;r=t;}
		l=getfa(l);
		for (;l&lt;=r;l=getfa(l))
		{
			color[l]=i;
			fa[l]=l+1;
		}
	}
	for (i=1;i&lt;=n;i++) printf(&quot;%d\n&quot;,color[i]);
	return 0;
}<pre><h2>Problem2054</h2><pre>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#define M 10000000+5
using namespace std;
int f[M],n,m,p,q,c[M];
int Getfather(int x)
{
	if (f[x]==x||!f[x])
		return f[x]=x;
	return f[x]=Getfather(f[x]);
}
int main()
{
	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;p,&amp;q);
	int tot=0;
        for (int i=m;i;i--)
	{
		int l=((long long)i*p+q)%n+1,r=((long long)i*q+p)%n+1;
		if (l&gt;r) swap(l,r);
		for (int k=Getfather(l);k&lt;=r;k=Getfather(k))
		{
			c[k]=i;
			tot++;
			f[k]=k+1;
		}
		if (tot==n) break;
	}
	for (int i=1;i&lt;=n;i++)
		printf(&quot;%d\n&quot;,c[i]);
	return 0;
}<pre><h2>Problem2055</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define h1(i) (i)
#define h2(i) ((i)+n)
#define inf 999999999
int o[211],aa[51111][4],pre[211];
int n,m,tot=1,S,T,S0,T0;
inline void addedge(int p,int q,int v,int c)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][3]=c;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline void add(int p,int q,int v,int c)
{
	addedge(p,q,v,c);
	addedge(q,p,0,-c);
}
bool spfa()
{
	static int dist[211],que[1000000];
	static bool dl[211];
	memset(dist,60,sizeof(dist));
	memset(dl,0,sizeof(dl));
	int head=0,tail=1;
	que[1]=S;
	dist[S]=0,dl[S]=true;
	while (head&lt;tail)
	{
		int x=que[++head];
		dl[x]=false;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;dist[y]&gt;dist[x]+aa[p][3])
			{
				dist[y]=dist[x]+aa[p][3];
				pre[y]=p;
				if (!dl[y])
					dl[y]=true,que[++tail]=y;
			}
		}
	}
	return dist[T]&lt;dist[0];
}
int calc()
{
	int ff=inf,p,res=0;
	for (p=pre[T];p;p=pre[aa[p^1][1]]) ff=min(ff,aa[p][2]);
	for (p=pre[T];p;p=pre[aa[p^1][1]])
	{
		res+=ff*aa[p][3];
		aa[p][2]-=ff,aa[p^1][2]+=ff;
	}
	return res;
}
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	S0=n+n+1,T0=S0+1,S=T0+1,T=S+1;
	add(T0,S0,m,0);
	int i,x,j;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		add(S,h2(i),x,0);
		add(h1(i),T,x,0);
		add(S0,h1(i),inf,0);
		add(h2(i),T0,inf,0);
	}
	for (i=1;i&lt;n;i++)
		for (j=i+1;j&lt;=n;j++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			if (x!=-1) add(h2(i),h1(j),inf,x);
		}
	int ans=0;
	while (spfa()) ans+=calc();
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem2055</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;

#define INF (ll)0x7fffffff
#define maxn 210

using namespace std;

typedef long long ll;
int n,m,su,sv,ssu,sum,tot=1,b[maxn],pre[maxn],xy[maxn];
ll dis[maxn],ans;
bool flag[maxn];

struct edge{int x,y,w,c,last;}a[maxn*maxn&lt;&lt;2];

void add(int x,int y,int w,int c)
{
	a[++tot]=(edge){x,y,w,c,b[x]};
	b[x]=tot;
}

void Add(int x,int y,int w,int c)
{
	add(x,y,w,c);add(y,x,0,-c);
}

#define v a[i].y
bool spfa()
{
	queue&lt;int&gt; q;q.push(su);
	memset(dis,0x3f,sizeof(dis));
	dis[su]=0;
	while(!q.empty()){
		int x=q.front();q.pop();flag[x]=0;
		for(int i=b[x];i;i=a[i].last){
			if(dis[v]&gt;dis[x]+a[i].c&amp;&amp;a[i].w){
				dis[v]=dis[x]+a[i].c;
				pre[v]=i;
				if(!flag[v]){
					flag[v]=1;
					q.push(v);
				}
			}
		}
	}
	if(dis[sv]&gt;=0) return false;
	int i=pre[sv],flow=INF;
	for(;a[i].x!=su;i=pre[a[i].x]) flow=min(flow,a[i].w);flow=min(flow,a[i].w);
	i=pre[sv];
	for(;a[i].x!=su;i=pre[a[i].x]) a[i].w-=flow,a[i^1].w+=flow;a[i].w-=flow,a[i^1].w+=flow;
	ans+=dis[sv]*flow;
	//printf(&quot;%d\n&quot;,flow);
	return true;
}

int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	sv=n*2+1,ssu=n*2+2;Add(su,ssu,m,0);
	for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;xy[i]),Add(i,i+n,xy[i],-INF),sum+=xy[i];
	for(int i=1;i&lt;=n;i++) Add(ssu,i,INF,0),Add(i+n,sv,INF,0);
	for(int i=1;i&lt;n;i++){
		for(int j=i+1;j&lt;=n;j++){
			int w;
			scanf(&quot;%d&quot;,&amp;w);
			if(w!=-1) Add(i+n,j,INF,w);
		}
	}
	while(spfa());
	//printf(&quot;%d\n&quot;,sum);
	ans+=(sum*INF);
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2063</h2><pre>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const double MXR=1000000000000000000LL;
struct ret {
	long long a;
	int b;
	ret operator+=(ret y)//合并操作，为了方便进行了重载
	{
		a+=y.a;
		b=y.b;
		return *this;
	}
};
long long ten[19]={1};
ret f[19][170][1000];
bool vis[19][170][1000];
int k;
ret calc(int h,int sum,int rem)
//对一棵高度为h，所有元素的数位和需要额外+sum，在此树之前的小组有rem的空间的完全十叉树进行记忆化搜索
{
	if (vis[h][sum][rem]) return f[h][sum][rem];
	vis[h][sum][rem]=true;
	ret &amp;ans=f[h][sum][rem];
	if (h==0) {//h=0的情况
		if (rem==0) {
			ans.a=1;
			if (sum&lt;k) ans.b=k-sum;
			else ans.b=0;
		} else {
			ans.a=0;
			if (rem&gt;sum) ans.b=rem-sum;
			else ans.b=0;
		}
		return ans;
	}
	ans.a=0;ans.b=rem;
	int i;
	for (i=0;i&lt;=9;++i) {//h&gt;0时，根据十个儿子合并得出
		ans+=calc(h-1,sum+i,ans.b);
	}
	return ans;
}
ret count(long long l,long long r)
{
	long long l2=l,r2=r;
	int i,j,h=-1,suml=0,sumr=0;
	for (i=18;i&gt;=0;--i) {//求出其LCA、两个数分别的数位和
		if (h&lt;0 &amp;&amp; l/ten[i]!=r/ten[i]) h=i;
		suml+=l/ten[i];
		sumr+=r/ten[i];
		l%=ten[i];r%=ten[i];
	}
	ret ans;
	if (h&lt;0) {//l=r的情况
		ans.a=1;
		if (suml&gt;=k) ans.b=0;else ans.b=k-suml;
		return ans;
	}
	ans.a=0;ans.b=0;
	l=l2,r=r2;
	ans+=calc(0,suml,ans.b);//不要忘记l
	for (i=0;i&lt;h;++i) {//向上走
		suml-=l%ten[i+1]/ten[i];
		for (j=l%ten[i+1]/ten[i]+1;j&lt;=9;++j) ans+=calc(i,suml+j,ans.b);
	}
	suml-=l%ten[h+1]/ten[h];
	for (j=l%ten[h+1]/ten[h]+1;j&lt;r%ten[h+1]/ten[h];++j) ans+=calc(h,suml+j,ans.b);//在LCA的下一层，向右走
	for (i=h-1;i&gt;=0;--i) {//向下走
		suml+=r%ten[i+2]/ten[i+1];
		for (j=0;j&lt;r%ten[i+1]/ten[i];++j) ans+=calc(i,suml+j,ans.b);
	}
	ans+=calc(0,suml+r%10,ans.b);//不要忘记r
	return ans;
}
int main()
{
	long long l,r;
	cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;
	bool flag=false;
	for (int i=1;i&lt;=18;++i) ten[i]=10*ten[i-1];
	if (r==MXR &amp;&amp; l&lt;r) {
		--r;
		flag=true;
	}
	ret ans=count(l,r);
	if (flag) {
		if (ans.b==0) {
			++ans.a;
			ans.b=k;
		}
		--ans.b;
	}
	if (ans.b&gt;0) --ans.a;
	cout&lt;&lt;ans.a&lt;&lt;endl;
}
<pre><h2>Problem2063</h2><pre>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const double MXR=1000000000000000000LL;
struct ret {
	long long a;
	int b;
	ret operator+=(ret y)//合并操作，为了方便进行了重载
	{
		a+=y.a;
		b=y.b;
		return *this;
	}
};
long long ten[19]={1};
ret f[19][170][1000];
bool vis[19][170][1000];
int k;
ret calc(int h,int sum,int rem)//对一棵高度为h，所有元素的数位和需要额外+sum，在此树之前的小组有rem的空间的完全十叉树进行记忆化搜索
{
	if (vis[h][sum][rem]) return f[h][sum][rem];
	vis[h][sum][rem]=true;
	ret &amp;ans=f[h][sum][rem];
	if (h==0) {//h=0的情况
		if (rem==0) {
			ans.a=1;
			if (sum&lt;k) ans.b=k-sum;
			else ans.b=0;
		} else {
			ans.a=0;
			if (rem&gt;sum) ans.b=rem-sum;
			else ans.b=0;
		}
		return ans;
	}
	ans.a=0;ans.b=rem;
	int i;
	for (i=0;i&lt;=9;++i) {//h&gt;0时，根据十个儿子合并得出
		ans+=calc(h-1,sum+i,ans.b);
	}
	return ans;
}
ret count(long long l,long long r)
{
	long long l2=l,r2=r;
	int i,j,h=-1,suml=0,sumr=0;
	for (i=18;i&gt;=0;--i) {//求出其LCA、两个数分别的数位和
		if (h&lt;0 &amp;&amp; l/ten[i]!=r/ten[i]) h=i;
		suml+=l/ten[i];
		sumr+=r/ten[i];
		l%=ten[i];r%=ten[i];
	}
	ret ans;
	if (h&lt;0) {//l=r的情况
		ans.a=1;
		if (suml&gt;=k) ans.b=0;else ans.b=k-suml;
		return ans;
	}
	ans.a=0;ans.b=0;
	l=l2,r=r2;
	ans+=calc(0,suml,ans.b);//不要忘记l
	for (i=0;i&lt;h;++i) {//向上走
		suml-=l%ten[i+1]/ten[i];
		for (j=l%ten[i+1]/ten[i]+1;j&lt;=9;++j) ans+=calc(i,suml+j,ans.b);
	}
	suml-=l%ten[h+1]/ten[h];
	for (j=l%ten[h+1]/ten[h]+1;j&lt;r%ten[h+1]/ten[h];++j) ans+=calc(h,suml+j,ans.b);//在LCA的下一层，向右走
	for (i=h-1;i&gt;=0;--i) {//向下走
		suml+=r%ten[i+2]/ten[i+1];
		for (j=0;j&lt;r%ten[i+1]/ten[i];++j) ans+=calc(i,suml+j,ans.b);
	}
	ans+=calc(0,suml+r%10,ans.b);//不要忘记r
	return ans;
}
int main()
{
	long long l,r;
	cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;
	bool flag=false;
	for (int i=1;i&lt;=18;++i) ten[i]=10*ten[i-1];
	ret ans=count(l,r);
	if (flag) {
		if (ans.b==0) {
			++ans.a;
			ans.b=k;
		}
		--ans.b;
	}
	if (ans.b&gt;0) --ans.a;
	cout&lt;&lt;ans.a&lt;&lt;endl;
}
<pre><h2>Problem2063</h2><pre>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
struct ret {
	long long a;
	int b;
	ret operator+=(ret y)//合并操作，为了方便进行了重载
	{
		a+=y.a;
		b=y.b;
		return *this;
	}
};
long long ten[19]={1};
ret f[19][170][1000];
bool vis[19][170][1000];
int k;
ret calc(int h,int sum,int rem)//对一棵高度为h，所有元素的数位和需要额外+sum，在此树之前的小组有rem的空间的完全十叉树进行记忆化搜索
{
	if (vis[h][sum][rem]) return f[h][sum][rem];
	vis[h][sum][rem]=true;
	ret &amp;ans=f[h][sum][rem];
	if (h==0) {//h=0的情况
		if (rem==0) {
			ans.a=1;
			if (sum&lt;k) ans.b=k-sum;
			else ans.b=0;
		} else {
			ans.a=0;
			if (rem&gt;sum) ans.b=rem-sum;
			else ans.b=0;
		}
		return ans;
	}
	ans.a=0;ans.b=rem;
	int i;
	for (i=0;i&lt;=9;++i) {//h&gt;0时，根据十个儿子合并得出
		ans+=calc(h-1,sum+i,ans.b);
	}
	return ans;
}
ret count(long long l,long long r)
{
	long long l2=l,r2=r;
	int i,j,h=-1,suml=0,sumr=0;
	for (i=18;i&gt;=0;--i) {//求出其LCA、两个数分别的数位和
		if (h&lt;0 &amp;&amp; l/ten[i]!=r/ten[i]) h=i;
		suml+=l/ten[i];
		sumr+=r/ten[i];
		l%=ten[i];r%=ten[i];
	}
	ret ans;
	if (h&lt;0) {//l=r的情况
		ans.a=1;
		if (suml&gt;=k) ans.b=0;else ans.b=k-suml;
		return ans;
	}
	ans.a=0;ans.b=0;
	l=l2,r=r2;
	ans+=calc(0,suml,ans.b);//不要忘记l
	for (i=0;i&lt;h;++i) {//向上走
		suml-=l%ten[i+1]/ten[i];
		for (j=l%ten[i+1]/ten[i]+1;j&lt;=9;++j) ans+=calc(i,suml+j,ans.b);
	}
	suml-=l%ten[h+1]/ten[h];
	for (j=l%ten[h+1]/ten[h]+1;j&lt;r%ten[h+1]/ten[h];++j) ans+=calc(h,suml+j,ans.b);//在LCA的下一层，向右走
	for (i=h-1;i&gt;=0;--i) {//向下走
		suml+=r%ten[i+2]/ten[i+1];
		for (j=0;j&lt;r%ten[i+1]/ten[i];++j) ans+=calc(i,suml+j,ans.b);
	}
	ans+=calc(0,suml+r%10,ans.b);//不要忘记r
	return ans;
}
int main()
{
	long long l,r;
	cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;
	bool flag=false;
	for (int i=1;i&lt;=18;++i) ten[i]=10*ten[i-1];
	ret ans=count(l,r);
	if (ans.b&gt;0) --ans.a;
	cout&lt;&lt;ans.a&lt;&lt;endl;
}
<pre><h2>Problem2063</h2><pre>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
struct ret {
	long long a;
	int b;
	ret operator+=(ret y)//合并操作，为了方便进行了重载
	{
		a+=y.a;
		b=y.b;
		return *this;
	}
};
long long ten[19]={1};
ret f[19][170][1000];
bool vis[19][170][1000];
int k;
ret calc(int h,int sum,int rem)//对一棵高度为h，所有元素的数位和需要额外+sum，在此树之前的小组有rem的空间的完全

//十叉树进行记忆化搜索
{
	if (vis[h][sum][rem]) return f[h][sum][rem];
	vis[h][sum][rem]=true;
	ret &amp;ans=f[h][sum][rem];
	if (h==0) {//h=0的情况
		if (rem==0) {
			ans.a=1;
			if (sum&lt;k) ans.b=k-sum;
			else ans.b=0;
		} else {
			ans.a=0;
			if (rem&gt;sum) ans.b=rem-sum;
			else ans.b=0;
		}
		return ans;
	}
	ans.a=0;ans.b=rem;
	int i;
	for (i=0;i&lt;=9;++i) {//h&gt;0时，根据十个儿子合并得出
		ans+=calc(h-1,sum+i,ans.b);
	}
	return ans;
}
ret count(long long l,long long r)
{
	long long l2=l,r2=r;
	int i,j,h=-1,suml=0,sumr=0;
	for (i=18;i&gt;=0;--i) {//求出其LCA、两个数分别的数位和
		if (h&lt;0 &amp;&amp; l/ten[i]!=r/ten[i]) h=i;
		suml+=l/ten[i];
		sumr+=r/ten[i];
		l%=ten[i];r%=ten[i];
	}
	ret ans;
	if (h&lt;0) {//l=r的情况
		ans.a=1;
		if (suml&gt;=k) ans.b=0;else ans.b=k-suml;
		return ans;
	}
	ans.a=0;ans.b=0;
	l=l2,r=r2;
	ans+=calc(0,suml,ans.b);//不要忘记l
	for (i=0;i&lt;h;++i) {//向上走
		suml-=l%ten[i+1]/ten[i];
		for (j=l%ten[i+1]/ten[i]+1;j&lt;=9;++j) ans+=calc(i,suml+j,ans.b);
	}
	suml-=l%ten[h+1]/ten[h];
	for (j=l%ten[h+1]/ten[h]+1;j&lt;r%ten[h+1]/ten[h];++j) ans+=calc(h,suml+j,ans.b);//在LCA的下一层，向右走
	for (i=h-1;i&gt;=0;--i) {//向下走
		suml+=r%ten[i+2]/ten[i+1];
		for (j=0;j&lt;r%ten[i+1]/ten[i];++j) ans+=calc(i,suml+j,ans.b);
	}
	ans+=calc(0,suml+r%10,ans.b);//不要忘记r
	return ans;
}
int main()
{
	long long l,r;
	cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;
	for (int i=1;i&lt;=18;++i) ten[i]=10*ten[i-1];
	ret ans=count(l,r);
	if (ans.b&gt;0) --ans.a;
	cout&lt;&lt;ans.a&lt;&lt;endl;
}
<pre><h2>Problem2063</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define LL long long
int M,i,a[20],b[20];
LL L,R,ten[20];
bool vt[20][200][1000];
struct ppt
{
	LL a;
	int b;
	friend ppt operator + (ppt x,ppt y)
	{
		y.a+=x.a;
		return y;
	}
} f[20][200][1000];
ppt calc(int h,int sum,int x)
{
	if (vt[h][sum][x]) return f[h][sum][x];
	ppt ans;
	if (h==1)
	{
		if (x==0)
		{
			ans.a=1;
			if (sum&gt;=M) ans.b=0;else ans.b=M-sum;
		}
		else
		{
			ans.a=0;
			if (x&lt;=sum) ans.b=0;else ans.b=x-sum;
		}
		return f[h][sum][x]=ans;
	}
	ans.a=0,ans.b=x;
	for (int i=0;i&lt;=9;i++)
		ans=ans+calc(h-1,sum+i,ans.b);
	vt[h][sum][x]=true;
	return f[h][sum][x]=ans;
}
ppt count(LL L,LL R)
{
	ppt ans;
	int i,j,suml,sumr,h=0;
	LL l,r,*tmp;
	for (suml=sumr=0,tmp=&amp;ten[17],l=L,r=R,i=1;i&lt;=18;i++,tmp--)
	{
		a[i]=l/(*tmp),suml+=a[i];
		b[i]=r/(*tmp),sumr+=b[i];
		if (a[i]!=b[i]&amp;&amp;!h) h=18-i+1;
		l%=*tmp;
		r%=*tmp;
	}
	if (L==R) return calc(1,suml,0);
	ans.a=0,ans.b=0;
	ans=ans+calc(1,suml,0);
	for (i=1;i&lt;h;i++)
	{
		suml-=a[18-i+1];
		for (j=a[18-i+1]+1;j&lt;=9;j++) ans=ans+calc(i,suml+j,ans.b);
	}
	suml-=a[18-h+1];
	for (i=a[18-h+1]+1;i&lt;b[18-h+1];i++) ans=ans+calc(h,suml+i,ans.b);
	suml+=b[18-h+1];
	for (i=h-1;i&gt;=1;i--)
	{
		for (j=0;j&lt;b[18-i+1];j++) ans=ans+calc(i,suml+j,ans.b);
		suml+=b[18-i+1];
	}
	ans=ans+calc(1,suml,ans.b);
	return ans;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld%lld%d&quot;,&amp;L,&amp;R,&amp;M);
	for (ten[0]=1,i=1;i&lt;=18;i++) ten[i]=ten[i-1]*10;
	ppt ans=count(L,R);
	if (ans.b&gt;0) --ans.a;
	printf(&quot;%lld\n&quot;,ans.a);
	return 0;
}
<pre><h2>Problem2064</h2><pre>var
    n1, n2, size                    :longint;
    i, j, k                         :longint;
    sum, w                          :array[0..1048576]of longint;
procedure init;
begin
    read(n1);
    for i:=1 to n1 do read(sum[1&lt;&lt;(i-1)]);
    read(n2);
    for i:=n1+1 to n1+n2 do
    begin
        read(sum[1&lt;&lt;(i-1)]);
        sum[1&lt;&lt;(i-1)]:=-sum[1&lt;&lt;(i-1)];
    end;
    n1:=n1+n2;
    size:=1&lt;&lt;n1-1;
end;
procedure calc(x:longint);
begin
    j:=x and (-x);
    sum[x]:=sum[j]+sum[x-j];
    for j:=1 to n1 do
        if x and (1&lt;&lt;(j-1))&gt;0 then
        begin
            k:=x-1&lt;&lt;(j-1);
            if w[k]&gt;w[x] then w[x]:=w[k];
        end;
    if sum[x]=0 then inc(w[x]);
end;
begin
    init;
    for i:=1 to size do calc(i);
    writeln(n1-2*w[size]);
end.
<pre><h2>Problem2064</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int f[1024][1024],num1[1024],num2[1024],sum1[1024],sum2[1024],o[100000],aa[2000000][2];
int n1,n2,i,j,k,l,p,q,all1,all2,tot;
void addedge(int p,int q) {aa[++tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int min(int a,int b) {return a&lt;b?a:b;}
int max(int a,int b) {return -min(-a,-b);}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n1);
	for (i=1;i&lt;=n1;i++) scanf(&quot;%d&quot;,&amp;sum1[1&lt;&lt;(i-1)]),num1[1&lt;&lt;(i-1)]=1;
	all1=(1&lt;&lt;n1)-1;
	for (i=0;i&lt;=all1;i++)
	{
		sum1[i]=sum1[i&amp;-i]+sum1[i^(i&amp;-i)];
		num1[i]=num1[i&amp;-i]+num1[i^(i&amp;-i)];
	}
	scanf(&quot;%d&quot;,&amp;n2);
	for (i=1;i&lt;=n2;i++)	scanf(&quot;%d&quot;,&amp;sum2[1&lt;&lt;(i-1)]),num2[1&lt;&lt;(i-1)]=1;
	all2=(1&lt;&lt;n2)-1;
	for (i=0;i&lt;=all2;i++)
	{
		sum2[i]=sum2[i&amp;-i]+sum2[i^(i&amp;-i)];
		addedge(sum2[i],i);
		num2[i]=num2[i&amp;-i]+num2[i^(i&amp;-i)];
	}
	for (i=0;i&lt;=all1;i++)
		for (j=0;j&lt;=all2;j++) f[i][j]=max(0,num1[i]+num2[j]-2);
	for (i=0;i&lt;=all1;i++)
		for (p=o[sum1[i]];p;p=aa[p][0])
		{
			j=aa[p][1];
			for (k=0;k&lt;i;k++)
				for (q=o[sum1[k]];q;q=aa[q][0])
				{
					l=aa[q][1];
					if ((k&amp;i)==k&amp;&amp;(l&amp;j)==l) f[i][j]=min(f[i][j],f[k][l]+f[i^k][j^l]);
				}
		}
	printf(&quot;%d\n&quot;,f[all1][all2]);
	return 0;
}
<pre><h2>Problem2064</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int f[1024][1024],num1[1024],num2[1024],sum1[1024],sum2[1024],o[100000],aa[2000000][2];
int n1,n2,i,j,k,l,p,q,all1,all2,tot;
void addedge(int p,int q) {aa[++tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int min(int a,int b) {return a&lt;b?a:b;}
int max(int a,int b) {return a&gt;b?a:b;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n1);
	for (i=1;i&lt;=n1;i++) scanf(&quot;%d&quot;,&amp;sum1[1&lt;&lt;(i-1)]),num1[1&lt;&lt;(i-1)]=1;
	all1=(1&lt;&lt;n1)-1;
	for (i=0;i&lt;=all1;i++)
	{
		sum1[i]=sum1[i&amp;-i]+sum1[i^(i&amp;-i)];
		num1[i]=num1[i&amp;-i]+num1[i^(i&amp;-i)];
	}
	scanf(&quot;%d&quot;,&amp;n2);
	for (i=1;i&lt;=n2;i++)	scanf(&quot;%d&quot;,&amp;sum2[1&lt;&lt;(i-1)]),num2[1&lt;&lt;(i-1)]=1;
	all2=(1&lt;&lt;n2)-1;
	for (i=0;i&lt;=all2;i++)
	{
		sum2[i]=sum2[i&amp;-i]+sum2[i^(i&amp;-i)];
		addedge(sum2[i],i);
		num2[i]=num2[i&amp;-i]+num2[i^(i&amp;-i)];
	}
	for (i=0;i&lt;=all1;i++)
		for (j=0;j&lt;=all2;j++) f[i][j]=max(0,num1[i]+num2[j]-2);
	for (i=0;i&lt;=all1;i++)
		for (p=o[sum1[i]];p;p=aa[p][0])
		{
			j=aa[p][1];
			for (k=(i-1)&amp;i;k&gt;0;k=(k-1)&amp;i)
				for (q=o[sum1[k]];q;q=aa[q][0])
				{
					l=aa[q][1];
					if ((k&amp;i)==k&amp;&amp;(l&amp;j)==l) f[i][j]=min(f[i][j],f[k][l]+f[i^k][j^l]);
				}
		}
	printf(&quot;%d\n&quot;,f[all1][all2]);
	return 0;
}
<pre><h2>Problem2064</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int f[1024][1024],num1[1024],num2[1024],sum1[1024],sum2[1024],o[100000],aa[2000000][2];
int n1,n2,i,j,k,l,p,q,all1,all2,tot;
void addedge(int p,int q) {aa[++tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int min(int a,int b) {return a&lt;b?a:b;}
int max(int a,int b) {return a&gt;b?a:b;}
int main()
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d&quot;,&amp;n1);
    for (i=1;i&lt;=n1;i++) scanf(&quot;%d&quot;,&amp;sum1[1&lt;&lt;(i-1)]),num1[1&lt;&lt;(i-1)]=1;
    all1=(1&lt;&lt;n1)-1;
    for (i=0;i&lt;=all1;i++)
    {
        sum1[i]=sum1[i&amp;-i]+sum1[i^(i&amp;-i)];
        num1[i]=num1[i&amp;-i]+num1[i^(i&amp;-i)];
    }
    scanf(&quot;%d&quot;,&amp;n2);
    for (i=1;i&lt;=n2;i++)  scanf(&quot;%d&quot;,&amp;sum2[1&lt;&lt;(i-1)]),num2[1&lt;&lt;(i-1)]=1;
    all2=(1&lt;&lt;n2)-1;
    for (i=0;i&lt;=all2;i++)
    {
        sum2[i]=sum2[i&amp;-i]+sum2[i^(i&amp;-i)];
        addedge(sum2[i],i);
        num2[i]=num2[i&amp;-i]+num2[i^(i&amp;-i)];
    }
    for (i=0;i&lt;=all1;i++)
        for (j=0;j&lt;=all2;j++) f[i][j]=max(0,num1[i]+num2[j]-2);
    for (i=0;i&lt;=all1;i++)
        for (p=o[sum1[i]];p;p=aa[p][0])
        {
            j=aa[p][1];
            for (k=(i-1)&amp;i;k&gt;0;k=(k-1)&amp;i)
                for (q=o[sum1[k]];q;q=aa[q][0])
                {
                    l=aa[q][1];
                    if ((k&amp;i)==k&amp;&amp;(l&amp;j)==l) f[i][j]=min(f[i][j],f[k][l]+f[i^k][j^l]);
                }
        }
    printf(&quot;%d\n&quot;,f[all1][all2]);
    return 0;
}<pre><h2>Problem2064</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int f[1024][1024],num1[1024],num2[1024],sum1[1024],sum2[1024];
int n1,n2,i,j,k,l,all1,all2;
int min(int a,int b) {return a&lt;b?a:b;}
int max(int a,int b) {return a&gt;b?a:b;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n1);
	for (i=1;i&lt;=n1;i++) scanf(&quot;%d&quot;,&amp;sum1[1&lt;&lt;(i-1)]),num1[1&lt;&lt;(i-1)]=1;
	all1=(1&lt;&lt;n1)-1;
	for (i=0;i&lt;=all1;i++)
	{
		sum1[i]=sum1[i&amp;-i]+sum1[i^(i&amp;-i)];
		num1[i]=num1[i&amp;-i]+num1[i^(i&amp;-i)];
	}
	scanf(&quot;%d&quot;,&amp;n2);
	for (i=1;i&lt;=n2;i++)	scanf(&quot;%d&quot;,&amp;sum2[1&lt;&lt;(i-1)]),num2[1&lt;&lt;(i-1)]=1;
	all2=(1&lt;&lt;n2)-1;
	for (i=0;i&lt;=all2;i++)
	{
		sum2[i]=sum2[i&amp;-i]+sum2[i^(i&amp;-i)];
		num2[i]=num2[i&amp;-i]+num2[i^(i&amp;-i)];
	}
	for (i=0;i&lt;=all1;i++)
		for (j=0;j&lt;=all2;j++) f[i][j]=max(0,num1[i]+num2[j]-2);
	for (i=0;i&lt;=all1;i++)
		for (j=0;j&lt;=all2;j++)
			if (sum1[i]==sum2[j])
				for (k=(i-1)&amp;i;k&gt;0;k=(k-1)&amp;i)
					for (l=(j-1)&amp;j;l&gt;0;l=(l-1)&amp;i)
						if (sum1[k]==sum2[l])
							f[i][j]=min(f[i][j],f[k][l]+f[i^k][j^l]);
	printf(&quot;%d\n&quot;,f[all1][all2]);
	return 0;
}
<pre><h2>Problem2064</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
int f[1024][1024],num1[1024],num2[1024],sum1[1024],sum2[1024],o[100000],aa[2000000][2];
int n1,n2,i,j,k,l,p,q,all1,all2,tot;
void addedge(int p,int q) {aa[++tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int main()
{
    scanf(&quot;%d&quot;,&amp;n1);
    for (i=1;i&lt;=n1;i++) scanf(&quot;%d&quot;,&amp;sum1[1&lt;&lt;(i-1)]),num1[1&lt;&lt;(i-1)]=1;
    all1=(1&lt;&lt;n1)-1;
    for (i=0;i&lt;=all1;i++)
    {
        sum1[i]=sum1[i&amp;-i]+sum1[i^(i&amp;-i)];
        num1[i]=num1[i&amp;-i]+num1[i^(i&amp;-i)];
    }
    scanf(&quot;%d&quot;,&amp;n2);
    for (i=1;i&lt;=n2;i++)  scanf(&quot;%d&quot;,&amp;sum2[1&lt;&lt;(i-1)]),num2[1&lt;&lt;(i-1)]=1;
    all2=(1&lt;&lt;n2)-1;
    for (i=0;i&lt;=all2;i++)
    {
        sum2[i]=sum2[i&amp;-i]+sum2[i^(i&amp;-i)];
        addedge(sum2[i],i);
        num2[i]=num2[i&amp;-i]+num2[i^(i&amp;-i)];
    }
    for (i=0;i&lt;=all1;i++)
        for (j=0;j&lt;=all2;j++) f[i][j]=max(0,num1[i]+num2[j]-2);
    for (i=0;i&lt;=all1;i++)
        for (p=o[sum1[i]];p;p=aa[p][0])
        {
            j=aa[p][1];
            for (k=(i-1)&amp;i;k&gt;0;k=(k-1)&amp;i)
                for (q=o[sum1[k]];q;q=aa[q][0])
                {
                    l=aa[q][1];
                    if ((k&amp;i)==k&amp;&amp;(l&amp;j)==l) f[i][j]=min(f[i][j],f[k][l]+f[i^k][j^l]);
                }
        }
    printf(&quot;%d\n&quot;,f[all1][all2]);
    return 0;
}<pre><h2>Problem2066</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;stack&gt;
#include&lt;cstdlib&gt;
#include&lt;string&gt;
#include&lt;bitset&gt;
#include&lt;map&gt;
#define INF 1000000000
#define N 1000005
#define fi first
#define se second
#define P 1000000007
#define debug(x) cerr&lt;&lt;#x&lt;&lt;&quot;=&quot;&lt;&lt;x&lt;&lt;endl
#define MP(x,y) make_pair(x,y)
using namespace std;
typedef long long LL;
typedef pair&lt;int,int&gt; pii;
char ch;
inline void getint(int &amp;x)
{
	x=0;
	for(ch=getchar();ch&lt;'0'||ch&gt;'9';ch=getchar());
	x=ch-48;
	for(ch=getchar();ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=x*10+ch-48;
}

int a[N],sg,b[N],z,mp[N];
int main()
{
	int m,n,cnt=0,t1,t2,i,j,ans=0;
	//freopen(&quot;game.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;game.out&quot;,&quot;w&quot;,stdout);
	cin&gt;&gt;m&gt;&gt;n;
	for(i=1;i&lt;=n;i++)
	{
		getint(a[i]);
		//scanf(&quot;%d&quot;,&amp;a[i]);
		a[i]=m-2-(n-i)-a[i];
		//debug(a[i]);
		if(a[i]==-1)
			cnt++;
	}
	if(cnt!=0)
	{
		printf(&quot;%d\n&quot;,cnt);
		return 0;
	}
	a[0]=INF+5;
	for(i=1;i&lt;=n;i++)
	{
		if(a[i]!=a[i-1])
		{
			if(mp[z]%2==1)
				sg^=b[z];
			z++;
			b[z]=1;
			mp[z]=a[i];
		}
		else b[z]++;
	}
	if(mp[z]%2==1)
		sg^=b[z];
	if(sg==0)
	{
		printf(&quot;0\n&quot;);
		return 0;
	}
	mp[z+1]=-5;
	//debug(z);
	//debug(sg);
	//cerr&lt;&lt;sg&lt;&lt;endl;
	for(i=1;i&lt;=z;i++)
	{
		if(mp[i]==0)
			continue;
		if(mp[i]%2==0)
		{
			t1=sg;
			if(mp[i]-1==mp[i+1])
			{
				t1^=b[i+1];
				for(j=1;j&lt;=b[i];j++)
				{
					t2=t1^(j+b[i+1]);
					if(t2==0)
					{
						//debug(j);
						ans++;
					}
				}
			}
			else
			{
				for(j=1;j&lt;=b[i];j++)
				{
					t2=t1^j;
					if(t2==0)
					{
						//cerr&lt;&lt;j&lt;&lt;endl;
						ans++;
					}
				}
			}
		}
		else
		{
			t1=sg^b[i];
			//debug(b[i]);
			for(j=0;j&lt;b[i];j++)
				if((t1^j)==0)
					ans++;
		}
	}
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}
// davidlee1999WTK 2015/
// srO myk Orz
//ios::sync_with_stdio(false);<pre><h2>Problem2084</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
char ss[501111],s[1001111];
int n,b[1001111];
inline bool cango(char a,char b)
{
	if (a=='#'&amp;&amp;b=='#') return true;
	if (a=='0'&amp;&amp;b=='1') return true;
	if (a=='1'&amp;&amp;b=='0') return true;
	return false;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d\n%s&quot;,&amp;n,ss+1);
	int cnt=0,i,id,right;
	s[0]='@';
	for (i=1;i&lt;=n;i++)
		s[++cnt]='#',s[++cnt]=ss[i];
	s[++cnt]='#',s[++cnt]='$';
	//printf(&quot;%s\n&quot;,s);
	right=0,id=0;
	LL ans=0;
	for (i=1;i&lt;=cnt;i++)
	{
		//printf(&quot;\n---------------------------------------------------------------------\n&quot;);
		if (right&gt;i) b[i]=min(b[id*2-i],right-i);
		else b[i]=0;
		while (cango(s[i-b[i]],s[i+b[i]])) b[i]++;
		//printf(&quot;b[i]=%d\n&quot;,b[i]);
		if (i&amp;1) ans+=(b[i]-1)/2;
		if (i+b[i]&gt;right)
			right=i+b[i],id=i;
		//printf(&quot;ans=%lld\n&quot;,ans);
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem2085</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define M 220
#define BASE 131
#define MOD 999911657
using namespace std;
int n,m,len[M];
char str[101000],*s[M];
long long power[101000],_hash[101000],*hash[M];
long long f[M][M],g[M][M],ans[M][M];
int Get_Hash(long long *hash,int l,int r)
{
	int len=r-l+1;
	return (hash[r]-hash[l-1]*power[len]%MOD+MOD)%MOD;
}
int Calculate(int x,int y)//计算x最长的后缀，这个后缀也是y的前缀
{
	int i;
	for(i=min(len[x],len[y])-(len[y]&lt;=len[x]);~i;i--)
		if( Get_Hash(hash[x],len[x]-i,len[x]-1) == Get_Hash(hash

[y],0,i-1) )
			return i;
	return 0;
}
int main()
{
	int T,i,j,k;
	cin&gt;&gt;n&gt;&gt;m;
	int temp=1,max_len=0;
	for(i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s&quot;,str+temp);

		s[i]=str+temp;
		hash[i]=_hash+temp;
		len[i]=strlen(s[i]);

		max_len=max(max_len,len[i]);

		++temp+=len[i];

		for(j=0;j&lt;len[i];j++)
			hash[i][j]=(hash[i][j-1]*BASE+s[i][j])%MOD;
	}
	for(power[0]=1,i=1;i&lt;=max_len;i++)
		power[i]=power[i-1]*BASE%MOD;
	memset(f,0x3f,sizeof f);
	for(i=1;i&lt;=n;i++)
	{
		f[0][i]=len[i];
		for(j=1;j&lt;=n;j++)
			f[i][j]=len[j]-Calculate(i,j);
	}
	memset(ans,0x3f,sizeof ans);
	for(i=1;i&lt;=n;i++)
		ans[i][i]=0;
	for(T=0;(1&lt;&lt;T)&lt;=m;T++)
	{
		if(T)
		{
			memset(g,0x3f,sizeof g);
			for(k=0;k&lt;=n;k++)
				for(i=0;i&lt;=n;i++)
					for(j=0;j&lt;=n;j++)
						g[i][j]=min(g[i][j],f[i][k]+f

[k][j]);
			memcpy(f,g,sizeof f);
		}
		if(m&amp;(1&lt;&lt;T) )
		{
			memset(g,0x3f,sizeof g);
			for(k=0;k&lt;=n;k++)
				for(i=0;i&lt;=n;i++)
					for(j=0;j&lt;=n;j++)
						g[i][j]=min(g[i][j],f[i][k]

+ans[k][j]);
			memcpy(ans,g,sizeof ans);
		}
	}
	long long ans=0x3f3f3f3f3f3f3f3fll;
	for(i=1;i&lt;=n;i++)
		ans=min(ans,::ans[0][i]);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}
<pre><h2>Problem2096</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const int NN=3001111;
LL K,n;
LL a[NN];
struct ppt
{
	LL w; int id;
	ppt(LL a=0,int b=0){w=a,id=b;}
} q1[NN],q2[NN];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld%lld&quot;,&amp;K,&amp;n);
	int i,h1,h2,t1,t2,L,R;
	for (i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]);
	int ans=1;
	h1=h2=0;
	q1[t1=1]=q2[t2=1]=ppt(a[1],1);
	for (L=R=1;L&lt;=n;L++)
	{
		while (h1&lt;t1&amp;&amp;q1[h1+1].id&lt;L) h1++;
		while (h2&lt;t2&amp;&amp;q2[h2+1].id&lt;L) h2++;
		for (;;)
		{
			if (q1[h1+1].w-q2[h2+1].w&gt;K) break;
			if (R&gt;n) break;
			R++;
			while (h1&lt;t1&amp;&amp;q1[t1].w&lt;=a[R]) t1--;
			q1[++t1]=ppt(a[R],R);
			while (h2&lt;t2&amp;&amp;q2[t2].w&gt;=a[R]) t2--;
			q2[++t2]=ppt(a[R],R);
		}
		int t=R-L;
		if (t&gt;ans) ans=t;
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem2097</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=101111;
int o[NN],aa[NN&lt;&lt;1][2],fa[NN],b[NN],f[NN];
int n,mid,cnt,use,K,tot=1;
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs(int v)
{
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dfs(y);
	}
	//printf(&quot;======================= dfs %d =====================\n&quot;,v);
	cnt=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		b[++cnt]=f[y];
	}
	sort(b+1,b+cnt+1);
	//printf(&quot;b &quot;);for(int i=1;i&lt;=cnt;i++)printf(&quot;%d &quot;,b[i]);ln;
	int i=cnt;
	while (i)
	{
		//printf(&quot;i=%d use=%d\n&quot;,i,use);
		if (b[i]+1&gt;mid) use++,i--;
		else if (i-1&amp;&amp;b[i]+b[i-1]+1&gt;mid) use++,i--;
		else break;
	}
	f[v]=b[i]+1;
	//printf(&quot;use=%d\n&quot;,use);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	int i,x,y;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	int l=1,r=n,res=0;
	while (l&lt;=r)
	{
		mid=(l+r)&gt;&gt;1;
		//printf(&quot;\n------------------------ l=%d r=%d mid=%d ---------------------------\n&quot;,l,r,mid);
		use=0;
		dfs(1);
		if (use&lt;=K) res=mid,r=mid-1;
		else l=mid+1;
	}
	printf(&quot;%d\n&quot;,res-1);
	return 0;
}<pre><h2>Problem2109</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
const int NN=20005;
int pos[NN],dy[NN],du[NN],du2[NN],o[NN],aa[NN&lt;&lt;1][2];
int n,m,tot;
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
struct ppt
{
	int v,w;
	friend bool operator &lt;(const ppt &amp;a,const ppt  &amp;b) {return a.w&lt;b.w;}
} q[NN];
priority_queue&lt;ppt&gt; Q;
void work(int the)
{
	while (!Q.empty()) Q.pop();
	int i;
	for (i=1;i&lt;=n;i++)
	{
		du2[i]=du[i];
		if (du2[i]==0) Q.push(q[i]);
	}
	for (i=n;i;i--)
	{
		ppt tmp=Q.top();
		if (tmp.v==the&amp;&amp;Q.size()&gt;1)
		{
			Q.pop();
			ppt t2=Q.top();
			if (t2.w&gt;=i)
			{
				Q.pop();
				Q.push(tmp);
				tmp=t2;
			}
		}
		else Q.pop();
		pos[tmp.v]=i;
		dy[i]=tmp.v;
		for (int p=o[tmp.v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (--du2[y]==0) Q.push(q[y]);
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;q[i].w);
		q[i].v=i;
	}
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		du[x]++;
		addedge(y,x);
	}
	for (i=1;i&lt;=n;i++)
	{
		work(i);
		printf(&quot;%d &quot;,pos[i]);
	}
	printf(&quot;\n&quot;);
	return 0;
}<pre><h2>Problem2111</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int NN=1001111;
int fac[NN],facinv[NN],size[NN&lt;&lt;1],f[NN];
int n,P;
LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
int C(int n,int m)
{
	return (LL)fac[n]*facinv[m]%P*facinv[n-m]%P;
}
int lucas(int n,int m)
{
	if (n&lt;m) return 0;
	if (m==0) return 1;
	return (LL)C(n%P,m%P)*lucas(n/P,m/P)%P;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;P);
	fac[0]=1;
	int i;
	for (i=1;i&lt;=n;i++)
		fac[i]=(LL)fac[i-1]*i%P;
	int t=min(P-1,n);
	facinv[t]=ksm(fac[t],P-2,P);
	for (i=t-1;i&gt;=0;i--)
		facinv[i]=(LL)facinv[i+1]*(i+1)%P;
	//printf(&quot;%d\n&quot;,lucas(5,2));
	for (i=n;i;i--)
	{
		//printf(&quot;\n---------------------------------------------------------------\n&quot;);
		int t1=(i&lt;&lt;1&gt;n)?1:f[i&lt;&lt;1];
		int t2=((i&lt;&lt;1|1)&gt;n)?1:f[i&lt;&lt;1|1];
		size[i]=size[i&lt;&lt;1]+size[i&lt;&lt;1|1]+1;
		//printf(&quot;t1=%d t2=%d size[i]=%d size[i&lt;&lt;1]=%d\n&quot;,t1,t2,size[i],size[i&lt;&lt;1]);
		f[i]=(LL)lucas(size[i]-1,size[i&lt;&lt;1])*t1%P*t2%P;
		//printf(&quot;f[%d]=%d\n&quot;,i,f[i]);
	}
	printf(&quot;%d\n&quot;,f[1]);
	return 0;
}<pre><h2>Problem2115</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const LL NN=501111,MM=1001111;
LL o[NN],aa[MM*2][3],b[NN+MM],dist[NN];
LL n,m,tot,cnt;
bool vt[NN];
inline void addedge(LL p,LL q,LL v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs(LL v)
{
	vt[v]=true;
	for (LL p=o[v];p;p=aa[p][0])
	{
		LL y=aa[p][1];
		if (!vt[y])
		{
			dist[y]=dist[v]^aa[p][2];
			dfs(y);
		}
		else b[++cnt]=dist[v]^aa[p][2]^dist[y];
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);
	LL i,j,x,y,z;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%lld%lld%lld&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
	}
	dfs(1);
	for (i=63;i;i--)
	{
		LL t=64-i,k=64-i;
		for (j=t+1;j&lt;=cnt;j++)
			if (b[j]&amp;(1ll&lt;&lt;(i-1))) {t=j;break;}
		if (t==64-i) continue;
		swap(b[k],b[t]);
		for (j=k+1;j&lt;=cnt;j++)
			if (b[j]&amp;(1ll&lt;&lt;(i-1))) b[j]^=b[k];
	}
	if (cnt&gt;63) cnt=63;
	LL ans=dist[n];
	for (i=1;i&lt;=63;i++)
		if ((ans^b[i])&gt;ans) ans^=b[i];
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem2118</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
#define inf 999999999
int o[500111],dist[500111],aa[6100001][3],a[15];
int n,tot;
LL L,R;
bool vt[500111];
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
struct ppt
{
	int v,d;
	ppt(int a=0,int b=0) {v=a;d=b;}
	friend bool operator &lt;(const ppt &amp;a,const ppt &amp;b) {return a.d&gt;b.d;}
};
priority_queue&lt;ppt&gt; Q;
void dij()
{
	for (int i=1;i&lt;a[1];i++) dist[i]=inf;
	Q.push(ppt(0,0));
	while (!Q.empty())
	{
		int v=Q.top().v,d=Q.top().d;
		Q.pop();
		if (vt[v]) continue;
		vt[v]=true;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (!vt[y]&amp;&amp;dist[y]&gt;d+aa[p][2])
			{
				dist[y]=d+aa[p][2];
				Q.push(ppt(y,dist[y]));
			}
		}
	}
}
LL work(LL n)
{
	LL res=0;
	for (int i=0;i&lt;a[1];i++)
		if (n%a[1]&gt;=i) res+=max(0ll,n/a[1]-dist[i]+1);
		else res+=max(0ll,n/a[1]-dist[i]);
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%lld%lld&quot;,&amp;n,&amp;L,&amp;R);
	int i,j;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		if (a[i]&lt;a[1]) swap(a[1],a[i]);
	}
	for (i=0;i&lt;a[1];i++)
		for (j=2;j&lt;=n;j++)
			addedge(i,(i+a[j])%a[1],(i+a[j])/a[1]);
	dij();
	//printf(&quot;dist &quot;);for(i=0;i&lt;a[1];i++)printf(&quot;%d &quot;,dist[i]);ln;
	printf(&quot;%lld\n&quot;,work(R)-work(L-1));
	return 0;
}<pre><h2>Problem2127</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define hao(i,j) (((i)-1)*m+(j))
#define inf 999999999
#define mii(a,b) ((a)&lt;(b)?(a):(b))
int q[11111],deep[11111],o[11111],aa[2000000][3];
int n,m,tot,S,T,ans;
bool bfs()
{
	int head=0,tail=1,p,x,y;
	memset(deep,0,4*(T+10));
	deep[S]=1;
	q[1]=S;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[T];
}
int dfs(int v,int ff)
{
	if (v==T) return ff;
	int res=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(aa[p][2],ff));
		if (tmp==0) deep[y]=inf;
		ff-=tmp;
		aa[p][2]-=tmp;
		aa[p^1][2]+=tmp;
		res+=tmp;
		if (!ff) break;
	}
	return res;
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v) {addedge(p,q,v);addedge(q,p,0);}
void add2(int p,int q,int v) {addedge(p,q,v);addedge(q,p,v);}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	S=n*m+1,T=S+1;
	tot=1;
	int i,j,x;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			ans+=(x&lt;&lt;1);
			add(S,hao(i,j),x&lt;&lt;1);
		}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			ans+=(x&lt;&lt;1);
			add(hao(i,j),T,x&lt;&lt;1);
		}
	for (i=1;i&lt;n;i++)
		for (j=1;j&lt;=m;j++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			ans+=2*x;
			add(S,hao(i,j),x);
			add(S,hao(i+1,j),x);
			add2(hao(i,j),hao(i+1,j),x);
		}
	for (i=1;i&lt;n;i++)
		for (j=1;j&lt;=m;j++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			ans+=2*x;
			add(hao(i,j),T,x);
			add(hao(i+1,j),T,x);
			add2(hao(i,j),hao(i+1,j),x);
		}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;m;j++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			ans+=2*x;
			add(S,hao(i,j),x);
			add(S,hao(i,j+1),x);
			add2(hao(i,j),hao(i,j+1),x);
		}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;m;j++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			ans+=2*x;
			add(hao(i,j),T,x);
			add(hao(i,j+1),T,x);
			add2(hao(i,j),hao(i,j+1),x);
		}
	while (bfs()) ans-=dfs(S,inf);
	printf(&quot;%d\n&quot;,ans&gt;&gt;1);
	return 0;
}
<pre><h2>Problem2131</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define maa(a,b) ((a)&gt;(b)?(a):(b))
#define LL long long
#define inf 999999999
int n,L,R,root,ww,ee,TTT,lc[3001111],rc[3001111];
LL ans,tmax[3001111];
struct ppt
{
	int t,p,w;
	friend bool operator &lt;(ppt a,ppt b) {return a.p==b.p?a.t&gt;b.t:a.p&lt;b.p;}
} a[101111];
LL find(int v,int l,int r)
{
	if (!v) return 0;
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tmax[v];
	int mid=(l+r)&gt;&gt;1;
	LL res=0;
	if (ww&lt;mid) res=max(res,find(lc[v],l,mid));
	if (ee&gt;mid) res=max(res,find(rc[v],mid,r));
	return res;
}
void change(int &amp;v,int l,int r,int i,LL x)
{
	if (!v) v=++TTT;
	if (r-l==1)
	{
		tmax[v]=maa(tmax[v],x);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid) change(lc[v],l,mid,i,x);
	else change(rc[v],mid,r,i,x);
	tmax[v]=maa(tmax[lc[v]],tmax[rc[v]]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);scanf(&quot;%d&quot;,&amp;n);
	L=inf,R=-inf;
	int i;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;a[i].t,&amp;a[i].p,&amp;a[i].w);
		int x=a[i].p,y=a[i].t*2;
		a[i].p=x-y,a[i].t=x+y;
		L=mii(L,a[i].t),R=maa(R,a[i].t);
	}
	sort(a+1,a+n+1);
	for (i=1;i&lt;=n;i++)
	{
		LL res=a[i].w;
		ww=a[i].t,ee=R+1;
		res=max(res,find(root,L,R+1)+a[i].w);
		ans=maa(ans,res);
		change(root,L,R+1,a[i].t,res);
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2132</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define hao(i,j) ((i-1)*m+j)
#define NN 1005
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define inf 999999999
#define ln printf(&quot;\n&quot;)
int A[NN][NN],B[NN][NN],C[NN][NN],q[NN*NN],deep[NN*NN],o[NN*NN],aa[NN*NN*6][3];
int n,m,tot,S,T,ans;
bool bfs()
{
	int head=0,tail=1,x,y,p;
	memset(deep,0,sizeof(int)*(T+10));
	deep[S]=1;
	q[1]=S;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[T];
}
int dfs(int v,int ff)
{
	if (v==T) return ff;
	int res=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(aa[p][2],ff));
		if (tmp==0) deep[y]=inf;
		ff-=tmp;
		aa[p][2]-=tmp;
		aa[p^1][2]+=tmp;
		res+=tmp;
		if (!ff) break;
	}
	return res;
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v)
{
	//printf(&quot;%d %d %d\n&quot;,p,q,v);
	addedge(p,q,v);
	addedge(q,p,0);
}
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j,x,y;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;A[i][j]),ans+=A[i][j];
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;B[i][j]),ans+=B[i][j];
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;C[i][j]);
	//printf(&quot;hao:\n&quot;);for(i=1;i&lt;=n;i++){for(j=1;j&lt;=m;j++)printf(&quot;%d &quot;,hao(i,j));ln;}ln;
	S=n*m+1,T=S+1;
	tot=1;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			if ((i+j)&amp;1) swap(A[i][j],B[i][j]);
			add(S,hao(i,j),A[i][j]);
			add(hao(i,j),T,B[i][j]);
			x=i-1,y=j;
			if (x&amp;&amp;y)
			{
				ans+=C[i][j]+C[x][y];
				addedge(hao(x,y),hao(i,j),C[i][j]+C[x][y]);
				addedge(hao(i,j),hao(x,y),C[i][j]+C[x][y]);
			}
			x=i,y=j-1;
			if (x&amp;&amp;y)
			{
				ans+=C[i][j]+C[x][y];
				addedge(hao(x,y),hao(i,j),C[i][j]+C[x][y]);
				addedge(hao(i,j),hao(x,y),C[i][j]+C[x][y]);
			}
		}
	//printf(&quot;ans=%d\n&quot;,ans);
	while (bfs()) ans-=dfs(S,inf);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2134</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef double DD;
const int NN=10000005;
int a[NN],n,A,B,C;
DD ans=0;
inline void work(int a,int b)
{
	if (a&lt;b) {int t=a;a=b;b=t;}
	ans+=1.0/a;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d%d%d&quot;,&amp;n,&amp;A,&amp;B,&amp;C,a+1);
	for (int i=2;i&lt;=n;i++) a[i] = ((long long)a[i-1] * A + B) % 100000001;
	for (int i=1;i&lt;=n;i++) a[i] = a[i] % C + 1;
	work(a[1],a[n]);
	for (int i=2;i&lt;=n;i++) work(a[i],a[i-1]);
	printf(&quot;%.3f\n&quot;,ans);
	return 0;
}<pre><h2>Problem2141</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define lc(v) ((v)&lt;&lt;1)
#define rc(v) ((v)&lt;&lt;1|1)
#define ln printf(&quot;\n&quot;)
const int NN=20111,MM=501111;
int fa[MM],size[MM],son[MM][2],num[MM],key[MM],a[NN],b[NN],c[NN];
int n,m,TTT;
void debug(int t){if(!t)return;debug(son[t][0]);printf(&quot;%d &quot;,key[t]);debug(son[t][1]);}
struct huishouzhan
{
	int sta[NN],top;
	void push(int x)
	{
		sta[++top]=x;
		fa[x]=son[x][0]=son[x][1]=key[x]=size[x]=num[x]=0;
	}
	int next() {return top&gt;0?sta[top--]:++TTT;}
} box;
struct Splay_Tree
{
	int root;
	void update(int t)
	{
		size[t]=size[son[t][0]]+size[son[t][1]]+num[t];
	}
	void rotate(int t,int p)
	{
		int y=fa[t];
		if (fa[y])
			if (y==son[fa[y]][0]) son[fa[y]][0]=t;
			else son[fa[y]][1]=t;
		fa[t]=fa[y];
		son[y][p^1]=son[t][p];
		if (son[t][p]) fa[son[t][p]]=y;
		son[t][p]=y;
		fa[y]=t;
		update(y),update(t);
	}
	void splay(int t,int ff)
	{
		while (fa[t]!=ff)
		{
			int y=fa[t];
			if (fa[y]==ff)
				if (t==son[y][0]) rotate(t,1);
				else rotate(t,0);
			else
				if (y==son[fa[y]][0])
					if (t==son[y][0]) rotate(y,1),rotate(t,1);
					else rotate(t,0),rotate(t,1);
				else
					if (t==son[y][1]) rotate(y,0),rotate(t,0);
					else rotate(t,1),rotate(t,0);
		}
		if (!ff) root=t;
		update(t);
	}
	void ins(int &amp;v,int x,int ff)
	{
		//printf(&quot;ins %d %d %d\n&quot;,v,x,ff);printf(&quot;key[v]=%d\n&quot;,key[v]);debug(v),ln;
		if (v==0)
		{
			v=box.next();
			fa[v]=ff;
			key[v]=x;
			size[v]=num[v]=1;
			splay(v,0);
			return;
		}
		if (x==key[v]) num[v]++,splay(v,0);
		else if (x&lt;key[v]) ins(son[v][0],x,v);
		else ins(son[v][1],x,v);
	}
	void del(int t,int x)
	{
		while (t)
		{
			if (key[t]==x) break;
			if (x&lt;key[t]) t=son[t][0];else t=son[t][1];
		}
		if (num[t]&gt;1) {num[t]--;splay(t,0);return;}
		splay(t,0);
		if (!son[t][0]||!son[t][1])
		{
			root=son[t][0]+son[t][1];
			fa[root]=0;
			box.push(t);
			return;
		}
		int y;
		for (y=son[t][0];son[y][1];y=son[y][1]);
		splay(y,t);
		son[y][1]=son[t][1];
		if (son[t][1]) fa[son[t][1]]=y;
		root=y,fa[y]=0;
		update(y);
		box.push(t);
	}
	int rank1(int t,int x)
	{
		int res=0;
		while (t)
		{
			if (key[t]&lt;x) res+=size[son[t][0]]+num[t],t=son[t][1];
			else t=son[t][0];
		}
		return res;
	}
	int rank2(int t,int x)
	{
		int res=0;
		while (t)
		{
			if (key[t]&gt;x) res+=size[son[t][1]]+num[t],t=son[t][0];
			else t=son[t][1];
		}
		return res;
	}
} T[NN*4];
void build(int v,int l,int r)
{
	for (int i=l;i&lt;r;i++) T[v].ins(T[v].root,a[i],0);//printf(&quot;debug: &quot;),debug(T[v].root),ln;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	build(lc(v),l,mid);
	build(rc(v),mid,r);
}
void change(int v,int l,int r,int i,int x,int kind)
{
	if (kind==1) T[v].ins(T[v].root,x,0);//,printf(&quot;ins %d %d %d %d\n&quot;,v,l,r,x),debug(T[v].root),ln;
	else T[v].del(T[v].root,x);//,printf(&quot;del %d %d %d %d\n&quot;,v,l,r,x),debug(T[v].root),ln;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid) change(lc(v),l,mid,i,x,kind);
	else change(rc(v),mid,r,i,x,kind);
}
int find1(int v,int l,int r,int ww,int ee,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return T[v].rank1(T[v].root,x);
	int mid=(l+r)&gt;&gt;1,res=0;
	if (ww&lt;mid) res+=find1(lc(v),l,mid,ww,ee,x);
	if (ee&gt;mid) res+=find1(rc(v),mid,r,ww,ee,x);
	return res;
}
int find2(int v,int l,int r,int ww,int ee,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return T[v].rank2(T[v].root,x);
	int mid=(l+r)&gt;&gt;1,res=0;
	if (ww&lt;mid) res+=find2(lc(v),l,mid,ww,ee,x);
	if (ee&gt;mid) res+=find2(rc(v),mid,r,ww,ee,x);
	return res;
}
int cha(int x)
{
	int l=1,r=n;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (b[mid]==x) return mid;
		if (b[mid]&lt;x) l=mid+1;
		else r=mid-1;
	}
	return -1;
}
void change0(int i,int x)
{
	for (;i&lt;=n;i+=(i&amp;-i)) c[i]+=x;
}
int getsum(int i)
{
	int res=0;
	for (;i;i-=(i&amp;-i)) res+=c[i];
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y,t;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),b[i]=a[i];
	sort(b+1,b+n+1);
	for (i=1;i&lt;=n;i++) a[i]=cha(a[i]);
	int now=0;
	for (i=1;i&lt;=n;i++)
	{
		now+=getsum(n)-getsum(a[i]);
		change0(a[i],1);
	}
	printf(&quot;%d\n&quot;,now);
	build(1,1,n+1);
	scanf(&quot;%d&quot;,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		//printf(&quot;\n---------------------------------------------------------------------\n&quot;);
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		if (a[x]==a[y]) {printf(&quot;%d\n&quot;,now);continue;}
		if (x&gt;y) t=x,x=y,y=t;
		now-=find1(1,1,n+1,x+1,y,a[x]);
		now+=find2(1,1,n+1,x+1,y,a[x]);
		now+=find1(1,1,n+1,x+1,y,a[y]);
		now-=find2(1,1,n+1,x+1,y,a[y]);
		if (a[x]&gt;a[y]) now--;else now++;
		printf(&quot;%d\n&quot;,now);
		change(1,1,n+1,x,a[x],-1);
		change(1,1,n+1,x,a[y],1);
		change(1,1,n+1,y,a[x],1);
		change(1,1,n+1,y,a[y],-1);
		t=a[x],a[x]=a[y],a[y]=t;
	}
	return 0;
}
<pre><h2>Problem2142</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
using namespace std;
#define LL long long
LL e[110000],w[110000],phi[110000],f[110000],pp[110000],prime[110000],num[110000];
LL P,P2,n,m,tt,i,tot,ans,res,sigma,j;
struct ppt{LL u,t;};
LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (;b&gt;0;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
ppt calc(LL n,LL prime,LL pp)
{
	ppt tmp;
	tmp.u=0,tmp.t=1;
	while (n&gt;0)
	{
		tmp.u+=n/prime;
		tmp.t=tmp.t*ksm(f[pp-1],n/pp,pp)%pp;
		tmp.t=tmp.t*f[n%pp]%pp;
		n/=prime;
	}
	return tmp;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld%lld%lld&quot;,&amp;P,&amp;n,&amp;m);
	for (tt=0,i=1;i&lt;=m;i++) scanf(&quot;%lld&quot;,&amp;w[i]),tt+=w[i];
	w[++m]=n-tt;
	if (m-1&gt;n||tt&gt;n) {printf(&quot;Impossible\n&quot;);return 0;}
	P2=P;
	for (i=2;i&lt;=(LL)sqrt(P);i++)
		if (P%i==0)
		{
			tot++;
			prime[tot]=i;
			pp[tot]=1;//pp[i]=pi^ci
			while (P%i==0)
			{
				num[tot]++;
				pp[tot]*=i;
				P/=i;
			}
			phi[tot]=pp[tot]-pp[tot]/i;
			e[tot]=ksm(P2/pp[tot],phi[tot]-1,pp[tot])*P2/pp[tot]%P2;
		}
	if (P&gt;1)
	{
		i=P;
		tot++;
		prime[tot]=i;
		pp[tot]=1;
		while (P%i==0)
		{
			num[tot]++;
			pp[tot]*=i;
			P/=i;
		}
		phi[tot]=pp[tot]-pp[tot]/i;
		e[tot]=ksm(P2/pp[tot],phi[tot]-1,pp[tot])*P2/pp[tot]%P2;
	}
	ans=0;
	for (i=1;i&lt;=tot;i++)
	{
		res=1;
		sigma=0;
		f[0]=1,f[1]=1;
		for (j=2;j&lt;pp[i];j++)
			if (j%prime[i]!=0) f[j]=f[j-1]*j%pp[i];
			else f[j]=f[j-1];
		ppt tmp=calc(n,prime[i],pp[i]);
		sigma+=tmp.u;
		res=res*tmp.t%pp[i];
		for (j=1;j&lt;=m;j++)
		{
			tmp=calc(w[j],prime[i],pp[i]);
			sigma-=tmp.u;
			res=res*ksm(tmp.t,phi[i]-1,pp[i])%pp[i];
		}
		res=res*ksm(prime[i],sigma,pp[i]);
		ans=(ans+res*e[i])%P2;
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2142</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
using namespace std;
#define LL long long
LL e[100],w[110000],phi[110000],f[110000],pp[110000],prime[110000],num[110000];
LL P,P2,n,m,tt,i,tot,ans,res,sigma,j;
struct ppt{LL u,t;};
LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (;b&gt;0;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
ppt calc(LL n,LL prime,LL pp)
{
	ppt tmp;
	tmp.u=0,tmp.t=1;
	while (n&gt;0)
	{
		tmp.u+=n/prime;
		tmp.t=tmp.t*ksm(f[pp-1],n/pp,pp)%pp;
		tmp.t=tmp.t*f[n%pp]%pp;
		n/=prime;
	}
	return tmp;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld%lld%lld&quot;,&amp;P,&amp;n,&amp;m);
	for (tt=0,i=1;i&lt;=m;i++) scanf(&quot;%lld&quot;,&amp;w[i]),tt+=w[i];
	w[++m]=n-tt;
	if (m-1&gt;n||tt&gt;n) {printf(&quot;Impossible\n&quot;);return 0;}
	P2=P;
	for (i=2;i&lt;=(LL)sqrt(P);i++)
		if (P%i==0)
		{
			tot++;
			prime[tot]=i;
			pp[tot]=1;//pp[i]=pi^ci
			while (P%i==0)
			{
				num[tot]++;
				pp[tot]*=i;
				P/=i;
			}
			phi[tot]=pp[tot]-pp[tot]/i;
			e[tot]=ksm(P2/pp[tot],phi[tot]-1,pp[tot])*P2/pp[tot]%P2;
		}
	if (P&gt;1)
	{
		i=P;
		tot++;
		prime[tot]=i;
		pp[tot]=1;
		while (P%i==0)
		{
			num[tot]++;
			pp[tot]*=i;
			P/=i;
		}
		phi[tot]=pp[tot]-pp[tot]/i;
		e[tot]=ksm(P2/pp[tot],phi[tot]-1,pp[tot])*P2/pp[tot]%P2;
	}
	ans=0;
	for (i=1;i&lt;=tot;i++)
	{
		res=1;
		sigma=0;
		f[0]=1,f[1]=1;
		for (j=2;j&lt;pp[i];j++)
			if (j%prime[i]!=0) f[j]=f[j-1]*j%pp[i];
			else f[j]=f[j-1];
		ppt tmp=calc(n,prime[i],pp[i]);
		sigma+=tmp.u;
		res=res*tmp.t%pp[i];
		for (j=1;j&lt;=m;j++)
		{
			tmp=calc(w[j],prime[i],pp[i]);
			sigma-=tmp.u;
			res=res*ksm(tmp.t,phi[i]-1,pp[i])%pp[i];
		}
		res=res*ksm(prime[i],sigma,pp[i]);
		ans=(ans+res*e[i])%P2;
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2142</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
using namespace std;
#define LL long long
LL e[21],w[21],phi[21],f[100000],pp[21],prime[21];
LL P,P2,n,m,tt,i,tot,ans,res,sigma,j;
struct ppt{LL u,t;};
LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (;b&gt;0;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
ppt calc(LL n,LL prime,LL pp)
{
	ppt tmp;
	tmp.u=0,tmp.t=1;
	while (n&gt;0)
	{
		tmp.u+=n/prime;
		tmp.t=tmp.t*ksm(f[pp-1],n/pp,pp)%pp;
		tmp.t=tmp.t*f[n%pp]%pp;
		n/=prime;
	}
	return tmp;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld%lld%lld&quot;,&amp;P,&amp;n,&amp;m);
	for (tt=0,i=1;i&lt;=m;i++) scanf(&quot;%lld&quot;,&amp;w[i]),tt+=w[i];
	w[++m]=n-tt;
	if (m-1&gt;n||tt&gt;n) {printf(&quot;Impossible\n&quot;);return 0;}
	P2=P;
	for (i=2;i&lt;=(LL)sqrt(P);i++)
		if (P%i==0)
		{
			tot++;
			prime[tot]=i;
			pp[tot]=1;//pp[i]=pi^ci
			for (pp[tot]=1;P%i==0;P/=i) pp[tot]*=i;
			phi[tot]=pp[tot]-pp[tot]/i;
			e[tot]=ksm(P2/pp[tot],phi[tot]-1,pp[tot])*P2/pp[tot]%P2;
		}
	if (P&gt;1)
	{
		i=P;
		tot++;
		prime[tot]=i;
		for (pp[tot]=1;P%i==0;P/=i) pp[tot]*=i;
		phi[tot]=pp[tot]-pp[tot]/i;
		e[tot]=ksm(P2/pp[tot],phi[tot]-1,pp[tot])*P2/pp[tot]%P2;
	}
	ans=0;
	for (i=1;i&lt;=tot;i++)
	{
		res=1;
		sigma=0;
		f[0]=1,f[1]=1;
		for (j=2;j&lt;pp[i];j++)
			if (j%prime[i]!=0) f[j]=f[j-1]*j%pp[i];
			else f[j]=f[j-1];
		ppt tmp=calc(n,prime[i],pp[i]);
		sigma+=tmp.u;
		res=res*tmp.t%pp[i];
		for (j=1;j&lt;=m;j++)
		{
			tmp=calc(w[j],prime[i],pp[i]);
			sigma-=tmp.u;
			res=res*ksm(tmp.t,phi[i]-1,pp[i])%pp[i];
		}
		res=res*ksm(prime[i],sigma,pp[i]);
		ans=(ans+res*e[i])%P2;
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2142</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
using namespace std;
#define LL long long
LL e[21],w[21],phi[21],f[100000],pp[21],prime[21];
LL P,P2,n,m,tt,i,tot,ans,res,sigma,j;
struct ppt{LL u,t;};
LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (;b&gt;0;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
ppt calc(LL n,LL prime,LL pp)
{
	ppt tmp;
	tmp.u=0,tmp.t=1;
	while (n&gt;0)
	{
		tmp.u+=n/prime;
		tmp.t=tmp.t*ksm(f[pp-1],n/pp,pp)%pp;
		tmp.t=tmp.t*f[n%pp]%pp;
		n/=prime;
	}
	return tmp;
}
int main()
{
	scanf(&quot;%lld%lld%lld&quot;,&amp;P,&amp;n,&amp;m);
	for (tt=0,i=1;i&lt;=m;i++) scanf(&quot;%lld&quot;,&amp;w[i]),tt+=w[i];
	w[++m]=n-tt;
	if (m-1&gt;n||tt&gt;n) {printf(&quot;Impossible\n&quot;);return 0;}
	P2=P;
	for (i=2;i&lt;=(LL)sqrt(P);i++)
		if (P%i==0)
		{
			tot++;
			prime[tot]=i;
			pp[tot]=1;//pp[i]=pi^ci
			for (pp[tot]=1;P%i==0;P/=i) pp[tot]*=i;
			phi[tot]=pp[tot]-pp[tot]/i;
			e[tot]=ksm(P2/pp[tot],phi[tot]-1,pp[tot])*P2/pp[tot]%P2;
		}
	if (P&gt;1)
	{
		i=P;
		tot++;
		prime[tot]=i;
		for (pp[tot]=1;P%i==0;P/=i) pp[tot]*=i;
		phi[tot]=pp[tot]-pp[tot]/i;
		e[tot]=ksm(P2/pp[tot],phi[tot]-1,pp[tot])*P2/pp[tot]%P2;
	}
	ans=0;
	for (i=1;i&lt;=tot;i++)
	{
		res=1;
		sigma=0;
		f[0]=1,f[1]=1;
		for (j=2;j&lt;pp[i];j++)
			if (j%prime[i]!=0) f[j]=f[j-1]*j%pp[i];
			else f[j]=f[j-1];
		ppt tmp=calc(n,prime[i],pp[i]);
		sigma+=tmp.u;
		res=res*tmp.t%pp[i];
		for (j=1;j&lt;=m;j++)
		{
			tmp=calc(w[j],prime[i],pp[i]);
			sigma-=tmp.u;
			res=res*ksm(tmp.t,phi[i]-1,pp[i])%pp[i];
		}
		res=res*ksm(prime[i],sigma,pp[i]);
		ans=(ans+res*e[i])%P2;
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2142</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
using namespace std;
#define LL long long
LL e[21],w[21],phi[21],f[100000],pp[21],prime[21];
LL P,P2,n,m,tt,i,tot,ans,res,sigma,j;
struct ppt{LL u,t;};
LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (;b&gt;0;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
ppt calc(LL n,LL prime,LL pp)
{
	ppt tmp;
	tmp.u=0,tmp.t=1;
	while (n&gt;0)
	{
		tmp.u+=n/prime;
		tmp.t=tmp.t*ksm(f[pp-1],n/pp,pp)%pp;
		tmp.t=tmp.t*f[n%pp]%pp;
		n/=prime;
	}
	return tmp;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;P,&amp;n,&amp;m);
	for (tt=0,i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;w[i]),tt+=w[i];
	w[++m]=n-tt;
	if (m-1&gt;n||tt&gt;n) {printf(&quot;Impossible\n&quot;);return 0;}
	P2=P;
	for (i=2;i&lt;=(LL)sqrt(P);i++)
		if (P%i==0)
		{
			tot++;
			prime[tot]=i;
			pp[tot]=1;//pp[i]=pi^ci
			for (pp[tot]=1;P%i==0;P/=i) pp[tot]*=i;
			phi[tot]=pp[tot]-pp[tot]/i;
			e[tot]=ksm(P2/pp[tot],phi[tot]-1,pp[tot])*P2/pp[tot]%P2;
		}
	if (P&gt;1)
	{
		i=P;
		tot++;
		prime[tot]=i;
		for (pp[tot]=1;P%i==0;P/=i) pp[tot]*=i;
		phi[tot]=pp[tot]-pp[tot]/i;
		e[tot]=ksm(P2/pp[tot],phi[tot]-1,pp[tot])*P2/pp[tot]%P2;
	}
	ans=0;
	for (i=1;i&lt;=tot;i++)
	{
		res=1;
		sigma=0;
		f[0]=1,f[1]=1;
		for (j=2;j&lt;pp[i];j++)
			if (j%prime[i]!=0) f[j]=f[j-1]*j%pp[i];
			else f[j]=f[j-1];
		ppt tmp=calc(n,prime[i],pp[i]);
		sigma+=tmp.u;
		res=res*tmp.t%pp[i];
		for (j=1;j&lt;=m;j++)
		{
			tmp=calc(w[j],prime[i],pp[i]);
			sigma-=tmp.u;
			res=res*ksm(tmp.t,phi[i]-1,pp[i])%pp[i];
		}
		res=res*ksm(prime[i],sigma,pp[i]);
		ans=(ans+res*e[i])%P2;
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2150</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf=99999999;
int aa[3000000][3],o[300000],deep[300000],q[3000000],hao[60][60][2];
int n,m,R,C,i,j,k,tot,S,T,head,tail,num,ans;
char ch;
int min(int a,int b) {return a&lt;b?a:b;}
void add(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void addedge(int p,int q,int v)
{
	add(p,q,v);
	add(q,p,0);
}
void bfs()
{
	head=tail=0;
	memset(deep,0,sizeof(deep[0])*(T+10));
	deep[S]=1;
	q[++tail]=S;
	while (head&lt;tail)
	{
		int x=q[++head];
		int p=o[x];
		while (p)
		{
			int y=aa[p][1];
			if (!deep[y]&amp;&amp;aa[p][2])
			{
				deep[y]=deep[x]+1;
				q[++tail]=y;
			}
			p=aa[p][0];
		}
	}
}
int dfs(int v,int flow)
{
	if (v==T) return flow;
	int res=0,p=o[v];
	while (p)
	{
		int y=aa[p][1];
		if (aa[p][2]&amp;&amp;deep[y]==deep[v]+1)
		{
			int tmp=dfs(y,min(aa[p][2],flow));
			if (tmp==0) deep[y]=inf;
			flow-=tmp;
			aa[p][2]-=tmp;
			aa[p^1][2]+=tmp;
			res+=tmp;
			if (!flow) break;
		}
		p=aa[p][0];
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d%d\n&quot;,&amp;n,&amp;m,&amp;R,&amp;C);
	for (i=1;i&lt;=n;i++,scanf(&quot;\n&quot;))
		for (j=1;j&lt;=m;j++)
		{
			scanf(&quot;%c&quot;,&amp;ch);
			if (ch=='.') hao[i][j][0]=++num,hao[i][j][1]=++num;
		}
	S=++num,T=++num;
	tot=1;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
			if (hao[i][j][0]!=0)
			{
				++ans;
				addedge(S,hao[i][j][0],1);
				addedge(hao[i][j][1],T,1);
				if (i+R&lt;=n&amp;&amp;j&gt;C) addedge(hao[i][j][0],hao[i+R][j-C][1],1);
				if (i+C&lt;=n&amp;&amp;j&gt;R) addedge(hao[i][j][0],hao[i+C][j-R][1],1);
				if (i+R&lt;=n&amp;&amp;j+C&lt;=m) addedge(hao[i][j][0],hao[i+R][j+C][1],1);
				if (i+C&lt;=n&amp;&amp;j+R&lt;=m) addedge(hao[i][j][0],hao[i+C][j+R][1],1);
			}
	bfs();
	while (deep[T])
	{
		ans-=dfs(S,inf);
		bfs();
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2150</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf=99999999;
int aa[3000000][4],o[300000],q[3000000],hao[60][60][2],dist[300000],pre[300000];
int n,m,R,C,i,j,k,tot,S,T,head,tail,num,ans;
char ch;
bool dl[300000];
int min(int a,int b) {return a&lt;b?a:b;}
void add(int p,int q,int v,int cost)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][3]=cost;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void addedge(int p,int q,int v,int cost)
{
	//printf(&quot;addedge:   %d %d %d %d\n&quot;,p,q,v,cost);
	add(p,q,v,cost);
	add(q,p,0,-cost);
}
bool relax(int x,int y,int v)
{
	if (dist[y]&gt;dist[x]+v)
	{
		dist[y]=dist[x]+v;
		return 1;
	}
	return 0;
}
void spfa()
{
	memset(dist,127,sizeof(dist[0])*(T+10));
	head=tail=0;
	memset(dl,0,sizeof(dl[0])*(T+10));
	dist[S]=0;
	dl[S]=1;
	q[++tail]=S;
	while (head&lt;tail)
	{
		int x=q[++head];
		dl[x]=0;
		int p=o[x];
		while (p)
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;relax(x,y,aa[p][3]))
			{
				pre[y]=p;
				if (!dl[y])
				{
					q[++tail]=y;
					dl[y]=1;
				}
			}
			p=aa[p][0];
		}
	}
}
void addcost()
{
	int p=pre[T],flow=inf;
	while (p)
	{
		flow=min(flow,aa[p][2]);
		p=pre[aa[p^1][1]];
	}
	p=pre[T];
	while (p)
	{
		ans+=flow*aa[p][3];
		aa[p][2]-=flow;
		aa[p^1][2]+=flow;
		p=pre[aa[p^1][1]];
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d%d\n&quot;,&amp;n,&amp;m,&amp;R,&amp;C);
	for (i=1;i&lt;=n;i++,scanf(&quot;\n&quot;))
		for (j=1;j&lt;=m;j++)
		{
			scanf(&quot;%c&quot;,&amp;ch);
			if (ch=='.') hao[i][j][0]=++num,hao[i][j][1]=++num;
		}
	S=++num,T=++num;
	tot=1;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
			if (hao[i][j][0]!=0)
			{
				addedge(S,hao[i][j][1],1,0);
				addedge(hao[i][j][0],T,1,0);
				addedge(S,hao[i][j][0],1,1);
				if (i+R&lt;=n&amp;&amp;j&gt;C&amp;&amp;hao[i+R][j-C][0]) addedge(hao[i][j][1],hao[i+R][j-C][0],1,0);
				if (i+C&lt;=n&amp;&amp;j&gt;R&amp;&amp;hao[i+C][j-R][0]) addedge(hao[i][j][1],hao[i+C][j-R][0],1,0);
				if (i+R&lt;=n&amp;&amp;j+C&lt;=m&amp;&amp;hao[i+R][j+C][0]) addedge(hao[i][j][1],hao[i+R][j+C][0],1,0);
				if (i+C&lt;=n&amp;&amp;j+R&lt;=m&amp;&amp;hao[i+C][j+R][0]) addedge(hao[i][j][1],hao[i+C][j+R][0],1,0);
			}
	spfa();
	while (dist[T]&lt;dist[0])
	{
		addcost();
		spfa();
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2152</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int NN=20111;
int num[3],fa[NN],deep[NN],o[NN],aa[NN*2][3],size[NN];
int n,tot=1,ans,TIME;
void calcsize(int v)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||deep[y]&lt;deep[v]) continue;
		fa[y]=v;
		calcsize(y);
		size[v]+=size[y];
	}
}
int findcore(int v)
{
	fa[v]=0;
	calcsize(v);
	for (;;)
	{
		bool flag=false;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (deep[y]&lt;deep[v]) continue;
			if ((size[y]&lt;&lt;1)&gt;size[v])
			{
				size[v]-=size[y];
				size[y]+=size[v];
				v=y;
				flag=true;
				break;
			}
		}
		if (!flag) return v;
	}
}
void dfs1(int v,int now)
{
	int t=3-now;
	if (t==3) t=0;
	ans+=num[t];
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||deep[y]&lt;deep[v]) continue;
		fa[y]=v;
		dfs1(y,(now+aa[p][2])%3);
	}
}
void dfs2(int v,int now)
{
	num[now]++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||deep[y]&lt;deep[v]) continue;
		dfs2(y,(now+aa[p][2])%3);
	}
}
void work(int v)
{
	//printf(&quot;\n------ work %d -----------------------------------------------------------\n&quot;,v);
	num[0]=1,num[1]=num[2]=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]) continue;
		fa[y]=v;
		dfs1(y,aa[p][2]);
		//printf(&quot;%d %d %d\n&quot;,num[0],num[1],num[2]);
		dfs2(y,aa[p][2]);
	}
	//printf(&quot;ans=%d\n&quot;,ans);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]) continue;
		y=findcore(y);
		deep[y]=deep[v]+1;
		work(y);
	}
}
int gcd(int a,int b) {return !b?a:gcd(b,a%b);}
void addedge(int p,int q,int v)
{
	//printf(&quot;add  %d %d %d\n&quot;,p,q,v);
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		z%=3;
		addedge(x,y,z),addedge(y,x,z);
	}
	memset(deep,60,sizeof(deep));
	x=findcore(1);
	deep[x]=1;
	//printf(&quot;x=%d\n&quot;,x);
	work(x);
	x=2*ans+n,y=n*n;
	z=gcd(x,y);
	x/=z,y/=z;
	if (x==0) printf(&quot;0/1\n&quot;);
	else if (x==1&amp;&amp;y==1) printf(&quot;1/1\n&quot;);
	else printf(&quot;%d/%d\n&quot;,x,y);
	return 0;
}<pre><h2>Problem2154</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define mo 20101009
LL f[10000005];
int tes,n,m,cnt;
void shai()
{
	static bool vt[10000005];
	static LL b[10000005];
	static int pr[2000000];
	vt[1]=true;
	f[1]=1;
	int i,j;
	for (i=2;i&lt;=n;i++)
	{
		if (!vt[i])
		{
			pr[++cnt]=i;
			b[i]=i;
			f[i]=1-i;
		}
		for (j=1;j&lt;=cnt;j++)
		{
			int x=i*pr[j];
			if (x&gt;n) break;
			vt[x]=true;
			if (i%pr[j]==0)
			{
				b[x]=b[i]*pr[j];
				if (b[x]==x) f[x]=1-pr[j];
				else f[x]=f[b[x]]*f[x/b[x]]%mo;
				break;
			}
			else
			{
				b[x]=pr[j];
				f[x]=f[b[x]]*f[i]%mo;
			}
		}
	}
	for (i=1;i&lt;=n;i++) f[i]=f[i]*i%mo;
	for (i=2;i&lt;=n;i++)
	{
		f[i]+=f[i-1];
		if (f[i]&gt;=mo) f[i]-=mo;
	}
}
LL calc(LL x,LL y)
{
	LL t1=x*(x+1)/2%mo;
	LL t2=y*(y+1)/2%mo;
	return t1*t2%mo;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	if (n&lt;m) {LL t=n;n=m;m=t;}
	shai();
	LL ans=0;int l,r;
	for (l=1;l&lt;=m;l=r+1)
	{
		r=min(n/(n/l),m/(m/l));
		(ans+=calc(n/l,m/l)*(f[r]-f[l-1]))%=mo;
	}
	if (ans&lt;0) ans+=mo;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem2163</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define inf 999999999
#define NN 11111
#define MM 101111
int o[NN*2],q[NN*2],deep[NN*2],aa[2*(NN*2+MM)][3];
int n,m,tot=1,S,T;
bool bfs()
{
	int head=0,tail=1,x,p,y;
	q[1]=S;
	memset(deep,0,sizeof(deep));
	deep[S]=1;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[T];
}
int dfs(int v,int ff)
{
	if (v==T) return ff;
	int res=0,p,y,tmp;
	for (p=o[v];p;p=aa[p][0])
	{
		y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		tmp=dfs(y,mii(ff,aa[p][2]));
		ff-=tmp;
		aa[p][2]-=tmp;
		aa[p^1][2]+=tmp;
		res+=tmp;
		if (ff==0) break;
	}
	return res;
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v)
{
	addedge(p,q,v);
	addedge(q,p,0);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,ans=0,x,y,w;
	S=n*2+1,T=S+1;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		ans+=x;
		add(i,T,x),add(S,i+n,x);
	}
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;w);
		add(x+n,y,w);
	}
	while (bfs()) ans-=dfs(S,inf);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2165</h2><pre>#include &lt;iostream&gt; 
#include &lt;cstdio&gt; 
#include &lt;cstdlib&gt; 
#include &lt;cstring&gt; 
#include &lt;cmath&gt; 
#include &lt;algorithm&gt; 
using namespace std; 
const int MaxN = 100 + 5; 
typedef long long LL; 
const LL INF = 1e18; 
int T, n, Top; 
LL m, Ans; 
struct Matrix  
{ 
    LL Num[MaxN][MaxN]; 
    void Clear(LL x) { 
        for (int i = 1; i &lt;= n; ++i) { 
            for (int j = 1; j &lt;= n; ++j) { 
                Num[i][j] = x; 
            } 
        } 
    } 
} M[70 + 5], M0, Temp; 
LL gmax(LL a, LL b) { 
    return a &gt; b ? a : b; 
} 
Matrix Mul(Matrix A, Matrix B) { 
    Matrix ret; 
    ret.Clear(-INF); 
    for (int k = 1; k &lt;= n; ++k) { 
        for (int i = 1; i &lt;= n; ++i) { 
            for (int j = 1; j &lt;= n; ++j) { 
                ret.Num[i][j] = gmax(ret.Num[i][j], A.Num[i][k] + B.Num[k][j]); 
                if (ret.Num[i][j] &gt; m) ret.Num[i][j] = m; 
            } 
        } 
    } 
    return ret; 
} 
bool Check(Matrix A) { 
    for (int i = 1; i &lt;= n; ++i)  
        if (A.Num[1][i] &gt;= m) return true; 
    return false; 
} 
int main()  
{ 
    scanf(&quot;%d&quot;, &amp;T); 
    for (int Case = 1; Case &lt;= T; ++Case) { 
        scanf(&quot;%d%lld&quot;, &amp;n, &amp;m); 
        for (int i = 1; i &lt;= n; ++i) { 
            for (int j = 1; j &lt;= n; ++j) { 
                scanf(&quot;%lld&quot;, &amp;M[0].Num[i][j]); 
                if (M[0].Num[i][j] == 0ll) M[0].Num[i][j] = -INF; 
            } 
        } 
        Top = 0; 
        while (true) { 
            ++Top; 
            M[Top] = Mul(M[Top - 1], M[Top - 1]); 
            if (Check(M[Top])) break; 
        } 
        Ans = 0ll; 
        M0.Clear(-INF); 
        for (int i = 1; i &lt;= n; ++i) M0.Num[i][i] = 0; 
        for (int i = Top; i &gt;= 0; --i) { 
            Temp = Mul(M0, M[i]); 
            if (!Check(Temp)) { 
                M0 = Temp; 
                Ans += (1ll &lt;&lt; i); 
            } 
        } 
        printf(&quot;%lld\n&quot;, Ans + 1); 
    } 
    return 0; 
}
<pre><h2>Problem2165</h2><pre>#include &lt;iostream&gt; 
#include &lt;cstdio&gt; 
#include &lt;cstdlib&gt; 
#include &lt;cstring&gt; 
#include &lt;cmath&gt; 
#include &lt;algorithm&gt; 
using namespace std; 
const int MaxN = 100 + 5; 
typedef long long LL; 
const LL INF = 1e18; 
int T, n, Top; 
LL m, Ans; 
struct Matrix  
{ 
    LL Num[MaxN][MaxN]; 
    void Clear(LL x) { 
        for (int i = 1; i &lt;= n; ++i) { 
            for (int j = 1; j &lt;= n; ++j) { 
                Num[i][j] = x; 
            } 
        } 
    } 
} M[70 + 5], M0, Temp; 
LL gmax(LL a, LL b) { 
    return a &gt; b ? a : b; 
} 
Matrix Mul(Matrix A, Matrix B) { 
    Matrix ret; 
    ret.Clear(-INF); 
    for (int k = 1; k &lt;= n; ++k) { 
        for (int i = 1; i &lt;= n; ++i) { 
            for (int j = 1; j &lt;= n; ++j) { 
                ret.Num[i][j] = gmax(ret.Num[i][j], A.Num[i][k] + B.Num[k][j]); 
                if (ret.Num[i][j] &gt; m) ret.Num[i][j] = m; 
            } 
        } 
    } 
    return ret; 
} 
bool Check(Matrix A) { 
    for (int i = 1; i &lt;= n; ++i)  
        if (A.Num[1][i] &gt;= m) return true; 
    return false; 
} 
int main()  
{ 
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d&quot;, &amp;T); 
    for (int Case = 1; Case &lt;= T; ++Case) { 
        scanf(&quot;%d%lld&quot;, &amp;n, &amp;m); 
        for (int i = 1; i &lt;= n; ++i) { 
            for (int j = 1; j &lt;= n; ++j) { 
                scanf(&quot;%lld&quot;, &amp;M[0].Num[i][j]); 
                if (M[0].Num[i][j] == 0ll) M[0].Num[i][j] = -INF; 
            } 
        } 
        Top = 0; 
        while (true) { 
            ++Top; 
            M[Top] = Mul(M[Top - 1], M[Top - 1]); 
            if (Check(M[Top])) break; 
        } 
        Ans = 0ll; 
        M0.Clear(-INF); 
        for (int i = 1; i &lt;= n; ++i) M0.Num[i][i] = 0; 
        for (int i = Top; i &gt;= 0; --i) { 
            Temp = Mul(M0, M[i]); 
            if (!Check(Temp)) { 
                M0 = Temp; 
                Ans += (1ll &lt;&lt; i); 
            } 
        } 
        printf(&quot;%lld\n&quot;, Ans + 1); 
    } 
    return 0; 
}
<pre><h2>Problem2165</h2><pre>#include &lt;iostream&gt; 
#include &lt;cstdio&gt; 
#include &lt;cstdlib&gt; 
#include &lt;cstring&gt; 
#include &lt;cmath&gt; 
#include &lt;algorithm&gt; 
  
using namespace std; 
  
const int MaxN = 100 + 5; 
  
typedef long long LL; 
  
const LL INF = (LL)1e18; 
  
int T, n, Top; 
  
LL m, Ans; 
  
struct Matrix  
{ 
    LL Num[MaxN][MaxN]; 
    void Clear(LL x) { 
        for (int i = 1; i &lt;= n; ++i) { 
            for (int j = 1; j &lt;= n; ++j) { 
                Num[i][j] = x; 
            } 
        } 
    } 
} M[70 + 5], M0, Temp; 
  
LL gmax(LL a, LL b) { 
    return a &gt; b ? a : b; 
} 
  
Matrix Mul(Matrix A, Matrix B) { 
    Matrix ret; 
    ret.Clear(-INF); 
    for (int k = 1; k &lt;= n; ++k) { 
        for (int i = 1; i &lt;= n; ++i) { 
            for (int j = 1; j &lt;= n; ++j) { 
                ret.Num[i][j] = gmax(ret.Num[i][j], A.Num[i][k] + B.Num[k][j]); 
                if (ret.Num[i][j] &gt; m) ret.Num[i][j] = m; 
            } 
        } 
    } 
    return ret; 
} 
  
bool Check(Matrix A) { 
    for (int i = 1; i &lt;= n; ++i)  
        if (A.Num[1][i] &gt;= m) return true; 
    return false; 
} 
int main()  
{ 
    scanf(&quot;%d&quot;, &amp;T); 
    for (int Case = 1; Case &lt;= T; ++Case) { 
        scanf(&quot;%d%lld&quot;, &amp;n, &amp;m); 
        for (int i = 1; i &lt;= n; ++i) { 
            for (int j = 1; j &lt;= n; ++j) { 
                scanf(&quot;%lld&quot;, &amp;M[0].Num[i][j]); 
                if (M[0].Num[i][j] == 0ll) M[0].Num[i][j] = -INF; 
            } 
        } 
        Top = 0; 
        while (true) { 
            ++Top; 
            M[Top] = Mul(M[Top - 1], M[Top - 1]); 
            if (Check(M[Top])) break; 
        } 
        Ans = 0ll; 
        M0.Clear(-INF); 
        for (int i = 1; i &lt;= n; ++i) M0.Num[i][i] = 0; 
        for (int i = Top; i &gt;= 0; --i) { 
            Temp = Mul(M0, M[i]); 
            if (!Check(Temp)) { 
                M0 = Temp; 
                Ans += (1ll &lt;&lt; i); 
            } 
        } 
        printf(&quot;%lld\n&quot;, Ans + 1); 
    } 
    return 0; 
}
<pre><h2>Problem2165</h2><pre>#include &lt;iostream&gt; 
#include &lt;cstdio&gt; 
#include &lt;cstdlib&gt; 
#include &lt;cstring&gt; 
#include &lt;cmath&gt; 
#include &lt;algorithm&gt; 
  
using namespace std; 
  
const int MaxN = 100 + 5; 
  
typedef long long LL; 
  
const LL INF = (LL)1e18; 
  
int T, n, Top; 
  
LL m, Ans; 
  
struct Matrix  
{ 
    LL Num[MaxN][MaxN]; 
    void Clear(LL x) { 
        for (int i = 1; i &lt;= n; ++i) { 
            for (int j = 1; j &lt;= n; ++j) { 
                Num[i][j] = x; 
            } 
        } 
    } 
} M[70 + 5], M0, Temp; 
  
LL gmax(LL a, LL b) { 
    return a &gt; b ? a : b; 
} 
  
Matrix Mul(Matrix A, Matrix B) { 
    Matrix ret; 
    ret.Clear(-INF); 
    for (int k = 1; k &lt;= n; ++k) { 
        for (int i = 1; i &lt;= n; ++i) { 
            for (int j = 1; j &lt;= n; ++j) { 
                ret.Num[i][j] = gmax(ret.Num[i][j], A.Num[i][k] + B.Num[k][j]); 
                if (ret.Num[i][j] &gt; m) ret.Num[i][j] = m; 
            } 
        } 
    } 
    return ret; 
} 
  
bool Check(Matrix A) { 
    for (int i = 1; i &lt;= n; ++i)  
        if (A.Num[1][i] &gt;= m) return true; 
    return false; 
} 
int main()  
{ 
    scanf(&quot;%d&quot;, &amp;T); 
    for (int Case = 1; Case &lt;= T; ++Case) { 
        scanf(&quot;%d%lld&quot;, &amp;n, &amp;m); 
        for (int i = 1; i &lt;= n; ++i) { 
            for (int j = 1; j &lt;= n; ++j) { 
                scanf(&quot;%lld&quot;, &amp;M[0].Num[i][j]); 
                if (M[0].Num[i][j] == 0ll) M[0].Num[i][j] = -INF; 
            } 
        } 
        Top = 0; 
        while (true) { 
			if (Check(M[Top])) break; 
            ++Top; 
            M[Top] = Mul(M[Top - 1], M[Top - 1]); 
        } 
        Ans = 0ll; 
        M0.Clear(-INF); 
        for (int i = 1; i &lt;= n; ++i) M0.Num[i][i] = 0; 
        for (int i = Top; i &gt;= 0; --i) { 
            Temp = Mul(M0, M[i]); 
            if (!Check(Temp)) { 
                M0 = Temp; 
                Ans += (1ll &lt;&lt; i); 
            } 
        } 
        printf(&quot;%lld\n&quot;, Ans + 1); 
    } 
    return 0; 
}
<pre><h2>Problem2165</h2><pre>#include &lt;iostream&gt; 
#include &lt;cstdio&gt; 
#include &lt;cstdlib&gt; 
#include &lt;cstring&gt; 
#include &lt;cmath&gt; 
#include &lt;algorithm&gt; 
  
using namespace std; 
  
const int MaxN = 100 + 5; 
  
typedef long long LL; 
  
const LL INF = (LL)1e18; 
  
int T, n, Top; 
  
LL m, Ans; 
  
struct Matrix  
{ 
    LL Num[MaxN][MaxN]; 
    void Clear(LL x) { 
        for (int i = 1; i &lt;= n; ++i) { 
            for (int j = 1; j &lt;= n; ++j) { 
                Num[i][j] = x; 
            } 
        } 
    } 
} M[70 + 5], M0, Temp; 
  
LL gmax(LL a, LL b) { 
    return a &gt; b ? a : b; 
} 
  
Matrix Mul(Matrix A, Matrix B) { 
    Matrix ret; 
    ret.Clear(-INF); 
    for (int k = 1; k &lt;= n; ++k) { 
        for (int i = 1; i &lt;= n; ++i) { 
            for (int j = 1; j &lt;= n; ++j) { 
                ret.Num[i][j] = gmax(ret.Num[i][j], A.Num[i][k] + B.Num[k][j]); 
                //if (ret.Num[i][j] &gt; m) ret.Num[i][j] = m; 
            } 
        } 
    } 
    return ret; 
} 
  
bool Check(Matrix A) { 
    for (int i = 1; i &lt;= n; ++i)  
        if (A.Num[1][i] &gt;= m) return true; 
    return false; 
} 
int main()  
{ 
    scanf(&quot;%d&quot;, &amp;T); 
    for (int Case = 1; Case &lt;= T; ++Case) { 
        scanf(&quot;%d%lld&quot;, &amp;n, &amp;m); 
        for (int i = 1; i &lt;= n; ++i) { 
            for (int j = 1; j &lt;= n; ++j) { 
                scanf(&quot;%lld&quot;, &amp;M[0].Num[i][j]); 
                if (M[0].Num[i][j] == 0ll) M[0].Num[i][j] = -INF; 
            } 
        } 
        Top = 0; 
        while (true) { 
			if (Check(M[Top])) break; 
            ++Top; 
            M[Top] = Mul(M[Top - 1], M[Top - 1]); 
        } 
        Ans = 0ll; 
        M0.Clear(-INF); 
        for (int i = 1; i &lt;= n; ++i) M0.Num[i][i] = 0; 
        for (int i = Top; i &gt;= 0; --i) { 
            Temp = Mul(M0, M[i]); 
            if (!Check(Temp)) { 
                M0 = Temp; 
                Ans += (1ll &lt;&lt; i); 
            } 
        } 
        printf(&quot;%lld\n&quot;, Ans + 1); 
    } 
    return 0; 
}
<pre><h2>Problem2165</h2><pre>#include &lt;iostream&gt; 
#include &lt;cstdio&gt; 
#include &lt;cstdlib&gt; 
#include &lt;cstring&gt; 
#include &lt;cmath&gt; 
#include &lt;algorithm&gt; 
  
using namespace std; 
  
const int MaxN = 100 + 5; 
  
typedef long long LL; 
  
const LL INF = (LL)1e18; 
  
int T, n, Top; 
  
LL m, Ans; 
  
struct Matrix  
{ 
    LL Num[MaxN][MaxN]; 
    void Clear(LL x) { 
        for (int i = 1; i &lt;= n; ++i) { 
            for (int j = 1; j &lt;= n; ++j) { 
                Num[i][j] = x; 
            } 
        } 
    } 
} M[70 + 5], M0, Temp; 
  
LL gmax(LL a, LL b) { 
    return a &gt; b ? a : b; 
} 
  
Matrix Mul(Matrix A, Matrix B) { 
    Matrix ret; 
    ret.Clear(-INF); 
    for (int i=1;i&lt;=n;i++) ret.Num[i][i]=0;
    for (int k = 1; k &lt;= n; ++k) { 
        for (int i = 1; i &lt;= n; ++i) { 
            for (int j = 1; j &lt;= n; ++j) { 
                ret.Num[i][j] = gmax(ret.Num[i][j], A.Num[i][k] + B.Num[k][j]); 
                //if (ret.Num[i][j] &gt; m) ret.Num[i][j] = m; 
            } 
        } 
    } 
    return ret; 
} 
  
bool Check(Matrix A) { 
    for (int i = 1; i &lt;= n; ++i)  
        if (A.Num[1][i] &gt;= m) return true; 
    return false; 
} 
int main()  
{ 
    scanf(&quot;%d&quot;, &amp;T); 
    for (int Case = 1; Case &lt;= T; ++Case) { 
        scanf(&quot;%d%lld&quot;, &amp;n, &amp;m); 
        for (int i = 1; i &lt;= n; ++i) { 
            for (int j = 1; j &lt;= n; ++j) { 
                scanf(&quot;%lld&quot;, &amp;M[0].Num[i][j]); 
                if (M[0].Num[i][j] == 0ll) M[0].Num[i][j] = -INF; 
            } 
        } 
        Top = 0; 
        while (true) { 
			if (Check(M[Top])) break; 
            ++Top; 
            M[Top] = Mul(M[Top - 1], M[Top - 1]); 
        } 
        Ans = 0ll; 
        M0.Clear(-INF); 
        for (int i = 1; i &lt;= n; ++i) M0.Num[i][i] = 0; 
        for (int i = Top; i &gt;= 0; --i) { 
            Temp = Mul(M0, M[i]); 
            if (!Check(Temp)) { 
                M0 = Temp; 
                Ans += (1ll &lt;&lt; i); 
            } 
        } 
        printf(&quot;%lld\n&quot;, Ans + 1); 
    } 
    return 0; 
}
<pre><h2>Problem2165</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define LL long long
const LL inf=(LL)1e18;
int n,i,j,tc,now;
LL ans,x,m;
struct matrix{LL w[110][110];matrix(){memset(w,0,sizeof(w));}} tt,temp,a[110];
LL max(LL a,LL b) {return a&gt;b?a:b;}
matrix mul(matrix A,matrix B)
{
	matrix C;
	int i,j,k;
	for (i=1;i&lt;=n;i++)
	{
		for (j=1;j&lt;=n;j++) C.w[i][j]=-inf;
		C.w[i][i]=0;
	}
	for (k=1;k&lt;=n;k++)
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=n;j++) C.w[i][j]=max(C.w[i][j],A.w[i][k]+B.w[k][j]);
	return C;
}
bool check(matrix a)
{
	for (int i=1;i&lt;=n;i++)
		if (a.w[1][i]&gt;=m) return 1;
	return 0;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;tc);
	for (;tc;tc--)
	{
		scanf(&quot;%d%lld&quot;,&amp;n,&amp;m);
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=n;j++)
			{
				scanf(&quot;%lld&quot;,&amp;x);
				if (x==0ll) a[0].w[i][j]=-inf;
				else a[0].w[i][j]=x;
			}
		now=0;
		while (!check(a[now]))
		{
			++now;
			a[now]=mul(a[now-1],a[now-1]);
		}
		ans=0ll;
		for (i=1;i&lt;=n;i++)
		{
			for (j=1;j&lt;=n;j++) tt.w[i][j]=-inf;
			tt.w[i][i]=0ll;
		}
		for (i=now;i&gt;=0;i--)
		{
			temp=mul(tt,a[i]);
			if (!check(temp))
			{
				ans+=(1ll&lt;&lt;i);
				tt=temp;
			}
		}
		printf(&quot;%lld\n&quot;,ans+1);
	}
	return 0;
}
<pre><h2>Problem2165</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define LL long long
const LL inf=(LL)1e18;
int n,i,j,tc,now;
LL ans,x,m;
struct matrix{LL w[110][110];matrix(){memset(w,0,sizeof(w));}} tt,temp,a[110];
LL max(LL a,LL b) {return a&gt;b?a:b;}
matrix mul(matrix A,matrix B)
{
	matrix C;
	int i,j,k;
	for (i=1;i&lt;=n;i++)
	{
		for (j=1;j&lt;=n;j++) C.w[i][j]=-inf;
		C.w[i][i]=0;
	}
	for (k=1;k&lt;=n;k++)
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=n;j++) C.w[i][j]=max(C.w[i][j],A.w[i][k]+B.w[k][j]);
	return C;
}
bool check(matrix a)
{
	for (int i=1;i&lt;=n;i++)
		if (a.w[1][i]&gt;=m) return 1;
	return 0;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;tc);
	for (;tc;tc--)
	{
		scanf(&quot;%d%lld&quot;,&amp;n,&amp;m);
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=n;j++)
			{
				scanf(&quot;%lld&quot;,&amp;x);
				if (x==0) a[0].w[i][j]=-inf;
				else a[0].w[i][j]=x;
			}
		now=0;
		while (!check(a[now]))
		{
			++now;
			a[now]=mul(a[now-1],a[now-1]);
		}
		ans=0;
		for (i=1;i&lt;=n;i++)
		{
			for (j=1;j&lt;=n;j++) tt.w[i][j]=-inf;
			tt.w[i][i]=0;
		}
		for (i=now;i&gt;=0;i--)
		{
			temp=mul(tt,a[i]);
			if (!check(temp))
			{
				ans+=(1ll&lt;&lt;i);
				tt=temp;
			}
		}
		printf(&quot;%lld\n&quot;,ans+1);
	}
	return 0;
}
<pre><h2>Problem2165</h2><pre>#include &lt;cstdio&gt;  
#include &lt;cstring&gt;  
#include &lt;algorithm&gt;  
#define inf (1ll&lt;&lt;62)  
#define FOR(i,j,k) for(int i=j;i&lt;=k;i++)  
using namespace std;  
typedef long long ll;  
int n; ll m;  
struct Matrix {  
    ll v[101][101];  
    Matrix() { memset(v, 0, sizeof v); }  
    ll *operator [](int x) { return v[x]; }  
    friend Matrix operator *(Matrix a, Matrix b) {  
        Matrix c;  
        FOR(i,1,n) FOR(j,1,n) {  
            c[i][j] = -inf;  
            FOR(k,1,n) c[i][j] = max(c[i][j], a[i][k] + b[k][j]);  
            if (c[i][j] &gt; m) c[i][j] = m;  
        }  
        return c;  
    }  
} f[100];  
bool check(Matrix x) {  
    FOR(i,1,n) if (x[1][i] &gt;= m) return true;  
    return false;  
}  
int main() {  
//	freopen(&quot;2165.in&quot;,&quot;r&quot;,stdin); 
    int kase, cnt;  
    scanf(&quot;%d&quot;, &amp;kase);  
    while (kase--) {  
        scanf(&quot;%d%lld&quot;, &amp;n, &amp;m);  
        FOR(i,1,n) FOR(j,1,n) {  
            scanf(&quot;%lld&quot;, &amp;f[0][i][j]);  
            if (f[0][i][j] == 0) f[0][i][j] = -inf;  
        }  
        for (cnt = 0; ; ) {  
            f[cnt + 1] = f[cnt] * f[cnt];  
            if (check(f[++cnt])) break;  
        }  
        Matrix t = f[0];  
        ll ans = 1;  
        for (int i = cnt; i &gt;= 0; i--) {  
            Matrix x = t * f[i];  
            if (!check(x)) {  
                t = x;  
                ans += 1ll &lt;&lt; i;  
            }  
        }  
        printf(&quot;%lld\n&quot;, ans + 1);  
    }  
    return 0;  
}  <pre><h2>Problem2176</h2><pre>#include&lt;cstdio&gt;
using namespace std;
unsigned char s[20001111];
int i,j,k,n;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d\n%s&quot;,&amp;n,s+1);
	for (i=1;i&lt;n;i++) s[i+n]=s[i];
	i=1,j=2;
	while (i&lt;=n&amp;&amp;j&lt;=n)
	{
		k=0;
		while (s[i+k]==s[j+k]&amp;&amp;k&lt;n) k++;
		if (k==n) break;
		if (s[i+k]&lt;s[j+k]) j+=k+1;
		else i+=k+1;
		if (i==j) j++;
	}
	k=i;
	for (i=1;i&lt;=n;i++) printf(&quot;%c&quot;,s[k+i-1]);
	return 0;
}<pre><h2>Problem2176</h2><pre>#include&lt;cstdio&gt;
using namespace std;
unsigned char s[20001111];
int n,i,j,k;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d\n&quot;,&amp;n);
	for (i=1;i&lt;=n;i++) s[i]=getchar();
	for (i=1;i&lt;n;i++) s[i+n]=s[i];
	i=1,j=2;
	while (i&lt;=n&amp;&amp;j&lt;=n)
	{
		k=0;
		while (s[i+k]==s[j+k]&amp;&amp;k&lt;n) k++;
		if (k==n) break;
		if (s[i+k]&lt;s[j+k]) j+=k+1;
		else i+=k+1;
		if (i==j) j++;
	}
	int t=i;
	for (i=1;i&lt;=n;i++) printf(&quot;%c&quot;,s[t++]);
	return 0;
}<pre><h2>Problem2176</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
unsigned char s[20001111];
int n;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d\n%s&quot;,&amp;n,s+1);
	int i,j;
	for (i=1;i&lt;n;i++) s[i+n]=s[i];
	i=1,j=2;
	while (i&lt;=n&amp;&amp;j&lt;=n)
	{
		int k=0;
		while (k&lt;n&amp;&amp;s[i+k]==s[j+k]) k++;
		if (k==n) break;
		if (s[i+k]&gt;s[j+k]) i+=k+1;
		else j+=k+1;
		if (i==j) j++;
	}
	int t=i;
	for (i=1;i&lt;=n;i++) printf(&quot;%c&quot;,s[t++]);
	return 0;
}<pre><h2>Problem2178</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define sqr(x) ((x)*(x))
#define inf 999999999
typedef double DD;
const DD eps=1e-13;
const int NN=10005;
int n;
DD R[NN];
bool cover[NN];
struct point
{
	DD x,y;
	void in()
	{
		double xx,yy;
		scanf(&quot;%lf%lf&quot;,&amp;xx,&amp;yy);
		x=xx,y=yy;
	}
	point(DD a=0,DD b=0) {x=a;y=b;}
	DD len() {return sqrt(sqr(x)+sqr(y));}
	friend point operator -(point a,point b) {a.x-=b.x;a.y-=b.y;return a;}
} O[NN];
struct ppt
{
	DD w;
	bool kind;
	friend bool operator &lt;(ppt a,ppt b) {return a.w&lt;b.w;}
} c[NN*2];
bool pan(int i,DD x)
{
	return x-(O[i].x-R[i])&gt;-eps&amp;&amp;O[i].x+R[i]-x&gt;-eps;
}
point getjd(int i,DD x)
{
	DD d=fabs(O[i].x-x);
	DD l=sqrt(sqr(R[i])-sqr(d));
	return point(O[i].y-l,O[i].y+l);
}
DD f(DD xx)
{
	int i,tot=0;
	for (i=1;i&lt;=n;i++)
		if (pan(i,xx))
		{
			point tmp=getjd(i,xx);
			tot++;c[tot].w=tmp.x;c[tot].kind=true;
			tot++;c[tot].w=tmp.y;c[tot].kind=false;
		}
	sort(c+1,c+tot+1);
	DD res=0;
	int cnt=0;
	for (i=1;i&lt;=tot;i++)
		if (c[i].kind)
		{
			cnt++;
			if (cnt==1) res-=c[i].w;
		}
		else
		{
			cnt--;
			if (cnt==0) res+=c[i].w;
		}
	return res;
}
DD simpson(DD len,DD fl,DD fr,DD fmid)
{
	return len*(fl+4*fmid+fr)/6;
}
DD calcarea(DD l,DD r,DD mid,DD fl,DD fr,DD fmid,DD S)
{
	//printf(&quot;%.3f %.3f\n&quot;,l,r);
	DD lm=(l+mid)*0.5,rm=(mid+r)*0.5;
	DD flm=f(lm),frm=f(rm);
	DD Sl=simpson(mid-l,fl,fmid,flm);
	DD Sr=simpson(r-mid,fmid,fr,frm);
	if (fabs(Sl+Sr-S)&lt;eps) return S;
	return calcarea(l,mid,lm,fl,fmid,flm,Sl)+calcarea(mid,r,rm,fmid,fr,frm,Sr);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	DD l=inf,r=-inf;
	for (int i=1;i&lt;=n;i++)
	{
		O[i].in();
		double xx;scanf(&quot;%lf&quot;,&amp;xx);R[i]=xx;
		if (O[i].x+R[i]-r&gt;eps) r=O[i].x+R[i];
		if (O[i].x-R[i]-l&lt;-eps) l=O[i].x-R[i];
	}
	for (int i=1;i&lt;n;i++) if (!cover[i])
		for (int j=i+1;j&lt;=n;j++) if (!cover[j])
			if ((O[i]-O[j]).len()-(R[j]-R[i])&lt;eps) cover[i]=true;
	int t=0;
	for (int i=1;i&lt;=n;i++)
		if (!cover[i]) t++,O[t]=O[i],R[t]=R[i];
	n=t;
	DD mid=(l+r)*0.5,fl=f(l),fr=f(r),fmid=f(mid);
	printf(&quot;%.3f\n&quot;,(double)calcarea(l,r,mid,fl,fr,fmid,simpson(r-l,fl,fr,fmid)));
	return 0;
}<pre><h2>Problem2178</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define sqr(x) ((x)*(x))
#define inf 999999999
typedef double DD;
const DD eps=1e-13;
const int NN=10005;
int n;
DD R[NN];
bool cover[NN];
struct point
{
	DD x,y;
	void in()
	{
		double xx,yy;
		scanf(&quot;%lf%lf&quot;,&amp;xx,&amp;yy);
		x=xx,y=yy;
	}
	point(DD a=0,DD b=0) {x=a;y=b;}
} O[NN];
struct ppt
{
	DD w;
	bool kind;
	friend bool operator &lt;(ppt a,ppt b) {return a.w&lt;b.w;}
} c[NN*2];
DD dist(point a,point b) {return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));}
bool pan(int i,DD x)
{
	return x-(O[i].x-R[i])&gt;-eps&amp;&amp;O[i].x+R[i]-x&gt;-eps;
}
point getjd(int i,DD x)
{
	DD d=fabs(O[i].x-x);
	DD l=sqrt(sqr(R[i])-sqr(d));
	return point(O[i].y-l,O[i].y+l);
}
DD f(DD xx)
{
	int i,tot=0;
	for (i=1;i&lt;=n;i++)
		if (pan(i,xx))
		{
			point tmp=getjd(i,xx);
			tot++;c[tot].w=tmp.x;c[tot].kind=true;
			tot++;c[tot].w=tmp.y;c[tot].kind=false;
		}
	sort(c+1,c+tot+1);
	DD res=0;
	int cnt=0;
	for (i=1;i&lt;=tot;i++)
		if (c[i].kind)
		{
			cnt++;
			if (cnt==1) res-=c[i].w;
		}
		else
		{
			cnt--;
			if (cnt==0) res+=c[i].w;
		}
	return res;
}
DD simpson(DD len,DD fl,DD fr,DD fmid)
{
	return len*(fl+4*fmid+fr)/6;
}
DD calcarea(DD l,DD r,DD mid,DD fl,DD fr,DD fmid,DD S)
{
	//printf(&quot;%.3f %.3f\n&quot;,l,r);
	DD lm=(l+mid)*0.5,rm=(mid+r)*0.5;
	DD flm=f(lm),frm=f(rm);
	DD Sl=simpson(mid-l,fl,fmid,flm);
	DD Sr=simpson(r-mid,fmid,fr,frm);
	if (fabs(Sl+Sr-S)&lt;eps) return S;
	return calcarea(l,mid,lm,fl,fmid,flm,Sl)+calcarea(mid,r,rm,fmid,fr,frm,Sr);
}
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	DD l=inf,r=-inf;
	for (int i=1;i&lt;=n;i++)
	{
		O[i].in();
		double xx;scanf(&quot;%lf&quot;,&amp;xx);R[i]=xx;
		if (O[i].x+R[i]-r&gt;eps) r=O[i].x+R[i];
		if (O[i].x-R[i]-l&lt;-eps) l=O[i].x-R[i];
	}
	for (int i=1;i&lt;=n;i++) if (!cover[i])
		for (int j=1;j&lt;=n;j++) if (i!=j&amp;&amp;!cover[j])
			if (dist(O[i],O[j])&lt;=(R[j]-R[i])) {cover[i]=true;break;}
	int t=0;
	for (int i=1;i&lt;=n;i++)
		if (!cover[i]) t++,O[t]=O[i],R[t]=R[i];
	n=t;
	//printf(&quot;n=%d\n&quot;,n);
	DD mid=(l+r)*0.5,fl=f(l),fr=f(r),fmid=f(mid);
	printf(&quot;%.3f\n&quot;,(double)calcarea(l,r,mid,fl,fr,fmid,simpson(r-l,fl,fr,fmid)));
	return 0;
}<pre><h2>Problem2179</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
const DD pai=3.14159265358979;
const int NN=2400005;
int n,N,L,rev[NN],ans[NN];
char s[NN];
struct cp
{
	DD r,i;
	cp(DD a=0,DD b=0) {r=a,i=b;}
	friend cp operator +(cp a,cp b) {a.r+=b.r;a.i+=b.i;return a;}
	friend cp operator -(cp a,cp b) {a.r-=b.r;a.i-=b.i;return a;}
	friend cp operator *(cp a,cp b) {return cp(a.r*b.r-a.i*b.i,a.r*b.i+a.i*b.r);}
} a[NN],b[NN],c[NN];
void fft(cp *a,int f)
{
	int i,j,k,p;
	for (i=0;i&lt;N;i++)
		if (i&lt;rev[i]) swap(a[i],a[rev[i]]);
	for (i=1;i&lt;N;i&lt;&lt;=1)
	{
		cp wn(cos(pai/i),f*sin(pai/i));
		for (p=i&lt;&lt;1,j=0;j&lt;N;j+=p)
		{
			cp w(1,0);
			for (k=0;k&lt;i;k++)
			{
				cp x=a[j+k],y=w*a[j+k+i];
				a[j+k]=x+y,a[j+k+i]=x-y;
				w=w*wn;
			}
		}
	}
	if (f==-1) for (i=0;i&lt;N;i++) a[i].r/=N;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d\n&quot;,&amp;n);
	scanf(&quot;%s\n&quot;,s+1);
	int i;
	for (i=1;i&lt;=n;i++) a[n-i].r=s[i]-'0';
	scanf(&quot;%s\n&quot;,s+1);
	for (i=1;i&lt;=n;i++) b[n-i].r=s[i]-'0';
	n=n+n-1;
	for (N=1;N&lt;n;N&lt;&lt;=1) L++;
	for (i=0;i&lt;N;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(L-1));
	fft(a,1);
	fft(b,1);
	for (i=0;i&lt;N;i++) c[i]=a[i]*b[i];
	fft(c,-1);
	for (i=0;i&lt;n;i++) ans[i]=(int)(c[i].r+0.5);
	for (i=0;i&lt;n-1;i++)
		if (ans[i]&gt;9) ans[i+1]+=ans[i]/10,ans[i]%=10;
	while (n&gt;1&amp;&amp;ans[n-1]==0) n--;
	for (i=n-1;i&gt;=0;i--) printf(&quot;%d&quot;,ans[i]);
	printf(&quot;\n&quot;);
	return 0;
}<pre><h2>Problem2179</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
const DD pai=3.14159265358979;
const int NN=240005;
int n,N,L,rev[NN],ans[NN];
char s[NN];
struct cp
{
	DD r,i;
	cp(DD a=0,DD b=0) {r=a,i=b;}
	friend cp operator +(cp a,cp b) {a.r+=b.r;a.i+=b.i;return a;}
	friend cp operator -(cp a,cp b) {a.r-=b.r;a.i-=b.i;return a;}
	friend cp operator *(cp a,cp b) {return cp(a.r*b.r-a.i*b.i,a.r*b.i+a.i*b.r);}
} a[NN],b[NN],c[NN];
void fft(cp *a,int f)
{
	int i,j,k,p;
	for (i=0;i&lt;N;i++)
		if (i&lt;rev[i]) swap(a[i],a[rev[i]]);
	for (i=1;i&lt;N;i&lt;&lt;=1)
	{
		cp wn(cos(pai/i),f*sin(pai/i));
		for (p=i&lt;&lt;1,j=0;j&lt;N;j+=p)
		{
			cp w(1,0);
			for (k=0;k&lt;i;k++)
			{
				cp x=a[j+k],y=w*a[j+k+i];
				a[j+k]=x+y,a[j+k+i]=x-y;
				w=w*wn;
			}
		}
	}
	if (f==-1) for (i=0;i&lt;N;i++) a[i].r/=N;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d\n&quot;,&amp;n);
	scanf(&quot;%s\n&quot;,s+1);
	int i;
	for (i=1;i&lt;=n;i++) a[n-i].r=s[i]-'0';
	scanf(&quot;%s\n&quot;,s+1);
	for (i=1;i&lt;=n;i++) b[n-i].r=s[i]-'0';
	n=n+n-1;
	for (N=1;N&lt;n;N&lt;&lt;=1) L++;
	for (i=0;i&lt;N;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(L-1));
	fft(a,1);
	fft(b,1);
	for (i=0;i&lt;N;i++) c[i]=a[i]*b[i];
	fft(c,-1);
	for (i=0;i&lt;n;i++) ans[i]=(int)(c[i].r+0.5);
	for (i=0;i&lt;n-1;i++)
		if (ans[i]&gt;9) ans[i+1]+=ans[i]/10,ans[i]%=10;
	while (n&gt;1&amp;&amp;ans[n-1]==0) n--;
	for (i=n-1;i&gt;=0;i--) printf(&quot;%d&quot;,ans[i]);
	printf(&quot;\n&quot;);
	return 0;
}<pre><h2>Problem2179</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
const DD pai=3.14159265358979;
const int NN=240005;
int n,N,L,rev[NN],ans[NN];
char s[NN];
struct cp
{
	DD r,i;
	cp(DD a=0,DD b=0) {r=a,i=b;}
	friend cp operator +(cp a,cp b) {a.r+=b.r;a.i+=b.i;return a;}
	friend cp operator -(cp a,cp b) {a.r-=b.r;a.i-=b.i;return a;}
	friend cp operator *(cp a,cp b) {return cp(a.r*b.r-a.i*b.i,a.r*b.i+a.i*b.r);}
} a[NN],b[NN],c[NN];
void fft(cp *a,int f)
{
	int i,j,k,p;
	for (i=0;i&lt;N;i++)
		if (i&lt;rev[i]) swap(a[i],a[rev[i]]);
	for (i=1;i&lt;N;i&lt;&lt;=1)
	{
		cp wn(cos(pai/i),f*sin(pai/i));
		for (p=i&lt;&lt;1,j=0;j&lt;N;j+=p)
		{
			cp w(1,0);
			for (k=0;k&lt;i;k++,w=w*wn)
			{
				cp x=a[j+k],y=w*a[j+k+i];
				a[j+k]=x+y,a[j+k+i]=x-y;
			}
		}
	}
	if (f==-1) for (i=0;i&lt;N;i++) a[i].r/=N;
}
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d\n&quot;,&amp;n);
	scanf(&quot;%s\n&quot;,s+1);
	int i;
	for (i=1;i&lt;=n;i++) a[n-i].r=s[i]-'0';
	scanf(&quot;%s\n&quot;,s+1);
	for (i=1;i&lt;=n;i++) b[n-i].r=s[i]-'0';
	n=n+n-1;
	for (N=1;N&lt;n;N&lt;&lt;=1) L++;
	for (i=0;i&lt;N;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(L-1));
	fft(a,1);
	fft(b,1);
	for (i=0;i&lt;N;i++) c[i]=a[i]*b[i];
	fft(c,-1);
	for (i=0;i&lt;n;i++) ans[i]=(int)(c[i].r+0.5);
	for (i=0;i&lt;n-1;i++)
		if (ans[i]&gt;9) ans[i+1]+=ans[i]/10,ans[i]%=10;
	while (n&gt;1&amp;&amp;ans[n-1]==0) n--;
	for (i=n-1;i&gt;=0;i--) printf(&quot;%d&quot;,ans[i]);
	printf(&quot;\n&quot;);
	return 0;
}<pre><h2>Problem2179</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;complex&gt;
#define pi acos(-1.0)
#define NN 200010
using namespace std;
typedef complex&lt;double&gt; E;
int n,m,l1,l2,L;
char s[NN];
E a[NN],b[NN];
int ans[NN],R[NN];


void FFT(E *a,int n,int on){
	for (int i=0;i&lt;=n;i++)
		if (i&lt;R[i])swap(a[i],a[R[i]]);
	for (int l=1;l&lt;n;l&lt;&lt;=1){
		E wn(cos(pi/l),on*sin(pi/l));
		for (int p=l&lt;&lt;1,j=0;j&lt;n;j+=p){
			E w(1,0);
			for (int i=0;i&lt;l;i++){
				E u=a[i+j],v=w*a[i+j+l];
				a[i+j]=u+v;
				a[i+j+l]=u-v;				
				w=w*wn;
			}
		}
	}
	if (on&lt;0)
		for (int i=0;i&lt;=n;i++)
			a[i]/=n;
}

int main(){
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d\n&quot;,&amp;n);
	n--;
	scanf(&quot;%s&quot;,s);
	for (int i=0;i&lt;=n;i++)	
		a[i]=s[n-i]-'0';
	scanf(&quot;%s&quot;,s);
	for (int i=0;i&lt;=n;i++)
		b[i]=s[n-i]-'0';
	n&lt;&lt;=1,L=0;
	for (m=1;m&lt;=n;m&lt;&lt;=1)
		L++;
	n=m;
	for (int i=0;i&lt;=n;i++)
		R[i]=R[i&gt;&gt;1]&gt;&gt;1|((i&amp;1)&lt;&lt;(L-1));
	FFT(a,n,1);
	FFT(b,n,1);
	for (int i=0;i&lt;=n;i++)
		a[i]=a[i]*b[i];
	FFT(a,n,-1);
	for (int i=0;i&lt;=n;i++){
		ans[i]+=(int)(a[i].real()+0.1);
		ans[i+1]=ans[i]/10;
		ans[i]%=10;
	}
	while(ans[n]==0)n--;
	for (int i=n;i&gt;=0;i--)
		printf(&quot;%d&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem2179</h2><pre>#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;complex&gt;
#include &lt;algorithm&gt;
#define pi acos(-1.0)
#define NN 400010
#define rep(i,s,t) for(int i=s;i&lt;=t;i++)
using namespace std;
typedef complex&lt;double&gt; E;
int n,m,L,R[NN],ans[NN];
E a[NN],b[NN];

inline int read()
{
	int t=0,f=1;char ch=getchar();
	while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch&gt;='0'&amp;&amp;ch&lt;='9')t=t*10+ch-'0',ch=getchar();
	return t*f;
}

void FFT(E *a,int n,int on)
{
	rep(i,0,n)
		if(i&lt;R[i])swap(a[i],a[R[i]]);
	for (int l=1;l&lt;n;l&lt;&lt;=1)
	{
		E wn(cos(pi/l),on*sin(pi/l));
		for (int p=l&lt;&lt;1,j=0;j&lt;n;j+=p)
		{
			E w(1,0);
			rep(i,0,l-1)
			{
				E u=a[i+j],v=w*a[i+j+l];
				a[i+j]=u+v;
				a[i+j+l]=u-v;
				w*=wn;
			}
		}
	}
	if(on&lt;0)rep(i,0,n)a[i]/=n;
} 

int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);//freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	n=read()-1;
	rep(i,0,n)
		a[n-i]=getchar()-'0';
	for(;getchar()!='\n';);
	rep(i,0,n)
		b[n-i]=getchar()-'0';
	m=n&lt;&lt;1;L=0;
	for(n=1;n&lt;=m;n&lt;&lt;=1)L++;
	rep(i,0,n)
		R[i]=R[i&gt;&gt;1]&gt;&gt;1|((i&amp;1)&lt;&lt;(L-1));
	FFT(a,n,1);FFT(b,n,1);
	rep(i,0,n)a[i]=a[i]*b[i];
	FFT(a,n,-1); 
	rep(i,0,n)
		ans[i]+=(int)(a[i].real()+0.1),ans[i+1]+=ans[i]/10,ans[i]%=10;
	while(!ans[n])n--;
	for(int i=n;i+1;i--)
		printf(&quot;%d&quot;,ans[i]);
	return 0;
}<pre><h2>Problem2186</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
LL fac[10001111],f[10001111],pr[1001111];
LL mo;
int n,m;
int asd;
bool vt[10001111];
LL ksm(LL a,int b)
{
	if (asd%10000==0) printf(&quot;%d\n&quot;,++asd);
	else asd++;
	LL res=1;
	for (;b;b&gt;&gt;=1,a=a*a%mo)
		if (b&amp;1) res=res*a%mo;
	return res;
}
void exgcd(int a,int b,int &amp;x,int &amp;y)
{
	if(b==0){x=1;y=0;return;}
	exgcd(b,a%b,x,y);
	int t=x;x=y;y=t-a/b*y;
}
LL calc(LL a)
{
	int x,y;
	exgcd(a,mo,x,y);
	return (x%mo+mo)%mo;
}
void prepare()
{
	vt[1]=true;
	int i,j,cnt=0;
	for (i=2;i&lt;=10000000;i++)
	{
		if (!vt[i]) pr[++cnt]=i;
		for (j=1;j&lt;=cnt;j++)
		{
			LL x=(LL)i*pr[j];
			if (x&gt;10000000) break;
			vt[x]=true;
			if (i%pr[j]==0) break;
		}
	}
	fac[0]=1;
	for (i=1;i&lt;=10000000;i++) fac[i]=(LL)fac[i-1]*i%mo;
	f[1]=1;
	for (i=2;i&lt;=10000000;i++)
		if (!vt[i]) f[i]=f[i-1]*(i-1)%mo*calc(i)%mo;
		else f[i]=f[i-1];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int tes;
	scanf(&quot;%d%I64d&quot;,&amp;tes,&amp;mo);
	prepare();
	for (;tes;tes--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		printf(&quot;%lld\n&quot;,(LL)fac[n]*f[m]%mo);
	}
	return 0;
}<pre><h2>Problem2190</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int n;
int getphi(int n)
{
	int res=1;
	for (int i=2;i*i&lt;=n;i++)
		if (n%i==0)
		{
			res=res*(i-1);
			n/=i;
			for (;n%i==0;n/=i) res=res*i;
		}
	if (n&gt;1) res=res*(n-1);
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int ans=0;
	for (int i=1;i&lt;n;i++) ans+=getphi(i);
	ans=ans*2+1;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem2194</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
typedef double DD;
const DD pai=3.14159265358979;
const int NN=401111;
int rev[NN],N,n,L;
struct cp
{
	DD r,i;
	cp(DD a=0,DD b=0) {r=a;i=b;}
	friend cp operator +(cp a,cp b) {a.r+=b.r;a.i+=b.i;return a;}
	friend cp operator -(cp a,cp b) {a.r-=b.r;a.i-=b.i;return a;}
	friend cp operator *(cp a,cp b) {return cp(a.r*b.r-a.i*b.i,a.r*b.i+b.r*a.i);}
} a[NN],b[NN];
void fft(cp *a,int f)
{
	int i,j,k,p;
	for (i=0;i&lt;N;i++)
		if (i&lt;rev[i]) swap(a[i],a[rev[i]]);
	for (i=1;i&lt;N;i&lt;&lt;=1)
	{
		cp wn(cos(pai/i),f*sin(pai/i));
		for (p=i&lt;&lt;1,j=0;j&lt;N;j+=p)
		{
			cp w(1,0);
			for (k=0;k&lt;i;k++,w=w*wn)
			{
				cp x=a[j+k],y=w*a[j+k+i];
				a[j+k]=x+y,a[j+k+i]=x-y;
			}
		}
	}
	if (f==-1) for (i=0;i&lt;N;i++) a[i].r/=N;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y;
	for (i=0;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		a[i].r=x,b[n-i].r=y;
	}
	n=n+n-1;
	for (N=1;N&lt;n;N&lt;&lt;=1) L++;
	for (i=0;i&lt;N;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(L-1));
	fft(a,1);
	fft(b,1);
	for (i=0;i&lt;N;i++) a[i]=a[i]*b[i];
	fft(a,-1);
	n=(n+1)/2;
	for (i=n;i&lt;=n*2-1;i++) printf(&quot;%d\n&quot;,(int)(a[i].r+0.5));
	return 0;
}<pre><h2>Problem2194</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
typedef double DD;
const DD pai=3.14159265358979;
const int NN=401111;
int rev[NN],N,n,L;
struct cp
{
	DD r,i;
	cp(DD a=0,DD b=0) {r=a;i=b;}
	friend cp operator +(cp a,cp b) {a.r+=b.r;a.i+=b.i;return a;}
	friend cp operator -(cp a,cp b) {a.r-=b.r;a.i-=b.i;return a;}
	friend cp operator *(cp a,cp b) {return cp(a.r*b.r-a.i*b.i,a.r*b.i+b.r*a.i);}
} a[NN],b[NN];
void fft(cp *a,int f)
{
	int i,j,k,p;
	for (i=0;i&lt;N;i++)
		if (i&lt;rev[i]) swap(a[i],a[rev[i]]);
	for (i=1;i&lt;N;i&lt;&lt;=1)
	{
		cp wn(cos(pai/i),f*sin(pai/i));
		for (p=i&lt;&lt;1,j=0;j&lt;N;j+=p)
		{
			cp w(1,0);
			for (k=0;k&lt;i;k++,w=w*wn)
			{
				cp x=a[j+k],y=w*a[j+k+i];
				a[j+k]=x+y,a[j+k+i]=x-y;
			}
		}
	}
	if (f==-1) for (i=0;i&lt;N;i++) a[i].r/=N;
}
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y;
	for (i=0;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		a[i].r=x,b[n-i-1].r=y;
	}
	n=n+n-1;
	for (N=1;N&lt;n;N&lt;&lt;=1) L++;
	for (i=0;i&lt;N;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(L-1));
	fft(a,1);
	fft(b,1);
	for (i=0;i&lt;N;i++) a[i]=a[i]*b[i];
	fft(a,-1);
	n=(n+1)/2;
	for (i=n-1;i&lt;n*2-1;i++) printf(&quot;%d\n&quot;,(int)(a[i].r+0.5));
	return 0;
}<pre><h2>Problem2194</h2><pre>#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;complex&gt;
#include &lt;algorithm&gt;
#define pi acos(-1.0)
#define NN 300010
using namespace std;
typedef complex&lt;double&gt; E;
int R[NN],n,m,l,L;
E a[NN],b[NN];

inline int read(){
	int f=1,t=0;
	char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9'){
		if (ch=='-')f=-1;
		ch=getchar();
	}
	while (ch&lt;='9'&amp;&amp;ch&gt;='0'){
		t=t*10+ch-'0';
		ch=getchar();
	}
	return t*f;
}

void FFT(E *a,int n,int on){
	for (int i=0;i&lt;=n;i++)
		if (i&lt;R[i])
			swap(a[i],a[R[i]]);
	for (int l=1;l&lt;n;l&lt;&lt;=1){
		E wn(cos(pi/l),on*sin(pi/l));
		for (int p=l&lt;&lt;1,j=0;j&lt;n;j+=p){
			E w(1,0);
			for (int i=0;i&lt;l;i++){
				E u=a[i+j],v=a[i+j+l]*w;
				a[i+j]=u+v;
				a[i+j+l]=u-v;				
				w*=wn;
			}
		}
	}
	if (on&lt;0)
		for (int i=0;i&lt;=n;i++)
			a[i]/=n;	
}

int main(){
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	n=read();n--;
	for (int i=0;i&lt;=n;i++)
		a[i]=(double)read(),b[n-i]=(double)read();
	m=n&lt;&lt;1;
	L=0;
	for (n=1;n&lt;=m;n&lt;&lt;=1)
		L++;
	for (int i=0;i&lt;=n;i++)
		R[i]=R[i&gt;&gt;1]&gt;&gt;1|((i&amp;1)&lt;&lt;(L-1));
	FFT(a,n,1);
	FFT(b,n,1);
	for (int i=0;i&lt;=n;i++)
		a[i]=b[i]*a[i];
	FFT(a,n,-1);
	for (int i=m/2;i&lt;=m;i++)
		printf(&quot;%d\n&quot;,(int)(a[i].real()+0.1));
	return 0;
}<pre><h2>Problem2194</h2><pre>#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;complex&gt;
#include &lt;algorithm&gt;
#define pi acos(-1.0)
#define NN 300010
#define rep(i,s,t) for(int i=s;i&lt;=t;i++)
using namespace std;
typedef complex&lt;double&gt; E;
int n,m,L,R[NN];
E a[NN],b[NN];

inline int read()
{
	int t=0,f=1;char ch=getchar();
	while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch&gt;='0'&amp;&amp;ch&lt;='9')t=t*10+ch-'0',ch=getchar();
	return t*f;
}

void FFT(E *a,int n,int on)
{
	rep(i,0,n)
		if(i&lt;R[i])swap(a[i],a[R[i]]);	
	for (int l=1;l&lt;n;l&lt;&lt;=1)
	{
		E wn(cos(pi/l),on*sin(pi/l));
		for(int p=l&lt;&lt;1,j=0;j&lt;n;j+=p)
		{
			E w(1,0);
			rep(i,0,l-1)//0~l-1
			{
				E u=a[i+j],v=a[i+j+l]*w;
				a[i+j]=u+v;
				a[i+j+l]=u-v;
				w*=wn;
			}
		}
	}
	if(on&lt;0)rep(i,0,n)a[i]/=n;
}

int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);//freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	n=read()-1;
	rep(i,0,n)
		a[i]=(double)read(),b[n-i]=(double)read();
	m=n&lt;&lt;1;L=0;
	for(n=1;n&lt;=m;n&lt;&lt;=1)L++;
	rep(i,0,n)
		R[i]=R[i&gt;&gt;1]&gt;&gt;1|((i&amp;1)&lt;&lt;(L-1));
	FFT(a,n,1);FFT(b,n,1);
	rep(i,0,n)a[i]=a[i]*b[i];
	FFT(a,n,-1);
	rep(i,m&gt;&gt;1,m)
		printf(&quot;%d\n&quot;,(int)(a[i].real()+0.1));
	return 0;
}<pre><h2>Problem2194</h2><pre>#include&lt;stdio.h&gt;
#define ll long long
#define mod 998244353
inline ll POW(ll x,ll y){
	ll z=1;
	while(y){
		if(y&amp;1) z=z*x%mod;
		x=x*x%mod,y&gt;&gt;=1;
	}
	return z;
}
void NTT(int o[],int n,int tp){
	for(int i=0,j=0;i&lt;n;++i){
		if(i&gt;j) o[i]^=o[j],o[j]^=o[i],o[i]^=o[j];
		for(int k=n&gt;&gt;1;(j^=k)&lt;k;k&gt;&gt;=1);
	}
	for(int i=2,x,y;i&lt;=n;i&lt;&lt;=1)
	    for(ll wn=POW(3,tp?(mod-1)/i:mod-1-(mod-1)/i),j=0;j&lt;n;j+=i)
	        for(ll w=1,k=0,p=i&gt;&gt;1;k&lt;p;++k,w=w*wn%mod)
				x=o[j+k],y=w*o[j+k+p]%mod,o[j+k]=(x+y)%mod,o[j+k+p]=(x-y+mod)%mod;
	if(!tp){
		ll inv=POW(n,mod-2);
		for(int i=0;i&lt;n;++i) o[i]=inv*o[i]%mod;
	}
}
inline void in(int &amp;TEMP){int EPX;for(TEMP=getchar();TEMP&lt;48||TEMP&gt;57;TEMP=getchar());for(TEMP^=48,EPX=getchar();EPX&lt;58&amp;&amp;EPX&gt;47;EPX=getchar())TEMP=(TEMP&lt;&lt;3)+(TEMP&lt;&lt;1)+(EPX^48);}
int n,len,a[610000],b[610000],ans[610000];
int main(){
	in(n);for(int i=0;i&lt;n;++i) in(a[i]),in(ans[i]);
	for(int i=0;i&lt;n;++i) b[i]=ans[n-i-1];
	for(len=1;len&lt;=n&lt;&lt;1;len&lt;&lt;=1);len&lt;&lt;=1;
	NTT(a,len,1),NTT(b,len,1);
	for(int i=0;i&lt;len;++i) ans[i]=(ll)a[i]*b[i]%mod;
	NTT(ans,len,0);
	for(int i=n-1,r=(n-1)&lt;&lt;1|1;i&lt;r;++i) printf(&quot;%d\n&quot;,ans[i]);
}
<pre><h2>Problem2208</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;bitset&gt;
using namespace std;
#define mii(a,b) (a&lt;b?a:b)
#define ln printf(&quot;\n&quot;)
const int NN=2111,MM=2000*2000+11;
int o[NN],fa[NN],dfn[NN],low[NN],aa[MM][2],sta[NN],num[NN];
int belong[NN],du[NN],b[NN];
int n,m,tot,scc,dfx,top;
bool vt[NN];
bitset&lt;2001&gt; f[2001];
struct edge
{
	int u,v;
	edge(int a=0,int b=0) {u=a;v=b;}
} e[MM];
inline void addedge(int p,int q)
{
	//printf(&quot;addedge %d %d\n&quot;,p,q);
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void tarjan(int v)
{
	vt[v]=true;
	dfn[v]=low[v]=++dfx;
	sta[++top]=v;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		if (!vt[y])
		{
			fa[y]=v;
			tarjan(y);
			low[v]=mii(low[v],low[y]);
		}
		else if (!belong[y])
			low[v]=mii(low[v],dfn[y]);
	}
	if (low[v]==dfn[v])
	{
		scc++;
		while (sta[top+1]!=v)
		{
			belong[sta[top--]]=scc;
			num[scc]++;
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j;
	for (i=1;i&lt;=n;i++) for (j=1;j&lt;=n;j++)
	{
		char ch=getchar();
		while (ch!='0'&amp;&amp;ch!='1') ch=getchar();
		if (ch=='1') e[++m]=edge(i,j),addedge(i,j);
	}
	for (i=1;i&lt;=n;i++)
		if (!vt[i]) tarjan(i);
	//printf(&quot;belong &quot;);for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,belong[i]);ln;
	memset(o,0,sizeof(o));tot=0;
	for (i=1;i&lt;=m;i++)
		if (belong[e[i].u]!=belong[e[i].v])
			du[belong[e[i].v]]++,addedge(belong[e[i].u],belong[e[i].v]);
	//printf(&quot;du &quot;);for (i=1;i&lt;=scc;i++) printf(&quot;%d &quot;,du[i]);ln;
	top=0;
	for (i=1;i&lt;=scc;i++)
		if (du[i]==0) sta[++top]=i;
	while (top)
	{
		int x=sta[top--];
		//printf(&quot;x=%d\n&quot;,x);
		b[++b[0]]=x;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (--du[y]==0) sta[++top]=y;
		}
	}
	//for (i=b[0];i;i--) printf(&quot;%d &quot;,b[i]);ln;
	for (i=b[0];i;i--)
	{
		int x=b[i];
		f[x][x]=1;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			f[x]|=f[y];
		}
	}
	int ans=0;
	for (i=1;i&lt;=scc;i++)
		for (j=1;j&lt;=scc;j++)
			if (f[i][j]) ans+=num[i]*num[j];
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem2209</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int mn=110000;
int fa[mn],son[mn][2],maxl[mn],minl[mn],maxr[mn],minr[mn],sum[mn],tree[mn],S[mn],a[mn];
bool tag1[mn],tag2[mn];
int n,m,aa,bb,x,i,root,kind;
char ch;
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
int max(int a,int b,int c)
{
	if (a&gt;=b&amp;&amp;a&gt;=c) return a;
	if (b&gt;=a&amp;&amp;b&gt;=c) return b;
	return c;
}
int min(int a,int b,int c) {return -max(-a,-b,-c);}
void make1(int t)
{
	tag1[t]=!tag1[t];
	tree[t]=-tree[t];
	sum[t]=-sum[t];
	swap(maxl[t],minl[t]);
	maxl[t]=-maxl[t];
	minl[t]=-minl[t];
	swap(maxr[t],minr[t]);
	maxr[t]=-maxr[t];
	minr[t]=-minr[t];
}
void make2(int t)
{
	tag2[t]=!tag2[t];
	swap(maxl[t],maxr[t]);
	swap(minl[t],minr[t]);
	swap(son[t][0],son[t][1]);
}
void update(int t)
{
	int x=son[t][0],y=son[t][1];
	S[t]=S[x]+S[y]+1;
	sum[t]=sum[x]+sum[y]+tree[t];
	maxl[t]=max(maxl[x],sum[x]+tree[t],sum[x]+tree[t]+maxl[y]);
	minl[t]=min(minl[x],sum[x]+tree[t],sum[x]+tree[t]+minl[y]);
	maxr[t]=max(maxr[y],sum[y]+tree[t],sum[y]+tree[t]+maxr[x]);
	minr[t]=min(minr[y],sum[y]+tree[t],sum[y]+tree[t]+minr[x]);
}
void pushdown(int t)
{
	if (tag1[t])
	{
		if (son[t][0]) make1(son[t][0]);
		if (son[t][1]) make1(son[t][1]);
		tag1[t]=0;
	}
	if (tag2[t])
	{
		if (son[t][0]) make2(son[t][0]);
		if (son[t][1]) make2(son[t][1]);
		tag2[t]=0;
	}
}
int build(int ll,int rr)
{
	int mid=(ll+rr)&gt;&gt;1;
	tree[mid]=a[mid-1];
	tag1[mid]=0,tag2[mid]=0;
	if (ll&lt;mid)
	{
		int x=build(ll,mid-1);
		fa[x]=mid;
		son[mid][0]=x;
	}
	if (mid&lt;rr)
	{
		int x=build(mid+1,rr);
		fa[x]=mid;
		son[mid][1]=x;
	}
	update(mid);
	return mid;
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
	update(y),update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
}
int find(int t,int x)
{
	for (;t;)
	{
		pushdown(t);
		if (x==S[son[t][0]]+1) return t;
		if (x&lt;=S[son[t][0]]) t=son[t][0];
		else x-=(S[son[t][0]]+1),t=son[t][1];
	}
}
void zhong(int t)
{
	if (t==0) return;
	pushdown(t);
	zhong(son[t][0]);
	printf(&quot;%d &quot;,tree[t]);
	zhong(son[t][1]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%c&quot;,&amp;ch);
		//printf(&quot;%c\n&quot;,ch);
		a[i]=ch=='('?1:-1;
	}
	root=build(1,n+2);
	for (;m;m--)
	{
		//printf(&quot;\n----------------------\n&quot;);
		//zhong(root);printf(&quot;\n&quot;);
		scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;aa,&amp;bb);
		++aa,++bb;
		//printf(&quot;%d %d\n&quot;,aa,bb);
		int x=find(root,aa-1);
		splay(x,0);
		x=find(root,bb+1);
		//printf(&quot;%d\n&quot;,x);
		splay(x,root);
		x=son[x][0];
		//printf(&quot;%d %d\n&quot;,maxr[x],minl[x]);
		if (kind==0) printf(&quot;%d\n&quot;,(maxr[x]+1)/2+(-minl[x]+1)/2);
		else if (kind==1) make1(x);
		else make2(x);
	}
	return 0;
}<pre><h2>Problem2209</h2><pre>Program BZOJ_2209;
Const
    maxn=100000+100+2;
    nill=-1;
Type
    SplayTree=record
        father                  :longint;
        son                     :array[0..1] of longint;
        key,sum,size            :longint;
        minl,maxl               :longint;
        minr,maxr               :longint;
        opp,rev                 :boolean;
    end;
Var
    tree                        :array[0..maxn] of SplayTree;
    a                           :array[0..maxn] of longint;
    n,m,i,root                  :longint;
     
Function Max(x,y:longint):longint;
Begin
    if x&gt;y then exit(x)
    else exit(y);
End;
     
Function Min(x,y:longint):longint;
Begin
    if x&lt;y then exit(x)
    else exit(y);
End;
     
Procedure Swap(Var x,y:longint);
Var temp                        :longint;
Begin
    temp:=x;x:=y;y:=temp;
End;
     
Procedure Init;
Var ch                          :char;
Begin
    readln(n,m);
    for i:=2 to n+1 do
        begin
            read(ch);
            if ch='(' then a[i]:=1
            else a[i]:=-1;
        end;
End;
     
Procedure Renew(x:longint;flag:boolean);
Begin
    with tree[x] do
        if flag then
            begin
                key:=key*(-1);
                sum:=sum*(-1);
                swap(minl,maxl);
                minl:=minl*(-1);
                maxl:=maxl*(-1);
                swap(minr,maxr);
                minr:=minr*(-1);
                maxr:=maxr*(-1);
                opp:=not opp;
            end
        else
            begin
                swap(son[0],son[1]);
                swap(minl,minr);
                swap(maxl,maxr);
                rev:=not rev;
            end;
End;
     
Procedure Update(x:longint);
Begin
    with tree[x] do
        begin
            size:=tree[son[0]].size+tree[son[1]].size+1;
            sum:=tree[son[0]].sum+tree[son[1]].sum+key;
            minl:=min(tree[son[0]].minl,tree[son[0]].sum+key+tree[son[1]].minl);
            maxl:=max(tree[son[0]].maxl,tree[son[0]].sum+key+tree[son[1]].maxl);
            minr:=min(tree[son[1]].minr,tree[son[1]].sum+key+tree[son[0]].minr);
            maxr:=max(tree[son[1]].maxr,tree[son[1]].sum+key+tree[son[0]].maxr);
        end;
End;
     
Procedure Push_Down(x:longint);
Begin
    with tree[x] do
        begin
            if opp then
                begin
                    renew(son[0],true);
                    renew(son[1],true);
                    opp:=false;
                end;
            if rev then
                begin
                    renew(son[0],false);
                    renew(son[1],false);
                    rev:=false;
                end;
        end;
End;
     
Function Build(l,r:longint):longint;
Var mid                         :longint;
Begin
    mid:=(l+r) shr 1;
    tree[mid].key:=a[mid];
    build:=mid;
    if l&lt;mid then
        begin
            tree[mid].son[0]:=build(l,mid-1);
            tree[tree[mid].son[0]].father:=mid;
        end;
    if mid&lt;r then
        begin
            tree[mid].son[1]:=build(mid+1,r);
            tree[tree[mid].son[1]].father:=mid;
        end;
    update(mid);
End;
 
Procedure Rotate(x,u:longint);
Var y                           :longint;
Begin
    push_down(tree[x].father);
    push_down(x);
    with tree[x] do
        begin
            y:=father;
            tree[y].son[u]:=son[u xor 1];
            tree[son[u xor 1]].father:=y;
            if y=root then root:=x
            else
                if y=tree[tree[y].father].son[0] then tree[tree[y].father].son[0]:=x
                else tree[tree[y].father].son[1]:=x;
            father:=tree[y].father;
            tree[y].father:=x;
            son[u xor 1]:=y;
        end;
    update(y);
End;
     
Procedure Splay(x,t:longint);
Var y,u,v                       :longint;
Begin
    push_down(x);
    while tree[x].father&lt;&gt;t do
        begin
            y:=tree[x].father;
            if tree[y].father=t then rotate(x,ord(x=tree[y].son[1]))
            else
                begin
                    if x=tree[y].son[0] then u:=0
                    else u:=1;
                    if y=tree[tree[y].father].son[0] then v:=0
                    else v:=1;
                    if u xor v=0 then
                        begin
                            rotate(y,v);
                            rotate(x,u);
                        end
                    else
                        begin
                            rotate(x,u);
                            rotate(x,v);
                        end;
                end;
        end;
    update(x);
End;
     
Function Find(x:longint):longint;
Var t                           :longint;
Begin
    t:=root;
    while true do
        begin
           push_down(t);
            with tree[t] do
                begin
                    if tree[son[0]].size+1=x then exit(t);
                    if tree[son[0]].size+1&gt;x then t:=son[0]
                    else
                        begin
                            dec(x,tree[son[0]].size+1);
                            t:=son[1];
                        end;
                end;
        end;
End;
     
Function Query(l,r:longint):longint;
Var p                           :longint;
Begin
    p:=find(l);splay(p,nill);
    p:=find(r+2);splay(p,root);
    p:=tree[tree[root].son[1]].son[0];
    query:=(abs(tree[p].minl)+1)&gt;&gt;1+(tree[p].maxr+1)&gt;&gt;1;
End;
     
Procedure Opposite(l,r:longint);
Var p                           :longint;
Begin
    p:=find(l);splay(p,nill);
    p:=find(r+2);splay(p,root);
    p:=tree[tree[root].son[1]].son[0];
    renew(p,true);
    update(tree[root].son[1]);
    update(root);
End;
     
Procedure Reverse(l,r:longint);
Var p                           :longint;
Begin
    p:=find(l);splay(p,nill);
    p:=find(r+2);splay(p,root);
    p:=tree[tree[root].son[1]].son[0];
    renew(p,false);
    update(tree[root].son[1]);
    update(root);
End;
     
Procedure Main;
Var u,p,q                       :longint;
Begin
    root:=build(1,n+2);
    tree[root].father:=nill;
     
    for i:=1 to m do
        begin
            read(u,p,q);
            case u of
                0 : writeln(query(p,q));
                1 : opposite(p,q);
                2 : reverse(p,q);
            end;
        end;
End;
     
Begin
    Init;
    Main;
End.<pre><h2>Problem2209</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int mn=110000,inf=99999999;
int fa[mn],son[mn][2],maxl[mn],minl[mn],maxr[mn],minr[mn],sum[mn],tree[mn],S[mn],a[mn];
bool tag1[mn],tag2[mn];
int n,m,aa,bb,x,i,root,kind;
char ch;
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
int max(int a,int b,int c)
{
	if (a&gt;=b&amp;&amp;a&gt;=c) return a;
	if (b&gt;=a&amp;&amp;b&gt;=c) return b;
	return c;
}
int min(int a,int b,int c) {return -max(-a,-b,-c);}
void make1(int t)
{
	tag1[t]=!tag1[t];
	tree[t]=-tree[t];
	sum[t]=-sum[t];
	swap(maxl[t],minl[t]);
	maxl[t]=-maxl[t];
	minl[t]=-minl[t];
	swap(maxr[t],minr[t]);
	maxr[t]=-maxr[t];
	minr[t]=-minr[t];
}
void make2(int t)
{
	tag2[t]=!tag2[t];
	swap(maxl[t],maxr[t]);
	swap(minl[t],minr[t]);
	swap(son[t][0],son[t][1]);
}
void update(int t)
{
	int x=son[t][0],y=son[t][1];
	S[t]=S[x]+S[y]+1;
	sum[t]=sum[x]+sum[y]+tree[t];
	maxl[t]=max(maxl[x],sum[x]+tree[t],sum[x]+tree[t]+maxl[y]);
	minl[t]=min(minl[x],sum[x]+tree[t],sum[x]+tree[t]+minl[y]);
	maxr[t]=max(maxr[y],sum[y]+tree[t],sum[y]+tree[t]+maxr[x]);
	minr[t]=min(minr[y],sum[y]+tree[t],sum[y]+tree[t]+minr[x]);
}
void pushdown(int t)
{
	if (tag1[t])
	{
		if (son[t][0]) make1(son[t][0]);
		if (son[t][1]) make1(son[t][1]);
		tag1[t]=0;
	}
	if (tag2[t])
	{
		if (son[t][0]) make2(son[t][0]);
		if (son[t][1]) make2(son[t][1]);
		tag2[t]=0;
	}
}
int build(int ll,int rr)
{
	int mid=(ll+rr)&gt;&gt;1;
	tree[mid]=a[mid-1];
	tag1[mid]=0,tag2[mid]=0;
	if (ll&lt;mid)
	{
		int x=build(ll,mid-1);
		fa[x]=mid;
		son[mid][0]=x;
	}
	if (mid&lt;rr)
	{
		int x=build(mid+1,rr);
		fa[x]=mid;
		son[mid][1]=x;
	}
	update(mid);
	return mid;
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
	update(y),update(t);
}
void splay(int t,int ff)
{
	pushdown(t);
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
}
int find(int t,int x)
{
	for (;t;)
	{
		pushdown(t);
		if (x==S[son[t][0]]+1) return t;
		if (x&lt;=S[son[t][0]]) t=son[t][0];
		else x-=(S[son[t][0]]+1),t=son[t][1];
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%c&quot;,&amp;ch);
		a[i]=ch=='('?1:-1;
	}
	S[0]=0,sum[0]=0,maxl[0]=-inf,minl[0]=inf,maxr[0]=-inf,minr[0]=inf;
	root=build(1,n+2);
	for (;m;m--)
	{
		//printf(&quot;\n----------------------\n&quot;);
		scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;aa,&amp;bb);
		++aa,++bb;
		int x=find(root,aa-1);
		splay(x,0);
		x=find(root,bb+1);
		splay(x,root);
		x=son[x][0];
		if (kind==0) printf(&quot;%d\n&quot;,(maxr[x]+1)/2+(-minl[x]+1)/2);
		else if (kind==1) make1(x);
		else make2(x);
	}
	return 0;
}<pre><h2>Problem2209</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int mn=110000,inf=99999999;
int fa[mn],son[mn][2],maxl[mn],minl[mn],maxr[mn],minr[mn],sum[mn],tree[mn],S[mn],a[mn];
bool tag1[mn],tag2[mn];
int n,m,aa,bb,x,i,root,kind;
char ch;
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
int max(int a,int b,int c)
{
	if (a&gt;=b&amp;&amp;a&gt;=c) return a;
	if (b&gt;=a&amp;&amp;b&gt;=c) return b;
	return c;
}
int min(int a,int b,int c) {return -max(-a,-b,-c);}
void make1(int t)
{
	tag1[t]=!tag1[t];
	tree[t]=-tree[t];
	sum[t]=-sum[t];
	swap(maxl[t],minl[t]);
	maxl[t]=-maxl[t];
	minl[t]=-minl[t];
	swap(maxr[t],minr[t]);
	maxr[t]=-maxr[t];
	minr[t]=-minr[t];
}
void make2(int t)
{
	tag2[t]=!tag2[t];
	swap(maxl[t],maxr[t]);
	swap(minl[t],minr[t]);
	swap(son[t][0],son[t][1]);
}
void update(int t)
{
	int x=son[t][0],y=son[t][1];
	S[t]=S[x]+S[y]+1;
	sum[t]=sum[x]+sum[y]+tree[t];
	maxl[t]=max(maxl[x],sum[x]+tree[t],sum[x]+tree[t]+maxl[y]);
	minl[t]=min(minl[x],sum[x]+tree[t],sum[x]+tree[t]+minl[y]);
	maxr[t]=max(maxr[y],sum[y]+tree[t],sum[y]+tree[t]+maxr[x]);
	minr[t]=min(minr[y],sum[y]+tree[t],sum[y]+tree[t]+minr[x]);
}
void pushdown(int t)
{
	if (tag1[t])
	{
		if (son[t][0]) make1(son[t][0]);
		if (son[t][1]) make1(son[t][1]);
		tag1[t]=0;
	}
	if (tag2[t])
	{
		if (son[t][0]) make2(son[t][0]);
		if (son[t][1]) make2(son[t][1]);
		tag2[t]=0;
	}
}
int build(int ll,int rr)
{
	int mid=(ll+rr)&gt;&gt;1;
	tree[mid]=a[mid-1];
	tag1[mid]=0,tag2[mid]=0;
	if (ll&lt;mid)
	{
		int x=build(ll,mid-1);
		fa[x]=mid;
		son[mid][0]=x;
	}
	if (mid&lt;rr)
	{
		int x=build(mid+1,rr);
		fa[x]=mid;
		son[mid][1]=x;
	}
	update(mid);
	return mid;
}
void rotate(int t,int p)
{
	int y=fa[t];
	//pushdown(y),pushdown(t);
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
	update(y),update(t);
}
void splay(int t,int ff)
{
	pushdown(t);
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
}
int find(int t,int x)
{
	for (;t;)
	{
		pushdown(t);
		if (x==S[son[t][0]]+1) return t;
		if (x&lt;=S[son[t][0]]) t=son[t][0];
		else x-=(S[son[t][0]]+1),t=son[t][1];
	}
}
int main()
{
	//、、freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%c&quot;,&amp;ch);
		a[i]=ch=='('?1:-1;
	}
	S[0]=0,sum[0]=0,maxl[0]=-inf,minl[0]=inf,maxr[0]=-inf,minr[0]=inf;
	root=build(1,n+2);
	for (;m;m--)
	{
		//printf(&quot;\n----------------------\n&quot;);
		scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;aa,&amp;bb);
		++aa,++bb;
		int x=find(root,aa-1);
		splay(x,0);
		x=find(root,bb+1);
		splay(x,root);
		x=son[x][0];
		if (kind==0) printf(&quot;%d\n&quot;,(maxr[x]+1)/2+(-minl[x]+1)/2);
		else if (kind==1) make1(x);
		else make2(x);
	}
	return 0;
}<pre><h2>Problem2209</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int mn=110000,inf=99999999;
int fa[mn],son[mn][2],maxl[mn],minl[mn],maxr[mn],minr[mn],sum[mn],tree[mn],S[mn],a[mn];
bool tag1[mn],tag2[mn];
int n,m,aa,bb,x,i,root,kind;
char ch;
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
int max(int a,int b,int c)
{
	if (a&gt;=b&amp;&amp;a&gt;=c) return a;
	if (b&gt;=a&amp;&amp;b&gt;=c) return b;
	return c;
}
int min(int a,int b,int c) {return -max(-a,-b,-c);}
void make1(int t)
{
	tag1[t]=!tag1[t];
	tree[t]=-tree[t];
	sum[t]=-sum[t];
	swap(maxl[t],minl[t]);
	maxl[t]=-maxl[t];
	minl[t]=-minl[t];
	swap(maxr[t],minr[t]);
	maxr[t]=-maxr[t];
	minr[t]=-minr[t];
}
void make2(int t)
{
	tag2[t]=!tag2[t];
	swap(maxl[t],maxr[t]);
	swap(minl[t],minr[t]);
	swap(son[t][0],son[t][1]);
}
void update(int t)
{
	int x=son[t][0],y=son[t][1];
	S[t]=S[x]+S[y]+1;
	sum[t]=sum[x]+sum[y]+tree[t];
	maxl[t]=max(maxl[x],sum[x]+tree[t],sum[x]+tree[t]+maxl[y]);
	minl[t]=min(minl[x],sum[x]+tree[t],sum[x]+tree[t]+minl[y]);
	maxr[t]=max(maxr[y],sum[y]+tree[t],sum[y]+tree[t]+maxr[x]);
	minr[t]=min(minr[y],sum[y]+tree[t],sum[y]+tree[t]+minr[x]);
}
void pushdown(int t)
{
	if (tag1[t])
	{
		if (son[t][0]) make1(son[t][0]);
		if (son[t][1]) make1(son[t][1]);
		tag1[t]=0;
	}
	if (tag2[t])
	{
		if (son[t][0]) make2(son[t][0]);
		if (son[t][1]) make2(son[t][1]);
		tag2[t]=0;
	}
}
int build(int ll,int rr)
{
	int mid=(ll+rr)&gt;&gt;1;
	tree[mid]=a[mid-1];
	tag1[mid]=0,tag2[mid]=0;
	if (ll&lt;mid)
	{
		int x=build(ll,mid-1);
		fa[x]=mid;
		son[mid][0]=x;
	}
	if (mid&lt;rr)
	{
		int x=build(mid+1,rr);
		fa[x]=mid;
		son[mid][1]=x;
	}
	update(mid);
	return mid;
}
void rotate(int t,int p)
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
	update(y);
}
void splay(int t,int ff)
{
	pushdown(t);
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
	update(t);
}
int find(int t,int x)
{
	for (;t;)
	{
		pushdown(t);
		if (x==S[son[t][0]]+1) return t;
		if (x&lt;=S[son[t][0]]) t=son[t][0];
		else x-=(S[son[t][0]]+1),t=son[t][1];
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%c&quot;,&amp;ch);
		a[i]=ch=='('?1:-1;
	}
	S[0]=0,sum[0]=0,maxl[0]=-inf,minl[0]=inf,maxr[0]=-inf,minr[0]=inf;
	root=build(1,n+2);
	for (;m;m--)
	{
		scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;aa,&amp;bb);
		++aa,++bb;
		int x=find(root,aa-1);
		splay(x,0);
		x=find(root,bb+1);
		splay(x,root);
		x=son[x][0];
		if (kind==0) printf(&quot;%d\n&quot;,(maxr[x]+1)/2+(-minl[x]+1)/2);
		else if (kind==1) make1(x);
		else make2(x);
	}
	return 0;
}<pre><h2>Problem2209</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int mn=110000,inf=99999999;
int fa[mn],son[mn][2],maxl[mn],minl[mn],maxr[mn],minr[mn],sum[mn],tree[mn],S[mn],a[mn];
bool tag1[mn],tag2[mn];
int n,m,aa,bb,x,i,root,kind;
char ch;
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
int max(int a,int b,int c)
{
	if (a&gt;=b&amp;&amp;a&gt;=c) return a;
	if (b&gt;=a&amp;&amp;b&gt;=c) return b;
	return c;
}
int min(int a,int b,int c) {return -max(-a,-b,-c);}
void make1(int t)
{
	tag1[t]=!tag1[t];
	tree[t]=-tree[t];
	sum[t]=-sum[t];
	swap(maxl[t],minl[t]);
	maxl[t]=-maxl[t];
	minl[t]=-minl[t];
	swap(maxr[t],minr[t]);
	maxr[t]=-maxr[t];
	minr[t]=-minr[t];
}
void make2(int t)
{
	tag2[t]=!tag2[t];
	swap(maxl[t],maxr[t]);
	swap(minl[t],minr[t]);
	swap(son[t][0],son[t][1]);
}
void update(int t)
{
	int x=son[t][0],y=son[t][1];
	S[t]=S[x]+S[y]+1;
	sum[t]=sum[x]+sum[y]+tree[t];
	maxl[t]=max(maxl[x],sum[x]+tree[t],sum[x]+tree[t]+maxl[y]);
	minl[t]=min(minl[x],sum[x]+tree[t],sum[x]+tree[t]+minl[y]);
	maxr[t]=max(maxr[y],sum[y]+tree[t],sum[y]+tree[t]+maxr[x]);
	minr[t]=min(minr[y],sum[y]+tree[t],sum[y]+tree[t]+minr[x]);
}
void pushdown(int t)
{
	if (tag1[t])
	{
		if (son[t][0]) make1(son[t][0]);
		if (son[t][1]) make1(son[t][1]);
		tag1[t]=0;
	}
	if (tag2[t])
	{
		if (son[t][0]) make2(son[t][0]);
		if (son[t][1]) make2(son[t][1]);
		tag2[t]=0;
	}
}
int build(int ll,int rr)
{
	int mid=(ll+rr)&gt;&gt;1;
	tree[mid]=a[mid-1];
	tag1[mid]=0,tag2[mid]=0;
	if (ll&lt;mid)
	{
		int x=build(ll,mid-1);
		fa[x]=mid;
		son[mid][0]=x;
	}
	if (mid&lt;rr)
	{
		int x=build(mid+1,rr);
		fa[x]=mid;
		son[mid][1]=x;
	}
	update(mid);
	return mid;
}
void rotate(int t,int p)
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
	update(y);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
	update(t);
}
int find(int t,int x)
{
	for (;t;)
	{
		pushdown(t);
		if (x==S[son[t][0]]+1) return t;
		if (x&lt;=S[son[t][0]]) t=son[t][0];
		else x-=(S[son[t][0]]+1),t=son[t][1];
	}
}
int main()
{
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%c&quot;,&amp;ch);
		a[i]=ch=='('?1:-1;
	}
	S[0]=0,sum[0]=0,maxl[0]=-inf,minl[0]=inf,maxr[0]=-inf,minr[0]=inf;
	root=build(1,n+2);
	for (;m;m--)
	{
		scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;aa,&amp;bb);
		++aa,++bb;
		int x=find(root,aa-1);
		splay(x,0);
		x=find(root,bb+1);
		splay(x,root);
		x=son[x][0];
		if (kind==0) printf(&quot;%d\n&quot;,(maxr[x]+1)/2+(-minl[x]+1)/2);
		else if (kind==1) make1(x);
		else make2(x);
	}
	return 0;
}<pre><h2>Problem2209</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int mn=110000,inf=99999999;
int fa[mn],son[mn][2],maxl[mn],minl[mn],maxr[mn],minr[mn],sum[mn],tree[mn],S[mn],a[mn];
bool tag1[mn],tag2[mn];
int n,m,aa,bb,x,i,root,kind;
char ch;
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
int max(int a,int b,int c)
{
	if (a&gt;=b&amp;&amp;a&gt;=c) return a;
	if (b&gt;=a&amp;&amp;b&gt;=c) return b;
	return c;
}
int min(int a,int b,int c) {return -max(-a,-b,-c);}
void make1(int t)
{
	tag1[t]=!tag1[t];
	tree[t]=-tree[t];
	sum[t]=-sum[t];
	swap(maxl[t],minl[t]);
	maxl[t]=-maxl[t];
	minl[t]=-minl[t];
	swap(maxr[t],minr[t]);
	maxr[t]=-maxr[t];
	minr[t]=-minr[t];
}
void make2(int t)
{
	tag2[t]=!tag2[t];
	swap(maxl[t],maxr[t]);
	swap(minl[t],minr[t]);
	swap(son[t][0],son[t][1]);
}
void update(int t)
{
	int x=son[t][0],y=son[t][1];
	S[t]=S[x]+S[y]+1;
	sum[t]=sum[x]+sum[y]+tree[t];
	maxl[t]=max(maxl[x],sum[x]+tree[t],sum[x]+tree[t]+maxl[y]);
	minl[t]=min(minl[x],sum[x]+tree[t],sum[x]+tree[t]+minl[y]);
	maxr[t]=max(maxr[y],sum[y]+tree[t],sum[y]+tree[t]+maxr[x]);
	minr[t]=min(minr[y],sum[y]+tree[t],sum[y]+tree[t]+minr[x]);
}
void pushdown(int t)
{
	if (tag1[t])
	{
		if (son[t][0]) make1(son[t][0]);
		if (son[t][1]) make1(son[t][1]);
		tag1[t]=0;
	}
	if (tag2[t])
	{
		if (son[t][0]) make2(son[t][0]);
		if (son[t][1]) make2(son[t][1]);
		tag2[t]=0;
	}
}
int build(int ll,int rr)
{
	int mid=(ll+rr)&gt;&gt;1;
	tree[mid]=a[mid-1];
	tag1[mid]=0,tag2[mid]=0;
	if (ll&lt;mid)
	{
		int x=build(ll,mid-1);
		fa[x]=mid;
		son[mid][0]=x;
	}
	if (mid&lt;rr)
	{
		int x=build(mid+1,rr);
		fa[x]=mid;
		son[mid][1]=x;
	}
	update(mid);
	return mid;
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
	update(y),update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
}
int find(int t,int x)
{
	for (;t;)
	{
		pushdown(t);
		if (x==S[son[t][0]]+1) return t;
		if (x&lt;=S[son[t][0]]) t=son[t][0];
		else x-=(S[son[t][0]]+1),t=son[t][1];
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%c&quot;,&amp;ch);
		a[i]=ch=='('?1:-1;
	}
	S[0]=0,sum[0]=0,maxl[0]=-inf,minl[0]=inf,maxr[0]=-inf,minr[0]=inf;
	root=build(1,n+2);
	for (;m;m--)
	{
		scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;aa,&amp;bb);
		++aa,++bb;
		int x=find(root,aa-1);
		splay(x,0);
		x=find(root,bb+1);
		splay(x,root);
		x=son[x][0];
		if (kind==0) printf(&quot;%d\n&quot;,(maxr[x]+1)/2+(-minl[x]+1)/2);
		else if (kind==1) make1(x);
		else make2(x);
	}
	return 0;
}<pre><h2>Problem2209</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int mn=110000,inf=99999999;
int fa[mn],son[mn][2],maxl[mn],minl[mn],maxr[mn],minr[mn],sum[mn],tree[mn],S[mn],a[mn];
bool tag1[mn],tag2[mn];
int n,m,aa,bb,x,i,root,kind;
char ch;
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
int max(int a,int b,int c)
{
	if (a&gt;=b&amp;&amp;a&gt;=c) return a;
	if (b&gt;=a&amp;&amp;b&gt;=c) return b;
	return c;
}
int min(int a,int b,int c) {return -max(-a,-b,-c);}
void make1(int t)
{
	tag1[t]=!tag1[t];
	tree[t]=-tree[t];
	sum[t]=-sum[t];
	swap(maxl[t],minl[t]);
	maxl[t]=-maxl[t];
	minl[t]=-minl[t];
	swap(maxr[t],minr[t]);
	maxr[t]=-maxr[t];
	minr[t]=-minr[t];
}
void make2(int t)
{
	tag2[t]=!tag2[t];
	swap(maxl[t],maxr[t]);
	swap(minl[t],minr[t]);
	swap(son[t][0],son[t][1]);
}
void update(int t)
{
	int x=son[t][0],y=son[t][1];
	S[t]=S[x]+S[y]+1;
	sum[t]=sum[x]+sum[y]+tree[t];
	maxl[t]=max(maxl[x],sum[x]+tree[t],sum[x]+tree[t]+maxl[y]);
	minl[t]=min(minl[x],sum[x]+tree[t],sum[x]+tree[t]+minl[y]);
	maxr[t]=max(maxr[y],sum[y]+tree[t],sum[y]+tree[t]+maxr[x]);
	minr[t]=min(minr[y],sum[y]+tree[t],sum[y]+tree[t]+minr[x]);
}
void pushdown(int t)
{
	if (tag1[t])
	{
		if (son[t][0]) make1(son[t][0]);
		if (son[t][1]) make1(son[t][1]);
		tag1[t]=0;
	}
	if (tag2[t])
	{
		if (son[t][0]) make2(son[t][0]);
		if (son[t][1]) make2(son[t][1]);
		tag2[t]=0;
	}
}
int build(int ll,int rr)
{
	int mid=(ll+rr)&gt;&gt;1;
	tree[mid]=a[mid-1];
	tag1[mid]=0,tag2[mid]=0;
	if (ll&lt;mid)
	{
		int x=build(ll,mid-1);
		fa[x]=mid;
		son[mid][0]=x;
	}
	if (mid&lt;rr)
	{
		int x=build(mid+1,rr);
		fa[x]=mid;
		son[mid][1]=x;
	}
	update(mid);
	return mid;
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
	update(y),update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
}
int find(int t,int x)
{
	for (;t;)
	{
		pushdown(t);
		if (x==S[son[t][0]]+1) return t;
		if (x&lt;=S[son[t][0]]) t=son[t][0];
		else x-=(S[son[t][0]]+1),t=son[t][1];
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%c&quot;,&amp;ch);
		a[i]=ch=='('?1:-1;
	}
	S[0]=0,sum[0]=0,maxl[0]=-inf,minl[0]=inf,maxr[0]=-inf,minr[0]=inf;
	root=build(1,n+2);
	for (;m;m--)
	{
		scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;aa,&amp;bb);
		++aa,++bb;
		int x=find(root,aa-1);
		splay(x,0);
		x=find(root,bb+1);
		splay(x,root);
		x=son[x][0];
		if (kind==0) printf(&quot;%d\n&quot;,(maxr[x]+1)/2+(-minl[x]+1)/2);
		else if (kind==1) make1(x),splay(x,0);
		else make2(x),splay(x,0);
	}
	return 0;
}<pre><h2>Problem2209</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int mn=110000,inf=99999999;
int fa[mn],son[mn][2],maxl[mn],minl[mn],maxr[mn],minr[mn],sum[mn],tree[mn],S[mn],a[mn];
bool tag1[mn],tag2[mn];
int n,m,aa,bb,x,i,root,kind;
char ch;
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
int max(int a,int b,int c)
{
    if (a&gt;=b&amp;&amp;a&gt;=c) return a;
    if (b&gt;=a&amp;&amp;b&gt;=c) return b;
    return c;
}
int min(int a,int b,int c) {return -max(-a,-b,-c);}
void make1(int t)
{
    tag1[t]=!tag1[t];
    tree[t]=-tree[t];
    sum[t]=-sum[t];
    swap(maxl[t],minl[t]);
    maxl[t]=-maxl[t];
    minl[t]=-minl[t];
    swap(maxr[t],minr[t]);
    maxr[t]=-maxr[t];
    minr[t]=-minr[t];
}
void make2(int t)
{
    tag2[t]=!tag2[t];
    swap(maxl[t],maxr[t]);
    swap(minl[t],minr[t]);
    swap(son[t][0],son[t][1]);
}
void update(int t)
{
    int x=son[t][0],y=son[t][1];
    S[t]=S[x]+S[y]+1;
    sum[t]=sum[x]+sum[y]+tree[t];
    maxl[t]=max(maxl[x],sum[x]+tree[t],sum[x]+tree[t]+maxl[y]);
    minl[t]=min(minl[x],sum[x]+tree[t],sum[x]+tree[t]+minl[y]);
    maxr[t]=max(maxr[y],sum[y]+tree[t],sum[y]+tree[t]+maxr[x]);
    minr[t]=min(minr[y],sum[y]+tree[t],sum[y]+tree[t]+minr[x]);
}
void pushdown(int t)
{
    if (tag1[t])
    {
        if (son[t][0]) make1(son[t][0]);
        if (son[t][1]) make1(son[t][1]);
        tag1[t]=0;
    }
    if (tag2[t])
    {
        if (son[t][0]) make2(son[t][0]);
        if (son[t][1]) make2(son[t][1]);
        tag2[t]=0;
    }
}
int build(int ll,int rr)
{
    int mid=(ll+rr)&gt;&gt;1;
    tree[mid]=a[mid-1];
    tag1[mid]=0,tag2[mid]=0;
    if (ll&lt;mid)
    {
        int x=build(ll,mid-1);
        fa[x]=mid;
        son[mid][0]=x;
    }
    if (mid&lt;rr)
    {
        int x=build(mid+1,rr);
        fa[x]=mid;
        son[mid][1]=x;
    }
    update(mid);
    return mid;
}
void rotate(int t,int p)
{
    int y=fa[t];
    fa[t]=fa[y];
    if (fa[y])
        if (y==son[fa[y]][0]) son[fa[y]][0]=t;
        else son[fa[y]][1]=t;
    son[y][p^1]=son[t][p];
    if (son[t][p]) fa[son[t][p]]=y;
    fa[y]=t;
    son[t][p]=y;
    update(y);
}
void splay(int t,int ff)
{
    pushdown(t);
    while (fa[t]!=ff)
    {
        int y=fa[t];
        if (fa[y]==ff)
            if (t==son[y][0]) rotate(t,1);
            else rotate(t,0);
        else
            if (y==son[fa[y]][0])
                if (t==son[y][0]) rotate(y,1),rotate(t,1);
                else rotate(t,0),rotate(t,1);
            else
                if (t==son[y][1]) rotate(y,0),rotate(t,0);
                else rotate(t,1),rotate(t,0);
    }
    if (ff==0) root=t;
    update(t);
}
int find(int t,int x)
{
    for (;t;)
    {
        pushdown(t);
        if (x==S[son[t][0]]+1) return t;
        if (x&lt;=S[son[t][0]]) t=son[t][0];
        else x-=(S[son[t][0]]+1),t=son[t][1];
    }
}
int main()
{
    scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
    for (i=1;i&lt;=n;i++)
    {
        scanf(&quot;%c&quot;,&amp;ch);
        a[i]=ch=='('?1:-1;
    }
    S[0]=0,sum[0]=0,maxl[0]=-inf,minl[0]=inf,maxr[0]=-inf,minr[0]=inf;
    root=build(1,n+2);
    for (;m;m--)
    {
        scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;aa,&amp;bb);
        ++aa,++bb;
        int x=find(root,aa-1);
        splay(x,0);
        x=find(root,bb+1);
        splay(x,root);
        x=son[x][0];
        if (kind==0) printf(&quot;%d\n&quot;,(maxr[x]+1)/2+(-minl[x]+1)/2);
        else if (kind==1) make1(x);
        else make2(x);
    }
    return 0;
}<pre><h2>Problem2212</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define mii(a,b) (a&lt;b?a:b)
const int NN=401111,AA=4000000;
int lc[NN],rc[NN],w[NN],b[NN],rt[NN],son[AA][2],size[AA];
int n,TTT,cnt,root;
LL ans0,ans1;
void init(int &amp;v)
{
	v=++TTT;
	int x;
	scanf(&quot;%d&quot;,&amp;x);
	if (x==0)
	{
		init(lc[v]);
		init(rc[v]);
	}
	else
	{
		b[++cnt]=x;
		w[v]=x;
	}
}
int cha(int x)
{
	int l=1,r=cnt;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (b[mid]==x) return mid;
		if (x&lt;b[mid]) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
void ins(int &amp;v,int l,int r,int x)
{
	if (v==0) v=++TTT;
	size[v]++;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid) ins(son[v][0],l,mid,x);
	else ins(son[v][1],mid,r,x);
}
int merge(int x,int y,int l,int r)
{
	if (!x||!y) return x+y;
	size[x]+=size[y];
	if (r-l==1) return x;
	int mid=(l+r)&gt;&gt;1;
	ans0+=(LL)size[son[x][1]]*size[son[y][0]];
	ans1+=(LL)size[son[y][1]]*size[son[x][0]];
	son[x][0]=merge(son[x][0],son[y][0],l,mid);
	son[x][1]=merge(son[x][1],son[y][1],mid,r);
	return x;
}
LL work(int v)
{
	if (w[v])
	{
		ins(rt[v],1,cnt+1,w[v]);
		return 0;
	}
	LL res=work(lc[v])+work(rc[v]);
	ans0=0,ans1=0;
	rt[v]=merge(rt[lc[v]],rt[rc[v]],1,cnt+1);
	return res+mii(ans0,ans1);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	init(root);
	sort(b+1,b+cnt+1);
	cnt=unique(b+1,b+cnt+1)-(b+1);
	for (int i=1;i&lt;=n&lt;&lt;1;i++)
		if (w[i]) w[i]=cha(w[i]);
	TTT=0;
	printf(&quot;%lld\n&quot;,work(root));
	return 0;
}<pre><h2>Problem2212</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define mii(a,b) (a&lt;b?a:b)
const int NN=401111,AA=4000000;
int lc[NN],rc[NN],w[NN],b[NN],rt[NN],son[AA][2],size[AA];
int n,TTT,cnt,root,x;
LL ans0,ans1;
void init(int &amp;v)
{
	v=++TTT;
	scanf(&quot;%d&quot;,&amp;x);
	if (x==0)
	{
		init(lc[v]);
		init(rc[v]);
	}
	else
	{
		b[++cnt]=x;
		w[v]=x;
	}
}
int cha(int x)
{
	int l=1,r=cnt;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (b[mid]==x) return mid;
		if (x&lt;b[mid]) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
void ins(int &amp;v,int l,int r,int x)
{
	if (v==0) v=++TTT;
	size[v]++;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid) ins(son[v][0],l,mid,x);
	else ins(son[v][1],mid,r,x);
}
int merge(int x,int y,int l,int r)
{
	if (!x||!y) return x+y;
	size[x]+=size[y];
	if (r-l==1) return x;
	int mid=(l+r)&gt;&gt;1;
	ans0+=(LL)size[son[x][1]]*size[son[y][0]];
	ans1+=(LL)size[son[y][1]]*size[son[x][0]];
	son[x][0]=merge(son[x][0],son[y][0],l,mid);
	son[x][1]=merge(son[x][1],son[y][1],mid,r);
	return x;
}
LL work(int v)
{
	if (w[v])
	{
		ins(rt[v],1,cnt+1,w[v]);
		return 0;
	}
	LL res=work(lc[v])+work(rc[v]);
	ans0=0,ans1=0;
	rt[v]=merge(rt[lc[v]],rt[rc[v]],1,cnt+1);
	return res+mii(ans0,ans1);
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	init(root);
	sort(b+1,b+cnt+1);
	cnt=unique(b+1,b+cnt+1)-(b+1);
	for (int i=1;i&lt;=n&lt;&lt;1;i++)
		if (w[i]) w[i]=cha(w[i]);
	TTT=0;
	printf(&quot;%lld\n&quot;,work(root));
	return 0;
}<pre><h2>Problem2219</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;iostream&gt;
using namespace std;
typedef long long LL;
const LL INF=1e17;
LL ksm(LL a,LL b,LL c=INF)
{
	LL res=1;
	for (;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
LL gcd(LL a,LL b) {return !b?a:gcd(b,a%b);}
LL getphi(LL n)
{
	LL res=1;
	for (int i=2;i*i&lt;=n;i++) if (n%i==0)
	{
		res*=i-1;
		for (n/=i;n%i==0;n/=i) res*=i;
	}
	if (n&gt;1) res*=n-1;
	return res;
}
LL getyg(LL p,LL phi)
{
	static LL ys[1000000];
	int cnt=0;
	for (int i=2;i*i&lt;=phi;i++) if (phi%i==0)
	{
		ys[++cnt]=i;
		if (i*i!=phi) ys[++cnt]=phi/i;
	}
	for (int i=2;;i++)
	{
		bool ok=true;
		for (int j=1;j&lt;=cnt;j++)
			if (ksm(i,ys[j],p)==1) {ok=false;break;}
		if (ok) return i;
	}
	return 0;
}
struct HT
{
	int tot,mod,TIME;
	int o[1000007],aa0[1000000],vt[1000007];
	LL aa1[1000000],f[1000000];
	HT() {mod=1000007;}
	void clear() {TIME++;tot=0;}
	void insert(LL x,LL y)
	{
		int t=x%mod;
		if (vt[t]!=TIME) vt[t]=TIME,o[t]=0;
		for (int p=o[t];p;p=aa0[p])
			if (aa1[p]==x)
			{
				f[p]=min(f[p],y);
				return;
			}
		tot++;aa1[tot]=x;f[tot]=y;
		aa0[tot]=o[t];o[t]=tot;
	}
	LL find(LL x)
	{
		int t=x%mod;
		if (vt[t]!=TIME) vt[t]=TIME,o[t]=0;
		for (int p=o[t];p;p=aa0[p])
			if (aa1[p]==x) return f[p];
		return -1;
	}
} ht;
LL bsgs(LL A,LL B,LL P,LL phi)
{
	B%=P;
	ht.clear();
	LL blo=sqrt(P)+1,tmp=1,i;
	for (i=0;i&lt;blo;i++)
	{
		ht.insert(tmp,i);
		tmp=tmp*A%P;
	}
	for (i=0;i&lt;blo;i++)
	{
		tmp=ksm(A,i*blo,P);
		tmp=B*ksm(tmp,phi-1,P)%P;
		if (tmp==0) return B==0?i*blo:-1;
		LL t=ht.find(tmp);
		if (t!=-1) return i*blo+t;
	}
	return -1;
}
LL extbsgs(LL A,LL B,LL P)
{
	B%=P;
	LL tmp=1;
	for (LL i=0;i&lt;=50;i++)
	{
		if (tmp==B) return i;
		tmp=tmp*A%P;
	}
	LL K=gcd(tmp,P);
	if (B%K) return -1;
	LL phi=getphi(P/K);
	LL ans=bsgs(A,B/K*ksm(tmp/K,phi-1,P),P/K,phi);
	return ans==-1?-1:ans+51;
}
LL work(LL A,LL B,LL p,LL s)
{
	LL pp=ksm(p,s);
	B%=pp;
	if (B==0) return ksm(p,s-((s-1)/A+1));
	LL cheng=1;
	if (gcd(B,p)!=1)
	{
		LL t=0;
		for (;B%p==0;B/=p) t++;
		if (t%A) return 0;
		cheng=ksm(p,t-t/A);
		s-=t;
	}
	LL phi=pp-pp/p;
	LL g=getyg(pp,phi);
	LL y=extbsgs(g,B,pp);
	if (y==-1) return 0;
	LL tmp=gcd(A,phi);
	if (y%tmp) return 0;
	return cheng*tmp;
}
int main()
{
	int tes;
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		LL A,B,P;
		cin&gt;&gt;A&gt;&gt;B&gt;&gt;P;
		P=2*P+1;
		LL ans=1;
		for (LL i=2;i*i&lt;=P;i++) if (P%i==0)
		{
			LL t=0;
			for (;P%i==0;P/=i) t++;
			ans*=work(A,B,i,t);
			if (ans==0) break;
		}
		if (ans&gt;0&amp;&amp;P&gt;1) ans*=work(A,B,P,1);
		cout&lt;&lt;ans&lt;&lt;endl;
	}
	return 0;
}<pre><h2>Problem2228</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int a[220][220][220],f[220][220][220],b[220][220][220],P,Q,R,i,j,k,ans,aa[220],stack[220],left[220],right[220];
int min(int a,int b) {return a&lt;b?a:b;}
int max(int a,int b) {return a&gt;b?a:b;}
char readchar() {char ch='1';while (ch!='N'&amp;&amp;ch!='P') ch=getchar();return ch;}
int calc(int P,int Q,int R)
{
	int i,j,k;
	//printf(&quot;%d %d %d\n&quot;,P,Q,R);
	//for (i=1;i&lt;=P;i++) for (j=1;j&lt;=Q;j++) {for (k=1;k&lt;=R;k++) printf(&quot;%d&quot;,a[i][j][k]);printf(&quot;\n&quot;);}
	memset(f,0,sizeof(f));
	for (i=1;i&lt;=P;i++)
		for (j=Q;j;j--)
			for (k=1;k&lt;=R;k++)
			{
				if (a[i][j][k]==0) f[i][j][k]=0;
				else f[i][j][k]=min(min(f[i][j][k-1],f[i][j+1][k]),f[i][j+1][k-1])+1;
				//printf(&quot;%d %d %d %d\n&quot;,i,j,k,f[i][j][k]);
			}
	int res=0;
	memset(left,0,sizeof(left));
	memset(right,127,sizeof(right));
	for (j=1;j&lt;=Q;j++)
		for (k=1;k&lt;=R;k++)
		{
			for (i=1;i&lt;=P;i++) aa[i]=f[i][j][k];
			aa[0]=0;
			int top=0;
			stack[top]=0;
			for (i=1;i&lt;=P;i++)
			{
				while (aa[i]&lt;aa[stack[top]])
				{
					right[stack[top]]=i-1;
					top--;
				}
				left[i]=stack[top]+1;
				stack[++top]=i;
			}
			while (top&gt;0) right[stack[top--]]=P;
			for (i=1;i&lt;=P;i++)
				res=max(res,aa[i]*(right[i]-left[i]+1));
		}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;P,&amp;Q,&amp;R);
	for (j=1;j&lt;=Q;j++)
		for (i=1;i&lt;=P;i++)
			for (k=1;k&lt;=R;k++) a[i][j][k]=(readchar()=='N'?1:0),b[i][j][k]=a[i][j][k];
	ans=max(ans,calc(P,Q,R));//P层，Q行R列
	//printf(&quot;%d\n&quot;,4*ans);
	for (i=1;i&lt;=P;i++)
		for (j=1;j&lt;=Q;j++)
			for (k=1;k&lt;=R;k++)
				a[j][i][k]=b[i][j][k]; 
	ans=max(ans,calc(Q,P,R));
	//printf(&quot;%d\n&quot;,4*ans);
	for (i=1;i&lt;=P;i++)
		for (j=1;j&lt;=Q;j++)
			for (k=1;k&lt;=R;k++)
				a[k][i][j]=b[i][j][k];
	ans=max(ans,calc(R,P,Q));
	printf(&quot;%d\n&quot;,4*ans);
	return 0;
}
<pre><h2>Problem2228</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int a[220][220][220],f[220][220][220],b[220][220][220],P,Q,R,i,j,k,ans,aa[220],stack[220],left[220],right[220];
inline int min(int a,int b) {return a&lt;b?a:b;}
inline int max(int a,int b) {return a&gt;b?a:b;}
char readchar() {char ch='1';while (ch!='N'&amp;&amp;ch!='P') ch=getchar();return ch;}
int calc(int P,int Q,int R)
{
	int i,j,k;
	memset(f,0,sizeof(f));
	for (i=1;i&lt;=P;i++)
		for (j=Q;j;j--)
			for (k=1;k&lt;=R;k++)
			{
				if (a[i][j][k]==0) f[i][j][k]=0;
				else f[i][j][k]=min(min(f[i][j][k-1],f[i][j+1][k]),f[i][j+1][k-1])+1;
			}
	int res=0;
	memset(left,0,sizeof(left));
	memset(right,127,sizeof(right));
	for (j=1;j&lt;=Q;j++)
		for (k=1;k&lt;=R;k++)
		{
			for (i=1;i&lt;=P;i++) aa[i]=f[i][j][k];
			aa[0]=0;
			int top=0;
			stack[top]=0;
			for (i=1;i&lt;=P;i++)
			{
				while (aa[i]&lt;aa[stack[top]])
				{
					right[stack[top]]=i-1;
					top--;
				}
				left[i]=stack[top]+1;
				stack[++top]=i;
			}
			while (top&gt;0) right[stack[top--]]=P;
			for (i=1;i&lt;=P;i++)
				res=max(res,aa[i]*(right[i]-left[i]+1));
		}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int P,Q,R;
	scanf(&quot;%d%d%d&quot;,&amp;P,&amp;Q,&amp;R);
	for (j=1;j&lt;=Q;j++)
		for (i=1;i&lt;=P;i++)
			for (k=1;k&lt;=R;k++) a[i][j][k]=(readchar()=='N'?1:0),b[i][j][k]=a[i][j][k];
	ans=max(ans,calc(P,Q,R));//P层，Q行R列
	for (i=1;i&lt;=P;i++)
		for (j=1;j&lt;=Q;j++)
			for (k=1;k&lt;=R;k++)
				a[j][i][k]=b[i][j][k]; 
	ans=max(ans,calc(Q,P,R));
	for (i=1;i&lt;=P;i++)
		for (j=1;j&lt;=Q;j++)
			for (k=1;k&lt;=R;k++)
				a[k][i][j]=b[i][j][k];
	ans=max(ans,calc(R,P,Q));
	printf(&quot;%d\n&quot;,4*ans);
	return 0;
}
<pre><h2>Problem2229</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 1505
#define MM 31011
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define inf 999999999
#define ln printf(&quot;\n&quot;)
int q[NN],deep[NN],o[NN],id[NN],q2[NN],vt[NN],mincut[NN][NN],aa[MM*2][3],bb[MM*2][3];
int n,m,SS,TT,tot,TIME,tes;
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);printf(&quot;\n&quot;);}
void out(){for(int i=1;i&lt;=n;i++){for(int j=1;j&lt;=n;j++)printf(&quot;%d &quot;,mincut[i][j]);ln;}}
bool bfs()
{
	int head=0,tail=1,p,x,y;
	memset(deep,0,4*(n+10));
	deep[SS]=1;
	q[1]=SS;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	//printf(&quot;deep &quot;);out(deep,1,n);
	return deep[TT];
}
int dfs(int v,int ff)
{
	if (v==TT) return ff;
	int res=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(aa[p][2],ff));
		if (tmp==0) deep[y]=inf;
		ff-=tmp;
		aa[p][2]-=tmp;
		aa[p^1][2]+=tmp;
		res+=tmp;
		if (!ff) break;
	}
	return res;
}
int dinic(int S,int T)
{
	//printf(&quot;=====dinic(%d,%d)=====\n&quot;,S,T);
	SS=S,TT=T;
	int res=0;
	while (bfs()) res+=dfs(SS,inf);
	//printf(&quot;=====dinic end with res=%d=====\n&quot;,res);
	return res;
}
void solve(int l,int r)
{
	//printf(&quot;--------------- solve %d %d -------------------\n&quot;,l,r);
	if (l==r) return;
	int head,tail,x,p,y,i,t,j,res;
	for (i=1;i&lt;=tot;i++)
	{
		aa[i][1]=bb[i][1];
		aa[i][2]=bb[i][2];
		aa[i][0]=bb[i][0];
	}
	mincut[id[l]][id[r]]=res=dinic(id[l],id[r]);
	//printf(&quot;mincut[%d][%d]=%d\n&quot;,id[l],id[r],res);
	head=0,q[tail=1]=id[l];
	TIME++;
	vt[id[l]]=TIME;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;vt[y]!=TIME) vt[y]=TIME,q[++tail]=y;
		}
	}
	//printf(&quot;vt &quot;);out(vt,1,n);
	t=0;
	for (i=1;i&lt;=n;i++)
		if (vt[i]!=TIME) q2[++t]=i;
	for (i=1;i&lt;=tail;i++)
		for (j=1;j&lt;=t;j++)
			mincut[q[i]][q2[j]]=mincut[q2[j]][q[i]]=mii(mincut[q[i]][q2[j]],res);
	//out();
	memset(q,0,sizeof(q));memset(q2,0,sizeof(q2));//dddddddddddddddddddddddddddddddddd
	tail=t=0;
	for (i=l;i&lt;=r;i++)
		if (vt[id[i]]==TIME) q[++tail]=id[i];
		else q2[++t]=id[i];
	//printf(&quot;q &quot;);out(q,1,n);printf(&quot;q2 &quot;);out(q2,1,n);
	i=l;
	for (j=1;j&lt;=tail;j++) id[i++]=q[j];
	for (j=1;j&lt;=t;j++) id[i++]=q2[j];
	//printf(&quot;id &quot;);out(id,1,n);
	solve(l,l+tail-1);
	solve(l+tail,r);
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=bb[tot][1]=q;
	aa[tot][2]=bb[tot][2]=v;
	aa[tot][0]=bb[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--,ln)
	{
		//printf(&quot;\n------------------------------------------------------------\n&quot;);
		memset(mincut,127,sizeof(mincut));
		memset(o,0,sizeof(o));
		tot=1;
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		int i,j,x,y,z,ask;
		for (i=1;i&lt;=m;i++)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			addedge(x,y,z);
			addedge(y,x,z);
		}
		for (i=1;i&lt;=n;i++) id[i]=i;
		solve(1,n);
		//for (i=1;i&lt;=n;i++){for(j=1;j&lt;=n;j++) printf(&quot;%d &quot;,mincut[i][j]);ln;}
		for (scanf(&quot;%d&quot;,&amp;ask);ask;ask--)
		{
			scanf(&quot;%d&quot;,&amp;x);
			int ans=0;
			for (i=1;i&lt;n;i++)
				for (j=i+1;j&lt;=n;j++)
					if (mincut[i][j]&lt;=x) ans++;
			printf(&quot;%d\n&quot;,ans);
		}
	}
	return 0;
}
<pre><h2>Problem2229</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 1545
#define MM 3111
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define inf 999999999
#define ln printf(&quot;\n&quot;)
int q[NN],deep[NN],o[NN],id[NN],q2[NN],vt[NN],mincut[NN][NN],aa[MM*2][3],bb[MM*2][3];
int n,m,SS,TT,tot,TIME,tes;
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);printf(&quot;\n&quot;);}
void out(){for(int i=1;i&lt;=n;i++){for(int j=1;j&lt;=n;j++)printf(&quot;%d &quot;,mincut[i][j]);ln;}}
bool bfs()
{
	int head=0,tail=1,p,x,y;
	memset(deep,0,4*(n+10));
	deep[SS]=1;
	q[1]=SS;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	//printf(&quot;deep &quot;);out(deep,1,n);
	return deep[TT];
}
int dfs(int v,int ff)
{
	if (v==TT) return ff;
	int res=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(aa[p][2],ff));
		if (tmp==0) deep[y]=inf;
		ff-=tmp;
		aa[p][2]-=tmp;
		aa[p^1][2]+=tmp;
		res+=tmp;
		if (!ff) break;
	}
	return res;
}
int dinic(int S,int T)
{
	//printf(&quot;=====dinic(%d,%d)=====\n&quot;,S,T);
	SS=S,TT=T;
	int res=0;
	while (bfs()) res+=dfs(SS,inf);
	//printf(&quot;=====dinic end with res=%d=====\n&quot;,res);
	return res;
}
void solve(int l,int r)
{
	//printf(&quot;--------------- solve %d %d -------------------\n&quot;,l,r);
	if (l==r) return;
	int head,tail,x,p,y,i,t,j,res;
	for (i=1;i&lt;=tot;i++)
	{
		aa[i][1]=bb[i][1];
		aa[i][2]=bb[i][2];
		aa[i][0]=bb[i][0];
	}
	mincut[id[l]][id[r]]=res=dinic(id[l],id[r]);
	//printf(&quot;mincut[%d][%d]=%d\n&quot;,id[l],id[r],res);
	head=0,q[tail=1]=id[l];
	TIME++;
	vt[id[l]]=TIME;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;vt[y]!=TIME) vt[y]=TIME,q[++tail]=y;
		}
	}
	//printf(&quot;vt &quot;);out(vt,1,n);
	t=0;
	for (i=1;i&lt;=n;i++)
		if (vt[i]!=TIME) q2[++t]=i;
	for (i=1;i&lt;=tail;i++)
		for (j=1;j&lt;=t;j++)
			mincut[q[i]][q2[j]]=mincut[q2[j]][q[i]]=mii(mincut[q[i]][q2[j]],res);
	//out();
	memset(q,0,sizeof(q));memset(q2,0,sizeof(q2));//dddddddddddddddddddddddddddddddddd
	tail=t=0;
	for (i=l;i&lt;=r;i++)
		if (vt[id[i]]==TIME) q[++tail]=id[i];
		else q2[++t]=id[i];
	//printf(&quot;q &quot;);out(q,1,n);printf(&quot;q2 &quot;);out(q2,1,n);
	i=l;
	for (j=1;j&lt;=tail;j++) id[i++]=q[j];
	for (j=1;j&lt;=t;j++) id[i++]=q2[j];
	//printf(&quot;id &quot;);out(id,1,n);
	solve(l,l+tail-1);
	solve(l+tail,r);
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=bb[tot][1]=q;
	aa[tot][2]=bb[tot][2]=v;
	aa[tot][0]=bb[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--,ln)
	{
		//printf(&quot;\n------------------------------------------------------------\n&quot;);
		memset(mincut,127,sizeof(mincut));
		memset(o,0,sizeof(o));
		tot=1;
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		int i,j,x,y,z,ask;
		for (i=1;i&lt;=m;i++)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			addedge(x,y,z);
			addedge(y,x,z);
		}
		for (i=1;i&lt;=n;i++) id[i]=i;
		solve(1,n);
		//for (i=1;i&lt;=n;i++){for(j=1;j&lt;=n;j++) printf(&quot;%d &quot;,mincut[i][j]);ln;}
		for (scanf(&quot;%d&quot;,&amp;ask);ask;ask--)
		{
			scanf(&quot;%d&quot;,&amp;x);
			int ans=0;
			for (i=1;i&lt;n;i++)
				for (j=i+1;j&lt;=n;j++)
					if (mincut[i][j]&lt;=x) ans++;
			printf(&quot;%d\n&quot;,ans);
		}
	}
	return 0;
}
<pre><h2>Problem2229</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 155
#define MM 3111
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define inf 999999999
#define ln printf(&quot;\n&quot;)
int q[NN],deep[NN],o[NN],id[NN],q2[NN],vt[NN],mincut[NN][NN],aa[MM*2][3],bb[MM*2][3];
int n,m,SS,TT,tot,TIME,tes;
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);printf(&quot;\n&quot;);}
void out(){for(int i=1;i&lt;=n;i++){for(int j=1;j&lt;=n;j++)printf(&quot;%d &quot;,mincut[i][j]);ln;}}
bool bfs()
{
	int head=0,tail=1,p,x,y;
	memset(deep,0,sizeof(deep));
	deep[SS]=1;
	q[1]=SS;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	//printf(&quot;deep &quot;);out(deep,1,n);
	return deep[TT];
}
int dfs(int v,int ff)
{
	if (v==TT) return ff;
	int res=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(aa[p][2],ff));
		if (tmp==0) deep[y]=inf;
		ff-=tmp;
		aa[p][2]-=tmp;
		aa[p^1][2]+=tmp;
		res+=tmp;
		if (!ff) break;
	}
	return res;
}
int dinic(int S,int T)
{
	//printf(&quot;=====dinic(%d,%d)=====\n&quot;,S,T);
	SS=S,TT=T;
	int res=0;
	while (bfs()) res+=dfs(SS,inf);
	//printf(&quot;=====dinic end with res=%d=====\n&quot;,res);
	return res;
}
void solve(int l,int r)
{
	//printf(&quot;--------------- solve %d %d -------------------\n&quot;,l,r);
	if (l==r) return;
	int head,tail,x,p,y,i,t,j,res;
	for (i=1;i&lt;=tot;i++)
	{
		aa[i][1]=bb[i][1];
		aa[i][2]=bb[i][2];
		aa[i][0]=bb[i][0];
	}
	mincut[id[l]][id[r]]=res=dinic(id[l],id[r]);
	//printf(&quot;mincut[%d][%d]=%d\n&quot;,id[l],id[r],res);
	head=0,q[tail=1]=id[l];
	TIME++;
	vt[id[l]]=TIME;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;vt[y]!=TIME) vt[y]=TIME,q[++tail]=y;
		}
	}
	//printf(&quot;vt &quot;);out(vt,1,n);
	t=0;
	for (i=1;i&lt;=n;i++)
		if (vt[i]!=TIME) q2[++t]=i;
	for (i=1;i&lt;=tail;i++)
		for (j=1;j&lt;=t;j++)
			mincut[q[i]][q2[j]]=mincut[q2[j]][q[i]]=mii(mincut[q[i]][q2[j]],res);
	//out();
	//memset(q,0,sizeof(q));memset(q2,0,sizeof(q2));//dddddddddddddddddddddddddddddddddd
	tail=t=0;
	for (i=l;i&lt;=r;i++)
		if (vt[id[i]]==TIME) q[++tail]=id[i];
		else q2[++t]=id[i];
	//printf(&quot;q &quot;);out(q,1,n);printf(&quot;q2 &quot;);out(q2,1,n);
	i=l;
	for (j=1;j&lt;=tail;j++) id[i++]=q[j];
	for (j=1;j&lt;=t;j++) id[i++]=q2[j];
	//printf(&quot;id &quot;);out(id,1,n);
	solve(l,l+tail-1);
	solve(l+tail,r);
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=bb[tot][1]=q;
	aa[tot][2]=bb[tot][2]=v;
	aa[tot][0]=bb[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--,ln)
	{
		//printf(&quot;\n------------------------------------------------------------\n&quot;);
		memset(mincut,127,sizeof(mincut));
		memset(o,0,sizeof(o));
		tot=1;
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		int i,j,x,y,z,ask;
		for (i=1;i&lt;=m;i++)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			addedge(x,y,z);
			addedge(y,x,z);
		}
		for (i=1;i&lt;=n;i++) id[i]=i;
		solve(1,n);
		//for (i=1;i&lt;=n;i++){for(j=1;j&lt;=n;j++) printf(&quot;%d &quot;,mincut[i][j]);ln;}
		for (scanf(&quot;%d&quot;,&amp;ask);ask;ask--)
		{
			scanf(&quot;%d&quot;,&amp;x);
			int ans=0;
			for (i=1;i&lt;n;i++)
				for (j=i+1;j&lt;=n;j++)
					if (mincut[i][j]&lt;=x) ans++;
			printf(&quot;%d\n&quot;,ans);
		}
	}
	return 0;
}
<pre><h2>Problem2229</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 999999999
#define mii(a,b) (a&lt;b?a:b)
#define ln printf(&quot;\n&quot;)
const int NN=155,MM=3111;
int o[NN],cur[NN],aa[MM*2][3],q[NN],deep[NN],id[NN],id1[NN],id2[NN],cut[NN][NN];
int tes,n,m,ask,yuan,hui,tot;
bool vt[NN];
void out(int*a,int l,int r){for(int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);ln;}
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
struct edge
{
	int u,v,c;
	void in() {scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;c);}
	void add() {addedge(u,v,c),addedge(v,u,c);}
} e[MM];
bool bfs()
{
	int head=0,tail=1;
	q[1]=yuan;
	memset(deep,0,sizeof(deep));
	deep[yuan]=1;
	while (head&lt;tail)
	{
		int x=q[++head];
		cur[x]=o[x];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y])
				deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[hui];
}
int dfs(int v,int ff)
{
	if (v==hui) return ff;
	int res=0;
	for (int &amp;p=cur[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(aa[p][2],ff));
		ff-=tmp,aa[p][2]-=tmp;
		aa[p^1][2]+=tmp,res+=tmp;
		if (ff==0) break;
	}
	if (res==0) deep[v]=inf;
	return res;
}
int dinic(int S,int T)
{
	yuan=S,hui=T;
	int res=0;
	while (bfs()) res+=dfs(yuan,inf);
	return res;
}
void dfs2(int v)
{
	vt[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (vt[y]||!aa[p][2]) continue;
		dfs2(y);
	}
}
void work(int l,int r)
{
	if (l&gt;=r) return;
	//printf(&quot;\n----------------------- work %d %d --------------------------------------\n&quot;,l,r);out(id,l,r);
	memset(o,0,sizeof(o));tot=1;
	int i,j,k;
	for (i=1;i&lt;=m;i++) e[i].add();
	int S=id[l],T=id[r];
	int res=dinic(S,T);
	int n1=0,n2=0;
	memset(vt,0,sizeof(vt));
	dfs2(S);
	for (i=1;i&lt;=n;i++)
		if (vt[i]) id1[++n1]=i;
		else id2[++n2]=i;
	for (i=1;i&lt;=n1;i++)
		for (j=1;j&lt;=n2;j++)
		{
			int x=id1[i],y=id2[j];
			if (res&lt;cut[x][y]) cut[x][y]=cut[y][x]=res;
		}
	n1=n2=0;
	for (i=l;i&lt;=r;i++)
		if (vt[id[i]]) id1[++n1]=id[i];
		else id2[++n2]=id[i];
	for (k=l,i=1;i&lt;=n1;i++) id[k++]=id1[i];
	for (j=1;j&lt;=n2;j++) id[k++]=id2[j];
	work(l,l+n1-1);
	work(l+n1,r);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--,printf(&quot;\n&quot;))
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		int i,j,x;
		for (i=1;i&lt;=m;i++) e[i].in();
		for (i=1;i&lt;=n;i++) id[i]=i;
		memset(cut,60,sizeof(cut));
		work(1,n);
		//ln;for(i=1;i&lt;=n;i++){for(j=1;j&lt;=n;j++)printf(&quot;%d &quot;,cut[i][j]);ln;}ln;
		for (scanf(&quot;%d&quot;,&amp;ask);ask;ask--)
		{
			scanf(&quot;%d&quot;,&amp;x);
			int ans=0;
			for (i=1;i&lt;n;i++) for (j=i+1;j&lt;=n;j++)
				if (cut[i][j]&lt;=x) ans++;
			printf(&quot;%d\n&quot;,ans);
		}
	}
	return 0;
}<pre><h2>Problem2229</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 999999999
#define mii(a,b) (a&lt;b?a:b)
const int NN=155,MM=3111;
int o[NN],cur[NN],aa[MM*2][3],q[NN],deep[NN],id[NN],id1[NN],id2[NN],cut[NN][NN];
int tes,n,m,ask,yuan,hui,tot;
bool vt[NN];
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
struct edge
{
	int u,v,c;
	void in() {scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;c);}
	void add() {addedge(u,v,c),addedge(v,u,c);}
} e[MM];
bool bfs()
{
	int head=0,tail=1;
	q[1]=yuan;
	memset(deep,0,sizeof(deep));
	deep[yuan]=1;
	while (head&lt;tail)
	{
		int x=q[++head];
		cur[x]=o[x];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y])
				deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[hui];
}
int dfs(int v,int ff)
{
	if (v==hui) return ff;
	int res=0;
	for (int &amp;p=cur[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(aa[p][2],ff));
		ff-=tmp,aa[p][2]-=tmp;
		aa[p^1][2]+=tmp,res+=tmp;
		if (ff==0) break;
	}
	if (res==0) deep[v]=inf;
	return res;
}
int dinic(int S,int T)
{
	yuan=S,hui=T;
	int res=0;
	while (bfs()) res+=dfs(yuan,inf);
	return res;
}
void dfs2(int v)
{
	vt[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (vt[y]||!aa[p][2]) continue;
		dfs2(y);
	}
}
void work(int l,int r)
{
	if (l&gt;=r) return;
	memset(o,0,sizeof(o));tot=1;
	int i,j,k;
	for (i=1;i&lt;=m;i++) e[i].add();
	int S=id[l],T=id[r];
	int res=dinic(S,T);
	int n1=0,n2=0;
	memset(vt,0,sizeof(vt));
	dfs2(S);
	for (i=1;i&lt;=n;i++)
		if (vt[i]) id1[++n1]=i;
		else id2[++n2]=i;
	for (i=1;i&lt;=n1;i++)
		for (j=1;j&lt;=n2;j++)
		{
			int x=id1[i],y=id2[j];
			if (res&lt;cut[x][y]) cut[x][y]=cut[y][x]=res;
		}
	n1=n2=0;
	for (i=l;i&lt;=r;i++)
		if (vt[id[i]]) id1[++n1]=id[i];
		else id2[++n2]=id[i];
	for (k=l,i=1;i&lt;=n1;i++) id[k++]=id1[i];
	for (j=1;j&lt;=n2;j++) id[k++]=id2[j];
	work(l,l+n1-1);
	work(l+n1,r);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--,printf(&quot;\n&quot;))
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		int i,j,x;
		for (i=1;i&lt;=m;i++) e[i].in();
		for (i=1;i&lt;=n;i++) id[i]=i;
		memset(cut,60,sizeof(cut));
		work(1,n);
		for (scanf(&quot;%d&quot;,&amp;ask);ask;ask--)
		{
			scanf(&quot;%d&quot;,&amp;x);
			int ans=0;
			for (i=1;i&lt;n;i++) for (j=i+1;j&lt;=n;j++)
				if (cut[i][j]&lt;=x) ans++;
			printf(&quot;%d\n&quot;,ans);
		}
	}
	return 0;
}<pre><h2>Problem2229</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 999999999
const int NN=155,MM=3011;
int o[NN],cur[NN],aa[MM&lt;&lt;1][3],deep[NN],id[NN],q1[NN],q2[NN],vt[NN],mincut[NN][NN];
int tes,n,m,Q,tot,yuan,hui,TIME;
inline int min(int a,int b) {return a&lt;b?a:b;}
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
struct edge
{
	int u,v,w;
	inline void in() {scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);}
	inline void add()
	{
		addedge(u,v,w);
		addedge(v,u,w);
	}
} e[MM];
bool bfs()
{
	static int que[NN];
	for (int i=1;i&lt;=n;i++) deep[i]=0;
	deep[yuan]=1;
	int head=0,tail=1;
	que[1]=yuan;
	while (head&lt;tail)
	{
		int x=que[++head];
		cur[x]=o[x];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y])
				deep[y]=deep[x]+1,que[++tail]=y;
		}
	}
	return deep[hui];
}
int dfs(int v,int ff)
{
	if (v==hui) return ff;
	int res=0;
	for (int &amp;p=cur[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,min(ff,aa[p][2]));
		ff-=tmp,aa[p][2]-=tmp;
		aa[p^1][2]+=tmp,res+=tmp;
		if (!ff) break;
	}
	if (!res) deep[v]=inf;
	return res;
}
int dinic(int S,int T)
{
	yuan=S,hui=T;
	int ans=0;
	while (bfs()) ans+=dfs(yuan,inf);
	return ans;
}
void bfs2(int S,int tt)
{
	static int que[NN];
	int head=0,tail=1;
	vt[S]=tt;
	que[1]=S;
	while (head&lt;tail)
	{
		int x=que[++head];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;vt[y]!=tt)
				vt[y]=tt,que[++tail]=y;
		}
	}
}
void work(int l,int r)
{
	if (l&gt;=r) return;
	int i,j;
	for (i=1;i&lt;=n;i++) o[i]=0;
	tot=1;
	for (i=1;i&lt;=m;i++) e[i].add();
	int flow=dinic(id[l],id[r]);
	bfs2(id[l],++TIME);
	int n1=0,n2=0;
	for (i=1;i&lt;=n;i++)
		if (vt[i]==TIME) q1[++n1]=i;
		else q2[++n2]=i;
	for (i=1;i&lt;=n1;i++)
		for (j=1;j&lt;=n2;j++)
		{
			int t1=q1[i],t2=q2[j];
			mincut[t1][t2]=mincut[t2][t1]=min(mincut[t1][t2],flow);
		}
	n1=n2=0;
	for (i=l;i&lt;=r;i++)
		if (vt[id[i]]==TIME) q1[++n1]=id[i];
		else q2[++n2]=id[i];
	j=l;
	for (i=1;i&lt;=n1;i++) id[j++]=q1[i];
	for (i=1;i&lt;=n2;i++) id[j++]=q2[i];
	work(l,l+n1-1);
	work(l+n1,r);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--,printf(&quot;\n&quot;))
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		int i,j,x;
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=n;j++) mincut[i][j]=inf;
		for (i=1;i&lt;=m;i++) e[i].in();
		for (i=1;i&lt;=n;i++) id[i]=i;
		work(1,n);
		for (scanf(&quot;%d&quot;,&amp;Q);Q;Q--)
		{
			scanf(&quot;%d&quot;,&amp;x);
			int ans=0;
			for (i=1;i&lt;=n;i++)
				for (j=i+1;j&lt;=n;j++)
					if (mincut[i][j]&lt;=x) ans++;
			printf(&quot;%d\n&quot;,ans);
		}
	}
	return 0;
}<pre><h2>Problem2241</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int NN=111;
int a[NN][NN],b[NN][NN],n,m,sum,ans;
void check(int R,int C)
{
	//printf(&quot;\n-------------- check %d %d ------------------------------------------------\n&quot;,R,C);
	if (sum%(R*C)) return;
	if (sum/(R*C)&gt;=ans) return;
	int i,j,k,l,tmp;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++) b[i][j]=a[i][j];
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
			if (b[i][j])
			{
				if (i+R-1&gt;n||j+C-1&gt;m) return;
				tmp=b[i][j];
				for (k=i;k&lt;i+R;k++)
					for (l=j;l&lt;j+C;l++)
					{
						if (b[k][l]&lt;tmp) return;
						b[k][l]-=tmp;
					}
			}
	ans=sum/(R*C);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j;
	sum=0;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;a[i][j]),sum+=a[i][j];
	ans=999999999;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++) check(i,j);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem2242</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define LL long long
LL tc,K,a,b,P,x,y,z,i,j,tmp;
LL ksm(LL a,LL b,LL c)
{
    LL res=1;
    for (;b&gt;0;b&gt;&gt;=1,a=a*a%c)
        if (b&amp;1) res=res*a%c;
    return res;
}
LL extgcd(LL a,LL b)
{
    if (b==0)
    {
        x=1,y=0;
        return a;
    }
    LL tmp=extgcd(b,a%b);
    LL i=y;
    y=x-a/b*y;
    x=i;
    return tmp;
}
struct ppt {LL val,id;} f[1000000];
bool cmp(ppt a,ppt b) {return a.val&lt;b.val;}
int main()
{
	//freopen(&quot;2242.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2242.out&quot;,&quot;w&quot;,stdout);
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%lld%lld&quot;,&amp;tc,&amp;K);
    if (K==1)
        for (i=1;i&lt;=tc;i++)
        {
            scanf(&quot;%lld%lld%lld&quot;,&amp;x,&amp;y,&amp;z);
            printf(&quot;%lld\n&quot;,ksm(x,y,z));
        }
    else if (K==2)
        for (i=1;i&lt;=tc;i++)
        {
            scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;P);
            // ax=b (%P)
            // ax+Py=b 
            //ax+by=gcd(a,b);
            //bx'+(a%b)y'=gcd(a,b)
            //bx'+ay'-a/b*b*y'=ax+by
            //x=y'
            //y=x'-a/b*y'
            tmp=extgcd(a,P);
            //printf(&quot;tmp= %d\n&quot;,tmp);
            if (b%tmp!=0) printf(&quot;Orz, I cannot find x!\n&quot;);
            else
            {
                x*=b/tmp,y*=b/tmp;
                LL t=P/tmp;
                x=(x%t+t)%t;
                printf(&quot;%lld\n&quot;,x);
            }
        } 
    else
        for (;tc;tc--)
        {
            scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;P);
            a%=P,b%=P;
            LL m=(int)sqrt(P)+1;
            LL ym=ksm(y,m,P);
            f[0].val=1,f[0].id=0;
            for (i=1;i&lt;m;i++) f[i].val=f[i-1].val*a%P,f[i].id=i;
            //for (i=0;i&lt;=m;i++) printf(&quot;%lld &quot;,f[i].val);printf(&quot;\n&quot;);
            sort(f,f+m,cmp);
            LL num=0;
            for (i=1;i&lt;m;i++)
                if (f[i].val!=f[num].val) f[++num]=f[i];
                else if (f[i].id&lt;f[num].id) f[num].id=f[i].id;
            //for (i=0;i&lt;=m;i++) printf(&quot;%lld &quot;,f[i].id);printf(&quot;\n&quot;);
            //printf(&quot;num=%d\n&quot;,num);
            bool flag=0;
            for (i=0;i&lt;=m;i++)
            {
                tmp=ksm(a,i*m,P);
                if (tmp==0)
                    if (b==0) {printf(&quot;%lld\n&quot;,i*m);flag=1;break;}
                    else break;
                tmp=b*ksm(tmp,P-2,P)%P;
                LL l=0,r=num,res=-1;
                while (l&lt;=r)
                {
                    int mid=(l+r)&gt;&gt;1;
                    if (f[mid].val==tmp) {res=mid;break;}
                    else if (f[mid].val&gt;tmp) r=mid-1;
                    else l=mid+1;
                }
                if (res!=-1)
                {
                    printf(&quot;%lld\n&quot;,i*m+f[res].id);
                    flag=1;
                    break;
                }
            }
            if (!flag) printf(&quot;Orz, I cannot find x!\n&quot;);
        }
    return 0;
}
<pre><h2>Problem2242</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define LL long long
LL tc,K,a,b,P,x,y,z,i,j,tmp;
LL ksm(LL a,LL b,LL c)
{
    LL res=1;
    for (;b&gt;0;b&gt;&gt;=1,a=a*a%c)
        if (b&amp;1) res=res*a%c;
    return res;
}
LL extgcd(LL a,LL b)
{
    if (b==0)
    {
        x=1,y=0;
        return a;
    }
    LL tmp=extgcd(b,a%b);
    LL i=y;
    y=x-a/b*y;
    x=i;
    return tmp;
}
struct ppt {LL val,id;} f[1000000];
bool cmp(ppt a,ppt b) {return a.val&lt;b.val;}
int main()
{
    scanf(&quot;%lld%lld&quot;,&amp;tc,&amp;K);
    if (K==1)
        for (i=1;i&lt;=tc;i++)
        {
            scanf(&quot;%lld%lld%lld&quot;,&amp;x,&amp;y,&amp;z);
            printf(&quot;%lld\n&quot;,ksm(x,y,z));
        }
    else if (K==2)
        for (i=1;i&lt;=tc;i++)
        {
            scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;P);
            tmp=extgcd(a,P);
            if (b%tmp!=0) printf(&quot;Orz, I cannot find x!\n&quot;);
            else
            {
                x*=b/tmp,y*=b/tmp;
                LL t=P/tmp;
                x=(x%t+t)%t;
                printf(&quot;%lld\n&quot;,x);
            }
        } 
    else
        for (;tc;tc--)
        {
            scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;P);
            a%=P,b%=P;
            LL m=(int)sqrt(P)+1;
            f[0].val=1,f[0].id=0;
            for (i=1;i&lt;m;i++) f[i].val=f[i-1].val*a%P,f[i].id=i;
            sort(f,f+m,cmp);
            LL num=0;
            for (i=1;i&lt;m;i++)
                if (f[i].val!=f[num].val) f[++num]=f[i];
                else if (f[i].id&lt;f[num].id) f[num].id=f[i].id;
            bool flag=0;
            for (i=0;i&lt;=m;i++)
            {
                tmp=ksm(a,i*m,P);
                if (tmp==0)
                    if (b==0) {printf(&quot;%lld\n&quot;,i*m);flag=1;break;}
                    else break;
                tmp=b*ksm(tmp,P-2,P)%P;
                LL l=0,r=num,res=-1;
                while (l&lt;=r)
                {
                    int mid=(l+r)&gt;&gt;1;
                    if (f[mid].val==tmp) {res=mid;break;}
                    else if (f[mid].val&gt;tmp) r=mid-1;
                    else l=mid+1;
                }
                if (res!=-1)
                {
                    printf(&quot;%lld\n&quot;,i*m+f[res].id);
                    flag=1;
                    break;
                }
            }
            if (!flag) printf(&quot;Orz, I cannot find x!\n&quot;);
        }
    return 0;
}
<pre><h2>Problem2242</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;map&gt;
using namespace std;
typedef long long LL;
LL f[100005];
LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (a%=c;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
LL extgcd(LL a,LL b,LL &amp;x,LL &amp;y)
{
	if (!b)
	{
		x=1,y=0;
		return a;
	}
	LL tmp=extgcd(b,a%b,y,x);
	y-=a/b*x;
	return tmp;
}
void work2(LL a,LL b,LL P)
{
	LL x,y;
	LL gcd=extgcd(a,P,x,y);
	if (b%gcd) {printf(&quot;Orz, I cannot find x!\n&quot;);return;}
	LL t=b/gcd;
	x*=t;
	t=P/gcd;
	x%=t;
	if (x&lt;0) x+=t;
	printf(&quot;%lld\n&quot;,x);
}
map&lt;LL,int&gt; b;
void work3(LL A,LL B,LL P)
{
	int size=(int)sqrt(P)+1;
	f[0]=1;
	b.clear();
	for (int i=1;i&lt;size;i++)
	{
		f[i]=f[i-1]*A%P;
		if (b.find(f[i])==b.end()) b[f[i]]=i;
	}
	for (int i=0;i*size&lt;P;i++)
	{
		LL tmp=ksm(A,i*size,P);
		if (tmp==0)
		{
			if (B==0) printf(&quot;%d\n&quot;,i*size);
			else printf(&quot;Orz, I cannot find x!\n&quot;);
			return;
		}
		tmp=B*ksm(tmp,P-2,P)%P;
		if (b.count(tmp))
		{
			printf(&quot;%d\n&quot;,i*size+b[tmp]);
			return;
		}
	}
	printf(&quot;Orz, I cannot find x!\n&quot;);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int tes,K;
	LL x,y,P;
	scanf(&quot;%d%d&quot;,&amp;tes,&amp;K);
	for (;tes;tes--)
	{
		scanf(&quot;%lld%lld%lld&quot;,&amp;x,&amp;y,&amp;P);
		if (K==1) printf(&quot;%lld\n&quot;,ksm(x,y,P));
		else if (K==2) work2(x,y,P);
		else work3(x,y,P);
	}
	return 0;
}<pre><h2>Problem2242</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;map&gt;
using namespace std;
typedef long long LL;
LL f[100005];
LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (a%=c;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
LL extgcd(LL a,LL b,LL &amp;x,LL &amp;y)
{
	if (!b)
	{
		x=1,y=0;
		return a;
	}
	LL tmp=extgcd(b,a%b,y,x);
	y-=a/b*x;
	return tmp;
}
void work2(LL a,LL b,LL P)
{
	LL x,y;
	LL gcd=extgcd(a,P,x,y);
	if (b%gcd) {printf(&quot;Orz, I cannot find x!\n&quot;);return;}
	LL t=b/gcd;
	x*=t;
	t=P/gcd;
	x%=t;
	if (x&lt;0) x+=t;
	printf(&quot;%lld\n&quot;,x);
}
map&lt;int,int&gt; b;
void work3(LL A,LL B,LL P)
{
	int size=(int)sqrt(P)+1;
	f[0]=1;
	b.clear();
	for (int i=1;i&lt;size;i++)
	{
		f[i]=f[i-1]*A%P;
		if (b.find(f[i])==b.end()) b[f[i]]=i;
	}
	for (int i=0;i*size&lt;P;i++)
	{
		LL tmp=ksm(A,i*size,P);
		if (tmp==0)
		{
			if (B==0) printf(&quot;%d\n&quot;,i*size);
			else printf(&quot;Orz, I cannot find x!\n&quot;);
			return;
		}
		tmp=B*ksm(tmp,P-2,P)%P;
		if (b.count(tmp))
		{
			printf(&quot;%d\n&quot;,i*size+b[tmp]);
			return;
		}
	}
	printf(&quot;Orz, I cannot find x!\n&quot;);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int tes,K;
	LL x,y,P;
	scanf(&quot;%d%d&quot;,&amp;tes,&amp;K);
	for (;tes;tes--)
	{
		scanf(&quot;%lld%lld%lld&quot;,&amp;x,&amp;y,&amp;P);
		if (K==1) printf(&quot;%lld\n&quot;,ksm(x,y,P));
		else if (K==2) work2(x,y,P);
		else work3(x,y,P);
	}
	return 0;
}<pre><h2>Problem2242</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
using namespace std;
typedef long long LL;
int tes,kind;
inline LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (a%=c;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
void work1()
{
	LL a,b,c;
	for (;tes;tes--)
	{
		scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c);
		printf(&quot;%lld\n&quot;,ksm(a,b,c));
	}
}
LL extgcd(LL a,LL b,LL &amp;x,LL &amp;y)
{
	if (b==0)
	{
		x=1,y=0;
		return a;
	}
	LL tmp=extgcd(b,a%b,y,x);
	y-=a/b*x;
	return tmp;
}
void work2()
{
	LL a,M,P;
	for (;tes;tes--)
	{
		scanf(&quot;%lld%lld%lld\n&quot;,&amp;a,&amp;M,&amp;P);
		LL x,y;
		LL gcd=extgcd(a,P,x,y);
		if (M%gcd) {printf(&quot;Orz, I cannot find x!\n&quot;);continue;}
		x*=M/gcd;
		int t=P/gcd;
		x=x%t;if (x&lt;0) x+=t;
		printf(&quot;%lld\n&quot;,x);
	}
}
struct HT
{
	#define mo 999997
	int vt[mo],o[mo],TIME,tot,aa0[1000000];
	LL f[1000000],aa1[1000000];
	void clear() {tot=0;TIME++;}
	void insert(LL X,LL Y)
	{
		int t=X%mo;
		if (vt[t]==TIME)
			for (int p=o[t];p;p=aa0[p])
				if (aa1[p]==X)
				{
					if (Y&lt;f[p]) f[p]=Y;
					return;
				}
		if (vt[t]!=TIME) {vt[t]=TIME;o[t]=0;}
		tot++;aa1[tot]=X;aa0[tot]=o[t];
		o[t]=tot;f[tot]=Y;
	}
	LL find(LL X)
	{
		int t=X%mo;
		if (vt[t]==TIME)
			for (int p=o[t];p;p=aa0[p])
				if (aa1[p]==X) return f[p];
		return -1;
	}
} ht;
void work3()
{
	static LL a[100000];
	LL A,B,P,i;
	for (;tes;tes--)
	{
		ht.clear();
		scanf(&quot;%lld%lld%lld&quot;,&amp;A,&amp;B,&amp;P);
		int blo=(int)sqrt(P-1)+1;
		ht.insert(a[0]=1,0);
		for (i=1;i&lt;blo;i++)
			ht.insert(a[i]=a[i-1]*A%P,i);
		LL now=1;
		bool flag=false;
		for (i=0;i&lt;P;i+=blo)
		{
			if (now==0)
			{
				if (B==0) flag=true,printf(&quot;%lld\n&quot;,i);
				break;
			}
			LL tmp=B*ksm(now,P-2,P)%P;
			LL t=ht.find(tmp);
			if (t&gt;=0) {flag=true;printf(&quot;%lld\n&quot;,i+t);break;}
			now=now*a[blo-1]%P*A%P;
		}
		if (!flag) printf(&quot;Orz, I cannot find x!\n&quot;);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;tes,&amp;kind);
	if (kind==1) work1();
	else if (kind==2) work2();
	else work3();
	return 0;
}<pre><h2>Problem2243</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define NN 110000
#define lc(v) (v&lt;&lt;1)
#define rc(v) ((v&lt;&lt;1)+1)
#define inf 99999999
int size[NN],deep[NN],up[NN],fa[NN],pos[NN],which[NN],heavy[NN],o[NN],aa[NN*2][2];
int color[NN],tag[NN*4],tl[NN*4],tr[NN*4],tnum[NN*4];
int n,m,tot,cnt,ans,ww,ee;
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void chaindfs1(int v)
{
	int tmp=0,mm=-inf;
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		chaindfs1(y);
		size[v]+=size[y];
		if (size[y]&gt;mm) mm=size[y],tmp=y;
	}
	heavy[v]=tmp;
}
void chaindfs2(int v)
{
	pos[v]=++cnt;
	which[cnt]=v;
	if (!heavy[v]) return;
	up[heavy[v]]=up[v];
	chaindfs2(heavy[v]);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||y==heavy[v]) continue;
		up[y]=y;
		chaindfs2(y);
	}
}
void pushdown(int v)
{
	if (tag[v]==-1) return;
	int x=lc(v),y=rc(v);
	tl[x]=tr[x]=tl[y]=tr[y]=tag[x]=tag[y]=tag[v];
	tnum[x]=tnum[y]=1;
	tag[v]=-1;
}
void update(int v)
{
	int x=lc(v),y=rc(v);
	tl[v]=tl[x];
	tr[v]=tr[y];
	tnum[v]=tnum[x]+tnum[y];
	if (tr[x]==tl[y]) tnum[v]--;
}
void build(int v,int l,int r)
{
	tag[v]=-1;
	if (r-l==1)
	{
		tl[v]=tr[v]=color[which[l]];
		tnum[v]=1;
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(lc(v),l,mid);
	build(rc(v),mid,r);
	update(v);
}
void change(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		tag[v]=x;
		tl[v]=tr[v]=x;
		tnum[v]=1;
		return;
	}
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) change(lc(v),l,mid,x);
	if (ee&gt;mid) change(rc(v),mid,r,x);
	update(v);
}
int find(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tnum[v];
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (ee&lt;=mid) return find(lc(v),l,mid);
	else if (ww&gt;=mid) return find(rc(v),mid,r);
	else
	{
		int res=find(lc(v),l,mid)+find(rc(v),mid,r);
		if (tr[lc(v)]==tl[rc(v)]) res--;
		return res;
	}
}
int find2(int v,int l,int r,int i)
{
	if (r-l==1) return tl[v];
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid) return find2(lc(v),l,mid,i);
	else return find2(rc(v),mid,r,i);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;color[i]);
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d\n&quot;,&amp;x,&amp;y);
		addedge(x,y);
		addedge(y,x);
	}
	chaindfs1(1);
	up[1]=1;
	chaindfs2(1);
	//for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,which[i]);printf(&quot;\n&quot;);
	build(1,1,n+1);
	for (;m;m--)
	{
		//printf(&quot;\n-------------------------------------------\n&quot;);
		//for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,find2(1,1,n+1,i));printf(&quot;\n&quot;);
		char ch;
		scanf(&quot;%c &quot;,&amp;ch);
		//printf(&quot;%c\n&quot;,ch);
		if (ch=='C')
		{
			scanf(&quot;%d%d%d\n&quot;,&amp;x,&amp;y,&amp;z);
			while (up[x]!=up[y])
			{
				if (deep[up[x]]&lt;deep[up[y]]) swap(x,y);
				ww=pos[up[x]];
				ee=pos[x]+1;
				change(1,1,n+1,z);
				x=fa[up[x]];
			}
			if (deep[x]&lt;deep[y]) swap(x,y);
			ww=pos[y];
			ee=pos[x]+1;
			//printf(&quot;%d %d\n&quot;,ww,ee);
			change(1,1,n+1,z);
		}
		else
		{
			ans=0;
			scanf(&quot;%d%d\n&quot;,&amp;x,&amp;y);
			while (up[x]!=up[y])
			{
				if (deep[up[x]]&lt;deep[up[y]]) swap(x,y);
				ww=pos[up[x]];
				ee=pos[x]+1;
				//printf(&quot;%d %d\n&quot;,ww,ee);
				ans+=find(1,1,n+1);
				if (find2(1,1,n+1,pos[up[x]])==find2(1,1,n+1,pos[fa[up[x]]])) ans--;
				x=fa[up[x]];
				//printf(&quot;ans %d\n&quot;,ans);
			}
			//printf(&quot;asdasd %d\n&quot;,ans);
			if (deep[x]&lt;deep[y]) swap(x,y);
			ww=pos[y];
			ee=pos[x]+1;
			ans+=find(1,1,n+1);
			printf(&quot;%d\n&quot;,ans);
		}
	}
	return 0;
}
<pre><h2>Problem2243</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define NN 110000
#define lc(v) (v&lt;&lt;1)
#define rc(v) ((v&lt;&lt;1)+1)
#define inf 99999999
int size[NN],deep[NN],up[NN],fa[NN],pos[NN],which[NN],heavy[NN],o[NN],aa[NN*2][2];
int color[NN],tag[NN*4],tl[NN*4],tr[NN*4],tnum[NN*4];
int n,m,tot,cnt,ans,ww,ee;
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void chaindfs1(int v)
{
	int tmp=0,mm=-inf;
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		chaindfs1(y);
		size[v]+=size[y];
		if (size[y]&gt;mm) mm=size[y],tmp=y;
	}
	heavy[v]=tmp;
}
void chaindfs2(int v)
{
	pos[v]=++cnt;
	which[cnt]=v;
	if (!heavy[v]) return;
	up[heavy[v]]=up[v];
	chaindfs2(heavy[v]);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||y==heavy[v]) continue;
		up[y]=y;
		chaindfs2(y);
	}
}
void pushdown(int v)
{
	if (tag[v]==-1) return;
	int x=lc(v),y=rc(v);
	tl[x]=tr[x]=tl[y]=tr[y]=tag[x]=tag[y]=tag[v];
	tnum[x]=tnum[y]=1;
	tag[v]=-1;
}
void update(int v)
{
	int x=lc(v),y=rc(v);
	tl[v]=tl[x];
	tr[v]=tr[y];
	tnum[v]=tnum[x]+tnum[y];
	if (tr[x]==tl[y]) tnum[v]--;
}
void build(int v,int l,int r)
{
	tag[v]=-1;
	if (r-l==1)
	{
		tl[v]=tr[v]=color[which[l]];
		tnum[v]=1;
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(lc(v),l,mid);
	build(rc(v),mid,r);
	update(v);
}
void change(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		tag[v]=x;
		tl[v]=tr[v]=x;
		tnum[v]=1;
		return;
	}
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) change(lc(v),l,mid,x);
	if (ee&gt;mid) change(rc(v),mid,r,x);
	update(v);
}
int find(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tnum[v];
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (ee&lt;=mid) return find(lc(v),l,mid);
	else if (ww&gt;=mid) return find(rc(v),mid,r);
	else
	{
		int res=find(lc(v),l,mid)+find(rc(v),mid,r);
		if (tr[lc(v)]==tl[rc(v)]) res--;
		return res;
	}
}
int find2(int v,int l,int r,int i)
{
	if (r-l==1) return tl[v];
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid) return find2(lc(v),l,mid,i);
	else return find2(rc(v),mid,r,i);
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;color[i]);
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d\n&quot;,&amp;x,&amp;y);
		addedge(x,y);
		addedge(y,x);
	}
	chaindfs1(1);
	up[1]=1;
	chaindfs2(1);
	build(1,1,n+1);
	for (;m;m--)
	{
		char ch;
		scanf(&quot;%c &quot;,&amp;ch);
		if (ch=='C')
		{
			scanf(&quot;%d%d%d\n&quot;,&amp;x,&amp;y,&amp;z);
			while (up[x]!=up[y])
			{
				if (deep[up[x]]&lt;deep[up[y]]) swap(x,y);
				ww=pos[up[x]];
				ee=pos[x]+1;
				change(1,1,n+1,z);
				x=fa[up[x]];
			}
			if (deep[x]&lt;deep[y]) swap(x,y);
			ww=pos[y];
			ee=pos[x]+1;
			change(1,1,n+1,z);
		}
		else
		{
			ans=0;
			scanf(&quot;%d%d\n&quot;,&amp;x,&amp;y);
			while (up[x]!=up[y])
			{
				if (deep[up[x]]&lt;deep[up[y]]) swap(x,y);
				ww=pos[up[x]];
				ee=pos[x]+1;
				ans+=find(1,1,n+1);
				if (find2(1,1,n+1,pos[up[x]])==find2(1,1,n+1,pos[fa[up[x]]])) ans--;
				x=fa[up[x]];
			}
			if (deep[x]&lt;deep[y]) swap(x,y);
			ww=pos[y];
			ee=pos[x]+1;
			ans+=find(1,1,n+1);
			printf(&quot;%d\n&quot;,ans);
		}
	}
	return 0;
}
<pre><h2>Problem2243</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define NN 101111
int fa[NN],aa[NN*2][2],o[NN],tag[NN],tc[NN],tl[NN],tr[NN],tnum[NN],son[NN][2];
int n,m,tot;
bool rrr[NN];
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
void dfs(int v)
{
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dfs(y);
	}
}
void make(int v,int c)
{
	if (!v) return;
	tag[v]=c;
	tl[v]=tr[v]=tc[v]=c;
	tnum[v]=1;
}
void pushdown(int v)
{
	if (tag[v]==-1) return;
	make(son[v][0],tag[v]);
	make(son[v][1],tag[v]);
	tag[v]=-1;
}
void update(int v)
{
	int x=son[v][0],y=son[v][1];
	tl[v]=x?tl[x]:tc[v];
	tr[v]=y?tr[y]:tc[v];
	tnum[v]=tnum[x]+tnum[y]+1;
	if (tc[v]==tr[x]) tnum[v]--;
	if (tc[v]==tl[y]) tnum[v]--;
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
}
int access(int x)
{
	//printf(&quot;\naccessing %d\n&quot;,x);
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		//printf(&quot;%d %d\n&quot;,x,y);
		splay(x);
		//printf(&quot;splay(x) end.\n&quot;);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
	//printf(&quot;access end.\n\n&quot;);
	return y;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,x,y,z,k,res;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;tc[i]);
		tl[i]=tr[i]=tc[i];
		tnum[i]=1;
		tag[i]=-1;
		rrr[i]=true;
	}
	tl[0]=tr[0]=tc[0]=-1;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	dfs(1);
	//printf(&quot;dfs end.\n&quot;);
	for (i=1;i&lt;=m;i++)
	{
		//printf(&quot;\n------------------- %d ----------------------\n&quot;,i);
		char ch='1';
		while (ch!='Q'&amp;&amp;ch!='C') ch=getchar();
		if (ch=='C')
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			access(x);
			k=access(y);
			//printf(&quot;two accesses end.\n&quot;);
			tc[k]=z,update(k);
			if (son[k][1])
			{
				make(son[k][1],z);
				splay(son[k][1]);
			}
			//printf(&quot;splay(son[k][1]) end.\n&quot;);
			if (k!=x)
			{
				splay(x);
				make(x,z);
			}
		}
		else
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			access(x);
			//printf(&quot;access(x) end.\n&quot;);
			k=access(y);
			//printf(&quot;k=%d\n&quot;,k);
			//printf(&quot;son[k][1]=%d\n&quot;,son[k][1]);
			//printf(&quot;tl[2]=%d\n&quot;,tl[2]);
			res=tnum[son[k][1]]+1;
			if (tc[k]==tl[son[k][1]]) res--;
			//printf(&quot;%d %d\n&quot;,tc[k],tl[son[k][1]]);
			//printf(&quot;res=%d\n&quot;,res);
			if (k!=x)
			{
				splay(x);
				res+=tnum[x];
				if (tl[x]==tc[k]) res--;
			}
			printf(&quot;%d\n&quot;,res);
		}
	}
	return 0;
}
<pre><h2>Problem2244</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
typedef double DD;
const int NN=51111;
int f1[NN],f2[NN],c[NN],id[NN],id2[NN],b[NN];
int n;
DD g1[NN],g2[NN],d[NN];
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
void out(DD *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%.3f &quot;,a[i]);ln;}
struct ppt
{
	int x,y;
	void out() {printf(&quot;x=%d y=%d\n&quot;,x,y);}
} q[NN];
void change(int i,int x,DD num)
{
	for (;i&lt;=n;i+=i&amp;-i)
		if (x&gt;c[i]) c[i]=x,d[i]=num;
		else if (x==c[i]) d[i]+=num;
}
void getmax(int i,int &amp;res1,DD &amp;res2)
{
	res1=res2=0;
	for (;i;i-=i&amp;-i)
		if (c[i]&gt;res1) res1=c[i],res2=d[i];
		else if (c[i]==res1) res2+=d[i];
}
void clear(int i)
{
	for (;i&lt;=n;i+=i&amp;-i) c[i]=0,d[i]=0;
}
bool cmp(int a,int b) {return q[a].x&lt;q[b].x;}
void cdq(int l,int r,int *f,DD *g)
{
	if (l==r) return;
	int mid=(l+r)&gt;&gt;1;
	int i,j,k,tt;
	cdq(l,mid,f,g);
	//printf(&quot;\n------------------ cdq %d %d ---------------------------------------\nid: &quot;,l,r);out(id,l,r);
	for (j=mid+1;j&lt;=r;j++) id2[j]=id[j];
	sort(id2+mid+1,id2+r+1,cmp);
	for (j=l,i=mid+1;i&lt;=r;i++)
	{
		int t=id2[i];
		for (tt=id[j];j&lt;=mid&amp;&amp;q[tt].x&lt;=q[t].x;tt=id[++j])
			change(q[tt].y,f[tt],g[tt]);
		DD num;
		getmax(q[t].y,tt,num);
		if (tt+1&gt;f[t]) f[t]=tt+1,g[t]=num;
		else if (tt+1==f[t]) g[t]+=num;
	}
	for (j=l;j&lt;=mid;j++) clear(q[id[j]].y);
	cdq(mid+1,r,f,g);
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if ((i&lt;=mid&amp;&amp;q[id[i]].x&lt;q[id[j]].x)||j&gt;r) id2[k]=id[i++];
		else id2[k]=id[j++];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
}
int cha(int x)
{
	int l=1,r=n;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (b[mid]==x) return mid;
		if (b[mid]&gt;x) r=mid-1;else l=mid+1;
	}
	return -1;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;q[i].x,&amp;q[i].y),b[i]=q[i].y;
	sort(b+1,b+n+1);
	for (i=1;i&lt;=n;i++) q[i].y=cha(q[i].y);
	//printf(&quot;q:\n&quot;);for(i=1;i&lt;=n;i++)q[i].out();ln;
	
	for (i=1;i&lt;=n;i++) q[i].x=-q[i].x,q[i].y=n-q[i].y+1,id[i]=i;
	for (i=1;i&lt;+n;i++) f1[i]=1,g1[i]=1;
	cdq(1,n,f1,g1);
	//printf(&quot;f1 &quot;);out(f1,1,n);printf(&quot;g1 &quot;);out(g1,1,n);
	
	int ans=0;
	for (i=1;i&lt;=n;i++)
		if (f1[i]&gt;ans) ans=f1[i];
	DD ans2=0;
	for (i=1;i&lt;=n;i++)
		if (f1[i]==ans) ans2+=g1[i];
		
	for (i=1;i&lt;=n;i++) q[i].x=-q[i].x,q[i].y=n-q[i].y+1,id[i]=n-i+1;
	for (i=1;i&lt;=n;i++) f2[i]=1,g2[i]=1;
	cdq(1,n,f2,g2);
	
	//ln;ln;
	printf(&quot;%d\n&quot;,ans);
	for (i=1;i&lt;=n;i++)
		if (f1[i]+f2[i]-1==ans) printf(&quot;%.5f &quot;,g1[i]*g2[i]/ans2);
		else printf(&quot;0 &quot;);
	return 0;
}<pre><h2>Problem2244</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
const int NN=51111;
int f1[NN],f2[NN],c[NN],id[NN],id2[NN],b[NN];
int n;
DD g1[NN],g2[NN],d[NN];
struct ppt
{
	int x,y;
} q[NN];
void change(int i,int x,DD num)
{
	for (;i&lt;=n;i+=i&amp;-i)
		if (x&gt;c[i]) c[i]=x,d[i]=num;
		else if (x==c[i]) d[i]+=num;
}
void getmax(int i,int &amp;res1,DD &amp;res2)
{
	res1=res2=0;
	for (;i;i-=i&amp;-i)
		if (c[i]&gt;res1) res1=c[i],res2=d[i];
		else if (c[i]==res1) res2+=d[i];
}
void clear(int i)
{
	for (;i&lt;=n;i+=i&amp;-i) c[i]=0,d[i]=0;
}
bool cmp(int a,int b) {return q[a].x&lt;q[b].x;}
void cdq(int l,int r,int *f,DD *g)
{
	if (l==r) return;
	int mid=(l+r)&gt;&gt;1;
	int i,j,k,tt;
	cdq(l,mid,f,g);
	for (j=mid+1;j&lt;=r;j++) id2[j]=id[j];
	sort(id2+mid+1,id2+r+1,cmp);
	for (j=l,i=mid+1;i&lt;=r;i++)
	{
		int t=id2[i];
		for (tt=id[j];j&lt;=mid&amp;&amp;q[tt].x&lt;=q[t].x;tt=id[++j])
			change(q[tt].y,f[tt],g[tt]);
		DD num;
		getmax(q[t].y,tt,num);
		if (tt+1&gt;f[t]) f[t]=tt+1,g[t]=num;
		else if (tt+1==f[t]) g[t]+=num;
	}
	for (j=l;j&lt;=mid;j++) clear(q[id[j]].y);
	cdq(mid+1,r,f,g);
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if ((i&lt;=mid&amp;&amp;q[id[i]].x&lt;q[id[j]].x)||j&gt;r) id2[k]=id[i++];
		else id2[k]=id[j++];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
}
int cha(int x)
{
	int l=1,r=n;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (b[mid]==x) return mid;
		if (b[mid]&gt;x) r=mid-1;else l=mid+1;
	}
	return -1;
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	int i;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;q[i].x,&amp;q[i].y),b[i]=q[i].y;
	sort(b+1,b+n+1);
	for (i=1;i&lt;=n;i++) q[i].y=cha(q[i].y);
	
	for (i=1;i&lt;=n;i++) 
	{
		q[i].x=-q[i].x,q[i].y=n-q[i].y+1;
		id[i]=i,f1[i]=1,g1[i]=1;
	}
	cdq(1,n,f1,g1);
	
	int ans=0;
	for (i=1;i&lt;=n;i++)
		if (f1[i]&gt;ans) ans=f1[i];
	DD ans2=0;
	for (i=1;i&lt;=n;i++)
		if (f1[i]==ans) ans2+=g1[i];
		
	for (i=1;i&lt;=n;i++)
	{
		q[i].x=-q[i].x,q[i].y=n-q[i].y+1;
		id[i]=n-i+1,f2[i]=1,g2[i]=1;
	}
	cdq(1,n,f2,g2);
	
	printf(&quot;%d\n&quot;,ans);
	for (i=1;i&lt;=n;i++)
		if (f1[i]+f2[i]-1==ans) printf(&quot;%.5f &quot;,g1[i]*g2[i]/ans2);
		else printf(&quot;0 &quot;);
	return 0;
}<pre><h2>Problem2245</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 999999999
#define mii(a,b) (a&lt;b?a:b)
typedef long long LL;
const int NN=5011;
int dist[NN],q[NN+10],aa[1031111][4],pre[NN],o[NN],a[NN];
int n,m,tot=1,S,T;
LL ans;
bool dl[NN];
bool spfa()
{
	memset(dist,60,sizeof(dist));
	dist[S]=0;
	int head=0,tail=1;
	q[1]=S;
	memset(dl,0,sizeof(dl));
	dl[S]=true;
	while (head!=tail)
	{
		head++;if (head&gt;NN) head=1;
		int x=q[head];
		dl[x]=false;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;dist[y]&gt;dist[x]+aa[p][3])
			{
				pre[y]=p;
				dist[y]=dist[x]+aa[p][3];
				if (!dl[y])
				{
					dl[y]=true;
					tail++;if (tail&gt;NN) tail=NN;
					q[tail]=y;
				}
			}
		}
	}
	if (dist[T]==dist[0]) return false;
	int p,ff=inf;
	for (p=pre[T];p;p=pre[aa[p^1][1]]) ff=mii(ff,aa[p][2]);
	for (p=pre[T];p;p=pre[aa[p^1][1]])
	{
		ans+=(LL)ff*aa[p][3];
		aa[p][2]-=ff,aa[p^1][2]+=ff;
	}
	return true;
}
void addedge(int p,int q,int v,int c)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][3]=c;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v,int c)
{
	//printf(&quot;add  %d %d %d %d\n&quot;,p,q,v,c);
	addedge(p,q,v,c);
	addedge(q,p,0,-c);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;m,&amp;n);
	S=n+m+1,T=S+1,tot=1;
	int i,j,x,y;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;x),add(S,i,x,0);
	for (i=1;i&lt;=m;i++)
		for (j=1;j&lt;=n;j++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			if (x) add(j,i+n,inf,0);
		}
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		for (j=1;j&lt;=x;j++) scanf(&quot;%d&quot;,&amp;a[j]);
		for (j=1;j&lt;=x;j++) scanf(&quot;%d&quot;,&amp;y),add(i+n,T,a[j]-a[j-1],y);
		scanf(&quot;%d&quot;,&amp;y),add(i+n,T,inf,y);
	}
	ans=0;
	while (spfa());
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem2245</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 999999999
#define mii(a,b) (a&lt;b?a:b)
typedef long long LL;
const int NN=511;
int dist[NN],q[NN+10],aa[131111][4],pre[NN],o[NN],a[NN];
int n,m,tot=1,S,T;
LL ans;
bool dl[NN];
bool spfa()
{
	memset(dist,60,sizeof(dist));
	dist[S]=0;
	int head=0,tail=1;
	q[1]=S;
	memset(dl,0,sizeof(dl));
	dl[S]=true;
	while (head!=tail)
	{
		head++;if (head&gt;NN) head=1;
		int x=q[head];
		dl[x]=false;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;dist[y]&gt;dist[x]+aa[p][3])
			{
				pre[y]=p;
				dist[y]=dist[x]+aa[p][3];
				if (!dl[y])
				{
					dl[y]=true;
					tail++;if (tail&gt;NN) tail=NN;
					q[tail]=y;
				}
			}
		}
	}
	if (dist[T]==dist[0]) return false;
	int p,ff=inf;
	for (p=pre[T];p;p=pre[aa[p^1][1]]) ff=mii(ff,aa[p][2]);
	for (p=pre[T];p;p=pre[aa[p^1][1]])
	{
		ans+=(LL)ff*aa[p][3];
		aa[p][2]-=ff,aa[p^1][2]+=ff;
	}
	return true;
}
void addedge(int p,int q,int v,int c)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][3]=c;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v,int c)
{
	//printf(&quot;add  %d %d %d %d\n&quot;,p,q,v,c);
	addedge(p,q,v,c);
	addedge(q,p,0,-c);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;m,&amp;n);
	S=n+m+1,T=S+1,tot=1;
	int i,j,x,y;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;x),add(S,i,x,0);
	for (i=1;i&lt;=m;i++)
		for (j=1;j&lt;=n;j++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			if (x) add(j,i+n,inf,0);
		}
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		for (j=1;j&lt;=x;j++) scanf(&quot;%d&quot;,&amp;a[j]);
		for (j=1;j&lt;=x;j++) scanf(&quot;%d&quot;,&amp;y),add(i+n,T,a[j]-a[j-1],y);
		scanf(&quot;%d&quot;,&amp;y),add(i+n,T,inf,y);
	}
	ans=0;
	while (spfa());
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem2245</h2><pre>#define M 300
#define oo 0x7fffffff
#define ll long long
#define Min(a,b)((a)&lt;(b)?(a):(b))

#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

bool can[M][M],vis[M&lt;&lt;2];
int flow[M&lt;&lt;2],from[M&lt;&lt;2],tot;
int q[M&lt;&lt;5],head,tail,S,T,m;ll dis[M&lt;&lt;2];
int n,C[M],t[M][M],s[M],val[M][M],first[M&lt;&lt;2];

struct Edge{int u,v,w,next;ll c;}edge[M*M&lt;&lt;1];

inline void add(int u,int v,int w,ll c)
{
	edge[tot].u=u;edge[tot].v=v;
	edge[tot].w=w;edge[tot].c=c;
	edge[tot].next=first[u];first[u]=tot++;
}

inline void Add(int u,int v,int w,ll c)
{
	add(u,v,w,c);add(v,u,0,-c);
}

inline bool spfa(ll &amp;cost)
{
	memset(flow,0,sizeof(flow));
	memset(from,0,sizeof(from));
	memset(dis,0x7f,sizeof(dis));
	head=tail=0;q[tail]=S;dis[S]=0;flow[S]=oo;
	while(head&lt;=tail){
		int p=q[head++];vis[p]=false;
		for(int i=first[p];i!=-1;i=edge[i].next)
		    if(edge[i].w&gt;0&amp;&amp;dis[edge[i].v]&gt;dis[p]+edge[i].c){
				dis[edge[i].v]=dis[p]+edge[i].c;
				from[edge[i].v]=i;flow[edge[i].v]=Min(flow[p],edge[i].w);
				if(!vis[edge[i].v]){vis[edge[i].v]=true;q[++tail]=edge[i].v;}
		    }
	}
	if(dis[T]==dis[T+1])return false;
	cost+=dis[T]*(ll)flow[T];
	for(int i=T;i!=S;i=edge[from[i]].u)
		edge[from[i]].w-=flow[T],edge[from[i]^1].w+=flow[T];
	return true;
}

inline ll MincostMaxflow()
{
	ll ret=0;while(spfa(ret));return ret;
}

int main()
{
	memset(first,-1,sizeof(first));
	scanf(&quot;%d%d&quot;,&amp;m,&amp;n);S=0;T=m+n+1;
	for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;C[i]);
	for(int i=1;i&lt;=m;i++)for(int j=1;j&lt;=n;j++)
	    scanf(&quot;%d&quot;,&amp;can[i][j]);
	for(int i=1;i&lt;=m;i++){
		scanf(&quot;%d&quot;,&amp;s[i]);
		for(int j=1;j&lt;=s[i];j++)scanf(&quot;%d&quot;,&amp;t[i][j]);
		for(int j=1;j&lt;=s[i]+1;j++)scanf(&quot;%d&quot;,&amp;val[i][j]);
	}
	for(int i=1;i&lt;=n;i++)Add(S,i,C[i],0);
	for(int i=1;i&lt;=m;i++){
		for(int j=1;j&lt;=s[i];j++)
		    Add(i+n,T,t[i][j]-t[i][j-1],(ll)val[i][j]);
		Add(i+n,T,oo,(ll)val[i][s[i]+1]);
	}
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)
	    if(can[j][i])Add(i,j+n,oo,0);
	printf(&quot;%lld&quot;,MincostMaxflow());
}
<pre><h2>Problem2257</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
int b[10000000],n,K,cnt;
void work(int x)
{
	//printf(&quot;\n------------------- x=%d -------------------------------------------\n&quot;,x);
	for (int i=1;i*i&lt;=x;i++) if (x%i==0)
	{
		b[++cnt]=i;
		if (i*i!=x) b[++cnt]=x/i;
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	int i,j,x;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		work(x);
	}
	sort(b+1,b+cnt+1);
	//for (i=1;i&lt;=cnt;i++) printf(&quot;%d &quot;,b[i]);ln;
	int ans=0;
	for (i=1;i&lt;=cnt;i=j+1)
	{
		j=i;
		while (b[j]==b[i]) j++;
		j--;
		//printf(&quot;%d %d\n&quot;,i,j);
		if (j-i+1&gt;=K) ans=b[i];
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem2260</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
typedef double DD;
const int NN=1011,MM=1001111;
int n,m,id[NN];
bool flag[NN];
struct wupin
{
	DD w;int num;
} q[NN];
struct edge
{
	int u,v;DD w;
	edge(int a=0,int b=0,DD c=0) {u=a;v=b;w=c;}
} e[MM];
DD zhuliu(int root,int n,int m)
{
	static int id[NN],vt[NN],pre[NN];
	static DD in[NN];
	DD res=0;
	for (;;)
	{
		int i;
		for (i=1;i&lt;=n;i++) in[i]=inf;
		for (i=1;i&lt;=m;i++)
		{
			int x=e[i].u,y=e[i].v;
			if (x!=y&amp;&amp;e[i].w&lt;in[y])
				in[y]=e[i].w,pre[y]=x;
		}
		in[root]=0;
		for (i=1;i&lt;=n;i++)
			if (in[i]&gt;=inf) return -inf;
		int cnt=0;
		memset(id,0,sizeof(id));
		memset(vt,0,sizeof(vt));
		for (i=1;i&lt;=n;i++)
		{
			res+=in[i];
			int x=i;
			for (;!id[x]&amp;&amp;vt[x]!=i&amp;&amp;x!=root;x=pre[x]) vt[x]=i;
			if (x==root||id[x]) continue;
			id[x]=++cnt;
			for (int y=pre[x];y!=x;y=pre[y]) id[y]=cnt;
		}
		if (cnt==0) break;
		for (i=1;i&lt;=n;i++)
			if (!id[i]) id[i]=++cnt;
		for (i=1;i&lt;=m;i++)
		{
			int x=e[i].u,y=e[i].v;
			e[i].u=id[x],e[i].v=id[y];
			if (id[x]!=id[y]) e[i].w-=in[y];
		}
		n=cnt,root=id[root];
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y,t;DD z;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%lf%d&quot;,&amp;q[i].w,&amp;q[i].num);
		if (q[i].num==0) flag[i]=true;
	}
	t=0;
	for (i=1;i&lt;=n;i++)
		if (!flag[i]) id[i]=++t,q[t]=q[i];
	n=t;
	static DD in[NN];
	for (i=1;i&lt;=n;i++) in[i]=q[i].w;
	scanf(&quot;%d&quot;,&amp;t);
	for (i=1;i&lt;=t;i++)
	{
		scanf(&quot;%d%d%lf&quot;,&amp;x,&amp;y,&amp;z);
		if (flag[x]||flag[y]) continue;
		x=id[x],y=id[y];
		e[++m]=edge(x,y,z);
		if (z&lt;in[y]) in[y]=z;
	}
	DD ans=0;
	for (i=1;i&lt;=n;i++)
	{
		ans+=in[i]*(q[i].num-1);
		e[++m]=edge(n+1,i,q[i].w);
	}
	//printf(&quot;ans=%.3f\n&quot;,ans);
	ans+=zhuliu(n+1,n+1,m);
	printf(&quot;%.2f\n&quot;,ans);
	return 0;
}<pre><h2>Problem2260</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
typedef double DD;
const int NN=111,MM=101111;
int n,m,id[NN];
bool flag[NN];
struct wupin
{
	DD w;int num;
} q[NN];
struct edge
{
	int u,v;DD w;
	edge(int a=0,int b=0,DD c=0) {u=a;v=b;w=c;}
} e[MM];
DD zhuliu(int root,int n,int m)
{
	static int id[NN],vt[NN],pre[NN];
	static DD in[NN];
	DD res=0;
	for (;;)
	{
		int i;
		for (i=1;i&lt;=n;i++) in[i]=inf;
		for (i=1;i&lt;=m;i++)
		{
			int x=e[i].u,y=e[i].v;
			if (x!=y&amp;&amp;e[i].w&lt;in[y])
				in[y]=e[i].w,pre[y]=x;
		}
		in[root]=0;
		for (i=1;i&lt;=n;i++)
			if (in[i]&gt;=inf) return -inf;
		int cnt=0;
		memset(id,0,sizeof(id));
		memset(vt,0,sizeof(vt));
		for (i=1;i&lt;=n;i++)
		{
			res+=in[i];
			int x=i;
			for (;!id[x]&amp;&amp;vt[x]!=i&amp;&amp;x!=root;x=pre[x]) vt[x]=i;
			if (x==root||id[x]) continue;
			id[x]=++cnt;
			for (int y=pre[x];y!=x;y=pre[y]) id[y]=cnt;
		}
		if (cnt==0) break;
		for (i=1;i&lt;=n;i++)
			if (!id[i]) id[i]=++cnt;
		for (i=1;i&lt;=m;i++)
		{
			int x=e[i].u,y=e[i].v;
			e[i].u=id[x],e[i].v=id[y];
			if (id[x]!=id[y]) e[i].w-=in[y];
		}
		n=cnt,root=id[root];
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y,t;DD z;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%lf%d&quot;,&amp;q[i].w,&amp;q[i].num);
		if (q[i].num==0) flag[i]=true;
	}
	t=0;
	for (i=1;i&lt;=n;i++)
		if (!flag[i]) id[i]=++t,q[t]=q[i];
	n=t;
	static DD in[NN];
	for (i=1;i&lt;=n;i++) in[i]=q[i].w;
	scanf(&quot;%d&quot;,&amp;t);
	for (i=1;i&lt;=t;i++)
	{
		scanf(&quot;%d%d%lf&quot;,&amp;x,&amp;y,&amp;z);
		if (flag[x]||flag[y]) continue;
		x=id[x],y=id[y];
		e[++m]=edge(x,y,z);
		if (z&lt;in[y]) in[y]=z;
	}
	DD ans=0;
	for (i=1;i&lt;=n;i++)
	{
		ans+=in[i]*(q[i].num-1);
		e[++m]=edge(n+1,i,q[i].w);
	}
	//printf(&quot;ans=%.3f\n&quot;,ans);
	ans+=zhuliu(n+1,n+1,m);
	printf(&quot;%.2f\n&quot;,ans);
	return 0;
}<pre><h2>Problem2276</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define mp make_pair
#define se second
#define fi first
#define ln printf(&quot;\n&quot;)
int n;
pair&lt;int,int&gt; q[1000005];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
	if (f) x=-x;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);
	int ans=1,i,l,r,head=0,tail=0;
	for (i=1;i&lt;=n;i++)
	{
		//printf(&quot;\n-----------------------------------------------------------------------\n&quot;);
		read(l),read(r);
		while (head&lt;tail&amp;&amp;q[head+1].se&gt;r) head++;
		if (head&lt;tail&amp;&amp;i-q[head].fi&gt;ans) ans=i-q[head].fi;
		while (head&lt;tail&amp;&amp;l&gt;q[tail].se) tail--;
		q[++tail]=mp(i,l);
		//for (int j=head+1;j&lt;=tail;j++)printf(&quot;%d %d  &quot;,q[j].fi,q[j].se);putchar('\n');
	}
	//ln;ln;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem2276</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define mp make_pair
#define se second
#define fi first
int n;
pair&lt;int,int&gt; q[1000005];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
	if (f) x=-x;
}
int main()
{
	read(n);
	int ans=1,i,l,r,head=0,tail=0;
	for (i=1;i&lt;=n;i++)
	{
		read(l),read(r);
		while (head&lt;tail&amp;&amp;q[head+1].se&gt;r) head++;
		if (head&lt;tail&amp;&amp;i-q[head].fi&gt;ans) ans=i-q[head].fi;
		while (head&lt;tail&amp;&amp;l&gt;q[tail].se) tail--;
		q[++tail]=mp(i,l);
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem2281</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define mo 1000000007
#define LL long long
LL fac[11111],f[29][11111];
LL n,K,D;
LL ksm(LL a,LL b)
{
	LL res=1;
	for (a%=mo;b;b&gt;&gt;=1,a=a*a%mo)
		if (b&amp;1) res=res*a%mo;
	return res;
}
LL C(LL n,LL m)
{
	if (n&lt;m) return 0;
	LL tmp=fac[m]*fac[n-m]%mo;
	return fac[n]*ksm(tmp,mo-2)%mo;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;K,&amp;D);
	LL i,j,k;
	for (fac[0]=1,i=1;i&lt;=10000;i++) fac[i]=fac[i-1]*i%mo;
	//printf(&quot;C(5,2)=%I64d\n&quot;,C(5,2));
	LL ans=C(n,K);
	//printf(&quot;as=%I64d\n&quot;,ans);
	f[0][0]=1;
	for (i=1;i&lt;=25;i++)
		for (j=0;j&lt;=n-K;j++)
		{
			for (k=0;k*(1&lt;&lt;(i-1))&lt;=j&amp;&amp;k&lt;=K/2;k+=D+1)
				f[i][j]+=f[i-1][j-k*(1&lt;&lt;(i-1))]*C(K/2,k);//,printf(&quot;+1&quot;);
			f[i][j]%=mo;
			//printf(&quot;f[%I64d][%I64d]=%I64d\n&quot;,i,j,f[i][j]);
		}
	//for(i=1;i&lt;=50;i++){for(j=1;j&lt;=50;j++)printf(&quot;%d &quot;,f[i][j]);printf(&quot;\n&quot;);}
	//printf(&quot;%I64d\n&quot;,f[25][0]);
	//printf(&quot;%d %d\n&quot;,n-K/2,K/2);
	for (i=0;i&lt;=n-K;i++)
		ans=(ans-f[25][i]*C(n-i-K/2,K/2))%mo;
	if (ans&lt;0) ans+=mo;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2282</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 999999999
#define ln printf(&quot;\n&quot;)
const int NN=301111;
int o[NN],aa[NN*2][3],dd[NN],d2[NN],dist[NN],fa[NN],pre[NN],b[NN];
int n,S,tot=1,num,mm,mi;
bool flag[NN];
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
bool check(int mid)
{
	//printf(&quot;\n--------- check %d ----------------------------------------------------\n&quot;,mid);
	int i,l,r;
	for (i=1;i&lt;=num;i++)
		if (d2[i]&gt;mid) return false;
	int tmp=0;
	for (l=1;l&lt;=num;l++)
	{
		tmp+=dd[l]-dd[l-1];
		if (d2[l]&gt;tmp) tmp=d2[l];
		if (tmp&gt;mid) break;
	}
	l--;
	tmp=0;
	for (r=num;r;r--)
	{
		tmp=tmp+dd[r+1]-dd[r];
		if (d2[r]&gt;tmp) tmp=d2[r];
		if (tmp&gt;mid) break;
	}
	r++;
	//printf(&quot;l=%d r=%d\n&quot;,l,r);
	if (l&gt;r) return true;
	if (dd[r]-dd[l]&gt;S) return false;
	return true;
}
void dfs(int v)
{
	if (dist[v]&gt;mm) mm=dist[v],mi=v;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||flag[y]) continue;
		fa[y]=v;
		dist[y]=dist[v]+aa[p][2];
		pre[y]=v;
		dfs(y);
	}
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;S);
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
	}
	dist[1]=0;fa[1]=0;mm=0;
	dfs(1);
	dist[mi]=0;fa[mi]=0;pre[mi]=0;mm=0;
	dfs(mi);
	//printf(&quot;dist &quot;);out(dist,1,n);printf(&quot;mi=%d\n&quot;,mi);
	num=0;
	for (x=mi;x;x=pre[x]) b[++num]=x,flag[x]=true;
	for (i=1;i+i&lt;=num;i++) {int t=b[i];b[i]=b[num-i+1];b[num-i+1]=t;}
	for (i=1;i&lt;=num;i++) dd[i]=dist[b[i]];
	for (i=1;i&lt;=num;i++)
	{
		mm=0;
		for (int p=o[b[i]];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (flag[y]) continue;
			dist[y]=aa[p][2];fa[y]=0;
			dfs(y);
		}
		d2[i]=mm;
	}
	//ln;printf(&quot;b &quot;);out(b,1,num);printf(&quot;dd &quot;);out(dd,1,num);printf(&quot;d2 &quot;);out(d2,1,num);
	int l=0,r=inf,ans;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (check(mid)) ans=mid,r=mid-1;
		else l=mid+1;
	}
	//ln;ln;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem2282</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 999999999
#define ln printf(&quot;\n&quot;)
const int NN=301111;
int o[NN],aa[NN*2][3],dd[NN],d2[NN],dist[NN],fa[NN],pre[NN],b[NN],sta[NN],cur[NN];
int n,S,tot=1,num,mm,mi;
bool flag[NN];
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
bool check(int mid)
{
	//printf(&quot;\n--------- check %d ----------------------------------------------------\n&quot;,mid);
	int i,l,r;
	for (i=1;i&lt;=num;i++)
		if (d2[i]&gt;mid) return false;
	int tmp=0;
	for (l=1;l&lt;=num;l++)
	{
		tmp+=dd[l]-dd[l-1];
		if (d2[l]&gt;tmp) tmp=d2[l];
		if (tmp&gt;mid) break;
	}
	l--;
	tmp=0;
	for (r=num;r;r--)
	{
		tmp=tmp+dd[r+1]-dd[r];
		if (d2[r]&gt;tmp) tmp=d2[r];
		if (tmp&gt;mid) break;
	}
	r++;
	//printf(&quot;l=%d r=%d\n&quot;,l,r);
	if (l&gt;r) return true;
	if (dd[r]-dd[l]&gt;S) return false;
	return true;
}
void dfs(int v)
{
	/*if (dist[v]&gt;mm) mm=dist[v],mi=v;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||flag[y]) continue;
		fa[y]=v;
		dist[y]=dist[v]+aa[p][2];
		pre[y]=v;
		dfs(y);
	}*/
	int top=0;
	sta[top=1]=v;
	cur[v]=o[v];
	while (top)
	{
		v=sta[top];
		if (dist[v]&gt;mm) mm=dist[v],mi=v;
		int p=cur[v];
		if (p==0) {top--;continue;}
		cur[v]=aa[p][0];
		int y=aa[p][1];
		if (y==fa[v]||flag[y]) continue;
		fa[y]=v;
		dist[y]=dist[v]+aa[p][2];
		pre[y]=v;
		sta[++top]=y;
		cur[y]=o[y];
	}
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;S);
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
	}
	dist[1]=0;fa[1]=0;mm=0;
	dfs(1);
	//printf(&quot;dist &quot;);out(dist,1,n);printf(&quot;mi=%d\n&quot;,mi);
	dist[mi]=0;fa[mi]=0;pre[mi]=0;mm=0;
	dfs(mi);
	num=0;
	for (x=mi;x;x=pre[x]) b[++num]=x,flag[x]=true;
	for (i=1;i+i&lt;=num;i++) {int t=b[i];b[i]=b[num-i+1];b[num-i+1]=t;}
	for (i=1;i&lt;=num;i++) dd[i]=dist[b[i]];
	for (i=1;i&lt;=num;i++)
	{
		mm=0;
		for (int p=o[b[i]];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (flag[y]) continue;
			dist[y]=aa[p][2];fa[y]=0;
			dfs(y);
		}
		d2[i]=mm;
	}
	//ln;printf(&quot;b &quot;);out(b,1,num);printf(&quot;dd &quot;);out(dd,1,num);printf(&quot;d2 &quot;);out(d2,1,num);
	int l=0,r=inf,ans;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (check(mid)) ans=mid,r=mid-1;
		else l=mid+1;
	}
	//ln;ln;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem2285</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
#define inf 999999999
#define sinf 999999
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define ln printf(&quot;\n&quot;)
typedef double DD;
const DD eps=1e-7;
const int NN=705,MM=401111;
int aa[MM][2],o[NN],cur[NN],du[NN],sta[NN],deep[NN],q[NN],b[NN];
int n,m,m1,n1,tot=1,S,T;
DD cc[MM],cost[NN],f[NN];
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}bool qwe=false;
void out(DD *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%.3f &quot;,a[i]);ln;}
struct edge
{
	int a,b,t,s;
} e[101111];
void tuopu()
{
	int top=0,num=0;
	for (int i=1;i&lt;=n;i++) if (!du[i]) sta[++top]=i;
	while (top)
	{
		int x=sta[top--];
		b[++num]=x;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (--du[y]==0) sta[++top]=y;
		}
	}
}
bool check(DD mid,int t)
{
	int i;
	for (i=1;i&lt;=m;i++) cc[i+1]=e[i].t-mid*e[i].s;
	for (i=1;i&lt;=n;i++) f[i]=inf;
	f[t]=0;
	for (i=n;i;i--)
	{
		int x=b[i];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (f[y]+cc[p]&lt;f[x]) f[x]=f[y]+cc[p];
		}
	}
	//printf(&quot;f &quot;);out(f,1,n);printf(&quot;The result is %s.\n&quot;,f[n]&lt;-eps?&quot;true&quot;:&quot;false&quot;);
	return f[n]&lt;-eps;
}
DD calc(int t)
{
	//printf(&quot;\n--------------------------- calc %d ------------------------------------------------------\n&quot;,t);
	DD l=0,r=inf,ans=inf;
	while (r-l&gt;1e-4)
	{
		//printf(&quot;========== mid=%.3f ==========\n&quot;,(l+r)*0.5);
		DD mid=(l+r)*0.5;
		if (check(mid,t)) ans=mid,r=mid;
		else l=mid;
		if (f[n]&gt;inf*0.5) return sinf;
	}
	//printf(&quot;ans=%.3f\n&quot;,ans);
	return ans;
}
bool bfs()
{
	int head=0,tail=1;
	memset(deep,0,4*(T+10));
	deep[S]=1;
	q[1]=S;
	while (head&lt;tail)
	{
		int x=q[++head];
		cur[x]=o[x];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (!deep[y]&amp;&amp;cc[p]&gt;eps)
				deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[T];
}
DD dfs(int v,DD ff)
{
	if (v==T) return ff;
	DD res=0;
	for (int &amp;p=cur[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]!=deep[v]+1||cc[p]&lt;eps) continue;
		DD tmp=dfs(y,mii(ff,cc[p]));
		ff-=tmp,cc[p]-=tmp;
		cc[p^1]+=tmp,res+=tmp;
		if (ff&lt;eps) break;
	}
	if (res&lt;eps) deep[v]=inf;
	return res;
}
inline void addedge(int p,int q,DD v)
{
	//printf(&quot;addedge %d %d %.3f\n&quot;,p,q,v);
	tot++;
	aa[tot][1]=q;
	cc[tot]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline void add(int p,int q,DD v)
{
	addedge(p,q,v);
	addedge(q,p,0);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].t,&amp;e[i].s);
		addedge(e[i].a,e[i].b,0);du[e[i].b]++;
	}
	tuopu();
	//ln;printf(&quot;b &quot;);out(b,1,n);
	scanf(&quot;%d%d&quot;,&amp;m1,&amp;n1);
	//printf(&quot;0\n&quot;);
	for (i=1;i&lt;=n1;i++) cost[i]=calc(i);
	//printf(&quot;0\n&quot;);for (;;);
	//ln;printf(&quot;cost &quot;);out(cost,1,n1);
	memset(o,0,sizeof(o));tot=1;
	S=n1+1,T=S+1;
	for (i=1;i&lt;=n1;i+=2) add(S,i,cost[i]);
	for (i=2;i&lt;=n1;i+=2) add(i,T,cost[i]);
	for (i=1;i&lt;=m1;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y),add(x,y,inf);
		if (cost[x]&gt;sinf-eps&amp;&amp;cost[y]&gt;sinf-eps)
			{printf(&quot;-1\n&quot;);return 0;}
	}
	DD ans=0;
	while (bfs()) ans+=dfs(S,inf);
	//ln;ln;
	printf(&quot;%.1f\n&quot;,ans);
	return 0;
}<pre><h2>Problem2285</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
#define inf 999999999
#define sinf 999999
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define ln printf(&quot;\n&quot;)
typedef double DD;
const DD eps=1e-7;
const int NN=705,MM=401111;
int aa[MM][2],o[NN],cur[NN],du[NN],sta[NN],deep[NN],q[NN],b[NN];
int n,m,m1,n1,tot=1,S,T;
DD cc[MM],cost[NN],f[NN];
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}bool qwe=false;
void out(DD *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%.3f &quot;,a[i]);ln;}
struct edge
{
	int a,b,t,s;
} e[101111];
void tuopu()
{
	int top=0,num=0;
	for (int i=1;i&lt;=n;i++) if (!du[i]) sta[++top]=i;
	while (top)
	{
		int x=sta[top--];
		b[++num]=x;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (--du[y]==0) sta[++top]=y;
		}
	}
}
bool check(DD mid,int t)
{
	int i;
	for (i=1;i&lt;=m;i++) cc[i+1]=e[i].t-mid*e[i].s;
	for (i=1;i&lt;=n;i++) f[i]=inf;
	f[t]=0;
	for (i=n;i;i--)
	{
		int x=b[i];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (f[y]+cc[p]&lt;f[x]) f[x]=f[y]+cc[p];
		}
	}
	//printf(&quot;f &quot;);out(f,1,n);printf(&quot;The result is %s.\n&quot;,f[n]&lt;-eps?&quot;true&quot;:&quot;false&quot;);
	return f[n]&lt;-eps;
}
DD calc(int t)
{
	//printf(&quot;\n--------------------------- calc %d ------------------------------------------------------\n&quot;,t);
	DD l=0,r=inf,ans=inf;
	while (r-l&gt;1e-4)
	{
		//printf(&quot;========== mid=%.3f ==========\n&quot;,(l+r)*0.5);
		DD mid=(l+r)*0.5;
		if (check(mid,t)) ans=mid,r=mid;
		else l=mid;
		if (fabs(f[n])&lt;eps) return mid;
		if (f[n]&gt;inf*0.5) return sinf;
	}
	//printf(&quot;ans=%.3f\n&quot;,ans);
	return ans;
}
bool bfs()
{
	int head=0,tail=1;
	memset(deep,0,4*(T+10));
	deep[S]=1;
	q[1]=S;
	while (head&lt;tail)
	{
		int x=q[++head];
		cur[x]=o[x];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (!deep[y]&amp;&amp;cc[p]&gt;eps)
				deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[T];
}
DD dfs(int v,DD ff)
{
	if (v==T) return ff;
	DD res=0;
	for (int &amp;p=cur[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]!=deep[v]+1||cc[p]&lt;eps) continue;
		DD tmp=dfs(y,mii(ff,cc[p]));
		ff-=tmp,cc[p]-=tmp;
		cc[p^1]+=tmp,res+=tmp;
		if (ff&lt;eps) break;
	}
	if (res&lt;eps) deep[v]=inf;
	return res;
}
inline void addedge(int p,int q,DD v)
{
	//printf(&quot;addedge %d %d %.3f\n&quot;,p,q,v);
	tot++;
	aa[tot][1]=q;
	cc[tot]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline void add(int p,int q,DD v)
{
	addedge(p,q,v);
	addedge(q,p,0);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].t,&amp;e[i].s);
		addedge(e[i].a,e[i].b,0);du[e[i].b]++;
	}
	tuopu();
	//ln;printf(&quot;b &quot;);out(b,1,n);
	scanf(&quot;%d%d&quot;,&amp;m1,&amp;n1);
	//printf(&quot;0\n&quot;);
	for (i=1;i&lt;=n1;i++) cost[i]=calc(i);
	//printf(&quot;0\n&quot;);for (;;);
	//ln;printf(&quot;cost &quot;);out(cost,1,n1);
	memset(o,0,sizeof(o));tot=1;
	S=n1+1,T=S+1;
	for (i=1;i&lt;=n1;i+=2) add(S,i,cost[i]);
	for (i=2;i&lt;=n1;i+=2) add(i,T,cost[i]);
	for (i=1;i&lt;=m1;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y),add(x,y,inf);
		if (cost[x]&gt;sinf-eps&amp;&amp;cost[y]&gt;sinf-eps)
			{printf(&quot;-1\n&quot;);return 0;}
	}
	DD ans=0;
	while (bfs()) ans+=dfs(S,inf);
	//ln;ln;
	printf(&quot;%.1f\n&quot;,ans);
	return 0;
}<pre><h2>Problem2285</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
#define inf 999999999
#define sinf 999999
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define ln printf(&quot;\n&quot;)
typedef double DD;
const DD eps=1e-7;
const int NN=705,MM=401111;
int aa[MM][2],o[NN],cur[NN],du[NN],sta[NN],deep[NN],q[NN],b[NN];
int n,m,m1,n1,tot=1,S,T;
DD cc[MM],cost[NN],f[NN];
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}bool qwe=false;
void out(DD *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%.3f &quot;,a[i]);ln;}
struct edge
{
	int a,b,t,s;
} e[101111];
void tuopu()
{
	int top=0,num=0;
	for (int i=1;i&lt;=n;i++) if (!du[i]) sta[++top]=i;
	while (top)
	{
		int x=sta[top--];
		b[++num]=x;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (--du[y]==0) sta[++top]=y;
		}
	}
}
bool check(DD mid,int t)
{
	int i;
	for (i=1;i&lt;=m;i++) cc[i+1]=e[i].t-mid*e[i].s;
	for (i=1;i&lt;=n;i++) f[i]=inf;
	f[t]=0;
	for (i=n;i;i--)
	{
		int x=b[i];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (f[y]+cc[p]&lt;f[x]) f[x]=f[y]+cc[p];
		}
	}
	//printf(&quot;f &quot;);out(f,1,n);printf(&quot;The result is %s.\n&quot;,f[n]&lt;-eps?&quot;true&quot;:&quot;false&quot;);
	return f[n]&lt;-eps;
}
DD calc(int t)
{
	//printf(&quot;\n--------------------------- calc %d ------------------------------------------------------\n&quot;,t);
	DD l=0,r=1000,ans=inf;
	while (r-l&gt;1e-4)
	{
		//printf(&quot;========== mid=%.3f ==========\n&quot;,(l+r)*0.5);
		DD mid=(l+r)*0.5;
		if (check(mid,t)) ans=mid,r=mid;
		else l=mid;
		if (fabs(f[n])&lt;eps) return mid;
		if (f[n]&gt;inf*0.5) return sinf;
	}
	//printf(&quot;ans=%.3f\n&quot;,ans);
	return ans;
}
bool bfs()
{
	int head=0,tail=1;
	memset(deep,0,4*(T+10));
	deep[S]=1;
	q[1]=S;
	while (head&lt;tail)
	{
		int x=q[++head];
		cur[x]=o[x];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (!deep[y]&amp;&amp;cc[p]&gt;eps)
				deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[T];
}
DD dfs(int v,DD ff)
{
	if (v==T) return ff;
	DD res=0;
	for (int &amp;p=cur[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]!=deep[v]+1||cc[p]&lt;eps) continue;
		DD tmp=dfs(y,mii(ff,cc[p]));
		ff-=tmp,cc[p]-=tmp;
		cc[p^1]+=tmp,res+=tmp;
		if (ff&lt;eps) break;
	}
	if (res&lt;eps) deep[v]=inf;
	return res;
}
inline void addedge(int p,int q,DD v)
{
	//printf(&quot;addedge %d %d %.3f\n&quot;,p,q,v);
	tot++;
	aa[tot][1]=q;
	cc[tot]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline void add(int p,int q,DD v)
{
	addedge(p,q,v);
	addedge(q,p,0);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].t,&amp;e[i].s);
		addedge(e[i].a,e[i].b,0);du[e[i].b]++;
	}
	tuopu();
	//ln;printf(&quot;b &quot;);out(b,1,n);
	scanf(&quot;%d%d&quot;,&amp;m1,&amp;n1);
	//printf(&quot;0\n&quot;);
	for (i=1;i&lt;=n1;i++) cost[i]=calc(i);
	//printf(&quot;0\n&quot;);for (;;);
	//ln;printf(&quot;cost &quot;);out(cost,1,n1);
	memset(o,0,sizeof(o));tot=1;
	S=n1+1,T=S+1;
	for (i=1;i&lt;=n1;i+=2) add(S,i,cost[i]);
	for (i=2;i&lt;=n1;i+=2) add(i,T,cost[i]);
	for (i=1;i&lt;=m1;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y),add(x,y,inf);
		if (cost[x]&gt;sinf-eps&amp;&amp;cost[y]&gt;sinf-eps)
			{printf(&quot;-1\n&quot;);return 0;}
	}
	DD ans=0;
	while (bfs()) ans+=dfs(S,inf);
	//ln;ln;
	printf(&quot;%.1f\n&quot;,ans);
	return 0;
}<pre><h2>Problem2285</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
#define inf 999999999
#define sinf 999999
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define ln printf(&quot;\n&quot;)
typedef double DD;
const DD eps=1e-7;
const int NN=705,MM=401111;
int aa[MM][2],o[NN],cur[NN],du[NN],sta[NN],deep[NN],q[NN],b[NN];
int n,m,m1,n1,tot=1,S,T;
DD cc[MM],cost[NN],f[NN];
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}bool qwe=false;
void out(DD *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%.3f &quot;,a[i]);ln;}
struct edge
{
	int a,b,t,s;
} e[101111];
void tuopu()
{
	int top=0,num=0;
	for (int i=1;i&lt;=n;i++) if (!du[i]) sta[++top]=i;
	while (top)
	{
		int x=sta[top--];
		b[++num]=x;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (--du[y]==0) sta[++top]=y;
		}
	}
}
bool check(DD mid,int t)
{
	int i;
	for (i=1;i&lt;=m;i++) cc[i+1]=e[i].t-mid*e[i].s;
	for (i=1;i&lt;=n;i++) f[i]=inf;
	f[t]=0;
	for (i=n;i;i--)
	{
		int x=b[i];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (f[y]+cc[p]&lt;f[x]) f[x]=f[y]+cc[p];
		}
	}
	//printf(&quot;f &quot;);out(f,1,n);printf(&quot;The result is %s.\n&quot;,f[n]&lt;-eps?&quot;true&quot;:&quot;false&quot;);
	return f[n]&lt;-eps;
}
DD calc(int t)
{
	//printf(&quot;\n--------------------------- calc %d ------------------------------------------------------\n&quot;,t);
	DD l=0,r=1000,ans=inf,li=1e-3;
	while (r-l&gt;li)
	{
		//printf(&quot;========== mid=%.3f ==========\n&quot;,(l+r)*0.5);
		DD mid=(l+r)*0.5;
		if (check(mid,t)) ans=mid,r=mid;
		else l=mid;
		if (fabs(f[n])&lt;eps) return mid;
		if (f[n]&gt;inf*0.5) return sinf;
	}
	//printf(&quot;ans=%.3f\n&quot;,ans);
	return ans;
}
bool bfs()
{
	int head=0,tail=1;
	memset(deep,0,4*(T+10));
	deep[S]=1;
	q[1]=S;
	while (head&lt;tail)
	{
		int x=q[++head];
		cur[x]=o[x];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (!deep[y]&amp;&amp;cc[p]&gt;eps)
				deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[T];
}
DD dfs(int v,DD ff)
{
	if (v==T) return ff;
	DD res=0;
	for (int &amp;p=cur[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]!=deep[v]+1||cc[p]&lt;eps) continue;
		DD tmp=dfs(y,mii(ff,cc[p]));
		ff-=tmp,cc[p]-=tmp;
		cc[p^1]+=tmp,res+=tmp;
		if (ff&lt;eps) break;
	}
	if (res&lt;eps) deep[v]=inf;
	return res;
}
inline void addedge(int p,int q,DD v)
{
	//printf(&quot;addedge %d %d %.3f\n&quot;,p,q,v);
	tot++;
	aa[tot][1]=q;
	cc[tot]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline void add(int p,int q,DD v)
{
	addedge(p,q,v);
	addedge(q,p,0);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].t,&amp;e[i].s);
		addedge(e[i].a,e[i].b,0);du[e[i].b]++;
	}
	tuopu();
	//ln;printf(&quot;b &quot;);out(b,1,n);
	scanf(&quot;%d%d&quot;,&amp;m1,&amp;n1);
	//printf(&quot;0\n&quot;);
	for (i=1;i&lt;=n1;i++) cost[i]=calc(i);
	//printf(&quot;0\n&quot;);for (;;);
	//ln;printf(&quot;cost &quot;);out(cost,1,n1);
	memset(o,0,sizeof(o));tot=1;
	S=n1+1,T=S+1;
	for (i=1;i&lt;=n1;i+=2) add(S,i,cost[i]);
	for (i=2;i&lt;=n1;i+=2) add(i,T,cost[i]);
	for (i=1;i&lt;=m1;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y),add(x,y,inf);
		if (cost[x]&gt;sinf-eps&amp;&amp;cost[y]&gt;sinf-eps)
			{printf(&quot;-1\n&quot;);return 0;}
	}
	DD ans=0;
	while (bfs()) ans+=dfs(S,inf);
	//ln;ln;
	printf(&quot;%.1f\n&quot;,ans);
	return 0;
}<pre><h2>Problem2285</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
#define inf 999999999
#define sinf 999999
#define mii(a,b) ((a)&lt;(b)?(a):(b))
typedef double DD;
const DD eps=1e-7;
const int NN=705,MM=101111;
int aa[MM][2],o[NN],cur[NN],du[NN],sta[NN],deep[NN],q[NN],b[NN];
int n,m,m1,n1,tot=1,S,T;
DD cc[MM],cost[NN],f[NN];
struct edge
{
	int a,b,t,s;
} e[101111];
void tuopu()
{
	int top=0,num=0;
	for (int i=1;i&lt;=n;i++) if (!du[i]) sta[++top]=i;
	while (top)
	{
		int x=sta[top--];
		b[++num]=x;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (--du[y]==0) sta[++top]=y;
		}
	}
}
bool check(DD mid,int t)
{
	int i;
	for (i=1;i&lt;=m;i++) cc[i+1]=e[i].t-mid*e[i].s;
	for (i=1;i&lt;=n;i++) f[i]=inf;
	f[t]=0;
	for (i=n;i;i--)
	{
		int x=b[i];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (f[y]+cc[p]&lt;f[x]) f[x]=f[y]+cc[p];
		}
	}
	return f[n]&lt;-eps;
}
DD calc(int t)
{
	DD l=0,r=1000,ans=inf,li=1e-3;
	while (r-l&gt;li)
	{
		DD mid=(l+r)*0.5;
		if (check(mid,t)) ans=mid,r=mid;
		else l=mid;
		if (fabs(f[n])&lt;eps) return mid;
		if (f[n]&gt;inf*0.5) return sinf;
	}
	return ans;
}
bool bfs()
{
	int head=0,tail=1;
	memset(deep,0,4*(T+10));
	deep[S]=1;
	q[1]=S;
	while (head&lt;tail)
	{
		int x=q[++head];
		cur[x]=o[x];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (!deep[y]&amp;&amp;cc[p]&gt;eps)
				deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[T];
}
DD dfs(int v,DD ff)
{
	if (v==T) return ff;
	DD res=0;
	for (int &amp;p=cur[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]!=deep[v]+1||cc[p]&lt;eps) continue;
		DD tmp=dfs(y,mii(ff,cc[p]));
		ff-=tmp,cc[p]-=tmp;
		cc[p^1]+=tmp,res+=tmp;
		if (ff&lt;eps) break;
	}
	if (res&lt;eps) deep[v]=inf;
	return res;
}
inline void addedge(int p,int q,DD v)
{
	tot++;
	aa[tot][1]=q;
	cc[tot]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline void add(int p,int q,DD v)
{
	addedge(p,q,v);
	addedge(q,p,0);
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].t,&amp;e[i].s);
		addedge(e[i].a,e[i].b,0);du[e[i].b]++;
	}
	tuopu();
	scanf(&quot;%d%d&quot;,&amp;m1,&amp;n1);
	for (i=1;i&lt;=n1;i++) cost[i]=calc(i);
	memset(o,0,sizeof(o));tot=1;
	S=n1+1,T=S+1;
	for (i=1;i&lt;=n1;i+=2) add(S,i,cost[i]);
	for (i=2;i&lt;=n1;i+=2) add(i,T,cost[i]);
	for (i=1;i&lt;=m1;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y),add(x,y,inf);
		if (cost[x]&gt;sinf-eps&amp;&amp;cost[y]&gt;sinf-eps)
			{printf(&quot;-1\n&quot;);return 0;}
	}
	DD ans=0;
	while (bfs()) ans+=dfs(S,inf);
	printf(&quot;%.1f\n&quot;,ans);
	return 0;
}<pre><h2>Problem2286</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define inf 999999999
const int NN=251111;
int o[NN],aa[NN*2][3],deep[NN],fa[20][NN],the[20][NN],sta[NN],dfn[NN];
int vt[NN],flag[NN],a[NN];
int n,m,tot,top,TIME,num;
LL f[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs(int v)
{
	dfn[v]=++TIME;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[0][v]) continue;
		fa[0][y]=v;
		the[0][y]=aa[p][2];
		deep[y]=deep[v]+1;
		dfs(y);
	}
}
void prepare()
{
	deep[1]=1;
	dfs(1);
	for (int j=1;j&lt;=19;j++)
		for (int i=1;i&lt;=n;i++)
		{
			fa[j][i]=fa[j-1][fa[j-1][i]];
			the[j][i]=min(the[j-1][i],the[j-1][fa[j-1][i]]);
		}
}
inline int getlca(int x,int y)
{
	if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
	for (int i=19;i&gt;=0;i--)
		if (deep[fa[i][x]]&gt;=deep[y]) x=fa[i][x];
	if (x==y) return x;
	for (int i=19;i&gt;=0;i--)
		if (fa[i][x]!=fa[i][y]) x=fa[i][x],y=fa[i][y];
	return fa[0][x];
}
inline int getmin(int x,int y)
{
	if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
	int res=inf;
	for (int i=19;i&gt;=0;i--)
		if (deep[fa[i][x]]&gt;=deep[y])
			res=min(res,the[i][x]),x=fa[i][x];
	return res;
}
inline void add2(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=getmin(p,q);
	if (vt[p]!=TIME) vt[p]=TIME,o[p]=0;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dp()
{
	static int que[NN];
	int head=0,tail=1;
	que[1]=1;
	while (head&lt;tail)
	{
		int x=que[++head];
		if (vt[x]!=TIME) continue;
		for (int p=o[x];p;p=aa[p][0]) que[++tail]=aa[p][1];
	}
	for (int i=tail;i;i--)
	{
		int x=que[i];
		f[x]=0;
		if (vt[x]!=TIME) continue;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (flag[y]==m) f[x]+=aa[p][2];
			else f[x]+=min((LL)aa[p][2],f[y]);
		}
	}
}
bool cmp(const int &amp;a,const int &amp;b) {return dfn[a]&lt;dfn[b];}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y),read(z);
		addedge(x,y,z),addedge(y,x,z);
	}
	prepare();
	for (read(m);m;m--)
	{
		tot=0;TIME++;
		read(num);
		for (i=1;i&lt;=num;i++)
		{
			read(a[i]);
			flag[a[i]]=m;
		}
		sort(a+1,a+num+1,cmp);
		sta[top=1]=1;
		for (i=1;i&lt;=num;i++)
		{
			x=a[i];
			int lca=getlca(x,sta[top]);
			for (;deep[lca]&lt;deep[sta[top]];top--)
			{
				if (deep[sta[top-1]]&lt;=deep[lca])
				{
					add2(lca,sta[top--]);
					if (lca!=sta[top]) sta[++top]=lca;
					break;
				}
				add2(sta[top-1],sta[top]);
			}
			if (x!=sta[top]) sta[++top]=x;
		}
		for (;top&gt;1;top--) add2(sta[top-1],sta[top]);
		dp();
		printf(&quot;%lld\n&quot;,f[1]);
	}
	return 0;
}<pre><h2>Problem2286</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define inf 999999999
const int NN=251111;
int o[NN],aa[NN*2][3],deep[NN],fa[20][NN],the[20][NN],sta[NN],dfn[NN];
int vt[NN],flag[NN],a[NN];
int n,m,tot,top,TIME,num;
LL f[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs()
{
	static int cur[NN];
	sta[top=1]=1;
	dfn[1]=++TIME;
	cur[1]=o[1];
	while (top)
	{
		int v=sta[top];
		int p=cur[v];
		if (p==0) {top--;continue;}
		int y=aa[p][1];;
		cur[v]=aa[p][0];
		if (y==fa[0][v]) continue;
		fa[0][y]=v;
		the[0][y]=aa[p][2];
		deep[y]=deep[v]+1;
		sta[++top]=y;
		cur[y]=o[y];
		dfn[y]=++TIME;
	}
}
void prepare()
{
	deep[1]=1;
	dfs();
	for (int j=1;j&lt;=19;j++)
		for (int i=1;i&lt;=n;i++)
		{
			fa[j][i]=fa[j-1][fa[j-1][i]];
			the[j][i]=min(the[j-1][i],the[j-1][fa[j-1][i]]);
		}
}
inline int getlca(int x,int y)
{
	if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
	for (int i=19;i&gt;=0;i--)
		if (deep[fa[i][x]]&gt;=deep[y]) x=fa[i][x];
	if (x==y) return x;
	for (int i=19;i&gt;=0;i--)
		if (fa[i][x]!=fa[i][y]) x=fa[i][x],y=fa[i][y];
	return fa[0][x];
}
inline int getmin(int x,int y)
{
	if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
	int res=inf;
	for (int i=19;i&gt;=0;i--)
		if (deep[fa[i][x]]&gt;=deep[y])
			res=min(res,the[i][x]),x=fa[i][x];
	return res;
}
inline void add2(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=getmin(p,q);
	if (vt[p]!=TIME) vt[p]=TIME,o[p]=0;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dp()
{
	static int que[NN];
	int head=0,tail=1;
	que[1]=1;
	while (head&lt;tail)
	{
		int x=que[++head];
		if (vt[x]!=TIME) continue;
		for (int p=o[x];p;p=aa[p][0]) que[++tail]=aa[p][1];
	}
	for (int i=tail;i;i--)
	{
		int x=que[i];
		f[x]=0;
		if (vt[x]!=TIME) continue;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (flag[y]==m) f[x]+=aa[p][2];
			else f[x]+=min((LL)aa[p][2],f[y]);
		}
	}
}
bool cmp(const int &amp;a,const int &amp;b) {return dfn[a]&lt;dfn[b];}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y),read(z);
		addedge(x,y,z),addedge(y,x,z);
	}
	prepare();
	for (read(m);m;m--)
	{
		tot=0;TIME++;
		read(num);
		for (i=1;i&lt;=num;i++)
		{
			read(a[i]);
			flag[a[i]]=m;
		}
		sort(a+1,a+num+1,cmp);
		sta[top=1]=1;
		for (i=1;i&lt;=num;i++)
		{
			x=a[i];
			int lca=getlca(x,sta[top]);
			for (;deep[lca]&lt;deep[sta[top]];top--)
			{
				if (deep[sta[top-1]]&lt;=deep[lca])
				{
					add2(lca,sta[top--]);
					if (lca!=sta[top]) sta[++top]=lca;
					break;
				}
				add2(sta[top-1],sta[top]);
			}
			if (x!=sta[top]) sta[++top]=x;
		}
		for (;top&gt;1;top--) add2(sta[top-1],sta[top]);
		dp();
		printf(&quot;%lld\n&quot;,f[1]);
	}
	return 0;
}<pre><h2>Problem2286</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define inf 999999999
#define ln printf(&quot;\n&quot;)
const int NN=2051111;
int o[NN],aa[NN][3],dfn[NN],deep[NN];
int n,m,tot,dfx,tes;
LL f[NN];
bool flag[NN];
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);ln;}
struct Shu
{
	int fa[21][NN],the[21][NN];
	inline void addedge(int p,int q,int v)
	{
		tot++;
		aa[tot][1]=q;
		aa[tot][2]=v;
		aa[tot][0]=o[p];
		o[p]=tot;
	}
	void dfs(int v)
	{
		dfn[v]=++dfx;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[0][v]) continue;
			fa[0][y]=v;
			the[0][y]=aa[p][2];
			deep[y]=deep[v]+1;
			dfs(y);
		}
	}
	void in()
	{
		scanf(&quot;%d&quot;,&amp;n);
		int i,j,x,y,z;
		for (i=1;i&lt;n;i++)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			addedge(x,y,z),addedge(y,x,z);
		}
		deep[1]=1;
		dfs(1);
		for (j=1;j&lt;=20;j++)
			for (i=1;i&lt;=n;i++)
			{
				fa[j][i]=fa[j-1][fa[j-1][i]];
				the[j][i]=min(the[j-1][i],the[j-1][fa[j-1][i]]);
			}
	}
	int getmin(int x,int y)
	{
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		//printf(&quot;getmin %d %d\n&quot;,x,y);
		int res=inf;
		for (int i=20;i&gt;=0;i--)
			if (deep[fa[i][x]]&gt;=deep[y])
			{
				//printf(&quot;i=%d\n&quot;,i);
				res=min(res,the[i][x]);
				x=fa[i][x];
			}
		return res;
	}
	int getlca(int x,int y)
	{
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		for (int i=20;i&gt;=0;i--)
			if (deep[fa[i][x]]&gt;=deep[y]) x=fa[i][x];
		if (x==y) return x;
		for (int i=20;i&gt;=0;i--)
			if (fa[i][x]!=fa[i][y]) x=fa[i][x],y=fa[i][y];
		return fa[0][x];
	}
} shu;
bool cmp(const int &amp;a,const int &amp;b) {return dfn[a]&lt;dfn[b];}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=shu.getmin(p,q);
	aa[tot][0]=o[p];
	o[p]=tot;
	//printf(&quot;addedge %d %d %d\n&quot;,p,q,aa[tot][2]);
}
void dp(int v)
{
	//printf(&quot;dp %d\n&quot;,v);
	f[v]=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		dp(y);
		if (flag[y]) f[v]+=aa[p][2];
		else f[v]+=min((LL)aa[p][2],f[y]);
	}
}
void work()
{
	//printf(&quot;\n------------------------------------------------------------------------\n&quot;);
	static int a[NN],b[NN],sta[NN],fa[NN];
	int i,top,cnt;
	scanf(&quot;%d&quot;,&amp;m);
	for (i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	sort(a+1,a+m+1,cmp);
	sta[top=1]=b[cnt=1]=1;
	for (i=1;i&lt;=m;i++)
	{
		//printf(&quot;================================\n&quot;);
		int x=a[i];
		//printf(&quot;x=%d\n&quot;,x);
		flag[x]=true;
		int lca=shu.getlca(x,sta[top]);
		while (deep[lca]&lt;deep[sta[top]])
		{
			if (deep[lca]&gt;=deep[sta[top-1]])
			{
				fa[sta[top--]]=lca;
				if (lca!=sta[top])
				{
					sta[++top]=b[++cnt]=lca;
					flag[lca]=false;
				}
				break;
			}
			fa[sta[top]]=sta[top-1];
			top--;
		}
		if (x!=sta[top]) sta[++top]=b[++cnt]=x;
	}
	//printf(&quot;sta &quot;);out(sta,1,top);
	for (;top;top--) fa[sta[top]]=sta[top-1];
	//printf(&quot;b &quot;);out(b,1,cnt);printf(&quot;fa &quot;);out(fa,1,n);
	for (i=1;i&lt;=cnt;i++) o[b[i]]=0;
	tot=0;
	for (i=2;i&lt;=cnt;i++) addedge(fa[b[i]],b[i]);
	dp(1);
	printf(&quot;%lld\n&quot;,f[1]);
}
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	shu.in();
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--) work();
	return 0;
}<pre><h2>Problem2286</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define inf 999999999
#define ln printf(&quot;\n&quot;)
const int NN=251111;
int o[NN],aa[NN*2][3],dfn[NN],deep[NN];
int n,m,tot,dfx,tes;
LL f[NN];
bool flag[NN];
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);ln;}
struct Shu
{
	int fa[21][NN],the[21][NN];
	inline void addedge(int p,int q,int v)
	{
		tot++;
		aa[tot][1]=q;
		aa[tot][2]=v;
		aa[tot][0]=o[p];
		o[p]=tot;
	}
	void dfs(int v)
	{
		dfn[v]=++dfx;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[0][v]) continue;
			fa[0][y]=v;
			the[0][y]=aa[p][2];
			deep[y]=deep[v]+1;
			dfs(y);
		}
	}
	void in()
	{
		scanf(&quot;%d&quot;,&amp;n);
		int i,j,x,y,z;
		for (i=1;i&lt;n;i++)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			addedge(x,y,z),addedge(y,x,z);
		}
		deep[1]=1;
		dfs(1);
		for (j=1;j&lt;=20;j++)
			for (i=1;i&lt;=n;i++)
			{
				fa[j][i]=fa[j-1][fa[j-1][i]];
				the[j][i]=min(the[j-1][i],the[j-1][fa[j-1][i]]);
			}
	}
	int getmin(int x,int y)
	{
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		//printf(&quot;getmin %d %d\n&quot;,x,y);
		int res=inf;
		for (int i=20;i&gt;=0;i--)
			if (deep[fa[i][x]]&gt;=deep[y])
			{
				//printf(&quot;i=%d\n&quot;,i);
				res=min(res,the[i][x]);
				x=fa[i][x];
			}
		return res;
	}
	int getlca(int x,int y)
	{
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		for (int i=20;i&gt;=0;i--)
			if (deep[fa[i][x]]&gt;=deep[y]) x=fa[i][x];
		if (x==y) return x;
		for (int i=20;i&gt;=0;i--)
			if (fa[i][x]!=fa[i][y]) x=fa[i][x],y=fa[i][y];
		return fa[0][x];
	}
} shu;
bool cmp(const int &amp;a,const int &amp;b) {return dfn[a]&lt;dfn[b];}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=shu.getmin(p,q);
	aa[tot][0]=o[p];
	o[p]=tot;
	//printf(&quot;addedge %d %d %d\n&quot;,p,q,aa[tot][2]);
}
void dp(int v)
{
	//printf(&quot;dp %d\n&quot;,v);
	f[v]=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		dp(y);
		if (flag[y]) f[v]+=aa[p][2];
		else f[v]+=min((LL)aa[p][2],f[y]);
	}
}
void work()
{
	//printf(&quot;\n------------------------------------------------------------------------\n&quot;);
	static int a[NN],b[NN],sta[NN],fa[NN];
	int i,top,cnt;
	scanf(&quot;%d&quot;,&amp;m);
	for (i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	sort(a+1,a+m+1,cmp);
	sta[top=1]=b[cnt=1]=1;
	for (i=1;i&lt;=m;i++)
	{
		//printf(&quot;================================\n&quot;);
		int x=a[i];
		//printf(&quot;x=%d\n&quot;,x);
		flag[x]=true;
		int lca=shu.getlca(x,sta[top]);
		while (deep[lca]&lt;deep[sta[top]])
		{
			if (deep[lca]&gt;=deep[sta[top-1]])
			{
				fa[sta[top--]]=lca;
				if (lca!=sta[top])
				{
					sta[++top]=b[++cnt]=lca;
					flag[lca]=false;
				}
				break;
			}
			fa[sta[top]]=sta[top-1];
			top--;
		}
		if (x!=sta[top]) sta[++top]=b[++cnt]=x;
	}
	//printf(&quot;sta &quot;);out(sta,1,top);
	for (;top;top--) fa[sta[top]]=sta[top-1];
	//printf(&quot;b &quot;);out(b,1,cnt);printf(&quot;fa &quot;);out(fa,1,n);
	for (i=1;i&lt;=cnt;i++) o[b[i]]=0;
	tot=0;
	for (i=2;i&lt;=cnt;i++) addedge(fa[b[i]],b[i]);
	dp(1);
	printf(&quot;%lld\n&quot;,f[1]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	shu.in();
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--) work();
	return 0;
}<pre><h2>Problem2289</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
typedef pair&lt;DD,DD&gt; pdd;
#define mp make_pair
#define fi first
#define se second
#define sqr(x) ((x)*(x))
#define ln printf(&quot;\n&quot;)
const DD dinf=1e30,eps=1e-8;
const int NN=101111;
int n;
inline int dcmp(DD x)
{
	if (fabs(x)&lt;eps) return 0;
	return x&lt;0?-1:1;
}
DD yxdl(DD a,DD b,DD c)
{
	DD cosA=(sqr(a)+sqr(b)-sqr(c))/(2*a*b);
	return acos(cosA);
}
struct point
{
	DD x,y;
	point(DD a=0,DD b=0) {x=a;y=b;}
	void out() {printf(&quot;x=%.3f y=%.3f  \n&quot;,x,y);}
	DD len() {return sqrt(sqr(x)+sqr(y));}
	point rotate(DD sita)
	{
		DD t1=x,t2=y;
		x=t1*cos(sita)-t2*sin(sita);
		y=t2*cos(sita)+t1*sin(sita);
		return *this;
	}
	friend point operator +(point a,point b) {return point(a.x+b.x,a.y+b.y);}
	friend point operator -(point a,point b) {return point(a.x-b.x,a.y-b.y);}
	friend point operator /(point a,DD t) {return point(a.x/t,a.y/t);}
	friend point operator *(point a,DD t) {return point(a.x*t,a.y*t);}
};
struct Yuan
{
	point O;DD r;
	void in() {scanf(&quot;%lf%lf%lf&quot;,&amp;O.x,&amp;O.y,&amp;r);}
	friend point operator &amp;(Yuan a,Yuan b)
	{
		if (a.r&lt;b.r) swap(a,b);
		DD r1=a.r,r2=b.r,d=(a.O-b.O).len();
		if (dcmp(d-(r1+r2))&gt;=0) {printf(&quot;NO\n&quot;);exit(0);}
		if (dcmp(d-(r1-r2))&lt;=0) return b.O;
		DD sita=yxdl(d,r1,r2);
		point v=(b.O-a.O).rotate(sita);
		v=v/d*r1;
		return a.O+v;
	}
} C[NN];
pdd getqj(DD X,Yuan C)
{
	DD d=fabs(C.O.x-X);
	DD l=sqrt(sqr(C.r)-sqr(d));
	return mp(C.O.y-l,C.O.y+l);
}
inline bool pan(DD X,point P)
{
	if (P.x&gt;X) return true;
	return false;
}
bool work(DD X)
{
	pdd now=mp(-dinf,dinf);
	int lfrom,rfrom,i;
	for (i=1;i&lt;=n;i++)
	{
		//printf(&quot;=========== i=%d ===========\n&quot;,i);
		if (dcmp(fabs(X-C[i].O.x)-C[i].r)&gt;=0) return pan(X,C[i]&amp;C[i==1?2:1]);
		pdd tmp=getqj(X,C[i]);
		//printf(&quot;%.3f %.3f\n&quot;,tmp.fi,tmp.se);
		if (dcmp(tmp.se-now.fi)&lt;=0) return pan(X,C[i]&amp;C[lfrom]);
		if (dcmp(tmp.fi-now.se)&gt;=0) return pan(X,C[i]&amp;C[rfrom]);
		if (dcmp(tmp.fi-now.fi)&gt;0) now.fi=tmp.fi,lfrom=i;
		if (dcmp(tmp.se-now.se)&lt;0) now.se=tmp.se,rfrom=i;
	}
	//printf(&quot;%.3f %.3f\n&quot;,now.fi,now.se);
	printf(&quot;YES\n&quot;);exit(0);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	if (n==1) {printf(&quot;YES\n&quot;);return 0;}
	DD l=dinf,r=-dinf;
	int i;
	for (i=1;i&lt;=n;i++)
	{
		C[i].in();
		l=min(l,C[i].O.x-C[i].r);
		r=max(r,C[i].O.x+C[i].r);
	}
	//(C[1]&amp;C[1]).out();ln;
	while (r-l&gt;0.0000001)
	{
		DD mid=(l+r)*0.5;
		//printf(&quot;\n------------------ l=%.3f r=%.3f mid=%.3f -----------------------\n&quot;,l,r,mid);
		if (work(mid)) l=mid;
		else r=mid;
	}
	printf(&quot;NO\n&quot;);
	return 0;
}<pre><h2>Problem2289</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
typedef pair&lt;DD,DD&gt; pdd;
#define mp make_pair
#define fi first
#define se second
#define sqr(x) ((x)*(x))
const DD dinf=1e30,eps=1e-8;
const int NN=101111;
int n;
inline int dcmp(DD x)
{
	if (fabs(x)&lt;eps) return 0;
	return x&lt;0?-1:1;
}
DD yxdl(DD a,DD b,DD c)
{
	DD cosA=(sqr(a)+sqr(b)-sqr(c))/(2*a*b);
	return acos(cosA);
}
struct point
{
	DD x,y;
	point(DD a=0,DD b=0) {x=a;y=b;}
	void out() {printf(&quot;x=%.3f y=%.3f  \n&quot;,x,y);}
	DD len() {return sqrt(sqr(x)+sqr(y));}
	point rotate(DD sita)
	{
		DD t1=x,t2=y;
		x=t1*cos(sita)-t2*sin(sita);
		y=t2*cos(sita)+t1*sin(sita);
		return *this;
	}
	friend point operator +(point a,point b) {return point(a.x+b.x,a.y+b.y);}
	friend point operator -(point a,point b) {return point(a.x-b.x,a.y-b.y);}
	friend point operator /(point a,DD t) {return point(a.x/t,a.y/t);}
	friend point operator *(point a,DD t) {return point(a.x*t,a.y*t);}
};
struct Yuan
{
	point O;DD r;
	void in() {scanf(&quot;%lf%lf%lf&quot;,&amp;O.x,&amp;O.y,&amp;r);}
	friend point operator &amp;(Yuan a,Yuan b)
	{
		if (a.r&lt;b.r) swap(a,b);
		DD r1=a.r,r2=b.r,d=(a.O-b.O).len();
		if (dcmp(d-(r1+r2))&gt;=0) {printf(&quot;NO\n&quot;);exit(0);}
		if (dcmp(d-(r1-r2))&lt;=0) return b.O;
		DD sita=yxdl(d,r1,r2);
		point v=(b.O-a.O).rotate(sita);
		v=v/d*r1;
		return a.O+v;
	}
} C[NN];
pdd getqj(DD X,Yuan C)
{
	DD d=fabs(C.O.x-X);
	DD l=sqrt(sqr(C.r)-sqr(d));
	return mp(C.O.y-l,C.O.y+l);
}
inline bool pan(DD X,point P)
{
	if (P.x&gt;X) return true;
	return false;
}
bool work(DD X)
{
	pdd now=mp(-dinf,dinf);
	int lfrom,rfrom,i;
	for (i=1;i&lt;=n;i++)
	{
		if (dcmp(fabs(X-C[i].O.x)-C[i].r)&gt;=0) return pan(X,C[i]&amp;C[i==1?2:1]);
		pdd tmp=getqj(X,C[i]);
		if (dcmp(tmp.se-now.fi)&lt;=0) return pan(X,C[i]&amp;C[lfrom]);
		if (dcmp(tmp.fi-now.se)&gt;=0) return pan(X,C[i]&amp;C[rfrom]);
		if (dcmp(tmp.fi-now.fi)&gt;0) now.fi=tmp.fi,lfrom=i;
		if (dcmp(tmp.se-now.se)&lt;0) now.se=tmp.se,rfrom=i;
	}
	printf(&quot;YES\n&quot;);exit(0);
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	if (n==1) {printf(&quot;YES\n&quot;);return 0;}
	DD l=dinf,r=-dinf;
	int i;
	for (i=1;i&lt;=n;i++)
	{
		C[i].in();
		l=min(l,C[i].O.x-C[i].r);
		r=max(r,C[i].O.x+C[i].r);
	}
	while (r-l&gt;0.000001)
	{
		DD mid=(l+r)*0.5;
		if (work(mid)) l=mid;
		else r=mid;
	}
	printf(&quot;NO\n&quot;);
	return 0;
}<pre><h2>Problem2300</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
using namespace std;
#define DD double
#define inf 99999999
#define sm 0.00000001
int m,Q,n,x,y,root,SIZE,i,fa[210000],son[210000][2],xx[210000],yy[210000],ask[210000][2],asknum;
DD now,ans[210000];
bool flag[210000];
struct dian
{
	DD x,y;
	int pred,succ;
};
dian tmp,key[210000];
DD dist(DD x1,DD y1,DD x2,DD y2) {return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));}
DD det(dian a,dian b) {return a.x*b.y-b.x*a.y;}
dian dec(dian a,dian b) {dian tmp;tmp.x=a.x-b.x;tmp.y=a.y-b.y;return tmp;}
void rotate(int t,int p)
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
}
int splaypred(dian v)
{
	int t=root,res=root;
	for (;t;)
	{
		if (key[t].x==v.x) return t;
		if (key[t].x-v.x&gt;sm) t=son[t][0];
		else res=t,t=son[t][1];
	}
	return res;
}
int splaysucc(dian v)
{
	int t=root,res;
	for (;t;)
	{
		if (key[t].x-v.x&lt;sm) t=son[t][1];
		else res=t,t=son[t][0];
	}
	return res;
}
void del(int t)
{
	splay(t,0);
	if (!son[t][0]) {root=son[t][1];fa[son[t][1]]=0;return;}
	if (!son[t][1]) {root=son[t][0];fa[son[t][0]]=0;return;}
	int y=son[t][0];
	for (;son[y][1];y=son[y][1]);
	splay(y,root);
	fa[y]=0;
	son[y][1]=son[t][1];
	fa[son[t][1]]=y;
	root=y;
}
void ins(dian v)
{
	//printf(&quot;\ninsert start\n&quot;);
	for (;;)//删前驱 
	{
		int t=splaypred(v);
		//printf(&quot;sussfully find splaypred of v: %d\n&quot;,t);
		int t1=key[t].pred,t2=key[t].succ;
		if (det(dec(key[t2],key[t]),dec(v,key[t]))&lt;-sm) return;
		if (key[t].x==v.x)
			if (key[t].y-v.y&gt;sm) return;
			else
			{
				now-=(dist(key[t1].x,key[t1].y,key[t].x,key[t].y)+dist(key[t].x,key[t].y,key[t2].x,key[t2].y));
				now+=dist(key[t1].x,key[t1].y,key[t2].x,key[t2].y);
				key[t1].succ=t2;
				key[t2].pred=t1;
				//printf(&quot;wrong\n&quot;);
				del(t);
			}
		else
			if ((v.y-key[t].y)/(v.x-key[t].x)-(key[t].y-key[t1].y)/(key[t].x-key[t1].x)&lt;-sm) break;
			else
			{
				now-=(dist(key[t1].x,key[t1].y,key[t].x,key[t].y)+dist(key[t].x,key[t].y,key[t2].x,key[t2].y));
				now+=dist(key[t1].x,key[t1].y,key[t2].x,key[t2].y);
				key[t1].succ=t2;
				key[t2].pred=t1;
				//printf(&quot;wrong\n&quot;);
				del(t);
			}
	}
	//printf(&quot;end of first for\n\n&quot;);
	for (;;)//删后继
	{
		int t=splaysucc(v);
		int t1=key[t].pred,t2=key[t].succ;
		if ((v.y-key[t].y)/(v.x-key[t].x)-(key[t].y-key[t2].y)/(key[t].x-key[t2].x)&gt;sm) break;
		else
		{
			now-=(dist(key[t1].x,key[t1].y,key[t].x,key[t].y)+dist(key[t].x,key[t].y,key[t2].x,key[t2].y));
			now+=dist(key[t1].x,key[t1].y,key[t2].x,key[t2].y);
			key[t1].succ=t2;
			key[t2].pred=t1;
			del(t);
		}
	}
	//printf(&quot;end of second for\n\n&quot;);
	int t=root,res;
	for (;t;)
	{
		res=t;
		if (key[t].x-v.x&gt;sm) t=son[t][0];
		else t=son[t][1];
	}
	t=res;
	//printf(&quot;%d\n&quot;,t);
	int t1=key[t].pred,t2=key[t].succ;
	if (v.x-key[t].x&lt;-sm)
	{
		now-=dist(key[t1].x,key[t1].y,key[t].x,key[t].y);
		now+=dist(key[t1].x,key[t1].y,v.x,v.y)+dist(v.x,v.y,key[t].x,key[t].y);
		son[t][0]=++SIZE;
		fa[SIZE]=t;
		key[SIZE]=v;
		key[SIZE].pred=t1;
		key[SIZE].succ=t;
		key[t1].succ=SIZE;
		key[t].pred=SIZE;
	}
	else
	{
		now-=dist(key[t].x,key[t].y,key[t2].x,key[t2].y);
		now+=dist(key[t].x,key[t].y,v.x,v.y)+dist(v.x,v.y,key[t2].x,key[t2].y);
		son[t][1]=++SIZE;
		fa[SIZE]=t;
		key[SIZE]=v;
		key[SIZE].pred=t;
		key[SIZE].succ=t2;
		key[t2].pred=SIZE;
		key[t].succ=SIZE;
	}
	splay(SIZE,0);
	//printf(&quot;insert end\n&quot;);
}
int main()
{
	//freopen(&quot;2300.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2300.out&quot;,&quot;w&quot;,stdout);
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;x,&amp;y);
	key[1].x=-sm,key[1].y=-inf;
	fa[1]=2,son[2][0]=1;
	key[2].pred=1;
	key[2].x=key[2].y=0;
	key[2].succ=3;
	fa[2]=3;son[3][0]=2;
	key[3].x=x,key[3].y=y;
	key[3].pred=2,key[3].succ=4;
	fa[3]=0;
	root=3;
	key[4].x=n,key[4].y=0;
	key[4].pred=3,key[4].succ=5;
	fa[4]=3,son[3][1]=4;
	key[5].x=n+sm,key[5].y=-inf;
	fa[5]=4,son[4][1]=5;
	SIZE=5;
	now=(dist(0,0,x,y)+dist(x,y,n,0));
	scanf(&quot;%d&quot;,&amp;m);
	for (i=1;i&lt;=m;i++) scanf(&quot;%d%d&quot;,&amp;xx[i],&amp;yy[i]);
	scanf(&quot;%d&quot;,&amp;Q);
	//printf(&quot;Q=: %d\n&quot;,Q);
	for (i=1;i&lt;=Q;i++)
	{
		scanf(&quot;%d&quot;,&amp;ask[i][0]);
		if (ask[i][0]==1)
		{
			scanf(&quot;%d&quot;,&amp;ask[i][1]);
			flag[ask[i][1]]=1;
		}
	}
	//printf(&quot;%.2f\n&quot;,now);
	for (i=1;i&lt;=m;i++)
		if (!flag[i])
		{
			tmp.x=xx[i],tmp.y=yy[i];
			ins(tmp);
			//printf(&quot;%.2f\n&quot;,now);
		}
	//printf(&quot;insert end\n\n&quot;);
	for (i=Q;i;i--)
		if (ask[i][0]==2) ans[++asknum]=now;
		else
		{
			//printf(&quot;\n------------------------------------\n&quot;);
			//printf(&quot;%d\n&quot;,i);
			tmp.x=xx[ask[i][1]],tmp.y=yy[ask[i][1]];
			ins(tmp);
		}
	for (i=asknum;i;i--) printf(&quot;%.2f\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem2300</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
using namespace std;
#define DD double
#define inf 99999999
#define sm 0.00000001
int m,Q,n,x,y,root,SIZE,i,fa[210000],son[210000][2],xx[210000],yy[210000],ask[210000][2],asknum;
DD now,ans[210000];
bool flag[210000];
struct dian
{
	DD x,y;
	int pred,succ;
};
dian tmp,key[210000];
DD dist(DD x1,DD y1,DD x2,DD y2) {return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));}
DD det(dian a,dian b) {return a.x*b.y-b.x*a.y;}
dian dec(dian a,dian b) {dian tmp;tmp.x=a.x-b.x;tmp.y=a.y-b.y;return tmp;}
void rotate(int t,int p)
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
}
int splaypred(dian v)
{
	int t=root,res=root;
	for (;t;)
	{
		if (key[t].x==v.x) return t;
		if (key[t].x-v.x&gt;sm) t=son[t][0];
		else res=t,t=son[t][1];
	}
	return res;
}
int splaysucc(dian v)
{
	int t=root,res;
	for (;t;)
	{
		if (key[t].x-v.x&lt;sm) t=son[t][1];
		else res=t,t=son[t][0];
	}
	return res;
}
void del(int t)
{
	splay(t,0);
	if (!son[t][0]) {root=son[t][1];fa[son[t][1]]=0;return;}
	if (!son[t][1]) {root=son[t][0];fa[son[t][0]]=0;return;}
	int y=son[t][0];
	for (;son[y][1];y=son[y][1]);
	splay(y,root);
	fa[y]=0;
	son[y][1]=son[t][1];
	fa[son[t][1]]=y;
	root=y;
}
void ins(dian v)
{
	int t=splaypred(v);
	for (;;)
	{
		int t1=key[t].pred,t2=key[t].succ;
		if (det(dec(key[t2],key[t]),dec(v,key[t]))&lt;-sm) return;
		if (key[t].x==v.x)
			if (key[t].y-v.y&gt;sm) return;
			else
			{
				now-=(dist(key[t1].x,key[t1].y,key[t].x,key[t].y)+dist(key[t].x,key[t].y,key[t2].x,key[t2].y));
				now+=dist(key[t1].x,key[t1].y,key[t2].x,key[t2].y);
				key[t1].succ=t2;
				key[t2].pred=t1;
				del(t);
			}
		else
			if ((v.y-key[t].y)/(v.x-key[t].x)-(key[t].y-key[t1].y)/(key[t].x-key[t1].x)&lt;-sm) break;
			else
			{
				now-=(dist(key[t1].x,key[t1].y,key[t].x,key[t].y)+dist(key[t].x,key[t].y,key[t2].x,key[t2].y));
				now+=dist(key[t1].x,key[t1].y,key[t2].x,key[t2].y);
				key[t1].succ=t2;
				key[t2].pred=t1;
				del(t);
			}
		t=t1;
	}
	t=splaysucc(v);
	for (;;)
	{
		int t1=key[t].pred,t2=key[t].succ;
		if ((v.y-key[t].y)/(v.x-key[t].x)-(key[t].y-key[t2].y)/(key[t].x-key[t2].x)&gt;sm) break;
		else
		{
			now-=(dist(key[t1].x,key[t1].y,key[t].x,key[t].y)+dist(key[t].x,key[t].y,key[t2].x,key[t2].y));
			now+=dist(key[t1].x,key[t1].y,key[t2].x,key[t2].y);
			key[t1].succ=t2;
			key[t2].pred=t1;
			del(t);
		}
		t=t2;
	}
	t=root;
	int res;
	for (;t;)
	{
		res=t;
		if (key[t].x-v.x&gt;sm) t=son[t][0];
		else t=son[t][1];
	}
	t=res;
	int t1=key[t].pred,t2=key[t].succ;
	if (v.x-key[t].x&lt;-sm)
	{
		now-=dist(key[t1].x,key[t1].y,key[t].x,key[t].y);
		now+=dist(key[t1].x,key[t1].y,v.x,v.y)+dist(v.x,v.y,key[t].x,key[t].y);
		son[t][0]=++SIZE;
		fa[SIZE]=t;
		key[SIZE]=v;
		key[SIZE].pred=t1;
		key[SIZE].succ=t;
		key[t1].succ=SIZE;
		key[t].pred=SIZE;
	}
	else
	{
		now-=dist(key[t].x,key[t].y,key[t2].x,key[t2].y);
		now+=dist(key[t].x,key[t].y,v.x,v.y)+dist(v.x,v.y,key[t2].x,key[t2].y);
		son[t][1]=++SIZE;
		fa[SIZE]=t;
		key[SIZE]=v;
		key[SIZE].pred=t;
		key[SIZE].succ=t2;
		key[t2].pred=SIZE;
		key[t].succ=SIZE;
	}
	splay(SIZE,0);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;x,&amp;y);
	key[1].x=-sm,key[1].y=-inf;
	fa[1]=2,son[2][0]=1;
	key[2].pred=1;
	key[2].x=key[2].y=0;
	key[2].succ=3;
	fa[2]=3;son[3][0]=2;
	key[3].x=x,key[3].y=y;
	key[3].pred=2,key[3].succ=4;
	fa[3]=0;
	root=3;
	key[4].x=n,key[4].y=0;
	key[4].pred=3,key[4].succ=5;
	fa[4]=3,son[3][1]=4;
	key[5].x=n+sm,key[5].y=-inf;
	fa[5]=4,son[4][1]=5;
	SIZE=5;
	now=(dist(0,0,x,y)+dist(x,y,n,0));
	scanf(&quot;%d&quot;,&amp;m);
	for (i=1;i&lt;=m;i++) scanf(&quot;%d%d&quot;,&amp;xx[i],&amp;yy[i]);
	scanf(&quot;%d&quot;,&amp;Q);
	for (i=1;i&lt;=Q;i++)
	{
		scanf(&quot;%d&quot;,&amp;ask[i][0]);
		if (ask[i][0]==1)
		{
			scanf(&quot;%d&quot;,&amp;ask[i][1]);
			flag[ask[i][1]]=1;
		}
	}
	for (i=1;i&lt;=m;i++)
		if (!flag[i])
		{
			tmp.x=xx[i],tmp.y=yy[i];
			ins(tmp);
		}
	for (i=Q;i;i--)
		if (ask[i][0]==2) ans[++asknum]=now;
		else
		{
			tmp.x=xx[ask[i][1]],tmp.y=yy[ask[i][1]];
			ins(tmp);
		}
	for (i=asknum;i;i--) printf(&quot;%.2f\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem2300</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
using namespace std;
#define DD double
#define inf 99999999
#define sm 0.00000001
int m,Q,n,x,y,root,SIZE,i,fa[210000],son[210000][2],xx[210000],yy[210000],ask[210000][2],asknum;
DD now,ans[210000];
bool flag[210000];
struct dian
{
	DD x,y;
	int pred,succ;
};
dian tmp,key[210000];
DD dist(DD x1,DD y1,DD x2,DD y2) {return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));}
DD det(dian a,dian b) {return a.x*b.y-b.x*a.y;}
dian dec(dian a,dian b) {dian tmp;tmp.x=a.x-b.x;tmp.y=a.y-b.y;return tmp;}
void rotate(int t,int p)
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
}
int splaypred(dian v)
{
	int t=root,res=root;
	for (;t;)
	{
		if (key[t].x==v.x) return t;
		if (key[t].x-v.x&gt;sm) t=son[t][0];
		else res=t,t=son[t][1];
	}
	return res;
}
int splaysucc(dian v)
{
	int t=root,res;
	for (;t;)
	{
		if (key[t].x-v.x&lt;sm) t=son[t][1];
		else res=t,t=son[t][0];
	}
	return res;
}
void del(int t)
{
	splay(t,0);
	if (!son[t][0]) {root=son[t][1];fa[son[t][1]]=0;return;}
	if (!son[t][1]) {root=son[t][0];fa[son[t][0]]=0;return;}
	int y=son[t][0];
	for (;son[y][1];y=son[y][1]);
	splay(y,root);
	fa[y]=0;
	son[y][1]=son[t][1];
	fa[son[t][1]]=y;
	root=y;
}
void ins(dian v)
{
	int t=splaypred(v);
	for (;;)
	{
		int t1=key[t].pred,t2=key[t].succ;
		if (det(dec(key[t2],key[t]),dec(v,key[t]))&lt;-sm) return;
		if (key[t].x==v.x)
			if (key[t].y-v.y&gt;sm) return;
			else
			{
				now-=(dist(key[t1].x,key[t1].y,key[t].x,key[t].y)+dist(key[t].x,key[t].y,key[t2].x,key[t2].y));
				now+=dist(key[t1].x,key[t1].y,key[t2].x,key[t2].y);
				key[t1].succ=t2;
				key[t2].pred=t1;
				del(t);
			}
		else
			if ((v.y-key[t].y)/(v.x-key[t].x)-(key[t].y-key[t1].y)/(key[t].x-key[t1].x)&lt;-sm) break;
			else
			{
				now-=(dist(key[t1].x,key[t1].y,key[t].x,key[t].y)+dist(key[t].x,key[t].y,key[t2].x,key[t2].y));
				now+=dist(key[t1].x,key[t1].y,key[t2].x,key[t2].y);
				key[t1].succ=t2;
				key[t2].pred=t1;
				del(t);
			}
		t=t1;
	}
	t=splaysucc(v);
	for (;;)
	{
		int t1=key[t].pred,t2=key[t].succ;
		if ((v.y-key[t].y)/(v.x-key[t].x)-(key[t].y-key[t2].y)/(key[t].x-key[t2].x)&gt;sm) break;
		else
		{
			now-=(dist(key[t1].x,key[t1].y,key[t].x,key[t].y)+dist(key[t].x,key[t].y,key[t2].x,key[t2].y));
			now+=dist(key[t1].x,key[t1].y,key[t2].x,key[t2].y);
			key[t1].succ=t2;
			key[t2].pred=t1;
			del(t);
		}
		t=t2;
	}
	t=root;
	int res;
	for (;t;)
	{
		res=t;
		if (key[t].x-v.x&gt;sm) t=son[t][0];
		else t=son[t][1];
	}
	t=res;
	int t1=key[t].pred,t2=key[t].succ;
	if (v.x-key[t].x&lt;-sm)
	{
		now-=dist(key[t1].x,key[t1].y,key[t].x,key[t].y);
		now+=dist(key[t1].x,key[t1].y,v.x,v.y)+dist(v.x,v.y,key[t].x,key[t].y);
		son[t][0]=++SIZE;
		fa[SIZE]=t;
		key[SIZE]=v;
		key[SIZE].pred=t1;
		key[SIZE].succ=t;
		key[t1].succ=SIZE;
		key[t].pred=SIZE;
	}
	else
	{
		now-=dist(key[t].x,key[t].y,key[t2].x,key[t2].y);
		now+=dist(key[t].x,key[t].y,v.x,v.y)+dist(v.x,v.y,key[t2].x,key[t2].y);
		son[t][1]=++SIZE;
		fa[SIZE]=t;
		key[SIZE]=v;
		key[SIZE].pred=t;
		key[SIZE].succ=t2;
		key[t2].pred=SIZE;
		key[t].succ=SIZE;
	}
	splay(SIZE,0);
}
int main()
{
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;x,&amp;y);
	key[1].x=-sm,key[1].y=-inf;
	fa[1]=2,son[2][0]=1;
	key[2].pred=1;
	key[2].x=key[2].y=0;
	key[2].succ=3;
	fa[2]=3;son[3][0]=2;
	key[3].x=x,key[3].y=y;
	key[3].pred=2,key[3].succ=4;
	fa[3]=0;
	root=3;
	key[4].x=n,key[4].y=0;
	key[4].pred=3,key[4].succ=5;
	fa[4]=3,son[3][1]=4;
	key[5].x=n+sm,key[5].y=-inf;
	fa[5]=4,son[4][1]=5;
	SIZE=5;
	now=(dist(0,0,x,y)+dist(x,y,n,0));
	scanf(&quot;%d&quot;,&amp;m);
	for (i=1;i&lt;=m;i++) scanf(&quot;%d%d&quot;,&amp;xx[i],&amp;yy[i]);
	scanf(&quot;%d&quot;,&amp;Q);
	for (i=1;i&lt;=Q;i++)
	{
		scanf(&quot;%d&quot;,&amp;ask[i][0]);
		if (ask[i][0]==1)
		{
			scanf(&quot;%d&quot;,&amp;ask[i][1]);
			flag[ask[i][1]]=1;
		}
	}
	for (i=1;i&lt;=m;i++)
		if (!flag[i])
		{
			tmp.x=xx[i],tmp.y=yy[i];
			ins(tmp);
		}
	for (i=Q;i;i--)
		if (ask[i][0]==2) ans[++asknum]=now;
		else
		{
			tmp.x=xx[ask[i][1]],tmp.y=yy[ask[i][1]];
			ins(tmp);
		}
	for (i=asknum;i;i--) printf(&quot;%.2f\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem2301</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
int pr[51111],miu[51111],sum_miu[51111];
int K,prcnt;
void shai()
{
	static bool vt[51111];
	int i,j;
	vt[1]=true;
	miu[1]=1;
	for (i=2;i&lt;=50000;i++)
	{
		if (!vt[i])
		{
			pr[++prcnt]=i;
			miu[i]=-1;
		}
		for (j=1;j&lt;=prcnt;j++)
		{
			int x=i*pr[j];
			if (x&gt;50000) break;
			vt[x]=true;
			if (i%pr[j]==0)
			{
				miu[x]=0;
				break;
			}
			miu[x]=-miu[i];
		}
	}
	for (i=1;i&lt;=50000;i++)
		sum_miu[i]=sum_miu[i-1]+miu[i];
}
LL work(int n,int m)
{
	n/=K,m/=K;
	if (n&gt;m) {int t=n;n=m;m=t;}
	int l,r;
	LL res=0;
	for (l=1;l&lt;=n;l=r+1)
	{
		r=min(n/(n/l),m/(m/l));
		res+=(LL)(sum_miu[r]-sum_miu[l-1])*(n/l)*(m/l);
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	shai();
	int tes,a,b,c,d;
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d%d%d%d%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;K);
		printf(&quot;%lld\n&quot;,work(b,d)-work(a-1,d)-work(b,c-1)+work(a-1,c-1));
	}
	return 0;
}<pre><h2>Problem2306</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
const DD dinf=1e30;
DD f[105][105],g[105][105],p,w[105];
int n,m,S;
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j,k,x,y;
	for (i=1;i&lt;=n;i++) scanf(&quot;%lf&quot;,&amp;w[i]);
	scanf(&quot;%d%lf&quot;,&amp;S,&amp;p);
	for (i=1;i&lt;=n;i++)
	{
		for (j=1;j&lt;=n;j++) f[i][j]=-dinf;
		f[i][i]=w[i];
	}
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		f[x][y]=w[x]+w[y]*p;
	}
	DD tmp=p;
	for (int tt=1;tt&lt;=30;tt++)
	{
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=n;j++) g[i][j]=-dinf;
		for (k=1;k&lt;=n;k++)
			for (i=1;i&lt;=n;i++)
				for (j=1;j&lt;=n;j++)
					g[i][j]=max(g[i][j],f[i][k]+f[k][j]*tmp-w[k]*tmp);
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=n;j++) f[i][j]=g[i][j];
		tmp=tmp*tmp;
	}
	DD ans=0;
	for (i=1;i&lt;=n;i++)
		if (f[S][i]&gt;ans) ans=f[S][i];
	printf(&quot;%.1f\n&quot;,ans);
	return 0;
}<pre><h2>Problem2314</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define inf 999999999
#define mo 1032992941
#define ln printf(&quot;\n&quot;)
const int NN=501111;
int f[NN],g[NN],h[NN],o[NN],aa[NN&lt;&lt;1][2],fa[NN],que[NN];
int n,tot=1;
LL F[NN],G[NN],H[NN];
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);ln;}
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9')
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar();
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void bfs()
{
	int head=0,tail=1;
	que[1]=1;
	while (head&lt;tail)
	{
		int x=que[++head];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[x]) continue;
			fa[y]=x;
			que[++tail]=y;
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);
	int i,x,y;
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y);
		addedge(x,y),addedge(y,x);
	}
	bfs();
	//printf(&quot;que &quot;);for(i=1;i&lt;=n;i++)printf(&quot;%d &quot;,que[i]);ln;
	for (i=n;i;i--)
	{
		int x=que[i];
		//printf(&quot;\n--------------------------------- x=%d ----------------------------------------\n&quot;,x);
		f[x]=1,g[x]=inf,h[x]=0;
		F[x]=1,G[x]=0,H[x]=1;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[x]) continue;
			int ff=f[x],gg=g[x],hh=h[x];
			LL GG=G[x],HH=H[x];
			int tmp=min(f[y],min(g[y],h[y]));
			f[x]=ff+tmp;
			LL res=0;
			if (f[y]==tmp) res+=F[y];
			if (g[y]==tmp) res+=G[y];
			if (h[y]==tmp) res+=H[y];
			F[x]=F[x]*res%mo;
			tmp=min(gg+f[y],min(gg+g[y],hh+f[y]));
			//printf(&quot;%d %d %d\n&quot;,gg+f[y],gg+g[y],hh+f[y]);
			g[x]=tmp;
			res=0;
			if (gg+f[y]==tmp) res+=GG*F[y]%mo;
			if (gg+g[y]==tmp) res+=GG*G[y]%mo;
			if (hh+f[y]==tmp) res+=HH*F[y]%mo;
			G[x]=res%mo;
			h[x]+=g[y];
			if (h[x]&lt;0) h[x]=inf;
			H[x]=HH*G[y]%mo;
		}
	}
	//ln;printf(&quot;f &quot;);out(f,1,n);printf(&quot;g &quot;);out(g,1,n);printf(&quot;h &quot;);out(h,1,n);ln;
	if (f[1]&lt;g[1]) printf(&quot;%d\n%lld\n&quot;,f[1],F[1]);
	else if (g[1]&lt;f[1]) printf(&quot;%d\n%lld\n&quot;,g[1],G[1]);
	else printf(&quot;%d\n%lld\n&quot;,f[1],(F[1]+G[1])%mo);
	return 0;
}<pre><h2>Problem2324</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf=99999999,mn=400;
int dist[mn],o[mn],a[mn][mn],pre[mn],aa[1000000][4],q[1000000];
bool dl[mn];
int n,m,S,T,head,tail,i,j,k,K,tot,ans;
int min(int a,int b) {return a&lt;b?a:b;}
void add(int p,int q,int v,int cost)
{
	++tot;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][3]=cost;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void addedge(int p,int q,int v,int cost)
{
	//printf(&quot;addedge:  %d %d %d %d\n&quot;,p,q,v,cost);
	add(p,q,v,cost);
	add(q,p,0,-cost);
}
void init()
{
	int x,y,z;
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;K);
	for (i=0;i&lt;=n;i++)
	{
		for (j=0;j&lt;=n;j++) a[i][j]=inf;
		a[i][i]=0;
	}
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		if (z&lt;a[x][y]||a[x][y]==0) a[x][y]=a[y][x]=z;
	}
	tot=1;
	for (k=0;k&lt;=n;k++)
		for (i=0;i&lt;=n;i++)
			for (j=0;j&lt;=n;j++)
			{
				a[i][j]=min(a[i][j],a[i][k]+a[k][j]);
				if (i&lt;j&amp;&amp;k==j&amp;&amp;a[i][j]&lt;inf) addedge(i,j+n,inf,a[i][j]);
			}
	S=n*2+1,T=S+1;
	addedge(S,0,K,0);
	for (i=1;i&lt;=n;i++)
	{
		addedge(i+n,T,1,0);
		addedge(S,i,1,0);
	}
}
bool relax(int x,int y,int v)
{
	if (dist[y]&gt;dist[x]+v)
	{
		dist[y]=dist[x]+v;
		return 1;
	}
	return 0;
}
bool spfa()
{
	memset(dist,127,sizeof(dist[0])*(T+10));
	head=tail=0;
	memset(dl,0,sizeof(dl[0])*(T+10));
	dist[S]=0;
	dl[S]=1;
	q[++tail]=S;
	while (head&lt;tail)
	{
		int x=q[++head];
		dl[x]=0;
		int p=o[x];
		while (p)
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;relax(x,y,aa[p][3]))
			{
				pre[y]=p;
				if (!dl[y])
				{
					q[++tail]=y;
					dl[y]=1;
				}
			}
			p=aa[p][0];
		}
	}
	if (dist[T]==dist[T+1]) return 0;
	return 1;
}
void addcost()
{
	int p=pre[T],flow=inf;
	while (p)
	{
		flow=min(flow,aa[p][2]);
		p=pre[aa[p^1][1]];
	}
	p=pre[T];
	while (p)
	{
		ans+=flow*aa[p][3];
		aa[p][2]-=flow;
		aa[p^1][2]+=flow;
		p=pre[aa[p^1][1]];
	}
	//printf(&quot;-------------\n&quot;);
}
void doit()
{
	ans=0;
	while (spfa()) addcost();
	printf(&quot;%d\n&quot;,ans);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	init();
	doit();
	return 0;
}
<pre><h2>Problem2324</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf=99999999,mn=400;
int dist[mn],o[mn],a[mn][mn],pre[mn],aa[1000000][4],q[1000000];
bool dl[mn];
int n,m,S,T,head,tail,i,j,k,K,tot,ans;
int min(int a,int b) {return a&lt;b?a:b;}
void add(int p,int q,int v,int cost)
{
	++tot;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][3]=cost;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void addedge(int p,int q,int v,int cost)
{
	add(p,q,v,cost);
	add(q,p,0,-cost);
}
void init()
{
	int x,y,z;
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;K);
	for (i=0;i&lt;=n;i++)
	{
		for (j=0;j&lt;=n;j++) a[i][j]=inf;
		a[i][i]=0;
	}
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		if (z&lt;a[x][y]||a[x][y]==0) a[x][y]=a[y][x]=z;
	}
	tot=1;
	for (k=0;k&lt;=n;k++)
		for (i=0;i&lt;=n;i++)
			for (j=0;j&lt;=n;j++)
			{
				a[i][j]=min(a[i][j],a[i][k]+a[k][j]);
				if (i&lt;j&amp;&amp;k==j) addedge(i,j+n,inf,a[i][j]);
			}
	S=n*2+1,T=S+1;
	addedge(S,0,K,0);
	for (i=1;i&lt;=n;i++)
	{
		addedge(i+n,T,1,0);
		addedge(S,i,1,0);
	}
}
bool relax(int x,int y,int v)
{
	if (dist[y]&gt;dist[x]+v)
	{
		dist[y]=dist[x]+v;
		return 1;
	}
	return 0;
}
bool spfa()
{
	memset(dist,127,sizeof(dist[0])*(T+10));
	head=tail=0;
	memset(dl,0,sizeof(dl[0])*(T+10));
	dist[S]=0;
	dl[S]=1;
	q[++tail]=S;
	while (head&lt;tail)
	{
		int x=q[++head];
		dl[x]=0;
		int p=o[x];
		while (p)
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;relax(x,y,aa[p][3]))
			{
				pre[y]=p;
				if (!dl[y])
				{
					q[++tail]=y;
					dl[y]=1;
				}
			}
			p=aa[p][0];
		}
	}
	if (dist[T]==dist[T+1]) return 0;
	return 1;
}
void addcost()
{
	int p=pre[T],flow=inf;
	while (p)
	{
		flow=min(flow,aa[p][2]);
		p=pre[aa[p^1][1]];
	}
	p=pre[T];
	while (p)
	{
		ans+=flow*aa[p][3];
		aa[p][2]-=flow;
		aa[p^1][2]+=flow;
		p=pre[aa[p^1][1]];
	}
}
void doit()
{
	ans=0;
	while (spfa()) addcost();
	printf(&quot;%d\n&quot;,ans);
}
int main()
{
	init();
	doit();
	return 0;
}<pre><h2>Problem2324</h2><pre>var i,j,k,s,t,z,m,n,x,y,sum,mm,head,tail,xxx,num:longint;
ans,min:int64;
last,f,pre:array[1..400]of int64;
d:array[0..151,1..151,1..151]of int64;
a,b,c,w,next,aa,bb,fan,q:array[1..400000]of int64;
tt:array[1..400]of boolean;
procedure build(xx,yy,zz,ff:longint);
begin
  inc(mm);
  a[mm]:=xx;
  b[mm]:=yy;
  c[mm]:=zz;
  w[mm]:=ff;
  next[mm]:=last[xx];
  last[xx]:=mm;
  fan[mm]:=mm+1;
  inc(mm);
  a[mm]:=yy;
  b[mm]:=xx;
  w[mm]:=-ff;
  next[mm]:=last[yy];
  last[yy]:=mm;
  fan[mm]:=mm-1;
end;
function can:boolean;
var jj,xx,kk:longint;
begin
  head:=0;
  tail:=1;
  q[1]:=s;
  fillchar(f,sizeof(f),63);
  f[s]:=0;
  tt[s]:=true;
  while head&lt;tail do begin
    inc(head);
    xx:=q[head];
    kk:=f[xx];
    jj:=last[xx];
    while jj&lt;&gt;0 do begin
      if (f[b[jj]]&gt;w[jj]+kk)and(c[jj]&gt;0) then begin
        f[b[jj]]:=w[jj]+kk;
        pre[b[jj]]:=jj;
        if not tt[b[jj]] then begin inc(tail); q[tail]:=b[jj]; tt[b[jj]]:=true; end;
      end;
      jj:=next[jj];
    end;
    tt[xx]:=false;
  end;
  if f[t]&lt;1061109567 then exit(true);
  exit(false);
end;
 
begin
  //assign(input,'lx.in');assign(output,'lx.out');reset(input);rewrite(output);
  read(n,m,num);
  s:=2*(n+1)+1;
  t:=s+1;
  inc(n);
  for i:=0 to n do for j:=1 to n do for k:=1 to n do if j&lt;&gt;k then d[i,j,k]:=maxlongint;
  for i:=1 to m do begin read(x,y); inc(x); inc(y); aa[i]:=x; bb[i]:=y;read(xxx); if d[0,x,y]&gt;xxx then d[0,x,y]:=xxx; d[0,y,x]:=d[0,x,y];end;
  {for k:=1 to n do begin
    for i:=1 to n do
      for j:=1 to n do if dist[i,k]+dist[k,j]&lt;dist[i,j] then dist[i,j]:=dist[i,k]+dist[k,j];
    for i:=1 to k do begin d[i,k]:=dist[i,k]; d[k,i]:=d[i,k]; end;
  end;}
  for k:=1 to n do for i:=1 to n do for j:=1 to n do
      if d[k-1,i,j]&gt;d[k-1,i,k]+d[k-1,k,j] then d[k,i,j]:=d[k-1,i,k]+d[k-1,k,j]
      else d[k,i,j]:=d[k-1,i,j];
  build(s,n+1,num,0);
  for i:=1 to n do begin
    build(i+n,i,maxlongint,0);
    build(s,i,1,0);
    build(i+n,t,1,0);
    for j:=i+1 to n do if d[j-1,i,j]&lt;maxlongint then build(i,j+n,1,d[j-1,i,j]);
  end;
  while can do begin
    min:=maxlongint;
    x:=t;
    while pre[x]&lt;&gt;0 do begin if c[pre[x]]&lt;min then min:=c[pre[x]]; x:=a[pre[x]]; end;
    ans:=ans+f[t]*min;
    x:=t;
    while pre[x]&lt;&gt;0 do begin dec(c[pre[x]],min); inc(c[fan[pre[x]]],min); x:=a[pre[x]]; end;
  end;
  writeln(ans);
  //close(input);  close(output);
end.<pre><h2>Problem2324</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf=99999999,mn=400;
int dist[mn],o[mn],a[mn][mn],pre[mn],aa[1000000][4],q[1000000];
bool dl[mn];
int n,m,S,T,head,tail,i,j,k,K,tot,ans;
int min(int a,int b) {return a&lt;b?a:b;}
void add(int p,int q,int v,int cost)
{
    ++tot;
    aa[tot][1]=q;
    aa[tot][2]=v;
    aa[tot][3]=cost;
    aa[tot][0]=o[p];
    o[p]=tot;
}
void addedge(int p,int q,int v,int cost)
{
    add(p,q,v,cost);
    add(q,p,0,-cost);
}
void init()
{
    int x,y,z;
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;K);
    for (i=0;i&lt;=n;i++)
    {
        for (j=0;j&lt;=n;j++) a[i][j]=inf;
        a[i][i]=0;
    }
    for (i=1;i&lt;=m;i++)
    {
        scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
        if (z&lt;a[x][y]||a[x][y]==0) a[x][y]=a[y][x]=z;
    }
    tot=1;
    for (k=0;k&lt;=n;k++)
        for (i=0;i&lt;=n;i++)
            for (j=0;j&lt;=n;j++)
            {
                a[i][j]=min(a[i][j],a[i][k]+a[k][j]);
                if (i&lt;j&amp;&amp;k==j) addedge(i,j+n,inf,a[i][j]);
            }
    S=n*2+1,T=S+1;
    addedge(S,0,K,0);
    for (i=1;i&lt;=n;i++)
    {
    	addedge(i+n,i,inf,0);
        addedge(i+n,T,1,0);
        addedge(S,i,1,0);
    }
}
bool relax(int x,int y,int v)
{
    if (dist[y]&gt;dist[x]+v)
    {
        dist[y]=dist[x]+v;
        return 1;
    }
    return 0;
}
bool spfa()
{
    memset(dist,127,sizeof(dist[0])*(T+10));
    head=tail=0;
    memset(dl,0,sizeof(dl[0])*(T+10));
    dist[S]=0;
    dl[S]=1;
    q[++tail]=S;
    while (head&lt;tail)
    {
        int x=q[++head];
        dl[x]=0;
        int p=o[x];
        while (p)
        {
            int y=aa[p][1];
            if (aa[p][2]&amp;&amp;relax(x,y,aa[p][3]))
            {
                pre[y]=p;
                if (!dl[y])
                {
                    q[++tail]=y;
                    dl[y]=1;
                }
            }
            p=aa[p][0];
        }
    }
    if (dist[T]==dist[T+1]) return 0;
    return 1;
}
void addcost()
{
    int p=pre[T],flow=inf;
    while (p)
    {
        flow=min(flow,aa[p][2]);
        p=pre[aa[p^1][1]];
    }
    p=pre[T];
    while (p)
    {
        ans+=flow*aa[p][3];
        aa[p][2]-=flow;
        aa[p^1][2]+=flow;
        p=pre[aa[p^1][1]];
    }
}
void doit()
{
    ans=0;
    while (spfa()) addcost();
    printf(&quot;%d\n&quot;,ans);
}
int main()
{
    init();
    doit();
    return 0;
}<pre><h2>Problem2326</h2><pre>type arr=array[0..4,0..4]of int64;
var n,m,now,sum:int64;
    sav,ans,b:arr;
function quickadd(a,b:int64):int64;
var sum:int64;
begin
  sum:=0;
  while b&lt;&gt;0 do
   begin
     if b and 1=1 then sum:=(sum+a)mod m;
     b:=b shr 1;
     a:=(a+a)mod m;
   end;
  exit(sum);
end;

procedure cheng(a,b:arr;var c:arr);
var i,j,k:longint;
begin
  fillchar(c,sizeof(c),0);
  for i:=1 to 4 do
   for j:=1 to 4 do
     for k:=1 to 4 do
       c[i][j]:=(c[i][j]+quickadd(a[i][k],b[k][j]))mod m;
end;

procedure quickmod(n:int64);
begin
  while n&lt;&gt;0 do
   begin
     if n and 1=1 then cheng(ans,b,ans);
     n:=n shr 1;
     cheng(b,b,b);
   end;
end;

procedure init;
var i:longint;
begin
  read(n,m);
  now:=9;
  fillchar(b,sizeof(b),0);
  b[1][1]:=10;b[1][2]:=1;
  b[3][1]:=1;b[3][3]:=1;
  b[4][1]:=1;b[4][3]:=1;b[4][4]:=1;
  sav:=b;
  fillchar(ans,sizeof(ans),0);
  for i:=1 to 4 do ans[i][i]:=1;
  while true do
   begin
     sum:=now-((now+1)div 10);
     if now&lt;n then quickmod(sum+ord(sum&lt;&gt;9))
              else
               begin
                quickmod(n-((now-9)div 10));
                break;
               end;
     now:=now*10+9;
     sav[1][1]:=sav[1][1]*10;
     b:=sav;
   end;
  write(ans[4][1]);
end;

begin
  init;
end.<pre><h2>Problem2326</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define LL long long
LL n,ten[19];
int mo;
struct matrix
{
	LL m[4][4];
	matrix() {memset(m,0,sizeof(m));}
	friend matrix operator *(matrix a,matrix b)
	{
		matrix c;
		int i,j,k;
		for (k=1;k&lt;=3;k++)
			for (i=1;i&lt;=3;i++)
				for (j=1;j&lt;=3;j++)
					c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]%mo)%mo;
		return c;
	}
	friend matrix operator ^(matrix a,LL x)
	{
		matrix res;
		res.m[1][1]=res.m[2][2]=res.m[3][3]=1;
		for (;x;x&gt;&gt;=1,a=a*a) if (x&amp;1) res=res*a;
		return res;
	}
} a,res,ans;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld%d&quot;,&amp;n,&amp;mo);
	int i;
	for (ten[0]=1,i=1;i&lt;=18;i++) ten[i]=ten[i-1]*10;
	res.m[1][1]=res.m[2][2]=res.m[3][3]=1;
	for (i=1;ten[i]&lt;=n&amp;&amp;i&lt;=18;i++)
	{
		a.m[1][1]=ten[i]%mo;
		a.m[2][1]=a.m[2][2]=a.m[3][2]=a.m[3][3]=1;
		res=res*(a^(ten[i]-ten[i-1]));
	}
	if (ten[i]&gt;n)
	{
		a.m[1][1]=ten[i]%mo;
		a.m[2][1]=a.m[2][2]=a.m[3][2]=a.m[3][3]=1;
		res=res*(a^(n-ten[i-1]+1));
		//printf(&quot;%lld\n&quot;,n-ten[i-1]+1);
	}
	ans.m[1][2]=ans.m[1][3]=1;
	ans=ans*res;
	printf(&quot;%lld\n&quot;,ans.m[1][1]);
	return 0;
}
<pre><h2>Problem2326</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define LL long long
LL n,ten[19];
int mo;
struct matrix
{
	LL m[4][4];
	matrix() {memset(m,0,sizeof(m));}
	friend matrix operator *(matrix a,matrix b)
	{
		matrix c;
		int i,j,k;
		for (k=1;k&lt;=3;k++)
			for (i=1;i&lt;=3;i++)
				for (j=1;j&lt;=3;j++)
					c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j])%mo;
		return c;
	}
	friend matrix operator ^(matrix a,LL x)
	{
		matrix res;
		res.m[1][1]=res.m[2][2]=res.m[3][3]=1;
		for (;x;x&gt;&gt;=1,a=a*a) if (x&amp;1) res=res*a;
		return res;
	}
} a,res,ans;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld%d&quot;,&amp;n,&amp;mo);
	int i;
	for (ten[0]=1,i=1;i&lt;=18;i++) ten[i]=ten[i-1]*10;
	res.m[1][1]=res.m[2][2]=res.m[3][3]=1;
	for (i=1;ten[i]&lt;=n&amp;&amp;i&lt;=18;i++)
	{
		a.m[1][1]=ten[i]%mo;
		a.m[2][1]=a.m[2][2]=a.m[3][2]=a.m[3][3]=1;
		res=res*(a^(ten[i]-ten[i-1]));
	}
	if (ten[i]&gt;n)
	{
		a.m[1][1]=ten[i]%mo;
		a.m[2][1]=a.m[2][2]=a.m[3][2]=a.m[3][3]=1;
		res=res*(a^(n-ten[i-1]+1));
		//printf(&quot;%lld\n&quot;,n-ten[i-1]+1);
	}
	ans.m[1][2]=ans.m[1][3]=1;
	ans=ans*res;
	printf(&quot;%lld\n&quot;,ans.m[1][1]);
	return 0;
}
<pre><h2>Problem2327</h2><pre>program hnoi2011day1b;
const maxn=1000010;
      modd=1000000007;
type edge=record
     v,pre:longint;
     cut:boolean;
     end;
     arr=array[0..maxn]of longint;
     arr2=array[0..maxn*3]of longint;
var e:array[0..maxn*4]of edge;
    hash,last,fa,x,y:array[0..maxn]of longint;
    w:array[0..maxn*3]of longint;
    a:array[0..maxn]of longint;
    f:array[0..maxn,0..1]of int64;
    er:array[0..maxn]of int64;
    must,cir:array[0..maxn]of boolean;
    tot,n,num,max:longint;
    ans:int64;
function gcd(a,b:int64):int64;
begin
  if b=0 then exit(a);
  exit(gcd(b,a mod b));
end;
procedure addedge(u,v:longint);
begin
  inc(tot);e[tot].v:=v;e[tot].pre:=last[u];
  last[u]:=tot;e[tot].cut:=false;
  inc(tot);e[tot].v:=u;e[tot].pre:=last[v];
  last[v]:=tot;e[tot].cut:=false;
end;
procedure qsort(l,r:longint;var b:arr2);
var i,j,x,y:longint;
begin
  i:=l;j:=r;
  x:=b[(l+r)shr 1];
  repeat
    while b[i]&lt;x do inc(i);
    while b[j]&gt;x do dec(j);
    if i&lt;=j then
     begin
       y:=b[i];b[i]:=b[j];b[j]:=y;
       inc(i);dec(j);
     end;
  until i&gt;j;
  if i&lt;r then qsort(i,r,b);
  if j&gt;l then qsort(l,j,b);
end;
procedure dfs(p:longint);
var tmp:longint;
begin
  tmp:=last[p];
  while tmp&lt;&gt;-1 do
   begin
     if (fa[p]&lt;&gt;e[tmp].v)and(not e[tmp].cut) then
      begin
        if fa[e[tmp].v]&lt;&gt;0 then
         begin
           inc(num);
           x[num]:=p;
           y[num]:=e[tmp].v;
           e[tmp].cut:=true;
           e[tmp xor 1].cut:=true;
           w[num&lt;&lt;1-1]:=p;
           w[num&lt;&lt;1]:=e[tmp].v;
           cir[p]:=true;
           cir[e[tmp].v]:=true;
         end
        else
         begin
           fa[e[tmp].v]:=p;
           dfs(e[tmp].v);
         end;
      end;
     tmp:=e[tmp].pre;
   end;
end;
procedure treedp(p:longint);
var tmp:longint;
begin
  tmp:=last[p];
  if cir[p] then
  begin
   if must[p] then
    begin
      f[p][1]:=er[hash[p]]-1;
      f[p][0]:=0
    end
   else
    begin
      f[p][1]:=0;
      f[p][0]:=1;
    end;
  end
   else
  begin
   f[p][0]:=1;
   f[p][1]:=er[hash[p]]-1;
  end;
  while tmp&lt;&gt;-1 do
   begin
     if (fa[p]&lt;&gt;e[tmp].v)and(not e[tmp].cut)then
      begin
        treedp(e[tmp].v);
        f[p][0]:=(f[p][0]*(f[e[tmp].v][0]+f[e[tmp].v][1]))mod modd;
        f[p][1]:=(f[p][1]*f[e[tmp].v][0])mod modd;
      end;
     tmp:=e[tmp].pre;
   end;
end;
procedure main(p:longint);
var i,j,k,now:longint;
    sum:int64;
    flag:boolean;
begin
  num:=0;fa[p]:=-1;j:=0;
  dfs(p);
  qsort(1,num shl 1,w);
  for i:=1 to num shl 1 do
   if w[i]&lt;&gt;w[j] then
    begin
      inc(j);
      w[j]:=w[i];
    end;
  sum:=0;
  for i:=0 to (1 shl j-1) do
   begin
     for k:=1 to j do must[w[k]]:=false;
     k:=i;now:=1;
     while k&lt;&gt;0 do
      begin
        if k and 1=1 then must[w[now]]:=true;
        inc(now);
        k:=k shr 1;
      end;
     flag:=false;
     for k:=1 to num do
      if must[x[k]] and must[y[k]] then
       begin
         flag:=true;
         break;
       end;
     if flag then continue;
     treedp(p);
     sum:=sum+f[p][0]+f[p][1];
     if sum&gt;modd then sum:=sum mod modd;
   end;
  ans:=(ans*sum)mod modd
end;
procedure prepare;
var i,j:int64;k:longint;
begin
  i:=2;
  tot:=-1;
  fillchar(last,sizeof(last),255);
  while i shl 1&lt;=max do
   begin
     j:=1;
     while (j&lt;i)and(j*i*2&lt;=max) do
      begin
        if ((i and 1)&lt;&gt;(j and 1))and(gcd(i,j)=1)and
        (i*i-j*j&lt;=max) then
         if (hash[j*i*2]&lt;&gt;0)and(hash[i*i-j*j]&lt;&gt;0)then
           addedge(j*i*2,i*i-j*j);
        inc(j);
      end;
     inc(i);
   end;
  er[0]:=1;
  for k:=1 to n do
   er[k]:=(er[k-1]*2)mod modd;
end;
procedure init;
var i:longint;
begin
  read(n);
  max:=-1;
  fillchar(hash,sizeof(hash),0);
  for i:=1 to n do
   begin
     read(a[i]);
     inc(hash[a[i]]);
     if max&lt;a[i] then max:=a[i];
   end;
  prepare;
  fillchar(fa,sizeof(fa),0);
  fillchar(cir,sizeof(cir),false);
  fillchar(w,sizeof(w),0);
  w[0]:=-1;
  ans:=1;
  for i:=1 to n do
   if fa[a[i]]=0 then
    main(a[i]);
  ans:=ans-1;
  if ans&lt;0 then ans:=ans+modd;
  write(ans);
end;

begin
  init;
end.<pre><h2>Problem2327</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 1001111
#define LL long long
#define mo 1000000007
#define ln printf(&quot;\n&quot;)
int o[NN],aa[5000000][2],fa[NN],flag[NN],f[NN],g[NN],a[NN],b[NN*3],q1[NN],q2[NN],er[NN];
int n,tot=1,cnt;
bool on[NN],cut[5000000],choose[NN],vt[NN],yes;
map&lt;int,bool&gt; link[NN];
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
void dfs(int v)
{
	vt[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (fa[v]==y||cut[p]) continue;
		if (!vt[y]) fa[y]=v,dfs(y);
		else
		{
			b[++b[0]]=v,b[++b[0]]=y;
			cnt++;
			q1[cnt]=v,q2[cnt]=y;
			on[v]=on[y]=true;
			cut[p]=cut[p^1]=true;
		}
	}
}
void treedp(int v)
{
	if (on[v])
		if (choose[v]) f[v]=er[flag[v]]-1,g[v]=0;
		else f[v]=0,g[v]=1;
	else f[v]=er[flag[v]]-1,g[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (fa[v]==y||cut[p]) continue;
		treedp(y);
		f[v]=(LL)f[v]*g[y]%mo;
		g[v]=(LL)g[v]*(f[y]+g[y])%mo;
	}
}
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int gcd(int a,int b) {return !b?a:gcd(b,a%b);}
int main()
{
	//freopen(&quot;input9.txt&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		flag[a[i]]++;
	}
	for (er[0]=1,i=1;i&lt;=n;i++) er[i]=er[i-1]*2%mo;
	for (LL i=1;i&lt;=1000000;i++)
		for (LL j=1;j*i*2&lt;=1000000;j++)
			if (gcd(i,j)==1&amp;&amp;(i&amp;1)!=(j&amp;1))
			{
				LL x=abs(j*j-i*i),y=2*i*j;
				if (x&gt;1000000||y&gt;1000000) continue;
				if (flag[x]&amp;&amp;flag[y]&amp;&amp;!link[x][y])
				{
					link[x][y]=link[y][x]=true;
					addedge(x,y);
					addedge(y,x);
				}
			}
	//printf(&quot;%d\n&quot;,tot);
	int ans=1;
	for (i=1;i&lt;=n;i++)
		if (!vt[a[i]])
		{
			if (a[i]==116572) yes=true;
			cnt=0;
			b[0]=0;
			dfs(a[i]);
			sort(b+1,b+b[0]+1);
			int num,res,S;
			for (num=1,j=2;j&lt;=b[0];j++)
				if (b[j]!=b[num]) b[++num]=b[j];
			if (b[0]==0) num=0;
			//if (yes) printf(&quot;%d\n&quot;,num);
			//if (yes) out(b,1,num);
			res=0;
			for (S=0;S&lt;=(1&lt;&lt;num)-1;S++)
			{
				for (j=1;j&lt;=num;j++) choose[b[j]]=false;
				for (j=1;j&lt;=num;j++)
					if (S&amp;(1&lt;&lt;(j-1))) choose[b[j]]=true;
					else choose[b[j]]=false;
				bool tt=true;
				for (j=1;j&lt;=cnt&amp;&amp;tt;j++)
					if (choose[q1[j]]&amp;&amp;choose[q2[j]]) tt=false;
				if (!tt) continue;
				treedp(a[i]);
				res=((res+f[a[i]])%mo+g[a[i]])%mo;
				//if (yes) printf(&quot;S=%d res=%d\n&quot;,S,res);
			}
			//printf(&quot;%d %d\n&quot;,a[i],res);
			ans=(LL)ans*res%mo;
			yes=false;
		}
	ans--;
	if (ans&lt;0) ans+=mo;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2327</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 1001111
#define LL long long
#define mo 1000000007
int o[NN],aa[5000000][2],fa[NN],flag[NN],f[NN],g[NN],a[NN],b[NN*3],q1[NN],q2[NN],er[NN];
int n,tot=1,cnt;
bool on[NN],cut[5000000],choose[NN],vt[NN];
void dfs(int v)
{
	vt[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (fa[v]==y||cut[p]) continue;
		if (!vt[y]) fa[y]=v,dfs(y);
		else
		{
			b[++b[0]]=v,b[++b[0]]=y;
			cnt++;
			q1[cnt]=v,q2[cnt]=y;
			on[v]=on[y]=true;
			cut[p]=cut[p^1]=true;
		}
	}
}
void treedp(int v)
{
	if (on[v])
		if (choose[v]) f[v]=er[flag[v]]-1,g[v]=0;
		else f[v]=0,g[v]=1;
	else f[v]=er[flag[v]]-1,g[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (fa[v]==y||cut[p]) continue;
		treedp(y);
		f[v]=(LL)f[v]*g[y]%mo;
		g[v]=(LL)g[v]*(f[y]+g[y])%mo;
	}
}
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int gcd(int a,int b) {return !b?a:gcd(b,a%b);}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	int i,j;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		flag[a[i]]++;
	}
	for (er[0]=1,i=1;i&lt;=n;i++) er[i]=er[i-1]*2%mo;
	for (LL i=1;i&lt;=1000000;i++)
		for (LL j=1;j&lt;i&amp;&amp;j*i*2&lt;=1000000;j++)
			if (gcd(i,j)==1&amp;&amp;(i&amp;1)!=(j&amp;1))
			{
				LL x=i*i-j*j,y=2*i*j;
				if (x&gt;1000000||y&gt;1000000) continue;
				if (flag[x]&amp;&amp;flag[y])
				{
					addedge(x,y);
					addedge(y,x);
				}
			}
	int ans=1;
	for (i=1;i&lt;=n;i++)
		if (!vt[a[i]])
		{
			cnt=0;
			b[0]=0;
			dfs(a[i]);
			sort(b+1,b+b[0]+1);
			int num,res,S;
			for (num=1,j=2;j&lt;=b[0];j++)
				if (b[j]!=b[num]) b[++num]=b[j];
			if (b[0]==0) num=0;
			res=0;
			for (S=0;S&lt;=(1&lt;&lt;num)-1;S++)
			{
				for (j=1;j&lt;=num;j++) choose[b[j]]=false;
				for (j=1;j&lt;=num;j++)
					if (S&amp;(1&lt;&lt;(j-1))) choose[b[j]]=true;
					else choose[b[j]]=false;
				bool tt=true;
				for (j=1;j&lt;=cnt&amp;&amp;tt;j++)
					if (choose[q1[j]]&amp;&amp;choose[q2[j]]) tt=false;
				if (!tt) continue;
				treedp(a[i]);
				res=((res+f[a[i]])%mo+g[a[i]])%mo;
			}
			ans=(LL)ans*res%mo;
		}
	ans--;
	if (ans&lt;0) ans+=mo;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2327</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 1001111
#define LL long long
#define mo 1000000007
int o[NN],aa[3000000][2],fa[NN],flag[NN],f[NN],g[NN],a[NN],b[NN*3],q1[NN],q2[NN],er[NN];
int n,tot=1,cnt;
bool on[NN],cut[3000000],choose[NN],vt[NN];
void dfs(int v)
{
	vt[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (fa[v]==y||cut[p]) continue;
		if (!vt[y]) fa[y]=v,dfs(y);
		else
		{
			b[++b[0]]=v,b[++b[0]]=y;
			cnt++;
			q1[cnt]=v,q2[cnt]=y;
			on[v]=on[y]=true;
			cut[p]=cut[p^1]=true;
		}
	}
}
void treedp(int v)
{
	if (on[v])
		if (choose[v]) f[v]=er[flag[v]]-1,g[v]=0;
		else f[v]=0,g[v]=1;
	else f[v]=er[flag[v]]-1,g[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (fa[v]==y||cut[p]) continue;
		treedp(y);
		f[v]=(LL)f[v]*g[y]%mo;
		g[v]=(LL)g[v]*(f[y]+g[y])%mo;
	}
}
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int gcd(int a,int b) {return !b?a:gcd(b,a%b);}
int main()
{
	//freopen(&quot;input9.txt&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		flag[a[i]]++;
	}
	for (er[0]=1,i=1;i&lt;=n;i++) er[i]=er[i-1]*2%mo;
	for (LL i=1;i&lt;=1000000;i++)
		for (LL j=1;j&lt;i&amp;&amp;j*i*2&lt;=1000000;j++)
			if (gcd(i,j)==1&amp;&amp;(i&amp;1)!=(j&amp;1))
			{
				LL x=i*i-j*j,y=2*i*j;
				if (x&gt;1000000||y&gt;1000000) continue;
				if (flag[x]&amp;&amp;flag[y])
				{
					addedge(x,y);
					addedge(y,x);
				}
			}
	int ans=1;
	for (i=1;i&lt;=n;i++)
		if (!vt[a[i]])
		{
			cnt=0;
			b[0]=0;
			dfs(a[i]);
			sort(b+1,b+b[0]+1);
			int num,res,S;
			for (num=1,j=2;j&lt;=b[0];j++)
				if (b[j]!=b[num]) b[++num]=b[j];
			if (b[0]==0) num=0;
			res=0;
			for (S=0;S&lt;=(1&lt;&lt;num)-1;S++)
			{
				for (j=1;j&lt;=num;j++) choose[b[j]]=false;
				for (j=1;j&lt;=num;j++)
					if (S&amp;(1&lt;&lt;(j-1))) choose[b[j]]=true;
					else choose[b[j]]=false;
				bool tt=true;
				for (j=1;j&lt;=cnt&amp;&amp;tt;j++)
					if (choose[q1[j]]&amp;&amp;choose[q2[j]]) tt=false;
				if (!tt) continue;
				treedp(a[i]);
				res=((res+f[a[i]])%mo+g[a[i]])%mo;
			}
			ans=(LL)ans*res%mo;
		}
	ans--;
	if (ans&lt;0) ans+=mo;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2328</h2><pre>#include&lt;cstdio&gt; 
#include&lt;cstdlib&gt; 
#include&lt;cstring&gt; 
#include&lt;cmath&gt; 
#include&lt;algorithm&gt; 
#define eps 1e-13 
#define MAXN 10010 
using namespace std; 
int dcmp(double p) 
{ 
    if(fabs(p)&lt;eps)  return 0; 
    return p&gt;eps?1:-1; 
} 
int n; 
double vmax,oil,a,b; 
bool mark; 
struct Node 
{ 
    double deltax,deltay,k,speed,dis; 
    friend bool operator &lt; (const Node &amp;a,const Node &amp;b){  return a.speed&lt;b.speed;  } 
}road[MAXN]; 
void read() 
{ 
    mark=false; 
    scanf(&quot;%lf %lf %lf %lf %d&quot;,&amp;a,&amp;b,&amp;vmax,&amp;oil,&amp;n); 
    for(int i=1;i&lt;=n;i++) 
    { 
        scanf(&quot;%lf %lf&quot;,&amp;road[i].deltax,&amp;road[i].deltay); 
        road[i].deltax/=1000,road[i].deltay/=1000; 
    } 
} 
void First_Speed() 
{ 
    for(int i=1;i&lt;=n;i++) 
    { 
        road[i].k=road[i].deltay/road[i].deltax; 
        road[i].dis=sqrt(road[i].deltax*road[i].deltax+road[i].deltay*road[i].deltay); 
        if(dcmp(road[i].k)&gt;=0)  road[i].speed=0,mark=true; 
        else road[i].speed=min(vmax,-b*road[i].k/a); 
    } 
} 
void solve() 
{ 
    for(int i=1;i&lt;=n;i++) 
        oil=oil-max(0.0,b*road[i].k+a*road[i].speed)*road[i].dis; 
    if(dcmp(oil)&lt;0||(!dcmp(oil)&amp;&amp;mark)) 
    { 
        printf(&quot;IMPOSSIBLE\n&quot;); 
        return ; 
    } 
    sort(road+1,road+n+1); 
    double nowd=road[1].dis,nowv=road[1].speed; 
    for(int i=2;i&lt;=n;i++) 
    { 
        double delta_oil=(road[i].speed-nowv)*a*nowd; 
        if(dcmp(oil-delta_oil)&lt;=0) 
        { 
            nowv=nowv+oil/a/nowd; 
            double ans=nowd/nowv; 
            for(int j=i;j&lt;=n;j++) 
                ans=ans+road[j].dis/road[j].speed; 
            printf(&quot;%.5lf\n&quot;,ans); 
            return ; 
        } 
        nowv=road[i].speed,nowd+=road[i].dis,oil-=delta_oil; 
    } 
    nowv=min(vmax,nowv+oil/a/nowd); 
    printf(&quot;%.5lf\n&quot;,nowd/nowv); 
} 
int main() 
{ 
    int test; 
    for(scanf(&quot;%d&quot;,&amp;test);test&gt;=1;test--) 
    { 
        read(); 
        First_Speed(); 
        solve(); 
    } 
    return 0; 
}
 <pre><h2>Problem2329</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 101111
#define ln printf(&quot;\n&quot;)
int tlmin[NN],trmin[NN],tlmax[NN],trmax[NN],tsum[NN],key[NN],size[NN],fa[NN],son[NN][2],b[NN],tag2[NN];
int n,m,root;
bool tag1[NN],tag3[NN];
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
int min3(int a,int b,int c)
{
	if (a&lt;=b&amp;&amp;a&lt;=c) return a;
	if (b&lt;=c) return b;
	return c;
}
int max3(int a,int b,int c)
{
	if (a&gt;=b&amp;&amp;a&gt;=c) return a;
	if (b&gt;=c) return b;
	return c;
}
void rev(int v)
{
	if (!v) return;
	tag1[v]=!tag1[v];
	swap(son[v][0],son[v][1]);
	swap(tlmin[v],trmin[v]);
	swap(tlmax[v],trmax[v]);
}
void make(int v,int kind)
{
	if (!v) return;
	tag2[v]=kind;
	if (tag3[v]) tag3[v]=false;
	key[v]=kind;
	if (kind==1)
	{
		tsum[v]=size[v];
		tlmax[v]=trmax[v]=size[v];
		tlmin[v]=trmin[v]=0;
	}
	else
	{
		tsum[v]=-size[v];
		tlmin[v]=trmin[v]=-size[v];
		tlmax[v]=trmax[v]=0;
	}
}
void inv(int v)
{
	if (!v) return;
	//printf(&quot;invert %d\n&quot;,v);
	if (tag2[v]) {make(v,-tag2[v]);return;}
	tag3[v]=!tag3[v];
	key[v]=-key[v];
	tsum[v]=-tsum[v];
	swap(tlmin[v],tlmax[v]);
	tlmin[v]=-tlmin[v],tlmax[v]=-tlmax[v];
	//printf(&quot;trmin[v]=%d\n&quot;,trmin[v]);
	swap(trmin[v],trmax[v]);
	trmin[v]=-trmin[v],trmax[v]=-trmax[v];
	//printf(&quot;trmax[v]=%d\n&quot;,trmax[v]);
}
void pushdown(int v)
{
	int x=son[v][0],y=son[v][1];
	if (tag1[v])
	{
		rev(x),rev(y);
		tag1[v]=false;
	}
	if (tag2[v])
	{
		make(x,tag2[v]),make(y,tag2[v]);
		tag2[v]=0;
	}
	if (tag3[v])
	{
		inv(x),inv(y);
		tag3[v]=false;
	}
}
void update(int v)
{
	int x=son[v][0],y=son[v][1];
	size[v]=size[x]+size[y]+1;
	tsum[v]=tsum[x]+tsum[y]+key[v];
	tlmin[v]=min3(tlmin[x],tsum[x]+key[v],tsum[x]+key[v]+tlmin[y]);
	tlmax[v]=max3(tlmax[x],tsum[x]+key[v],tsum[x]+key[v]+tlmax[y]);
	trmin[v]=min3(trmin[y],tsum[y]+key[v],tsum[y]+key[v]+trmin[x]);
	trmax[v]=max3(trmax[y],tsum[y]+key[v],tsum[y]+key[v]+trmax[x]);
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (!ff) root=t;
}
int find(int t,int K)
{
	while (t)
	{
		pushdown(t);
		int tmp=size[son[t][0]];
		if (K==tmp+1) return t;
		if (K&lt;=tmp) t=son[t][0];
		else K-=(tmp+1),t=son[t][1];
	}
	return -1;
}
int build(int l,int r)
{
	int mid=(l+r)&gt;&gt;1,v=mid;
	key[v]=b[mid];
	tag1[v]=tag3[v]=false,tag2[v]=0;
	if (key[v]==-1)
	{
		tlmin[v]=trmin[v]=-1;
		tlmax[v]=trmax[v]=0;
	}
	else
	{
		tlmax[v]=trmax[v]=1;
		tlmin[v]=trmin[v]=0;
	}
	if (l&lt;mid) son[v][0]=build(l,mid-1),fa[son[v][0]]=v;
	if (r&gt;mid) son[v][1]=build(mid+1,r),fa[son[v][1]]=v;
	update(v);
	return v;
}
void debug(int t){if(!t)return;pushdown(t);debug(son[t][0]);printf(&quot;%c&quot;,key[t]&gt;0?'(':key[t]&lt;0?')':'_');debug(son[t][1]);}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i;
	for (i=2;i&lt;=n+1;i++)
	{
		char ch=getchar();
		while (ch!='('&amp;&amp;ch!=')') ch=getchar();
		b[i]=(ch=='(')?1:-1;
	}
	n+=2;
	root=build(1,n);
	//debug(root),ln;printf(&quot;key &quot;);out(key,1,n);
	//printf(&quot;fa &quot;),out(fa,1,n);printf(&quot;son &quot;);for(int i=1;i&lt;=n;i++)printf(&quot;%d %d   &quot;,son[i][0],son[i][1]);ln;ln;
	//for(int i=1;i&lt;=n;i++)printf(&quot;%d:  key=%d tsum=%d tlmin=%d tlmax=%d trmin=%d trmax=%d\n&quot;,i,key[i],tsum[i],tlmin[i],tlmax[i],trmin[i],trmax[i]);
	for (;m;m--)
	{
		//printf(&quot;\n\n-----------------------------------------------------------------------------\n&quot;);
		char ch=getchar();
		while (ch&lt;'A'||ch&gt;'Z') ch=getchar();
		int l,r,x,y;
		//printf(&quot;ch=%c\n&quot;,ch);
		if (ch=='R')
		{
			for (i=1;i&lt;=6;i++) ch=getchar();
			scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
			l++,r++;
			while (ch!='('&amp;&amp;ch!=')') ch=getchar();
			int kind=(ch=='(')?1:-1;
			x=find(root,l-1),splay(x,0);
			y=find(root,r+1),splay(y,x);
			x=son[y][0];
			make(x,kind);
			splay(x,0);
			//ln;printf(&quot;root=%d  &quot;,root);debug(root),ln,ln;
			//printf(&quot;fa &quot;),out(fa,1,n);printf(&quot;son &quot;);for(int i=1;i&lt;=n;i++)printf(&quot;%d %d   &quot;,son[i][0],son[i][1]);ln,ln;
			//for(int i=1;i&lt;=n;i++)printf(&quot;%d:  key=%d tsum=%d tlmin=%d tlmax=%d trmin=%d trmax=%d\n&quot;,i,key[i],tsum[i],tlmin[i],tlmax[i],trmin[i],trmax[i]);
		}
		else if (ch=='S')
		{
			for (i=1;i&lt;=3;i++) ch=getchar();
			scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
			l++,r++;
			x=find(root,l-1),splay(x,0);
			y=find(root,r+1),splay(y,x);
			x=son[y][0];
			rev(x);
			splay(x,0);
		}
		else if (ch=='I')
		{
			for (i=1;i&lt;=5;i++) ch=getchar();
			scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
			l++,r++;
			x=find(root,l-1),splay(x,0);
			y=find(root,r+1),splay(y,x);
			x=son[y][0];
			//ln;printf(&quot;x=%d\n&quot;,x);
			//ln;printf(&quot;root=%d  &quot;,root);debug(root),ln,ln;
			//printf(&quot;fa &quot;),out(fa,1,n);printf(&quot;son &quot;);for(int i=1;i&lt;=n;i++)printf(&quot;%d %d   &quot;,son[i][0],son[i][1]);ln,ln;
			//for(int i=1;i&lt;=n;i++)printf(&quot;%d:  key=%d tsum=%d tlmin=%d tlmax=%d trmin=%d trmax=%d\n&quot;,i,key[i],tsum[i],tlmin[i],tlmax[i],trmin[i],trmax[i]);
			//printf(&quot;x=%d son[x][0]=%d son[x][1]=%d\n&quot;,x,son[x][0],son[x][1]);
			inv(x);
			splay(x,0);
		}
		else
		{
			for (i=1;i&lt;=4;i++) ch=getchar();
			scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
			l++,r++;
			x=find(root,l-1),splay(x,0);
			y=find(root,r+1),splay(y,x);
			//printf(&quot;%d %d\n&quot;,x,y);
			x=son[y][0];
			//update(3),update(4);
			//ln;printf(&quot;root=%d  &quot;,root);debug(root),ln,ln;
			//printf(&quot;fa &quot;),out(fa,1,n);printf(&quot;son &quot;);for(int i=1;i&lt;=n;i++)printf(&quot;%d %d   &quot;,son[i][0],son[i][1]);ln,ln;
			//for(int i=1;i&lt;=n;i++)printf(&quot;%d:  key=%d tsum=%d tlmin=%d tlmax=%d trmin=%d trmax=%d\n&quot;,i,key[i],tsum[i],tlmin[i],tlmax[i],trmin[i],trmax[i]);
			l=-tlmin[x],r=trmax[x];
			//printf(&quot;%d %d\n&quot;,l,r);
			printf(&quot;%d\n&quot;,(l+1)/2+(r+1)/2);
			//printf(&quot;%d %d %d\n&quot;,tag1[3],tag2[3],tag3[3]);
			//printf(&quot;tlmin[3]=%d,trmax[3]=%d tsum[3]=%d\n&quot;,tlmin[3],trmax[3],tsum[3]);
			splay(x,0);
		}
		//ln;printf(&quot;root=%d  &quot;,root);debug(root),ln,ln;
		//printf(&quot;fa &quot;),out(fa,1,n);printf(&quot;son &quot;);for(int i=1;i&lt;=n;i++)printf(&quot;%d %d   &quot;,son[i][0],son[i][1]);ln,ln;
		//for(int i=1;i&lt;=n;i++)printf(&quot;%d:  key=%d tsum=%d tlmin=%d tlmax=%d trmin=%d trmax=%d\n&quot;,i,key[i],tsum[i],tlmin[i],tlmax[i],trmin[i],trmax[i]);
	}
	return 0;
}
<pre><h2>Problem2329</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 101111
int tlmin[NN],trmin[NN],tlmax[NN],trmax[NN],tsum[NN],key[NN],size[NN],fa[NN],son[NN][2],b[NN],tag2[NN];
int n,m,root;
bool tag1[NN],tag3[NN];
int min3(int a,int b,int c)
{
	if (a&lt;=b&amp;&amp;a&lt;=c) return a;
	if (b&lt;=c) return b;
	return c;
}
int max3(int a,int b,int c)
{
	if (a&gt;=b&amp;&amp;a&gt;=c) return a;
	if (b&gt;=c) return b;
	return c;
}
void rev(int v)
{
	if (!v) return;
	tag1[v]=!tag1[v];
	swap(son[v][0],son[v][1]);
	swap(tlmin[v],trmin[v]);
	swap(tlmax[v],trmax[v]);
}
void make(int v,int kind)
{
	if (!v) return;
	tag2[v]=kind;
	if (tag3[v]) tag3[v]=false;
	key[v]=kind;
	if (kind==1)
	{
		tsum[v]=size[v];
		tlmax[v]=trmax[v]=size[v];
		tlmin[v]=trmin[v]=0;
	}
	else
	{
		tsum[v]=-size[v];
		tlmin[v]=trmin[v]=-size[v];
		tlmax[v]=trmax[v]=0;
	}
}
void inv(int v)
{
	if (!v) return;
	if (tag2[v]) {make(v,-tag2[v]);return;}
	tag3[v]=!tag3[v];
	key[v]=-key[v];
	tsum[v]=-tsum[v];
	swap(tlmin[v],tlmax[v]);
	tlmin[v]=-tlmin[v],tlmax[v]=-tlmax[v];
	swap(trmin[v],trmax[v]);
	trmin[v]=-trmin[v],trmax[v]=-trmax[v];
}
void pushdown(int v)
{
	int x=son[v][0],y=son[v][1];
	if (tag1[v])
	{
		rev(x),rev(y);
		tag1[v]=false;
	}
	if (tag2[v])
	{
		make(x,tag2[v]),make(y,tag2[v]);
		tag2[v]=0;
	}
	if (tag3[v])
	{
		inv(x),inv(y);
		tag3[v]=false;
	}
}
void update(int v)
{
	int x=son[v][0],y=son[v][1];
	size[v]=size[x]+size[y]+1;
	tsum[v]=tsum[x]+tsum[y]+key[v];
	tlmin[v]=min3(tlmin[x],tsum[x]+key[v],tsum[x]+key[v]+tlmin[y]);
	tlmax[v]=max3(tlmax[x],tsum[x]+key[v],tsum[x]+key[v]+tlmax[y]);
	trmin[v]=min3(trmin[y],tsum[y]+key[v],tsum[y]+key[v]+trmin[x]);
	trmax[v]=max3(trmax[y],tsum[y]+key[v],tsum[y]+key[v]+trmax[x]);
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (!ff) root=t;
}
int find(int t,int K)
{
	while (t)
	{
		pushdown(t);
		int tmp=size[son[t][0]];
		if (K==tmp+1) return t;
		if (K&lt;=tmp) t=son[t][0];
		else K-=(tmp+1),t=son[t][1];
	}
	return -1;
}
int build(int l,int r)
{
	int mid=(l+r)&gt;&gt;1,v=mid;
	key[v]=b[mid];
	tag1[v]=tag3[v]=false,tag2[v]=0;
	if (key[v]==-1)
	{
		tlmin[v]=trmin[v]=-1;
		tlmax[v]=trmax[v]=0;
	}
	else
	{
		tlmax[v]=trmax[v]=1;
		tlmin[v]=trmin[v]=0;
	}
	if (l&lt;mid) son[v][0]=build(l,mid-1),fa[son[v][0]]=v;
	if (r&gt;mid) son[v][1]=build(mid+1,r),fa[son[v][1]]=v;
	update(v);
	return v;
}
void debug(int t){if(!t)return;pushdown(t);debug(son[t][0]);printf(&quot;%c&quot;,key[t]&gt;0?'(':key[t]&lt;0?')':'_');debug(son[t][1]);}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i;
	for (i=2;i&lt;=n+1;i++)
	{
		char ch=getchar();
		while (ch!='('&amp;&amp;ch!=')') ch=getchar();
		b[i]=(ch=='(')?1:-1;
	}
	n+=2;
	root=build(1,n);
	for (;m;m--)
	{
		char ch=getchar();
		while (ch&lt;'A'||ch&gt;'Z') ch=getchar();
		int l,r,x,y;
		if (ch=='R')
		{
			for (i=1;i&lt;=6;i++) ch=getchar();
			scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
			l++,r++;
			while (ch!='('&amp;&amp;ch!=')') ch=getchar();
			int kind=(ch=='(')?1:-1;
			x=find(root,l-1),splay(x,0);
			y=find(root,r+1),splay(y,x);
			x=son[y][0];
			make(x,kind);
			splay(x,0);
		}
		else if (ch=='S')
		{
			for (i=1;i&lt;=3;i++) ch=getchar();
			scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
			l++,r++;
			x=find(root,l-1),splay(x,0);
			y=find(root,r+1),splay(y,x);
			x=son[y][0];
			rev(x);
			splay(x,0);
		}
		else if (ch=='I')
		{
			for (i=1;i&lt;=5;i++) ch=getchar();
			scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
			l++,r++;
			x=find(root,l-1),splay(x,0);
			y=find(root,r+1),splay(y,x);
			x=son[y][0];
			inv(x);
			splay(x,0);
		}
		else
		{
			for (i=1;i&lt;=4;i++) ch=getchar();
			scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
			l++,r++;
			x=find(root,l-1),splay(x,0);
			y=find(root,r+1),splay(y,x);
			x=son[y][0];
			l=-tlmin[x],r=trmax[x];
			printf(&quot;%d\n&quot;,(l+1)/2+(r+1)/2);
			splay(x,0);
		}
	}
	return 0;
}
<pre><h2>Problem2330</h2><pre>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;cmath&gt;
using namespace std;
#define maxn 210000
int n,k,num;
int b[maxn],val[maxn],in[maxn],next[maxn],p[maxn],dis[maxn];
bool vis[maxn];
void add(int x,int y,int z)
{
    num++;
    b[num]=y;
    val[num]=z;
    next[num]=p[x];
    p[x]=num;
}
queue&lt;int&gt;q;
bool spfa()
{
    int tot,cur;
    while(!q.empty())
    {
        cur=q.front();
        q.pop();
        vis[cur]=false;
        for(tot=p[cur];tot;tot=next[tot])
        {
            if(dis[cur]+val[tot]&gt;dis[b[tot]])
            {
                dis[b[tot]]=dis[cur]+val[tot];
                in[tot]++;
                if(in[tot]&gt;n) return false;
                if(!vis[b[tot]])
                {
                    vis[b[tot]]=1;
                    q.push(b[tot]);
                }
            }
        }
    }
    return true;
}
int main()
{
    int u,v,op;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
    for(int i=1;i&lt;=k;i++)
    {
        scanf(&quot;%d%d%d&quot;,&amp;op,&amp;u,&amp;v);
        if(op==1)
        {
            add(u,v,0);
            add(v,u,0);
        }
        if(op==2)
        {
            add(u,v,1);
            if(u==v)
            {
                printf(&quot;-1\n&quot;);
                return 0;
            }
        }
        if(op==3)
        {
            add(v,u,0);
        }
        if(op==4)
        {
            add(v,u,1);
            if(u==v)
            {
                printf(&quot;-1\n&quot;);
                return 0;
            }
        }
        if(op==5)
        {
            add(u,v,0);
        }
    }
    for(int i=1;i&lt;=n;i++)
    {
        vis[i]=1;
        dis[i]=1;
        q.push(i);
    }
    if(!spfa())
    {
        printf(&quot;-1\n&quot;);
        return 0;
    }

    long long tmp=0;
    for(int i=1;i&lt;=n;i++)
    {
        tmp+=dis[i];
    }
    printf(&quot;%lld\n&quot;,tmp);
    return 0;
}<pre><h2>Problem2330</h2><pre>var
  aa:array[0..500050,1..3]of longint;
  o,dist,time:array[0..200050]of longint;
  q:array[0..3000000]of longint;
  dl:array[0..200050]of boolean;
  n,m,i,x,y,z,head,tail,tot,p:longint;
  ans:int64;
procedure add(p,q,v:longint);
begin
  inc(tot);
  aa[tot,1]:=q;
  aa[tot,2]:=v;
  aa[tot,3]:=o[p];
  o[p]:=tot;
end;
function relax(x,y,v:longint):boolean;
begin
  if dist[y]&lt;dist[x]+v then
    begin
      dist[y]:=dist[x]+v;
      exit(true);
    end;
  exit(false);
end;
procedure outitno;
begin
  writeln(-1);
  halt;
end;
begin
  //assign(input,'1.in');reset(input);
  //assign(output,'sss.out');rewrite(output);
  readln(n,m);
  for i:=1 to m do
    begin
      readln(x,y,z);
      case x of
        1://f[y]=f[z]
          begin
            add(y,z,0);
            add(z,y,0);
          end;
        2://f[y]&lt;f[z] f[z]-1&gt;=f[y]
          //add(z,y,-1);
          begin
            add(y,z,1);
            if y=z then outitno;
          end;
        3://f[y]&gt;=f[z]
          //add(y,z,0);
          add(z,y,0);
        4://f[y]&gt;f[z] f[y]-1&gt;=f[z]
          //add(y,z,-1);
          begin
            add(z,y,1);
            if y=z then outitno;
          end;
        5://f[y]&lt;=f[z]
          //add(z,y,0);
          add(y,z,0);
        end;
    end;
  head:=0;tail:=0;
  for i:=1 to n do
    begin
      inc(tail);
      q[tail]:=i;
      dist[i]:=1;
      dl[i]:=true;
      time[i]:=0;
    end;
  while head&lt;&gt;tail do
    begin
      inc(head);
      if head=3000000 then head:=1;
      x:=q[head];
      //writeln(x);
      dl[x]:=false;
      p:=o[x];
      while p&gt;0 do
        begin
          y:=aa[p,1];
          if relax(x,y,aa[p,2]) then
            if not dl[y] then
              begin
                inc(tail);
                if tail=3000000 then tail:=1;
                q[tail]:=y;
                dl[y]:=true;
                inc(time[y]);
                if time[y]&gt;n then outitno;
              end;
          p:=aa[p,3];
        end;
    end;
  ans:=0;
  for i:=1 to n do inc(ans,dist[i]);
  writeln(ans);
  //for i:=1 to n do writeln(dist[i]);
  //close(input);close(output);
end.<pre><h2>Problem2330</h2><pre>var
  aa:array[0..500050,1..3]of longint;
  o,dist,time:array[0..200050]of longint;
  q:array[0..3000000]of longint;
  dl:array[0..200050]of boolean;
  n,m,i,x,y,z,head,tail,tot,p:longint;
  ans:int64;
procedure add(p,q,v:longint);
begin
  inc(tot);
  aa[tot,1]:=q;
  aa[tot,2]:=v;
  aa[tot,3]:=o[p];
  o[p]:=tot;
end;
function relax(x,y,v:longint):boolean;
begin
  if dist[y]&lt;dist[x]+v then
    begin
      dist[y]:=dist[x]+v;
      exit(true);
    end;
  exit(false);
end;
procedure outitno;
begin
  writeln(-1);
  halt;
end;
begin
  //assign(input,'1.in');reset(input);
  //assign(output,'sss.out');rewrite(output);
  readln(n,m);
  for i:=1 to m do
    begin
      readln(x,y,z);
      case x of
        1://f[y]=f[z]
          begin
            add(y,z,0);
            add(z,y,0);
          end;
        2://f[y]&lt;f[z] f[z]-1&gt;=f[y]
          //add(z,y,-1);
          begin
            add(y,z,1);
            //if y=z then outitno;
          end;
        3://f[y]&gt;=f[z]
          //add(y,z,0);
          add(z,y,0);
        4://f[y]&gt;f[z] f[y]-1&gt;=f[z]
          //add(y,z,-1);
          begin
            add(z,y,1);
            //if y=z then outitno;
          end;
        5://f[y]&lt;=f[z]
          //add(z,y,0);
          add(y,z,0);
        end;
    end;
  head:=0;tail:=0;
  for i:=1 to n do
    begin
      inc(tail);
      q[tail]:=i;
      dist[i]:=1;
      dl[i]:=true;
      time[i]:=0;
    end;
  while head&lt;&gt;tail do
    begin
      inc(head);
      if head=3000000 then head:=1;
      x:=q[head];
      //writeln(x);
      dl[x]:=false;
      p:=o[x];
      while p&gt;0 do
        begin
          y:=aa[p,1];
          if relax(x,y,aa[p,2]) then
            if not dl[y] then
              begin
                inc(tail);
                if tail=3000000 then tail:=1;
                q[tail]:=y;
                dl[y]:=true;
                inc(time[y]);
                if time[y]&gt;n then outitno;
              end;
          p:=aa[p,3];
        end;
    end;
  ans:=0;
  for i:=1 to n do inc(ans,dist[i]);
  writeln(ans);
  //for i:=1 to n do writeln(dist[i]);
  //close(input);close(output);
end.<pre><h2>Problem2330</h2><pre>var
  aa:array[0..500050,1..3]of longint;
  o,dist,time:array[0..200050]of longint;
  q:array[0..3000000]of longint;
  dl:array[0..200050]of boolean;
  n,m,i,x,y,z,head,tail,tot,p:longint;
  ans:int64;
procedure add(p,q,v:longint);
begin
  inc(tot);
  aa[tot,1]:=q;
  aa[tot,2]:=v;
  aa[tot,3]:=o[p];
  o[p]:=tot;
end;
function relax(x,y,v:longint):boolean;
begin
  if dist[y]&lt;dist[x]+v then
    begin
      dist[y]:=dist[x]+v;
      exit(true);
    end;
  exit(false);
end;
procedure outitno;
begin
  writeln(-1);
  halt;
end;
begin
  readln(n,m);
  for i:=1 to m do
    begin
      readln(x,y,z);
      case x of
        1:begin
            add(y,z,0);
            add(z,y,0);
          end;
        2:add(y,z,1);
        3:add(z,y,0);
        4:add(z,y,1);
        5:add(y,z,0);
        end;
    end;
  head:=0;tail:=0;
  for i:=1 to n do
    begin
      inc(tail);
      q[tail]:=i;
      dist[i]:=1;
      dl[i]:=true;
      time[i]:=0;
    end;
  while head&lt;&gt;tail do
    begin
      inc(head);
      if head=3000000 then head:=1;
      x:=q[head];
      dl[x]:=false;
      p:=o[x];
      while p&gt;0 do
        begin
          y:=aa[p,1];
          if relax(x,y,aa[p,2]) then
            if not dl[y] then
              begin
                inc(tail);
                if tail=3000000 then tail:=1;
                q[tail]:=y;
                dl[y]:=true;
                inc(time[y]);
                if time[y]&gt;n then outitno;
              end;
          p:=aa[p,3];
        end;
    end;
  ans:=0;
  for i:=1 to n do inc(ans,dist[i]);
  writeln(ans);
end.<pre><h2>Problem2331</h2><pre>#include&lt;cstdio&gt;
#include&lt;map&gt;
using namespace std;
#define mo 20110520
#define fi first
#define se second
#define ln printf(&quot;\n&quot;)
int n,m,now;
bool can[111][111];
char a[111][111],b[111][111];
map&lt;int,int&gt; C[2];
map&lt;int,int&gt;::iterator it;
int pack(int *a)
{
	int res=0;
	for (int i=0;i&lt;=m;i++) res=res&lt;&lt;2|a[i];
	return res;
}
void repack(int *a,int X)
{
	for (int i=m;i&gt;=0;i--)
	{
		a[i]=X&amp;3;
		X&gt;&gt;=2;
	}
}
void youyi(int *a)
{
	for (int i=m;i&gt;0;i--) a[i]=a[i-1];
	a[0]=0;
}
void renew(int *a,int ff)
{
	//printf(&quot;  ins  &quot;);for (int i=0;i&lt;=m;i++)printf(&quot;%d &quot;,a[i]);ln;
	int t=pack(a);
	int tmp=C[now^1][t]+=ff;
	if (tmp&gt;mo) C[now^1][t]-=mo;
}
void work1(int i,int j)
{
	static int aa[15],a[15];
	for (it=C[now].begin();it!=C[now].end();it++)
	{
		int X=(*it).fi,ff=(*it).se,k;
		repack(aa,X);
		//for(k=0;k&lt;=m;k++)printf(&quot;%d &quot;,aa[k]);printf(&quot;  ff=%d\n&quot;,ff);
		int left=aa[j-1],up=aa[j];
		if (left==0&amp;&amp;up==0)
		{
			if (can[i+1][j])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=1,a[j]=0;
				if (j==m) youyi(a);
				renew(a,ff);
			}
			if (can[i][j+1])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=0,a[j]=1;
				renew(a,ff);
			}
			if (can[i][j+1]&amp;&amp;can[i+1][j])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=a[j]=2;
				renew(a,ff);
			}
		}
		else if (left==0&amp;&amp;up==1)
		{
			if (can[i+1][j])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=1,a[j]=0;
				if (j==m) youyi(a);
				renew(a,ff);
			}
			if (can[i][j+1])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=0,a[j]=2;
				renew(a,ff);
			}
		}
		else if (left==0&amp;&amp;up==2)
		{
			if (can[i+1][j])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=2,a[j]=0;
				if (j==m) youyi(a);
				renew(a,ff);
			}
			for (k=0;k&lt;=m;k++) a[k]=aa[k];
			a[j-1]=a[j]=0;
			if (j==m) youyi(a);
			renew(a,ff);
		}
		else if (left==1&amp;&amp;up==0)
		{
			if (can[i+1][j])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=2,a[j]=0;
				if (j==m) youyi(a);
				renew(a,ff);
			}
			if (can[i][j+1])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=0,a[j]=1;
				renew(a,ff);
			}
		}
		else if (left==1&amp;&amp;up==1)
		{
			for (k=0;k&lt;=m;k++) a[k]=aa[k];
			a[j-1]=a[j]=0;
			if (j==m) youyi(a);
			renew(a,ff);
		}
		else if (left==1&amp;&amp;up==2) continue;
		else if (left==2&amp;&amp;up==0)
		{
			if (can[i][j+1])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=0,a[j]=2;
				renew(a,ff);
			}
			for (k=0;k&lt;=m;k++) a[k]=aa[k];
			a[j-1]=a[j]=0;
			if (j==m) youyi(a);
			renew(a,ff);
		}
		else if (left==2&amp;&amp;up==1) continue;
		else if (left==2&amp;&amp;up==2) continue;
	}
}
void work2(int i,int j)
{
	static int a[15];
	for (it=C[now].begin();it!=C[now].end();it++)
	{
		int X=(*it).fi,ff=(*it).se;
		repack(a,X);
		int left=a[j-1],up=a[j];
		if (left==1||up==1) continue;
		a[j-1]=a[j]=0;
		if(j==m) youyi(a);
		renew(a,ff);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			char ch=getchar();
			while (ch!='*'&amp;&amp;ch!='_') ch=getchar();
			a[i][j]=b[i][j]=ch;
		}
	if (n&lt;m)
	{
		for (i=1;i&lt;=m;i++)
			for (j=1;j&lt;=n;j++) a[i][j]=b[j][i];
		int t=n;n=m;m=t;
	}
	//for (i=1;i&lt;=n;i++){for(j=1;j&lt;=m;j++)printf(&quot;%c&quot;,a[i][j]);ln;}ln;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
			if (a[i][j]=='_') can[i][j]=true;
	now=0;
	C[now].clear();
	C[now][0]=1;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			//printf(&quot;\n--------------- i=%d j=%d ---------------------------------\n&quot;,i,j);
			C[now^1].clear();
			if (can[i][j]) work1(i,j);
			else work2(i,j);
			now^=1;
		}
	int ans=0;
	for (it=C[now].begin();it!=C[now].end();it++)
		ans=(ans+(*it).se)%mo;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem2331</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;map&gt;
using namespace std;
#define mo 20110520
#define fi first
#define se second
#define ln printf(&quot;\n&quot;)
int n,m,now;
bool can[111][111];
char a[111][111],b[111][111];
struct HT
{
	#define MOD 9997
	int o[MOD+10],f[1000000],aa[1000000][2],tot;
	void clear()
	{
		tot=0;
		memset(o,0,sizeof(o));
	}
	void insert(int X,int ff)
	{
		int t=X%MOD;
		for (int p=o[t];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==X)
			{
				f[p]+=ff;if (f[p]&gt;mo) f[p]-=mo;
				return;
			}
		}
		tot++;aa[tot][1]=X;aa[tot][0]=o[t];
		o[t]=tot;f[tot]=ff;
	}
} C[2];
inline int pack(int *a)
{
	int res=0;
	for (int i=0;i&lt;=m;i++) res=res&lt;&lt;2|a[i];
	return res;
}
inline void repack(int *a,int X)
{
	for (int i=m;i&gt;=0;i--)
	{
		a[i]=X&amp;3;
		X&gt;&gt;=2;
	}
}
inline void youyi(int *a)
{
	for (int i=m;i&gt;0;i--) a[i]=a[i-1];
	a[0]=0;
}
void work1(int i,int j)
{
	static int aa[15],a[15];
	for (int p=1;p&lt;=C[now].tot;p++)
	{
		int X=C[now].aa[p][1],ff=C[now].f[p],k;
		repack(aa,X);
		//for(k=0;k&lt;=m;k++)printf(&quot;%d &quot;,aa[k]);printf(&quot;  ff=%d\n&quot;,ff);
		int left=aa[j-1],up=aa[j];
		if (left==0&amp;&amp;up==0)
		{
			if (can[i+1][j])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=1,a[j]=0;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),ff);
			}
			if (can[i][j+1])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=0,a[j]=1;
				C[now^1].insert(pack(a),ff);
			}
			if (can[i][j+1]&amp;&amp;can[i+1][j])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=a[j]=2;
				C[now^1].insert(pack(a),ff);
			}
		}
		else if (left==0&amp;&amp;up==1)
		{
			if (can[i+1][j])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=1,a[j]=0;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),ff);
			}
			if (can[i][j+1])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=0,a[j]=2;
				C[now^1].insert(pack(a),ff);
			}
		}
		else if (left==0&amp;&amp;up==2)
		{
			if (can[i+1][j])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=2,a[j]=0;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),ff);
			}
			for (k=0;k&lt;=m;k++) a[k]=aa[k];
			a[j-1]=a[j]=0;
			if (j==m) youyi(a);
			C[now^1].insert(pack(a),ff);
		}
		else if (left==1&amp;&amp;up==0)
		{
			if (can[i+1][j])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=2,a[j]=0;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),ff);
			}
			if (can[i][j+1])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=0,a[j]=1;
				C[now^1].insert(pack(a),ff);
			}
		}
		else if (left==1&amp;&amp;up==1)
		{
			for (k=0;k&lt;=m;k++) a[k]=aa[k];
			a[j-1]=a[j]=0;
			if (j==m) youyi(a);
			C[now^1].insert(pack(a),ff);
		}
		else if (left==1&amp;&amp;up==2) continue;
		else if (left==2&amp;&amp;up==0)
		{
			if (can[i][j+1])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=0,a[j]=2;
				C[now^1].insert(pack(a),ff);
			}
			for (k=0;k&lt;=m;k++) a[k]=aa[k];
			a[j-1]=a[j]=0;
			if (j==m) youyi(a);
			C[now^1].insert(pack(a),ff);
		}
		else if (left==2&amp;&amp;up==1) continue;
		else if (left==2&amp;&amp;up==2) continue;
	}
}
void work2(int i,int j)
{
	static int a[15];
	for (int p=1;p&lt;=C[now].tot;p++)
	{
		int X=C[now].aa[p][1],ff=C[now].f[p];
		repack(a,X);
		int left=a[j-1],up=a[j];
		if (left==1||up==1) continue;
		a[j-1]=a[j]=0;
		if(j==m) youyi(a);
		C[now^1].insert(pack(a),ff);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			char ch=getchar();
			while (ch!='*'&amp;&amp;ch!='_') ch=getchar();
			a[i][j]=b[i][j]=ch;
		}
	if (n&lt;m)
	{
		for (i=1;i&lt;=m;i++)
			for (j=1;j&lt;=n;j++) a[i][j]=b[j][i];
		int t=n;n=m;m=t;
	}
	//for (i=1;i&lt;=n;i++){for(j=1;j&lt;=m;j++)printf(&quot;%c&quot;,a[i][j]);ln;}ln;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
			if (a[i][j]=='_') can[i][j]=true;
	now=0;
	C[now].clear();
	C[now].insert(0,1);
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			//printf(&quot;\n--------------- i=%d j=%d ---------------------------------\n&quot;,i,j);
			C[now^1].clear();
			if (can[i][j]) work1(i,j);
			else work2(i,j);
			now^=1;
		}
	int ans=0;
	for (int p=1;p&lt;=C[now].tot;p++) ans=(ans+C[now].f[p])%mo;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem2331</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;map&gt;
using namespace std;
#define mo 20110520
#define fi first
#define se second
#define ln printf(&quot;\n&quot;)
int n,m,now;
bool can[111][111];
char a[111][111],b[111][111];
struct HT
{
	#define MOD 9997
	int o[MOD+10],f[1000000],aa[1000000][2],tot;
	void clear()
	{
		tot=0;
		memset(o,0,sizeof(o));
	}
	void insert(int X,int ff)
	{
		int t=X%MOD;
		for (int p=o[t];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==X)
			{
				f[p]+=ff;if (f[p]&gt;mo) f[p]-=mo;
				return;
			}
		}
		tot++;aa[tot][1]=X;aa[tot][0]=o[t];
		o[t]=tot;f[tot]=ff;
	}
} C[2];
inline int pack(int *a)
{
	int res=0;
	for (int i=0;i&lt;=m;i++) res=res&lt;&lt;2|a[i];
	return res;
}
inline void repack(int *a,int X)
{
	for (int i=m;i&gt;=0;i--)
	{
		a[i]=X&amp;3;
		X&gt;&gt;=2;
	}
}
inline void youyi(int *a)
{
	for (int i=m;i&gt;0;i--) a[i]=a[i-1];
	a[0]=0;
}
void work1(int i,int j)
{
	static int aa[15],a[15];
	for (int p=1;p&lt;=C[now].tot;p++)
	{
		int X=C[now].aa[p][1],ff=C[now].f[p],k;
		repack(aa,X);
		//for(k=0;k&lt;=m;k++)printf(&quot;%d &quot;,aa[k]);printf(&quot;  ff=%d\n&quot;,ff);
		int left=aa[j-1],up=aa[j];
		if (left==0&amp;&amp;up==0)
		{
			if (can[i+1][j])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=1,a[j]=0;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),ff);
			}
			if (can[i][j+1])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=0,a[j]=1;
				C[now^1].insert(pack(a),ff);
			}
			if (can[i][j+1]&amp;&amp;can[i+1][j])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=a[j]=2;
				C[now^1].insert(pack(a),ff);
			}
		}
		else if (left==0&amp;&amp;up==1)
		{
			if (can[i+1][j])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=1,a[j]=0;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),ff);
			}
			if (can[i][j+1])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=0,a[j]=2;
				C[now^1].insert(pack(a),ff);
			}
		}
		else if (left==0&amp;&amp;up==2)
		{
			if (can[i+1][j])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=2,a[j]=0;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),ff);
			}
			for (k=0;k&lt;=m;k++) a[k]=aa[k];
			a[j-1]=a[j]=0;
			if (j==m) youyi(a);
			C[now^1].insert(pack(a),ff);
		}
		else if (left==1&amp;&amp;up==0)
		{
			if (can[i+1][j])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=2,a[j]=0;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),ff);
			}
			if (can[i][j+1])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=0,a[j]=1;
				C[now^1].insert(pack(a),ff);
			}
		}
		else if (left==1&amp;&amp;up==1)
		{
			for (k=0;k&lt;=m;k++) a[k]=aa[k];
			a[j-1]=a[j]=0;
			if (j==m) youyi(a);
			C[now^1].insert(pack(a),ff);
		}
		else if (left==1&amp;&amp;up==2) continue;
		else if (left==2&amp;&amp;up==0)
		{
			if (can[i][j+1])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=0,a[j]=2;
				C[now^1].insert(pack(a),ff);
			}
			for (k=0;k&lt;=m;k++) a[k]=aa[k];
			a[j-1]=a[j]=0;
			if (j==m) youyi(a);
			C[now^1].insert(pack(a),ff);
		}
		else if (left==2&amp;&amp;up==1) continue;
		else if (left==2&amp;&amp;up==2) continue;
	}
}
void work2(int i,int j)
{
	static int a[15];
	for (int p=1;p&lt;=C[now].tot;p++)
	{
		int X=C[now].aa[p][1],ff=C[now].f[p];
		repack(a,X);
		int left=a[j-1],up=a[j];
		if (left==1||up==1) continue;
		a[j-1]=a[j]=0;
		if(j==m) youyi(a);
		C[now^1].insert(pack(a),ff);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			char ch=getchar();
			while (ch!='*'&amp;&amp;ch!='_') ch=getchar();
			a[i][j]=b[i][j]=ch;
		}
	if (n&lt;m)
	{
		for (i=1;i&lt;=m;i++)
			for (j=1;j&lt;=n;j++) a[i][j]=b[j][i];
		int t=n;n=m;m=t;
	}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
			if (a[i][j]=='_') can[i][j]=true;
	now=0;
	C[now].clear();
	C[now].insert(0,1);
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			C[now^1].clear();
			if (can[i][j]) work1(i,j);
			else work2(i,j);
			now^=1;
		}
	int ans=0;
	for (int p=1;p&lt;=C[now].tot;p++) ans=(ans+C[now].f[p])%mo;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem2331</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;map&gt;
using namespace std;
#define mo 20110520
#define fi first
#define se second
#define ln printf(&quot;\n&quot;)
int n,m,now;
bool can[111][111];
char a[111][111],b[111][111];
struct HT
{
	#define MOD 99997
	int o[MOD+10],f[1000000],aa[1000000][2],tot;
	void clear()
	{
		tot=0;
		memset(o,0,sizeof(o));
	}
	void insert(int X,int ff)
	{
		int t=X%MOD;
		for (int p=o[t];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==X)
			{
				f[p]+=ff;if (f[p]&gt;mo) f[p]-=mo;
				return;
			}
		}
		tot++;aa[tot][1]=X;aa[tot][0]=o[t];
		o[t]=tot;f[tot]=ff;
	}
} C[2];
inline int pack(int *a)
{
	int res=0;
	for (int i=0;i&lt;=m;i++) res=res&lt;&lt;2|a[i];
	return res;
}
inline void repack(int *a,int X)
{
	for (int i=m;i&gt;=0;i--)
	{
		a[i]=X&amp;3;
		X&gt;&gt;=2;
	}
}
inline void youyi(int *a)
{
	for (int i=m;i&gt;0;i--) a[i]=a[i-1];
	a[0]=0;
}
void work1(int i,int j)
{
	static int aa[15],a[15];
	for (int p=1;p&lt;=C[now].tot;p++)
	{
		int X=C[now].aa[p][1],ff=C[now].f[p],k;
		repack(aa,X);
		//for(k=0;k&lt;=m;k++)printf(&quot;%d &quot;,aa[k]);printf(&quot;  ff=%d\n&quot;,ff);
		int left=aa[j-1],up=aa[j];
		if (left==0&amp;&amp;up==0)
		{
			if (can[i+1][j])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=1,a[j]=0;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),ff);
			}
			if (can[i][j+1])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=0,a[j]=1;
				C[now^1].insert(pack(a),ff);
			}
			if (can[i][j+1]&amp;&amp;can[i+1][j])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=a[j]=2;
				C[now^1].insert(pack(a),ff);
			}
		}
		else if (left==0&amp;&amp;up==1)
		{
			if (can[i+1][j])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=1,a[j]=0;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),ff);
			}
			if (can[i][j+1])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=0,a[j]=2;
				C[now^1].insert(pack(a),ff);
			}
		}
		else if (left==0&amp;&amp;up==2)
		{
			if (can[i+1][j])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=2,a[j]=0;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),ff);
			}
			for (k=0;k&lt;=m;k++) a[k]=aa[k];
			a[j-1]=a[j]=0;
			if (j==m) youyi(a);
			C[now^1].insert(pack(a),ff);
		}
		else if (left==1&amp;&amp;up==0)
		{
			if (can[i+1][j])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=2,a[j]=0;
				if (j==m) youyi(a);
				C[now^1].insert(pack(a),ff);
			}
			if (can[i][j+1])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=0,a[j]=1;
				C[now^1].insert(pack(a),ff);
			}
		}
		else if (left==1&amp;&amp;up==1)
		{
			for (k=0;k&lt;=m;k++) a[k]=aa[k];
			a[j-1]=a[j]=0;
			if (j==m) youyi(a);
			C[now^1].insert(pack(a),ff);
		}
		else if (left==1&amp;&amp;up==2) continue;
		else if (left==2&amp;&amp;up==0)
		{
			if (can[i][j+1])
			{
				for (k=0;k&lt;=m;k++) a[k]=aa[k];
				a[j-1]=0,a[j]=2;
				C[now^1].insert(pack(a),ff);
			}
			for (k=0;k&lt;=m;k++) a[k]=aa[k];
			a[j-1]=a[j]=0;
			if (j==m) youyi(a);
			C[now^1].insert(pack(a),ff);
		}
		else if (left==2&amp;&amp;up==1) continue;
		else if (left==2&amp;&amp;up==2) continue;
	}
}
void work2(int i,int j)
{
	static int a[15];
	for (int p=1;p&lt;=C[now].tot;p++)
	{
		int X=C[now].aa[p][1],ff=C[now].f[p];
		repack(a,X);
		int left=a[j-1],up=a[j];
		if (left==1||up==1) continue;
		a[j-1]=a[j]=0;
		if(j==m) youyi(a);
		C[now^1].insert(pack(a),ff);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			char ch=getchar();
			while (ch!='*'&amp;&amp;ch!='_') ch=getchar();
			a[i][j]=b[i][j]=ch;
		}
	if (n&lt;m)
	{
		for (i=1;i&lt;=m;i++)
			for (j=1;j&lt;=n;j++) a[i][j]=b[j][i];
		int t=n;n=m;m=t;
	}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
			if (a[i][j]=='_') can[i][j]=true;
	now=0;
	C[now].clear();
	C[now].insert(0,1);
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			C[now^1].clear();
			if (can[i][j]) work1(i,j);
			else work2(i,j);
			now^=1;
		}
	int ans=0;
	for (int p=1;p&lt;=C[now].tot;p++) ans=(ans+C[now].f[p])%mo;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem2333</h2><pre>#include&lt;cstdio&gt;
#include&lt;set&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=301111;
int lc[NN],rc[NN],fa[NN],tag[NN],dist[NN],w[NN],b[NN];
int n,m;
multiset&lt;int&gt; S;
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
void pushdown(int v)
{
	if (!tag[v]) return;
	int x=lc[v],y=rc[v];
	tag[x]+=tag[v],w[x]+=tag[v];
	tag[y]+=tag[v],w[y]+=tag[v];
	tag[v]=0;
}
int merge(int x,int y)
{
	if (!x||!y) return x+y;
	if (w[x]&lt;w[y]) {int t=x;x=y;y=t;}
	pushdown(x);
	rc[x]=merge(rc[x],y);
	if (rc[x]) fa[rc[x]]=x;
	if (dist[lc[x]]&lt;dist[rc[x]])
		{int t=lc[x];lc[x]=rc[x];rc[x]=t;}
	dist[x]=dist[rc[x]]+1;
	return x;
}
int getroot(int x)
{
	for (;fa[x];x=fa[x]);
	return x;
}
void pushroot(int x)
{
	b[0]=0;
	for (;x;x=fa[x]) b[++b[0]]=x;
	for (;b[0];b[0]--) pushdown(b[b[0]]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y,now=0;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;w[i]);
		S.insert(w[i]);
		dist[i]=1;
	}
	scanf(&quot;%d&quot;,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		//printf(&quot;\n-------------------------------------------------------------------------\n&quot;);
		char ch=getchar();
		while (ch!='U'&amp;&amp;ch!='A'&amp;&amp;ch!='F') ch=getchar();
		//printf(&quot;ch=%c\n&quot;,ch);
		if (ch=='U')
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			//printf(&quot;%d %d\n&quot;,x,y);printf(&quot;getroot1=%d\n&quot;,getroot(1));
			int t1=getroot(x),t2=getroot(y);
			//printf(&quot;%d %d\n&quot;,t1,t2);
			if (t1!=t2)
			{
				int t=merge(t1,t2);
				if (t==t1) S.erase(S.find(w[t2]));
				else S.erase(S.find(w[t1]));
			}
		}
		else if (ch=='A')
		{
			ch=getchar();
			if (ch=='1')
			{
				scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
				pushroot(x);
				int t=getroot(x);
				S.erase(S.find(w[t]));
				int t1=lc[x],t2=rc[x];
				int t3=merge(t1,t2);
				fa[t3]=fa[x];
				if (x==lc[fa[x]]) lc[fa[x]]=t3;
				else rc[fa[x]]=t3;
				fa[x]=lc[x]=rc[x]=0;
				w[x]+=y;
				if (t==x) t=merge(t3,x);
				else t=merge(t,x);
				S.insert(w[t]);
			}
			else if (ch=='2')
			{
				scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
				int t=getroot(x);
				S.erase(S.find(w[t]));
				tag[t]+=y,w[t]+=y;
				S.insert(w[t]);
			}
			else scanf(&quot;%d&quot;,&amp;x),now+=x;
		}
		else
		{
			ch=getchar();
			if (ch=='1')
			{
				scanf(&quot;%d&quot;,&amp;x);
				pushroot(x);
				//printf(&quot;w[x]=%d\n&quot;,w[x]);printf(&quot;%d %d\n&quot;,x,w[3]);
				printf(&quot;%d\n&quot;,w[x]+now);
			}
			else if (ch=='2')
			{
				scanf(&quot;%d&quot;,&amp;x);
				x=getroot(x);
				printf(&quot;%d\n&quot;,w[x]+now);
			}
			else
			{
				multiset&lt;int&gt;::iterator it;
				it=S.end();
				printf(&quot;%d\n&quot;,*(--it)+now);
			}
		}
		//printf(&quot;fa &quot;),out(fa,1,n);printf(&quot;lc &quot;);out(lc,1,n);printf(&quot;rc &quot;);out(rc,1,n);printf(&quot;w &quot;);out(w,1,n);printf(&quot;tag &quot;);out(tag,1,n);
	}
	return 0;
}<pre><h2>Problem2336</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;
#define maa(a,b) ((a)&gt;(b)?(a):(b))
#define ran(x) (rand()%(x)+1)
#define inf 999999999
#define ln printf(&quot;\n&quot;)
int A[2000],B[2000],C[2000],a[2000],b[2000],c[2000],d[2000];
int n,numa,numb,numc,ans,suma,sumb;
struct job
{
	int a,b;
} q[2000];
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
int calc(int *a,int n1,int *b,int n2)
{
	int tmp=0,t1=sumb,t2=suma,i;
	for (i=1;i&lt;=n1;i++)
	{
		tmp+=q[a[i]].a;
		t1=maa(t1,tmp)+q[a[i]].b;
	}
	tmp=0;
	for (i=1;i&lt;=n2;i++)
	{
		tmp+=q[b[i]].b;
		t2=maa(t2,tmp)+q[b[i]].a;
	}
	return maa(t1,t2);
}
bool cmp1(int i,int j) {return q[i].b==q[j].b?q[i].a&lt;q[j].a:q[i].b&gt;q[j].b;}
bool cmp2(int i,int j) {return q[i].a==q[j].a?q[i].b&lt;q[j].b:q[i].a&gt;q[j].a;}
void work()
{
	int i;
	for (i=1;i&lt;=numa;i++) a[i]=A[i];
	sort(a+1,a+numa+1,cmp1);
	for (i=1;i&lt;=numb;i++) b[i]=B[i];
	sort(b+1,b+numb+1,cmp2);
	int res=calc(a,numa,b,numb);
	for (int ttt=2000;ttt;ttt--)
	{
		for (i=1;i&lt;=numa;i++) c[i]=a[i];
		for (i=1;i&lt;=numb;i++) d[i]=b[i];
		if (numa) swap(c[ran(numa)],c[ran(numa)]);
		if (numb) swap(d[ran(numb)],d[ran(numb)]);
		int tmp=calc(c,numa,d,numb);
		if (tmp&lt;res)
		{
			res=tmp;
			for (i=1;i&lt;=numa;i++) a[i]=c[i];
			for (i=1;i&lt;=numb;i++) b[i]=d[i];
		}
	}
	if (ans&gt;res) ans=res;
}
void dfs(int t)
{
	if (t==numc+1)
	{
		work();
		return;
	}
	A[++numa]=C[t],suma+=q[C[t]].a;
	dfs(t+1);
	numa--,suma-=q[C[t]].a;
	B[++numb]=C[t],sumb+=q[C[t]].b;
	dfs(t+1);
	numb--,sumb-=q[C[t]].b;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	srand(19980723);
	scanf(&quot;%d&quot;,&amp;n);
	for (int i=1;i&lt;=n;i++)
	{
		int kind;
		scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;q[i].a,&amp;q[i].b);
		if (kind==1) A[++numa]=i,suma+=q[i].a;
		else if (kind==2) B[++numb]=i,sumb+=q[i].b;
		else C[++numc]=i;
	}
	ans=inf;
	dfs(1);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2336</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;
#define maa(a,b) ((a)&gt;(b)?(a):(b))
#define ran(x) (rand()%(x)+1)
#define inf 999999999
#define ln printf(&quot;\n&quot;)
int A[2000],B[2000],C[2000],a[2000],b[2000],c[2000],d[2000];
int n,numa,numb,numc,ans,suma,sumb;
struct job
{
	int a,b;
} q[2000];
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
int calc(int *a,int n1,int *b,int n2)
{
	int tmp=0,t1=sumb,t2=suma,i;
	for (i=1;i&lt;=n1;i++)
	{
		tmp+=q[a[i]].a;
		t1=maa(t1,tmp)+q[a[i]].b;
	}
	tmp=0;
	for (i=1;i&lt;=n2;i++)
	{
		tmp+=q[b[i]].b;
		t2=maa(t2,tmp)+q[b[i]].a;
	}
	return maa(t1,t2);
}
bool cmp1(int i,int j) {return q[i].b==q[j].b?q[i].a&lt;q[j].a:q[i].b&gt;q[j].b;}
bool cmp2(int i,int j) {return q[i].a==q[j].a?q[i].b&lt;q[j].b:q[i].a&gt;q[j].a;}
void work()
{
	int i;
	for (i=1;i&lt;=numa;i++) a[i]=A[i];
	sort(a+1,a+numa+1,cmp1);
	for (i=1;i&lt;=numb;i++) b[i]=B[i];
	sort(b+1,b+numb+1,cmp2);
	int res=calc(a,numa,b,numb);
	for (int ttt=1000;ttt;ttt--)
	{
		for (i=1;i&lt;=numa;i++) c[i]=a[i];
		for (i=1;i&lt;=numb;i++) d[i]=b[i];
		if (numa) swap(c[ran(numa)],c[ran(numa)]);
		if (numb) swap(d[ran(numb)],d[ran(numb)]);
		int tmp=calc(c,numa,d,numb);
		if (tmp&lt;res)
		{
			res=tmp;
			for (i=1;i&lt;=numa;i++) a[i]=c[i];
			for (i=1;i&lt;=numb;i++) b[i]=d[i];
		}
	}
	if (ans&gt;res) ans=res;
}
void dfs(int t)
{
	if (t==numc+1)
	{
		work();
		return;
	}
	A[++numa]=C[t],suma+=q[C[t]].a;
	dfs(t+1);
	numa--,suma-=q[C[t]].a;
	B[++numb]=C[t],sumb+=q[C[t]].b;
	dfs(t+1);
	numb--,sumb-=q[C[t]].b;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	srand(19980723);
	scanf(&quot;%d&quot;,&amp;n);
	for (int i=1;i&lt;=n;i++)
	{
		int kind;
		scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;q[i].a,&amp;q[i].b);
		if (kind==1) A[++numa]=i,suma+=q[i].a;
		else if (kind==2) B[++numb]=i,sumb+=q[i].b;
		else C[++numc]=i;
	}
	ans=inf;
	dfs(1);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2336</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;
#define maa(a,b) ((a)&gt;(b)?(a):(b))
#define ran(x) (rand()%(x)+1)
#define inf 999999999
#define ln printf(&quot;\n&quot;)
int A[2000],B[2000],C[2000],a[2000],b[2000],c[2000],d[2000];
int n,numa,numb,numc,ans,suma,sumb;
struct job
{
	int a,b;
} q[2000];
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
int calc(int *a,int n1,int *b,int n2)
{
	int tmp=0,t1=sumb,t2=suma,i;
	for (i=1;i&lt;=n1;i++)
	{
		tmp+=q[a[i]].a;
		t1=maa(t1,tmp)+q[a[i]].b;
	}
	tmp=0;
	for (i=1;i&lt;=n2;i++)
	{
		tmp+=q[b[i]].b;
		t2=maa(t2,tmp)+q[b[i]].a;
	}
	return maa(t1,t2);
}
bool cmp1(int i,int j) {return q[i].b==q[j].b?q[i].a&lt;q[j].a:q[i].b&gt;q[j].b;}
bool cmp2(int i,int j) {return q[i].a==q[j].a?q[i].b&lt;q[j].b:q[i].a&gt;q[j].a;}
void work()
{
	int i;
	for (i=1;i&lt;=numa;i++) a[i]=A[i];
	//sort(a+1,a+numa+1,cmp1);
	for (i=1;i&lt;=numb;i++) b[i]=B[i];
	//sort(b+1,b+numb+1,cmp2);
	int res=calc(a,numa,b,numb);
	for (int ttt=1000;ttt;ttt--)
	{
		for (i=1;i&lt;=numa;i++) c[i]=a[i];
		for (i=1;i&lt;=numb;i++) d[i]=b[i];
		if (numa) swap(c[ran(numa)],c[ran(numa)]);
		if (numb) swap(d[ran(numb)],d[ran(numb)]);
		int tmp=calc(c,numa,d,numb);
		if (tmp&lt;res)
		{
			res=tmp;
			for (i=1;i&lt;=numa;i++) a[i]=c[i];
			for (i=1;i&lt;=numb;i++) b[i]=d[i];
		}
	}
	if (ans&gt;res) ans=res;
}
void dfs(int t)
{
	if (t==numc+1)
	{
		work();
		return;
	}
	A[++numa]=C[t],suma+=q[C[t]].a;
	dfs(t+1);
	numa--,suma-=q[C[t]].a;
	B[++numb]=C[t],sumb+=q[C[t]].b;
	dfs(t+1);
	numb--,sumb-=q[C[t]].b;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	srand(19980723);
	scanf(&quot;%d&quot;,&amp;n);
	for (int i=1;i&lt;=n;i++)
	{
		int kind;
		scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;q[i].a,&amp;q[i].b);
		if (kind==1) A[++numa]=i,suma+=q[i].a;
		else if (kind==2) B[++numb]=i,sumb+=q[i].b;
		else C[++numc]=i;
	}
	ans=inf;
	dfs(1);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2336</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;
#define maa(a,b) ((a)&gt;(b)?(a):(b))
#define ran(x) (rand()%(x)+1)
#define inf 999999999
#define ln printf(&quot;\n&quot;)
int A[2000],B[2000],C[2000],a[2000],b[2000],c[2000],d[2000];
int n,numa,numb,numc,ans,suma,sumb;
struct job
{
	int a,b;
} q[2000];
int calc(int *a,int n1,int *b,int n2)
{
	int tmp=0,t1=sumb,t2=suma,i;
	for (i=1;i&lt;=n1;i++)
	{
		tmp+=q[a[i]].a;
		t1=maa(t1,tmp)+q[a[i]].b;
	}
	tmp=0;
	for (i=1;i&lt;=n2;i++)
	{
		tmp+=q[b[i]].b;
		t2=maa(t2,tmp)+q[b[i]].a;
	}
	return maa(t1,t2);
}
void work()
{
	int i;
	for (i=1;i&lt;=numa;i++) a[i]=A[i];
	for (i=1;i&lt;=numb;i++) b[i]=B[i];
	int res=calc(a,numa,b,numb);
	for (int ttt=1000;ttt;ttt--)
	{
		for (i=1;i&lt;=numa;i++) c[i]=a[i];
		for (i=1;i&lt;=numb;i++) d[i]=b[i];
		if (numa) swap(c[ran(numa)],c[ran(numa)]);
		if (numb) swap(d[ran(numb)],d[ran(numb)]);
		int tmp=calc(c,numa,d,numb);
		if (tmp&lt;res)
		{
			res=tmp;
			for (i=1;i&lt;=numa;i++) a[i]=c[i];
			for (i=1;i&lt;=numb;i++) b[i]=d[i];
		}
	}
	if (ans&gt;res) ans=res;
}
void dfs(int t)
{
	if (t==numc+1)
	{
		work();
		return;
	}
	A[++numa]=C[t],suma+=q[C[t]].a;
	dfs(t+1);
	numa--,suma-=q[C[t]].a;
	B[++numb]=C[t],sumb+=q[C[t]].b;
	dfs(t+1);
	numb--,sumb-=q[C[t]].b;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	srand(19980723);
	scanf(&quot;%d&quot;,&amp;n);
	for (int i=1;i&lt;=n;i++)
	{
		int kind;
		scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;q[i].a,&amp;q[i].b);
		if (kind==1) A[++numa]=i,suma+=q[i].a;
		else if (kind==2) B[++numb]=i,sumb+=q[i].b;
		else C[++numc]=i;
	}
	ans=inf;
	dfs(1);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2336</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;
#define maa(a,b) ((a)&gt;(b)?(a):(b))
#define ran(x) (rand()%(x)+1)
#define inf 999999999
#define ln printf(&quot;\n&quot;)
int A[2000],B[2000],C[2000],a[2000],b[2000],c[2000],d[2000];
int n,numa,numb,numc,ans,suma,sumb;
struct job
{
	int a,b;
} q[2000];
int calc(int *a,int n1,int *b,int n2)
{
	int tmp=0,t1=sumb,t2=suma,i;
	for (i=1;i&lt;=n1;i++)
	{
		tmp+=q[a[i]].a;
		t1=maa(t1,tmp)+q[a[i]].b;
	}
	tmp=0;
	for (i=1;i&lt;=n2;i++)
	{
		tmp+=q[b[i]].b;
		t2=maa(t2,tmp)+q[b[i]].a;
	}
	return maa(t1,t2);
}
void work()
{
	int i;
	for (i=1;i&lt;=numa;i++) a[i]=A[i];
	for (i=1;i&lt;=numb;i++) b[i]=B[i];
	int res=calc(a,numa,b,numb);
	for (int ttt=1000;ttt;ttt--)
	{
		for (i=1;i&lt;=numa;i++) c[i]=a[i];
		for (i=1;i&lt;=numb;i++) d[i]=b[i];
		if (numa) swap(c[ran(numa)],c[ran(numa)]);
		if (numb) swap(d[ran(numb)],d[ran(numb)]);
		int tmp=calc(c,numa,d,numb);
		if (tmp&lt;res||ran(100000)&lt;=100)
		{
			res=tmp;
			for (i=1;i&lt;=numa;i++) a[i]=c[i];
			for (i=1;i&lt;=numb;i++) b[i]=d[i];
		}
	}
	if (ans&gt;res) ans=res;
}
void dfs(int t)
{
	if (t==numc+1)
	{
		work();
		return;
	}
	A[++numa]=C[t],suma+=q[C[t]].a;
	dfs(t+1);
	numa--,suma-=q[C[t]].a;
	B[++numb]=C[t],sumb+=q[C[t]].b;
	dfs(t+1);
	numb--,sumb-=q[C[t]].b;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	srand(19980723);
	scanf(&quot;%d&quot;,&amp;n);
	for (int i=1;i&lt;=n;i++)
	{
		int kind;
		scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;q[i].a,&amp;q[i].b);
		if (kind==1) A[++numa]=i,suma+=q[i].a;
		else if (kind==2) B[++numb]=i,sumb+=q[i].b;
		else C[++numc]=i;
	}
	ans=inf;
	dfs(1);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2337</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define DD double
int aa[1000000][3],o[10000],du[10000];
int n,m,tot,i,x,y,z,maxm;
DD a[1000][1000],f[10000],ans;
DD fabs(DD x) {return x&gt;0?x:-x;}
int max(int a,int b) {return a&gt;b?a:b;}
void fswap(DD &amp;a,DD &amp;b) {DD t=a;a=b;b=t;}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
DD calc()
{
	int i,j,k,mj;
	DD tmp;
	memset(a,0,sizeof(a));
	for (i=1;i&lt;=n;i++) a[i][i]=1;
	for (i=1;i&lt;n;i++)
		for (int p=o[i];p;p=aa[p][0])
		{
			j=aa[p][1];
			if ((aa[p][2]&amp;1)==0) a[i][j]-=(1.0/du[i]);
			else
			{
				a[i][j]+=(1.0/du[i]);
				a[i][n+1]+=(1.0/du[i]);
			}
		}
	for (i=1;i&lt;=n-1;i++)
	{
		tmp=fabs(a[i][i]),mj=i;
		for (j=i+1;j&lt;=n;j++)
			if (fabs(a[j][i])&gt;tmp) tmp=fabs(a[j][i]),mj=j;
		for (j=i;j&lt;=n+1;j++) fswap(a[i][j],a[mj][j]);
		for (j=i+1;j&lt;=n;j++)
		{
			tmp=a[j][i]/a[i][i];
			for (k=i;k&lt;=n+1;k++) a[j][k]=a[i][k]*tmp-a[j][k];
		}
	}
	f[n]=0;
	for (i=n-1;i;i--)
	{
		tmp=0;
		for (j=i+1;j&lt;=n;j++) tmp+=a[i][j]*f[j];
		f[i]=(a[i][n+1]-tmp)/a[i][i];
	}
	for (i=1;i&lt;=n;i++)
		for (int p=o[i];p;p=aa[p][0]) aa[p][2]&gt;&gt;=1;
	return f[1];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		if (x==y)
		{
			du[x]++;
			addedge(x,y,z);
		}
		else
		{
			du[x]++,du[y]++;
			addedge(x,y,z);
			addedge(y,x,z);
		}
		maxm=max(maxm,z);
	}
	for (int tmp=1;maxm&gt;0;tmp&lt;&lt;=1,maxm&gt;&gt;=1) ans+=tmp*calc();
	printf(&quot;%.3f\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2338</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define DD long double
const DD eps=1e-9;
int n,cnt;
struct point
{
	int x,y;
	point(int a=0,int b=0) {x=a,y=b;}
	friend bool operator &lt;(point a,point b) {return a.x==b.x?a.y&lt;b.y:a.x&lt;b.x;}
	friend bool operator ==(point a,point b) {return a.x==b.x&amp;&amp;a.y==b.y;}
} a[1511];
struct seg
{
	point a,b,mid;
	DD len;
	friend bool operator &lt;(seg a,seg b) {return a.mid==b.mid?a.len&lt;b.len:a.mid&lt;b.mid;}
} e[2251111];
DD dist(point a,point b)
{
	return sqrt((DD)(a.x-b.x)*(a.x-b.x)+(DD)(a.y-b.y)*(a.y-b.y));
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;a[i].x,&amp;a[i].y);
		a[i].x&lt;&lt;=1,a[i].y&lt;&lt;=1;
	}
	for (i=1;i&lt;n;i++)
		for (j=i+1;j&lt;=n;j++)
		{
			cnt++;
			e[cnt].a=a[i],e[cnt].b=a[j];
			e[cnt].mid=point((a[i].x+a[j].x)&gt;&gt;1,(a[i].y+a[j].y)&gt;&gt;1);
			e[cnt].len=dist(a[i],a[j]);
		}
	sort(e+1,e+cnt+1);
	DD ans=0;
	int k=1;
	while (k&lt;=cnt)
	{
		int t=k;
		while (e[t].mid==e[k].mid&amp;&amp;fabs(e[t].len-e[k].len)&lt;eps&amp;&amp;t&lt;=cnt) t++;
		t--;
		if (k==t) {k=t+1;continue;}
		for (i=k;i&lt;t;i++)
			for (j=i+1;j&lt;=t;j++)
			{
				DD d1=dist(e[i].a,e[j].a);
				DD d2=dist(e[i].a,e[j].b);
				DD area=d1*d2;
				if (area&gt;ans) ans=area;
			}
		k=t+1;
	}
	printf(&quot;%.0f\n&quot;,(double)ans/4);
	return 0;
}
<pre><h2>Problem2339</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define mo 100000007
#define LL long long
LL f[1001111],g[1001111];
int n,m;
LL ksm(LL a,int b)
{
	LL res=1;
	for (a%=mo;b;b&gt;&gt;=1,a=a*a%mo) if (b&amp;1) res=res*a%mo;
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	f[1]=0,f[2]=0;
	LL tot=ksm(2,n)-1;
	g[1]=tot,g[2]=g[1]*(tot-1)%mo;
	LL tt=2;
	for (int i=3;i&lt;=m;i++)
	{
		tt=tt*i%mo;
		f[i]=(g[i-1]-f[i-1]-f[i-2]*(i-1)%mo*(tot-(i-2)))%mo;
		g[i]=g[i-1]*(tot-(i-1))%mo;
	}
	LL ans=f[m]*ksm(tt,mo-2)%mo;
	if (ans&lt;0) ans+=mo;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2342</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=1001111;
int a[NN],b[NN],p[NN];
int n;
set&lt;int&gt; S;
bool cmp(int x,int y) {return x-p[x]&lt;y-p[y];}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d\n&quot;,&amp;n);
	int i;
	for (i=1;i&lt;=n;i++) a[i]=getchar();
	b[0]=0;b[1]=256;
	int num=1;
	for (i=1;i&lt;=n;i++)
		b[++num]=a[i],b[++num]=256;
	b[++num]=257;
	//printf(&quot;num=%d\n&quot;,num);
	int id=0,right=0;
	for (i=1;i&lt;num;i++)
	{
		if (right&gt;i) p[i]=min(p[id*2-i],right-i);
		else p[i]=1;
		while (b[i+p[i]]==b[i-p[i]]) p[i]++;
		if (i+p[i]&gt;right) right=i+p[i],id=i;
		//printf(&quot;%d &quot;,p[i]);
	}
	//ln;
	for (i=1;i&lt;n;i++) p[i]=(p[i*2+1]-1)/2;//,printf(&quot;%d &quot;,p[i]);ln;
	for (i=1;i&lt;=n;i++) b[i]=i;
	sort(b+1,b+n+1,cmp);
	//for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,b[i]);ln;
	int now=1;
	int ans=0;
	for (i=1;i&lt;=n;i++)
	{
		for (;now&lt;=n&amp;&amp;b[now]-p[b[now]]&lt;=i;now++) S.insert(b[now]);
		set&lt;int&gt;::iterator it=S.upper_bound(i+p[i]/2);
		if (it!=S.begin()) ans=max(ans,4*(*(--it)-i));
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem2393</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
int cnt;
LL b[5111],L,R,ans;
bool flag[5111];
void dfs0(LL x)
{
	if (x&gt;R) return;
	b[++cnt]=x;
	dfs0(x*10+2);
	dfs0(x*10+9);
}
LL gcd(LL a,LL b) {return !b?a:gcd(b,a%b);}
void dfs(int t,LL now,int num)
{
	if (t==cnt+1)
	{
		if (num==0) return;
		if (num&amp;1) ans+=R/now-(L-1)/now;
		else ans-=R/now-(L-1)/now;
		return;
	}
	dfs(t+1,now,num);
	now=now*b[t]/gcd(now,b[t]);
	if (now&lt;=R) dfs(t+1,now,num+1);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld%lld&quot;,&amp;L,&amp;R);
	dfs0(2),dfs0(9);
	int i,j;
	for (i=1;i&lt;=cnt;i++)
		for (j=1;j&lt;=cnt;j++) if (i!=j)
			if (b[i]%b[j]==0) flag[i]=true;
	int t=0;
	for (i=1;i&lt;=cnt;i++)
		if (!flag[i]) b[++t]=b[i];
	cnt=t;
	//printf(&quot;b &quot;);for(i=1;i&lt;=cnt;i++)printf(&quot;%lld &quot;,b[i]);ln;
	dfs(1,1,0);
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem2395</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define LL long long
#define NN 210
#define MM 11000
#define inf 9999999999999999ll
int fa[NN],a[MM],b[MM],xx[MM],yy[MM];
int n,m;
LL ans;
struct point
{
	int x,y;
	point(int a=0,int b=0) {x=a;y=b;}
	friend point operator - (point a,point b) {a.x-=b.x,a.y-=b.y;return a;}
} O;
struct edge
{
	int w,id;
	friend bool operator &lt; (edge a,edge b) {return a.w&lt;b.w;}
} e[MM];
LL det(point a,point b) {return (LL)a.x*b.y-(LL)b.x*a.y;}
int getfa(int x) {return fa[x]==x?x:fa[x]=getfa(fa[x]);}
point kruscal()
{
	//printf(&quot;\n------------------------------------------------\n&quot;);
	int i,t1,t2,sumx=0,sumy=0;
	for (i=1;i&lt;=n;i++) fa[i]=i;
	sort(e+1,e+m+1);
	//for (i=1;i&lt;=m;i++) printf(&quot;%d %d\n&quot;,a[e[i].id],b[e[i].id]);
	for (i=1;i&lt;=m;i++)
	{
		t1=getfa(a[e[i].id]),t2=getfa(b[e[i].id]);
		if (t1==t2) continue;
		fa[t1]=t2;
		sumx+=xx[e[i].id],sumy+=yy[e[i].id];
		//printf(&quot;%d &quot;,e[i].id);
	}
	LL tmp=(LL)sumx*(LL)sumy;
	if (tmp&lt;ans||(tmp==ans&amp;&amp;sumx&lt;O.x))
	{
		ans=tmp;
		O.x=sumx;
		O.y=sumy;
	}
	//printf(&quot;\n&quot;);printf(&quot;%I64d\n&quot;,ans);
	return point(sumx,sumy);
}
void work(point minx,point miny)
{
	int t1=miny.x-minx.x,t2=minx.y-miny.y;
	for (int i=1;i&lt;=m;i++) e[i].id=i,e[i].w=t1*yy[i]+t2*xx[i];
	point P=kruscal();
	if (det(minx-miny,P-miny)&lt;=0) return;
	work(minx,P);
	work(P,miny);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;a[i],&amp;b[i],&amp;xx[i],&amp;yy[i]);
		a[i]++,b[i]++;
	}
	ans=inf;
	O.x=O.y=inf;
	for (i=1;i&lt;=m;i++) e[i].id=i,e[i].w=xx[i];
	point minx=kruscal();
	//printf(&quot;%d %d\n&quot;,minx.x,minx.y);
	for (i=1;i&lt;=m;i++) e[i].id=i,e[i].w=yy[i];
	point miny=kruscal();
	//printf(&quot;%d %d\n&quot;,miny.x,miny.y);
	work(minx,miny);
	//printf(&quot;\n\n\n\n&quot;);
	printf(&quot;%d %d\n&quot;,O.x,O.y);
	return 0;
}
<pre><h2>Problem2395</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define LL long long
#define NN 210
#define MM 11000
#define inf 99999999999ll
int fa[NN],a[MM],b[MM],xx[MM],yy[MM];
int n,m;
LL ans;
struct point
{
	int x,y;
	point(int a=0,int b=0) {x=a;y=b;}
	friend point operator - (point a,point b) {a.x-=b.x,a.y-=b.y;return a;}
} O;
struct edge
{
	int w,id;
	friend bool operator &lt; (edge a,edge b) {return a.w&lt;b.w;}
} e[MM];
LL det(point a,point b) {return (LL)a.x*b.y-(LL)b.x*a.y;}
int getfa(int x) {return fa[x]==x?x:fa[x]=getfa(fa[x]);}
point kruscal()
{
	int i,t1,t2,sumx=0,sumy=0;
	for (i=1;i&lt;=n;i++) fa[i]=i;
	sort(e+1,e+m+1);
	for (i=1;i&lt;=m;i++)
	{
		t1=getfa(a[e[i].id]),t2=getfa(b[e[i].id]);
		if (t1==t2) continue;
		fa[t1]=t2;
		sumx+=xx[e[i].id],sumy+=yy[e[i].id];
	}
	LL tmp=(LL)sumx*(LL)sumy;
	if (tmp&lt;ans||(tmp==ans&amp;&amp;sumx&lt;O.x))
	{
		ans=tmp;
		O.x=sumx;
		O.y=sumy;
	}
	return point(sumx,sumy);
}
void work(point minx,point miny)
{
	int t1=miny.x-minx.x,t2=minx.y-miny.y;
	for (int i=1;i&lt;=m;i++) e[i].id=i,e[i].w=t1*yy[i]+t2*xx[i];
	point P=kruscal();
	if (det(minx-miny,P-miny)&lt;=0) return;
	work(minx,P);
	work(P,miny);
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;a[i],&amp;b[i],&amp;xx[i],&amp;yy[i]);
		a[i]++,b[i]++;
	}
	ans=inf;
	O.x=O.y=inf;
	for (i=1;i&lt;=m;i++) e[i].id=i,e[i].w=xx[i];
	point minx=kruscal();
	for (i=1;i&lt;=m;i++) e[i].id=i,e[i].w=yy[i];
	point miny=kruscal();
	work(minx,miny);
	printf(&quot;%d %d\n&quot;,O.x,O.y);
	return 0;
}
<pre><h2>Problem2395</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 211
#define MM 11111
#define LL long long
int fa[NN],xx[MM],yy[MM],a[MM],b[MM];
int n,m,i;
LL ans;
struct edge
{
	int id,w;
	friend bool operator &lt;(edge a,edge b) {return a.w&lt;b.w;}
} e[MM];
struct point
{
	int x,y;
	point(int a=0,int b=0) {x=a,y=b;}
	friend point operator -(point a,point b) {a.x-=b.x;a.y-=b.y;return a;}
	friend LL operator %(point a,point b) {return (LL)a.x*b.y-(LL)b.x*a.y;}
} Pans,M,N;
int getfa(int x) {return fa[x]==x?x:fa[x]=getfa(fa[x]);}
point kruscal()
{
	int i,id,x,y,cnt,sumx=0,sumy=0;
	for (i=1;i&lt;=n;i++) fa[i]=i;
	sort(e+1,e+m+1);
	for (cnt=0,i=1;cnt&lt;n-1;i++)
	{
		id=e[i].id;
		x=getfa(a[id]),y=getfa(b[id]);
		if (x==y) continue;
		cnt++;
		fa[x]=y;
		sumx+=xx[id],sumy+=yy[id];
	}
	LL tmp=(LL)sumx*sumy;
	point P=point(sumx,sumy);
	if (tmp&lt;ans) ans=tmp,Pans=P;
	else if (tmp==ans&amp;&amp;sumx&lt;Pans.x) Pans=P;
	return P;
}
void calc(point M,point N)
{
	int t1=N.x-M.x,t2=M.y-N.y;
	for (int i=1;i&lt;=m;i++) e[i].id=i,e[i].w=t1*yy[i]+t2*xx[i];
	point P=kruscal();
	if ((M-N)%(P-N)&lt;=0) return;
	calc(M,P);
	calc(P,N);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;a[i],&amp;b[i],&amp;xx[i],&amp;yy[i]);
		a[i]++,b[i]++;
	}
	ans=99999999999999ll;
	Pans.x=Pans.y=999999999;
	for (i=1;i&lt;=m;i++) e[i].id=i,e[i].w=xx[i];
	M=kruscal();
	for (i=1;i&lt;=m;i++) e[i].id=i,e[i].w=yy[i];
	N=kruscal();
	calc(M,N);
	printf(&quot;%d %d\n&quot;,Pans.x,Pans.y);
	return 0;
}
<pre><h2>Problem2395</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 211
#define MM 11111
#define LL long long
int fa[NN],xx[MM],yy[MM],a[MM],b[MM];
int n,m,i;
LL ans;
struct edge
{
	int id,w;
	friend bool operator &lt;(edge a,edge b) {return a.w&lt;b.w;}
} e[MM];
struct point
{
	int x,y;
	point(int a=0,int b=0) {x=a,y=b;}
	friend point operator -(point a,point b) {a.x-=b.x;a.y-=b.y;return a;}
	friend LL operator %(point a,point b) {return (LL)a.x*b.y-(LL)b.x*a.y;}
} Pans,M,N;
int getfa(int x) {return fa[x]==x?x:fa[x]=getfa(fa[x]);}
point kruscal()
{
	int i,id,x,y,cnt,sumx=0,sumy=0;
	for (i=1;i&lt;=n;i++) fa[i]=i;
	sort(e+1,e+m+1);
	for (cnt=0,i=1;cnt&lt;n-1;i++)
	{
		id=e[i].id;
		x=getfa(a[id]),y=getfa(b[id]);
		if (x==y) continue;
		cnt++;
		fa[x]=y;
		sumx+=xx[id],sumy+=yy[id];
	}
	LL tmp=(LL)sumx*sumy;
	point P=point(sumx,sumy);
	if (tmp&lt;ans) ans=tmp,Pans=P;
	else if (tmp==ans&amp;&amp;sumx&lt;Pans.x) Pans=P;
	return P;
}
void calc(point M,point N)
{
	int t1=N.x-M.x,t2=M.y-N.y;
	for (int i=1;i&lt;=m;i++) e[i].id=i,e[i].w=t1*yy[i]+t2*xx[i];
	point P=kruscal();
	if ((M-N)%(P-N)&lt;=0) return;
	calc(M,P);
	calc(P,N);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;a[i],&amp;b[i],&amp;xx[i],&amp;yy[i]);
		a[i]++,b[i]++;
	}
	ans=999999999ll;
	Pans.x=Pans.y=999999999;
	for (i=1;i&lt;=m;i++) e[i].id=i,e[i].w=xx[i];
	M=kruscal();
	for (i=1;i&lt;=m;i++) e[i].id=i,e[i].w=yy[i];
	N=kruscal();
	calc(M,N);
	printf(&quot;%d %d\n&quot;,Pans.x,Pans.y);
	return 0;
}
<pre><h2>Problem2395</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define INF 9999999999999999ll
#define _ if(qwe)
const int NN=211,MM=11111;
int n,m,fa[NN];
LL ans;
bool qwe=false;
struct point
{
	int x,y;
	point(int a=0,int b=0) {x=a;y=b;}
	friend point operator -(point a,point b) {return point(a.x-b.x,a.y-b.y);}
	friend LL operator %(point a,point b) {return (LL)a.x*b.y-(LL)b.x*a.y;}
} Pans;
struct E
{
	int u,v,x,y,w;
	void in()
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;u,&amp;v,&amp;x,&amp;y);
		u++,v++;
	}
	friend bool operator &lt;(E a,E b) {return a.w&lt;b.w;}
} e[MM];
int getfa(int x) {return fa[x]==x?x:fa[x]=getfa(fa[x]);}
point kru(int t1,int t2)
{
	int i;
	for (i=1;i&lt;=m;i++)
		e[i].w=t1*e[i].x+t2*e[i].y;
	sort(e+1,e+m+1);
	//if (qwe) for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,e[i].w);
	for (i=1;i&lt;=n;i++) fa[i]=i;
	int sum1=0,sum2=0;
	for (i=1;i&lt;=m;i++)
	{
		int x=getfa(e[i].u),y=getfa(e[i].v);
		if (x==y) continue;
		sum1+=e[i].x,sum2+=e[i].y;
		fa[x]=y;
	}
	LL tmp=(LL)sum1*sum2;
	point P(sum1,sum2);
	if (tmp&lt;ans) ans=tmp,Pans=P;
	else if (tmp==ans&amp;&amp;sum1&lt;Pans.x) Pans=P;
	return P;
}
void work(point M,point N)
{
	int a=N.x-M.x,b=N.y-M.y;
	point P=kru(-b,a);
	if ((P-M)%(N-M)&lt;=0) return;
	work(M,P);
	work(P,N);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (int i=1;i&lt;=m;i++) e[i].in();
	ans=INF;
	//qwe=true;
	point M=kru(1,0);
	//qwe=false;
	point N=kru(0,1);
	//printf(&quot;%d %d\n&quot;,M.x,M.y);
	work(M,N);
	printf(&quot;%d %d\n&quot;,Pans.x,Pans.y);
	return 0;
}<pre><h2>Problem2395</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define mp make_pair
#define fi first
#define se second
#define INF 9999999999999999ll
int n,m,fa[211];
struct point
{
	LL x,y;
	point(LL a=0,LL b=0) {x=a;y=b;}
	friend point operator -(const point &amp;a,const point &amp;b) {return point(a.x-b.x,a.y-b.y);}
	friend LL operator %(const point &amp;a,const point &amp;b) {return a.x*b.y-b.x*a.y;}
	friend bool operator &lt;(const point &amp;a,const point &amp;b)
	{
		if (a.x!=b.x) return a.x&lt;b.x;
		return a.y&lt;b.y;
	}
};
pair&lt;LL,point&gt; ans;
struct edge
{
	int u,v,c,t;LL w;
	inline void in()
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;u,&amp;v,&amp;c,&amp;t);
		u++,v++;
	}
	friend bool operator &lt;(const edge &amp;a,const edge &amp;b) {return a.w&lt;b.w;}
} e[10111];
int getfa(int x) {return fa[x]==x?x:fa[x]=getfa(fa[x]);}
point kruskal(LL t1,LL t2)
{
	int i;
	for (i=1;i&lt;=m;i++)
		e[i].w=t1*e[i].c+t2*e[i].t;
	sort(e+1,e+m+1);
	for (i=1;i&lt;=n;i++) fa[i]=i;
	int sumc=0,sumt=0;
	for (i=1;i&lt;=m;i++)
	{
		int x=getfa(e[i].u),y=getfa(e[i].v);
		if (x==y) continue;
		fa[x]=y;
		sumc+=e[i].c,sumt+=e[i].t;
	}
	point P=point(sumc,sumt);
	pair&lt;LL,point&gt; tmp=mp((LL)sumc*sumt,P);
	if (tmp&lt;ans) ans=tmp;
	return P;
}
void work(point M,point N)
{
	LL A=N.x-M.x,B=N.y-M.y;
	point P=kruskal(-B,A);
	if ((N-M)%(P-M)&gt;=0) return;
	work(M,P);
	work(P,N);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (int i=1;i&lt;=m;i++) e[i].in();
	ans=mp(INF,point(0,0));
	point M=kruskal(1,0);
	point N=kruskal(0,1);
	work(M,N);
	printf(&quot;%lld %lld\n&quot;,ans.se.x,ans.se.y);
	return 0;
}<pre><h2>Problem2396</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
using namespace std;
const int NN=105;
int n;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
	if (f) x=-x;
}
struct matrix
{
	int qq[NN][NN];
	matrix() {memset(qq,0,sizeof(qq));}
	int * operator [](int x) {return qq[x];}
	void in()
	{
		for (int i=1;i&lt;=n;i++)
			for (int j=1;j&lt;=n;j++) read(qq[i][j]);
	}
} A,B,C;
struct matrix1n
{
	int qq[NN];
	matrix1n() {memset(qq,0,sizeof(qq));}
	int &amp; operator [](int x) {return qq[x];}
} X;
matrix1n operator *(matrix1n a,matrix b)
{
	matrix1n c;
	for (int i=1;i&lt;=n;i++)
		for (int j=1;j&lt;=n;j++) c[i]+=a[j]*b[j][i];
	return c;
}
bool operator ==(matrix1n a,matrix1n b)
{
	for (int i=1;i&lt;=n;i++)
		if (a[i]!=b[i]) return false;
	return true;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	while (scanf(&quot;%d&quot;,&amp;n)!=EOF)
	{
		A.in(),B.in(),C.in();
		for (int i=1;i&lt;=n;i++) X[i]=rand()%1000+13;
		if (X*A*B==X*C) printf(&quot;Yes\n&quot;);
		else printf(&quot;No\n&quot;);
	}
	return 0;
}<pre><h2>Problem2396</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
using namespace std;
const int NN=105;
int n;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
	if (f) x=-x;
}
struct matrix
{
	int qq[NN][NN];
	matrix() {memset(qq,0,sizeof(qq));}
	int * operator [](int x) {return qq[x];}
	void in()
	{
		for (int i=1;i&lt;=n;i++)
			for (int j=1;j&lt;=n;j++) read(qq[i][j]);
	}
} A,B,C;
struct matrix1n
{
	int qq[NN];
	matrix1n() {memset(qq,0,sizeof(qq));}
	int &amp; operator [](int x) {return qq[x];}
} X;
matrix1n operator *(matrix1n a,matrix b)
{
	matrix1n c;
	for (int i=1;i&lt;=n;i++)
		for (int j=1;j&lt;=n;j++) c[i]+=a[j]*b[j][i];
	return c;
}
bool operator ==(matrix1n a,matrix1n b)
{
	for (int i=1;i&lt;=n;i++)
		if (a[i]!=b[i]) return false;
	return true;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	while (scanf(&quot;%d&quot;,&amp;n)!=EOF)
	{
		A.in(),B.in(),C.in();
		for (int i=1;i&lt;=n;i++) X[i]=1999-i;
		if (X*A*B==X*C) printf(&quot;Yes\n&quot;);
		else printf(&quot;No\n&quot;);
	}
	return 0;
}<pre><h2>Problem2402</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
typedef double DD;
#define pb push_back
#define ls (v&lt;&lt;1)
#define rs (v&lt;&lt;1|1)
#define ln printf(&quot;\n&quot;)
const DD eps=1e-7,dinf=1e30;
const int NN=30111;
int o[NN],aa[NN&lt;&lt;1][2],deep[NN],fa[NN],size[NN],hea[NN],up[NN],pos[NN],dy[NN];
int n,m,tot=1,cnt,ww,ee;
DD res1,res2,mid,X[NN],Y[NN],P[NN],Q[NN];
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
struct point
{
	DD x,y;
	void out() {printf(&quot;x=%.3f y=%.3f\n&quot;,x,y);}
	point(DD a=0,DD b=0) {x=a;y=b;}
	friend point operator -(const point &amp;a,const point &amp;b) {return point(a.x-b.x,a.y-b.y);}
	friend DD operator %(const point &amp;a,const point &amp;b) {return a.x*b.y-b.x*a.y;}
	friend DD operator *(const point &amp;a,const point &amp;b) {return a.x*b.x+a.y*b.y;}
};
vector&lt;point&gt; v1[NN&lt;&lt;2],v2[NN&lt;&lt;2];
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs1(int v)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		dfs1(y);
		size[v]+=size[y];
		if (size[y]&gt;size[hea[v]]) hea[v]=y;
	}
}
void dfs2(int v)
{
	pos[v]=++cnt;
	dy[cnt]=v;
	if (hea[v])
	{
		up[hea[v]]=up[v];
		dfs2(hea[v]);
	}
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||y==hea[v]) continue;
		up[y]=y;
		dfs2(y);
	}
}
void merge(vector&lt;point&gt; &amp;a,vector&lt;point&gt; &amp;b,vector&lt;point&gt; &amp;c)
{
	int n1=b.size(),n2=c.size(),i,j;
	for (i=j=0;i&lt;n1||j&lt;n2;)
		if ((i&lt;n1&amp;&amp;b[i].x&lt;c[j].x)||j&gt;=n2) a.pb(b[i++]);
		else a.pb(c[j++]);
	static point temp[NN];
	int n=a.size(),cnt=0;
	for (i=0;i&lt;n;i++)
	{
		while (cnt&gt;1&amp;&amp;(a[i]-temp[cnt-1])%(temp[cnt]-temp[cnt-1])&lt;=0) cnt--;
		temp[++cnt]=a[i];
	}
	a.clear();
	for (i=1;i&lt;=cnt;i++) a.pb(temp[i]);
}
void build(int v,int l,int r)
{
	if (r-l==1)
	{
		int t=dy[l];
		v1[v].pb(point(X[t],Y[t]));
		v2[v].pb(point(P[t],Q[t]));
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(ls,l,mid);
	build(rs,mid,r);
	merge(v1[v],v1[ls],v1[rs]);
	merge(v2[v],v2[ls],v2[rs]);
}
DD sanfen(vector&lt;point&gt; &amp;a)
{
	//printf(&quot;=========== sanfen =============\n&quot;);
	int l=0,r=a.size()-1;
	point v=point(-mid,1);
	while (r-l&gt;4)
	{
		int t=(r-l)/3,m1=l+t,m2=r-t;
		if (a[m1]*v&gt;a[m2]*v) r=m2-1;
		else l=m1+1;
	}
	DD res=-dinf;
	for (int i=l;i&lt;=r;i++) res=max(res,a[i]*v);
	return res;
}
void find(int v,int l,int r)
{
	//printf(&quot;find %d %d %d\n&quot;,v,l,r);
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		res1=max(res1,sanfen(v1[v]));
		res2=max(res2,sanfen(v2[v]));
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) find(ls,l,mid);
	if (ee&gt;mid) find(rs,mid,r);
}
bool check(int x,int y)
{
	res1=res2=-dinf;
	while (up[x]!=up[y])
	{
		if (deep[up[x]]&lt;deep[up[y]]) {int t=x;x=y;y=t;}
		ww=pos[up[x]],ee=pos[x]+1;
		find(1,1,n+1);
		x=fa[up[x]];
		//printf(&quot;res1=%.3f res2=%.3f\n&quot;,res1,res2);
	}
	if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
	ww=pos[y],ee=pos[x]+1;
	find(1,1,n+1);
	//printf(&quot;res1=%.3f res2=%.3f\n&quot;,res1,res2);
	return res1+res2&gt;-eps;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y;
	for (i=1;i&lt;=n;i++) scanf(&quot;%lf&quot;,&amp;X[i]);
	for (i=1;i&lt;=n;i++) scanf(&quot;%lf&quot;,&amp;Y[i]);
	for (i=1;i&lt;=n;i++) scanf(&quot;%lf&quot;,&amp;P[i]);
	for (i=1;i&lt;=n;i++) scanf(&quot;%lf&quot;,&amp;Q[i]);
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	deep[1]=1,dfs1(1);
	up[1]=1,dfs2(1);
	//printf(&quot;pos &quot;);out(pos,1,n);printf(&quot;up &quot;);out(up,1,n);ln;
	build(1,1,n+1);
	for (scanf(&quot;%d&quot;,&amp;m);m;m--)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		DD l=0,r=2*1e8;
		while (r-l&gt;0.000001)
		{
			mid=(l+r)*0.5;
			//printf(&quot;\n---------------------- l=%.3f r=%.3f mid=%.3f ------------------------------\n&quot;,l,r,mid);
			if (check(x,y)) l=mid;
			else r=mid;
		}
		printf(&quot;%.4f\n&quot;,l);
	}
	return 0;
}<pre><h2>Problem2402</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
typedef double DD;
#define pb push_back
#define ls (v&lt;&lt;1)
#define rs (v&lt;&lt;1|1)
const DD eps=1e-7,dinf=1e30;
const int NN=30111;
int o[NN],aa[NN&lt;&lt;1][2],deep[NN],fa[NN],size[NN],hea[NN],up[NN],pos[NN],dy[NN];
int n,m,tot=1,cnt,ww,ee;
DD res1,res2,mid,X[NN],Y[NN],P[NN],Q[NN];
struct point
{
	DD x,y;
	point(DD a=0,DD b=0) {x=a;y=b;}
	friend point operator -(const point &amp;a,const point &amp;b) {return point(a.x-b.x,a.y-b.y);}
	friend DD operator %(const point &amp;a,const point &amp;b) {return a.x*b.y-b.x*a.y;}
	friend DD operator *(const point &amp;a,const point &amp;b) {return a.x*b.x+a.y*b.y;}
};
vector&lt;point&gt; v1[NN&lt;&lt;2],v2[NN&lt;&lt;2];
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs1(int v)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		dfs1(y);
		size[v]+=size[y];
		if (size[y]&gt;size[hea[v]]) hea[v]=y;
	}
}
void dfs2(int v)
{
	pos[v]=++cnt;
	dy[cnt]=v;
	if (hea[v])
	{
		up[hea[v]]=up[v];
		dfs2(hea[v]);
	}
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||y==hea[v]) continue;
		up[y]=y;
		dfs2(y);
	}
}
void merge(vector&lt;point&gt; &amp;a,vector&lt;point&gt; &amp;b,vector&lt;point&gt; &amp;c)
{
	int n1=b.size(),n2=c.size(),i,j;
	for (i=j=0;i&lt;n1||j&lt;n2;)
		if ((i&lt;n1&amp;&amp;b[i].x&lt;c[j].x)||j&gt;=n2) a.pb(b[i++]);
		else a.pb(c[j++]);
	static point temp[NN];
	int n=a.size(),cnt=0;
	for (i=0;i&lt;n;i++)
	{
		while (cnt&gt;1&amp;&amp;(a[i]-temp[cnt-1])%(temp[cnt]-temp[cnt-1])&lt;=0) cnt--;
		temp[++cnt]=a[i];
	}
	a.clear();
	for (i=1;i&lt;=cnt;i++) a.pb(temp[i]);
}
void build(int v,int l,int r)
{
	if (r-l==1)
	{
		int t=dy[l];
		v1[v].pb(point(X[t],Y[t]));
		v2[v].pb(point(P[t],Q[t]));
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(ls,l,mid);
	build(rs,mid,r);
	merge(v1[v],v1[ls],v1[rs]);
	merge(v2[v],v2[ls],v2[rs]);
}
DD sanfen(vector&lt;point&gt; &amp;a)
{
	int l=0,r=a.size()-1;
	point v=point(-mid,1);
	while (r-l&gt;4)
	{
		int t=(r-l)/3,m1=l+t,m2=r-t;
		if (a[m1]*v&gt;a[m2]*v) r=m2-1;
		else l=m1+1;
	}
	DD res=-dinf;
	for (int i=l;i&lt;=r;i++) res=max(res,a[i]*v);
	return res;
}
void find(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		res1=max(res1,sanfen(v1[v]));
		res2=max(res2,sanfen(v2[v]));
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) find(ls,l,mid);
	if (ee&gt;mid) find(rs,mid,r);
}
bool check(int x,int y)
{
	res1=res2=-dinf;
	while (up[x]!=up[y])
	{
		if (deep[up[x]]&lt;deep[up[y]]) {int t=x;x=y;y=t;}
		ww=pos[up[x]],ee=pos[x]+1;
		find(1,1,n+1);
		x=fa[up[x]];
	}
	if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
	ww=pos[y],ee=pos[x]+1;
	find(1,1,n+1);
	return res1+res2&gt;-eps;
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y;
	for (i=1;i&lt;=n;i++) scanf(&quot;%lf&quot;,&amp;X[i]);
	for (i=1;i&lt;=n;i++) scanf(&quot;%lf&quot;,&amp;Y[i]);
	for (i=1;i&lt;=n;i++) scanf(&quot;%lf&quot;,&amp;P[i]);
	for (i=1;i&lt;=n;i++) scanf(&quot;%lf&quot;,&amp;Q[i]);
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	deep[1]=1,dfs1(1);
	up[1]=1,dfs2(1);
	build(1,1,n+1);
	for (scanf(&quot;%d&quot;,&amp;m);m;m--)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		DD l=0,r=2*1e8;
		while (r-l&gt;0.00001)
		{
			mid=(l+r)*0.5;
			if (check(x,y)) l=mid;
			else r=mid;
		}
		printf(&quot;%.4f\n&quot;,l);
	}
	return 0;
}<pre><h2>Problem2406</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define INF 0x7fffffff
struct node{
    int qi,zhong,flow,next;
    node(int _=0,int __=0,int ___=0,int ____=0):qi(_),zhong(__),flow(___),next(____){}
}edge[100010];
int first[505],cur[505],du[505];
int cnt=1,S,T,Maxflow,tot,n,m,L,R,SS,TT;
int hang[205],lie[205];
void add(int x,int y,int z){edge[++cnt]=node(x,y,z,first[x]),first[x]=cnt,edge[++cnt]=node(y,x,0,first[y]),first[y]=cnt;}
int dis[505],gap[505];
int ISAP(int now,int flow){
	if(now==TT)return flow;
	int sum=0,tmp;
	for(int i=cur[now];i;i=edge[i].next){
		if(edge[i].flow&amp;&amp;dis[edge[i].zhong]+1==dis[now]){
			tmp=ISAP(edge[i].zhong,min(flow-sum,edge[i].flow)),edge[i].flow-=tmp,edge[i^1].flow+=tmp,cur[now]=i;
			if((sum+=tmp)==flow)return sum;
			if(dis[S]&gt;=T)return sum;
		}
	}
	if(!(--gap[dis[now]]))dis[SS]=TT;
	++gap[++dis[now]],cur[now]=first[now];
	return sum;
}
bool check(int mid){
	cnt=1,tot=0,Maxflow=0;
	memset(first,0,sizeof(first));
	for(int i=1;i&lt;=n;i++){
		int s=hang[i]+mid,x=hang[i]-mid&lt;0?0:hang[i]-mid;
		add(S,i,s-x);
		du[S]-=x,du[i]+=x;
	}
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=m;j++){
			add(i,j+n,R-L);
			du[i]-=L,du[j+n]+=L;
		}
	}
	for(int i=1;i&lt;=m;i++){
		int s=lie[i]+mid,x=lie[i]-mid&lt;0?0:lie[i]-mid;
		add(i+n,T,s-x);
		du[i+n]-=x,du[T]+=x;
	}
	for(int i=S;i&lt;=T;i++){
		if(du[i]&lt;0)tot-=du[i],add(i,TT,-du[i]),du[i]=0;
		else if(du[i]&gt;0)add(SS,i,du[i]),du[i]=0;
	}
	add(T,S,INF);
	memset(dis,0,sizeof(dis));
	memset(gap,0,sizeof(gap));
	while(dis[SS]&lt;TT)Maxflow+=ISAP(SS,INF);
	return tot==Maxflow;
}
void divide(){
	int l=0,r=100010,ans;
	while(l&lt;=r){
		int mid=l+r&gt;&gt;1;
		if(check(mid)){
			ans=mid,r=mid-1;
		}else l=mid+1;
	}
	printf(&quot;%d\n&quot;,ans);
}
int main(){
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1,x;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)scanf(&quot;%d&quot;,&amp;x),hang[i]+=x,lie[j]+=x;
	scanf(&quot;%d%d&quot;,&amp;L,&amp;R);
	S=0,T=n+m+1,SS=T+1,TT=SS+1;
	divide();
}
<pre><h2>Problem2406</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;
#define INF 0x7fffffff
struct node{
    int qi,zhong,flow,next;
    node(int _=0,int __=0,int ___=0,int ____=0):qi(_),zhong(__),flow(___),next(____){}
}edge[100010];
int first[505],cur[505],du[505];
int cnt=1,S,T,Maxflow,tot,n,m,L,R,SS,TT;
int hang[205],lie[205];
void add(int x,int y,int z){edge[++cnt]=node(x,y,z,first[x]),first[x]=cnt,edge[++cnt]=node(y,x,0,first[y]),first[y]=cnt;}
int dis[505],gap[505];
int ISAP(int now,int flow){
	if(now==TT)return flow;
	int sum=0,tmp;
	for(int i=cur[now];i;i=edge[i].next){
		if(edge[i].flow&amp;&amp;dis[edge[i].zhong]+1==dis[now]){
			tmp=ISAP(edge[i].zhong,min(flow-sum,edge[i].flow)),edge[i].flow-=tmp,edge[i^1].flow+=tmp,cur[now]=i;
			if((sum+=tmp)==flow)return sum;
			if(dis[S]&gt;=T)return sum;
		}
	}
	if(!(--gap[dis[now]]))dis[SS]=TT;
	++gap[++dis[now]],cur[now]=first[now];
	return sum;
}
bool check(int mid){
	cnt=1,tot=0,Maxflow=0;
	memset(first,0,sizeof(first));
	for(int i=1;i&lt;=n;i++){
		int s=hang[i]+mid,x=hang[i]-mid&lt;0?0:hang[i]-mid;
		add(S,i,s-x);
		du[S]-=x,du[i]+=x;
	}
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=m;j++){
			add(i,j+n,R-L);
			du[i]-=L,du[j+n]+=L;
		}
	}
	for(int i=1;i&lt;=m;i++){
		int s=lie[i]+mid,x=lie[i]-mid&lt;0?0:lie[i]-mid;
		add(i+n,T,s-x);
		du[i+n]-=x,du[T]+=x;
	}
	for(int i=S;i&lt;=T;i++){
		if(du[i]&lt;0)tot-=du[i],add(i,TT,-du[i]),du[i]=0;
		else if(du[i]&gt;0)add(SS,i,du[i]),du[i]=0;
	}
	add(T,S,INF);
	memset(dis,0,sizeof(dis));
	memset(gap,0,sizeof(gap));
	while(dis[SS]&lt;TT)Maxflow+=ISAP(SS,INF);
	return tot==Maxflow;
}
void divide(){
	int l=0,r=100010,ans;
	while(l&lt;r){
		int mid=rand()%(r-l)+l;
		if(check(mid)){
			ans=mid,r=mid-1;
		}else l=mid+1;
	}
	if(check(l))ans=l;
	printf(&quot;%d\n&quot;,ans);
}
int main(){
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1,x;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)scanf(&quot;%d&quot;,&amp;x),hang[i]+=x,lie[j]+=x;
	scanf(&quot;%d%d&quot;,&amp;L,&amp;R);
	S=0,T=n+m+1,SS=T+1,TT=SS+1;
	divide();
}
<pre><h2>Problem2406</h2><pre>#include&lt;ctime&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;
#define INF 0x7fffffff
struct node{
    int qi,zhong,flow,next;
    node(int _=0,int __=0,int ___=0,int ____=0):qi(_),zhong(__),flow(___),next(____){}
}edge[100010];
int first[505],cur[505],du[505];
int cnt=1,S,T,Maxflow,tot,n,m,L,R,SS,TT;
int hang[205],lie[205];
int a[205][205],b[205][205];
void add(int x,int y,int z){edge[++cnt]=node(x,y,z,first[x]),first[x]=cnt,edge[++cnt]=node(y,x,0,first[y]),first[y]=cnt;}
int dis[505],gap[505];
int ISAP(int now,int flow){
	if(now==TT)return flow;
	int sum=0,tmp;
	for(int i=cur[now];i;i=edge[i].next){
		if(edge[i].flow&amp;&amp;dis[edge[i].zhong]+1==dis[now]){
			tmp=ISAP(edge[i].zhong,min(flow-sum,edge[i].flow)),edge[i].flow-=tmp,edge[i^1].flow+=tmp,cur[now]=i;
			if((sum+=tmp)==flow)return sum;
			if(dis[S]&gt;=T)return sum;
		}
	}
	if(!(--gap[dis[now]]))dis[SS]=TT;
	++gap[++dis[now]],cur[now]=first[now];
	return sum;
}
bool check(int mid){
	cnt=1,tot=0,Maxflow=0;
	memset(first,0,sizeof(first));
	for(int i=1;i&lt;=n;i++){
		int s=hang[i]+mid,x=hang[i]-mid&lt;0?0:hang[i]-mid;
		add(S,i,s-x);
		du[S]-=x,du[i]+=x;
	}
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=m;j++){
			add(i,j+n,R-L);
			du[i]-=L,du[j+n]+=L;
		}
	}
	for(int i=1;i&lt;=m;i++){
		int s=lie[i]+mid,x=lie[i]-mid&lt;0?0:lie[i]-mid;
		add(i+n,T,s-x);
		du[i+n]-=x,du[T]+=x;
	}
	for(int i=S;i&lt;=T;i++){
		if(du[i]&lt;0)tot-=du[i],add(i,TT,-du[i]),du[i]=0;
		else if(du[i]&gt;0)add(SS,i,du[i]),du[i]=0;
	}
	add(T,S,INF);
	memset(dis,0,sizeof(dis));
	memset(gap,0,sizeof(gap));
	while(dis[SS]&lt;TT)Maxflow+=ISAP(SS,INF);
	return tot==Maxflow;
}
void divide(){
	int l=0,r=0,ans=0;
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=m;j++){
			b[i][j]=abs(a[i][j]-(r==l?0:rand()%(r-l)+l));
		}
	}
	for(int i=1;i&lt;=n;i++){
		int Sum=0;
		for(int j=1;j&lt;=m;j++){
			Sum+=b[i][j];
		}
		if(r&lt;Sum)r=Sum;
	}
	for(int i=1;i&lt;=m;i++){
		int Sum=0;
		for(int j=1;j&lt;=n;j++){
			Sum+=b[j][i];
		}
		if(r&lt;Sum)r=Sum;
	}
	while(l&lt;r){
		int mid=rand()%(r-l)+l;
		if(check(mid)){
			ans=mid,r=mid-1;
		}else l=mid+1;
	}
	if(check(l))ans=l;
	printf(&quot;%d\n&quot;,ans);
}
int main(){
	srand(19991007);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1,x;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)scanf(&quot;%d&quot;,&amp;a[i][j]),hang[i]+=a[i][j],lie[j]+=a[i][j];
	scanf(&quot;%d%d&quot;,&amp;L,&amp;R);
	S=0,T=n+m+1,SS=T+1,TT=SS+1;
	divide();
}
<pre><h2>Problem2406</h2><pre>#include&lt;ctime&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;
#define INF 0x7fffffff
struct node{
    int qi,zhong,flow,next;
    node(int _=0,int __=0,int ___=0,int ____=0):qi(_),zhong(__),flow(___),next(____){}
}edge[100010];
int first[505],cur[505],du[505];
int cnt=1,S,T,Maxflow,tot,n,m,L,R,SS,TT;
int hang[205],lie[205];
int a[205][205],b[205][205];
void add(int x,int y,int z){edge[++cnt]=node(x,y,z,first[x]),first[x]=cnt,edge[++cnt]=node(y,x,0,first[y]),first[y]=cnt;}
int dis[505],gap[505];
int ISAP(int now,int flow){
	if(now==TT)return flow;
	int sum=0,tmp;
	for(int i=cur[now];i;i=edge[i].next){
		if(edge[i].flow&amp;&amp;dis[edge[i].zhong]+1==dis[now]){
			tmp=ISAP(edge[i].zhong,min(flow-sum,edge[i].flow)),edge[i].flow-=tmp,edge[i^1].flow+=tmp,cur[now]=i;
			if((sum+=tmp)==flow)return sum;
			if(dis[S]&gt;=T)return sum;
		}
	}
	if(!(--gap[dis[now]]))dis[SS]=TT;
	++gap[++dis[now]],cur[now]=first[now];
	return sum;
}
bool check(int mid){
	cnt=1,tot=0,Maxflow=0;
	memset(first,0,sizeof(first));
	for(int i=1;i&lt;=n;i++){
		int s=hang[i]+mid,x=hang[i]-mid&lt;0?0:hang[i]-mid;
		add(S,i,s-x);
		du[S]-=x,du[i]+=x;
	}
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=m;j++){
			add(i,j+n,R-L);
			du[i]-=L,du[j+n]+=L;
		}
	}
	for(int i=1;i&lt;=m;i++){
		int s=lie[i]+mid,x=lie[i]-mid&lt;0?0:lie[i]-mid;
		add(i+n,T,s-x);
		du[i+n]-=x,du[T]+=x;
	}
	for(int i=S;i&lt;=T;i++){
		if(du[i]&lt;0)tot-=du[i],add(i,TT,-du[i]),du[i]=0;
		else if(du[i]&gt;0)add(SS,i,du[i]),du[i]=0;
	}
	add(T,S,INF);
	memset(dis,0,sizeof(dis));
	memset(gap,0,sizeof(gap));
	while(dis[SS]&lt;TT)Maxflow+=ISAP(SS,INF);
	return tot==Maxflow;
}
void divide(){
	int l=0,r=0,ans=0;
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=m;j++){
			b[i][j]=abs(a[i][j]-(r==l?0:rand()%(r-l)+l));
		}
	}
	for(int i=1;i&lt;=n;i++){
		int Sum=0;
		for(int j=1;j&lt;=m;j++){
			Sum+=b[i][j];
		}
		if(r&lt;Sum)r=Sum;
	}
	for(int i=1;i&lt;=m;i++){
		int Sum=0;
		for(int j=1;j&lt;=n;j++){
			Sum+=b[j][i];
		}
		if(r&lt;Sum)r=Sum;
	}
	while(l&lt;r){
		int mid=rand()%(r-l)+l;
		if(check(mid)){
			ans=mid,r=mid-1;
		}else l=mid+1;
	}
	if(check(l))ans=l;
	printf(&quot;%d\n&quot;,ans);
}
int main(){
	srand(19981011);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1,x;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)scanf(&quot;%d&quot;,&amp;a[i][j]),hang[i]+=a[i][j],lie[j]+=a[i][j];
	scanf(&quot;%d%d&quot;,&amp;L,&amp;R);
	S=0,T=n+m+1,SS=T+1,TT=SS+1;
	divide();
}
<pre><h2>Problem2406</h2><pre>#include&lt;ctime&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;
#define INF 0x7fffffff
struct node{
    int qi,zhong,flow,next;
    node(int _=0,int __=0,int ___=0,int ____=0):qi(_),zhong(__),flow(___),next(____){}
}edge[100010];
int first[505],cur[505],du[505];
int cnt=1,S,T,Maxflow,tot,n,m,L,R,SS,TT;
int hang[205],lie[205];
int a[205][205],b[205][205];
void add(int x,int y,int z){edge[++cnt]=node(x,y,z,first[x]),first[x]=cnt,edge[++cnt]=node(y,x,0,first[y]),first[y]=cnt;}
int dis[505],gap[505];
int ISAP(int now,int flow){
	if(now==TT)return flow;
	int sum=0,tmp;
	for(int i=cur[now];i;i=edge[i].next){
		if(edge[i].flow&amp;&amp;dis[edge[i].zhong]+1==dis[now]){
			tmp=ISAP(edge[i].zhong,min(flow-sum,edge[i].flow)),edge[i].flow-=tmp,edge[i^1].flow+=tmp,cur[now]=i;
			if((sum+=tmp)==flow)return sum;
			if(dis[S]&gt;=T)return sum;
		}
	}
	if(!(--gap[dis[now]]))dis[SS]=TT;
	++gap[++dis[now]],cur[now]=first[now];
	return sum;
}
bool check(int mid){
	cnt=1,tot=0,Maxflow=0;
	memset(first,0,sizeof(first));
	for(int i=1;i&lt;=n;i++){
		int s=hang[i]+mid,x=hang[i]-mid&lt;0?0:hang[i]-mid;
		add(S,i,s-x);
		du[S]-=x,du[i]+=x;
	}
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=m;j++){
			add(i,j+n,R-L);
			du[i]-=L,du[j+n]+=L;
		}
	}
	for(int i=1;i&lt;=m;i++){
		int s=lie[i]+mid,x=lie[i]-mid&lt;0?0:lie[i]-mid;
		add(i+n,T,s-x);
		du[i+n]-=x,du[T]+=x;
	}
	for(int i=S;i&lt;=T;i++){
		if(du[i]&lt;0)tot-=du[i],add(i,TT,-du[i]),du[i]=0;
		else if(du[i]&gt;0)add(SS,i,du[i]),du[i]=0;
	}
	add(T,S,INF);
	memset(dis,0,sizeof(dis));
	memset(gap,0,sizeof(gap));
	while(dis[SS]&lt;TT)Maxflow+=ISAP(SS,INF);
	return tot==Maxflow;
}
void divide(){
	int l=0,r=0,ans=0;
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=m;j++){
			b[i][j]=abs(a[i][j]-(r==l?0:rand()%(r-l)+l));
		}
	}
	for(int i=1;i&lt;=n;i++){
		int Sum=0;
		for(int j=1;j&lt;=m;j++){
			Sum+=b[i][j];
		}
		if(r&lt;Sum)r=Sum;
	}
	for(int i=1;i&lt;=m;i++){
		int Sum=0;
		for(int j=1;j&lt;=n;j++){
			Sum+=b[j][i];
		}
		if(r&lt;Sum)r=Sum;
	}
	while(l&lt;r){
		int mid=rand()%(r-l)+l;
		if(check(mid)){
			ans=mid,r=mid-1;
		}else l=mid+1;
	}
	if(check(l))ans=l;
	printf(&quot;%d\n&quot;,ans);
}
int main(){
	srand(19981206);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1,x;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)scanf(&quot;%d&quot;,&amp;a[i][j]),hang[i]+=a[i][j],lie[j]+=a[i][j];
	scanf(&quot;%d%d&quot;,&amp;L,&amp;R);
	S=0,T=n+m+1,SS=T+1,TT=SS+1;
	divide();
}
<pre><h2>Problem2406</h2><pre>#include&lt;ctime&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;
#define INF 0x7fffffff
struct node{
    int qi,zhong,flow,next;
    node(int _=0,int __=0,int ___=0,int ____=0):qi(_),zhong(__),flow(___),next(____){}
}edge[100010];
int first[505],cur[505],du[505];
int cnt=1,S,T,Maxflow,tot,n,m,L,R,SS,TT;
int hang[205],lie[205];
int a[205][205],b[205][205];
void add(int x,int y,int z){edge[++cnt]=node(x,y,z,first[x]),first[x]=cnt,edge[++cnt]=node(y,x,0,first[y]),first[y]=cnt;}
int dis[505],gap[505];
int ISAP(int now,int flow){
	if(now==TT)return flow;
	int sum=0,tmp;
	for(int i=cur[now];i;i=edge[i].next){
		if(edge[i].flow&amp;&amp;dis[edge[i].zhong]+1==dis[now]){
			tmp=ISAP(edge[i].zhong,min(flow-sum,edge[i].flow)),edge[i].flow-=tmp,edge[i^1].flow+=tmp,cur[now]=i;
			if((sum+=tmp)==flow)return sum;
			if(dis[S]&gt;=T)return sum;
		}
	}
	if(!(--gap[dis[now]]))dis[SS]=TT;
	++gap[++dis[now]],cur[now]=first[now];
	return sum;
}
bool check(int mid){
	cnt=1,tot=0,Maxflow=0;
	memset(first,0,sizeof(first));
	for(int i=1;i&lt;=n;i++){
		int s=hang[i]+mid,x=hang[i]-mid&lt;0?0:hang[i]-mid;
		add(S,i,s-x);
		du[S]-=x,du[i]+=x;
	}
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=m;j++){
			add(i,j+n,R-L);
			du[i]-=L,du[j+n]+=L;
		}
	}
	for(int i=1;i&lt;=m;i++){
		int s=lie[i]+mid,x=lie[i]-mid&lt;0?0:lie[i]-mid;
		add(i+n,T,s-x);
		du[i+n]-=x,du[T]+=x;
	}
	for(int i=S;i&lt;=T;i++){
		if(du[i]&lt;0)tot-=du[i],add(i,TT,-du[i]),du[i]=0;
		else if(du[i]&gt;0)add(SS,i,du[i]),du[i]=0;
	}
	add(T,S,INF);
	memset(dis,0,sizeof(dis));
	memset(gap,0,sizeof(gap));
	while(dis[SS]&lt;TT)Maxflow+=ISAP(SS,INF);
	return tot==Maxflow;
}
void divide(){
	int l=0,r=0,ans=0;
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=m;j++){
			b[i][j]=abs(a[i][j]-(r==l?0:rand()%(r-l)+l));
		}
	}
	for(int i=1;i&lt;=n;i++){
		int Sum=0;
		for(int j=1;j&lt;=m;j++){
			Sum+=b[i][j];
		}
		if(r&lt;Sum)r=Sum;
	}
	for(int i=1;i&lt;=m;i++){
		int Sum=0;
		for(int j=1;j&lt;=n;j++){
			Sum+=b[j][i];
		}
		if(r&lt;Sum)r=Sum;
	}
	while(l&lt;r){
		int mid=rand()%(r-l)+l;
		if(check(mid)){
			ans=mid,r=mid-1;
		}else l=mid+1;
	}
	if(check(l))ans=l;
	printf(&quot;%d\n&quot;,ans);
}
int main(){
	srand(1603171845);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1,x;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)scanf(&quot;%d&quot;,&amp;a[i][j]),hang[i]+=a[i][j],lie[j]+=a[i][j];
	scanf(&quot;%d%d&quot;,&amp;L,&amp;R);
	S=0,T=n+m+1,SS=T+1,TT=SS+1;
	divide();
}
<pre><h2>Problem2406</h2><pre>#include&lt;ctime&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;
#define INF 0x7fffffff
struct node{
    int qi,zhong,flow,next;
    node(int _=0,int __=0,int ___=0,int ____=0):qi(_),zhong(__),flow(___),next(____){}
}edge[100010];
int first[505],cur[505],du[505];
int cnt=1,S,T,Maxflow,tot,n,m,L,R,SS,TT;
int hang[205],lie[205];
int a[205][205],b[205][205];
void add(int x,int y,int z){edge[++cnt]=node(x,y,z,first[x]),first[x]=cnt,edge[++cnt]=node(y,x,0,first[y]),first[y]=cnt;}
int dis[505],gap[505];
int ISAP(int now,int flow){
	if(now==TT)return flow;
	int sum=0,tmp;
	for(int i=cur[now];i;i=edge[i].next){
		if(edge[i].flow&amp;&amp;dis[edge[i].zhong]+1==dis[now]){
			tmp=ISAP(edge[i].zhong,min(flow-sum,edge[i].flow)),edge[i].flow-=tmp,edge[i^1].flow+=tmp,cur[now]=i;
			if((sum+=tmp)==flow)return sum;
			if(dis[S]&gt;=T)return sum;
		}
	}
	if(!(--gap[dis[now]]))dis[SS]=TT;
	++gap[++dis[now]],cur[now]=first[now];
	return sum;
}
bool check(int mid){
	cnt=1,tot=0,Maxflow=0;
	memset(first,0,sizeof(first));
	for(int i=1;i&lt;=n;i++){
		int s=hang[i]+mid,x=hang[i]-mid&lt;0?0:hang[i]-mid;
		add(S,i,s-x);
		du[S]-=x,du[i]+=x;
	}
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=m;j++){
			add(i,j+n,R-L);
			du[i]-=L,du[j+n]+=L;
		}
	}
	for(int i=1;i&lt;=m;i++){
		int s=lie[i]+mid,x=lie[i]-mid&lt;0?0:lie[i]-mid;
		add(i+n,T,s-x);
		du[i+n]-=x,du[T]+=x;
	}
	for(int i=S;i&lt;=T;i++){
		if(du[i]&lt;0)tot-=du[i],add(i,TT,-du[i]),du[i]=0;
		else if(du[i]&gt;0)add(SS,i,du[i]),du[i]=0;
	}
	add(T,S,INF);
	memset(dis,0,sizeof(dis));
	memset(gap,0,sizeof(gap));
	while(dis[SS]&lt;TT)Maxflow+=ISAP(SS,INF);
	return tot==Maxflow;
}
void divide(){
	int l=0,r=0,ans=0;
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=m;j++){
			b[i][j]=abs(a[i][j]-(r==l?0:rand()%(r-l)+l));
		}
	}
	for(int i=1;i&lt;=n;i++){
		int Sum=0;
		for(int j=1;j&lt;=m;j++){
			Sum+=b[i][j];
		}
		if(r&lt;Sum)r=Sum;
	}
	for(int i=1;i&lt;=m;i++){
		int Sum=0;
		for(int j=1;j&lt;=n;j++){
			Sum+=b[j][i];
		}
		if(r&lt;Sum)r=Sum;
	}
	while(l&lt;r){
		int mid=rand()%(r-l)+l;
		if(check(mid)){
			ans=mid,r=mid-1;
		}else l=mid+1;
	}
	if(check(l))ans=l;
	printf(&quot;%d\n&quot;,ans);
}
int main(){
	srand(19990828);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1,x;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)scanf(&quot;%d&quot;,&amp;a[i][j]),hang[i]+=a[i][j],lie[j]+=a[i][j];
	scanf(&quot;%d%d&quot;,&amp;L,&amp;R);
	S=0,T=n+m+1,SS=T+1,TT=SS+1;
	divide();
}
<pre><h2>Problem2406</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;

#define maxn 410
#define INF 0x3fffffff

using namespace std;

int n,m,l,r,su,sv,ssu,ssv,dep[maxn],tot,b[maxn],out[maxn],in[maxn],hang[maxn],lie[maxn];
int w[maxn][maxn];

struct edge{
	int x,y,w,last;
}a[maxn*maxn&lt;&lt;3];

void add(int x,int y,int w)
{
	a[++tot]=(edge){x,y,w,b[x]};
	b[x]=tot;
}

void Add(int x,int y,int w)
{
	add(x,y,w);add(y,x,0);
}

void insert(int x,int y,int L,int R)
{
	//printf(&quot;%d %d %d %d\n&quot;,x,y,L,R);
	out[x]+=L;in[y]+=L;
	if(R!=L) Add(x,y,R-L);
}

#define v a[i].y
bool bfs()
{
    queue&lt;int&gt; q;
    q.push(ssu);
    memset(dep,0,sizeof(dep));
    dep[ssu]=1;
    while(!q.empty()){
        int x=q.front();
        q.pop();
        for(int i=b[x];i;i=a[i].last){
            if(!dep[v]&amp;&amp;a[i].w&gt;0){
                dep[v]=dep[x]+1;
                if(v==ssv) return 1;
                q.push(v);
            }
        }
    }
    return dep[ssv]!=0;
}
 
int Dinic(int x,int flow)
{
    if(x==ssv) return flow;
    int remain=flow;
    for(int i=b[x];i;i=a[i].last){
        if(!remain) break;
        if(dep[v]==dep[x]+1&amp;&amp;a[i].w&gt;0){
            int tmp=Dinic(v,min(a[i].w,remain));
            if(!tmp){
                dep[v]=0;
                continue;
            }
            a[i].w-=tmp;
            a[i^1].w+=tmp;
            remain-=tmp;
        }
    }
    return flow-remain;
}

bool check(int mid)
{
	memset(b,0,sizeof(b));
	memset(in,0,sizeof(in));
	memset(out,0,sizeof(out));
	tot=1;
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++) insert(i,j+n,l,r);
	for(int i=1;i&lt;=n;i++){
		int L=max(0,hang[i]-mid),R=hang[i]+mid;
		L=max(L,m*l);
		if(L&gt;R) continue;
		insert(su,i,L,R);
	}
	for(int i=1;i&lt;=m;i++){
		int L=max(0,lie[i]-mid),R=lie[i]+mid;
		L=max(L,n*l);
		if(L&gt;R) continue;
		insert(i+n,sv,L,R);
	}
	int sum=0,tmp,ans=0;
	for(int i=0;i&lt;=n+m+1;i++){
		if(in[i]&gt;out[i]) Add(ssu,i,in[i]-out[i]),sum+=(in[i]-out[i]);
		else if(in[i]&lt;out[i]) Add(i,ssv,out[i]-in[i]);
	}
	Add(sv,su,INF);
	while(bfs()){
		while(tmp=Dinic(ssu,INF)) ans+=tmp;
	}
	return ans&gt;=sum;
}

int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	sv=n+m+1;ssu=n+m+2,ssv=n+m+3;
	for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++){
		scanf(&quot;%d&quot;,&amp;w[i][j]);
	}
	scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++) hang[i]+=w[i][j],lie[j]+=w[i][j];
	int L=0,R=2000000,ans=0;
	while(L&lt;=R){
		int mid=L+R&gt;&gt;1;
		if(check(mid)){
			ans=mid;
			R=mid-1;
		}else{
			L=mid+1;
		}
	}
	printf(&quot;%d\n&quot;,ans);
	//while(1);
	return 0;
}
<pre><h2>Problem2406</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
  
#define maxn 410
#define INF 0x7fffffff
  
using namespace std;
  
int n,m,l,r,su,sv,ssu,ssv,dep[maxn],tot,b[maxn],out[maxn],in[maxn],hang[maxn],lie[maxn];
int w[maxn][maxn];
  
struct edge{
    int x,y,w,last;
}a[maxn*maxn&lt;&lt;3];
  
void add(int x,int y,int w)
{
    a[++tot]=(edge){x,y,w,b[x]};
    b[x]=tot;
}
  
void Add(int x,int y,int w)
{
    add(x,y,w);add(y,x,0);
}
  
void insert(int x,int y,int L,int R)
{
    out[x]+=L;in[y]+=L;
    if(R!=L) Add(x,y,R-L);
}
  
#define v a[i].y
bool bfs()
{
    queue&lt;int&gt; q;
    q.push(ssu);
    memset(dep,0,sizeof(dep));
    dep[ssu]=1;
    while(!q.empty()){
        int x=q.front();
        q.pop();
        for(int i=b[x];i;i=a[i].last){
            if(!dep[v]&amp;&amp;a[i].w&gt;0){
                dep[v]=dep[x]+1;
                if(v==ssv) return 1;
                q.push(v);
            }
        }
    }
    return dep[ssv]!=0;
}
   
int Dinic(int x,int flow)
{
    if(x==ssv) return flow;
    int remain=flow;
    for(int i=b[x];i;i=a[i].last){
        if(!remain) break;
        if(dep[v]==dep[x]+1&amp;&amp;a[i].w&gt;0){
            int tmp=Dinic(v,min(a[i].w,remain));
            if(!tmp){
                dep[v]=0;
                continue;
            }
            a[i].w-=tmp;
            a[i^1].w+=tmp;
            remain-=tmp;
        }
    }
    return flow-remain;
}
  
bool check(int mid)
{
    memset(b,0,sizeof(b));
    memset(in,0,sizeof(in));
    memset(out,0,sizeof(out));
    tot=1;
    for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++) insert(i,j+n,l,r);
    for(int i=1;i&lt;=n;i++){
        int L=max(0,hang[i]-mid),R=hang[i]+mid;
        L=max(L,m*l);
        if(L&gt;R) continue;
        insert(su,i,L,R);
    }
    for(int i=1;i&lt;=m;i++){
        int L=max(0,lie[i]-mid),R=lie[i]+mid;
        L=max(L,n*l);
        if(L&gt;R) continue;
        insert(i+n,sv,L,R);
    }
    int sum=0,tmp,ans=0;
    for(int i=0;i&lt;=n+m+1;i++){
        if(in[i]&gt;out[i]) Add(ssu,i,in[i]-out[i]),sum+=(in[i]-out[i]);
        else if(in[i]&lt;out[i]) Add(i,ssv,out[i]-in[i]);
    }
    Add(sv,su,INF);
    while(bfs()){
        while(tmp=Dinic(ssu,INF)) ans+=tmp;
    }
    return ans&gt;=sum;
}
  
int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    sv=n+m+1;ssu=n+m+2,ssv=n+m+3;
    for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++){
        scanf(&quot;%d&quot;,&amp;w[i][j]);
    }
    scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
    for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++) hang[i]+=w[i][j],lie[j]+=w[i][j];
    int L=0,R=2000000,ans;
    while(L&lt;=R){
        int mid=L+R&gt;&gt;1;
        if(check(mid)){
            ans=mid;
            R=mid-1;
        }else{
            L=mid+1;
        }
    }
    printf(&quot;%d\n&quot;,ans);
    return 0;
}
<pre><h2>Problem2406</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
  
#define maxn 410
#define INF 0x7fffffff
  
using namespace std;
  
int n,m,l,r,su,sv,ssu,ssv,dep[maxn],tot,b[maxn],out[maxn],in[maxn],hang[maxn],lie[maxn];
int w[maxn][maxn];
  
struct edge{
    int x,y,w,last;
}a[maxn*maxn&lt;&lt;3];
  
void add(int x,int y,int w)
{
    a[++tot]=(edge){x,y,w,b[x]};
    b[x]=tot;
}
  
void Add(int x,int y,int w)
{
    add(x,y,w);add(y,x,0);
}
  
void insert(int x,int y,int L,int R)
{
    out[x]+=L;in[y]+=L;
    if(R!=L) Add(x,y,R-L);
}
  
#define v a[i].y
bool bfs()
{
    queue&lt;int&gt; q;
    q.push(ssu);
    memset(dep,0,sizeof(dep));
    dep[ssu]=1;
    while(!q.empty()){
        int x=q.front();
        q.pop();
        for(int i=b[x];i;i=a[i].last){
            if(!dep[v]&amp;&amp;a[i].w&gt;0){
                dep[v]=dep[x]+1;
                if(v==ssv) return 1;
                q.push(v);
            }
        }
    }
    return dep[ssv]!=0;
}
   
int Dinic(int x,int flow)
{
    if(x==ssv) return flow;
    int remain=flow;
    for(int i=b[x];i;i=a[i].last){
        if(!remain) break;
        if(dep[v]==dep[x]+1&amp;&amp;a[i].w&gt;0){
            int tmp=Dinic(v,min(a[i].w,remain));
            if(!tmp){
                dep[v]=0;
                continue;
            }
            a[i].w-=tmp;
            a[i^1].w+=tmp;
            remain-=tmp;
        }
    }
    return flow-remain;
}
  
bool check(int mid)
{
    memset(b,0,sizeof(b));
    memset(in,0,sizeof(in));
    memset(out,0,sizeof(out));
    tot=1;
    for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++) insert(i,j+n,l,r);
    for(int i=1;i&lt;=n;i++){
        int L=max(0,hang[i]-mid),R=hang[i]+mid;
        L=max(L,m*l),min(R,r*m);;
        if(L&gt;R) continue;
        insert(su,i,L,R);
    }
    for(int i=1;i&lt;=m;i++){
        int L=max(0,lie[i]-mid),R=lie[i]+mid;
        L=max(L,n*l),min(R,r*m);;
        if(L&gt;R) continue;
        insert(i+n,sv,L,R);
    }
    int sum=0,tmp,ans=0;
    for(int i=0;i&lt;=n+m+1;i++){
        if(in[i]&gt;out[i]) Add(ssu,i,in[i]-out[i]),sum+=(in[i]-out[i]);
        else if(in[i]&lt;out[i]) Add(i,ssv,out[i]-in[i]);
    }
    Add(sv,su,INF);
    while(bfs()){
        while(tmp=Dinic(ssu,INF)) ans+=tmp;
    }
    return ans&gt;=sum;
}
  
int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    sv=n+m+1;ssu=n+m+2,ssv=n+m+3;
    for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++){
        scanf(&quot;%d&quot;,&amp;w[i][j]);
    }
    scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
    for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++) hang[i]+=w[i][j],lie[j]+=w[i][j];
    int L=0,R=2000000,ans;
    while(L&lt;=R){
        int mid=L+R&gt;&gt;1;
        if(check(mid)){
            ans=mid;
            R=mid-1;
        }else{
            L=mid+1;
        }
    }
    printf(&quot;%d\n&quot;,ans);
    return 0;
}
<pre><h2>Problem2406</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
 
#define maxn 410
#define INF 0x7fffffff
 
using namespace std;
 
int n,m,l,r,su,sv,ssu,ssv,dep[maxn],tot,b[maxn],out[maxn],in[maxn],hang[maxn],lie[maxn];
int w[maxn][maxn];
 
struct edge{
    int x,y,w,last;
}a[maxn*maxn&lt;&lt;3];
 
void add(int x,int y,int w)
{
    a[++tot]=(edge){x,y,w,b[x]};
    b[x]=tot;
}
 
void Add(int x,int y,int w)
{
    add(x,y,w);add(y,x,0);
}
 
void insert(int x,int y,int L,int R)
{
    out[x]+=L;in[y]+=L;
    if(L!=R)Add(x,y,R-L);
}
 
#define v a[i].y
bool bfs()
{
    queue&lt;int&gt; q;
    q.push(ssu);
    memset(dep,0,sizeof(dep));
    dep[ssu]=1;
    while(!q.empty()){
        int x=q.front();
        q.pop();
        for(int i=b[x];i;i=a[i].last){
            if(!dep[v]&amp;&amp;a[i].w&gt;0){
                dep[v]=dep[x]+1;
                if(v==ssv) return 1;
                q.push(v);
            }
        }
    }
    return dep[ssv]!=0;
}
  
int Dinic(int x,int flow)
{
    if(x==ssv) return flow;
    int remain=flow;
    for(int i=b[x];i;i=a[i].last){
        if(!remain) break;
        if(dep[v]==dep[x]+1&amp;&amp;a[i].w&gt;0){
            int tmp=Dinic(v,min(a[i].w,remain));
            if(!tmp){
                dep[v]=0;
                continue;
            }
            a[i].w-=tmp;
            a[i^1].w+=tmp;
            remain-=tmp;
        }
    }
    return flow-remain;
}
 
bool check(int mid)
{
    memset(b,0,sizeof(b));
    memset(in,0,sizeof(in));
    memset(out,0,sizeof(out));
    tot=1;
    for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++) insert(i,j+n,l,r);
    for(int i=1;i&lt;=n;i++){
        int L=max(0,hang[i]-mid),R=hang[i]+mid;
        L=max(L,m*l);
        if(L&gt;R) continue;
        insert(su,i,L,R);
    }
    for(int i=1;i&lt;=m;i++){
        int L=max(0,lie[i]-mid),R=lie[i]+mid;
        L=max(L,n*l);
        if(L&gt;R) continue;
        insert(i+n,sv,L,R);
    }
    int sum=0,tmp,ans=0;
    for(int i=0;i&lt;=n+m+1;i++){
        if(in[i]&gt;out[i]) Add(ssu,i,in[i]-out[i]),sum+=(in[i]-out[i]);
        else if(in[i]&lt;out[i]) Add(i,ssv,out[i]-in[i]);
    }
    Add(sv,su,INF);
    while(bfs()){
        while(tmp=Dinic(ssu,INF)) ans+=tmp;
    }
    return ans&gt;=sum;
}
 
int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    sv=n+m+1;ssu=n+m+2,ssv=n+m+3;
    for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++){
        scanf(&quot;%d&quot;,&amp;w[i][j]);
    }
    scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
    for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++) hang[i]+=w[i][j],lie[j]+=w[i][j];
    int L=0,R=2000000,ans=0;
    while(L&lt;=R){
        int mid=L+R&gt;&gt;1;
        if(check(mid)){
            ans=mid;
            R=mid-1;
        }else{
            L=mid+1;
        }
    }
    printf(&quot;%d\n&quot;,ans);
    return 0;
}<pre><h2>Problem2406</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
 
#define maxn 410
#define INF 0x7fffffff
 
using namespace std;
 
int n,m,l,r,su,sv,ssu,ssv,dep[maxn],tot,b[maxn],out[maxn],in[maxn],hang[maxn],lie[maxn];
int w[maxn][maxn];
 
struct edge{
    int x,y,w,last;
}a[maxn*maxn&lt;&lt;3];
 
void add(int x,int y,int w)
{
    a[++tot]=(edge){x,y,w,b[x]};
    b[x]=tot;
}
 
void Add(int x,int y,int w)
{
    add(x,y,w);add(y,x,0);
}
 
void insert(int x,int y,int L,int R)
{
    out[x]+=L;in[y]+=L;
    Add(x,y,R-L);
}
 
#define v a[i].y
bool bfs()
{
    queue&lt;int&gt; q;
    q.push(ssu);
    memset(dep,0,sizeof(dep));
    dep[ssu]=1;
    while(!q.empty()){
        int x=q.front();
        q.pop();
        for(int i=b[x];i;i=a[i].last){
            if(!dep[v]&amp;&amp;a[i].w&gt;0){
                dep[v]=dep[x]+1;
                if(v==ssv) return 1;
                q.push(v);
            }
        }
    }
    return dep[ssv]!=0;
}
  
int Dinic(int x,int flow)
{
    if(x==ssv) return flow;
    int remain=flow;
    for(int i=b[x];i;i=a[i].last){
        if(!remain) break;
        if(dep[v]==dep[x]+1&amp;&amp;a[i].w&gt;0){
            int tmp=Dinic(v,min(a[i].w,remain));
            if(!tmp){
                dep[v]=0;
                continue;
            }
            a[i].w-=tmp;
            a[i^1].w+=tmp;
            remain-=tmp;
        }
    }
    return flow-remain;
}
 
bool check(int mid)
{
    memset(b,0,sizeof(b));
    memset(in,0,sizeof(in));
    memset(out,0,sizeof(out));
    tot=1;
    for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++) insert(i,j+n,l,r);
    for(int i=1;i&lt;=n;i++){
        int L=max(0,hang[i]-mid),R=hang[i]+mid;
        L=max(L,m*l);
        if(L&gt;R) continue;
        insert(su,i,L,R);
    }
    for(int i=1;i&lt;=m;i++){
        int L=max(0,lie[i]-mid),R=lie[i]+mid;
        L=max(L,n*l);
        if(L&gt;R) continue;
        insert(i+n,sv,L,R);
    }
    int sum=0,tmp,ans=0;
    for(int i=0;i&lt;=n+m+1;i++){
        if(in[i]&gt;out[i]) Add(ssu,i,in[i]-out[i]),sum+=(in[i]-out[i]);
        else if(in[i]&lt;out[i]) Add(i,ssv,out[i]-in[i]);
    }
    Add(sv,su,INF);
    while(bfs()){
        while(tmp=Dinic(ssu,INF)) ans+=tmp;
    }
    return ans&gt;=sum;
}
 
int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    sv=n+m+1;ssu=n+m+2,ssv=n+m+3;
    for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++){
        scanf(&quot;%d&quot;,&amp;w[i][j]);
    }
    scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
    for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++) hang[i]+=w[i][j],lie[j]+=w[i][j];
    int L=0,R=2000000,ans;
    while(L&lt;=R){
        int mid=L+R&gt;&gt;1;
        if(check(mid)){
            ans=mid;
            R=mid-1;
        }else{
            L=mid+1;
        }
    }
    printf(&quot;%d\n&quot;,ans);
    return 0;
}<pre><h2>Problem2406</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
 
#define maxn 410
#define INF 0x7fffffff
 
using namespace std;
 
int n,m,l,r,su,sv,ssu,ssv,dep[maxn],tot,b[maxn],out[maxn],in[maxn],hang[maxn],lie[maxn];
int w[maxn][maxn];
 
struct edge{
    int x,y,w,last;
}a[maxn*maxn&lt;&lt;3];
 
void add(int x,int y,int w)
{
    a[++tot]=(edge){x,y,w,b[x]};
    b[x]=tot;
}
 
void Add(int x,int y,int w)
{
    add(x,y,w);add(y,x,0);
}
 
void insert(int x,int y,int L,int R)
{
    out[x]+=L;in[y]+=L;
    Add(x,y,R-L);
}
 
#define v a[i].y
bool bfs()
{
    queue&lt;int&gt; q;
    q.push(ssu);
    memset(dep,0,sizeof(dep));
    dep[ssu]=1;
    while(!q.empty()){
        int x=q.front();
        q.pop();
        for(int i=b[x];i;i=a[i].last){
            if(!dep[v]&amp;&amp;a[i].w&gt;0){
                dep[v]=dep[x]+1;
                if(v==ssv) return 1;
                q.push(v);
            }
        }
    }
    return dep[ssv]!=0;
}
  
int Dinic(int x,int flow)
{
    if(x==ssv) return flow;
    int remain=flow;
    for(int i=b[x];i;i=a[i].last){
        if(!remain) break;
        if(dep[v]==dep[x]+1&amp;&amp;a[i].w&gt;0){
            int tmp=Dinic(v,min(a[i].w,remain));
            if(!tmp){
                dep[v]=0;
                continue;
            }
            a[i].w-=tmp;
            a[i^1].w+=tmp;
            remain-=tmp;
        }
    }
    return flow-remain;
}
 
bool check(int mid)
{
    memset(b,0,sizeof(b));
    memset(in,0,sizeof(in));
    memset(out,0,sizeof(out));
    tot=1;
    for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++) insert(i,j+n,l,r);
    for(int i=1;i&lt;=n;i++){
        int L=max(0,hang[i]-mid),R=hang[i]+mid;
        //L=max(L,m*l);
        //if(L&gt;R) continue;
        insert(su,i,L,R);
    }
    for(int i=1;i&lt;=m;i++){
        int L=max(0,lie[i]-mid),R=lie[i]+mid;
        //L=max(L,n*l);
        //if(L&gt;R) continue;
        insert(i+n,sv,L,R);
    }
    int sum=0,tmp,ans=0;
    for(int i=0;i&lt;=n+m+1;i++){
        if(in[i]&gt;out[i]) Add(ssu,i,in[i]-out[i]),sum+=(in[i]-out[i]);
        else if(in[i]&lt;out[i]) Add(i,ssv,out[i]-in[i]);
    }
    Add(sv,su,INF);
    while(bfs()){
        while(tmp=Dinic(ssu,INF)) ans+=tmp;
    }
    return ans&gt;=sum;
}
 
int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    sv=n+m+1;ssu=n+m+2,ssv=n+m+3;
    for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++){
        scanf(&quot;%d&quot;,&amp;w[i][j]);
    }
    scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
    for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++) hang[i]+=w[i][j],lie[j]+=w[i][j];
    int L=0,R=2000000,ans;
    while(L&lt;=R){
        int mid=L+R&gt;&gt;1;
        if(check(mid)){
            ans=mid;
            R=mid-1;
        }else{
            L=mid+1;
        }
    }
    printf(&quot;%d\n&quot;,ans);
    return 0;
}<pre><h2>Problem2425</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
int num[55];
int len;
LL C[55][55];
char s[55];
inline LL work(int x)
{
	LL res=1;
	for (int i=0;i&lt;=9;i++)
	{
		res*=C[x][num[i]];
		x-=num[i];
	}
	return res;
}
int main()
{
	scanf(&quot;%s&quot;,s+1);
	len=strlen(s+1);
	int i,j;
	for (i=1;i&lt;=len;i++) num[s[i]-'0']++;
	C[0][0]=1;
	for (i=1;i&lt;=50;i++)
	{
		C[i][0]=1;
		for (j=1;j&lt;=50;j++)
			C[i][j]=C[i-1][j]+C[i-1][j-1];
	}
	LL ans=0;
	for (i=1;i&lt;=len;i++)
	{
		if (s[i]=='0') {num[0]--;continue;}
		for (j=0;j&lt;s[i]-'0';j++) if (num[j])
		{
			num[j]--;
			ans+=work(len-i);
			num[j]++;
		}
		num[s[i]-'0']--;
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem2431</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define mo 10000
#define ln printf(&quot;\n&quot;)
int f[1005],sum[1005];
int n,K;
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	int i,j;
	for (i=0;i&lt;=K;i++) sum[i]=1;
	for (i=2;i&lt;=n;i++)
	{
		//printf(&quot;\n-----------------------------------------------------\n&quot;);
		for (j=0;j&lt;=K;j++)
		{
			if (j&gt;=i)
			{
				f[j]=sum[j]-sum[j-i];
				if (f[j]&lt;0) f[j]+=mo;
			}
			else f[j]=sum[j];
		}
		//for (j=0;j&lt;=K;j++)printf(&quot;%d &quot;,f[j]);ln;
		sum[0]=f[0];
		for (j=1;j&lt;=K;j++)
		{
			sum[j]=sum[j-1]+f[j];
			if (sum[j]&gt;=mo) sum[j]-=mo;
		}
	}
	printf(&quot;%d\n&quot;,f[K]);
	return 0;
}<pre><h2>Problem2431</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define mo 10000
int f[1005],sum[1005];
int n,K;
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	int i,j;
	for (i=0;i&lt;=K;i++) sum[i]=1;
	for (i=2;i&lt;=n;i++)
	{
		for (j=0;j&lt;=K;j++)
		{
			if (j&gt;=i)
			{
				f[j]=sum[j]-sum[j-i];
				if (f[j]&lt;0) f[j]+=mo;
			}
			else f[j]=sum[j];
		}
		sum[0]=f[0];
		for (j=1;j&lt;=K;j++)
		{
			sum[j]=sum[j-1]+f[j];
			if (sum[j]&gt;=mo) sum[j]-=mo;
		}
	}
	printf(&quot;%d\n&quot;,f[K]);
	return 0;
}<pre><h2>Problem2434</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
#define NN 1100000
#define pb push_back
#define lowbit(i) (i&amp;-i)
int son[NN][26],fail[NN],begin[NN],end[NN],pos[NN],o[NN],aa[NN*2][2],s[NN],q[NN],c[NN],ans[NN],fa[NN];
int m,TTT,tot,cnt;
bool flag[NN][26];
vector&lt;int&gt; a[NN],id[NN];
void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void buildfail()
{
	int head=0,tail=1,i;
	q[1]=1;
	while (head&lt;tail)
	{
		int x=q[++head];
		addedge(fail[x],x);
		for (i=0;i&lt;=25;i++)
			if (son[x][i]==0) son[x][i]=son[fail[x]][i];
			else
			{
				fail[son[x][i]]=son[fail[x]][i];
				q[++tail]=son[x][i];
			}
	}
}
void dfs(int v)
{
	begin[v]=++cnt;
	for (int p=o[v];p;p=aa[p][0]) dfs(aa[p][1]);
	end[v]=cnt;
}
void change(int i,int x)
{
	//printf(&quot;change %d %d\n&quot;,i,x);
	if (i==0) return;
	for (;i&lt;=cnt;i+=lowbit(i)) c[i]+=x;
}
int getsum(int i)
{
	//printf(&quot;getsum %d\n&quot;,i);
	int res=0;
	for (;i;i-=lowbit(i)) res+=c[i];
	return res;
}
void dfs2(int v)
{
	int i,tmp;
	change(begin[v],1);
	for (i=0;i&lt;a[v].size();i++)
	{
		tmp=a[v][i];
		ans[id[v][i]]=getsum(end[tmp])-getsum(begin[tmp]-1);
	}
	for (i=0;i&lt;=25;i++)
		if (flag[v][i]) dfs2(son[v][i]);
	change(begin[v],-1);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int len,i,x,y,num,now,cc;
	for (i=0;i&lt;=25;i++) son[0][i]=1,flag[0][i]=true,son[1][i]=0;
	TTT=1;
	char ch;
	for (len=num=0,now=1,scanf(&quot;%c&quot;,&amp;ch),cc=ch-'a';ch!='\n';scanf(&quot;%c&quot;,&amp;ch),cc=ch-'a')
		if (ch=='P') pos[++num]=now;
		else if (ch=='B') now=fa[now];
		else
			if (son[now][cc]) now=son[now][cc];
			else
			{
				son[now][cc]=++TTT;
				fa[TTT]=now;
				flag[now][cc]=true;
				now=son[now][cc];
				for (i=0;i&lt;=25;i++) son[now][i]=0;
			}
	//for (i=1;i&lt;=TTT;i++){for (int j=0;j&lt;=25;j++) printf(&quot;%d &quot;,son[i][j]);printf(&quot;\n&quot;);}
	//printf(&quot;%d\n&quot;,TTT);
	buildfail();
	dfs(1);
	//for (i=0;i&lt;=TTT;i++) printf(&quot;%d %d\n&quot;,begin[i],end[i]);printf(&quot;\n&quot;);
	//printf(&quot;%d\n&quot;,TTT);
	scanf(&quot;%d&quot;,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		//printf(&quot;%d %d\n&quot;,pos[x],pos[y]);
		a[pos[y]].pb(pos[x]);
		id[pos[y]].pb(i);
	}
	dfs2(1);
	for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem2434</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
#define NN 110000
#define pb push_back
#define lowbit(i) (i&amp;-i)
int son[NN][26],fail[NN],begin[NN],end[NN],pos[NN],o[NN],aa[NN*2][2],s[NN],q[NN],c[NN],ans[NN],fa[NN];
int m,TTT,tot,cnt;
bool flag[NN][26];
vector&lt;int&gt; a[NN],id[NN];
void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void buildfail()
{
	int head=0,tail=1,i;
	q[1]=1;
	while (head&lt;tail)
	{
		int x=q[++head];
		addedge(fail[x],x);
		for (i=0;i&lt;=25;i++)
			if (son[x][i]==0) son[x][i]=son[fail[x]][i];
			else
			{
				fail[son[x][i]]=son[fail[x]][i];
				q[++tail]=son[x][i];
			}
	}
}
void dfs(int v)
{
	begin[v]=++cnt;
	for (int p=o[v];p;p=aa[p][0]) dfs(aa[p][1]);
	end[v]=cnt;
}
void change(int i,int x)
{
	//printf(&quot;change %d %d\n&quot;,i,x);
	if (i==0) return;
	for (;i&lt;=cnt;i+=lowbit(i)) c[i]+=x;
}
int getsum(int i)
{
	//printf(&quot;getsum %d\n&quot;,i);
	int res=0;
	for (;i;i-=lowbit(i)) res+=c[i];
	return res;
}
void dfs2(int v)
{
	int i,tmp;
	change(begin[v],1);
	for (i=0;i&lt;a[v].size();i++)
	{
		tmp=a[v][i];
		ans[id[v][i]]=getsum(end[tmp])-getsum(begin[tmp]-1);
	}
	for (i=0;i&lt;=25;i++)
		if (flag[v][i]) dfs2(son[v][i]);
	change(begin[v],-1);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int len,i,x,y,num,now,cc;
	for (i=0;i&lt;=25;i++) son[0][i]=1,flag[0][i]=true,son[1][i]=0;
	TTT=1;
	char ch;
	for (len=num=0,now=1,scanf(&quot;%c&quot;,&amp;ch),cc=ch-'a';ch!='\n';scanf(&quot;%c&quot;,&amp;ch),cc=ch-'a')
		if (ch=='P') pos[++num]=now;
		else if (ch=='B') now=fa[now];
		else
			if (son[now][cc]) now=son[now][cc];
			else
			{
				son[now][cc]=++TTT;
				fa[TTT]=now;
				flag[now][cc]=true;
				now=son[now][cc];
				for (i=0;i&lt;=25;i++) son[now][i]=0;
			}
	//for (i=1;i&lt;=TTT;i++){for (int j=0;j&lt;=25;j++) printf(&quot;%d &quot;,son[i][j]);printf(&quot;\n&quot;);}
	//printf(&quot;%d\n&quot;,TTT);
	buildfail();
	dfs(1);
	//for (i=0;i&lt;=TTT;i++) printf(&quot;%d %d\n&quot;,begin[i],end[i]);printf(&quot;\n&quot;);
	//printf(&quot;%d\n&quot;,TTT);
	scanf(&quot;%d&quot;,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		//printf(&quot;%d %d\n&quot;,pos[x],pos[y]);
		a[pos[y]].pb(pos[x]);
		id[pos[y]].pb(i);
	}
	dfs2(1);
	for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem2435</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const int NN=1001111;
int o[NN],aa[NN*2][3],q[NN],fa[NN],size[NN];
int n,tot;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline int abs(int x) {return x&gt;0?x:-x;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,x,y,z;
	read(n);
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y),read(z);
		addedge(x,y,z),addedge(y,x,z);
	}
	int head=0,tail=1;
	q[1]=1;
	while (head&lt;tail)
	{
		int x=q[++head];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[x]) continue;
			fa[y]=x;
			q[++tail]=y;
		}
	}
	for (i=1;i&lt;=n;i++) size[i]=1;
	for (i=n;i;i--) size[fa[q[i]]]+=size[q[i]];
	LL ans=0;
	for (i=1;i&lt;=n;i++)
		for (int p=o[i];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[i]) continue;
			ans+=(LL)aa[p][2]*abs(size[y]*2-n);
		}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem2440</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
int pr[101111],miu[1001111];
int prcnt,n,K,tes;
void shai()
{
	static bool vt[1001111];
	vt[1]=true;
	miu[1]=1;
	for (int i=2;i&lt;=1000000;i++)
	{
		if (!vt[i])
		{
			pr[++prcnt]=i;
			miu[i]=-1;
		}
		for (int j=1;j&lt;=prcnt;j++)
		{
			int x=i*pr[j];
			if (x&gt;1000000) break;
			vt[x]=true;
			if (i%pr[j]==0)
			{
				miu[x]=0;
				break;
			}
			miu[x]=-miu[i];
		}
	}
	//for (int i=1;i&lt;=10;i++) printf(&quot;miu[%d]=%d\n&quot;,i,miu[i]);ln;
}
LL calc(LL mid)
{
	LL res=0;
	for (LL i=2;i*i&lt;=mid;i++)
		res+=-mid/(i*i)*miu[i];
	return mid-res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	shai();
	//printf(&quot;%lld\n&quot;,calc(3));
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d&quot;,&amp;K);
		LL l=1,r=3000000000ll,res=0;
		while (l&lt;=r)
		{
			LL mid=(l+r)&gt;&gt;1;
			LL tmp=calc(mid);
			if (tmp&gt;=K) res=mid,r=mid-1;
			else l=mid+1;
		}
		printf(&quot;%lld\n&quot;,res);
	}
	return 0;
}<pre><h2>Problem2453</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#define N 10001
#define M 1000001
using namespace std;
int n,q,m,block;
int c[N],pos[N],pre[N],b[N],last[M];
int find(int x,int v)
{
	int l=(x-1)*block+1,r=min(x*block,n);
	int first=l;
	while(l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if(pre[mid]&lt;v)l=mid+1;
		else r=mid-1;
	}
	return l-first;
}
void reset(int x)
{
	int l=(x-1)*block+1,r=min(x*block,n);
	for(int i=l;i&lt;=r;i++)pre[i]=b[i];
	sort(pre+l,pre+r+1);
}
void build()
{
	for(int i=1;i&lt;=n;i++)
	{
		b[i]=last[c[i]];
		last[c[i]]=i;
		pos[i]=(i-1)/block+1;
	}
	for(int i=1;i&lt;=m;i++)reset(i);
}
int ask(int l,int r)
{
	int ans=0;
	if(pos[l]==pos[r])
	{
		for(int i=l;i&lt;=r;i++)if(b[i]&lt;l)ans++;
	}
	else 
	{
		for(int i=l;i&lt;=block*pos[l];i++)if(b[i]&lt;l)ans++;
		for(int i=block*(pos[r]-1)+1;i&lt;=r;i++)if(b[i]&lt;l)ans++;
	}
	for(int i=pos[l]+1;i&lt;pos[r];i++)
	    ans+=find(i,l);
	return ans;
}
void change(int x,int v)
{
	for(int i=1;i&lt;=n;i++)last[c[i]]=0;
	c[x]=v;
	for(int i=1;i&lt;=n;i++)
	{
		int t=b[i];
		b[i]=last[c[i]];
		if(t!=b[i])reset(pos[i]);
		last[c[i]]=i;
	}
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;q);
	for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;c[i]);
	block=int(sqrt(n)+log(2*n)/log(2));
	if(n%block)m=n/block+1;
	else m=n/block;
	build();
	char ch[5];int x,y;
	for(int i=1;i&lt;=q;i++)
	{
		scanf(&quot;%s%d%d&quot;,ch,&amp;x,&amp;y);
		if(ch[0]=='Q')printf(&quot;%d\n&quot;,ask(x,y));
		else change(x,y);
	}
	return 0;
}<pre><h2>Problem2453</h2><pre>#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define NN 10100
using namespace std;
int a[NN],num[NN],b[NN],pos[NN],w[NN],tmp[NN*100]={0};
int n,m,q,blk,sum;
bool f[10010];
 
inline int min(int a,int b){return (a&lt;b)?a:b;}
 
void reset(int i){
    int l=(i-1)*blk+1,r=min(l+blk-1,n);
    for (int i=l;i&lt;=r;i++)
        b[i]=a[i];
    sort(b+l,b+r+1);
}
 
int find(int l,int r,int x){
    while (l&lt;=r){
        int mid=l+r&gt;&gt;1;
        if (b[mid]&lt;x)l=mid+1;
        else r=mid-1;
    }
    return l-1;
}
 
int query(int x,int y){
    int L=pos[x],R=pos[y];
    int tt=R;
    int res=0;
    if (L==R){
        for (int i=x;i&lt;=y;i++)
            if (a[i]&lt;x)res++;
    }
    else{
        for (int i=x;pos[i]==L;i++)
            if (a[i]&lt;x)res++;
        for (int i=y;pos[i]==R;i--)
            if (a[i]&lt;x)res++;
        for (int i=L+1;i&lt;R;i++)
            res+=find((i-1)*blk+1,i*blk,x)-((i-1)*blk);
    }
    return res; 
}
 
 
void change(int x,int t){
    for (int i=1;i&lt;=n;i++)
    	tmp[num[i]]=0;
    memset(f,0,sizeof(f));
    num[x]=t;
    for (int i=1;i&lt;=n;i++){
        t=a[i];
        a[i]=tmp[num[i]];
        tmp[num[i]]=i;
        if (t!=a[i])f[pos[i]]=1;
    }
    for (int i=1;i&lt;=sum;i++)
        if (f[i])reset(i);
}
 
int main(){
	
    sum=scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    blk=sqrt(n);
    sum=n/blk;
    if (n%blk)sum++;
    memset(tmp,0,sizeof(tmp));
    for (int i=1;i&lt;=n;i++){
        scanf(&quot;%d&quot;,&amp;num[i]);
        a[i]=tmp[num[i]];
        tmp[num[i]]=i;
        pos[i]=(i-1)/blk+1;
    }
    for (int i=1;i&lt;=sum;i++)
        reset(i);
    char s[10];
    int x,y;
    for (int i=1;i&lt;=m;i++){
        scanf(&quot;%s%d%d\n&quot;,s,&amp;x,&amp;y);
        if (s[0]=='R')change(x,y);
        else printf(&quot;%d\n&quot;,query(x,y));
    }
    return 0;
}<pre><h2>Problem2456</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int n;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int x=-1,num=0,i,y;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;y);
		if (y==x) num++;
		else if (num==0) x=y,num=1;
		else num--;
	}
	printf(&quot;%d\n&quot;,x);
	return 0;
}<pre><h2>Problem2458</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
#define sqr(x) ((x)*(x))
#define ln printf(&quot;\n&quot;)
const DD dinf=1e30;
const int NN=201111;
int id[NN],id2[NN],b[NN];
int n;
struct point
{
	DD x,y;
	void in() {scanf(&quot;%lf%lf&quot;,&amp;x,&amp;y);}
	void out() {printf(&quot;%.3f %.3f\n&quot;,x,y);}
} q[NN];
inline bool cmp(const int &amp;a,const int &amp;b) {return q[a].x&lt;q[b].x;}
inline DD dis(point a,point b)
{
	return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));
}
DD work(int l,int r)
{
	if (l==r) return dinf;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	DD X=(q[id[mid]].x+q[id[mid+1]].x)*0.5;
	DD res=min(work(l,mid),work(mid+1,r));
	//printf(&quot;\n-------------------------- work %d %d ---------------------------------\n&quot;,l,r);
	//printf(&quot;res=%.3f X=%3f\n&quot;,res,X);
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if ((i&lt;=mid&amp;&amp;q[id[i]].y&lt;q[id[j]].y)||j&gt;r) id2[k]=id[i++];
		else id2[k]=id[j++];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
	//for (i=l;i&lt;=r;i++) printf(&quot;%d &quot;,id[i]);ln;
	int cnt=0;
	for (i=l;i&lt;=r;i++)
	{
		int t=id[i];
		if (abs(q[t].x-X)&gt;=res*0.5) continue;
		//printf(&quot;t=%d\n&quot;,t);
		for (j=cnt;q[t].y-q[b[j]].y&lt;res*0.5&amp;&amp;j;j--)
			for (k=j-1;q[b[j]].y-q[b[k]].y&lt;res*0.5&amp;&amp;k;k--)
				res=min(res,dis(q[t],q[b[j]])+dis(q[t],q[b[k]])+dis(q[b[j]],q[b[k]]));
		b[++cnt]=t;
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i;
	for (i=1;i&lt;=n;i++) q[i].in();
	//printf(&quot;q:\n&quot;);for(i=1;i&lt;=n;i++)q[i].out();ln;
	for (i=1;i&lt;=n;i++) id[i]=i;
	sort(id+1,id+n+1,cmp);
	//printf(&quot;id &quot;);for(i=1;i&lt;=n;i++) printf(&quot;%d &quot;,id[i]);ln;ln;
	printf(&quot;%.6f\n&quot;,work(1,n));
	return 0;
}<pre><h2>Problem2460</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define fi first
#define se second
int n;
LL temp[71];
pair&lt;int,LL&gt; a[1011];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j;
	for (i=1;i&lt;=n;i++)
		scanf(&quot;%lld%d&quot;,&amp;a[i].se,&amp;a[i].fi);
	sort(a+1,a+n+1);
	reverse(a+1,a+n+1);
	int ans=0;
	for (i=1;i&lt;=n;i++)
	{
		for (j=63;j;j--)
			if (a[i].se&amp;(1ll&lt;&lt;(j-1)))
			{
				if (temp[j]==0)
				{
					temp[j]=a[i].se;
					ans+=a[i].fi;
					break;
				}
				else a[i].se^=temp[j];
			}
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem2460</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define fi first
#define se second
int n;
LL temp[71];
pair&lt;int,LL&gt; a[1011];
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	int i,j;
	for (i=1;i&lt;=n;i++)
		scanf(&quot;%lld%d&quot;,&amp;a[i].se,&amp;a[i].fi);
	sort(a+1,a+n+1);
	reverse(a+1,a+n+1);
	int ans=0;
	for (i=1;i&lt;=n;i++)
	{
		for (j=63;j;j--)
			if (a[i].se&amp;(1ll&lt;&lt;(j-1)))
			{
				if (temp[j]==0)
				{
					temp[j]=a[i].se;
					ans+=a[i].fi;
					break;
				}
				else a[i].se^=temp[j];
			}
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem2463</h2><pre>#include&lt;cstdio&gt;
using namespace std;

int main()
{
	int n;
	for (;;)
	{
		scanf(&quot;%d&quot;,&amp;n);
		if (n==0) break;
		printf((n&amp;1)?&quot;Bob\n&quot;:&quot;Alice\n&quot;);
	}
	return 0;
}<pre><h2>Problem2466</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;bitset&gt;
using namespace std;
#define inf 999999999
const int NN=105;
int n,cnt,b[NN],X[NN];
bitset&lt;NN&gt; a[NN];
bool flag[NN];
void gause()
{
	int i,j;
	for (i=1;i&lt;n;i++)
	{
		for (j=i;j&lt;=n;j++)
			if (a[j][i]==1) break;
		if (j==n+1)
		{
			flag[i]=true;
			b[++cnt]=i;
			continue;
		}
		if (j!=i) swap(a[i],a[j]);
		for (j=i+1;j&lt;=n;j++)
			if (a[j][i]) a[j]^=a[i];
	}
	if (a[n][n]==0)
		flag[n]=true,b[++cnt]=n;
}
int calc()
{
	int res=0;
	for (int i=n;i;i--)
	{
		if (!flag[i])
		{
			int tmp=0;
			for (int j=i+1;j&lt;=n;j++)
				if (a[i][j]) tmp^=X[j];
			X[i]=a[i][n+1]^tmp;
		}
		res+=X[i];
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (;;)
	{
		scanf(&quot;%d&quot;,&amp;n);
		if (n==0) break;
		int i,x,y;
		for (i=1;i&lt;=n;i++)
		{
			a[i].reset();
			a[i][i]=a[i][n+1]=1;
			flag[i]=false;
		}
		for (i=1;i&lt;n;i++)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			a[x][y]=a[y][x]=1;
		}
		cnt=0;
		gause();
		int ans=inf;
		for (int S=0;S&lt;1&lt;&lt;cnt;S++)
		{
			for (i=1;i&lt;=cnt;i++)
				if (S&amp;(1&lt;&lt;(i-1))) X[b[i]]=1;
				else X[b[i]]=0;
			ans=min(ans,calc());
		}
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem2467</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define mo 2007
int tes,n;
inline int ksm(int a,int b)
{
	int res=1;
	for (;b;b&gt;&gt;=1,a=a*a%mo)
		if (b&amp;1) res=res*a%mo;
	return res;
}
int main()
{
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		int ans=n*4*ksm(5,n-1)%mo;
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem2476</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mo 987654321
typedef long long LL;
int n;
struct matrix
{
	LL m[2][2];
	matrix() {memset(m,0,sizeof(m));} 
	LL * operator [](int x) {return m[x];}
	void out() {printf(&quot;%I64d %I64d\n%I64d %I64d\n&quot;,m[0][0],m[0][1],m[1][0],m[1][1]);}
	friend matrix operator *(matrix a,matrix b)
	{
		matrix c;
		for (int k=0;k&lt;2;k++)
			for (int i=0;i&lt;2;i++)
				for (int j=0;j&lt;2;j++)
					c[i][j]=(c[i][j]+a[i][k]*b[k][j])%mo;
		return c;
	}
	friend matrix operator ^(matrix a,int b)
	{
		matrix res;
		res[0][0]=res[1][1]=1;
		for (;b;b&gt;&gt;=1,a=a*a)
			if (b&amp;1) res=res*a;
		return res;
	}
};
int work(int n)
{
	n&gt;&gt;=1;
	matrix a,ans;
	a[0][0]=0,a[1][0]=1,a[0][1]=-1,a[1][1]=3;
	a=a^(n-5);
	ans[0][0]=5,ans[0][1]=13;
	//ans.out(),a.out();
	ans=ans*a;
	LL tmp=ans[0][1];
	tmp=(tmp-(n-1))%mo;
	if (tmp&lt;0) tmp+=mo;
	return tmp;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (;;)
	{
		scanf(&quot;%d&quot;,&amp;n);
		if (!n) break;
		if (n&lt;=7||n&amp;1) printf(&quot;0\n&quot;);
		else if (n==8) printf(&quot;%d\n&quot;,2);
		else printf(&quot;%d\n&quot;,work(n));
	}
	return 0;
}<pre><h2>Problem2480</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
using namespace std;
typedef long long LL;

inline LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (a%=c;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
LL gcd(LL a,LL b) {return !b?a:gcd(b,a%b);}
LL getphi(LL n)
{
	LL res=1;
	for (int i=2;i*i&lt;=n;i++) if (n%i==0)
	{
		res*=i-1;
		for (n/=i;n%i==0;n/=i) res*=i;
	}
	if (n&gt;1) res*=n-1;
	return res;
}
struct HT
{
	#define mod 1000007
	int tot,TIME,o[mod],vt[mod],aa0[1000000],f[1000000];
	LL aa1[1000000];
	void clear() {TIME++;tot=0;}
	void insert(LL x,int i)
	{
		int t=x%mod;
		if (vt[t]!=TIME) vt[t]=TIME,o[t]=0;
		for (int p=o[t];p;p=aa0[p])
			if (aa1[p]==x)
			{
				if (i&lt;f[p]) f[p]=i;
				return;
			}
		tot++;aa1[tot]=x;aa0[tot]=o[t];
		o[t]=tot;f[tot]=i;
	}
	int find(LL x)
	{
		int t=x%mod;
		if (vt[t]!=TIME) vt[t]=TIME,o[t]=0;
		for (int p=o[t];p;p=aa0[p])
			if (aa1[p]==x) return f[p];
		return -1;
	}
} ht;
LL bsgs(LL A,LL B,LL P,LL phi)
{
	A%=P,B%=P;
	int blo=(int)sqrt(P)+1,i;
	LL tmp=1;
	ht.clear();
	for (i=0;i&lt;blo;i++,tmp=tmp*A%P)
		ht.insert(tmp,i);
	LL t=1;
	for (i=0;i&lt;P;i+=blo,t=t*tmp%P)
	{
		if (t==0)
		{
			if (B==0) return i;
			return -1;
		}
		LL res=ht.find(B*ksm(t,phi-1,P)%P);
		if (res!=-1) return i+res;
	}
	return -1;
}
LL extbsgs(LL A,LL B,LL P)
{
	A%=P,B%=P;
	LL tmp=1;
	for (int i=0;i&lt;=29;i++,tmp=tmp*A%P)
		if (tmp==B) return i;
	LL t=gcd(tmp,P);
	if (B%t) return -1;
	LL phi=getphi(P/t);
	LL res=bsgs(A,B/t*ksm(tmp/t,phi-1,P/t),P/t,phi);
	if (res!=-1) return res+30;
	else return -1;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	LL a,b,p;
	for (;;)
	{
		scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;p,&amp;b);
		if (!a&amp;&amp;!b&amp;&amp;!p) break;
		LL ans=extbsgs(a,b,p);
		if (ans==-1) printf(&quot;No Solution\n&quot;);
		else printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem2480</h2><pre>#include&lt;stdio.h&gt;//A^x=B(mod C)
#include&lt;math.h&gt;
#include&lt;string.h&gt;
#define ll long long
inline int phi(int C){
	int ans=C;
	for(int i=2,r=sqrt(C)+0.01;i&lt;=r;++i)
	    if(!(C%i)){
			ans=ans/i*(i-1);
			while(!(C%i)) C/=i;
	    }
	if(C!=1) ans=ans/C*(C-1);
	return ans;
}
inline ll POW(ll x,ll y,ll mod){
	for(ll z=1;;x=x*x%mod,y&gt;&gt;=1)
	    if(y&amp;1) z=z*x%mod;
	    else if(!y) return z;
}
inline int GCD(int a,int b){
	for(int c;b;c=b,b=a%b,a=c);
	return a;
}
inline void EXGCD(ll a,ll b,ll &amp;x,ll &amp;y){
	if(!b){x=1,y=0;return;}
	else EXGCD(b,a%b,y,x),y-=a/b*x;
}
int cnt,hash[100007],num[100007],ci[100007];
inline void add(int x,int shu){
	int pos=x%100007;
	while(hash[pos]&amp;&amp;num[hash[pos]]!=x) pos=(pos+1)%100007;
	if(num[hash[pos]]==x&amp;&amp;ci[hash[pos]]&gt;shu) ci[hash[pos]]=shu;
	if(!hash[pos]) hash[pos]=++cnt,num[cnt]=x,ci[cnt]=shu;
}
inline int find(int x){
	int pos=x%100007;
	while(hash[pos]&amp;&amp;num[hash[pos]]!=x) pos=(pos+1)%100007;
	if(hash[pos]) return ci[hash[pos]];
	return -1;
}
inline int BSGS(int A,int B,int C){
	ll i,j,k,m=sqrt(C)+1,x,y;
	cnt=0,memset(hash,0,sizeof(hash));
	for(i=0,j=1;i&lt;m;++i,j=j*A%C) add(j,i);
	for(i=0,k=1;i&lt;m;++i,k=k*j%C){
		EXGCD(k,C,x,y);
		x=(x*B%C+C)%C;
		if(~(x=find(x))) return i*m+x;
	}
	return -1;
}
inline int EXBSGS(int A,int B,int C){
	ll tip,du,cnt=0,D=1;
	for(du=0,tip=C;tip;++du,tip&gt;&gt;=1);
	for(ll i=0,j=1;i&lt;=du;++i,j=j*A%C)
	    if(j==B) return i;
	while((tip=GCD(A,C))!=1){
		if(B%tip) return -1;
		++cnt,B/=tip,C/=tip,D=D*A/tip%C;
	}
	B=B*POW(D,phi(C)-1,C)%C;
	if(~(tip=BSGS(A%C,B,C))) return tip+cnt;
	return -1;
}
int main(){
	int A,B,C,ANS;
	for(scanf(&quot;%d%d%d&quot;,&amp;A,&amp;C,&amp;B);A&amp;&amp;B&amp;&amp;C;scanf(&quot;%d%d%d&quot;,&amp;A,&amp;C,&amp;B)){
		if(~(ANS=EXBSGS(A%C,B,C))) printf(&quot;%d\n&quot;,ANS);
		else puts(&quot;No Solution&quot;);
	}
}
<pre><h2>Problem2500</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define maa(a,b) (a&gt;b?a:b)
#define ln printf(&quot;\n&quot;)
typedef long long LL;
const int NN=1001111;
int o[NN],aa[NN*2][3],fa[NN],n,m,tot=1;
LL f[NN],g[NN],up[NN],a[NN];
struct ppt
{
	LL w;
	int id;
	ppt(LL a=0,int b=0) {w=a;id=b;}
} q1[NN],q2[NN];
void dp(int v)
{
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dp(y);
		LL tmp=f[y]+aa[p][2];
		if (tmp&gt;f[v]) g[v]=f[v],f[v]=tmp;
		else if (tmp&gt;g[v]) g[v]=tmp;
	}
}
void dp2(int v)
{
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		up[y]=up[v]+aa[p][2];
		if (f[y]+aa[p][2]==f[v]) up[y]=max(up[y],g[v]+aa[p][2]);
		else up[y]=max(up[y],f[v]+aa[p][2]);
		dp2(y);
	}
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,L,R;
	for (i=2;i&lt;=n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,i,y),addedge(i,x,y);
	}
	dp(1);
	dp2(1);
	for (i=1;i&lt;=n;i++) a[i]=maa(f[i],up[i]);//,printf(&quot;%I64d &quot;,a[i]);ln;
	int h1=0,h2=0,t1=1,t2=1;
	q1[1]=q2[1]=ppt(a[1],1);
	int ans=1;
	for (L=R=1;L&lt;=n;L++)
	{
		if (n-L+1&lt;=ans) break;
		while (h1&lt;t1&amp;&amp;q1[h1+1].id&lt;L) h1++;
		while (h2&lt;t2&amp;&amp;q2[h2+1].id&lt;L) h2++;
		while (R&lt;=n)
		{
			if (q1[h1+1].w-q2[h2+1].w&gt;m) break;
			R++;
			if (R&gt;n) break;
			while (h1&lt;t1&amp;&amp;a[R]&gt;=q1[t1].w) t1--;
			q1[++t1]=ppt(a[R],R);
			while (h2&lt;t2&amp;&amp;a[R]&lt;=q2[t2].w) t2--;
			q2[++t2]=ppt(a[R],R);
		}
		int t=R-L;
		if (t&gt;ans) ans=t;
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem2502</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
using namespace std;
#define mii(a,b) (a&lt;b?a:b)
#define NN 1000000
#define inf 999999999
int deep[NN],q[NN],o[NN],aa[NN*2][3];
int n,m,tot=1,cnt,S,T;
vector&lt;int&gt; in[NN],out[NN];
bool bfs()
{
	int head=0,tail=1,x,p,y;
	q[1]=S;
	memset(deep,0,sizeof(deep));
	deep[S]=1;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[T];
}
int dfs(int v,int ff)
{
	if (v==T) return ff;
	int res=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(aa[p][2],ff));
		if (tmp==0) deep[y]=inf;
		ff-=tmp;
		aa[p][2]-=tmp;
		aa[p^1][2]+=tmp;
		res+=tmp;
		if (ff==0) break;
	}
	return res;
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v)
{
	addedge(p,q,v);
	addedge(q,p,0);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j,k,x,num;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;num);
		for (j=1;j&lt;=num;j++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			cnt++;
			out[i].push_back(cnt);
			in[x].push_back(cnt);
		}
	}
	tot=1;
	S=cnt*2+1,T=cnt*2+2;
	for (i=1;i&lt;=cnt;i++) add(i,T,1),add(S,i+cnt,1),add(i,i+cnt,inf);
	for (i=1;i&lt;=n;i++)
		for (j=0;j&lt;in[i].size();j++)
			for (k=0;k&lt;out[i].size();k++)
				add(in[i][j]+cnt,out[i][k],1);
	int ans=cnt;
	while (bfs()) ans-=dfs(S,inf);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2502</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
using namespace std;
#define mii(a,b) (a&lt;b?a:b)
#define NN 1000000
#define inf 999999999
int deep[NN],q[NN],o[NN],aa[NN*2][3];
int n,m,tot=1,cnt,S,T;
vector&lt;int&gt; in[NN],out[NN];
bool bfs()
{
	int head=0,tail=1,x,p,y;
	q[1]=S;
	memset(deep,0,sizeof(deep));
	deep[S]=1;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[T];
}
int dfs(int v,int ff)
{
	if (v==T) return ff;
	int res=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(aa[p][2],ff));
		if (tmp==0) deep[y]=inf;
		ff-=tmp;
		aa[p][2]-=tmp;
		aa[p^1][2]+=tmp;
		res+=tmp;
		if (ff==0) break;
	}
	return res;
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v)
{
	addedge(p,q,v);
	addedge(q,p,0);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j,k,x,num;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;num);
		for (j=1;j&lt;=num;j++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			cnt++;
			out[i].push_back(cnt);
			in[x].push_back(cnt);
		}
	}
	tot=1;
	S=cnt*2+1,T=cnt*2+2;
	for (i=1;i&lt;=cnt;i++) add(i,T,1),add(S,i+cnt,1),add(i,i+cnt,inf);
	for (i=1;i&lt;=n;i++)
		for (j=0;j&lt;in[i].size();j++)
			for (k=0;k&lt;out[i].size();k++)
				add(in[i][j]+cnt,out[i][k],inf);
	int ans=cnt;
	while (bfs()) ans-=dfs(S,inf);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2502</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
using namespace std;
#define mii(a,b) (a&lt;b?a:b)
#define NN 1000000
#define inf 999999999
int deep[NN],q[NN],o[NN],aa[NN*2][3],cur[NN];
int n,m,tot=1,cnt,S,T;
vector&lt;int&gt; in[NN],out[NN];
bool bfs()
{
	int head=0,tail=1,x,p,y;
	q[1]=S;
	memset(deep,0,sizeof(deep));
	deep[S]=1;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	for (int i=1;i&lt;=T;i++) cur[i]=o[i];
	return deep[T];
}
int dfs(int v,int ff)
{
	if (v==T) return ff;
	int res=0;
	for (int &amp;p=cur[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(aa[p][2],ff));
		ff-=tmp;
		aa[p][2]-=tmp;
		aa[p^1][2]+=tmp;
		res+=tmp;
		if (ff==0) break;
	}
	return res;
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v)
{
	addedge(p,q,v);
	addedge(q,p,0);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j,k,x,num;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;num);
		for (j=1;j&lt;=num;j++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			cnt++;
			out[i].push_back(cnt);
			in[x].push_back(cnt);
		}
	}
	tot=1;
	S=cnt*2+1,T=cnt*2+2;
	for (i=1;i&lt;=cnt;i++) add(i,T,1),add(S,i+cnt,1),add(i,i+cnt,inf);
	for (i=1;i&lt;=n;i++)
		for (j=0;j&lt;in[i].size();j++)
			for (k=0;k&lt;out[i].size();k++)
				add(in[i][j]+cnt,out[i][k],inf);
	int ans=cnt;
	while (bfs()) ans-=dfs(S,inf);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2502</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;

#define maxn 110
#define INF 0x7fffffff

using namespace std;

int n,sum,tot,b[maxn],su,sv,dep[maxn],ssv,in[maxn],out[maxn];
bool flag[maxn][maxn];

struct edge{
	int x,y,w,last;
}a[maxn*maxn],e[maxn*maxn];

void add(int x,int y,int w)
{
	a[++tot]=(edge){x,y,w,b[x]};
	b[x]=tot;
}

void Add(int x,int y,int w)
{
	//printf(&quot;!%d %d %d\n&quot;,x,y,w);
	add(x,y,w);add(y,x,0);
}

#define v a[i].y
bool bfs()
{
	queue&lt;int&gt; q;
	q.push(su);
	memset(dep,0,sizeof(dep));
	dep[su]=1;
	while(!q.empty()){
		int x=q.front();q.pop();
		for(int i=b[x];i;i=a[i].last){
			if(!dep[v]&amp;&amp;a[i].w&gt;0){
				dep[v]=dep[x]+1;
				q.push(v);
			}
		}
	}
	return dep[sv]!=0;
}

int Dinic(int x,int flow)
{
	if(x==sv) return flow;
	int remain=flow;
	for(int i=b[x];i;i=a[i].last){
		if(dep[v]==dep[x]+1&amp;&amp;a[i].w&amp;&amp;remain){
			int tmp=Dinic(v,min(a[i].w,remain));
			if(!tmp){
				dep[v]=0;continue;
			}
			a[i].w-=tmp;
			a[i^1].w+=tmp;
			remain-=tmp;
		}
	}
	return flow-remain;
}

bool check(int mid)
{
	memcpy(a,e,sizeof(e));
	a[tot^1].w=mid;
	int ans=0,tmp;
	while(bfs()){
		while(tmp=Dinic(su,INF)) ans+=tmp;
	}
	return ans&gt;=sum;
}

int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	su=0,sv=n+1,ssv=n+2;tot=1;
	for(int i=1;i&lt;=n;i++){
		int t;scanf(&quot;%d&quot;,&amp;t);
		for(int j=1;j&lt;=t;j++){
			int y;
			scanf(&quot;%d&quot;,&amp;y);
			in[y]++;out[i]++;
			
			Add(i,y,INF);
		}
	}
	for(int i=1;i&lt;=n;i++){
		if(in[i]-out[i]&gt;0) Add(su,i,in[i]-out[i]),sum+=(in[i]-out[i]);
		else Add(i,sv,out[i]-in[i]);
	}
	for(int i=1;i&lt;=n;i++){
		Add(ssv,i,INF);
	}
	Add(su,ssv,INF);
	int L=0,R=n*n,Ans=n*n;
	memcpy(e,a,sizeof(a));
	//printf(&quot;%d\n&quot;,check(4));
	while(L&lt;=R){
		int mid=(L+R)&gt;&gt;1;
		if(check(mid)) Ans=mid,R=mid-1;
		else L=mid+1;
	}
	printf(&quot;%d\n&quot;,Ans);
	//while(1);
	return 0;
}
/*
3
1 2
1 3
0
*/
<pre><h2>Problem2521</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mii(a,b) (a&lt;b?a:b)
#define NN 511
#define MM 811
#define inf 999999999
int deep[NN],o[NN],q[NN],aa[MM*2][3];
int n,m,it,tot=1,S,T;
struct edge
{
	int a,b,w;
} e[MM];
bool bfs()
{
	int head=0,tail=1,x,p,y;
	memset(deep,0,sizeof(deep));
	deep[S]=1;
	q[1]=S;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[T];
}
int dfs(int v,int ff)
{
	if (v==T) return ff;
	int res=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(aa[p][2],ff));
		if (tmp==0) deep[y]=inf;
		ff-=tmp;
		aa[p][2]-=tmp;
		aa[p^1][2]+=tmp;
		res+=tmp;
		if (!ff) break;
	}
	return res;
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add2(int p,int q,int v)
{
	addedge(p,q,v);
	addedge(q,p,v);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;it);
	int i;
	for (i=1;i&lt;=m;i++) scanf(&quot;%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
	tot=1;
	for (i=1;i&lt;=m;i++)
		if (i!=it&amp;&amp;e[i].w&lt;=e[it].w)
			add2(e[i].a,e[i].b,e[it].w-e[i].w+1);
	S=e[it].a,T=e[it].b;
	int ans=0;
	while (bfs()) ans+=dfs(S,inf);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2527</h2><pre>#include &lt;cstdio&gt;
using namespace std;
const int maxn=300100;
struct orz1
{
	int pos;
	long long have,need;
}a[maxn],a1[maxn],a2[maxn];
struct orz2
{
	int l,r;
	long long num;
}b[maxn];
int next[maxn],n,m,k,ans[maxn],last[maxn];
long long sum[maxn];
void insert(int x,long long value)
{
	for (;x&lt;=m;x+=x&amp;-x) sum[x]+=value;
}
long long get(int x)
{
	long long tmp=0;
	for (;x;x-=x&amp;-x) tmp+=sum[x];
	return tmp;
}
void solve(int head,int tail,int l,int r)
{
	if (head&gt;tail) return;//一定要写这一句
	if (l==r)
	{
		int i;
		for (i=head;i&lt;=tail;i++) ans[a[i].pos]=l;
		return;
	}
	int mid=(l+r)&gt;&gt;1,i;
	for (i=l;i&lt;=mid;i++) if (b[i].l&lt;=b[i].r) {insert(b[i].l,b[i].num); insert(b[i].r+1,-b[i].num);}
	else {insert(1,b[i].num); insert(b[i].r+1,-b[i].num); insert(b[i].l,b[i].num);}
	int t1=0,t2=0,j;
	long long tmp;
	for (i=head;i&lt;=tail;i++)
	{
		tmp=0;
		for (j=last[a[i].pos];j&amp;&amp;tmp&lt;=a[i].need;j=next[j]) tmp+=get(j);
		if (tmp+a[i].have&gt;=a[i].need) a1[++t1]=a[i];
		else { a[i].have+=tmp; a2[++t2]=a[i];}
	}
	for (i=l;i&lt;=mid;i++) if (b[i].l&lt;=b[i].r) {insert(b[i].l,-b[i].num); insert(b[i].r+1,b[i].num);}//消除影响
	else {insert(1,-b[i].num); insert(b[i].r+1,b[i].num); insert(b[i].l,-b[i].num);}
	for (i=head;i&lt;head+t1;i++) a[i]=a1[i-head+1];
	for (i=head+t1;i&lt;=tail;i++) a[i]=a2[i-head-t1+1];
	solve(head,head+t1-1,l,mid);
	solve(head+t1,tail,mid+1,r);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
	int i,x;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		next[i]=last[x];
		last[x]=i;
	}
	for (i=1;i&lt;=n;i++) {scanf(&quot;%I64d&quot;,&amp;a[i].need); a[i].pos=i;}
	scanf(&quot;%d&quot;,&amp;k);
	for (i=1;i&lt;=k;i++) scanf(&quot;%d%d%I64d&quot;,&amp;b[i].l,&amp;b[i].r,&amp;b[i].num);
	b[++k].l=1;b[k].r=n;b[k].num=1000000010;
	solve(1,n,1,k);
	for (i=1;i&lt;=n;i++) if (ans[i]==k) printf(&quot;NIE\n&quot;); else printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem2527</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
#define NN 1001111
#define inf 99999999999
#define pb push_back
#define LL long long
LL ans[NN],id[NN],id1[NN],id2[NN],L[NN],R[NN],A[NN],P[NN];
LL c[NN],b[NN],have[NN];
LL n,m,K;
vector&lt;LL&gt; pos[NN];
void out(LL *a,LL l,LL r){for(LL i=l;i&lt;=r;i++)printf(&quot;%lld &quot;,a[i]);printf(&quot;\n&quot;);}
void change(LL i,LL x)
{
	//printf(&quot;change %lld %lld\n&quot;,i,x);
	for (;i&lt;=m;i+=(i&amp;-i)) c[i]+=x;
}
LL getsum(LL i)
{
	//printf(&quot;getsum %lld\n&quot;,i);
	LL res=0;
	for (;i;i-=(i&amp;-i)) res+=c[i];
	//printf(&quot;getsum = %lld\n&quot;,res);
	return res;
}
void make(LL t,LL kind)
{
	LL tmp=A[t]*kind;
	if (R[t]&gt;=L[t])
	{
		change(L[t],tmp);
		change(R[t]+1,-tmp);
	}
	else
	{
		change(1,tmp);
		change(R[t]+1,-tmp);
		change(L[t],tmp);
		change(m+1,-tmp);
	}
}
void solve(LL head,LL tail,LL l,LL r)
{
	if (head&gt;tail) return;
	//printf(&quot;\n------------ head=%lld tail=%lld l=%lld r=%lld mid=%lld ---------------\n&quot;,head,tail,l,r,(l+r)/2);
	if (l==r)
	{
		for (LL i=head;i&lt;=tail;i++) ans[id[i]]=l;
		return;
	}
	LL mid,i,j,k,t;
	mid=(l+r)&gt;&gt;1;
	for (i=l;i&lt;=mid;i++) make(i,1);
	for (i=head;i&lt;=tail;i++)
	{
		t=id[i];
		b[t]=0;
		for (j=0;j&lt;pos[t].size()&amp;&amp;b[t]&lt;=P[t];j++) b[t]+=getsum(pos[t][j]);
		//printf(&quot;size[%lld]=%lld\n&quot;,t,pos[t].size());
	}
	//printf(&quot;b &quot;);out(b,1,n);
	for (i=l;i&lt;=mid;i++) make(i,-1);
	for (i=j=0,k=head;k&lt;=tail;k++)
	{
		t=id[k];
		if (have[t]+b[t]&gt;=P[t]) id1[++i]=t;
		else have[t]+=b[t],id2[++j]=t;
	}
	//printf(&quot;id1 &quot;);out(id1,1,n);printf(&quot;id2 &quot;);out(id2,1,n);
	t=head;
	for (k=1;k&lt;=i;k++) id[t++]=id1[k];
	for (k=1;k&lt;=j;k++) id[t++]=id2[k];
	solve(head,head+i-1,l,mid);
	solve(head+i,tail,mid+1,r);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);
	LL i,x;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%lld&quot;,&amp;x);
		pos[x].pb(i);
	}
	for (i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;P[i]),id[i]=i;
	scanf(&quot;%lld&quot;,&amp;K);
	for (i=1;i&lt;=K;i++) scanf(&quot;%lld%lld%lld&quot;,&amp;L[i],&amp;R[i],&amp;A[i]);
	K++,L[K]=1,R[K]=n,A[K]=inf;
	solve(1,n,1,K);
	for (i=1;i&lt;=n;i++)
		if (ans[i]&lt;K) printf(&quot;%lld\n&quot;,ans[i]);
		else printf(&quot;NIE\n&quot;);
	return 0;
}
<pre><h2>Problem2530</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int a[3111][3111];
int n,m;
bool flag[3111];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j,x,y;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		a[x][y]=a[y][x]=1;
	}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++) if (i!=j)
			if (a[i][j]==0&amp;&amp;!flag[i]&amp;&amp;!flag[j]) flag[i]=flag[j]=true;
	//for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,flag[i]);printf(&quot;\n&quot;);
	int t=n/3;
	for (i=1;i&lt;=n;i++)
	{
		if (!flag[i])
			printf(t==1?&quot;%d\n&quot;:&quot;%d &quot;,i),t--;
		if (t==0) break;
	}
	return 0;
}<pre><h2>Problem2534</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#define maxn 50010
using namespace std;
typedef long long LL;
LL ans;
char str[maxn];
int n,g;
int Sa[maxn],rank[maxn],height[maxn];
int father[maxn];
struct Node
{
    Node *lc,*rc;
    int size;
}*Root[maxn];
Node* Insert(int l,int r,int p)
{
    Node* it=new Node;
    it-&gt;size=1;
    if(l==r)
        return it;
    int mid=(l+r)&gt;&gt;1;
    if(p&lt;=mid)
        it-&gt;lc=Insert(l,mid,p);
    else
        it-&gt;rc=Insert(mid+1,r,p);
    return it;
}
int Query(Node *p,int l,int r,int x,int y)
{
    if(p==0)
        return 0;
    if(l==x&amp;&amp;r==y)
        return p-&gt;size;
    int mid=(l+r)&gt;&gt;1;
    if(y&lt;=mid)
        return Query(p-&gt;lc,l,mid,x,y);
    else if(mid&lt;x)
        return Query(p-&gt;rc,mid+1,r,x,y);
    else
        return Query(p-&gt;lc,l,mid,x,mid)+Query(p-&gt;rc,mid+1,r,mid+1,y);
}
Node* merge(Node* a,Node* b)
{
    if(a==0)
        return b;
    if(b==0)
        return a;
    Node* c=new Node;
    c-&gt;size=a-&gt;size+b-&gt;size;
    c-&gt;lc=merge(a-&gt;lc,b-&gt;lc),c-&gt;rc=merge(a-&gt;rc,b-&gt;rc);
    return c;
}
int Find(int p)
{
    if(father[p]!=p)
        father[p]=Find(father[p]);
    return father[p];
}
void sort(int *a,int *b,int *c,int n,int m)
{
    static int sum[maxn];
    for(int i=1;i&lt;=m;++i)
        sum[i]=0;
    for(int i=1;i&lt;=n;++i)
        ++sum[c[i]];
    for(int i=1;i&lt;=m;++i)
        sum[i]+=sum[i-1];
    for(int i=n;i&gt;=1;--i)
        b[sum[c[a[i]]]--]=a[i];
}
void make_Sa()
{
    n=strlen(str+1);
    static int x[maxn],y[maxn];
    for(int i=1;i&lt;=n;++i)
        x[i]=str[i],rank[i]=i;
    sort(rank,Sa,x,n,256);
    rank[Sa[1]]=1;
    for(int i=2;i&lt;=n;++i)
        rank[Sa[i]]=rank[Sa[i-1]]+(x[Sa[i]]!=x[Sa[i-1]]);
    for(int i=1;i&lt;=n;i&lt;&lt;=1)
    {
        for(int j=1;j&lt;=n;++j)
            x[j]=rank[j],y[j]=i+j&lt;=n?rank[i+j]:0,Sa[j]=j;
        sort(Sa,rank,y,n,n),sort(rank,Sa,x,n,n);
        rank[Sa[1]]=1;
        for(int j=2;j&lt;=n;++j)
            rank[Sa[j]]=rank[Sa[j-1]]+(x[Sa[j]]!=x[Sa[j-1]]||y[Sa[j]]!=y[Sa[j-1]]);
        if(rank[Sa[n]]==n)
            return ;
    }
}
void debug()
{
    for(int i=1;i&lt;=n;++i)
    {
        printf(&quot;(&quot;);
        for(int j=Sa[i];j&lt;=n;++j)
            printf(&quot;%d &quot;,str[j]);
        printf(&quot;) %d\n&quot;,height[i]);
    }
}
void make_height()
{
    for(int i=1,j=0;i&lt;=n;++i)
    {
        if(j&gt;0)
            --j;
        if(rank[i]!=1)
            while(str[i+j]==str[Sa[rank[i]-1]+j])
                ++j;
        height[rank[i]]=j;
    }
}
int calc(int lcp,int L1,int R1,int L2,int R2,Node *p1,Node *p2)
{
    if(R1-L1&gt;R2-L2)
        swap(L1,L2),swap(R1,R2),swap(p1,p2);
    int tot=0;
    for(int i=L1;i&lt;=R1;++i)
    {
        int p=Sa[i];
        if(p-g-1&gt;=1)
            tot+=Query(p2,1,n,max(1,p-g-lcp),p-g-1);
        if(p+g+1&lt;=n)
            tot+=Query(p2,1,n,p+g+1,min(p+g+lcp,n));
    }
    return tot;
}
void work()
{
    //debug();
    static pair&lt;int,int&gt; pos[maxn];
    static int R[maxn];
    for(int i=1;i&lt;=n;++i)
        pos[i]=make_pair(height[i],i),father[i]=i,R[i]=i;
    sort(pos+1,pos+n+1),reverse(pos+1,pos+n+1);
    for(int i=1;i&lt;=n;++i)
        Root[i]=Insert(1,n,Sa[i]);
    for(int j=n,i=1;j&gt;=1;--j)
        for(;pos[i].first==j;++i)
        {
            int a=pos[i].second,b=Find(a-1);
            ans+=calc(j,a,R[a],b,R[b],Root[a],Root[b]);
            father[a]=b,R[b]=R[a],Root[b]=merge(Root[a],Root[b]);
        }
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);//freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d\n%s&quot;,&amp;g,str+1);
    //printf(&quot;%s\n&quot;,str+1);
    make_Sa();
    make_height();
    work();
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
<pre><h2>Problem2534</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=201111;
int rank[NN],sa[NN],height[NN],log[NN],f[NN][19];
int n,m;
char s[NN];
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);ln;}
void SA(char *r,int n,int m)
{
	//printf(&quot;n=%d\n&quot;,n);
	static int sa2[NN],sum[NN],wv[NN];
	int i,j,p,*x=rank,*y=sa2,*t;
	for (i=0;i&lt;=m;i++) sum[i]=0;
	for (i=1;i&lt;=n;i++) sum[x[i]=r[i]]++;
	for (i=1;i&lt;=m;i++) sum[i]+=sum[i-1];
	for (i=n;i;i--) sa[sum[x[i]]--]=i;
	for (j=p=1;p&lt;n;j&lt;&lt;=1,m=p)
	{
		for (i=n-j+1,p=0;i&lt;=n;i++) y[++p]=i;
		for (i=1;i&lt;=n;i++) if (sa[i]&gt;j) y[++p]=sa[i]-j;
		for (i=0;i&lt;=m;i++) sum[i]=0;
		for (i=1;i&lt;=n;i++) sum[wv[i]=x[y[i]]]++;
		for (i=1;i&lt;=m;i++) sum[i]+=sum[i-1];
		for (i=n;i;i--) sa[sum[wv[i]]--]=y[i];
		for (t=x,x=y,y=t,i=2,x[sa[1]]=p=1;i&lt;=n;i++)
			x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+j]==y[sa[i-1]+j])?p:++p;
	}
	for (i=1;i&lt;=n;i++) rank[i]=x[i];
	for (i=1,p=0;i&lt;=n;i++) if (x[i]&gt;1)
	{
		j=sa[x[i]-1];
		while (r[i+p]==r[j+p]) p++;
		height[x[i]]=p;
		if (p) p--;
	}
}
int getlcp(int x,int y,int kind)
{
	if (kind==2) x=n+n+2-x,y=n+n+2-y;
	//printf(&quot;getlcp %d %d %d\n&quot;,x,y,kind);
	x=rank[x],y=rank[y];
	if (x&gt;y) {int t=x;x=y;y=t;}
	x++;
	//printf(&quot;x=%d y=%d\n&quot;,x,y);
	int t=log[y-x+1];
	//printf(&quot;t=%d\n&quot;,t);
	return min(f[x][t],f[y-(1&lt;&lt;t)+1][t]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d\n%s\n&quot;,&amp;m,s+1);
	int i,j;
	n=strlen(s+1);
	s[n+1]='#';
	for (i=n;i;i--) s[n-i+n+2]=s[i];
	//printf(&quot;%s\n&quot;,s+1);
	SA(s,n+n+1,255);
	//printf(&quot;rank &quot;);out(rank,1,n+n+1);printf(&quot;height &quot;);out(height,1,n+n+1);printf(&quot;sa &quot;);out(sa,1,n+n+1);
	for (i=1;i&lt;=n+n+1;i++) f[i][0]=height[i];
	for (j=1;j&lt;=18;j++)
		for (i=1;i+(1&lt;&lt;(j-1))&lt;=n+n+1;i++)
			f[i][j]=min(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]);
	log[1]=0;
	for (i=2;i&lt;=n+n+1;i++) log[i]=(i==(i&amp;-i))?log[i-1]+1:log[i-1];
	//printf(&quot;%d\n&quot;,getlcp(1,4,1));
	int ans=0;
	for (i=1;i&lt;=n;i++)
	{
		//printf(&quot;\n-----------------------------------------------------------------------\n&quot;);
		for (j=1;j&lt;=n;j+=i)
		{
			int A=j,B=j+i+m;
			if (B&gt;n) continue;
			int t1=getlcp(A,B,1),t2=getlcp(A,B,2);
			if (t1&gt;i) t1=i;
			if (t2&gt;i) t2=i;
			//printf(&quot;%d %d %d %d\n&quot;,A,B,t1,t2);
			if (t1+t2&gt;i) ans+=t1+t2-i;
			//printf(&quot;ans=%d\n&quot;,ans);
		}
		//printf(&quot;ans=%d\n&quot;,ans);
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem2534</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int NN=201111;
int rank[NN],sa[NN],height[NN],log[NN],f[NN][19];
int n,m;
char s[NN];
void SA(char *r,int n,int m)
{
	static int sa2[NN],sum[NN],wv[NN];
	int i,j,p,*x=rank,*y=sa2,*t;
	for (i=0;i&lt;=m;i++) sum[i]=0;
	for (i=1;i&lt;=n;i++) sum[x[i]=r[i]]++;
	for (i=1;i&lt;=m;i++) sum[i]+=sum[i-1];
	for (i=n;i;i--) sa[sum[x[i]]--]=i;
	for (j=p=1;p&lt;n;j&lt;&lt;=1,m=p)
	{
		for (i=n-j+1,p=0;i&lt;=n;i++) y[++p]=i;
		for (i=1;i&lt;=n;i++) if (sa[i]&gt;j) y[++p]=sa[i]-j;
		for (i=0;i&lt;=m;i++) sum[i]=0;
		for (i=1;i&lt;=n;i++) sum[wv[i]=x[y[i]]]++;
		for (i=1;i&lt;=m;i++) sum[i]+=sum[i-1];
		for (i=n;i;i--) sa[sum[wv[i]]--]=y[i];
		for (t=x,x=y,y=t,i=2,x[sa[1]]=p=1;i&lt;=n;i++)
			x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+j]==y[sa[i-1]+j])?p:++p;
	}
	for (i=1;i&lt;=n;i++) rank[i]=x[i];
	for (i=1,p=0;i&lt;=n;i++) if (x[i]&gt;1)
	{
		j=sa[x[i]-1];
		while (r[i+p]==r[j+p]) p++;
		height[x[i]]=p;
		if (p) p--;
	}
}
int getlcp(int x,int y,int kind)
{
	if (kind==2) x=n+n+2-x,y=n+n+2-y;
	x=rank[x],y=rank[y];
	if (x&gt;y) {int t=x;x=y;y=t;}
	x++;
	int t=log[y-x+1];
	return min(f[x][t],f[y-(1&lt;&lt;t)+1][t]);
}
int main()
{
	scanf(&quot;%d\n%s\n&quot;,&amp;m,s+1);
	int i,j;
	n=strlen(s+1);
	s[n+1]='#';
	for (i=n;i;i--) s[n-i+n+2]=s[i];
	SA(s,n+n+1,255);
	for (i=1;i&lt;=n+n+1;i++) f[i][0]=height[i];
	for (j=1;j&lt;=18;j++)
		for (i=1;i+(1&lt;&lt;(j-1))&lt;=n+n+1;i++)
			f[i][j]=min(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]);
	log[1]=0;
	for (i=2;i&lt;=n+n+1;i++) log[i]=(i==(i&amp;-i))?log[i-1]+1:log[i-1];
	int ans=0;
	for (i=1;i&lt;=n;i++)
	{
		for (j=1;j&lt;=n;j+=i)
		{
			int A=j,B=j+i+m;
			if (B&gt;n) continue;
			int t1=getlcp(A,B,1),t2=getlcp(A,B,2);
			if (t1&gt;i) t1=i;
			if (t2&gt;i) t2=i;
			if (t1+t2&gt;i) ans+=t1+t2-i;
		}
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem2535</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
const int NN=20005;
int pos[NN],dy[NN],du[NN],du2[NN],o[NN],aa[NN&lt;&lt;1][2];
int n,m,tot;
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
struct ppt
{
	int v,w;
	friend bool operator &lt;(const ppt &amp;a,const ppt  &amp;b) {return a.w&lt;b.w;}
} q[NN];
priority_queue&lt;ppt&gt; Q;
void work(int the)
{
	while (!Q.empty()) Q.pop();
	int i;
	for (i=1;i&lt;=n;i++)
	{
		du2[i]=du[i];
		if (du2[i]==0) Q.push(q[i]);
	}
	for (i=n;i;i--)
	{
		ppt tmp=Q.top();
		if (tmp.v==the&amp;&amp;Q.size()&gt;1)
		{
			Q.pop();
			ppt t2=Q.top();
			if (t2.w&gt;=i)
			{
				Q.pop();
				Q.push(tmp);
				tmp=t2;
			}
		}
		else Q.pop();
		pos[tmp.v]=i;
		dy[i]=tmp.v;
		for (int p=o[tmp.v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (--du2[y]==0) Q.push(q[y]);
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;q[i].w);
		q[i].v=i;
	}
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		du[x]++;
		addedge(y,x);
	}
	work(0);
	for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,dy[i]);
	printf(&quot;\n&quot;);
	for (i=1;i&lt;=n;i++)
	{
		work(i);
		printf(&quot;%d &quot;,pos[i]);
	}
	printf(&quot;\n&quot;);
	return 0;
}<pre><h2>Problem2553</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define LD long double
#define DD double
int son[101][26],fail[101],q[101];
int n,L,al,TTT;
bool flag[101];
char s[33];
LD tmp;
struct matrix {LD m[100][100];} a,b,c;
void ACins(int len)
{
	int now,i,x;
	now=1;
	for (i=1;i&lt;=len;i++)
	{
		x=s[i]-'a';
		if (son[now][x]) now=son[now][x];
		else son[now][x]=++TTT,now=TTT;
	}
	flag[now]=true;
}
void buildfail()
{
	int head,tail,x,i;
	head=0,q[tail=1]=1;
	while (head&lt;tail)
	{
		x=q[++head];
		flag[x]|=flag[fail[x]];
		for (i=0;i&lt;al;i++)
			if (son[x][i]==0) son[x][i]=son[fail[x]][i];
			else fail[son[x][i]]=son[fail[x]][i],q[++tail]=son[x][i];
	}
}
void mul(matrix &amp;a,matrix &amp;b)
{
	int i,j,k;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++) c.m[i][j]=0;
	for (k=1;k&lt;=n;k++)
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=n;j++)
				c.m[i][j]+=a.m[i][k]*b.m[k][j];
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++) a.m[i][j]=c.m[i][j];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d\n&quot;,&amp;n,&amp;L,&amp;al);
	int i,j;
	for (i=0;i&lt;al;i++) son[0][i]=1;
	TTT=1;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s\n&quot;,s+1);
		ACins(strlen(s+1));
	}
	buildfail();
	n=TTT+1;
	a.m[n][n]=1;
	//printf(&quot;%d\n&quot;,TTT);
	for (tmp=1.0/al,i=1;i&lt;=TTT;i++)
		for (j=0;j&lt;al;j++)
			if (flag[son[i][j]]) a.m[i][n]+=tmp,a.m[i][1]+=tmp;
			else a.m[i][son[i][j]]+=tmp;
	//for (i=1;i&lt;=n;i++){for (j=1;j&lt;=n;j++) printf(&quot;%.3f &quot;,(DD)a.m[i][j]);printf(&quot;\n&quot;);}
	for (i=1;i&lt;=n;i++) b.m[i][i]=1;
	for (;L;L&gt;&gt;=1)
	{
		if (L&amp;1) mul(b,a);
		mul(a,a);
		//for (printf(&quot;\n&quot;),i=1;i&lt;=n;i++){for (j=1;j&lt;=n;j++) printf(&quot;%.3f &quot;,(DD)b.m[i][j]);printf(&quot;\n&quot;);}
	}
	printf(&quot;%.8f\n&quot;,(DD)b.m[1][n]);
	return 0;
}
<pre><h2>Problem2553</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define LD long double
#define DD double
int son[99][26],fail[99],q[99];
int n,L,al,TTT;
bool flag[99];
char s[17];
LD tmp;
struct matrix {LD m[99][99];} a,b,c;
void ACins(int len)
{
	int now,i,x;
	now=1;
	for (i=1;i&lt;=len;i++)
	{
		x=s[i]-'a';
		if (son[now][x]) now=son[now][x];
		else son[now][x]=++TTT,now=TTT;
	}
	flag[now]=true;
}
void buildfail()
{
	int head,tail,x,i;
	head=0,q[tail=1]=1;
	while (head&lt;tail)
	{
		x=q[++head];
		flag[x]|=flag[fail[x]];
		for (i=0;i&lt;al;i++)
			if (son[x][i]==0) son[x][i]=son[fail[x]][i];
			else fail[son[x][i]]=son[fail[x]][i],q[++tail]=son[x][i];
	}
}
void mul(matrix &amp;a,matrix &amp;b)
{
	int i,j,k;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++) c.m[i][j]=0;
	for (k=1;k&lt;=n;k++)
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=n;j++)
				c.m[i][j]+=a.m[i][k]*b.m[k][j];
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++) a.m[i][j]=c.m[i][j];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d\n&quot;,&amp;n,&amp;L,&amp;al);
	int i,j;
	for (i=0;i&lt;al;i++) son[0][i]=1;
	TTT=1;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s\n&quot;,s+1);
		ACins(strlen(s+1));
	}
	buildfail();
	n=TTT+1;
	a.m[n][n]=1;
	//printf(&quot;%d\n&quot;,TTT);
	for (tmp=1.0/al,i=1;i&lt;=TTT;i++)
		for (j=0;j&lt;al;j++)
			if (flag[son[i][j]]) a.m[i][n]+=tmp,a.m[i][1]+=tmp;
			else a.m[i][son[i][j]]+=tmp;
	//for (i=1;i&lt;=n;i++){for (j=1;j&lt;=n;j++) printf(&quot;%.3f &quot;,(DD)a.m[i][j]);printf(&quot;\n&quot;);}
	for (i=1;i&lt;=n;i++) b.m[i][i]=1;
	for (;L;L&gt;&gt;=1)
	{
		if (L&amp;1) mul(b,a);
		mul(a,a);
		//for (printf(&quot;\n&quot;),i=1;i&lt;=n;i++){for (j=1;j&lt;=n;j++) printf(&quot;%.3f &quot;,(DD)b.m[i][j]);printf(&quot;\n&quot;);}
	}
	printf(&quot;%.8f\n&quot;,(DD)b.m[1][n]);
	return 0;
}
<pre><h2>Problem2553</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define LD long double
#define DD double
int son[99][26],fail[99],q[99];
int n,L,al,TTT;
bool flag[99];
char s[17];
LD tmp;
struct matrix {LD m[99][99];} a,b,c;
void ACins(int len)
{
	int now,i,x;
	now=1;
	for (i=1;i&lt;=len;i++)
	{
		x=s[i]-'a';
		if (son[now][x]) now=son[now][x];
		else son[now][x]=++TTT,now=TTT;
	}
	flag[now]=true;
}
void buildfail()
{
	int head,tail,x,i;
	head=0,q[tail=1]=1;
	while (head&lt;tail)
	{
		x=q[++head];
		flag[x]|=flag[fail[x]];
		for (i=0;i&lt;al;i++)
			if (son[x][i]==0) son[x][i]=son[fail[x]][i];
			else fail[son[x][i]]=son[fail[x]][i],q[++tail]=son[x][i];
	}
}
void mul(matrix &amp;a,matrix &amp;b)
{
	int i,j,k;
	LD *x;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++) c.m[i][j]=0;
	for (k=1;k&lt;=n;k++)
		for (x=&amp;c.m[1][1],i=1;i&lt;=n;i++,x+=99-n)
			for (j=1;j&lt;=n;j++,x++)
				*x+=a.m[i][k]*b.m[k][j];
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++) a.m[i][j]=c.m[i][j];
}
int main()
{
	scanf(&quot;%d%d%d\n&quot;,&amp;n,&amp;L,&amp;al);
	int i,j;
	for (i=0;i&lt;al;i++) son[0][i]=1;
	TTT=1;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s\n&quot;,s+1);
		ACins(strlen(s+1));
	}
	buildfail();
	n=TTT+1;
	a.m[n][n]=1;
	for (tmp=1.0/al,i=1;i&lt;=TTT;i++)
		for (j=0;j&lt;al;j++)
		{
			int x=son[i][j];
			if (flag[x]) a.m[i][n]+=tmp,a.m[i][1]+=tmp;
			else a.m[i][x]+=tmp;
		}
	for (i=1;i&lt;=n;i++) b.m[i][i]=1;
	for (;L;L&gt;&gt;=1)
	{
		if (L&amp;1) mul(b,a);
		mul(a,a);
	}
	printf(&quot;%.8f\n&quot;,(DD)b.m[1][n]);
	return 0;
}
<pre><h2>Problem2553</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define LD long double
#define DD double
int son[89][26],fail[89],q[89];
int n,L,al,TTT;
bool flag[89];
char s[17];
struct matrix {LD m[89][89];} a,b,c;
void ACins(int len)
{
	int now,i,x;
	now=1;
	for (i=1;i&lt;=len;i++)
	{
		x=s[i]-'a';
		if (son[now][x]) now=son[now][x];
		else son[now][x]=++TTT,now=TTT;
	}
	flag[now]=true;
}
void buildfail()
{
	int head,tail,x,i,y,z;
	head=0,q[tail=1]=1;
	while (head&lt;tail)
	{
		x=q[++head];
		y=fail[x];
		flag[x]|=flag[y];
		for (i=0;i&lt;al;i++)
		{
			z=son[y][i];
			int &amp;tt=son[x][i];
			if (tt==0) tt=z;
			else fail[tt]=z,q[++tail]=tt;
		}
	}
}
void mul(matrix &amp;a,matrix &amp;b)
{
	int i,j,k;
	LD *x;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++) c.m[i][j]=0;
	for (k=1;k&lt;=n;k++)
		for (x=&amp;c.m[1][1],i=1;i&lt;=n;i++,x+=89-n)
			for (j=1;j&lt;=n;j++,x++)
				*x+=a.m[i][k]*b.m[k][j];
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++) a.m[i][j]=c.m[i][j];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d\n&quot;,&amp;n,&amp;L,&amp;al);
	int i,j;
	for (i=0;i&lt;al;i++) son[0][i]=1;
	TTT=1;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s\n&quot;,s+1);
		ACins(strlen(s+1));
	}
	buildfail();
	n=TTT+1;
	a.m[n][n]=1;
	LD tmp=1.0/al;
	for (i=1;i&lt;=TTT;i++)
		for (j=0;j&lt;al;j++)
		{
			int x=son[i][j];
			if (flag[x]) a.m[i][n]+=tmp,a.m[i][1]+=tmp;
			else a.m[i][x]+=tmp;
		}
	for (i=1;i&lt;=n;i++) b.m[i][i]=1;
	for (;L;L&gt;&gt;=1)
	{
		if (L&amp;1) mul(b,a);
		mul(a,a);
	}
	printf(&quot;%.8f\n&quot;,(DD)b.m[1][n]);
	return 0;
}
<pre><h2>Problem2555</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int NN=3001111;
int pre[NN],son[NN][26],val[NN],right[NN];
int n,TTT,last;
char ss[NN],s[NN];
void add(int x)
{
	//printf(&quot;add %d\n&quot;,x);
	int p=last,end=++TTT;
	last=end;
	val[end]=val[p]+1;
	for (;p!=-1&amp;&amp;!son[p][x];p=pre[p]) son[p][x]=end;
	if (p==-1) {pre[end]=0;return;}
	int q=son[p][x];
	if (val[q]==val[p]+1) {pre[end]=q;return;}
	int nq=++TTT;
	val[nq]=val[p]+1;
	pre[nq]=pre[q];
	pre[q]=pre[end]=nq;
	memcpy(son[nq],son[q],sizeof(son[q]));
	right[nq]=right[q];
	for (;p!=-1&amp;&amp;son[p][x]==q;p=pre[p]) son[p][x]=nq;
}
void maintain()
{
	for (int x=last;x!=-1;x=pre[x]) right[x]++;
}
int find(char *s,int len)
{
	int x=0;
	for (int i=0;i&lt;len;i++)
	{
		if (!son[x][s[i]-'A']) return 0;
		x=son[x][s[i]-'A'];
	}
	return right[x];
}
void fix(char *s,int last)
{
    int len=strlen(s);
    for (int i=0;i&lt;len;i++)
	{
        last=(last*131+i)%len;
        swap(s[i],s[last]);
    }
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d\n&quot;,&amp;n);
	scanf(&quot;%s\n&quot;,ss+1);
	pre[0]=-1;
	int len=strlen(ss+1);
	int i;
	for (i=1;i&lt;=len;i++) add(ss[i]-'A'),maintain();
	int lastans=0;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s%s\n&quot;,s,ss);
		//printf(&quot;%s %s\n&quot;,s,ss);
		int len=strlen(ss);
		fix(ss,lastans);
		int ans;
		if (s[0]=='Q') printf(&quot;%d\n&quot;,ans=find(ss,len)),lastans^=ans;
		else for (int j=0;j&lt;len;j++) add(ss[j]-'A'),maintain();
	}
	return 0;
}<pre><h2>Problem2560</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
#define mo 1000000007
const int NN=17;
int c[NN][NN],f[69999],g[69999];
int n;
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	int i,j;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++) scanf(&quot;%d&quot;,&amp;c[i][j]);
	f[0]=1;
	for (int S=1;S&lt;(1&lt;&lt;n);S++)
	{
		g[S]=1;
		for (i=1;i&lt;=n;i++) if (S&amp;(1&lt;&lt;(i-1)))
			for (j=i+1;j&lt;=n;j++) if (S&amp;(1&lt;&lt;(j-1)))
				g[S]=(LL)g[S]*(c[i][j]+1)%mo;
		f[S]=g[S];
		for (i=1;!(S&amp;(1&lt;&lt;(i-1)));i++);
		int lowbit=1&lt;&lt;(i-1);
		if (S==lowbit) continue;
		for (int T=S-1;T!=0;T=(T-1)&amp;S) if (T&amp;lowbit)
		{
			f[S]-=(LL)f[T]*g[S^T]%mo;
			if (f[S]&lt;0) f[S]+=mo;
		}
	}
	printf(&quot;%d\n&quot;,f[(1&lt;&lt;n)-1]);
	return 0;
}<pre><h2>Problem2561</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mii(a,b) (a&lt;b?a:b)
#define inf 999999999
int deep[1000000],q[1000000],o[1000000],aa[1000000][3];
int n,m,tot=1,S,T;
struct edge
{
	int a,b,w;
} e[1000000],t;
bool bfs()
{
	int head=0,tail=1,x,p,y;
	q[1]=S;
	memset(deep,0,sizeof(deep));
	deep[S]=1;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[T];
}
int dfs(int v,int ff)
{
	if (v==T) return ff;
	int res=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(aa[p][2],ff));
		if (tmp==0) deep[y]=inf;
		ff-=tmp;
		aa[p][2]-=tmp;
		aa[p^1][2]+=tmp;
		res+=tmp;
		if (ff==0) break;
	}
	return res;
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v)
{
	addedge(p,q,v);
	addedge(q,p,0);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i;
	for (i=1;i&lt;=m;i++) scanf(&quot;%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
	scanf(&quot;%d%d%d&quot;,&amp;t.a,&amp;t.b,&amp;t.w);
	for (i=1;i&lt;=m;i++)
		if (e[i].w&lt;t.w)
		{
			add(e[i].a,e[i].b,1);
			add(e[i].b,e[i].a,1);
		}
	S=t.a,T=t.b;
	int ans=0;
	while (bfs()) ans+=dfs(S,inf);
	memset(o,0,sizeof(o));
	tot=1;
	for (i=1;i&lt;=m;i++)
		if (e[i].w&gt;t.w)
		{
			add(e[i].a,e[i].b,1);
			add(e[i].b,e[i].a,1);
		}
	while (bfs()) ans+=dfs(S,inf);
	printf(&quot;%d\n&quot;,ans);
}
<pre><h2>Problem2563</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,m,a[10111];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
	if (f) x=-x;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	int ans=0;
	int i,x,y,z;
	for (i=1;i&lt;=n;i++)
	{
		read(x);
		a[i]=x&lt;&lt;1;
		ans-=x;
	}
	for (i=1;i&lt;=m;i++)
	{
		read(x),read(y),read(z);
		a[x]+=z,a[y]+=z;
		ans-=z;
	}
	sort(a+1,a+n+1);
	for (i=n;i&gt;0;i-=2) ans+=a[i];
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem2563</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,m,a[10111];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
	if (f) x=-x;
}
int main()
{
	read(n),read(m);
	int ans=0;
	int i,x,y,z;
	for (i=1;i&lt;=n;i++)
	{
		read(x);
		a[i]=x&lt;&lt;1;
		ans-=x;
	}
	for (i=1;i&lt;=m;i++)
	{
		read(x),read(y),read(z);
		a[x]+=z,a[y]+=z;
		ans-=z;
	}
	sort(a+1,a+n+1);
	for (i=n;i&gt;0;i-=2) ans+=a[i];
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem2566</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;set&gt;
#include&lt;map&gt;
using namespace std;
#define inf 999999999
#define ln printf(&quot;\n&quot;)
const int NN=12011;
int o[NN],aa[NN&lt;&lt;1][3],dist[NN],size[NN],deep[NN],fa[NN],f[17][NN],ceng[NN],boss[NN],color[NN];
int n,m,tot=1;
multiset&lt;int&gt; ans;
map&lt;int,multiset&lt;int&gt; &gt; S[NN];
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs(int v)
{
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		dist[y]=dist[v]+aa[p][2];
		dfs(y);
	}
}
inline int getlca(int x,int y)
{
	if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
	for (int i=16;i&gt;=0;i--)
		if (deep[f[i][x]]&gt;=deep[y]) x=f[i][x];
	if (x==y) return x;
	for (int i=16;i&gt;=0;i--)
		if (f[i][x]!=f[i][y]) x=f[i][x],y=f[i][y];
	return f[0][x];
}
inline int getdist(int x,int y)
{
	int lca=getlca(x,y);
	return dist[x]+dist[y]-(dist[lca]&lt;&lt;1);
}
void calcsize(int v)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||ceng[y]&lt;ceng[v]) continue;
		fa[y]=v;
		calcsize(y);
		size[v]+=size[y];
	}
}
int getcore(int v)
{
	fa[v]=0,calcsize(v);
	for (;;)
	{
		bool flag=false;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (ceng[y]&lt;ceng[v]) continue;
			if (size[y]&lt;&lt;1&gt;size[v])
			{
				size[v]-=size[y];
				size[y]+=size[v];
				v=y;flag=true;break;
			}
		}
		if (!flag) break;
	}
	return v;
}
void work(int v)
{
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (ceng[y]&lt;ceng[v]) continue;
		y=getcore(y);
		ceng[y]=ceng[v]+1;
		boss[y]=v;
		work(y);
	}
}
void modify(int x,int c)
{
	for (int y=x;y;y=boss[y])
	{
		int d=getdist(x,y);
		if (S[y][color[x]].size()&gt;1)
			ans.erase(ans.find(*S[y][color[x]].begin()+*(++S[y][color[x]].begin())));
		S[y][color[x]].erase(S[y][color[x]].find(d));
		if (S[y][color[x]].size()&gt;1)
			ans.insert(*S[y][color[x]].begin()+*(++S[y][color[x]].begin()));
		if (S[y][c].size()&gt;1)
			ans.erase(ans.find(*S[y][c].begin()+*(++S[y][c].begin())));
		S[y][c].insert(d);
		if (S[y][c].size()&gt;1)
			ans.insert(*S[y][c].begin()+*(++S[y][c].begin()));
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j,x,y,z;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;color[i]);
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
	}
	deep[1]=1,dfs(1);
	for (i=1;i&lt;=n;i++) f[0][i]=fa[i];
	for (j=1;j&lt;=16;j++)
		for (i=1;i&lt;=n;i++) f[j][i]=f[j-1][f[j-1][i]];
	int t=getcore(1);
	memset(ceng,60,sizeof(ceng));
	ceng[t]=1,work(t);
	//printf(&quot;boss &quot;);out(boss,1,n);ln;
	ans.insert(inf);
	for (i=1;i&lt;=n;i++)
		for (int y=i;y;y=boss[y])
			S[y][color[i]].insert(getdist(i,y));
	for (i=1;i&lt;=n;i++)
		for (map&lt;int,multiset&lt;int&gt; &gt;::iterator it=S[i].begin();it!=S[i].end();it++)
			if ((*it).second.size()&gt;1) ans.insert(*(*it).second.begin()+*(++(*it).second.begin()));
	if (*ans.begin()==inf) printf(&quot;-1\n&quot;);
	else printf(&quot;%d\n&quot;,*ans.begin());
	for (scanf(&quot;%d&quot;,&amp;m);m;m--)
	{
		//printf(&quot;\n---------------------------------------------------------\n&quot;);
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		modify(x,y);
		color[x]=y;
		if (*ans.begin()==inf) printf(&quot;-1\n&quot;);
		else printf(&quot;%d\n&quot;,*ans.begin());
	}
	return 0;
}<pre><h2>Problem2566</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;set&gt;
#include&lt;map&gt;
using namespace std;
#define inf 999999999
const int NN=12011;
int o[NN],aa[NN&lt;&lt;1][3],dist[NN],size[NN],deep[NN],fa[NN],f[17][NN],ceng[NN],boss[NN],color[NN];
int n,m,tot=1;
multiset&lt;int&gt; ans;
map&lt;int,multiset&lt;int&gt; &gt; S[NN];
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs(int v)
{
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		dist[y]=dist[v]+aa[p][2];
		dfs(y);
	}
}
inline int getlca(int x,int y)
{
	if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
	for (int i=16;i&gt;=0;i--)
		if (deep[f[i][x]]&gt;=deep[y]) x=f[i][x];
	if (x==y) return x;
	for (int i=16;i&gt;=0;i--)
		if (f[i][x]!=f[i][y]) x=f[i][x],y=f[i][y];
	return f[0][x];
}
inline int getdist(int x,int y)
{
	int lca=getlca(x,y);
	return dist[x]+dist[y]-(dist[lca]&lt;&lt;1);
}
void calcsize(int v)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||ceng[y]&lt;ceng[v]) continue;
		fa[y]=v;
		calcsize(y);
		size[v]+=size[y];
	}
}
int getcore(int v)
{
	fa[v]=0,calcsize(v);
	for (;;)
	{
		bool flag=false;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (ceng[y]&lt;ceng[v]) continue;
			if (size[y]&lt;&lt;1&gt;size[v])
			{
				size[v]-=size[y];
				size[y]+=size[v];
				v=y;flag=true;break;
			}
		}
		if (!flag) break;
	}
	return v;
}
void work(int v)
{
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (ceng[y]&lt;ceng[v]) continue;
		y=getcore(y);
		ceng[y]=ceng[v]+1;
		boss[y]=v;
		work(y);
	}
}
void modify(int x,int c)
{
	for (int y=x;y;y=boss[y])
	{
		int d=getdist(x,y);
		if (S[y][color[x]].size()&gt;1)
			ans.erase(ans.find(*S[y][color[x]].begin()+*(++S[y][color[x]].begin())));
		S[y][color[x]].erase(S[y][color[x]].find(d));
		if (S[y][color[x]].size()&gt;1)
			ans.insert(*S[y][color[x]].begin()+*(++S[y][color[x]].begin()));
		if (S[y][c].size()&gt;1)
			ans.erase(ans.find(*S[y][c].begin()+*(++S[y][c].begin())));
		S[y][c].insert(d);
		if (S[y][c].size()&gt;1)
			ans.insert(*S[y][c].begin()+*(++S[y][c].begin()));
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j,x,y,z;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;color[i]);
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
	}
	deep[1]=1,dfs(1);
	for (i=1;i&lt;=n;i++) f[0][i]=fa[i];
	for (j=1;j&lt;=16;j++)
		for (i=1;i&lt;=n;i++) f[j][i]=f[j-1][f[j-1][i]];
	int t=getcore(1);
	memset(ceng,60,sizeof(ceng));
	ceng[t]=1,work(t);
	ans.insert(inf);
	for (i=1;i&lt;=n;i++)
		for (int y=i;y;y=boss[y])
			S[y][color[i]].insert(getdist(i,y));
	for (i=1;i&lt;=n;i++)
		for (map&lt;int,multiset&lt;int&gt; &gt;::iterator it=S[i].begin();it!=S[i].end();it++)
			if ((*it).second.size()&gt;1) ans.insert(*(*it).second.begin()+*(++(*it).second.begin()));
	if (*ans.begin()==inf) printf(&quot;-1\n&quot;);
	else printf(&quot;%d\n&quot;,*ans.begin());
	for (scanf(&quot;%d&quot;,&amp;m);m;m--)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		modify(x,y);
		color[x]=y;
		if (*ans.begin()==inf) printf(&quot;-1\n&quot;);
		else printf(&quot;%d\n&quot;,*ans.begin());
	}
	return 0;
}<pre><h2>Problem2580</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int n,K,SIZE,i,j,k,ans,son[1000][3],fail[1000],num[1000],q[1000],f[1101][1000];
char s[25][25];
int max(int a,int b) {return a&gt;b?a:b;}
void ACins(int t)
{
	int len,i,j,ss[25];
	len=strlen(s[t]+1);
	for (i=1;i&lt;=len;i++) ss[i]=s[t][i]-'A';
	int now=1;
	for (i=1;i&lt;=len;i++)
		if (son[now][ss[i]]!=0) now=son[now][ss[i]];
		else
		{
			son[now][ss[i]]=++SIZE;
			now=SIZE;
			fail[now]=0;
			for (j=0;j&lt;=2;j++) son[now][j]=0;
		}
	num[now]++;
}
void buildfail()
{
	int head=0,tail,x,i;
	q[tail=1]=1;
	while (head&lt;tail)
	{
		//printf(&quot;tail:%d\n&quot;,tail);
		x=q[++head];
		num[x]+=num[fail[x]];
		for (i=0;i&lt;=2;i++)
			if (son[x][i]==0) son[x][i]=son[fail[x]][i];
			else
			{
				fail[son[x][i]]=son[fail[x]][i];
				q[++tail]=son[x][i];
			}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d %d &quot;,&amp;n,&amp;K);
	for (i=0;i&lt;=2;i++) son[0][i]=1,son[1][i]=0;
	SIZE=1;
	for (i=1;i&lt;=n;i++) scanf(&quot;%s&quot;,s[i]+1),ACins(i);
	//for (int ii=1;ii&lt;=SIZE;ii++){printf(&quot;%d %d %d %d | %d %d\n&quot;,ii,son[ii][0],son[ii][1],son[ii][2],num[ii],fail[ii]);}printf(&quot;-----------\n&quot;);
	buildfail();
	//for (int ii=1;ii&lt;=SIZE;ii++){printf(&quot;%d %d %d %d | %d %d\n&quot;,ii,son[ii][0],son[ii][1],son[ii][2],num[ii],fail[ii]);}printf(&quot;-----------\n&quot;);
	memset(f,-1,sizeof(f));
	f[0][1]=0;
	for (i=0;i&lt;=K;i++)
		for (j=1;j&lt;=SIZE;j++)
		if (f[i][j]&gt;=0)
			for (k=0;k&lt;=2;k++)
				f[i+1][son[j][k]]=max(f[i+1][son[j][k]],f[i][j]+num[son[j][k]]);
	//for (i=1;i&lt;=K;i++){for (j=1;j&lt;=SIZE;j++) printf(&quot;%d &quot;,f[i][j]);printf(&quot;\n&quot;);}
	for (j=1;j&lt;=SIZE;j++) ans=max(ans,f[K][j]);
	//for (int i=1;i&lt;=SIZE;i++){printf(&quot;%d %d %d %d\n&quot;,i,son[i][0],son[i][1],son[i][2]);}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2580</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int n,K,SIZE,i,j,k,ans,son[1000][3],fail[1000],num[1000],q[1000],f[1101][1000];
char s[25][25];
int max(int a,int b) {return a&gt;b?a:b;}
void ACins(int t)
{
	int len,i,j,ss[25];
	len=strlen(s[t]+1);
	for (i=1;i&lt;=len;i++) ss[i]=s[t][i]-'A';
	int now=1;
	for (i=1;i&lt;=len;i++)
		if (son[now][ss[i]]!=0) now=son[now][ss[i]];
		else
		{
			son[now][ss[i]]=++SIZE;
			now=SIZE;
			fail[now]=0;
			for (j=0;j&lt;=2;j++) son[now][j]=0;
		}
	num[now]++;
}
void buildfail()
{
	int head=0,tail,x,i;
	q[tail=1]=1;
	while (head&lt;tail)
	{
		x=q[++head];
		num[x]+=num[fail[x]];
		for (i=0;i&lt;=2;i++)
			if (son[x][i]==0) son[x][i]=son[fail[x]][i];
			else
			{
				fail[son[x][i]]=son[fail[x]][i];
				q[++tail]=son[x][i];
			}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d %d &quot;,&amp;n,&amp;K);
	for (i=0;i&lt;=2;i++) son[0][i]=1,son[1][i]=0;
	SIZE=1;
	for (i=1;i&lt;=n;i++) scanf(&quot;%s&quot;,s[i]+1),ACins(i);
	buildfail();
	memset(f,128,sizeof(f));
	f[0][1]=0;
	for (i=0;i&lt;=K;i++)
		for (j=1;j&lt;=SIZE;j++)
			for (k=0;k&lt;=2;k++)
				f[i+1][son[j][k]]=max(f[i+1][son[j][k]],f[i][j]+num[son[j][k]]);
	for (j=1;j&lt;=SIZE;j++) ans=max(ans,f[K][j]);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2580</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int NN=1005,AA=311;
int f[NN][AA],son[AA][3],fail[AA],num[AA],q[AA];
int n,K,TTT;
char s[17];
void ins(int len)
{
	int now=1;
	for (int i=1;i&lt;=len;i++)
	{
		int t=s[i]-'A';
		if (son[now][t]) now=son[now][t];
		else now=son[now][t]=++TTT;
	}
	num[now]=1;
}
void buildfail()
{
	int head=0,tail=1;
	q[1]=1;
	while (head&lt;tail)
	{
		int x=q[++head];
		num[x]+=num[fail[x]];
		for (int i=0;i&lt;3;i++)
			if (son[x][i]==0) son[x][i]=son[fail[x]][i];
			else
			{
				fail[son[x][i]]=son[fail[x]][i];
				q[++tail]=son[x][i];
			}
	}
}
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	int i,j,k;
	for (i=0;i&lt;3;i++) son[1][i]=0,son[0][i]=1;
	TTT=1;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s&quot;,s+1);
		ins(strlen(s+1));
	}
	buildfail();
	memset(f,-60,sizeof(f));
	f[0][1]=0;
	for (i=0;i&lt;K;i++)
		for (j=1;j&lt;=TTT;j++) if (f[i][j]&gt;=0)
			for (k=0;k&lt;3;k++)
			{
				int t=son[j][k];
				if (f[i+1][t]&lt;0) f[i+1][t]=f[i][j]+num[t];
				else f[i+1][t]=max(f[i+1][t],f[i][j]+num[t]);
			}
	int ans=0;
	for (i=1;i&lt;=TTT;i++)
		if (f[K][i]&gt;ans) ans=f[K][i];
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem2580</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int AA=311;
int son[AA][26],num[AA],fail[AA],f[1111][AA];
int n,K,TTT;
char s[17];
void ins(int len)
{
	int now=1;
	for (int i=1;i&lt;=len;i++)
	{
		int t=s[i]-'A';
		if (son[now][t]) now=son[now][t];
		else now=son[now][t]=++TTT;
	}
	num[now]++;
}
void build()
{
	static int que[AA];
	int head=0,tail=1;
	que[1]=1;
	while (head&lt;tail)
	{
		int x=que[++head];
		num[x]+=num[fail[x]];
		for (int i=0;i&lt;26;i++)
			if (son[x][i]==0) son[x][i]=son[fail[x]][i];
			else
			{
				fail[son[x][i]]=son[fail[x]][i];
				que[++tail]=son[x][i];
			}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;K);
	int i,j,k;
	for (i=0;i&lt;26;i++) son[1][i]=0,son[0][i]=1;
	TTT=1;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s\n&quot;,s+1);
		ins(strlen(s+1));
	}
	build();
	memset(f,-1,sizeof(f));
	f[0][1]=0;
	for (i=0;i&lt;K;i++)
		for (j=1;j&lt;=TTT;j++) if (f[i][j]&gt;=0)
			for (k=0;k&lt;26;k++)
			{
				int t=son[j][k];
				f[i+1][t]=max(f[i+1][t],f[i][j]+num[t]);
			}
	int ans=0;
	for (i=1;i&lt;=TTT;i++)
		if (f[K][i]&gt;ans) ans=f[K][i];
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem2580</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
int que[1000000],fail[1000000],son[100000][26],f[3000][3000],num[100000];
int n,K,TTT;
char s[100000];
void buildfail()
{
	int head=0,tail=1;
	que[1]=1;
	while (head&lt;tail)
	{
		//printf(&quot;%d\n&quot;,tail);
		int x=que[++head];
		num[x]+=num[fail[x]];
		for (int i=0;i&lt;26;i++)
			if (son[x][i]==0) son[x][i]=son[fail[x]][i];
			else
			{
				fail[son[x][i]]=son[fail[x]][i];
				que[++tail]=son[x][i];
			}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);//freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;K);
	int i,j,k;
	for (i=0;i&lt;26;i++) son[0][i]=1,son[1][i]=0;
	TTT=1;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s\n&quot;,s+1);
		int now=1,len=strlen(s+1);
		for (j=1;j&lt;=len;j++)
		{
			int t=s[j]-'A';
			if (son[now][t]) now=son[now][t];
			else now=son[now][t]=++TTT;
		}
		num[now]++;
	}
	//printf(&quot;0\n&quot;);
	buildfail();
	//printf(&quot;0\n&quot;);
	memset(f,-1,sizeof(f));
	f[0][1]=0;
	for (i=0;i&lt;K;i++)
		for (j=1;j&lt;=TTT;j++) if (f[i][j]!=-1)
			for (k=0;k&lt;26;k++)
			{
				int t=son[j][k];
				f[i+1][t]=max(f[i+1][t],f[i][j]+num[t]);
			}
	int ans=0;
	for (i=1;i&lt;=TTT;i++) ans=max(ans,f[K][i]);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem2580</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
int que[1000000],fail[1000000],son[100000][26],f[3000][3000],num[100000];
int n,K,TTT;
char s[100000];
void buildfail()
{
    int head=0,tail=1;
    que[1]=1;
    while (head&lt;tail)
    {
        //printf(&quot;%d\n&quot;,tail);
        int x=que[++head];
        num[x]+=num[fail[x]];
        for (int i=0;i&lt;26;i++)
            if (son[x][i]==0) son[x][i]=son[fail[x]][i];
            else
            {
                fail[son[x][i]]=son[fail[x]][i];
                que[++tail]=son[x][i];
            }
    }
}
int main()
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);//freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d%d\n&quot;,&amp;n,&amp;K);
    int i,j,k;
    for (i=0;i&lt;26;i++) son[0][i]=1;//,son[1][i]=0;
    TTT=1;
    for (i=1;i&lt;=n;i++)
    {
        scanf(&quot;%s\n&quot;,s+1);
        int now=1,len=strlen(s+1);
        for (j=1;j&lt;=len;j++)
        {
            int t=s[j]-'A';
            if (son[now][t]) now=son[now][t];
            else now=son[now][t]=++TTT;
        }
        num[now]++;
    }
    //printf(&quot;0\n&quot;);
    buildfail();
    //printf(&quot;0\n&quot;);
    memset(f,-1,sizeof(f));
    f[0][1]=0;
    for (i=0;i&lt;K;i++)
        for (j=1;j&lt;=TTT;j++) if (f[i][j]!=-1)
            for (k=0;k&lt;26;k++)
            {
                int t=son[j][k];
                f[i+1][t]=max(f[i+1][t],f[i][j]+num[t]);
            }
    int ans=0;
    for (i=1;i&lt;=TTT;i++) ans=max(ans,f[K][i]);
    printf(&quot;%d\n&quot;,ans);
    return 0;
}<pre><h2>Problem2580</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
using namespace std;
const int N=110000;
char s[N];
int ch[N][3],sz,val[N],fail[N],last[N],num[N],f[1100][11000],n,K,ans;
queue&lt;int&gt;Q;
void insert(char *s,int v)
{
    int l=strlen(s),u=1;
    for(int i=0;i&lt;l;i++)
    {
        int c=s[i]-'A';
        if(!ch[u][c])
            ch[u][c]=++sz;
        u=ch[u][c];
    }
    val[u]+=v;
} 
void getfail()
{
    Q.push(1);
    while(Q.size())
    {
        int now=Q.front();Q.pop();
        for(int i=0;i&lt;3;i++)
        {
            int u=ch[now][i];
            if(!u) {ch[now][i]=ch[fail[now]][i]; continue;}
            Q.push(u);
            fail[u]=ch[fail[now]][i];
            val[u]+=val[fail[u]];
        }
    }
}
void find()
{
    memset(f,-0x3f,sizeof(f));
    f[0][1]=0;
    for(int i=0;i&lt;K;i++)
        for(int j=1;j&lt;=sz;j++)if(f[i][j]&gt;=0)
          for(int k=0;k&lt;3;k++)
          {
            int next=ch[j][k];
            f[i+1][next]=max(f[i+1][next],f[i][j]+val[next]);
             
          }
}
int main() 
{
     
    scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	sz=1;for(int i=0;i&lt;3;i++) ch[0][i]=1;
    for(int i=1;i&lt;=n;i++)
      scanf(&quot;%s&quot;,s),insert(s,1);
    getfail();
    find();
    for(int i=0;i&lt;=sz;i++)
      ans=max(ans,f[K][i]);
    printf(&quot;%d\n&quot;,ans);
}<pre><h2>Problem2580</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
using namespace std;
const int N=110000;
char s[N];
int ch[N][3],sz,val[N],fail[N],last[N],num[N],f[1100][11000],n,K,ans;
queue&lt;int&gt;Q;
void insert(char *s,int v)
{
    int l=strlen(s),u=1;
    for(int i=0;i&lt;l;i++)
    {
        int c=s[i]-'A';
        if(!ch[u][c])
            ch[u][c]=++sz;
        u=ch[u][c];
    }
    val[u]+=v;
} 
void getfail()
{
    Q.push(1);
    while(Q.size())
    {
        int now=Q.front();Q.pop();
        for(int i=0;i&lt;3;i++)
        {
            int u=ch[now][i];
            if(!u) {ch[now][i]=ch[fail[now]][i]; continue;}
            Q.push(u);
            fail[u]=ch[fail[now]][i];
            val[u]+=val[fail[u]];
        }
    }
}
void find()
{
    memset(f,-0x3f,sizeof(f));
    f[0][1]=0;
    for(int i=0;i&lt;K;i++)
        for(int j=1;j&lt;=sz;j++)//if(f[i][j]&gt;=0)
          for(int k=0;k&lt;3;k++)
          {
            int next=ch[j][k];
            f[i+1][next]=max(f[i+1][next],f[i][j]+val[next]);
             
          }
}
int main() 
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	sz=1;
	for(int i=0;i&lt;3;i++) ch[0][i]=1;
    for(int i=1;i&lt;=n;i++)
      scanf(&quot;%s&quot;,s),insert(s,1);
    getfail();
    find();
    for(int i=0;i&lt;=sz;i++)
      ans=max(ans,f[K][i]);
    printf(&quot;%d\n&quot;,ans);
}<pre><h2>Problem2588</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int AA=2001111,NN=101111;
int o[NN],aa[NN*2][2],b[NN],w[NN],lc[AA],rc[AA],size[AA],deep[NN];
int root[NN],fa[19][NN];
int n,m,tot,TTT;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	while (ch&lt;'0'||ch&gt;'9')
		{if (ch=='-') f=true;ch=getchar();}
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
	if (f) x=-x;
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int cha(int x)
{
	int l=1,r=n;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (b[mid]==x) return mid;
		if (b[mid]&gt;x) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
void ins(int &amp;v,int u,int l,int r,int x)
{
	if (v==0) v=++TTT;
	size[v]=size[u]+1;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid) rc[v]=rc[u],ins(lc[v],lc[u],l,mid,x);
	else lc[v]=lc[u],ins(rc[v],rc[u],mid,r,x);
}
void dfs(int v)
{
	ins(root[v],root[fa[0][v]],1,n+1,w[v]);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[0][v]) continue;
		fa[0][y]=v;
		deep[y]=deep[v]+1;
		dfs(y);
	}
}
int find(int a,int b,int c,int d,int l,int r,int K)
{
	if (r-l==1) return l;
	int mid=(l+r)&gt;&gt;1;
	int tmp=size[lc[a]]+size[lc[b]]-size[lc[c]]-size[lc[d]];
	if (K&lt;=tmp) return find(lc[a],lc[b],lc[c],lc[d],l,mid,K);
	else return find(rc[a],rc[b],rc[c],rc[d],mid,r,K-tmp);
}
int getlca(int x,int y)
{
	if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
	for (int i=18;i&gt;=0;i--)
		if (deep[fa[i][x]]&gt;=deep[y]) x=fa[i][x];
	if (x==y) return x;
	for (int i=18;i&gt;=0;i--)
		if (fa[i][x]!=fa[i][y]) x=fa[i][x],y=fa[i][y];
	return fa[0][x];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	int i,j,x,y,K;
	for (i=1;i&lt;=n;i++) read(w[i]),b[i]=w[i];
	sort(b+1,b+n+1);
	for (i=1;i&lt;=n;i++) w[i]=cha(w[i]);
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y);
		addedge(x,y),addedge(y,x);
	}
	deep[1]=1;
	dfs(1);
	for (j=1;j&lt;=18;j++)
		for (i=1;i&lt;=n;i++) fa[j][i]=fa[j-1][fa[j-1][i]];
	int lastans=0;
	for (;m;m--)
	{
		read(x),read(y),read(K);
		x^=lastans;
		int lca=getlca(x,y);
		lastans=find(root[x],root[y],root[lca],root[fa[0][lca]],1,n+1,K);
		lastans=b[lastans];
		printf(m==1?&quot;%d&quot;:&quot;%d\n&quot;,lastans);
	}
	return 0;
}<pre><h2>Problem2594</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 100111
#define MM 3001111
#define QQ 100111
#define shuchu(i) printf(&quot;%d %d %d %d\n&quot;,e[i].a,e[i].b,e[i].w,e[i].id)
int fa[NN*2],tmm[NN*2],tw[NN*2],tmax[NN*2],son[NN*2][2],tag[NN*2],which[NN*2],ans[QQ],ff[NN];
int n,m,Q,TTT;
bool rrr[NN*2],flag[MM];
struct edge {int id,a,b,w;} e[MM];
struct ppt {int kind,a,b,id;} task[QQ];
int getint()
{
	char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	int tmp=0;
	for (;'0'&lt;=ch&amp;&amp;ch&lt;='9';ch=getchar()) tmp=tmp*10+ch-'0';
	return tmp;
}
void update(int v)
{
	int x=son[v][0],y=son[v][1];
	tmax[v]=tw[v];
	tmm[v]=v;
	if (tmax[x]&gt;tmax[v]) tmax[v]=tmax[x],tmm[v]=tmm[x];
	if (tmax[y]&gt;tmax[v]) tmax[v]=tmax[y],tmm[v]=tmm[y];
}
void rev(int v)
{
	tag[v]=!tag[v];
	swap(son[v][0],son[v][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	rev(son[v][0]);
	rev(son[v][1]);
	tag[v]=false;
}
//void zhong(int v) {if (v==0) return;pushdown(v);zhong(son[v][0]);zhong(son[v][1]);}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	//printf(&quot;			splaying %d\n&quot;,t);
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	//printf(&quot;			splay end.\n&quot;);
}
int access(int x)
{
	//printf(&quot;      access %d begin.\n&quot;,x);
	//printf(&quot;fa &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,fa[i]);printf(&quot;\n&quot;);
	//printf(&quot;rrr &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,rrr[i]?1:0);printf(&quot;\n&quot;);
	//printf(&quot;son &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d %d   &quot;,son[i][0],son[i][1]);printf(&quot;\n&quot;);
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		//printf(&quot;fa[1]=%d\n&quot;,fa[1]);printf(&quot;fa[8]=%d\n&quot;,fa[8]);
		//printf(&quot;		----- x=%d y=%d------------\n&quot;,x,y);
		splay(x);
		//printf(&quot;		access splay end.\n&quot;);
		//printf(&quot;fa &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,fa[i]);printf(&quot;\n&quot;);
		//printf(&quot;rrr &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,rrr[i]?1:0);printf(&quot;\n&quot;);
		//printf(&quot;son &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d %d   &quot;,son[i][0],son[i][1]);printf(&quot;\n&quot;);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
	//printf(&quot;fa &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,fa[i]);printf(&quot;\n&quot;);
	//printf(&quot;rrr &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,rrr[i]?1:0);printf(&quot;\n&quot;);
	//printf(&quot;son &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d %d   &quot;,son[i][0],son[i][1]);printf(&quot;\n&quot;);
	//printf(&quot;      access end.\n&quot;);
	return y;
}
void makeroot(int v)
{
	//printf(&quot;  makeroot %d begin\n&quot;,v);
	access(v);
	//printf(&quot;fa &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,fa[i]);printf(&quot;\n&quot;);
	//printf(&quot;rrr &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,rrr[i]?1:0);printf(&quot;\n&quot;);
	//printf(&quot;son &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d %d   &quot;,son[i][0],son[i][1]);printf(&quot;\n&quot;);
	//printf(&quot;access end.\n&quot;);
	splay(v);
	rev(v);
	//printf(&quot;  makeroot end.\n&quot;);
}
void link(int x,int y)
{
	//printf(&quot;\nlink %d and %d begin.\n&quot;,x,y);
	makeroot(x);
	//printf(&quot;fa &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,fa[i]);printf(&quot;\n&quot;);
	//printf(&quot;rrr &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,rrr[i]?1:0);printf(&quot;\n&quot;);
	splay(x);
	access(y);
	fa[x]=y;
	rrr[x]=false;
	son[y][1]=x;
	//printf(&quot;link end.\n&quot;);
}
void cut(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	fa[x]=fa[y];
	son[y][0]=fa[y]=0;
	rrr[x]=true;
}
int getroot(int x)
{
	//printf(&quot;getroot %d\n&quot;,x);
	access(x);
	splay(x);
	if (son[x][0]==0)
	{
		//printf(&quot;root is %d\n&quot;,x);printf(&quot;\n&quot;);
		return x;
	}
	for (x=son[x][0];son[x][0];x=son[x][0]);
	//printf(&quot;root is %d\n&quot;,x);printf(&quot;\n&quot;);
	return x;
}
int findid(int x,int y)
{
	//printf(&quot;findid %d %d\n&quot;,x,y);
	makeroot(x);
	//for (int i=1;i&lt;=TTT;i++) zhong(i);
	//printf(&quot;fa &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,fa[i]);printf(&quot;\n&quot;);
	//printf(&quot;rrr &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,rrr[i]?1:0);printf(&quot;\n&quot;);
	//printf(&quot;son &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d %d   &quot;,son[i][0],son[i][1]);printf(&quot;\n&quot;);
	//printf(&quot;asd\n&quot;);
	access(y);
	//printf(&quot;fa &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,fa[i]);printf(&quot;\n&quot;);
	//printf(&quot;rrr &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,rrr[i]?1:0);printf(&quot;\n&quot;);
	//printf(&quot;son &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d %d   &quot;,son[i][0],son[i][1]);printf(&quot;\n&quot;);
	splay(y);
	//printf(&quot;tw &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,tw[i]);printf(&quot;\n&quot;);
	//printf(&quot;findid end with the id of %d\n\n&quot;,tmm[y]);
	return tmm[y];
}
bool cmp(edge a,edge b) {return a.a==b.a?a.b&lt;b.b:a.a&lt;b.a;}
int cha(int x,int y)
{
	int l=1,r=m;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (e[mid].a==x&amp;&amp;e[mid].b==y) return mid;
		if (e[mid].a&gt;x||(e[mid].a==x&amp;&amp;e[mid].b&gt;y)) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
int getfa(int x) {return ff[x]==x?x:ff[x]=getfa(ff[x]);}
bool cmp2(edge a,edge b) {return a.w&lt;b.w;}
bool cmp3(edge a,edge b) {return a.id&lt;b.id;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;Q);
	int i,x,y,kind,tmp;
	for (i=1;i&lt;=m;i++)
	{
		e[i].a=getint(),e[i].b=getint(),e[i].w=getint();
		if (e[i].a&gt;e[i].b) swap(e[i].a,e[i].b);
	}
	sort(e+1,e+m+1,cmp);
	//for (i=1;i&lt;=m;i++) shuchu(i);
	for (i=1;i&lt;=m;i++) e[i].id=i;
	for (i=1;i&lt;=Q;i++)
	{
		kind=getint(),x=getint(),y=getint();
		if (x&gt;y) swap(x,y);
		task[i].kind=kind,task[i].a=x,task[i].b=y;
		if (kind==2)
		{
			task[i].id=cha(x,y);
			//printf(&quot;%d\n&quot;,task[i].id);
			flag[task[i].id]=true;
		}
	}
	//for (i=1;i&lt;=Q;i++) printf(&quot;%d %d %d %d\n&quot;,task[i].kind,task[i].a,task[i].b,task[i].id);
	sort(e+1,e+m+1,cmp2);
	//for (i=1;i&lt;=m;i++) shuchu(i);
	//for (i=1;i&lt;=m;i++) if (flag[e[i].id]) printf(&quot;asd %d\n&quot;,i);
	for (i=1;i&lt;=n;i++) rrr[i]=true,ff[i]=i;
	//printf(&quot;\n-------------------------------------------------------\n&quot;);
	for (TTT=n,tmp=0,i=1;i&lt;=m&amp;&amp;tmp&lt;n-1;i++)
	{
		if (flag[e[i].id]) continue;
		int x=e[i].a,y=e[i].b,id=e[i].id;
		int xx=getfa(x),yy=getfa(y);
		if (xx==yy) continue;
		ff[xx]=yy;
		TTT++;
		rrr[TTT]=true;
		which[TTT]=id;
		tw[TTT]=e[i].w;
		link(x,TTT);
		//printf(&quot;fa &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,fa[i]);printf(&quot;\n&quot;);
		//printf(&quot;rrr &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,rrr[i]?1:0);printf(&quot;\n&quot;);
		link(TTT,y);
		//printf(&quot;fa &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,fa[i]);printf(&quot;\n&quot;);
		//printf(&quot;rrr &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,rrr[i]?1:0);printf(&quot;\n&quot;);
		tmp++;
	}
	//printf(&quot;fa &quot;);for (i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,fa[i]);printf(&quot;\n&quot;);
	//printf(&quot;rrr &quot;);for (i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,rrr[i]?1:0);printf(&quot;\n&quot;);
	//printf(&quot;son &quot;);for (i=1;i&lt;=TTT;i++) printf(&quot;%d %d   &quot;,son[i][0],son[i][1]);printf(&quot;\n&quot;);
	//printf(&quot;\n---------------------------------------------------------------------------\n&quot;);
	sort(e+1,e+m+1,cmp3);
	for (int ii=Q;ii;ii--)
	{
		//printf(&quot;%d\n&quot;,ii);
		//printf(&quot;\n---------------------------------------------------------------------\n&quot;);
		//printf(&quot;%d\n&quot;,task[ii].kind);
		//printf(&quot;fa[1]=%d\n&quot;,fa[1]);
		//printf(&quot;fa &quot;);for (i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,fa[i]);printf(&quot;\n&quot;);
		//printf(&quot;rrr &quot;);for (i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,rrr[i]?1:0);printf(&quot;\n&quot;);
		//printf(&quot;son &quot;);for (i=1;i&lt;=TTT;i++) printf(&quot;%d %d   &quot;,son[i][0],son[i][1]);printf(&quot;\n&quot;);
		ppt t=task[ii];
		//printf(&quot;%d\n&quot;,t.kind);
		//printf(&quot;%d %d\n&quot;,t.a,t.b);
		if (t.kind==1) ans[ii]=tw[findid(t.a,t.b)];
		else if (getroot(t.a)!=getroot(t.b))
		{
			//printf(&quot;asdasdasd\n&quot;);
			//printf(&quot;fa &quot;);for (i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,fa[i]);printf(&quot;\n&quot;);
			//printf(&quot;rrr &quot;);for (i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,rrr[i]?1:0);printf(&quot;\n&quot;);
			//printf(&quot;son &quot;);for (i=1;i&lt;=TTT;i++) printf(&quot;%d %d   &quot;,son[i][0],son[i][1]);printf(&quot;\n&quot;);
			TTT++;
			rrr[TTT]=true;
			which[TTT]=t.id;
			tw[TTT]=e[t.id].w;
			link(t.a,TTT),link(TTT,t.b);
			//printf(&quot;fa &quot;);for (i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,fa[i]);printf(&quot;\n&quot;);
			//printf(&quot;rrr &quot;);for (i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,rrr[i]?1:0);printf(&quot;\n&quot;);
			//printf(&quot;son &quot;);for (i=1;i&lt;=TTT;i++) printf(&quot;%d %d   &quot;,son[i][0],son[i][1]);printf(&quot;\n&quot;);
		}
		else
		{
			//printf(&quot;asdasdasd\n&quot;);
			tmp=findid(t.a,t.b);
			if (e[which[tmp]].w&gt;e[task[ii].id].w)
			{
				cut(e[which[tmp]].a,tmp),cut(tmp,e[which[tmp]].b);
				//printf(&quot;cut end.\n&quot;);
				rrr[tmp]=true;
				which[tmp]=task[ii].id;
				//printf(&quot;%d\n&quot;,task[i].id);
				//printf(&quot;%d\n&quot;,task[2].id);
				tw[tmp]=e[task[ii].id].w;
				//printf(&quot;tw[tmp]=%d\n&quot;,tw[tmp]);
				link(t.a,tmp),link(tmp,t.b);
				//printf(&quot;link end.\n&quot;);
			}
		}
		//printf(&quot;\n&quot;);
		//for (i=1;i&lt;=TTT;i++) zhong(i);
		//printf(&quot;fa &quot;);for (i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,fa[i]);printf(&quot;\n&quot;);
		//printf(&quot;rrr &quot;);for (i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,rrr[i]?1:0);printf(&quot;\n&quot;);
		//printf(&quot;son &quot;);for (i=1;i&lt;=TTT;i++) printf(&quot;%d %d   &quot;,son[i][0],son[i][1]);printf(&quot;\n&quot;);
	}
	for (i=1;i&lt;=Q;i++)
		if (task[i].kind==1) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem2594</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 100111
#define MM 3001111
#define QQ 100111
int fa[NN*2],tmm[NN*2],tw[NN*2],tmax[NN*2],son[NN*2][2],tag[NN*2],which[NN*2],ans[QQ],ff[NN];
int n,m,Q,TTT;
bool rrr[NN*2],flag[MM];
struct edge {int id,a,b,w;} e[MM];
struct ppt {int kind,a,b,id;} task[QQ];
int getint()
{
	char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	int tmp=0;
	for (;'0'&lt;=ch&amp;&amp;ch&lt;='9';ch=getchar()) tmp=tmp*10+ch-'0';
	return tmp;
}
void update(int v)
{
	int x=son[v][0],y=son[v][1];
	tmax[v]=tw[v];
	tmm[v]=v;
	if (tmax[x]&gt;tmax[v]) tmax[v]=tmax[x],tmm[v]=tmm[x];
	if (tmax[y]&gt;tmax[v]) tmax[v]=tmax[y],tmm[v]=tmm[y];
}
void rev(int v)
{
	tag[v]=!tag[v];
	swap(son[v][0],son[v][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	rev(son[v][0]);
	rev(son[v][1]);
	tag[v]=false;
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
}
int access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
	return y;
}
void makeroot(int v)
{
	access(v);
	splay(v);
	rev(v);
}
void link(int x,int y)
{
	makeroot(x);
	splay(x);
	access(y);
	fa[x]=y;
	rrr[x]=false;
	son[y][1]=x;
}
void cut(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	fa[x]=fa[y];
	son[y][0]=fa[y]=0;
	rrr[x]=true;
}
int getroot(int x)
{
	access(x);
	splay(x);
	for (;son[x][0];x=son[x][0]);
	return x;
}
int findid(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	return tmm[y];
}
bool cmp(edge a,edge b) {return a.a==b.a?a.b&lt;b.b:a.a&lt;b.a;}
int cha(int x,int y)
{
	int l=1,r=m;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (e[mid].a==x&amp;&amp;e[mid].b==y) return mid;
		if (e[mid].a&gt;x||(e[mid].a==x&amp;&amp;e[mid].b&gt;y)) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
int getfa(int x) {return ff[x]==x?x:ff[x]=getfa(ff[x]);}
bool cmp2(edge a,edge b) {return a.w&lt;b.w;}
bool cmp3(edge a,edge b) {return a.id&lt;b.id;}
int main()
{
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;Q);
	int i,x,y,kind,tmp;
	for (i=1;i&lt;=m;i++)
	{
		e[i].a=getint(),e[i].b=getint(),e[i].w=getint();
		if (e[i].a&gt;e[i].b) swap(e[i].a,e[i].b);
	}
	sort(e+1,e+m+1,cmp);
	for (i=1;i&lt;=m;i++) e[i].id=i;
	for (i=1;i&lt;=Q;i++)
	{
		kind=getint(),x=getint(),y=getint();
		if (x&gt;y) swap(x,y);
		task[i].kind=kind,task[i].a=x,task[i].b=y;
		if (kind==2)
		{
			task[i].id=cha(x,y);
			flag[task[i].id]=true;
		}
	}
	sort(e+1,e+m+1,cmp2);
	for (i=1;i&lt;=n;i++) rrr[i]=true,ff[i]=i;
	for (TTT=n,tmp=0,i=1;i&lt;=m&amp;&amp;tmp&lt;n-1;i++)
	{
		if (flag[e[i].id]) continue;
		int x=e[i].a,y=e[i].b,id=e[i].id;
		int xx=getfa(x),yy=getfa(y);
		if (xx==yy) continue;
		ff[xx]=yy;
		TTT++;
		rrr[TTT]=true;
		which[TTT]=id;
		tw[TTT]=e[i].w;
		link(x,TTT),link(TTT,y);
		tmp++;
	}
	sort(e+1,e+m+1,cmp3);
	for (int ii=Q;ii;ii--)
	{
		ppt t=task[ii];
		if (t.kind==1) ans[ii]=tw[findid(t.a,t.b)];
		else if (getroot(t.a)!=getroot(t.b))
		{
			TTT++;
			rrr[TTT]=true;
			which[TTT]=t.id;
			tw[TTT]=e[t.id].w;
			link(t.a,TTT),link(TTT,t.b);
		}
		else
		{
			tmp=findid(t.a,t.b);
			if (e[which[tmp]].w&gt;e[task[ii].id].w)
			{
				cut(e[which[tmp]].a,tmp),cut(tmp,e[which[tmp]].b);
				rrr[tmp]=true;
				which[tmp]=task[ii].id;
				tw[tmp]=e[task[ii].id].w;
				link(t.a,tmp),link(tmp,t.b);
			}
		}
	}
	for (i=1;i&lt;=Q;i++)
		if (task[i].kind==1) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem2594</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 100111
#define MM 3001111
#define QQ 100111
int fa[NN*2],tmm[NN*2],tw[NN*2],tmax[NN*2],son[NN*2][2],tag[NN*2],which[NN*2],ans[QQ],ff[NN];
int n,m,Q,TTT;
bool rrr[NN*2],flag[MM];
struct edge {int id,a,b,w;} e[MM];
struct ppt {int kind,a,b,id;} task[QQ];
int getint()
{
	char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	int tmp=0;
	for (;'0'&lt;=ch&amp;&amp;ch&lt;='9';ch=getchar()) tmp=tmp*10+ch-'0';
	return tmp;
}
void update(int v)
{
	int x=son[v][0],y=son[v][1];
	tmax[v]=tw[v];
	tmm[v]=v;
	if (tmax[x]&gt;tmax[v]) tmax[v]=tmax[x],tmm[v]=tmm[x];
	if (tmax[y]&gt;tmax[v]) tmax[v]=tmax[y],tmm[v]=tmm[y];
}
void rev(int v)
{
	tag[v]=!tag[v];
	swap(son[v][0],son[v][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	rev(son[v][0]);
	rev(son[v][1]);
	tag[v]=false;
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
}
int access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
	return y;
}
void makeroot(int v)
{
	access(v);
	splay(v);
	rev(v);
}
void link(int x,int y)
{
	makeroot(x);
	splay(x);
	access(y);
	fa[x]=y;
	rrr[x]=false;
	son[y][1]=x;
}
void cut(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	fa[x]=fa[y];
	son[y][0]=fa[y]=0;
	rrr[x]=true;
}
int getroot(int x)
{
	access(x);
	splay(x);
	for (;son[x][0];x=son[x][0]);
	return x;
}
int findid(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	return tmm[y];
}
bool cmp(edge a,edge b) {return a.a==b.a?a.b&lt;b.b:a.a&lt;b.a;}
int cha(int x,int y)
{
	int l=1,r=m;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (e[mid].a==x&amp;&amp;e[mid].b==y) return mid;
		if (e[mid].a&gt;x||(e[mid].a==x&amp;&amp;e[mid].b&gt;y)) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
int getfa(int x) {return ff[x]==x?x:ff[x]=getfa(ff[x]);}
bool cmp2(edge a,edge b) {return a.w&lt;b.w;}
bool cmp3(edge a,edge b) {return a.id&lt;b.id;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;Q);
	int i,x,y,kind,tmp;
	for (i=1;i&lt;=m;i++)
	{
		//e[i].a=getint(),e[i].b=getint(),e[i].w=getint();
		scanf(&quot;%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
		if (e[i].a&gt;e[i].b) swap(e[i].a,e[i].b);
	}
	sort(e+1,e+m+1,cmp);
	for (i=1;i&lt;=m;i++) e[i].id=i;
	for (i=1;i&lt;=Q;i++)
	{
		//kind=getint(),x=getint(),y=getint();
		scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;x,&amp;y);
		if (x&gt;y) swap(x,y);
		task[i].kind=kind,task[i].a=x,task[i].b=y;
		if (kind==2)
		{
			task[i].id=cha(x,y);
			flag[task[i].id]=true;
		}
	}
	sort(e+1,e+m+1,cmp2);
	for (i=1;i&lt;=n;i++) rrr[i]=true,ff[i]=i;
	for (TTT=n,tmp=0,i=1;i&lt;=m&amp;&amp;tmp&lt;n-1;i++)
	{
		if (flag[e[i].id]) continue;
		int x=e[i].a,y=e[i].b,id=e[i].id;
		int xx=getfa(x),yy=getfa(y);
		if (xx==yy) continue;
		ff[xx]=yy;
		TTT++;
		rrr[TTT]=true;
		which[TTT]=id;
		tw[TTT]=e[i].w;
		link(x,TTT),link(TTT,y);
		tmp++;
	}
	sort(e+1,e+m+1,cmp3);
	for (int ii=Q;ii;ii--)
	{
		ppt t=task[ii];
		if (t.kind==1) ans[ii]=tw[findid(t.a,t.b)];
		else if (getroot(t.a)!=getroot(t.b))
		{
			TTT++;
			rrr[TTT]=true;
			which[TTT]=t.id;
			tw[TTT]=e[t.id].w;
			link(t.a,TTT),link(TTT,t.b);
		}
		else
		{
			tmp=findid(t.a,t.b);
			if (e[which[tmp]].w&gt;e[task[ii].id].w)
			{
				cut(e[which[tmp]].a,tmp),cut(tmp,e[which[tmp]].b);
				rrr[tmp]=true;
				which[tmp]=task[ii].id;
				tw[tmp]=e[task[ii].id].w;
				link(t.a,tmp),link(tmp,t.b);
			}
		}
	}
	for (i=1;i&lt;=Q;i++)
		if (task[i].kind==1) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem2594</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 100111
#define MM 1001111
#define QQ 100111
int fa[NN*2],tid[NN*2],key[NN*2],son[NN*2][2],tag[NN*2],which[NN*2],ans[QQ],ff[NN];
int n,m,Q,TTT;
bool rrr[NN*2],flag[MM];
struct edge {int id,a,b,w;} e[MM];
struct ppt {int kind,a,b,id;} task[QQ];
void update(int v)
{
	int x=son[v][0],y=son[v][1];
	tid[v]=v;
	if (key[tid[x]]&gt;key[tid[v]]) tid[v]=tid[x];
	if (key[tid[y]]&gt;key[tid[v]]) tid[v]=tid[y];
}
void rev(int v)
{
	tag[v]=!tag[v];
	swap(son[v][0],son[v][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	rev(son[v][0]);
	rev(son[v][1]);
	tag[v]=false;
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
}
int access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
	return y;
}
void makeroot(int v)
{
	access(v);
	splay(v);
	rev(v);
}
void link(int x,int y)
{
	makeroot(x);
	splay(x);
	access(y);
	fa[x]=y;
	rrr[x]=false;
	son[y][1]=x;
}
void cut(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	fa[x]=fa[y];
	son[y][0]=fa[y]=0;
	rrr[x]=true;
}
int getroot(int x)
{
	access(x);
	splay(x);
	for (;son[x][0];x=son[x][0]);
	return x;
}
int findid(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	return tid[y];
}
int cha(int x,int y)
{
	int l=1,r=m;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (e[mid].a==x&amp;&amp;e[mid].b==y) return mid;
		if (e[mid].a&gt;x||(e[mid].a==x&amp;&amp;e[mid].b&gt;y)) r=mid-1;
		else l=mid+1;
	}
}
int getfa(int x) {return ff[x]==x?x:ff[x]=getfa(ff[x]);}
bool cmp(edge a,edge b) {return a.a==b.a?a.b&lt;b.b:a.a&lt;b.a;}
bool cmp2(edge a,edge b) {return a.w&lt;b.w;}
bool cmp3(edge a,edge b) {return a.id&lt;b.id;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;Q);
	int i,x,y,kind,tmp;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
		if (e[i].a&gt;e[i].b) swap(e[i].a,e[i].b);
	}
	sort(e+1,e+m+1,cmp);
	for (i=1;i&lt;=m;i++) e[i].id=i;
	for (i=1;i&lt;=Q;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;x,&amp;y);
		if (x&gt;y) swap(x,y);
		task[i].kind=kind,task[i].a=x,task[i].b=y;
		if (kind==2)
		{
			task[i].id=cha(x,y);
			flag[task[i].id]=true;
		}
	}
	sort(e+1,e+m+1,cmp2);
	for (i=1;i&lt;=n;i++) rrr[i]=true,ff[i]=i;
	for (TTT=n,tmp=0,i=1;i&lt;=m&amp;&amp;tmp&lt;n-1;i++)
	{
		if (flag[e[i].id]) continue;
		int x=e[i].a,y=e[i].b,id=e[i].id;
		int xx=getfa(x),yy=getfa(y);
		if (xx==yy) continue;
		ff[xx]=yy;
		TTT++;
		rrr[TTT]=true;
		which[TTT]=id;
		key[TTT]=e[i].w;
		link(x,TTT),link(TTT,y);
		tmp++;
	}
	sort(e+1,e+m+1,cmp3);
	for (i=Q;i;i--)
	{
		ppt t=task[i];
		if (t.kind==1) ans[i]=key[findid(t.a,t.b)];
		else if (getroot(t.a)!=getroot(t.b))
		{
			TTT++;
			rrr[TTT]=true;
			which[TTT]=t.id;
			key[TTT]=e[t.id].w;
			link(t.a,TTT),link(TTT,t.b);
		}
		else
		{
			tmp=findid(t.a,t.b);
			if (e[which[tmp]].w&gt;e[t.id].w)
			{
				cut(e[which[tmp]].a,tmp),cut(tmp,e[which[tmp]].b);
				rrr[tmp]=true;
				which[tmp]=t.id;
				key[tmp]=e[t.id].w;
				link(t.a,tmp),link(tmp,t.b);
			}
		}
	}
	for (i=1;i&lt;=Q;i++)
		if (task[i].kind==1) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem2594</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 100111
#define MM 3001111
#define QQ 100111
int fa[NN*2],tid[NN*2],key[NN*2],tmax[NN*2],son[NN*2][2],tag[NN*2],which[NN*2],ans[QQ],ff[NN];
int n,m,Q,TTT;
bool rrr[NN*2],flag[MM];
struct edge {int id,a,b,w;} e[MM];
struct ppt {int kind,a,b,id;} task[QQ];
void update(int v)
{
	int x=son[v][0],y=son[v][1];
	tmax[v]=key[v];
	tid[v]=v;
	//if (tmax[x]&gt;tmax[v]) tmax[v]=tmax[x],tid[v]=tid[x];
	//if (tmax[y]&gt;tmax[v]) tmax[v]=tmax[y],tid[v]=tid[y];
	if (key[tid[x]]&gt;key[tid[v]]) tid[v]=tid[x];
	if (key[tid[y]]&gt;key[tid[v]]) tid[v]=tid[y];
}
void rev(int v)
{
	tag[v]=!tag[v];
	swap(son[v][0],son[v][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	rev(son[v][0]);
	rev(son[v][1]);
	tag[v]=false;
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
}
int access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
	return y;
}
void makeroot(int v)
{
	access(v);
	splay(v);
	rev(v);
}
void link(int x,int y)
{
	makeroot(x);
	splay(x);
	access(y);
	fa[x]=y;
	rrr[x]=false;
	son[y][1]=x;
}
void cut(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	fa[x]=fa[y];
	son[y][0]=fa[y]=0;
	rrr[x]=true;
}
int getroot(int x)
{
	access(x);
	splay(x);
	for (;son[x][0];x=son[x][0]);
	return x;
}
int findid(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	return tid[y];
}
int cha(int x,int y)
{
	int l=1,r=m;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (e[mid].a==x&amp;&amp;e[mid].b==y) return mid;
		if (e[mid].a&gt;x||(e[mid].a==x&amp;&amp;e[mid].b&gt;y)) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
int getfa(int x) {return ff[x]==x?x:ff[x]=getfa(ff[x]);}
bool cmp(edge a,edge b) {return a.a==b.a?a.b&lt;b.b:a.a&lt;b.a;}
bool cmp2(edge a,edge b) {return a.w&lt;b.w;}
bool cmp3(edge a,edge b) {return a.id&lt;b.id;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;Q);
	int i,x,y,kind,tmp;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
		if (e[i].a&gt;e[i].b) swap(e[i].a,e[i].b);
	}
	sort(e+1,e+m+1,cmp);
	for (i=1;i&lt;=m;i++) e[i].id=i;
	for (i=1;i&lt;=Q;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;x,&amp;y);
		if (x&gt;y) swap(x,y);
		task[i].kind=kind,task[i].a=x,task[i].b=y;
		if (kind==2)
		{
			task[i].id=cha(x,y);
			flag[task[i].id]=true;
		}
	}
	sort(e+1,e+m+1,cmp2);
	for (i=1;i&lt;=n;i++) rrr[i]=true,ff[i]=i;
	for (TTT=n,tmp=0,i=1;i&lt;=m&amp;&amp;tmp&lt;n-1;i++)
	{
		if (flag[e[i].id]) continue;
		int x=e[i].a,y=e[i].b,id=e[i].id;
		int xx=getfa(x),yy=getfa(y);
		if (xx==yy) continue;
		ff[xx]=yy;
		TTT++;
		rrr[TTT]=true;
		which[TTT]=id;
		key[TTT]=e[i].w;
		tid[TTT]=TTT;
		link(x,TTT),link(TTT,y);
		tmp++;
	}
	sort(e+1,e+m+1,cmp3);
	for (i=Q;i;i--)
	{
		ppt t=task[i];
		if (t.kind==1) ans[i]=key[findid(t.a,t.b)];
		else if (getroot(t.a)!=getroot(t.b))
		{
			TTT++;
			rrr[TTT]=true;
			which[TTT]=t.id;
			key[TTT]=e[t.id].w;
			tid[TTT]=TTT;
			link(t.a,TTT),link(TTT,t.b);
		}
		else
		{
			tmp=findid(t.a,t.b);
			if (e[which[tmp]].w&gt;e[t.id].w)
			{
				cut(e[which[tmp]].a,tmp),cut(tmp,e[which[tmp]].b);
				rrr[tmp]=true;
				which[tmp]=t.id;
				key[tmp]=e[t.id].w;
				tid[tmp]=tmp;
				link(t.a,tmp),link(tmp,t.b);
			}
		}
	}
	for (i=1;i&lt;=Q;i++)
		if (task[i].kind==1) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem2594</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 100111
#define MM 1001111
#define QQ 100111
int fa[NN*2],tid[NN*2],key[NN*2],son[NN*2][2],tag[NN*2],which[NN*2],ans[QQ],ff[NN];
int n,m,Q,TTT;
bool rrr[NN*2],flag[MM];
struct edge {int id,a,b,w;} e[MM];
struct ppt {int kind,a,b,id;} task[QQ];
void update(int v)
{
	int x=son[v][0],y=son[v][1];
	tid[v]=v;
	if (key[tid[x]]&gt;key[tid[v]]) tid[v]=tid[x];
	if (key[tid[y]]&gt;key[tid[v]]) tid[v]=tid[y];
}
void rev(int v)
{
	tag[v]=!tag[v];
	swap(son[v][0],son[v][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	rev(son[v][0]);
	rev(son[v][1]);
	tag[v]=false;
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
}
int access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
	return y;
}
void makeroot(int v)
{
	access(v);
	splay(v);
	rev(v);
}
void link(int x,int y)
{
	makeroot(x);
	splay(x);
	access(y);
	fa[x]=y;
	rrr[x]=false;
	son[y][1]=x;
}
void cut(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	fa[x]=fa[y];
	son[y][0]=fa[y]=0;
	rrr[x]=true;
}
int getroot(int x)
{
	access(x);
	splay(x);
	for (;son[x][0];x=son[x][0]);
	return x;
}
int findid(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	return tid[y];
}
int cha(int x,int y)
{
	int l=1,r=m;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (e[mid].a==x&amp;&amp;e[mid].b==y) return mid;
		if (e[mid].a&gt;x||(e[mid].a==x&amp;&amp;e[mid].b&gt;y)) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
int getfa(int x) {return ff[x]==x?x:ff[x]=getfa(ff[x]);}
bool cmp(edge a,edge b) {return a.a==b.a?a.b&lt;b.b:a.a&lt;b.a;}
bool cmp2(edge a,edge b) {return a.w&lt;b.w;}
bool cmp3(edge a,edge b) {return a.id&lt;b.id;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;Q);
	int i,x,y,kind,tmp;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
		if (e[i].a&gt;e[i].b) swap(e[i].a,e[i].b);
	}
	sort(e+1,e+m+1,cmp);
	for (i=1;i&lt;=m;i++) e[i].id=i;
	for (i=1;i&lt;=Q;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;x,&amp;y);
		if (x&gt;y) swap(x,y);
		task[i].kind=kind,task[i].a=x,task[i].b=y;
		if (kind==2)
		{
			task[i].id=cha(x,y);
			flag[task[i].id]=true;
		}
	}
	sort(e+1,e+m+1,cmp2);
	for (i=1;i&lt;=n;i++) rrr[i]=true,ff[i]=i;
	for (TTT=n,tmp=0,i=1;i&lt;=m&amp;&amp;tmp&lt;n-1;i++)
	{
		if (flag[e[i].id]) continue;
		int x=e[i].a,y=e[i].b,id=e[i].id;
		int xx=getfa(x),yy=getfa(y);
		if (xx==yy) continue;
		ff[xx]=yy;
		TTT++;
		rrr[TTT]=true;
		which[TTT]=id;
		key[TTT]=e[i].w;
		tid[TTT]=TTT;
		link(x,TTT),link(TTT,y);
		tmp++;
	}
	sort(e+1,e+m+1,cmp3);
	for (i=Q;i;i--)
	{
		ppt t=task[i];
		if (t.kind==1) ans[i]=key[findid(t.a,t.b)];
		else if (getroot(t.a)!=getroot(t.b))
		{
			TTT++;
			rrr[TTT]=true;
			which[TTT]=t.id;
			key[TTT]=e[t.id].w;
			tid[TTT]=TTT;
			link(t.a,TTT),link(TTT,t.b);
		}
		else
		{
			tmp=findid(t.a,t.b);
			if (e[which[tmp]].w&gt;e[t.id].w)
			{
				cut(e[which[tmp]].a,tmp),cut(tmp,e[which[tmp]].b);
				rrr[tmp]=true;
				which[tmp]=t.id;
				key[tmp]=e[t.id].w;
				tid[tmp]=tmp;
				link(t.a,tmp),link(tmp,t.b);
			}
		}
	}
	for (i=1;i&lt;=Q;i++)
		if (task[i].kind==1) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem2594</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 100111
#define MM 1001111
#define QQ 100111
int fa[NN*2],tid[NN*2],key[NN*2],son[NN*2][2],tag[NN*2],which[NN*2],ans[QQ],ff[NN];
int n,m,Q,TTT;
bool rrr[NN*2],flag[MM];
struct edge {int id,a,b,w;} e[MM];
struct ppt {int kind,a,b,id;} task[QQ];
void update(int v)
{
	int x=son[v][0],y=son[v][1];
	tid[v]=v;
	if (key[tid[x]]&gt;key[tid[v]]) tid[v]=tid[x];
	if (key[tid[y]]&gt;key[tid[v]]) tid[v]=tid[y];
}
void rev(int v)
{
	tag[v]=!tag[v];
	swap(son[v][0],son[v][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	rev(son[v][0]);
	rev(son[v][1]);
	tag[v]=false;
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
}
int access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
	return y;
}
void makeroot(int v)
{
	access(v);
	splay(v);
	rev(v);
}
void link(int x,int y)
{
	makeroot(x);
	splay(x);
	access(y);
	fa[x]=y;
	rrr[x]=false;
	son[y][1]=x;
}
void cut(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	//fa[x]=fa[y];
	//son[y][0]=fa[y]=0;
	son[y][0]=0;
	fa[x]=0;
	rrr[x]=true;
}
int getroot(int x)
{
	access(x);
	splay(x);
	for (;son[x][0];x=son[x][0]);
	return x;
}
int findid(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	return tid[y];
}
int cha(int x,int y)
{
	int l=1,r=m;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (e[mid].a==x&amp;&amp;e[mid].b==y) return mid;
		if (e[mid].a&gt;x||(e[mid].a==x&amp;&amp;e[mid].b&gt;y)) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
int getfa(int x) {return ff[x]==x?x:ff[x]=getfa(ff[x]);}
bool cmp(edge a,edge b) {return a.a==b.a?a.b&lt;b.b:a.a&lt;b.a;}
bool cmp2(edge a,edge b) {return a.w&lt;b.w;}
bool cmp3(edge a,edge b) {return a.id&lt;b.id;}
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;Q);
	int i,x,y,kind,tmp;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
		if (e[i].a&gt;e[i].b) swap(e[i].a,e[i].b);
	}
	sort(e+1,e+m+1,cmp);
	for (i=1;i&lt;=m;i++) e[i].id=i;
	for (i=1;i&lt;=Q;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;x,&amp;y);
		if (x&gt;y) swap(x,y);
		task[i].kind=kind,task[i].a=x,task[i].b=y;
		if (kind==2)
		{
			task[i].id=cha(x,y);
			flag[task[i].id]=true;
		}
	}
	sort(e+1,e+m+1,cmp2);
	for (i=1;i&lt;=n;i++) rrr[i]=true,ff[i]=i;
	for (TTT=n,tmp=0,i=1;i&lt;=m&amp;&amp;tmp&lt;n-1;i++)
	{
		if (flag[e[i].id]) continue;
		int x=e[i].a,y=e[i].b,id=e[i].id;
		int xx=getfa(x),yy=getfa(y);
		if (xx==yy) continue;
		ff[xx]=yy;
		TTT++;
		rrr[TTT]=true;
		which[TTT]=id;
		key[TTT]=e[i].w;
		tid[TTT]=TTT;
		link(x,TTT),link(TTT,y);
		tmp++;
	}
	sort(e+1,e+m+1,cmp3);
	for (i=Q;i;i--)
	{
		ppt t=task[i];
		if (t.kind==1) ans[i]=key[findid(t.a,t.b)];
		else if (getroot(t.a)!=getroot(t.b))
		{
			TTT++;
			rrr[TTT]=true;
			which[TTT]=t.id;
			key[TTT]=e[t.id].w;
			tid[TTT]=TTT;
			link(t.a,TTT),link(TTT,t.b);
		}
		else
		{
			tmp=findid(t.a,t.b);
			if (e[which[tmp]].w&gt;e[t.id].w)
			{
				cut(e[which[tmp]].a,tmp),cut(tmp,e[which[tmp]].b);
				rrr[tmp]=true;
				which[tmp]=t.id;
				key[tmp]=e[t.id].w;
				tid[tmp]=tmp;
				link(t.a,tmp),link(tmp,t.b);
			}
		}
	}
	for (i=1;i&lt;=Q;i++)
		if (task[i].kind==1) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem2594</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 100111
#define MM 1001111
#define QQ 100111
int fa[NN*2],tid[NN*2],key[NN*2],son[NN*2][2],tag[NN*2],which[NN*2],ans[QQ],ff[NN];
int n,m,Q,TTT;
bool rrr[NN*2],flag[MM];
struct edge {int id,a,b,w;} e[MM];
struct ppt {int kind,a,b,id;} task[QQ];
void update(int v)
{
	int x=son[v][0],y=son[v][1];
	tid[v]=v;
	if (key[tid[x]]&gt;key[tid[v]]) tid[v]=tid[x];
	if (key[tid[y]]&gt;key[tid[v]]) tid[v]=tid[y];
}
void rev(int v)
{
	tag[v]=!tag[v];
	swap(son[v][0],son[v][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	rev(son[v][0]);
	rev(son[v][1]);
	tag[v]=false;
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
}
int access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
	return y;
}
void makeroot(int v)
{
	access(v);
	splay(v);
	rev(v);
}
void link(int x,int y)
{
	makeroot(x);
	splay(x);
	access(y);
	fa[x]=y;
	rrr[x]=false;
	son[y][1]=x;
}
void cut(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	fa[x]=son[y][0]=0;
	rrr[x]=true;
}
int getroot(int x)
{
	access(x);
	splay(x);
	for (;son[x][0];x=son[x][0]);
	return x;
}
int findid(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	return tid[y];
}
int cha(int x,int y)
{
	int l=1,r=m;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (e[mid].a==x&amp;&amp;e[mid].b==y) return mid;
		if (e[mid].a&gt;x||(e[mid].a==x&amp;&amp;e[mid].b&gt;y)) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
int getfa(int x) {return ff[x]==x?x:ff[x]=getfa(ff[x]);}
bool cmp(edge a,edge b) {return a.a==b.a?a.b&lt;b.b:a.a&lt;b.a;}
bool cmp2(edge a,edge b) {return a.w&lt;b.w;}
bool cmp3(edge a,edge b) {return a.id&lt;b.id;}
int main()
{
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;Q);
	int i,x,y,kind,tmp;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
		if (e[i].a&gt;e[i].b) swap(e[i].a,e[i].b);
	}
	sort(e+1,e+m+1,cmp);
	for (i=1;i&lt;=m;i++) e[i].id=i;
	for (i=1;i&lt;=Q;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;x,&amp;y);
		if (x&gt;y) swap(x,y);
		task[i].kind=kind,task[i].a=x,task[i].b=y;
		if (kind==2)
		{
			task[i].id=cha(x,y);
			flag[task[i].id]=true;
		}
	}
	sort(e+1,e+m+1,cmp2);
	for (i=1;i&lt;=n;i++) rrr[i]=true,ff[i]=i;
	for (TTT=n,tmp=0,i=1;i&lt;=m&amp;&amp;tmp&lt;n-1;i++)
	{
		if (flag[e[i].id]) continue;
		int x=e[i].a,y=e[i].b,id=e[i].id;
		int xx=getfa(x),yy=getfa(y);
		if (xx==yy) continue;
		ff[xx]=yy;
		TTT++;
		rrr[TTT]=true;
		which[TTT]=id;
		key[TTT]=e[i].w;
		tid[TTT]=TTT;
		link(x,TTT),link(TTT,y);
		tmp++;
	}
	sort(e+1,e+m+1,cmp3);
	for (i=Q;i;i--)
	{
		ppt t=task[i];
		if (t.kind==1) ans[i]=key[findid(t.a,t.b)];
		else if (getroot(t.a)!=getroot(t.b))
		{
			TTT++;
			rrr[TTT]=true;
			which[TTT]=t.id;
			key[TTT]=e[t.id].w;
			tid[TTT]=TTT;
			link(t.a,TTT),link(TTT,t.b);
		}
		else
		{
			tmp=findid(t.a,t.b);
			if (e[which[tmp]].w&gt;e[t.id].w)
			{
				cut(e[which[tmp]].a,tmp),cut(tmp,e[which[tmp]].b);
				rrr[tmp]=true;
				which[tmp]=t.id;
				key[tmp]=e[t.id].w;
				tid[tmp]=tmp;
				link(t.a,tmp),link(tmp,t.b);
			}
		}
	}
	for (i=1;i&lt;=Q;i++)
		if (task[i].kind==1) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem2594</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 100111
#define MM 1001111
#define QQ 100111
int fa[NN*2],tid[NN*2],key[NN*2],son[NN*2][2],tag[NN*2],which[NN*2],ans[QQ],ff[NN];
int n,m,Q,TTT;
bool rrr[NN*2],flag[MM];
struct edge {int id,a,b,w;} e[MM];
struct ppt {int kind,a,b,id;} task[QQ];
void update(int v)
{
	int x=son[v][0],y=son[v][1];
	tid[v]=v;
	if (key[tid[x]]&gt;key[tid[v]]) tid[v]=tid[x];
	if (key[tid[y]]&gt;key[tid[v]]) tid[v]=tid[y];
}
void rev(int v)
{
	tag[v]=!tag[v];
	swap(son[v][0],son[v][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	rev(son[v][0]);
	rev(son[v][1]);
	tag[v]=false;
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
}
int access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
	return y;
}
void makeroot(int v)
{
	access(v);
	splay(v);
	rev(v);
}
void link(int x,int y)
{
	makeroot(x);
	splay(x);
	access(y);
	fa[x]=y;
	rrr[x]=false;
	son[y][1]=x;
}
void cut(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	fa[x]=son[y][0]=0;
	rrr[x]=true;
}
int getroot(int x)
{
	access(x);
	splay(x);
	for (;son[x][0];x=son[x][0]) pushdown(x);
	return x;
}
int findid(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	return tid[y];
}
int cha(int x,int y)
{
	int l=1,r=m;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (e[mid].a==x&amp;&amp;e[mid].b==y) return mid;
		if (e[mid].a&gt;x||(e[mid].a==x&amp;&amp;e[mid].b&gt;y)) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
int getfa(int x) {return ff[x]==x?x:ff[x]=getfa(ff[x]);}
bool cmp(edge a,edge b) {return a.a==b.a?a.b&lt;b.b:a.a&lt;b.a;}
bool cmp2(edge a,edge b) {return a.w&lt;b.w;}
bool cmp3(edge a,edge b) {return a.id&lt;b.id;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;Q);
	int i,x,y,kind,tmp;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
		if (e[i].a&gt;e[i].b) swap(e[i].a,e[i].b);
	}
	sort(e+1,e+m+1,cmp);
	for (i=1;i&lt;=m;i++) e[i].id=i;
	for (i=1;i&lt;=Q;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;x,&amp;y);
		if (x&gt;y) swap(x,y);
		task[i].kind=kind,task[i].a=x,task[i].b=y;
		if (kind==2)
		{
			task[i].id=cha(x,y);
			flag[task[i].id]=true;
		}
	}
	sort(e+1,e+m+1,cmp2);
	for (i=1;i&lt;=n;i++) rrr[i]=true,ff[i]=i;
	for (TTT=n,tmp=0,i=1;i&lt;=m&amp;&amp;tmp&lt;n-1;i++)
	{
		if (flag[e[i].id]) continue;
		int x=e[i].a,y=e[i].b,id=e[i].id;
		int xx=getfa(x),yy=getfa(y);
		if (xx==yy) continue;
		ff[xx]=yy;
		TTT++;
		rrr[TTT]=true;
		which[TTT]=id;
		key[TTT]=e[i].w;
		tid[TTT]=TTT;
		link(x,TTT),link(TTT,y);
		tmp++;
	}
	sort(e+1,e+m+1,cmp3);
	for (i=Q;i;i--)
	{
		ppt t=task[i];
		if (t.kind==1) ans[i]=key[findid(t.a,t.b)];
		else if (getroot(t.a)!=getroot(t.b))
		{
			TTT++;
			rrr[TTT]=true;
			which[TTT]=t.id;
			key[TTT]=e[t.id].w;
			tid[TTT]=TTT;
			link(t.a,TTT),link(TTT,t.b);
		}
		else
		{
			tmp=findid(t.a,t.b);
			if (e[which[tmp]].w&gt;e[t.id].w)
			{
				cut(e[which[tmp]].a,tmp),cut(tmp,e[which[tmp]].b);
				rrr[tmp]=true;
				which[tmp]=t.id;
				key[tmp]=e[t.id].w;
				tid[tmp]=tmp;
				link(t.a,tmp),link(tmp,t.b);
			}
		}
	}
	for (i=1;i&lt;=Q;i++)
		if (task[i].kind==1) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem2594</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 100111
#define MM 1001111
#define QQ 100111
int fa[NN*2],tid[NN*2],key[NN*2],son[NN*2][2],tag[NN*2],which[NN*2],ans[QQ],ff[NN];
int n,m,Q,TTT;
bool rrr[NN*2],flag[MM];
struct edge {int id,a,b,w;} e[MM];
struct ppt {int kind,a,b,id;} task[QQ];
void update(int v)
{
	int x=son[v][0],y=son[v][1];
	tid[v]=v;
	if (key[tid[x]]&gt;key[tid[v]]) tid[v]=tid[x];
	if (key[tid[y]]&gt;key[tid[v]]) tid[v]=tid[y];
}
void rev(int v)
{
	tag[v]=!tag[v];
	swap(son[v][0],son[v][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	rev(son[v][0]);
	rev(son[v][1]);
	tag[v]=false;
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
	else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
}
int access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
	return y;
}
void makeroot(int v)
{
	access(v);
	splay(v);
	rev(v);
}
void link(int x,int y)
{
	makeroot(x);
	splay(x);
	access(y);
	fa[x]=y;
	//rrr[x]=false;
	//son[y][1]=x;
}
void cut(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	fa[x]=son[y][0]=0;
	rrr[x]=true;
}
int getroot(int x)
{
	access(x);
	splay(x);
	for (;son[x][0];x=son[x][0]) pushdown(x);
	return x;
}
int findid(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	return tid[y];
}
int cha(int x,int y)
{
	int l=1,r=m;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (e[mid].a==x&amp;&amp;e[mid].b==y) return mid;
		if (e[mid].a&gt;x||(e[mid].a==x&amp;&amp;e[mid].b&gt;y)) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
int getfa(int x) {return ff[x]==x?x:ff[x]=getfa(ff[x]);}
bool cmp(edge a,edge b) {return a.a==b.a?a.b&lt;b.b:a.a&lt;b.a;}
bool cmp2(edge a,edge b) {return a.w&lt;b.w;}
bool cmp3(edge a,edge b) {return a.id&lt;b.id;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;Q);
	int i,x,y,kind,tmp;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
		if (e[i].a&gt;e[i].b) swap(e[i].a,e[i].b);
	}
	sort(e+1,e+m+1,cmp);
	for (i=1;i&lt;=m;i++) e[i].id=i;
	for (i=1;i&lt;=Q;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;x,&amp;y);
		if (x&gt;y) swap(x,y);
		task[i].kind=kind,task[i].a=x,task[i].b=y;
		if (kind==2)
		{
			task[i].id=cha(x,y);
			flag[task[i].id]=true;
		}
	}
	sort(e+1,e+m+1,cmp2);
	for (i=1;i&lt;=n;i++) rrr[i]=true,ff[i]=i;
	for (TTT=n,tmp=0,i=1;i&lt;=m&amp;&amp;tmp&lt;n-1;i++)
	{
		if (flag[e[i].id]) continue;
		int x=e[i].a,y=e[i].b,id=e[i].id;
		int xx=getfa(x),yy=getfa(y);
		if (xx==yy) continue;
		ff[xx]=yy;
		TTT++;
		rrr[TTT]=true;
		which[TTT]=id;
		key[TTT]=e[i].w;
		tid[TTT]=TTT;
		link(x,TTT),link(TTT,y);
		tmp++;
	}
	sort(e+1,e+m+1,cmp3);
	for (i=Q;i;i--)
	{
		ppt t=task[i];
		if (t.kind==1) ans[i]=key[findid(t.a,t.b)];
		else if (getroot(t.a)!=getroot(t.b))
		{
			TTT++;
			rrr[TTT]=true;
			which[TTT]=t.id;
			key[TTT]=e[t.id].w;
			tid[TTT]=TTT;
			link(t.a,TTT),link(TTT,t.b);
		}
		else
		{
			tmp=findid(t.a,t.b);
			if (e[which[tmp]].w&gt;e[t.id].w)
			{
				cut(e[which[tmp]].a,tmp),cut(tmp,e[which[tmp]].b);
				rrr[tmp]=true;
				which[tmp]=t.id;
				key[tmp]=e[t.id].w;
				tid[tmp]=tmp;
				link(t.a,tmp),link(tmp,t.b);
			}
		}
	}
	for (i=1;i&lt;=Q;i++)
		if (task[i].kind==1) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem2594</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 100111
#define MM 1001111
#define QQ 100111
int fa[NN*2],tid[NN*2],key[NN*2],son[NN*2][2],tag[NN*2],which[NN*2],ans[QQ],ff[NN];
int n,m,Q,TTT;
bool rrr[NN*2],flag[MM];
struct edge {int id,a,b,w;} e[MM];
struct ppt {int kind,a,b,id;} task[QQ];
void update(int v)
{
	int x=son[v][0],y=son[v][1];
	tid[v]=v;
	if (key[tid[x]]&gt;key[tid[v]]) tid[v]=tid[x];
	if (key[tid[y]]&gt;key[tid[v]]) tid[v]=tid[y];
}
void rev(int v)
{
	tag[v]=!tag[v];
	swap(son[v][0],son[v][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	rev(son[v][0]);
	rev(son[v][1]);
	tag[v]=false;
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
	else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
}
int access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
	return y;
}
void makeroot(int v)
{
	access(v);
	splay(v);
	rev(v);
}
void link(int x,int y)
{
	makeroot(x);
	splay(x);
	//access(y);
	fa[x]=y;
	//rrr[x]=false;
	//son[y][1]=x;
}
void cut(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	fa[x]=son[y][0]=0;
	rrr[x]=true;
}
int getroot(int x)
{
	access(x);
	splay(x);
	for (;son[x][0];x=son[x][0]) pushdown(x);
	return x;
}
int findid(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	return tid[y];
}
int cha(int x,int y)
{
	int l=1,r=m;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (e[mid].a==x&amp;&amp;e[mid].b==y) return mid;
		if (e[mid].a&gt;x||(e[mid].a==x&amp;&amp;e[mid].b&gt;y)) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
int getfa(int x) {return ff[x]==x?x:ff[x]=getfa(ff[x]);}
bool cmp(edge a,edge b) {return a.a==b.a?a.b&lt;b.b:a.a&lt;b.a;}
bool cmp2(edge a,edge b) {return a.w&lt;b.w;}
bool cmp3(edge a,edge b) {return a.id&lt;b.id;}
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;Q);
	int i,x,y,kind,tmp;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
		if (e[i].a&gt;e[i].b) swap(e[i].a,e[i].b);
	}
	sort(e+1,e+m+1,cmp);
	for (i=1;i&lt;=m;i++) e[i].id=i;
	for (i=1;i&lt;=Q;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;x,&amp;y);
		if (x&gt;y) swap(x,y);
		task[i].kind=kind,task[i].a=x,task[i].b=y;
		if (kind==2)
		{
			task[i].id=cha(x,y);
			flag[task[i].id]=true;
		}
	}
	sort(e+1,e+m+1,cmp2);
	for (i=1;i&lt;=n;i++) rrr[i]=true,ff[i]=i;
	for (TTT=n,tmp=0,i=1;i&lt;=m&amp;&amp;tmp&lt;n-1;i++)
	{
		if (flag[e[i].id]) continue;
		int x=e[i].a,y=e[i].b,id=e[i].id;
		int xx=getfa(x),yy=getfa(y);
		if (xx==yy) continue;
		ff[xx]=yy;
		TTT++;
		rrr[TTT]=true;
		which[TTT]=id;
		key[TTT]=e[i].w;
		tid[TTT]=TTT;
		link(x,TTT),link(TTT,y);
		tmp++;
	}
	sort(e+1,e+m+1,cmp3);
	for (i=Q;i;i--)
	{
		ppt t=task[i];
		if (t.kind==1) ans[i]=key[findid(t.a,t.b)];
		else if (getroot(t.a)!=getroot(t.b))
		{
			TTT++;
			rrr[TTT]=true;
			which[TTT]=t.id;
			key[TTT]=e[t.id].w;
			tid[TTT]=TTT;
			link(t.a,TTT),link(TTT,t.b);
		}
		else
		{
			tmp=findid(t.a,t.b);
			if (e[which[tmp]].w&gt;e[t.id].w)
			{
				cut(e[which[tmp]].a,tmp),cut(tmp,e[which[tmp]].b);
				rrr[tmp]=true;
				which[tmp]=t.id;
				key[tmp]=e[t.id].w;
				tid[tmp]=tmp;
				link(t.a,tmp),link(tmp,t.b);
			}
		}
	}
	for (i=1;i&lt;=Q;i++)
		if (task[i].kind==1) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem2594</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 100111
#define MM 1001111
#define QQ 100111
int fa[NN*2],tid[NN*2],key[NN*2],son[NN*2][2],tag[NN*2],which[NN*2],ans[QQ],ff[NN];
int n,m,Q,TTT;
bool rrr[NN*2],flag[MM];
struct edge {int id,a,b,w;} e[MM];
struct ppt {int kind,a,b,id;} task[QQ];
void update(int v)
{
	int x=son[v][0],y=son[v][1];
	tid[v]=v;
	if (key[tid[x]]&gt;key[tid[v]]) tid[v]=tid[x];
	if (key[tid[y]]&gt;key[tid[v]]) tid[v]=tid[y];
}
void rev(int v)
{
	tag[v]=!tag[v];
	swap(son[v][0],son[v][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	rev(son[v][0]);
	rev(son[v][1]);
	tag[v]=false;
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
	else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
}
int access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
	return y;
}
void makeroot(int v)
{
	access(v);
	splay(v);
	rev(v);
}
void link(int x,int y)
{
	makeroot(x);
	splay(x);
	fa[x]=y;
}
void cut(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	fa[x]=son[y][0]=0;
	rrr[x]=true;
}
int getroot(int x)
{
	access(x);
	splay(x);
	for (;son[x][0];x=son[x][0]) pushdown(x);
	return x;
}
int findid(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	return tid[y];
}
int cha(int x,int y)
{
	int l=1,r=m;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (e[mid].a==x&amp;&amp;e[mid].b==y) return mid;
		if (e[mid].a&gt;x||(e[mid].a==x&amp;&amp;e[mid].b&gt;y)) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
int getfa(int x) {return ff[x]==x?x:ff[x]=getfa(ff[x]);}
bool cmp(edge a,edge b) {return a.a==b.a?a.b&lt;b.b:a.a&lt;b.a;}
bool cmp2(edge a,edge b) {return a.w&lt;b.w;}
bool cmp3(edge a,edge b) {return a.id&lt;b.id;}
int main()
{
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;Q);
	int i,x,y,kind,tmp;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
		if (e[i].a&gt;e[i].b) swap(e[i].a,e[i].b);
	}
	sort(e+1,e+m+1,cmp);
	for (i=1;i&lt;=m;i++) e[i].id=i;
	for (i=1;i&lt;=Q;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;x,&amp;y);
		if (x&gt;y) swap(x,y);
		task[i].kind=kind,task[i].a=x,task[i].b=y;
		if (kind==2)
		{
			task[i].id=cha(x,y);
			flag[task[i].id]=true;
		}
	}
	sort(e+1,e+m+1,cmp2);
	for (i=1;i&lt;=n;i++) rrr[i]=true,ff[i]=i;
	for (TTT=n,tmp=0,i=1;i&lt;=m&amp;&amp;tmp&lt;n-1;i++)
	{
		if (flag[e[i].id]) continue;
		int x=e[i].a,y=e[i].b,id=e[i].id;
		int xx=getfa(x),yy=getfa(y);
		if (xx==yy) continue;
		ff[xx]=yy;
		TTT++;
		rrr[TTT]=true;
		which[TTT]=id;
		key[TTT]=e[i].w;
		tid[TTT]=TTT;
		link(x,TTT),link(TTT,y);
		tmp++;
	}
	sort(e+1,e+m+1,cmp3);
	for (i=Q;i;i--)
	{
		ppt t=task[i];
		if (t.kind==1) ans[i]=key[findid(t.a,t.b)];
		else if (getroot(t.a)!=getroot(t.b))
		{
			TTT++;
			rrr[TTT]=true;
			which[TTT]=t.id;
			key[TTT]=e[t.id].w;
			tid[TTT]=TTT;
			link(t.a,TTT),link(TTT,t.b);
		}
		else
		{
			tmp=findid(t.a,t.b);
			if (e[which[tmp]].w&gt;e[t.id].w)
			{
				cut(e[which[tmp]].a,tmp),cut(tmp,e[which[tmp]].b);
				rrr[tmp]=true;
				which[tmp]=t.id;
				key[tmp]=e[t.id].w;
				tid[tmp]=tmp;
				link(t.a,tmp),link(tmp,t.b);
			}
		}
	}
	for (i=1;i&lt;=Q;i++)
		if (task[i].kind==1) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem2594</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 100111
#define MM 1001111
#define QQ 100111
int fa[NN*2],tid[NN*2],key[NN*2],son[NN*2][2],tag[NN*2],which[NN*2],ans[QQ],ff[NN];
int n,m,Q,TTT;
bool rrr[NN*2],flag[MM];
struct edge {int id,a,b,w;} e[MM];
struct ppt {int kind,a,b,id;} task[QQ];
void update(int v)
{
	int x=son[v][0],y=son[v][1];
	tid[v]=v;
	if (key[tid[x]]&gt;key[tid[v]]) tid[v]=tid[x];
	if (key[tid[y]]&gt;key[tid[v]]) tid[v]=tid[y];
}
void rev(int v)
{
	tag[v]=!tag[v];
	swap(son[v][0],son[v][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	rev(son[v][0]);
	rev(son[v][1]);
	tag[v]=false;
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
	else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
}
int access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
	return y;
}
void makeroot(int v)
{
	access(v);
	splay(v);
	rev(v);
}
void link(int x,int y)
{
	makeroot(x);
	splay(x);
	fa[x]=y;
}
void cut(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	fa[x]=son[y][0]=0;
	rrr[x]=true;
}
int getroot(int x)
{
	access(x);
	splay(x);
	for (;son[x][0];x=son[x][0]) pushdown(x);
	return x;
}
int findid(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	return tid[y];
}
int cha(int x,int y)
{
	int l=1,r=m;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (e[mid].a==x&amp;&amp;e[mid].b==y) return mid;
		if (e[mid].a&gt;x||(e[mid].a==x&amp;&amp;e[mid].b&gt;y)) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
int getfa(int x) {return ff[x]==x?x:ff[x]=getfa(ff[x]);}
bool cmp(edge a,edge b) {return a.a==b.a?a.b&lt;b.b:a.a&lt;b.a;}
bool cmp2(edge a,edge b) {return a.w&lt;b.w;}
bool cmp3(edge a,edge b) {return a.id&lt;b.id;}
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;Q);
	int i,x,y,kind,tmp;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
		if (e[i].a&gt;e[i].b) swap(e[i].a,e[i].b);
	}
	sort(e+1,e+m+1,cmp);
	for (i=1;i&lt;=m;i++) e[i].id=i;
	for (i=1;i&lt;=Q;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;x,&amp;y);
		if (x&gt;y) swap(x,y);
		task[i].kind=kind,task[i].a=x,task[i].b=y;
		if (kind==2)
		{
			task[i].id=cha(x,y);
			flag[task[i].id]=true;
		}
	}
	sort(e+1,e+m+1,cmp2);
	for (i=1;i&lt;=n;i++) rrr[i]=true,ff[i]=i;
	for (TTT=n,tmp=0,i=1;i&lt;=m&amp;&amp;tmp&lt;n-1;i++)
	{
		if (flag[e[i].id]) continue;
		int x=e[i].a,y=e[i].b,id=e[i].id;
		int xx=getfa(x),yy=getfa(y);
		if (xx==yy) continue;
		ff[xx]=yy;
		TTT++;
		fa[TTT]=0;
		rrr[TTT]=true;
		which[TTT]=id;
		key[TTT]=e[i].w;
		tid[TTT]=TTT;
		link(x,TTT),link(TTT,y);
		tmp++;
	}
	sort(e+1,e+m+1,cmp3);
	for (i=Q;i;i--)
	{
		ppt t=task[i];
		if (t.kind==1) ans[i]=key[findid(t.a,t.b)];
		else if (getroot(t.a)!=getroot(t.b))
		{
			TTT++;
			fa[TTT]=0;
			rrr[TTT]=true;
			which[TTT]=t.id;
			key[TTT]=e[t.id].w;
			tid[TTT]=TTT;
			link(t.a,TTT),link(TTT,t.b);
		}
		else
		{
			tmp=findid(t.a,t.b);
			if (e[which[tmp]].w&gt;e[t.id].w)
			{
				cut(e[which[tmp]].a,tmp),cut(tmp,e[which[tmp]].b);
				rrr[tmp]=true;
				which[tmp]=t.id;
				key[tmp]=e[t.id].w;
				tid[tmp]=tmp;
				link(t.a,tmp),link(tmp,t.b);
			}
		}
	}
	for (i=1;i&lt;=Q;i++)
		if (task[i].kind==1) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem2595</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 15
const int dx[4]={-1,0,0,1},dy[4]={0,1,-1,0};
int f[1030][NN][NN],q1[30000],q2[30000],w[NN][NN];
int n,m,head,tail,mm,S,num,inf;
bool dl[NN][NN],vt[NN][NN],flag;
struct ppt
{
	int S,x,y;
	ppt(int a=0,int b=0,int c=0) {S=a,x=b,y=c;}
} pre[1030][NN][NN];
void spfa(int S)
{
	while (head&lt;tail)
	{
		head++;
		int x0=q1[head],y0=q2[head];
		dl[x0][y0]=false;
		for (int k=0;k&lt;=3;k++)
		{
			int x=x0+dx[k],y=y0+dy[k];
			if (x&lt;1||x&gt;n||y&lt;1||y&gt;m) continue;
			int tmp=f[S][x0][y0]+w[x][y];
			if (tmp&lt;f[S][x][y])
			{
				f[S][x][y]=tmp;
				pre[S][x][y]=ppt(S,x0,y0);
				tail++;
				q1[tail]=x,q2[tail]=y;
				dl[x][y]=true;
			}
		}
	}
}
void dfs(int S,int i,int j)
{
	vt[i][j]=true;
	ppt tmp=pre[S][i][j];
	if (tmp.S==0) return;
	if (tmp.S==S) dfs(S,tmp.x,tmp.y);
	else
	{
		dfs(tmp.S,i,j);
		dfs(S^tmp.S,i,j);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,j,k;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	memset(f,35,sizeof(f));
	inf=f[0][0][0];
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			scanf(&quot;%d&quot;,&amp;w[i][j]);
			if (w[i][j]==0) num++,f[1&lt;&lt;(num-1)][i][j]=0;
		}
	for (mm=(1&lt;&lt;num)-1,S=1;S&lt;=mm;S++)
	{
		head=tail=0;
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=m;j++)
			{
				for (k=(S-1)&amp;S;k&gt;0;k=(k-1)&amp;S)
				{
					int tmp=f[k][i][j]+f[S^k][i][j]-w[i][j];
					if (tmp&lt;f[S][i][j])
					{
						f[S][i][j]=tmp;
						pre[S][i][j]=ppt(k,i,j);
					}
				}
				if (f[S][i][j]&lt;inf)
				{
					tail++;
					q1[tail]=i,q2[tail]=j;
					dl[i][j]=true;
				}
			}
		spfa(S);
	}
	for (flag=true,i=1;i&lt;=n&amp;&amp;flag;i++)
		for (j=1;j&lt;=m;j++)
			if (w[i][j]==0)
			{
				printf(&quot;%d\n&quot;,f[mm][i][j]);
				dfs(mm,i,j);
				flag=false;
				break;
			}
	for (i=1;i&lt;=n;i++)
	{
		for (j=1;j&lt;=m;j++)
			if (w[i][j]==0) printf(&quot;x&quot;);
			else if (vt[i][j]) printf(&quot;o&quot;);
			else printf(&quot;_&quot;);
		printf(&quot;\n&quot;);
	}
	//freopen(&quot;CON&quot;,&quot;r&quot;,stdin);getchar();
	return 0;
}<pre><h2>Problem2595</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 15
const int dx[4]={-1,0,0,1},dy[4]={0,1,-1,0};
int f[1030][NN][NN],q1[30000],q2[30000],w[NN][NN];
int n,m,head,tail,mm,S,num,inf;
bool dl[NN][NN],vt[NN][NN],flag;
struct ppt
{
	int S,x,y;
	ppt(int a=0,int b=0,int c=0) {S=a,x=b,y=c;}
} pre[1030][NN][NN];
void spfa(int S)
{
	while (head&lt;tail)
	{
		head++;
		int x0=q1[head],y0=q2[head];
		dl[x0][y0]=false;
		for (int k=0;k&lt;=3;k++)
		{
			int x=x0+dx[k],y=y0+dy[k];
			if (x&lt;1||x&gt;n||y&lt;1||y&gt;m) continue;
			int tmp=f[S][x0][y0]+w[x][y];
			if (tmp&lt;f[S][x][y])
			{
				f[S][x][y]=tmp;
				pre[S][x][y]=ppt(S,x0,y0);
				tail++;
				q1[tail]=x,q2[tail]=y;
				dl[x][y]=true;
			}
		}
	}
}
void dfs(int S,int i,int j)
{
	vt[i][j]=true;
	ppt tmp=pre[S][i][j];
	if (tmp.S==0) return;
	if (tmp.S==S) dfs(S,tmp.x,tmp.y);
	else
	{
		dfs(tmp.S,i,j);
		dfs(S^tmp.S,i,j);
	}
}
int main()
{
	int i,j,k;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	memset(f,35,sizeof(f));
	inf=f[0][0][0];
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			scanf(&quot;%d&quot;,&amp;w[i][j]);
			if (w[i][j]==0) num++,f[1&lt;&lt;(num-1)][i][j]=0;
		}
	for (mm=(1&lt;&lt;num)-1,S=1;S&lt;=mm;S++)
	{
		int *asd;
		head=tail=0;
		for (i=1;i&lt;=n;i++)
			for (asd=&amp;f[S][i][1],j=1;j&lt;=m;j++,asd++)
			{
				for (k=(S-1)&amp;S;k&gt;0;k=(k-1)&amp;S)
				{
					int tmp=f[k][i][j]+f[S^k][i][j]-w[i][j];
					if (tmp&lt;*asd)
					{
						*asd=tmp;
						pre[S][i][j]=ppt(k,i,j);
					}
				}
				if (*asd&lt;inf)
				{
					tail++;
					q1[tail]=i,q2[tail]=j;
					dl[i][j]=true;
				}
			}
		spfa(S);
	}
	for (flag=true,i=1;i&lt;=n&amp;&amp;flag;i++)
		for (j=1;j&lt;=m;j++)
			if (w[i][j]==0)
			{
				printf(&quot;%d\n&quot;,f[mm][i][j]);
				dfs(mm,i,j);
				flag=false;
				break;
			}
	for (i=1;i&lt;=n;i++)
	{
		for (j=1;j&lt;=m;j++)
			if (w[i][j]==0) printf(&quot;x&quot;);
			else if (vt[i][j]) printf(&quot;o&quot;);
			else printf(&quot;_&quot;);
		printf(&quot;\n&quot;);
	}
	return 0;
}<pre><h2>Problem2595</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 15
const int dx[4]={-1,0,0,1},dy[4]={0,1,-1,0};
int f[1030][NN][NN],q1[30000],q2[30000],w[NN][NN];
int n,m,head,tail,mm,S,num,inf;
bool dl[NN][NN],vt[NN][NN],flag;
struct ppt
{
	int S,x,y;
	ppt(int a=0,int b=0,int c=0) {S=a,x=b,y=c;}
} pre[1030][NN][NN];
void spfa(int S)
{
	while (head&lt;tail)
	{
		head++;
		int x0=q1[head],y0=q2[head];
		int tt=f[S][x0][y0];
		dl[x0][y0]=false;
		for (int k=0;k&lt;=3;k++)
		{
			int x=x0+dx[k],y=y0+dy[k];
			if (x&lt;1||x&gt;n||y&lt;1||y&gt;m) continue;
			int tmp=tt+w[x][y];
			if (tmp&lt;f[S][x][y])
			{
				f[S][x][y]=tmp;
				pre[S][x][y]=ppt(S,x0,y0);
				tail++;
				q1[tail]=x,q2[tail]=y;
				dl[x][y]=true;
			}
		}
	}
}
void dfs(int S,int i,int j)
{
	vt[i][j]=true;
	ppt tmp=pre[S][i][j];
	if (tmp.S==0) return;
	if (tmp.S==S) dfs(S,tmp.x,tmp.y);
	else
	{
		dfs(tmp.S,i,j);
		dfs(S^tmp.S,i,j);
	}
}
int main()
{
	int i,j,k;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	memset(f,35,sizeof(f));
	inf=f[0][0][0];
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			scanf(&quot;%d&quot;,&amp;w[i][j]);
			if (w[i][j]==0) num++,f[1&lt;&lt;(num-1)][i][j]=0;
		}
	for (mm=(1&lt;&lt;num)-1,S=1;S&lt;=mm;S++)
	{
		int *asd;
		head=tail=0;
		for (i=1;i&lt;=n;i++)
			for (asd=&amp;f[S][i][1],j=1;j&lt;=m;j++,asd++)
			{
				for (k=(S-1)&amp;S;k&gt;0;k=(k-1)&amp;S)
				{
					int tmp=f[k][i][j]+f[S^k][i][j]-w[i][j];
					if (tmp&lt;*asd)
					{
						*asd=tmp;
						pre[S][i][j]=ppt(k,i,j);
					}
				}
				if (*asd&lt;inf)
				{
					tail++;
					q1[tail]=i,q2[tail]=j;
					dl[i][j]=true;
				}
			}
		spfa(S);
	}
	for (flag=true,i=1;i&lt;=n&amp;&amp;flag;i++)
		for (j=1;j&lt;=m;j++)
			if (w[i][j]==0)
			{
				printf(&quot;%d\n&quot;,f[mm][i][j]);
				dfs(mm,i,j);
				flag=false;
				break;
			}
	for (i=1;i&lt;=n;i++)
	{
		for (j=1;j&lt;=m;j++)
			if (w[i][j]==0) printf(&quot;x&quot;);
			else if (vt[i][j]) printf(&quot;o&quot;);
			else printf(&quot;_&quot;);
		printf(&quot;\n&quot;);
	}
	return 0;
}<pre><h2>Problem2595</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 15
const int dx[4]={-1,0,0,1},dy[4]={0,1,-1,0};
int f[1030][NN][NN],q1[30000],q2[30000],w[NN][NN];
int n,m,head,tail,mm,S,num,inf;
bool dl[NN][NN],vt[NN][NN],flag;
struct ppt
{
	int S,x,y;
	ppt(int a=0,int b=0,int c=0) {S=a,x=b,y=c;}
} pre[1030][NN][NN];
void spfa(int S)
{
	while (head&lt;tail)
	{
		head++;
		int x0=q1[head],y0=q2[head];
		int tt=f[S][x0][y0];
		dl[x0][y0]=false;
		for (int k=0;k&lt;=3;k++)
		{
			int x=x0+dx[k],y=y0+dy[k];
			if (x&lt;1||x&gt;n||y&lt;1||y&gt;m) continue;
			int tmp=tt+w[x][y];
			if (tmp&lt;f[S][x][y])
			{
				f[S][x][y]=tmp;
				pre[S][x][y]=ppt(S,x0,y0);
				tail++;
				q1[tail]=x,q2[tail]=y;
				dl[x][y]=true;
			}
		}
	}
}
void dfs(int S,int i,int j)
{
	vt[i][j]=true;
	ppt tmp=pre[S][i][j];
	if (tmp.S==0) return;
	if (tmp.S==S) dfs(S,tmp.x,tmp.y);
	else
	{
		dfs(tmp.S,i,j);
		dfs(S^tmp.S,i,j);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,j,k;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	memset(f,35,sizeof(f));
	inf=f[0][0][0];
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			scanf(&quot;%d&quot;,&amp;w[i][j]);
			if (w[i][j]==0) num++,f[1&lt;&lt;(num-1)][i][j]=0;
		}
	for (mm=(1&lt;&lt;num)-1,S=1;S&lt;=mm;S++)
	{
		int *asd;
		head=tail=0;
		for (i=1;i&lt;=n;i++)
			for (asd=&amp;f[S][i][1],j=1;j&lt;=m;j++,asd++)
			{
				for (k=(S-1)&amp;S;k&gt;0;k=(k-1)&amp;S)
				{
					int tmp=f[k][i][j]+f[S^k][i][j]-w[i][j];
					if (tmp&lt;*asd)
					{
						*asd=tmp;
						pre[S][i][j]=ppt(k,i,j);
					}
				}
				if (*asd&lt;inf)
				{
					tail++;
					q1[tail]=i,q2[tail]=j;
					dl[i][j]=true;
				}
			}
		spfa(S);
	}
	for (flag=true,i=1;i&lt;=n&amp;&amp;flag;i++)
		for (j=1;j&lt;=m;j++)
			if (w[i][j]==0)
			{
				printf(&quot;%d\n&quot;,f[mm][i][j]);
				dfs(mm,i,j);
				flag=false;
				break;
			}
	for (i=1;i&lt;=n;i++)
	{
		for (j=1;j&lt;=m;j++)
			if (w[i][j]==0) printf(&quot;x&quot;);
			else if (vt[i][j]) printf(&quot;o&quot;);
			else printf(&quot;_&quot;);
		printf(&quot;\n&quot;);
	}
	return 0;
}<pre><h2>Problem2595</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 15
const int dx[4]={-1,0,0,1},dy[4]={0,1,-1,0};
int f[1030][NN][NN],q1[30000],q2[30000],w[NN][NN];
int n,m,head,tail,mm,S,num,inf;
bool dl[NN][NN],vt[NN][NN],flag;
struct ppt
{
	int S,x,y;
	ppt(int a=0,int b=0,int c=0) {S=a,x=b,y=c;}
} pre[1030][NN][NN];
void spfa(int S)
{
	while (head&lt;tail)
	{
		head++;
		int x0=q1[head],y0=q2[head];
		int tt=f[S][x0][y0];
		dl[x0][y0]=false;
		for (int k=0;k&lt;=3;k++)
		{
			int x=x0+dx[k],y=y0+dy[k];
			if (x&lt;1||x&gt;n||y&lt;1||y&gt;m) continue;
			int tmp=tt+w[x][y];
			if (tmp&lt;f[S][x][y])
			{
				f[S][x][y]=tmp;
				pre[S][x][y]=ppt(S,x0,y0);
				tail++;
				q1[tail]=x,q2[tail]=y;
				dl[x][y]=true;
			}
		}
	}
}
void dfs(int S,int i,int j)
{
	vt[i][j]=true;
	ppt tmp=pre[S][i][j];
	if (tmp.S==0) return;
	if (tmp.S==S) dfs(S,tmp.x,tmp.y);
	else
	{
		dfs(tmp.S,i,j);
		dfs(S^tmp.S,i,j);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,j,k;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	memset(f,127,sizeof(f));
	inf=f[0][0][0];
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			scanf(&quot;%d&quot;,&amp;w[i][j]);
			if (w[i][j]==0) num++,f[1&lt;&lt;(num-1)][i][j]=0;
		}
	for (mm=(1&lt;&lt;num)-1,S=1;S&lt;=mm;S++)
	{
		int *asd;
		head=tail=0;
		for (i=1;i&lt;=n;i++)
			for (asd=&amp;f[S][i][1],j=1;j&lt;=m;j++,asd++)
			{
				for (k=(S-1)&amp;S;k&gt;0;k=(k-1)&amp;S)
				{
					int tmp=f[k][i][j]+f[S^k][i][j]-w[i][j];
					if (tmp&lt;*asd)
					{
						*asd=tmp;
						pre[S][i][j]=ppt(k,i,j);
					}
				}
				if (*asd&lt;inf)
				{
					tail++;
					q1[tail]=i,q2[tail]=j;
					dl[i][j]=true;
				}
			}
		spfa(S);
	}
	for (flag=true,i=1;i&lt;=n&amp;&amp;flag;i++)
		for (j=1;j&lt;=m;j++)
			if (w[i][j]==0)
			{
				printf(&quot;%d\n&quot;,f[mm][i][j]);
				dfs(mm,i,j);
				flag=false;
				break;
			}
	for (i=1;i&lt;=n;i++)
	{
		for (j=1;j&lt;=m;j++)
			if (w[i][j]==0) printf(&quot;x&quot;);
			else if (vt[i][j]) printf(&quot;o&quot;);
			else printf(&quot;_&quot;);
		printf(&quot;\n&quot;);
	}
	return 0;
}<pre><h2>Problem2597</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf=99999999;
int aa[2000000][4],q[4000000],hao[1000][1000],dist[200000],pre[200000];
int o[200000],ru[200000],win[200000],ans[1000][1000];
bool dl[20000];
int n,m,game,i,j,k,now,tot,S,T,head,tail,x,tmp;
int min(int a,int b) {return a&lt;b?a:b;}
void add(int p,int q,int v,int cost)
{
	++tot;
	if (tot==10)
	{
		tot++;
		tot--;
	}
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][3]=cost;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void addedge(int p,int q,int v,int cost)
{
	//printf(&quot;addedge:  %d %d %d %d\n&quot;,p,q,v,cost);
	add(p,q,v,cost);
	add(q,p,0,-cost);
}
void init()
{
	scanf(&quot;%d&quot;,&amp;n);
	game=now=n*(n-1)/2;
	tot=1;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			if (i&gt;=j) continue;
			hao[i][j]=hao[j][i]=now;
			if (x==2)
			{
				addedge(now,i+game,1,0),ru[i]++;
				addedge(now,j+game,1,0),ru[j]++;
			}
			else if (x==1) addedge(now,i+game,1,0),ru[i]++;
			else addedge(now,j+game,1,0),ru[j]++;
			now--;
		}
	S=game+n+1;
	T=S+1;
	for (i=1;i&lt;=game;i++) addedge(S,i,1,0);
	for (i=1;i&lt;=n;i++)
		for (tmp=1,j=1;j&lt;=ru[i];tmp+=2,j++) addedge(i+game,T,1,tmp);
}
bool relax(int x,int y,int v)
{
	if (dist[y]&gt;dist[x]+v)
	{
		dist[y]=dist[x]+v;
		return 1;
	}
	return 0;
}
bool spfa()
{
	memset(dist,127,sizeof(dist[0])*(T+10));
	head=tail=0;
	memset(dl,0,sizeof(dl[0])*(T+10));
	dist[S]=0;
	dl[S]=1;
	q[++tail]=S;
	while (head&lt;tail)
	{
		int x=q[++head];
		dl[x]=0;
		int p=o[x];
		while (p)
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;relax(x,y,aa[p][3]))
			{
				pre[y]=p;
				if (!dl[y])
				{
					q[++tail]=y;
					dl[y]=1;
				}
			}
			p=aa[p][0];
		}
	}
	//printf(&quot;%d\n&quot;,tail);
	//for (i=1;i&lt;=T;i++) printf(&quot;%d &quot;,dist[i]);printf(&quot;\n&quot;);
	if (dist[T]==dist[0]) return 0;
	else return 1;
}
void addcost()
{
	int p=pre[T],flow=inf;
	while (p)
	{
		flow=min(flow,aa[p][2]);
		p=pre[aa[p^1][1]];
	}
	p=pre[T];
	while (p)
	{
		aa[p][2]-=flow;
		aa[p^1][2]+=flow;
		p=pre[aa[p^1][1]];
	}
}
int calc(int i,int j)
{
	if (i==j) return 0;
	if (win[hao[i][j]]==i) return 1;
	else return 0;
}
void doit()
{
	while (spfa()) addcost();
	for (i=1;i&lt;=game;i++)
	{
		int p=o[i];
		while (p)
		{
			if (aa[p][2]==0) break;
			p=aa[p][0];
		}
		win[i]=aa[p][1]-game;
	}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++) ans[i][j]=calc(i,j);
	int res=0;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++)
			for (k=1;k&lt;=n;k++)
				if (i!=j&amp;&amp;j!=k&amp;&amp;i!=k&amp;&amp;ans[i][j]&amp;&amp;ans[j][k]&amp;&amp;ans[k][i]) ++res;
	printf(&quot;%d\n&quot;,res/3);
	for (i=1;i&lt;=n;i++)
	{
		for (j=1;j&lt;n;j++) printf(&quot;%d &quot;,ans[i][j]);
		printf(&quot;%d\n&quot;,ans[i][n]);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	init();
	doit();
	return 0;
}
<pre><h2>Problem2597</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf=99999999;
int aa[2000000][4],q[4000000],hao[1000][1000],dist[200000],pre[200000];
int o[200000],ru[200000],win[200000],ans[1000][1000];
bool dl[20000];
int n,m,game,i,j,k,now,tot,S,T,head,tail,x,tmp;
int min(int a,int b) {return a&lt;b?a:b;}
void add(int p,int q,int v,int cost)
{
	++tot;
	if (tot==10)
	{
		tot++;
		tot--;
	}
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][3]=cost;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void addedge(int p,int q,int v,int cost)
{
	add(p,q,v,cost);
	add(q,p,0,-cost);
}
void init()
{
	scanf(&quot;%d&quot;,&amp;n);
	game=now=n*(n-1)/2;
	tot=1;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			if (i&gt;=j) continue;
			hao[i][j]=hao[j][i]=now;
			if (x==2)
			{
				addedge(now,i+game,1,0),ru[i]++;
				addedge(now,j+game,1,0),ru[j]++;
			}
			else if (x==1) addedge(now,i+game,1,0),ru[i]++;
			else addedge(now,j+game,1,0),ru[j]++;
			now--;
		}
	S=game+n+1;
	T=S+1;
	for (i=1;i&lt;=game;i++) addedge(S,i,1,0);
	for (i=1;i&lt;=n;i++)
		for (tmp=0,j=1;j&lt;=ru[i];tmp+=1,j++) addedge(i+game,T,1,tmp);
}
bool relax(int x,int y,int v)
{
	if (dist[y]&gt;dist[x]+v)
	{
		dist[y]=dist[x]+v;
		return 1;
	}
	return 0;
}
bool spfa()
{
	memset(dist,127,sizeof(dist[0])*(T+10));
	head=tail=0;
	memset(dl,0,sizeof(dl[0])*(T+10));
	dist[S]=0;
	dl[S]=1;
	q[++tail]=S;
	while (head&lt;tail)
	{
		int x=q[++head];
		dl[x]=0;
		int p=o[x];
		while (p)
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;relax(x,y,aa[p][3]))
			{
				pre[y]=p;
				if (!dl[y])
				{
					q[++tail]=y;
					dl[y]=1;
				}
			}
			p=aa[p][0];
		}
	}
	if (dist[T]==dist[0]) return 0;
	else return 1;
}
void addcost()
{
	int p=pre[T],flow=inf;
	while (p)
	{
		flow=min(flow,aa[p][2]);
		p=pre[aa[p^1][1]];
	}
	p=pre[T];
	while (p)
	{
		aa[p][2]-=flow;
		aa[p^1][2]+=flow;
		p=pre[aa[p^1][1]];
	}
}
int calc(int i,int j)
{
	if (i==j) return 0;
	if (win[hao[i][j]]==i) return 1;
	else return 0;
}
void doit()
{
	while (spfa()) addcost();
	for (i=1;i&lt;=game;i++)
	{
		int p=o[i];
		while (p)
		{
			if (aa[p][2]==0) break;
			p=aa[p][0];
		}
		win[i]=aa[p][1]-game;
	}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++) ans[i][j]=calc(i,j);
	int res=0;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++)
			for (k=1;k&lt;=n;k++)
				if (i!=j&amp;&amp;j!=k&amp;&amp;i!=k&amp;&amp;ans[i][j]&amp;&amp;ans[j][k]&amp;&amp;ans[k][i]) ++res;
	printf(&quot;%d\n&quot;,res/3);
	for (i=1;i&lt;=n;i++)
	{
		for (j=1;j&lt;n;j++) printf(&quot;%d &quot;,ans[i][j]);
		printf(&quot;%d\n&quot;,ans[i][n]);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	init();
	doit();
	return 0;
}
<pre><h2>Problem2599</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define NN 210000
#define MM 1100000
#define inf 99999999
int vt[MM],b[MM],o[NN],aa[NN*2][3],size[NN];
int n,K,tot,TIME,ans;
bool done[NN];
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void calcsize(int v,int fa)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (done[y]||y==fa) continue;
		calcsize(y,v);
		size[v]+=size[y];
	}
}
int findcore(int v)
{
	bool flag=true;
	for (;flag;)
	{
		flag=false;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (done[y]) continue;
			if (size[y]*2&gt;size[v])
			{
				size[v]-=size[y];
				size[y]+=size[v];
				v=y;
				flag=true;
				break;
			}
		}
	}
	return v;
}
void dfs1(int v,int fa,int len,int e)
{
	if (len&gt;K) return;
	if (vt[K-len]==TIME&amp;&amp;b[K-len]+e&lt;ans) ans=b[K-len]+e;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (done[y]||y==fa) continue;
		dfs1(y,v,len+aa[p][2],e+1);
	}
}
void dfs2(int v,int fa,int len,int e)
{
	if (len&gt;K) return;
	if (vt[len]!=TIME) vt[len]=TIME,b[len]=e;
	else if (b[len]&gt;e) b[len]=e;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (done[y]||y==fa) continue;
		dfs2(y,v,len+aa[p][2],e+1);
	}
}
void work(int v)
{
	vt[0]=++TIME;
	b[0]=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (done[y]) continue;
		dfs1(y,v,aa[p][2],1);
		dfs2(y,v,aa[p][2],1);
	}
	done[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (done[y]) continue;
		calcsize(y,0);
		int core=findcore(y);
		work(core);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout); 
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		x++,y++;
		addedge(x,y,z);
		addedge(y,x,z);
	}
	//printf(&quot;%d\n&quot;,aa[2][2]);
	ans=inf;
	calcsize(1,0);
	//for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,size[i]);printf(&quot;\n&quot;);
	int core=findcore(1);
	//printf(&quot;%d\n&quot;,core);
	work(core);
	if (ans&lt;inf) printf(&quot;%d\n&quot;,ans);
	else printf(&quot;%d\n&quot;,-1);
	return 0;
}
<pre><h2>Problem2599</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define NN 210000
#define MM 1100000
#define inf 99999999
int vt[MM],b[MM],o[NN],aa[NN*2][3],size[NN];
int n,K,tot,TIME,ans;
bool done[NN];
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void calcsize(int v,int fa)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (done[y]||y==fa) continue;
		calcsize(y,v);
		size[v]+=size[y];
	}
}
int findcore(int v)
{
	bool flag=true;
	for (;flag;)
	{
		flag=false;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (done[y]) continue;
			if (size[y]*2&gt;size[v])
			{
				size[v]-=size[y];
				size[y]+=size[v];
				v=y;
				flag=true;
				break;
			}
		}
	}
	return v;
}
void dfs1(int v,int fa,int len,int e)
{
	if (len&gt;K) return;
	if (vt[K-len]==TIME&amp;&amp;b[K-len]+e&lt;ans) ans=b[K-len]+e;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (done[y]||y==fa) continue;
		dfs1(y,v,len+aa[p][2],e+1);
	}
}
void dfs2(int v,int fa,int len,int e)
{
	if (len&gt;K) return;
	if (vt[len]!=TIME) vt[len]=TIME,b[len]=e;
	else if (b[len]&gt;e) b[len]=e;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (done[y]||y==fa) continue;
		dfs2(y,v,len+aa[p][2],e+1);
	}
}
void work(int v)
{
	vt[0]=++TIME;
	b[0]=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (done[y]) continue;
		dfs1(y,v,aa[p][2],1);
		dfs2(y,v,aa[p][2],1);
	}
	done[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (done[y]) continue;
		calcsize(y,0);
		int core=findcore(y);
		work(core);
	}
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		x++,y++;
		addedge(x,y,z);
		addedge(y,x,z);
	}
	ans=inf;
	calcsize(1,0);
	int core=findcore(1);
	work(core);
	if (ans&lt;inf) printf(&quot;%d\n&quot;,ans);
	else printf(&quot;%d\n&quot;,-1);
	return 0;
}
<pre><h2>Problem2599</h2><pre>//一定要注意if (done[y]) continue; 
#include&lt;cstdio&gt;
using namespace std;
#define NN 210000
#define MM 1100000
#define inf 99999999
int vt[MM],b[MM],o[NN],aa[NN*2][3],size[NN];
int n,K,tot,TIME,ans;
bool done[NN];
//done就是这个点有没有做过。 
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void calcsize(int v,int fa)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (done[y]||y==fa) continue;
		calcsize(y,v);
		size[v]+=size[y];
	}
}
int findcore(int v)//渐进法找重心 
{
	bool flag=true;
	for (;flag;)
	{
		flag=false;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (done[y]) continue;
			if (size[y]*2&gt;size[v])
			{
				size[v]-=size[y];
				size[y]+=size[v];
				v=y;
				flag=true;
				break;
			}
		}
	}
	return v;
}
void dfs1(int v,int fa,int len,int e)
{
	if (len&gt;K) return;
	if (vt[K-len]==TIME&amp;&amp;b[K-len]+e&lt;ans) ans=b[K-len]+e;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (done[y]||y==fa) continue;
		dfs1(y,v,len+aa[p][2],e+1);
	}
}
void dfs2(int v,int fa,int len,int e)
{
	if (len&gt;K) return;
	if (vt[len]!=TIME) vt[len]=TIME,b[len]=e;
	else if (b[len]&gt;e) b[len]=e;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (done[y]||y==fa) continue;
		dfs2(y,v,len+aa[p][2],e+1);
	}
}
void work(int v)//这就是点分治 
{ 
	vt[0]=++TIME;
	done[v]=true;//IMIMIM
	b[0]=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (done[y]) continue;
		dfs1(y,v,aa[p][2],1);
		dfs2(y,v,aa[p][2],1);
	}
	//上面的根据题目而定 
	 
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (done[y]) continue;
		calcsize(y,0);
		int core=findcore(y);//找子树的重心 
		work(core);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout); 
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		x++,y++;
		addedge(x,y,z);
		addedge(y,x,z);
	}
	//printf(&quot;%d\n&quot;,aa[2][2]);
	ans=inf;
	calcsize(1,0);
	//for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,size[i]);printf(&quot;\n&quot;);
	int core=findcore(1);
	//printf(&quot;%d\n&quot;,core);
	work(core);
	if (ans&lt;inf) printf(&quot;%d\n&quot;,ans);
	else printf(&quot;%d\n&quot;,-1);
	return 0;
}
<pre><h2>Problem2599</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define NN 201111
#define MM 1001111
#define inf 199999999
int size[NN],o[NN],aa[NN*2][3],vt[MM],a[MM];
int n,K,tot,TIME,ans;
bool done[NN];
void dfs(int v,int fa)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa||done[y]) continue;
		dfs(y,v);
		size[v]+=size[y];
	}
}
int findcore(int v)
{
	bool flag=true;
	for (;flag;)
	{
		flag=false;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (done[y]||size[y]*2&lt;=size[v]) continue;
			size[v]-=size[y];
			size[y]+=size[v];
			v=y;
			flag=true;
			break;
		}
	}
	return v;
}
void dfs1(int v,int pre,int len,int num)
{
	//printf(&quot;%d %d %d %d\n&quot;,v,pre,len,num);
	if (len&gt;K) return;
	if (vt[K-len]==TIME&amp;&amp;num+a[K-len]&lt;ans) ans=num+a[K-len];
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==pre||done[y]) continue;
		dfs1(y,v,len+aa[p][2],num+1);
	}
}
void dfs2(int v,int pre,int len,int num)
{
	//printf(&quot;%d %d %d %d\n&quot;,v,pre,len,num);
	if (len&gt;K) return;
	//printf(&quot;%d\n&quot;,vt[len]);
	//printf(&quot;%d\n&quot;,TIME);
	if (vt[len]!=TIME) vt[len]=TIME,a[len]=num;
	else if (num&lt;a[len]) a[len]=num;
	//printf(&quot;%d\n&quot;,a[len]);
	//for(int i=0;i&lt;=10;i++)printf(&quot;%d &quot;,a[i]);printf(&quot;\n&quot;);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==pre||done[y]) continue;
		dfs2(y,v,len+aa[p][2],num+1);
	}
}
void work(int v)
{
	//printf(&quot;\n---------------------------------------------------\n&quot;);
	done[v]=true;
	TIME++;
	vt[0]=TIME,a[0]=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (done[y]) continue;
		dfs1(y,v,aa[p][2],1);
		dfs2(y,v,aa[p][2],1);
	}
	//for(int i=0;i&lt;=10;i++)printf(&quot;%d &quot;,a[i]);printf(&quot;\n&quot;);for(int i=0;i&lt;=10;i++)printf(&quot;%d &quot;,vt[i]);printf(&quot;\n&quot;);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (done[y]) continue;
		dfs(y,0);
		work(findcore(y));
	}
}
void addedge(int p,int q,int v)
{
	//printf(&quot;%d %d %d\n&quot;,p,q,v);
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,x,y,z;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		x++,y++;
		addedge(x,y,z),addedge(y,x,z);
	}
	dfs(1,0);
	ans=inf;
	work(findcore(1));
	if (ans==inf) printf(&quot;-1\n&quot;);else printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2599</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define NN 201111
#define MM 1001111
#define inf 199999999
int size[NN],o[NN],aa[NN*2][3],vt[MM],a[MM];
int n,K,tot,TIME,ans;
bool done[NN];
void dfs(int v,int fa)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (done[y]||y==fa) continue;
		dfs(y,v);
		size[v]+=size[y];
	}
}
int findcore(int v)
{
	bool flag=true;
	for (;flag;)
	{
		flag=false;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (done[y]||size[y]*2&lt;=size[v]) continue;
			size[v]-=size[y];
			size[y]+=size[v];
			v=y;
			flag=true;
			break;
		}
	}
	return v;
}
void dfs1(int v,int pre,int len,int num)
{
	if (len&gt;K) return;
	if (vt[K-len]==TIME&amp;&amp;num+a[K-len]&lt;ans) ans=num+a[K-len];
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==pre||done[y]) continue;
		dfs1(y,v,len+aa[p][2],num+1);
	}
}
void dfs2(int v,int pre,int len,int num)
{
	if (len&gt;K) return;
	if (vt[len]!=TIME) vt[len]=TIME,a[len]=num;
	else if (num&lt;a[len]) a[len]=num;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==pre||done[y]) continue;
		dfs2(y,v,len+aa[p][2],num+1);
	}
}
void work(int v)
{
	done[v]=true;
	TIME++;
	vt[0]=TIME,a[0]=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (done[y]) continue;
		dfs1(y,v,aa[p][2],1);
		dfs2(y,v,aa[p][2],1);
	}
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (done[y]) continue;
		dfs(y,0);
		work(findcore(y));
	}
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,x,y,z;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		x++,y++;
		addedge(x,y,z),addedge(y,x,z);
	}
	dfs(1,0);
	ans=inf;
	work(findcore(1));
	if (ans&lt;inf) printf(&quot;%d\n&quot;,ans);else printf(&quot;-1\n&quot;);
	return 0;
}
<pre><h2>Problem2599</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;

#define maxn 200010
#define maxk 1000010
#define INF 0x3fffffff

using namespace std;

int n,m,ans=INF,siz[maxn],tot,b[maxn],A[maxk],f[maxn],root,k;
bool vis[maxn];

struct edge{
	int x,y,w,last;
}a[maxn&lt;&lt;1];

inline int read()
{
	int ret=0;char ch=getchar();bool flag=0;
	while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')flag=1; ch=getchar();}
	while(ch&gt;='0'&amp;&amp;ch&lt;='9') ret=ret*10+ch-'0',ch=getchar();
	return flag?-ret:ret;
}

void add(int x,int y,int w)
{
	a[++tot]=(edge){x,y,w,b[x]};
	b[x]=tot;
}

void modify(int pos,int val)
{
	A[pos]=min(!A[pos]?INF:A[pos],val);
}

int query(int pos)
{
	return A[pos]==0?INF:A[pos];
}

#define v a[i].y

void calsize(int x,int fa)
{
	siz[x]=1;
	for(int i=b[x];i;i=a[i].last){
		if(v==fa||vis[v]) continue;
		calsize(v,x);
		siz[x]+=siz[v];
	}
}

void find(int x,int fa,int tot)
{
	f[x]=0;
	for(int i=b[x];i;i=a[i].last){
		if(v==fa||vis[v]) continue;
		f[x]=max(f[x],siz[v]);
		find(v,x,tot);
	}
	f[x]=max(f[x],tot-siz[x]);
	if(root==-1||f[x]&lt;f[root]) root=x;
}

void cal(int x,int fa,int dis,int sk)
{
	if(dis&gt;k) return;
	ans=min(ans,query(k-dis)+sk);
	for(int i=b[x];i;i=a[i].last){
		if(vis[v]||v==fa) continue;
		cal(v,x,dis+a[i].w,sk+1);
	}
}

void add(int x,int fa,int dis,int sk)
{
	if(dis&gt;k) return;
	modify(dis,sk);
	for(int i=b[x];i;i=a[i].last){
		if(vis[v]||v==fa) continue;
		add(v,x,dis+a[i].w,sk+1);
	}
}

void clear(int x,int fa,int dis)
{
	if(dis&gt;k) return;
	modify(dis,0);
	for(int i=b[x];i;i=a[i].last){
		if(vis[v]||v==fa) continue;
		clear(v,x,dis+a[i].w);
	}
}

void devide(int x)
{
	calsize(x,0);
	root=-1;
	find(x,0,siz[x]);
	//printf(&quot;%d\n&quot;,root);
	vis[root]=1;
	bool flag=0;
	for(int i=b[root];i;i=a[i].last){
		if(vis[v]) continue;
		if(flag) cal(v,root,a[i].w,1);else flag=1;
		add(v,root,a[i].w,1);
	}
	ans=min(ans,query(k));
	for(int i=b[root];i;i=a[i].last)if(!vis[v]) clear(v,root,a[i].w);
	for(int i=b[root];i;i=a[i].last){
		if(vis[v]) continue;
		devide(v);
	}
}

int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
	for(int i=1;i&lt;n;i++){
		int x,y,w;
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;w);
		x++,y++;
		add(x,y,w);add(y,x,w);
	}
	devide(1);
	printf(&quot;%d\n&quot;,ans&gt;n?-1:ans);
//	while(1);
	return 0;
}
<pre><h2>Problem2599</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define INF 0x7f7f7f7f
int n,cnt,K,tail,ans,first[200010],lie[200010],mn[1000010];
bool vis[200010];
struct node{
	int v,c,nt;
	node(){}
	node(int _,int __,int ___){v=_,c=__,nt=___;}
}e[400020];
void add(int x,int y,int z){e[++cnt]=node(y,z,first[x]),first[x]=cnt;}
int GetSize(int x,int f){
	int sz=1;
	for(int i=first[x];i;i=e[i].nt){
		if(e[i].v==f||vis[e[i].v])continue;
		sz+=GetSize(e[i].v,x);
	}
	return sz;
}
int GetRoot(int x,int f,int tot,int &amp;rt){
	int sz=1;
	bool flag=true;
	for(int i=first[x];i;i=e[i].nt){
		if(e[i].v==f||vis[e[i].v])continue;
		int k=GetRoot(e[i].v,x,tot,rt);
		if((k&lt;&lt;1)&gt;tot)flag=false;
		sz+=k;
	}
	if(((tot-sz)&lt;&lt;1)&gt;tot)flag=false;
	if(flag)rt=x;
	return sz;
}
void DFS(int x,int f,int val,int dep){
	if(val&gt;K)return;
	ans=min(ans,mn[K-val]+dep);
	for(int i=first[x];i;i=e[i].nt){
		if(vis[e[i].v]||e[i].v==f)continue;
		DFS(e[i].v,x,val+e[i].c,dep+1);
	}
}
void DFS2(int x,int f,int val,int dep){
	if(val&gt;K)return;
	mn[val]=min(mn[val],dep);
	lie[++tail]=val;
	for(int i=first[x];i;i=e[i].nt){
		if(vis[e[i].v]||e[i].v==f)continue;
		DFS2(e[i].v,x,val+e[i].c,dep+1);
	}
}
void Cal(int x){
	mn[0]=tail=0;
	for(int i=first[x];i;i=e[i].nt){
		if(vis[e[i].v])continue;
		DFS(e[i].v,0,e[i].c,1);
		DFS2(e[i].v,0,e[i].c,1);
	}
	for(int i=1;i&lt;=tail;i++)mn[lie[i]]=INF;
}
void divide(int x){
	int rt;
	GetRoot(x,0,GetSize(x,0),rt);
	vis[rt]=true;Cal(rt);
	for(int i=first[rt];i;i=e[i].nt)if(!vis[e[i].v])divide(e[i].v);
}
int main(){
	memset(mn,0x7f,sizeof(mn));
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	for(int i=1,x,y,z;i&lt;n;i++)scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z),add(x,y,z),add(y,x,z);
	ans=INF;divide(1);
	if(ans&gt;=n)puts(&quot;-1&quot;);
	else printf(&quot;%d\n&quot;,ans);
}
<pre><h2>Problem2618</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
using namespace std;
typedef double DD;
#define inf 999999999
#define ln printf(&quot;\n&quot;)
const DD eps=1e-7;
int n,m,now,num[2];
inline int dcmp(DD x)
{
	if (fabs(x)&lt;eps) return 0;
	return x&lt;0?-1:1;
}
struct point
{
	DD x,y;
	point(DD a=0,DD b=0) {x=a;y=b;}
	void in() {scanf(&quot;%lf%lf&quot;,&amp;x,&amp;y);}
	void out() {printf(&quot;%.3f %.3f &quot;,x,y);}
	friend point operator *(DD t,point a) {return point(a.x*t,a.y*t);}
	friend point operator +(point a,point b) {return point(a.x+b.x,a.y+b.y);}
	friend point operator -(point a,point b) {return point(a.x-b.x,a.y-b.y);}
	friend DD operator %(point a,point b) {return a.x*b.y-b.x*a.y;}
} b[2][511],q[511],P[511],V[511];
bool linesegxj(point P,point v,point A,point B)
{
	return dcmp(v%(A-P))*dcmp(v%(B-P))==-1;
}
point linejd(point P,point v,point Q,point w)
{
	point u=P-Q;
	DD t=(w%u)/(v%w);
	return P+t*v;
}
void ins(point P,point v)
{
	b[now][num[now]+1]=b[now][1];
	now^=1;
	num[now]=0;
	for (int i=1;i&lt;=num[now^1];i++)
	{
		point A=b[now^1][i],B=b[now^1][i+1];
		if (dcmp(v%(A-P))&gt;=0) b[now][++num[now]]=A;
		if (linesegxj(P,v,A,B))
			b[now][++num[now]]=linejd(P,v,A,B-A);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int cnt=0,i,j;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;m);
		for (j=1;j&lt;=m;j++) q[j].in();
		q[m+1]=q[1];
		for (j=1;j&lt;=m;j++)
		{
			cnt++;
			P[cnt]=q[j];
			V[cnt]=q[j+1]-q[j];
			//P[cnt].out(),V[cnt].out();ln;
		}
	}
	now=0;num[now]=4;
	b[0][1]=point(-inf,-inf);
	b[0][2]=point(inf,-inf);
	b[0][3]=point(inf,inf);
	b[0][4]=point(-inf,inf);
	for (i=1;i&lt;=cnt;i++)
	{
		//printf(&quot;\n------------------------------------------------------------------------------\n&quot;);
		ins(P[i],V[i]);
		//for (j=1;j&lt;=num[now];j++) b[now][j].out(),ln;
	}
	for (i=1;i&lt;=num[now];i++) q[i]=b[now][i];
	cnt=num[now];
	q[cnt+1]=q[1];
	DD ans=0;
	for (i=1;i&lt;=cnt;i++) ans+=q[i]%q[i+1];
	ans=fabs(ans)*0.5;
	printf(&quot;%.3f\n&quot;,ans);
	return 0;
}<pre><h2>Problem2618</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
using namespace std;
typedef double DD;
#define inf 999999999
#define ln printf(&quot;\n&quot;)
const DD eps=1e-7;
int n,m,now,num[2];
inline int dcmp(DD x)
{
    if (fabs(x)&lt;eps) return 0;
    return x&lt;0?-1:1;
}
struct point
{
    DD x,y;
    point(DD a=0,DD b=0) {x=a;y=b;}
    void in() {scanf(&quot;%lf%lf&quot;,&amp;x,&amp;y);}
    void out() {printf(&quot;%.3f %.3f &quot;,x,y);}
    friend point operator *(DD t,point a) {return point(a.x*t,a.y*t);}
    friend point operator +(point a,point b) {return point(a.x+b.x,a.y+b.y);}
    friend point operator -(point a,point b) {return point(a.x-b.x,a.y-b.y);}
    friend DD operator %(point a,point b) {return a.x*b.y-b.x*a.y;}
} b[2][511],q[511],P[511],V[511];
bool linesegxiangjiao(point P,point v,point A,point B)
{
    return dcmp(v%(A-P))*dcmp(v%(B-P))==-1;
}
point linesjiaodian(point P,point v,point Q,point w)
{
    point u=P-Q;
    DD t=(w%u)/(v%w);
    return P+t*v;
}
void ins(point P,point v)
{
    b[now][num[now]+1]=b[now][1];
    now^=1;
    num[now]=0;
    for (int i=1;i&lt;=num[now^1];i++)
    {
        point A=b[now^1][i],B=b[now^1][i+1];
        if (dcmp(v%(A-P))&gt;=0) b[now][++num[now]]=A;
        if (linesegxiangjiao(P,v,A,B))
            b[now][++num[now]]=linesjiaodian(P,v,A,B-A);
    }
}
int main()
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d&quot;,&amp;n);
    int cnt=0,i,j;
    for (i=1;i&lt;=n;i++)
    {
        scanf(&quot;%d&quot;,&amp;m);
        for (j=1;j&lt;=m;j++) q[j].in();
        q[m+1]=q[1];
        for (j=1;j&lt;=m;j++)
        {
            cnt++;
            P[cnt]=q[j];
            V[cnt]=q[j+1]-q[j];
        }
    }
    now=0;num[now]=4;
    b[0][1]=point(-inf,-inf);
    b[0][2]=point(inf,-inf);
    b[0][3]=point(inf,inf);
    b[0][4]=point(-inf,inf);
    for (i=1;i&lt;=cnt;i++) ins(P[i],V[i]);
    for (i=1;i&lt;=num[now];i++) q[i]=b[now][i];
    cnt=num[now];
    q[cnt+1]=q[1];
    DD ans=0;
    for (i=1;i&lt;=cnt;i++) ans+=q[i]%q[i+1];
    ans=fabs(ans)*0.5;
    printf(&quot;%.3f\n&quot;,ans);
    return 0;
}
<pre><h2>Problem2618</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
using namespace std;
typedef double DD;
#define ln printf(&quot;\n&quot;)
const DD eps=1e-7,dinf=1e10;
const int NN=1011;
int n,m,now,num[2];
inline int dcmp(DD x)
{
	if (fabs(x)&lt;eps) return 0;
	return x&lt;0?-1:1;
}
struct point
{
	DD x,y;
	point(DD a=0,DD b=0) {x=a;y=b;}
	inline void in() {scanf(&quot;%lf%lf&quot;,&amp;x,&amp;y);}
	inline void out() {printf(&quot;%.3f %.3f\n&quot;,x,y);}
	friend point operator +(const point &amp;a,const point &amp;b) {return point(a.x+b.x,a.y+b.y);}
	friend point operator -(const point &amp;a,const point &amp;b) {return point(a.x-b.x,a.y-b.y);}
	friend point operator *(DD t,const point &amp;a) {return point(a.x*t,a.y*t);}
	friend DD operator %(const point &amp;a,const point &amp;b) {return a.x*b.y-b.x*a.y;}
	friend point linejd(point P,point v,point Q,point w)
	{
		point u=P-Q;
		DD t=(w%u)/(v%w);
		return P+t*v;
	}
} b[2][NN],q[NN];
struct line
{
	point P,v;
	line(point a=point(0,0),point b=point(0,0)) {P=a;v=b;}
} xian[NN];
inline bool linesegxj(point P,point v,point A,point B)
{
	int t1=dcmp(v%(A-P)),t2=dcmp(v%(B-P));
	return t1*t2==-1;
}
void ins(point P,point v)
{
	b[now][num[now]+1]=b[now][1];
	num[now^=1]=0;
	for (int i=1;i&lt;=num[now^1];i++)
	{
		point A=b[now^1][i],B=b[now^1][i+1];
		if (dcmp(v%(A-P))&gt;=0) b[now][++num[now]]=A;
		if (linesegxj(P,v,A,B))
			b[now][++num[now]]=linejd(P,v,A,B-A);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int cnt=0,i;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;m);
		for (int i=1;i&lt;=m;i++) q[i].in();
		for (int i=1;i&lt;m;i++)
			xian[++cnt]=line(q[i],q[i+1]-q[i]);
		xian[++cnt]=line(q[m],q[1]-q[m]);
	}
	now=0;
	num[now]=4;
	b[0][1]=point(-dinf,-dinf);
	b[0][2]=point(dinf,-dinf);
	b[0][3]=point(dinf,dinf);
	b[0][4]=point(-dinf,dinf);
	for (i=1;i&lt;=cnt;i++)
		ins(xian[i].P,xian[i].v);
	DD ans=0;
	b[now][num[now]+1]=b[now][1];
	for (i=1;i&lt;=num[now];i++) ans+=b[now][i]%b[now][i+1];
	ans=fabs(ans)*0.5;
	printf(&quot;%.3f\n&quot;,ans);
	return 0;
}<pre><h2>Problem2631</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int mo=51061,NN=101111;
int fa[NN],son[NN][2],size[NN],o[NN],aa[NN*2][2];
unsigned key[NN],sum[NN],tag1[NN],tag2[NN];
int n,m,tot=1;
bool tag0[NN],rrr[NN];
void rev(int t)
{
	tag0[t]=!tag0[t];
	swap(son[t][0],son[t][1]);
}
void mul(int t,int x)
{
	tag1[t]=tag1[t]*x%mo;
	tag2[t]=tag2[t]*x%mo;
	key[t]=key[t]*x%mo;
	sum[t]=sum[t]*x%mo;
}
void add(int t,int x)
{
	tag2[t]=(tag2[t]+x)%mo;
	key[t]=(key[t]+x)%mo;
	sum[t]=(sum[t]+size[t]*x)%mo;
}
void pushdown(int t)
{
	int x=son[t][0],y=son[t][1];
	if (tag0[t])
	{
		rev(x),rev(y);
		tag0[t]=false;
	}
	if (tag1[t]!=1)
	{
		mul(x,tag1[t]),mul(y,tag1[t]);
		tag1[t]=1;
	}
	if (tag2[t])
	{
		add(x,tag2[t]),add(y,tag2[t]);
		tag2[t]=0;
	}
}
void update(int t)
{
	int x=son[t][0],y=son[t][1];
	sum[t]=(sum[x]+sum[y]+key[t])%mo;
	size[t]=size[x]+size[y]+1;
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
	else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
}
void access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
}
void makeroot(int x)
{
	access(x);
	splay(x);
	rev(x);
}
void link(int x,int y)
{
	makeroot(x);
	splay(x);
	fa[x]=y;
}
void cut(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	son[y][0]=fa[x]=0;
	rrr[x]=true;
}
void dfs(int v)
{
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dfs(y);
	}
}
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	dfs(1);
	for (i=1;i&lt;=n;i++)
	{
		tag0[i]=false,tag1[i]=1,tag2[i]=0;
		key[i]=sum[i]=1;
		size[i]=1;
		rrr[i]=true;
	}
	for (i=1;i&lt;=m;i++)
	{
		char ch=getchar();
		while (ch!='+'&amp;&amp;ch!='-'&amp;&amp;ch!='*'&amp;&amp;ch!='/') ch=getchar();
		if (ch=='+')
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			makeroot(x);
			access(y);
			splay(y);
			add(y,z);
		}
		else if (ch=='-')
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			cut(x,y);
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			link(x,y);
		}
		else if (ch=='*')
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			makeroot(x);
			access(y);
			splay(y);
			mul(y,z);
		}
		else
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			makeroot(x);
			access(y);
			splay(y);
			printf(&quot;%d\n&quot;,sum[y]);
		}
	}
	return 0;
}
<pre><h2>Problem2639</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define maa(a,b) ((a)&gt;(b)?(a):(b))
#define pb push_back
const int QQ=101111,NN=211;
int sum[NN][NN],b[NN*NN],a[NN][NN],num[NN*NN],ans[QQ],c[NN][NN][NN];
int n,m,Q;
void out(int*a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
struct point
{
	int x,y;
	point(int a=0,int b=0) {x=a;y=b;}
};
vector&lt;point&gt; pos[NN*NN];
struct dui
{
	int x1,x2,y1,y2;
	void out() {printf(&quot;%d %d  %d %d\n&quot;,x1,y1,x2,y2);}
	friend bool operator &lt;(dui a,dui b) {return a.x1&gt;b.x1;}
} D[NN*NN*NN];
struct query
{
	int x1,x2,y1,y2,id;
	void in()
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);
		if (x1&gt;x2) {int t=x1;x1=x2;x2=t;}
		if (y1&gt;y2) {int t=y1;y1=y2;y2=t;}
	}
	void out() {printf(&quot;%d %d  %d %d  %d\n&quot;,x1,y1,x2,y2,id);}
	int ask()
	{
		int tmp=sum[x2][y2]-sum[x1-1][y2]-sum[x2][y1-1]+sum[x1-1][y1-1];
		return tmp*tmp;
	}
	friend bool operator &lt;(query a,query b) {return a.x1&gt;b.x1;}
} q[QQ];
int cha(int x)
{
	int l=1,r=b[0];
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (b[mid]==x) return mid;
		if (b[mid]&gt;x) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
void change(int ii,int jj,int kk,int x)
{
	//printf(&quot;change %d %d %d\n&quot;,ii,jj,kk);
	for (int i=ii;i&lt;=200;i+=i&amp;-i)
		for (int j=jj;j&lt;=200;j+=j&amp;-j)
			for (int k=kk;k&lt;=200;k+=k&amp;-k) c[i][j][k]+=x;
}
int getsum(int ii,int jj,int kk)
{
	int res=0;
	for (int i=ii;i;i-=i&amp;-i)
		for (int j=jj;j;j-=j&amp;-j)
			for (int k=kk;k;k-=k&amp;-k) res+=c[i][j][k];
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j,k;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			scanf(&quot;%d&quot;,&amp;a[i][j]);
			b[++b[0]]=a[i][j];
		}
	sort(b+1,b+b[0]+1);
	int t=1;
	for (i=2;i&lt;=b[0];i++)
		if (b[t]!=b[i]) b[++t]=b[i];
	b[0]=t;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++) a[i][j]=cha(a[i][j]);
	//printf(&quot;b &quot;);out(b,1,b[0]);ln;for(i=1;i&lt;=n;i++){for(j=1;j&lt;=m;j++)printf(&quot;%d &quot;,a[i][j]);ln;}ln;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++) num[a[i][j]]++;
	scanf(&quot;%d&quot;,&amp;Q);
	for (i=1;i&lt;=Q;i++) q[i].in(),q[i].id=i;
	for (i=1;i&lt;=b[0];i++)
		if (num[i]&gt;200)
		{
			memset(sum,0,sizeof(sum));
			for (j=1;j&lt;=n;j++)
				for (k=1;k&lt;=m;k++)
					if (a[j][k]==i) sum[j][k]++;
			for (j=1;j&lt;=n;j++)
				for (k=1;k&lt;=m;k++)
					sum[j][k]+=sum[j][k-1]+sum[j-1][k]-sum[j-1][k-1];
			for (j=1;j&lt;=Q;j++) ans[j]+=q[j].ask();
		}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
			if (num[a[i][j]]&lt;=200) pos[a[i][j]].pb(point(i,j));//,printf(&quot;pos[%d].pb(%d,%d)\n&quot;,a[i][j],i,j);
	int num=0;
	for (i=1;i&lt;=b[0];i++)
		for (j=0;j&lt;(int)pos[i].size();j++)
			for (k=0;k&lt;(int)pos[i].size();k++)
			{
				num++;
				int x1=pos[i][j].x,x2=pos[i][k].x;
				D[num].x1=mii(x1,x2),D[num].x2=maa(x1,x2);
				int y1=pos[i][j].y,y2=pos[i][k].y;
				D[num].y1=mii(y1,y2),D[num].y2=maa(y1,y2);
			}
	sort(D+1,D+num+1);
	sort(q+1,q+Q+1);
	//printf(&quot;D:\n&quot;);for (i=1;i&lt;=num;i++) D[i].out();ln;printf(&quot;Q:\n&quot;);for(i=1;i&lt;=Q;i++)q[i].out();ln;
	int now=1;
	for (i=1;i&lt;=Q;i++)
	{
		for (;now&lt;=num&amp;&amp;D[now].x1&gt;=q[i].x1;now++)
			change(D[now].y1,D[now].x2,D[now].y2,1);
		ans[q[i].id]+=getsum(200,q[i].x2,q[i].y2)-getsum(q[i].y1-1,q[i].x2,q[i].y2);
	}
	for (i=1;i&lt;=Q;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem2639</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define maa(a,b) ((a)&gt;(b)?(a):(b))
#define pb push_back
const int QQ=101111,NN=211,B=200;
int sum[NN][NN],b[NN*NN],a[NN][NN],num[NN*NN],ans[QQ],c[NN][NN][NN];
int n,m,Q;
void out(int*a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
struct point
{
	int x,y;
	point(int a=0,int b=0) {x=a;y=b;}
};
vector&lt;point&gt; pos[NN*NN];
struct dui
{
	int x1,x2,y1,y2;
	void out() {printf(&quot;%d %d  %d %d\n&quot;,x1,y1,x2,y2);}
	friend bool operator &lt;(dui a,dui b) {return a.x1&gt;b.x1;}
} D[NN*NN*NN];
struct query
{
	int x1,x2,y1,y2,id;
	void in()
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);
		if (x1&gt;x2) {int t=x1;x1=x2;x2=t;}
		if (y1&gt;y2) {int t=y1;y1=y2;y2=t;}
	}
	void out() {printf(&quot;%d %d  %d %d  %d\n&quot;,x1,y1,x2,y2,id);}
	int ask()
	{
		int tmp=sum[x2][y2]-sum[x1-1][y2]-sum[x2][y1-1]+sum[x1-1][y1-1];
		return tmp*tmp;
	}
	friend bool operator &lt;(query a,query b) {return a.x1&gt;b.x1;}
} q[QQ];
int cha(int x)
{
	int l=1,r=b[0];
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (b[mid]==x) return mid;
		if (b[mid]&gt;x) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
void change(int ii,int jj,int kk,int x)
{
	//printf(&quot;change %d %d %d\n&quot;,ii,jj,kk);
	for (int i=ii;i&lt;=B;i+=i&amp;-i)
		for (int j=jj;j&lt;=B;j+=j&amp;-j)
			for (int k=kk;k&lt;=B;k+=k&amp;-k) c[i][j][k]+=x;
}
int getsum(int ii,int jj,int kk)
{
	int res=0;
	for (int i=ii;i;i-=i&amp;-i)
		for (int j=jj;j;j-=j&amp;-j)
			for (int k=kk;k;k-=k&amp;-k) res+=c[i][j][k];
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j,k;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			scanf(&quot;%d&quot;,&amp;a[i][j]);
			b[++b[0]]=a[i][j];
		}
	sort(b+1,b+b[0]+1);
	int t=1;
	for (i=2;i&lt;=b[0];i++)
		if (b[t]!=b[i]) b[++t]=b[i];
	b[0]=t;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++) a[i][j]=cha(a[i][j]);
	//printf(&quot;b &quot;);out(b,1,b[0]);ln;for(i=1;i&lt;=n;i++){for(j=1;j&lt;=m;j++)printf(&quot;%d &quot;,a[i][j]);ln;}ln;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++) num[a[i][j]]++;
	scanf(&quot;%d&quot;,&amp;Q);
	for (i=1;i&lt;=Q;i++) q[i].in(),q[i].id=i;
	for (i=1;i&lt;=b[0];i++)
		if (num[i]&gt;B)
		{
			memset(sum,0,sizeof(sum));
			for (j=1;j&lt;=n;j++)
				for (k=1;k&lt;=m;k++)
					if (a[j][k]==i) sum[j][k]++;
			for (j=1;j&lt;=n;j++)
				for (k=1;k&lt;=m;k++)
					sum[j][k]+=sum[j][k-1]+sum[j-1][k]-sum[j-1][k-1];
			for (j=1;j&lt;=Q;j++) ans[j]+=q[j].ask();
		}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
			if (num[a[i][j]]&lt;=B) pos[a[i][j]].pb(point(i,j));//,printf(&quot;pos[%d].pb(%d,%d)\n&quot;,a[i][j],i,j);
	int num=0;
	for (i=1;i&lt;=b[0];i++)
		for (j=0;j&lt;(int)pos[i].size();j++)
			for (k=0;k&lt;(int)pos[i].size();k++)
			{
				num++;
				int x1=pos[i][j].x,x2=pos[i][k].x;
				D[num].x1=mii(x1,x2),D[num].x2=maa(x1,x2);
				int y1=pos[i][j].y,y2=pos[i][k].y;
				D[num].y1=mii(y1,y2),D[num].y2=maa(y1,y2);
			}
	sort(D+1,D+num+1);
	sort(q+1,q+Q+1);
	//printf(&quot;D:\n&quot;);for (i=1;i&lt;=num;i++) D[i].out();ln;printf(&quot;Q:\n&quot;);for(i=1;i&lt;=Q;i++)q[i].out();ln;
	int now=1;
	for (i=1;i&lt;=Q;i++)
	{
		for (;now&lt;=num&amp;&amp;D[now].x1&gt;=q[i].x1;now++)
			change(D[now].y1,D[now].x2,D[now].y2,1);
		ans[q[i].id]+=getsum(B,q[i].x2,q[i].y2)-getsum(q[i].y1-1,q[i].x2,q[i].y2);
	}
	for (i=1;i&lt;=Q;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem2639</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define maa(a,b) ((a)&gt;(b)?(a):(b))
#define pb push_back
const int QQ=101111,NN=211,B=205;
int sum[NN][NN],b[NN*NN],a[NN][NN],num[NN*NN],ans[QQ],c[NN][NN][NN];
int n,m,Q;
void out(int*a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
struct point
{
	int x,y;
	point(int a=0,int b=0) {x=a;y=b;}
};
vector&lt;point&gt; pos[NN*NN];
struct dui
{
	int x1,x2,y1,y2;
	void out() {printf(&quot;%d %d  %d %d\n&quot;,x1,y1,x2,y2);}
	friend bool operator &lt;(dui a,dui b) {return a.x1&gt;b.x1;}
} D[NN*NN*NN];
struct query
{
	int x1,x2,y1,y2,id;
	void in()
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);
		if (x1&gt;x2) {int t=x1;x1=x2;x2=t;}
		if (y1&gt;y2) {int t=y1;y1=y2;y2=t;}
	}
	void out() {printf(&quot;%d %d  %d %d  %d\n&quot;,x1,y1,x2,y2,id);}
	int ask()
	{
		int tmp=sum[x2][y2]-sum[x1-1][y2]-sum[x2][y1-1]+sum[x1-1][y1-1];
		return tmp*tmp;
	}
	friend bool operator &lt;(query a,query b) {return a.x1&gt;b.x1;}
} q[QQ];
int cha(int x)
{
	int l=1,r=b[0];
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (b[mid]==x) return mid;
		if (b[mid]&gt;x) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
void change(int ii,int jj,int kk,int x)
{
	//printf(&quot;change %d %d %d\n&quot;,ii,jj,kk);
	for (int i=ii;i&lt;=B;i+=i&amp;-i)
		for (int j=jj;j&lt;=B;j+=j&amp;-j)
			for (int k=kk;k&lt;=B;k+=k&amp;-k) c[i][j][k]+=x;
}
int getsum(int ii,int jj,int kk)
{
	int res=0;
	for (int i=ii;i;i-=i&amp;-i)
		for (int j=jj;j;j-=j&amp;-j)
			for (int k=kk;k;k-=k&amp;-k) res+=c[i][j][k];
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j,k;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			scanf(&quot;%d&quot;,&amp;a[i][j]);
			b[++b[0]]=a[i][j];
		}
	sort(b+1,b+b[0]+1);
	int t=1;
	for (i=2;i&lt;=b[0];i++)
		if (b[t]!=b[i]) b[++t]=b[i];
	b[0]=t;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++) a[i][j]=cha(a[i][j]);
	//printf(&quot;b &quot;);out(b,1,b[0]);ln;for(i=1;i&lt;=n;i++){for(j=1;j&lt;=m;j++)printf(&quot;%d &quot;,a[i][j]);ln;}ln;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++) num[a[i][j]]++;
	scanf(&quot;%d&quot;,&amp;Q);
	for (i=1;i&lt;=Q;i++) q[i].in(),q[i].id=i;
	for (i=1;i&lt;=b[0];i++)
		if (num[i]&gt;B)
		{
			memset(sum,0,sizeof(sum));
			for (j=1;j&lt;=n;j++)
				for (k=1;k&lt;=m;k++)
					if (a[j][k]==i) sum[j][k]++;
			for (j=1;j&lt;=n;j++)
				for (k=1;k&lt;=m;k++)
					sum[j][k]+=sum[j][k-1]+sum[j-1][k]-sum[j-1][k-1];
			for (j=1;j&lt;=Q;j++) ans[j]+=q[j].ask();
		}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
			if (num[a[i][j]]&lt;=B) pos[a[i][j]].pb(point(i,j));//,printf(&quot;pos[%d].pb(%d,%d)\n&quot;,a[i][j],i,j);
	int num=0;
	for (i=1;i&lt;=b[0];i++)
		for (j=0;j&lt;(int)pos[i].size();j++)
			for (k=0;k&lt;(int)pos[i].size();k++)
			{
				num++;
				int x1=pos[i][j].x,x2=pos[i][k].x;
				D[num].x1=mii(x1,x2),D[num].x2=maa(x1,x2);
				int y1=pos[i][j].y,y2=pos[i][k].y;
				D[num].y1=mii(y1,y2),D[num].y2=maa(y1,y2);
			}
	sort(D+1,D+num+1);
	sort(q+1,q+Q+1);
	//printf(&quot;D:\n&quot;);for (i=1;i&lt;=num;i++) D[i].out();ln;printf(&quot;Q:\n&quot;);for(i=1;i&lt;=Q;i++)q[i].out();ln;
	int now=1;
	for (i=1;i&lt;=Q;i++)
	{
		for (;now&lt;=num&amp;&amp;D[now].x1&gt;=q[i].x1;now++)
			change(D[now].y1,D[now].x2,D[now].y2,1);
		ans[q[i].id]+=getsum(B,q[i].x2,q[i].y2)-getsum(q[i].y1-1,q[i].x2,q[i].y2);
	}
	for (i=1;i&lt;=Q;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem2650</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define mii(a,b) ((a)&lt;(b)?(a):(b))
typedef long long LL;
const LL INF=999999999999999999LL;
const int NN=1000005,inf=99999999;
LL f[NN],g[NN],sum1[NN],sum2[NN],C;
int n,h[NN],sta[NN];
inline LL F(LL a,LL b,LL c,LL x)
{
	return a*x*x+b*x+c;
}
LL calc(LL a,LL b,LL c,LL l,LL r)
{
	LL res=INF;
	res=min(res,F(a,b,c,l));
	res=min(res,F(a,b,c,r));
	LL t=(LL)(-b*1.0/(2*a));
	if (t&gt;=l&amp;&amp;t&lt;=r) res=min(res,F(a,b,c,t));
	if (t+1&gt;=l&amp;&amp;t+1&lt;=r) res=min(res,F(a,b,c,t+1));
	return res;
}
void work(LL *f)
{
	int i;
	sum1[0]=sum2[0]=0;
	for (i=1;i&lt;=n;i++)
	{
		sum1[i]=sum1[i-1]+h[i];
		sum2[i]=sum2[i-1]+(LL)h[i]*h[i];
	}
	f[0]=0;
	int now=0;
	for (i=1;i&lt;=n;i++)
	{
		f[i]=INF;
		if (now&gt;h[i]) continue;
		LL a=i-1;
		LL b=-2*sum1[i-1]-C;
		LL c=sum2[i-1]+C*h[i];
		f[i]=min(f[i],calc(a,b,c,now,h[i]));
		if (h[i]&gt;now) now=h[i];
	}
	int top;
	sta[top=1]=1;
	for (i=2;i&lt;=n;i++)
	{
		for (int tmp=0;top;tmp=h[sta[top--]])
		{
			int j=sta[top];
			LL a=i-j-1;
			LL b=-2*(sum1[i-1]-sum1[j])-2*C;
			LL c=sum2[i-1]-sum2[j]+C*(h[i]+h[j]);
			f[i]=min(f[i],f[j]+calc(a,b,c,tmp,mii(h[i],h[j])));
			if (h[j]&gt;h[i]) break;
		}
		sta[++top]=i;
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%lld&quot;,&amp;n,&amp;C);
	int i;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;h[i]);
	work(f);
	for (i=1;i+i&lt;=n;i++) swap(h[i],h[n-i+1]);
	work(g);
	LL ans=INF;
	for (i=1;i&lt;=n;i++)
		if (f[i]+g[n-i+1]&lt;ans) ans=f[i]+g[n-i+1];
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem2653</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 2000000000
int lc[5000000],rc[5000000],lmax[5000000],rmax[5000000],sum[5000000];
int a[5000000],b[5000000],q[10],root[5000000],pos[5000000];
int n,m,SIZE,ww,ee,mmax,ssum;
int max(int a,int b) {return a&gt;b?a:b;}
bool cmp(int x,int y) {return a[x]&lt;a[y];}
void update(int v)
{
	sum[v]=sum[lc[v]]+sum[rc[v]];
	lmax[v]=max(lmax[lc[v]],sum[lc[v]]+lmax[rc[v]]);
	rmax[v]=max(rmax[rc[v]],sum[rc[v]]+rmax[lc[v]]);
}
void build1(int &amp;v,int l,int r)
{
	if (!v) v=++SIZE;
	if (r-l==1)
	{
		sum[v]=lmax[v]=rmax[v]=1;
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build1(lc[v],l,mid);
	build1(rc[v],mid,r);
	update(v);
}
void ins(int &amp;v,int pos,int l,int r,int x)
{
	if (!v) v=++SIZE;
	if (r-l==1)
	{
		sum[v]=lmax[v]=rmax[v]=-1;
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid)
	{
		rc[v]=rc[pos];
		ins(lc[v],lc[pos],l,mid,x);
	}
	else
	{
		lc[v]=lc[pos];
		ins(rc[v],rc[pos],mid,r,x);
	}
	update(v);
}
int findsum(int v,int l,int r)
{
	//printf(&quot;findsum   %d %d %d\n&quot;,v,l,r);
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return sum[v];
	int mid=(l+r)&gt;&gt;1,res=0;
	if (ww&lt;mid) res+=findsum(lc[v],l,mid);
	if (ee&gt;mid) res+=findsum(rc[v],mid,r);
	return res;
}
void findrmax(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		mmax=max(mmax,ssum+rmax[v]);
		ssum=sum[v]+ssum;
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (ee&gt;mid) findrmax(rc[v],mid,r);
	if (ww&lt;mid) findrmax(lc[v],l,mid);
}
void findlmax(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		mmax=max(mmax,ssum+lmax[v]);
		ssum=ssum+sum[v];
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) findlmax(lc[v],l,mid);
	if (ee&gt;mid) findlmax(rc[v],mid,r);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),b[i]=a[i],pos[i]=i;
	sort(b+1,b+n+1);
	sort(pos+1,pos+n+1,cmp);
	build1(root[1],1,n+1);
	for (i=2;i&lt;=n;i++) ins(root[i],root[i-1],1,n+1,pos[i-1]);
	scanf(&quot;%d&quot;,&amp;m);
	int lastans=0;
	for (i=1;i&lt;=m;i++)
	{
		//printf(&quot;\n-------------------------------------\n&quot;);
		for (j=1;j&lt;=4;j++) scanf(&quot;%d&quot;,&amp;q[j]),q[j]=(q[j]+lastans)%n,++q[j];
		sort(q+1,q+5);
		//printf(&quot;q[i]: &quot;);for (j=1;j&lt;=4;j++) printf(&quot;%d &quot;,q[j]);printf(&quot;\n&quot;);
		int l=1,r=n;
		while (l&lt;=r)
		{
			int mid=(l+r)&gt;&gt;1;
			ssum=0,mmax=-inf;
			ww=q[2]+1,ee=q[3]-1+1;
			int res=0;
			//printf(&quot;ww,ee %d %d\n&quot;,ww,ee);
			if (q[3]&gt;q[2]+1) res=findsum(root[mid],1,n+1);
			//printf(&quot;res: %d\n&quot;,res);
			ww=q[1],ee=q[2]+1;
			findrmax(root[mid],1,n+1);
			res+=mmax;
			//printf(&quot;res: %d\n&quot;,res);
			ssum=0,mmax=-inf;
			ww=q[3],ee=q[4]+1;
			findlmax(root[mid],1,n+1);
			res+=mmax;
			//printf(&quot;res: %d\n&quot;,res);
			if (res&gt;=0) lastans=mid,l=mid+1;
			else r=mid-1;
		}
		printf(&quot;%d\n&quot;,lastans=b[lastans]);
	}
	return 0;
}
<pre><h2>Problem2653</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 2000000000
int lc[300000],rc[300000],lmax[300000],rmax[300000],sum[300000];
int a[300000],b[300000],q[10],root[300000],pos[300000];
int n,m,SIZE,ww,ee,mmax,ssum;
int max(int a,int b) {return a&gt;b?a:b;}
bool cmp(int x,int y) {return a[x]&lt;a[y];}
void update(int v)
{
	sum[v]=sum[lc[v]]+sum[rc[v]];
	lmax[v]=max(lmax[lc[v]],sum[lc[v]]+lmax[rc[v]]);
	rmax[v]=max(rmax[rc[v]],sum[rc[v]]+rmax[lc[v]]);
}
void build1(int &amp;v,int l,int r)
{
	if (!v) v=++SIZE;
	if (r-l==1)
	{
		sum[v]=lmax[v]=rmax[v]=1;
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build1(lc[v],l,mid);
	build1(rc[v],mid,r);
	update(v);
}
void ins(int &amp;v,int pos,int l,int r,int x)
{
	if (!v) v=++SIZE;
	if (r-l==1)
	{
		sum[v]=lmax[v]=rmax[v]=-1;
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid)
	{
		rc[v]=rc[pos];
		ins(lc[v],lc[pos],l,mid,x);
	}
	else
	{
		lc[v]=lc[pos];
		ins(rc[v],rc[pos],mid,r,x);
	}
	update(v);
}
int findsum(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return sum[v];
	int mid=(l+r)&gt;&gt;1,res=0;
	if (ww&lt;mid) res+=findsum(lc[v],l,mid);
	if (ee&gt;mid) res+=findsum(rc[v],mid,r);
	return res;
}
void findrmax(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		mmax=max(mmax,ssum+rmax[v]);
		ssum=sum[v]+ssum;
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (ee&gt;mid) findrmax(rc[v],mid,r);
	if (ww&lt;mid) findrmax(lc[v],l,mid);
}
void findlmax(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		mmax=max(mmax,ssum+lmax[v]);
		ssum=ssum+sum[v];
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) findlmax(lc[v],l,mid);
	if (ee&gt;mid) findlmax(rc[v],mid,r);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),b[i]=a[i],pos[i]=i;
	sort(b+1,b+n+1);
	sort(pos+1,pos+n+1,cmp);
	build1(root[1],1,n+1);
	for (i=2;i&lt;=n;i++) ins(root[i],root[i-1],1,n+1,pos[i-1]);
	scanf(&quot;%d&quot;,&amp;m);
	int lastans=0;
	for (i=1;i&lt;=m;i++)
	{
		for (j=1;j&lt;=4;j++) scanf(&quot;%d&quot;,&amp;q[j]),q[j]=(q[j]+lastans)%n,++q[j];
		sort(q+1,q+5);
		int l=1,r=n;
		while (l&lt;=r)
		{
			int mid=(l+r)&gt;&gt;1;
			ssum=0,mmax=-inf;
			ww=q[2]+1,ee=q[3]-1+1;
			int res=0;
			if (q[3]&gt;q[2]+1) res=findsum(root[mid],1,n+1);
			ww=q[1],ee=q[2]+1;
			findrmax(root[mid],1,n+1);
			res+=mmax;
			ssum=0,mmax=-inf;
			ww=q[3],ee=q[4]+1;
			findlmax(root[mid],1,n+1);
			res+=mmax;
			if (res&gt;=0) lastans=mid,l=mid+1;
			else r=mid-1;
		}
		printf(&quot;%d\n&quot;,lastans=b[lastans]);
	}
	return 0;
}
<pre><h2>Problem2655</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
using namespace std;
typedef long long LL;
LL A,mo,f[1511][511];
int n,size;
inline LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
void prepare()
{
	f[1][1]=1;
	int i,j;
	f[0][0]=1;
	for (i=1;i&lt;=size;i++)
	{
		f[i][0]=1;
		for (j=1;j&lt;=n;j++)
			f[i][j]=(f[i-1][j]+f[i-1][j-1]*i)%mo;
	}
}
LL work()
{
	LL res=0;int i,j;
	for (j=1;j&lt;=size;j++)
	{
		LL t1=1,t2=1;
		for (i=1;i&lt;=size;i++) if (i!=j)
		{
			t1=t1*(A-i)%mo;
			t2=t2*(j-i)%mo;
		}
		LL tmp=t1*ksm(t2,mo-2,mo)%mo;
		res=(res+f[j][n]*tmp)%mo;
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	cin&gt;&gt;A&gt;&gt;n&gt;&gt;mo;
	size=(int)n*2.5+1;
	prepare();
	LL ans=work();
	for (int i=1;i&lt;=n;i++) ans=ans*i%mo;
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem2661</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
#define ln printf(&quot;\n&quot;)
const int NN=2111;
int aa[3000000][4],o[NN],pre[NN];
int tot=1,A,B,S,T,ans,flow;
inline void addedge(int p,int q,int v,int c)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][3]=c;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline void add(int p,int q,int v,int c)
{
	addedge(p,q,v,c);
	addedge(q,p,0,-c);
}
bool spfa()
{
	static int que[NN],dist[NN];
	static bool dl[NN];
	int head=0,tail=1;
	que[1]=S;
	memset(dist,60,sizeof(dist));
	dist[S]=0;
	memset(dl,0,sizeof(dl));
	dl[S]=true;
	while (head&lt;tail)
	{
		int x=que[++head];
		dl[x]=false;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;dist[y]&gt;dist[x]+aa[p][3])
			{
				dist[y]=dist[x]+aa[p][3];
				pre[y]=p;
				if (!dl[y]) que[++tail]=y;
			}
		}
	}
	return dist[T]&lt;dist[0];
}
void calc()
{
	int ff=inf,p;
	for (p=pre[T];p;p=pre[aa[p^1][1]]) ff=min(ff,aa[p][2]);
	flow+=ff;
	for (p=pre[T];p;p=pre[aa[p^1][1]])
	{
		ans+=ff*aa[p][3];
		aa[p][2]-=ff,aa[p^1][2]+=ff;
	}
}
int gcd(int a,int b) {return !b?a:gcd(b,a%b);}
inline bool check(int x,int y)
{
	int t=x*x-y*y;
	int tmp=sqrt(t)+0.1;
	if (tmp*tmp!=t) return false;
	if (gcd(x,tmp)!=1) return false;
	return true;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;A,&amp;B);
	S=2001,T=2002;
	int i,j;
	for (i=A;i&lt;B;i++)
		for (j=i+1;j&lt;=B;j++)
			if (check(j,i))
			{
				add(i,j+1000,1,-(i+j));
				add(j,i+1000,1,-(i+j));
			}
	for (i=A;i&lt;=B;i++)
		add(S,i,1,0),add(i+1000,T,1,0);
	while (spfa()) calc();
	printf(&quot;%d %d\n&quot;,flow&gt;&gt;1,-ans&gt;&gt;1);
	return 0;
}<pre><h2>Problem2668</h2><pre>var
    n, m                        :longint;
    num                         :array[0..30,0..30] of longint;
    source, sink                :longint;
    go                          :array[0..2,0..8] of longint;
    ans                         :longint;
    last                        :array[0..2010] of longint;
    pre, other, len, cost       :array[0..400010] of longint;
    l                           :longint;
    que, d, father              :array[0..2010] of longint;
    flag                        :array[0..2010] of boolean;
    map                         :array[0..30,0..30] of longint;
function min(a,b:longint):longint;
begin
    if a&gt;b then min:=b else min:=a;
end;
procedure connect(a,b,c,d:longint);
begin
    inc(l);
    pre[l]:=last[a];
    last[a]:=l;
    other[l]:=b;
    len[l]:=c;
    cost[l]:=d;
end;
procedure init;
var
    i, j, k                     :longint;
    s                           :char;
    sum1, sum2                  :longint;
    key                         :longint;
    nx, ny                      :longint;
begin
    readln(n,m);
    go[1,1]:=-1; go[2,2]:=1; go[1,3]:=1; go[2,4]:=-1;
    go[1,5]:=-1; go[2,5]:=1;
    go[1,6]:=1; go[2,6]:=1;
    go[1,7]:=1; go[2,7]:=-1;
    go[1,8]:=-1; go[2,8]:=-1;
    sum1:=0; sum2:=0; l:=1;
    for i:=1 to n do
        for j:=1 to m do num[i,j]:=(i-1)*m+j;
     
    source:=n*m*3+2; sink:=source+1;
    for i:=1 to n do
    begin
        for j:=1 to m do
        begin
            read(s);
            if s='1' then
            begin
                connect(source,num[i,j]+n*m,1,0);
                connect(num[i,j]+n*m,source,0,0);
                map[i,j]:=1;
                inc(sum1);
            end;
        end;
        readln;
    end;
    for i:=1 to n do
    begin
        for j:=1 to m do
        begin  
            read(s);
            if s='1' then
            begin
                connect(num[i,j]+n*m,sink,1,0);
                connect(sink,num[i,j]+n*m,0,0);
                map[i,j]:=2;
                inc(sum2);
            end;
        end;
        readln;
    end;
    if sum1&lt;&gt;sum2 then
    begin
        writeln(-1);
        halt;
    end;
    for i:=1 to n do
    begin
        for j:=1 to m do
        begin
            read(s);
            key:=ord(s)-48;
            if map[i,j]=0 then
            begin
                connect(num[i,j],num[i,j]+n*m,key div 2,0);
                connect(num[i,j]+n*m,num[i,j],0,0);
                connect(num[i,j]+n*m,num[i,j]+2*n*m,key div 2,0);
                connect(num[i,j]+2*n*m,num[i,j]+n*m,0,0);
            end else
            if map[i,j]=1 then
            begin
                connect(num[i,j],num[i,j]+n*m,key div 2,0);
                connect(num[i,j]+n*m,num[i,j],0,0);
                connect(num[i,j]+n*m,num[i,j]+2*n*m,(key+1) div 2,0);
                connect(num[i,j]+2*n*m,num[i,j]+n*m,0,0);
            end else
            begin
                connect(num[i,j],num[i,j]+n*m,(key+1) div 2,0);
                connect(num[i,j]+n*m,num[i,j],0,0);
                connect(num[i,j]+n*m,num[i,j]+2*n*m,key div 2,0);
                connect(num[i,j]+2*n*m,num[i,j]+n*m,0,0);
            end;
        end;
        readln;
    end;
    for i:=1 to n do
        for j:=1 to m do
            for k:=1 to 8 do
            begin
                nx:=i+go[1,k];
                ny:=j+go[2,k];
                if (nx&lt;1) or (nx&gt;n) or (ny&lt;1) or (ny&gt;m) then continue;
                connect(num[i,j]+2*n*m,num[nx,ny],maxlongint div 10,1);
                connect(num[nx,ny],num[i,j]+2*m*n,0,-1);
            end;
end;
function spfa:boolean;
var
    cur, h, t                   :longint;
    q, p                        :longint;
begin
    filldword(d,sizeof(d) div 4, maxlongint div 10);
    d[source]:=0; 
    h:=0; t:=1;
    que[1]:=source;
    while h&lt;&gt;t do
    begin
        h:=h mod 2000+1;
        cur:=que[h];
        flag[cur]:=false;
        q:=last[cur];
        while q&lt;&gt;0 do
        begin
            if len[q]&gt;0 then
            begin
                p:=other[q];
                if d[p]&gt;d[cur]+cost[q] then
                begin
                    d[p]:=d[cur]+cost[q];
                    father[p]:=q;
                    if not flag[p] then
                    begin
                        t:=t mod 2000+1;
                        que[t]:=p;
                        flag[p]:=true;
                    end;
                end;
            end;
            q:=pre[q];
        end;
    end;
    if d[sink]=maxlongint div 10 then exit(false) else exit(true);
end;
procedure update;
var
    low, cur                    :longint;
begin
    cur:=sink;
    low:=maxlongint;
    while cur&lt;&gt;source do
    begin
        low:=min(low,len[father[cur]]);
        cur:=other[father[cur] xor 1];
    end;
    cur:=sink;
    while cur&lt;&gt;source do
    begin
        dec(len[father[cur]],low);
        inc(len[father[cur] xor 1],low);
        inc(ans,low*cost[father[cur]]);
        cur:=other[father[cur] xor 1];
    end;
end;
procedure main;
var
    q                           :longint;
begin
    while spfa do update;
    q:=last[source];
    while q&lt;&gt;0 do
    begin
        if len[q]&gt;0 then
        begin
            writeln(-1);
            halt;
        end;
        q:=pre[q];
    end;
    writeln(ans);
end;
begin
    init;
    main;
end.
<pre><h2>Problem2668</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
using namespace std;
const int dx[8]={-1,-1,-1,0,0,1,1,1},dy[8]={1,0,-1,1,-1,1,0,-1},inf=99999999;
int aa[1000000][4],o[500000],pre[500000],dist[500000],q[1000000];
int hao[1000][1000][3],a[1000][1000],map[1000][1000];
int n,m,S,T,head,tail,num,i,j,k,tot,cnt1,cnt2,ans;
bool dl[500000];
char ch;
int min(int a,int b) {return a&lt;b?a:b;}
void add(int p,int q,int v,int cost)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][3]=cost;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void addedge(int p,int q,int v,int cost)
{
	add(p,q,v,cost);
	add(q,p,0,-cost);
}
void init()
{
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
			for (k=0;k&lt;3;k++) hao[i][j][k]=++num;
	S=++num,T=++num;
	tot=1;
	for (i=1;i&lt;=n;i++,scanf(&quot;\n&quot;))//初状态 
		for (j=1;j&lt;=m;j++)
		{
			scanf(&quot;%c&quot;,&amp;ch);
			if (ch=='1')
			{
				cnt1++;
				map[i][j]=1;
				addedge(S,hao[i][j][1],1,0);
			}
		}
	for (i=1;i&lt;=n;i++,scanf(&quot;\n&quot;))//末状态 
		for (j=1;j&lt;=m;j++)
		{
			scanf(&quot;%c&quot;,&amp;ch);
			if (ch=='1')
			{
				cnt2++;
				map[i][j]=2;
				addedge(hao[i][j][1],T,1,0);
			}
		}
	if (cnt1!=cnt2)
	{
		printf(&quot;%d\n&quot;,-1);
		exit(0);
	}
	for (i=1;i&lt;=n;i++,scanf(&quot;\n&quot;))
		for (j=1;j&lt;=m;j++) scanf(&quot;%c&quot;,&amp;ch),a[i][j]=ch-'0';
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
			if (map[i][j]==1)
			{
				addedge(hao[i][j][0],hao[i][j][1],a[i][j]/2,0);
				addedge(hao[i][j][1],hao[i][j][2],(a[i][j]+1)/2,0);
			}
			else if (map[i][j]==2)
			{
				addedge(hao[i][j][0],hao[i][j][1],(a[i][j]+1)/2,0);
				addedge(hao[i][j][1],hao[i][j][2],a[i][j]/2,0);
			}
			else
			{
				addedge(hao[i][j][0],hao[i][j][1],a[i][j]/2,0);
				addedge(hao[i][j][1],hao[i][j][2],a[i][j]/2,0);
			}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
			for (k=0;k&lt;8;k++)
			{
				int x=i+dx[k],y=j+dy[k];
				if (x&lt;1||x&gt;n||y&lt;1||y&gt;m) continue;
				addedge(hao[i][j][2],hao[x][y][0],inf,1);
			}
}
bool relax(int x,int y,int v)
{
	if (dist[y]&gt;dist[x]+v)
	{
		dist[y]=dist[x]+v;
		return 1;
	}
	return 0;
}
bool spfa()
{
	head=tail=0;
	memset(dist,127,sizeof(dist[0])*(T+10));
	memset(dl,0,sizeof(dl[0])*(T+10));
	dist[S]=1;
	q[++tail]=S;
	dl[S]=1;
	while (head&lt;tail)
	{
		int x=q[++head];
		dl[x]=0;
		int p=o[x];
		while (p)
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;relax(x,y,aa[p][3]))
			{
				pre[y]=p;
				if (!dl[y]) q[++tail]=y,dl[y]=1;
			}
			p=aa[p][0];
		}
	}
	return dist[T]&lt;dist[0];
}
void addcost()
{
	int p=pre[T],flow=inf;
	while (p)
	{
		flow=min(flow,aa[p][2]);
		p=pre[aa[p^1][1]];
	}
	p=pre[T];
	while (p)
	{
		ans+=flow*aa[p][3];
		aa[p][2]-=flow;
		aa[p^1][2]+=flow;
		p=pre[aa[p^1][1]];
	}
}
void doit()
{
	for (;spfa();addcost());
	for (int p=o[S];p;p=aa[p][0])
		if (aa[p][2])
		{
			printf(&quot;%d\n&quot;,-1);
			exit(0);
		}
	printf(&quot;%d\n&quot;,ans);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	init();
	doit();
	return 0;
}
<pre><h2>Problem2683</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int id[4*501111],id2[4*501111],ans[4*511111];
int S,W,cnt,m;
struct info
{
    int kind,x,y,k,t;
} q[4*501111];
struct BIT
{
    int c[2000005];
    void change(int i,int x)
    {
        for (;i&lt;=W;i+=i&amp;-i) c[i]+=x;
    }
    int getsum(int i)
    {
        int res=0;
        for (;i;i-=i&amp;-i) res+=c[i];
        return res;
    }
    void clear(int i)
    {
        for (;i&lt;=W;i+=i&amp;-i) c[i]=0;
    }
} C;
void cdq(int l,int r)
{
    if (l==r) return;
    int mid=(l+r)&gt;&gt;1,i,j,k;
    cdq(l,mid),cdq(mid+1,r);
    for (i=mid+1,j=l;i&lt;=r;i++)
    {
        int t=id[i];
        for (int w=id[j];j&lt;=mid&amp;&amp;q[w].x&lt;=q[t].x;w=id[++j])
            if (q[w].kind==1) C.change(q[w].y,q[w].k);
        if (q[t].kind==2) ans[q[t].k]+=q[t].t*C.getsum(q[t].y);
    }
    for (j=l;j&lt;=mid;j++)
        if (q[id[j]].kind==1) C.clear(q[id[j]].y);
    for (i=l,j=mid+1,k=l;k&lt;=r;k++)
        if (j&gt;r||(i&lt;=mid&amp;&amp;q[id[i]].x&lt;q[id[j]].x)) id2[k]=id[i++];
        else id2[k]=id[j++];
    for (k=l;k&lt;=r;k++) id[k]=id2[k];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d&quot;,&amp;W);W++;
    S=0;
    for (;;)
    {
        int x,x1,x2,y1,y2;
        scanf(&quot;%d&quot;,&amp;x);
        if (x==1)
        {
            cnt++;q[cnt].kind=1;
            scanf(&quot;%d%d%d&quot;,&amp;q[cnt].x,&amp;q[cnt].y,&amp;q[cnt].k);
            q[cnt].x++,q[cnt].y++;
        }
        else if (x==2)
        {
            scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);
            x1++,x2++,y1++,y2++;
            ans[++m]=(x2-x1+1)*(y2-y1+1)*S;
            cnt++;q[cnt].kind=2,q[cnt].x=x2,q[cnt].y=y2,q[cnt].k=m,q[cnt].t=1;
            cnt++;q[cnt].kind=2,q[cnt].x=x2,q[cnt].y=y1-1,q[cnt].k=m,q[cnt].t=-1;
            cnt++;q[cnt].kind=2,q[cnt].x=x1-1,q[cnt].y=y2,q[cnt].k=m,q[cnt].t=-1;
            cnt++;q[cnt].kind=2,q[cnt].x=x1-1,q[cnt].y=y1-1,q[cnt].k=m,q[cnt].t=1;
        }
        else break;
    }
    for (int i=1;i&lt;=cnt;i++) id[i]=i;
    cdq(1,cnt);
    for (int i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
    return 0;
}<pre><h2>Problem2687</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define lc (v&lt;&lt;1)
#define rc (v&lt;&lt;1|1)
const int NN=1000005;
int tag[NN*4],cc[NN*4];
int n,ww;
LL ans;
inline void read(int &amp;x)
{
	char ch=getchar();x=0;
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
struct ppt
{
	int l,r;
	friend bool operator &lt;(const ppt &amp;a,const ppt &amp;b)
	{
		if (a.l==b.l) return a.r&gt;b.r;
		return a.l&lt;b.l;
	}
} q[NN];
void build(int v,int l,int r)
{
	tag[v]=-1;
	if (r-l==1)
	{
		cc[v]=0;
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(lc,l,mid);
	build(rc,mid,r);
}
inline void pushdown(int v)
{
	if (tag[v]==-1) return;
	tag[lc]=cc[lc]=tag[v];
	tag[rc]=cc[rc]=tag[v];
	tag[v]=-1;
}
void change(int v,int l,int r,int x)
{
	if (ww&lt;=l)
	{
		tag[v]=cc[v]=x;
		return;
	}
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) change(lc,l,mid,x);
	change(rc,mid,r,x);
}
int find(int v,int l,int r,int i)
{
	if (r-l==1) return cc[v];
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid) return find(lc,l,mid,i);
	else return find(rc,mid,r,i);
}
inline LL calc(int x,int y)
{
	if (x&gt;y) {int t=x;x=y;y=t;}
	if (q[x].r&lt;=q[y].l) return 0;
	return (LL)(q[y].r-q[x].l)*(q[x].r-q[y].l);
}
void DP()
{
	build(1,1,n+1);
	for (int i=1;i&lt;=n;i++)
	{
		int t=find(1,1,n+1,i);
		ans=max(ans,calc(i,t));
		int l=i+1,r=n,res=-1;
		while (l&lt;=r)
		{
			int mid=(l+r)&gt;&gt;1;
			t=find(1,1,n+1,mid);
			if (calc(mid,t)&lt;=calc(mid,i)) res=mid,r=mid-1;
			else l=mid+1;
		}
		if (res==-1) continue;
		ww=res;
		change(1,1,n+1,i);
	}
}
int main()
{
	read(n);
	int i;
	for (i=1;i&lt;=n;i++) read(q[i].l),read(q[i].r);
	sort(q+1,q+n+1);
	int t=1;
	for (i=2;i&lt;=n;i++)
		if (q[i].r&lt;=q[t].r)
			ans=max(ans,(LL)(q[t].r-q[t].l)*(q[i].r-q[i].l));
		else q[++t]=q[i];
	n=t;
	DP();
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem2693</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define mo 100000009
LL f[10000005];
int tes,n,m,cnt;
void shai()
{
	static bool vt[10000005];
	static LL b[10000005];
	static int pr[2000000];
	vt[1]=true;
	f[1]=1;
	int i,j;
	for (i=2;i&lt;=10000000;i++)
	{
		if (!vt[i])
		{
			pr[++cnt]=i;
			b[i]=i;
			f[i]=1-i;
		}
		for (j=1;j&lt;=cnt;j++)
		{
			int x=i*pr[j];
			if (x&gt;10000000) break;
			vt[x]=true;
			if (i%pr[j]==0)
			{
				b[x]=b[i]*pr[j];
				if (b[x]==x) f[x]=1-pr[j];
				else f[x]=f[b[x]]*f[x/b[x]]%mo;
				break;
			}
			else
			{
				b[x]=pr[j];
				f[x]=f[b[x]]*f[i]%mo;
			}
		}
	}
	for (i=1;i&lt;=10000000;i++) f[i]=f[i]*i%mo;
	for (i=2;i&lt;=10000000;i++)
	{
		f[i]+=f[i-1];
		if (f[i]&gt;=mo) f[i]-=mo;
	}
}
LL calc(LL x,LL y)
{
	LL t1=x*(x+1)/2%mo;
	LL t2=y*(y+1)/2%mo;
	return t1*t2%mo;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	shai();
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		if (n&lt;m) {LL t=n;n=m;m=t;}
		LL ans=0;int l,r;
		for (l=1;l&lt;=m;l=r+1)
		{
			r=min(n/(n/l),m/(m/l));
			(ans+=calc(n/l,m/l)*(f[r]-f[l-1]))%=mo;
		}
		if (ans&lt;0) ans+=mo;
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem2697</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;stack&gt;
#include&lt;cstdlib&gt;
#include&lt;string&gt;
#include&lt;bitset&gt;
#define INF 100000000
#define fi first
#define se second
using namespace std;
typedef long long LL;
typedef pair&lt;int,int&gt; pii;
LL c[30005];
int main()
{
    LL ans=0;
    int i,n,k;
  //  freopen(&quot;fly.in&quot;,&quot;r&quot;,stdin);
  //  freopen(&quot;fly.out&quot;,&quot;w&quot;,stdout);
    cin&gt;&gt;n&gt;&gt;k;
    for(i=1;i&lt;=k;i++)
        scanf(&quot;%I64d&quot;,&amp;c[i]);
    sort(c+1,c+1+k);
    for(i=k;i&amp;&amp;(--n)&gt;0;i--)
    {
        ans+=c[i]*n;
        n--;
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
// davidlee1999WTK 2014/
// srO myk Orz
//ios::sync_with_stdio(false);
<pre><h2>Problem2705</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
int n;
int getphi(int n)
{
	//printf(&quot;phi(%d)=&quot;,n);
	LL res=1;
	for (int i=2;i*i&lt;=n;i++)
		if (n%i==0)
		{
			n/=i;
			res=res*(i-1);
			for (;n%i==0;n/=i) res=res*i;
		}
	if (n&gt;1) res=res*(n-1);
	//printf(&quot;%I64d\n&quot;,res);
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	LL ans=0;
	for (int i=1;i*i&lt;=n;i++)
		if (n%i==0)
		{
			ans+=i*getphi(n/i);
			if (i*i!=n) ans+=n/i*getphi(i);
		}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem2707</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
using namespace std;
#define pb push_back
#define DD double
#define NN 11111
#define MM 1011111
const DD eps=1e-7;
int aa[MM][2],bb[MM][2],o1[NN],o2[NN],q[NN],stack[NN],b[NN],du[NN],belong[NN],hao[NN],dd[NN],dfn[NN],low[NN];
int n,m,i,S,T,cnt,top,tot1,tot2,TIME;
DD a[111][111],f[NN],res[111];
bool flag1[NN],flag2[NN],vt[NN];
vector&lt;int&gt; contain[NN];
struct edge {int a,b;} e[MM];
void addedge1(int p,int q) {tot1++;aa[tot1][1]=q;aa[tot1][0]=o1[p];o1[p]=tot1;}
void addedge2(int p,int q) {tot2++;bb[tot2][1]=q;bb[tot2][0]=o2[p];o2[p]=tot2;}
int min(int a,int b) {return a&lt;b?a:b;}
void swap(DD &amp;a,DD &amp;b) {DD t=a;a=b;b=t;}
void checkinf()
{
	int i,head,tail,p,x,y;
	head=0,q[tail=1]=S,flag1[S]=true;
	while (head&lt;tail)
	{
		//printf(&quot;%d\n&quot;,head);
		x=q[++head];
		for (p=o1[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			//if (head==8608) printf(&quot;%d %d %d\n&quot;,y,p,tail);
			if (flag1[y]) continue;
			flag1[y]=true;
			q[++tail]=y;
		}
	}
	for (i=1;i&lt;=m;i++) addedge2(e[i].b,e[i].a);
	head=0,q[tail=1]=T;flag2[T]=true;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o2[x];p;p=bb[p][0])
		{
			y=bb[p][1];
			if (flag2[y]) continue;
			flag2[y]=true;
			q[++tail]=y;
		}
	}
	for (i=1;i&lt;=n;i++)
		if (flag1[i]&amp;&amp;!flag2[i])
		{
			printf(&quot;INF\n&quot;);
			//freopen(&quot;CON&quot;,&quot;r&quot;,stdin);getchar();
			exit(0);
		}
}
void tarjan(int v)
{
	//printf(&quot;%d\n&quot;,v);
	int k,p,y;
	dfn[v]=low[v]=++TIME;
	vt[v]=true;
	stack[++top]=v;
	for (p=o1[v];p;p=aa[p][0])
	{
		y=aa[p][1];
		if (!vt[y])
		{
			tarjan(y);
			low[v]=min(low[v],low[y]);
		}
		else if (!belong[y]) low[v]=min(low[v],dfn[y]);
	}
	if (low[v]==dfn[v])
	{
		cnt++;
		//printf(&quot;%d\n&quot;,cnt);
		do
		{
			k=stack[top--];
			belong[k]=cnt;
			contain[cnt].pb(k);
		} while (k!=v);
	}
}
void tuopu()
{
	int i,x,y,p;
	tot2=0,memset(o2,0,sizeof(o2[0])*(n+100));
	for (i=1;i&lt;=m;i++)
	{
		x=e[i].a,y=e[i].b;
		if (belong[x]==belong[y]) continue;
		addedge2(belong[x],belong[y]);
		dd[belong[y]]++;
	}
	for (top=0,i=1;i&lt;=cnt;i++)
		if (dd[i]==0) stack[++top]=i;
	while (top&gt;0)
	{
		x=stack[top--];
		b[++b[0]]=x;
		for (p=o2[x];p;p=bb[p][0])
		{
			y=bb[p][1];
			dd[y]--;
			if (dd[y]==0) stack[++top]=y;
		}
	}
}
void calc(int t)
{
	//printf(&quot;\n--------- calcing %d ----------------\n&quot;,t);
	int i,num,ss,x,y,j,k,mj,p;
	DD tmp;
	num=0;
	for (i=0,ss=contain[t].size();i&lt;ss;i++)//����
	{
		x=contain[t][i];
		hao[x]=++num;
	}
	//printf(&quot;num=%d\n&quot;,num);
	//printf(&quot;hao: &quot;);for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,hao[i]);printf(&quot;\n&quot;);
	memset(a,0,sizeof(a));
	for (i=0,ss=contain[t].size();i&lt;ss;i++)//��������
	{
		x=contain[t][i];
		a[hao[x]][hao[x]]=1,a[hao[x]][num+1]=1;
		if (x==T)
		{
			a[hao[x]][num+1]=0;
			continue;
		}
		for (p=o1[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (belong[y]!=t) a[hao[x]][num+1]+=f[y]/du[x];
			else a[hao[x]][hao[y]]-=1.0/du[x];
		}
	}
	//for(i=1;i&lt;=num;i++){for(j=1;j&lt;=num+1;j++)printf(&quot;%.3f &quot;,a[i][j]);printf(&quot;\n&quot;);}
	memset(res,0,sizeof(res[0])*(num+10));
	for (i=1;i&lt;num;i++)
	{
		tmp=fabs(a[i][i]),mj=i;
		for (j=i+1;j&lt;=num;j++)
			if (fabs(a[j][i])-tmp&gt;eps) mj=j,tmp=fabs(a[j][i]);
		for (j=i;j&lt;=num+1;j++) swap(a[i][j],a[mj][j]);
		if (fabs(a[i][i])&lt;eps) continue;
		for (j=i+1;j&lt;=num;j++)
		{
			if (fabs(a[i][i])&lt;eps) continue;
			tmp=a[j][i]/a[i][i];
			for (k=i;k&lt;=num+1;k++) a[j][k]=a[i][k]*tmp-a[j][k];
		}
	}
	//printf(&quot;\n&quot;);for(i=1;i&lt;=num;i++){for(j=1;j&lt;=num+1;j++)printf(&quot;%.3f &quot;,a[i][j]);printf(&quot;\n&quot;);}
	//for(i=1;i&lt;=num;i++){for(j=1;j&lt;=num+1;j++)printf(&quot;%.3f &quot;,a[i][j]);printf(&quot;\n&quot;);}
	if (fabs(a[num][num])&gt;eps) res[num]=a[num][num+1]/a[num][num];
	//printf(&quot;%.3f\n&quot;,res[num]);
	for (i=num-1;i;i--)
	{
		tmp=0;
		for (j=i+1;j&lt;=num;j++) tmp+=a[i][j]*res[j];
		if (fabs(a[i][i])&lt;eps) continue;
		res[i]=(a[i][num+1]-tmp)/a[i][i];
	}
	//printf(&quot;res: &quot;);for (i=1;i&lt;=num;i++) printf(&quot;%.3f &quot;,res[i]);printf(&quot;\n&quot;);
	for (i=0,ss=contain[t].size();i&lt;ss;i++)
	{
		x=contain[t][i];
		f[x]=res[hao[x]];
	}
	//printf(&quot;f: &quot;);for (i=1;i&lt;=n;i++) printf(&quot;%.3f &quot;,f[i]);printf(&quot;\n&quot;);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	//freopen(&quot;labyrinth.in&quot;,&quot;r&quot;,stdin);freopen(&quot;labyrinth.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;S,&amp;T);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;e[i].a,&amp;e[i].b);
		addedge1(e[i].a,e[i].b);
		du[e[i].a]++;
	}
	checkinf();
	for (i=1;i&lt;=n;i++)
		if (!vt[i]) tarjan(i);
	//printf(&quot;cnt=%d\n&quot;,cnt);
	//printf(&quot;belong: &quot;);for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,belong[i]);printf(&quot;\n&quot;);
	//printf(&quot;du: &quot;);for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,du[i]);printf(&quot;\n&quot;);
	tuopu();
	//printf(&quot;b: &quot;);for (i=1;i&lt;=b[0];i++) printf(&quot;%d &quot;,b[i]);printf(&quot;\n&quot;);
	for (i=b[0];i;i--) calc(b[i]);
	//printf(&quot;\n\nf: &quot;);for (i=1;i&lt;=n;i++) printf(&quot;%.3f &quot;,f[i]);printf(&quot;\n&quot;);
	printf(&quot;%.3f\n&quot;,f[S]);
	//freopen(&quot;CON&quot;,&quot;r&quot;,stdin);getchar();
	return 0;
}
<pre><h2>Problem2707</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
using namespace std;
#define pb push_back
#define DD double
#define NN 11111
#define MM 1011111
const DD eps=1e-7;
int aa[MM][2],bb[MM][2],o1[NN],o2[NN],q[NN],stack[NN],b[NN],du[NN],belong[NN],hao[NN],dd[NN],dfn[NN],low[NN];
int n,m,i,S,T,cnt,top,tot1,tot2,TIME;
DD a[111][111],f[NN],res[111];
bool flag1[NN],flag2[NN],vt[NN];
vector&lt;int&gt; contain[NN];
struct edge {int a,b;} e[MM];
void addedge1(int p,int q) {tot1++;aa[tot1][1]=q;aa[tot1][0]=o1[p];o1[p]=tot1;}
void addedge2(int p,int q) {tot2++;bb[tot2][1]=q;bb[tot2][0]=o2[p];o2[p]=tot2;}
int min(int a,int b) {return a&lt;b?a:b;}
void swap(DD &amp;a,DD &amp;b) {DD t=a;a=b;b=t;}
void checkinf()
{
	int i,head,tail,p,x,y;
	head=0,q[tail=1]=S,flag1[S]=true;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o1[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (flag1[y]) continue;
			flag1[y]=true;
			q[++tail]=y;
		}
	}
	for (i=1;i&lt;=m;i++) addedge2(e[i].b,e[i].a);
	head=0,q[tail=1]=T;flag2[T]=true;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o2[x];p;p=bb[p][0])
		{
			y=bb[p][1];
			if (flag2[y]) continue;
			flag2[y]=true;
			q[++tail]=y;
		}
	}
	for (i=1;i&lt;=n;i++)
		if (flag1[i]&amp;&amp;!flag2[i])
		{
			printf(&quot;INF\n&quot;);
			exit(0);
		}
}
void tarjan(int v)
{
	int k,p,y;
	dfn[v]=low[v]=++TIME;
	vt[v]=true;
	stack[++top]=v;
	for (p=o1[v];p;p=aa[p][0])
	{
		y=aa[p][1];
		if (!vt[y])
		{
			tarjan(y);
			low[v]=min(low[v],low[y]);
		}
		else if (!belong[y]) low[v]=min(low[v],dfn[y]);
	}
	if (low[v]==dfn[v])
	{
		cnt++;
		do
		{
			k=stack[top--];
			belong[k]=cnt;
			contain[cnt].pb(k);
		} while (k!=v);
	}
}
void tuopu()
{
	int i,x,y,p;
	tot2=0,memset(o2,0,sizeof(o2[0])*(n+100));
	for (i=1;i&lt;=m;i++)
	{
		x=e[i].a,y=e[i].b;
		if (belong[x]==belong[y]) continue;
		addedge2(belong[x],belong[y]);
		dd[belong[y]]++;
	}
	for (top=0,i=1;i&lt;=cnt;i++)
		if (dd[i]==0) stack[++top]=i;
	while (top&gt;0)
	{
		x=stack[top--];
		b[++b[0]]=x;
		for (p=o2[x];p;p=bb[p][0])
		{
			y=bb[p][1];
			dd[y]--;
			if (dd[y]==0) stack[++top]=y;
		}
	}
}
void calc(int t)
{
	int i,num,ss,x,y,j,k,mj,p;
	DD tmp;
	num=0;
	for (i=0,ss=contain[t].size();i&lt;ss;i++)
	{
		x=contain[t][i];
		hao[x]=++num;
	}
	memset(a,0,sizeof(a));
	for (i=0,ss=contain[t].size();i&lt;ss;i++)
	{
		x=contain[t][i];
		a[hao[x]][hao[x]]=1,a[hao[x]][num+1]=1;
		if (x==T)
		{
			a[hao[x]][num+1]=0;
			continue;
		}
		for (p=o1[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (belong[y]!=t) a[hao[x]][num+1]+=f[y]/du[x];
			else a[hao[x]][hao[y]]-=1.0/du[x];
		}
	}
	memset(res,0,sizeof(res[0])*(num+10));
	for (i=1;i&lt;num;i++)
	{
		tmp=fabs(a[i][i]),mj=i;
		for (j=i+1;j&lt;=num;j++)
			if (fabs(a[j][i])-tmp&gt;eps) mj=j,tmp=fabs(a[j][i]);
		for (j=i;j&lt;=num+1;j++) swap(a[i][j],a[mj][j]);
		if (fabs(a[i][i])&lt;eps) continue;
		for (j=i+1;j&lt;=num;j++)
		{
			if (fabs(a[i][i])&lt;eps) continue;
			tmp=a[j][i]/a[i][i];
			for (k=i;k&lt;=num+1;k++) a[j][k]=a[i][k]*tmp-a[j][k];
		}
	}
	if (fabs(a[num][num])&gt;eps) res[num]=a[num][num+1]/a[num][num];
	for (i=num-1;i;i--)
	{
		tmp=0;
		for (j=i+1;j&lt;=num;j++) tmp+=a[i][j]*res[j];
		if (fabs(a[i][i])&lt;eps) continue;
		res[i]=(a[i][num+1]-tmp)/a[i][i];
	}
	for (i=0,ss=contain[t].size();i&lt;ss;i++)
	{
		x=contain[t][i];
		f[x]=res[hao[x]];
	}
}
int main()
{
	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;S,&amp;T);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;e[i].a,&amp;e[i].b);
		addedge1(e[i].a,e[i].b);
		du[e[i].a]++;
	}
	checkinf();
	for (i=1;i&lt;=n;i++)
		if (!vt[i]) tarjan(i);
	tuopu();
	for (i=b[0];i;i--) calc(b[i]);
	printf(&quot;%.3f\n&quot;,f[S]);
	return 0;
}
<pre><h2>Problem2716</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define lowbit(i) ((i)&amp;(-(i)))
#define NN 510000
#define inf 99999999
int ans[NN],xx[NN],yy[NN],c[5000000];
int n,m,mm,i;
struct query
{
	int x,y,id;
	bool kind;
	friend bool operator &lt; (query a,query b) {return a.id&lt;b.id;}
} a[NN*2],aa[NN*2];
int min(int a,int b) {return a&lt;b?a:b;}
int max(int a,int b) {return a&gt;b?a:b;}
void maintain()
{
	sort(a+1,a+m+1);
	for (int i=1;i&lt;=m;i++)
	{
		a[i].y-=mm;
		int t=a[i].x;a[i].x=a[i].y;a[i].y=t;
		a[i].x=-a[i].x;
	}
}
void change(int i,int x)
{
	for (;i&lt;=mm;i+=lowbit(i)) c[i]=max(c[i],x);
}
int getmax(int i)
{
	int res=0;
	for (;i;i-=lowbit(i)) res=max(res,c[i]);
	return res;
}
void clear(int i)
{
	for (;i&lt;=mm;i+=lowbit(i)) c[i]=0;
}
void cdq(int l,int r)
{
	if (l==r) return;
	int i,j,k,mid=(l+r)&gt;&gt;1;
	cdq(l,mid);
	cdq(mid+1,r);
	for (j=l,i=mid+1;i&lt;=r;i++)
	{
		for (;j&lt;=mid&amp;&amp;a[j].x&lt;=a[i].x;j++)
			if (!a[j].kind) change(a[j].y,a[j].x+a[j].y);
		if (a[i].kind)
		{
			int res=getmax(a[i].y);
			if (res) ans[a[i].id]=min(ans[a[i].id],a[i].x+a[i].y-res);
		}
	}
	for (j=l;j&lt;=mid;j++)
		if (!a[j].kind) clear(a[j].y);
	i=l,j=mid+1;
	for (k=l;k&lt;=r;k++)
		if ((i&lt;=mid&amp;&amp;a[i].x&lt;=a[j].x)||j&gt;r) aa[k]=a[i++];
		else aa[k]=a[j++];
	for (k=l;k&lt;=r;k++) a[k]=aa[k];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	//freopen(&quot;2648.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2648.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;xx[i],&amp;yy[i]);
		mm=max(mm,max(xx[i],yy[i]));
		a[i].x=xx[i],a[i].y=yy[i];
		a[i].kind=false,a[i].id=i;
	}
	for (i=n+1;i&lt;=n+m;i++)
	{
		int x;
		ans[i]=inf;
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;a[i].x,&amp;a[i].y);
		mm=max(mm,max(a[i].x,a[i].y));
		a[i].kind=(x==1?false:true);
		a[i].id=i;
	}
	m+=n;
	mm++;
	cdq(1,m);
	maintain();
	cdq(1,m);
	maintain();
	cdq(1,m);
	maintain();
	cdq(1,m);
	sort(a+1,a+m+1);
	for (i=1;i&lt;=m;i++) if (a[i].kind) printf(&quot;%d\n&quot;,ans[a[i].id]);
	return 0;
}<pre><h2>Problem2721</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
#define mo 1000000007
int n,cnt,pr[200000];
void shai()
{
	static bool vt[1000005];
	vt[1]=true;
	for (int i=2;i&lt;=1000000;i++)
	{
		if (!vt[i]) pr[++cnt]=i;
		for (int j=1;j&lt;=cnt;j++)
		{
			int x=i*pr[j];
			if (x&gt;1000000) break;
			vt[x]=true;
			if (i%pr[j]==0) break;
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	shai();
	scanf(&quot;%d&quot;,&amp;n);
	int i;
	static int b[200000];
	for (i=1;i&lt;=cnt;i++)
	{
		int x=n;
		while (x) b[i]+=x/pr[i],x/=pr[i];
	}
	int ans=1;
	for (i=1;i&lt;=cnt;i++)
		ans=(LL)ans*(b[i]&lt;&lt;1|1)%mo;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem2726</h2><pre>#include &lt;cstdio&gt;
#define LL long long
using namespace std;
const int maxn=300100;
LL f[maxn],w[maxn],t[maxn],s,y[maxn];
int n,head,tail,stack[maxn];
double k[maxn];
LL chaji(int a,int b,int c)
{
    return ((w[a]-w[c])*(y[b]-y[c])-(y[a]-y[c])*(w[b]-w[c]));
}
bool work(int a,int b,LL tt)
{
    return ((y[a]-y[b])&gt;tt*(w[b]-w[a]));
}
LL calc(int i,int j)
{
    return f[j]+(t[i]-t[j]+s)*w[j];
}
int find(double tt,int now)
{
    int l=1,r=tail,mid,ans;
    while (l&lt;=r)
    {
        mid=(l+r)&gt;&gt;1;
        if (k[mid]&gt;=tt) ans=stack[mid],l=mid+1; else r=mid-1;
    }
    return ans;
}
int main()
{
    scanf(&quot;%d%lld&quot;,&amp;n,&amp;s);
    int i,j;
    for (i=1;i&lt;=n;i++) scanf(&quot;%lld%lld&quot;,&amp;t[i],&amp;w[i]);
    LL tmp,last=0;
    for (i=n;i;i--) tmp=w[i],w[i]=last,last+=tmp;
    w[0]=last;
    for (i=2;i&lt;=n;i++) t[i]+=t[i-1];
    head=1,tail=2;
    stack[1]=0,stack[2]=1;
    y[0]=f[0]+(s-t[0])*w[0];
    f[1]=f[0]+(t[1]-t[0]+s)*w[0];
    y[1]=f[1]+(s-t[1])*w[1];
    if (n&gt;100000)
    for (i=2;i&lt;=n;i++)
    {
        for (;head&lt;tail&amp;&amp;work(stack[head],stack[head+1],t[i]);head++);
        j=stack[head];
        f[i]=f[j]+(t[i]-t[j]+s)*w[j];
        y[i]=f[i]+(s-t[i])*w[i];
        for (;head&lt;tail&amp;&amp;chaji(i,stack[tail],stack[tail-1])&lt;0;tail--);
        stack[++tail]=i;
    }
    else
    {
        k[1]=9999999*999;
        tail=1;
        for (i=1;i&lt;=n;i++)
        {
            j=find(-t[i],i);
            f[i]=f[j]+(t[i]-t[j]+s)*w[j];
            y[i]=f[i]+(s-t[i])*w[i];
            for (;1&lt;tail&amp;&amp;chaji(i,stack[tail],stack[tail-1])&lt;0;tail--);
            if (w[i]==w[stack[tail]]) continue;
            stack[++tail]=i;
            k[tail]=(y[i]-y[stack[tail-1]])/(double)(w[i]-w[stack[tail-1]]);
        }
    }
    printf(&quot;%lld\n&quot;,f[n]);
}
<pre><h2>Problem2726</h2><pre>#include &lt;cstdio&gt;
#define LL long long
using namespace std;
const int maxn=300100;
LL f[maxn],w[maxn],t[maxn],s,y[maxn];
int n,head,tail,stack[maxn];
double k[maxn];
LL chaji(int a,int b,int c)
{
    return ((w[a]-w[c])*(y[b]-y[c])-(y[a]-y[c])*(w[b]-w[c]));
}
bool work(int a,int b,LL tt)
{
    return ((y[a]-y[b])&gt;tt*(w[b]-w[a]));
}
LL calc(int i,int j)
{
    return f[j]+(t[i]-t[j]+s)*w[j];
}
int find(double tt,int now)
{
    int l=1,r=tail,mid,ans;
    while (l&lt;=r)
    {
        mid=(l+r)&gt;&gt;1;
        if (k[mid]&gt;=tt) ans=stack[mid],l=mid+1; else r=mid-1;
    }
    return ans;
}
int main()
{
    scanf(&quot;%d%lld&quot;,&amp;n,&amp;s);
    int i,j;
    for (i=1;i&lt;=n;i++) scanf(&quot;%lld%lld&quot;,&amp;t[i],&amp;w[i]);
    LL tmp,last=0;
    for (i=n;i;i--) tmp=w[i],w[i]=last,last+=tmp;
    w[0]=last;
    for (i=2;i&lt;=n;i++) t[i]+=t[i-1];
    head=1,tail=2;
    stack[1]=0,stack[2]=1;
    y[0]=f[0]+(s-t[0])*w[0];
    f[1]=f[0]+(t[1]-t[0]+s)*w[0];
    y[1]=f[1]+(s-t[1])*w[1];
   /* if (n&gt;100000)
    for (i=2;i&lt;=n;i++)
    {
        for (;head&lt;tail&amp;&amp;work(stack[head],stack[head+1],t[i]);head++);
        j=stack[head];
        f[i]=f[j]+(t[i]-t[j]+s)*w[j];
        y[i]=f[i]+(s-t[i])*w[i];
        for (;head&lt;tail&amp;&amp;chaji(i,stack[tail],stack[tail-1])&lt;0;tail--);
        stack[++tail]=i;
    }
    else
    {*/
        k[1]=9999999*999;
        tail=1;
        for (i=1;i&lt;=n;i++)
        {
            j=find(-t[i],i);
            f[i]=f[j]+(t[i]-t[j]+s)*w[j];
            y[i]=f[i]+(s-t[i])*w[i];
            for (;1&lt;tail&amp;&amp;chaji(i,stack[tail],stack[tail-1])&lt;0;tail--);
            if (w[i]==w[stack[tail]]) continue;
            stack[++tail]=i;
            k[tail]=(y[i]-y[stack[tail-1]])/(double)(w[i]-w[stack[tail-1]]);
        }
    //}
    printf(&quot;%lld\n&quot;,f[n]);
}
<pre><h2>Problem2726</h2><pre>#include &lt;cstdio&gt;
#define LL long long
using namespace std;
const int maxn=300100;
LL f[maxn],w[maxn],t[maxn],s,y[maxn];
int n,head,tail,stack[maxn];
double k[maxn];
LL chaji(int a,int b,int c)
{
    return ((w[a]-w[c])*(y[b]-y[c])-(y[a]-y[c])*(w[b]-w[c]));
}
int find(double tt,int now)
{
    int l=1,r=tail,mid,ans;
    while (l&lt;=r)
    {
        mid=(l+r)&gt;&gt;1;
        if (k[mid]&gt;=tt) ans=stack[mid],l=mid+1; else r=mid-1;
    }
    return ans;
}
int main()
{
    scanf(&quot;%d%lld&quot;,&amp;n,&amp;s);
    int i,j;
    for (i=1;i&lt;=n;i++) scanf(&quot;%lld%lld&quot;,&amp;t[i],&amp;w[i]);
    LL tmp,last=0;
    for (i=n;i;i--) tmp=w[i],w[i]=last,last+=tmp;
    w[0]=last;
    for (i=2;i&lt;=n;i++) t[i]+=t[i-1];
    head=1,tail=2;
    stack[1]=0,stack[2]=1;
    y[0]=f[0]+(s-t[0])*w[0];
    f[1]=f[0]+(t[1]-t[0]+s)*w[0];
    y[1]=f[1]+(s-t[1])*w[1];
    k[1]=9999999*999;
    tail=1;
    for (i=1;i&lt;=n;i++)
    {
        j=find(-t[i],i);
        f[i]=f[j]+(t[i]-t[j]+s)*w[j];
        y[i]=f[i]+(s-t[i])*w[i];
        for (;1&lt;tail&amp;&amp;chaji(i,stack[tail],stack[tail-1])&lt;0;tail--);
        if (w[i]==w[stack[tail]]) continue;
        stack[++tail]=i;
        k[tail]=(y[i]-y[stack[tail-1]])/(double)(w[i]-w[stack[tail-1]]);
    }
    printf(&quot;%lld\n&quot;,f[n]);
}
<pre><h2>Problem2726</h2><pre>#include &lt;cstdio&gt;
#define LL long long
using namespace std;
const int maxn=300100;
LL f[maxn],w[maxn],t[maxn],s,y[maxn];
int n,head,tail,stack[maxn];
double k[maxn];
LL chaji(int a,int b,int c)
{
    return ((w[a]-w[c])*(y[b]-y[c])-(y[a]-y[c])*(w[b]-w[c]));
}
int find(double tt,int now)
{
    int l=1,r=tail,mid,ans;
    while (l&lt;=r)
    {
        mid=(l+r)&gt;&gt;1;
        if (k[mid]&gt;=tt) ans=stack[mid],l=mid+1; else r=mid-1;
    }
    return ans;
}
int main()
{
    scanf(&quot;%d%lld&quot;,&amp;n,&amp;s);
    int i,j;
    for (i=1;i&lt;=n;i++) scanf(&quot;%lld%lld&quot;,&amp;t[i],&amp;w[i]);
    LL tmp,last=0;
    for (i=n;i;i--) tmp=w[i],w[i]=last,last+=tmp;
    w[0]=last;
    for (i=2;i&lt;=n;i++) t[i]+=t[i-1];
    head=1,tail=2;
    stack[1]=0,stack[2]=1;
    y[0]=(s-t[0])*w[0];
    f[1]=f[0]+(t[1]-t[0]+s)*w[0];
    y[1]=f[1]+(s-t[1])*w[1];
    k[1]=9999999*999;
    tail=1;
    for (i=1;i&lt;=n;i++)
    {
        j=find(-t[i],i);
        f[i]=f[j]+(t[i]-t[j]+s)*w[j];
        y[i]=f[i]+(s-t[i])*w[i];
        for (;1&lt;tail&amp;&amp;chaji(i,stack[tail],stack[tail-1])&lt;0;tail--);
        if (w[i]==w[stack[tail]]) continue;
        stack[++tail]=i;
        k[tail]=(y[i]-y[stack[tail-1]])/(double)(w[i]-w[stack[tail-1]]);
    }
    printf(&quot;%lld\n&quot;,f[n]);
}
<pre><h2>Problem2726</h2><pre>#include &lt;cstdio&gt;
#define LL long long
using namespace std;
const int maxn=300100;
LL f[maxn],w[maxn],t[maxn],s,y[maxn];
int n,head,tail,stack[maxn];
double k[maxn];
LL chaji(int a,int b,int c)
{
    return ((w[a]-w[c])*(y[b]-y[c])-(y[a]-y[c])*(w[b]-w[c]));
}
int find(double tt,int now)
{
    int l=1,r=tail,mid,ans;
    while (l&lt;=r)
    {
        mid=(l+r)&gt;&gt;1;
        if (k[mid]&gt;=tt) ans=stack[mid],l=mid+1; else r=mid-1;
    }
    return ans;
}
int main()
{
    scanf(&quot;%d%lld&quot;,&amp;n,&amp;s);
    int i,j;
    for (i=1;i&lt;=n;i++) scanf(&quot;%lld%lld&quot;,&amp;t[i],&amp;w[i]);
    LL tmp,last=0;
    for (i=n;i;i--) tmp=w[i],w[i]=last,last+=tmp;
    w[0]=last;
    for (i=2;i&lt;=n;i++) t[i]+=t[i-1];
    head=1,tail=2;
    stack[1]=0,stack[2]=1;
    y[0]=s*w[0];
    f[1]=f[0]+(t[1]-t[0]+s)*w[0];
    y[1]=f[1]+(s-t[1])*w[1];
    k[1]=9999999*999;
    tail=1;
    for (i=1;i&lt;=n;i++)
    {
        j=find(-t[i],i);
        f[i]=f[j]+(t[i]-t[j]+s)*w[j];
        y[i]=f[i]+(s-t[i])*w[i];
        for (;1&lt;tail&amp;&amp;chaji(i,stack[tail],stack[tail-1])&lt;0;tail--);
        if (w[i]==w[stack[tail]]) continue;
        stack[++tail]=i;
        k[tail]=(y[i]-y[stack[tail-1]])/(double)(w[i]-w[stack[tail-1]]);
    }
    printf(&quot;%lld\n&quot;,f[n]);
}
<pre><h2>Problem2726</h2><pre>#include &lt;cstdio&gt;
#define LL long long
using namespace std;
const int maxn=300100;
LL f[maxn],w[maxn],t[maxn],s,y[maxn];
int n,head,tail,stack[maxn];
double k[maxn];
LL chaji(int a,int b,int c)
{
    return ((w[a]-w[c])*(y[b]-y[c])-(y[a]-y[c])*(w[b]-w[c]));
}
int find(double tt,int now)
{
    int l=1,r=tail,mid,ans;
    while (l&lt;=r)
    {
        mid=(l+r)&gt;&gt;1;
        if (k[mid]&gt;=tt) ans=stack[mid],l=mid+1; else r=mid-1;
    }
    return ans;
}
int main()
{
    scanf(&quot;%d%lld&quot;,&amp;n,&amp;s);
    int i,j;
    for (i=1;i&lt;=n;i++) scanf(&quot;%lld%lld&quot;,&amp;t[i],&amp;w[i]);
    LL tmp,last=0;
    for (i=n;i;i--) tmp=w[i],w[i]=last,last+=tmp;
    w[0]=last;
    for (i=2;i&lt;=n;i++) t[i]+=t[i-1];
    head=1,tail=2;
    stack[1]=0,stack[2]=1;
    y[0]=s*w[0];
    f[1]=f[0]+(t[1]+s)*w[0];
    y[1]=f[1]+(s-t[1])*w[1];
    k[1]=9999999*999;
    tail=1;
    for (i=1;i&lt;=n;i++)
    {
        j=find(-t[i],i);
        f[i]=f[j]+(t[i]-t[j]+s)*w[j];
        y[i]=f[i]+(s-t[i])*w[i];
        for (;1&lt;tail&amp;&amp;chaji(i,stack[tail],stack[tail-1])&lt;0;tail--);
        if (w[i]==w[stack[tail]]) continue;
        stack[++tail]=i;
        k[tail]=(y[i]-y[stack[tail-1]])/(double)(w[i]-w[stack[tail-1]]);
    }
    printf(&quot;%lld\n&quot;,f[n]);
}
<pre><h2>Problem2726</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;iostream&gt;
using namespace std;
#define LL long long
#define sm 1e-7
LL n,i,j,head,tail;
LL T[1100000],F[1100000],sumT[1100000],sumF[1100000],f[1100000],q[1100000];
LL S;
bool flag;
double K[1100000];
LL min(LL a,LL b) {return a&lt;b?a:b;}
LL fenzi(LL i) {return f[i]-S*sumF[i]+sumT[i]*(sumF[i]-sumF[n]);}
int find(LL x)
{
	//for (int ii=1;ii&lt;=tail;ii++) printf(&quot;%.3f &quot;,K[ii]);
	int res=tail;
	int l=1,r=tail;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (K[mid]-x&lt;sm) res=mid,l=mid+1;
		else r=mid-1;
	}
	return q[res];
}
void doit()
{
	K[1]=-99999*99999;
	q[++tail]=0;
	for (i=1;i&lt;=n;i++)
	{
		//for (int ii=1;ii&lt;=tail;ii++) printf(&quot;%.3f &quot;,K[ii]);
		//cout&lt;&lt;0&lt;&lt;endl;
		if (i==4)
		{
		//	printf(&quot;sumT:  %lld\n&quot;,sumT[i]);
			++i;
			--i;
		}
		//printf(&quot;sumT:  %lld\n&quot;,sumT[i]);
		j=find(sumT[i]);
		//printf(&quot;%lld\n&quot;,j);
		f[i]=f[j]+(S+sumT[i]-sumT[j])*(sumF[n]-sumF[j]);
	//	printf(&quot;%lld\n&quot;,f[i]);
		int k=q[tail],j=q[tail-1];
		while (tail&gt;head+1&amp;&amp;(fenzi(i)-fenzi(k))*(sumF[k]-sumF[j])&lt;=(fenzi(k)-fenzi(j))*(sumF[i]-sumF[k]))
		{
			--tail;
			k=q[tail],j=q[tail-1];
		}
		if (sumF[q[tail]]==sumF[i]) continue;
		q[++tail]=i;
		K[tail]=(fenzi(q[tail])-fenzi(q[tail-1]))/(double)(sumF[q[tail]]-sumF[q[tail-1]]);
		//for (int ii=1;ii&lt;=tail;ii++) printf(&quot;%.3f &quot;,K[ii]);printf(&quot;\n&quot;);
		//printf(&quot;\n&quot;);
		//for (int ii=1;ii&lt;=tail;ii++) printf(&quot;%.3f &quot;,K[ii]);printf(&quot;\n&quot;);
	}
	printf(&quot;%lld\n&quot;,f[n]);
	exit(0);
}
int main()
{
	//freopen(&quot;2726.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2726.out&quot;,&quot;w&quot;,stdout);
	//freopen(&quot;2726.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2726.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld%lld&quot;,&amp;n,&amp;S);
	sumF[0]=sumT[0]=0;
	flag=0;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%lld%lld&quot;,&amp;T[i],&amp;F[i]),sumT[i]=sumT[i-1]+T[i],sumF[i]=sumF[i-1]+F[i];
		if (T[i]&lt;0) flag=1;
	}
	memset(f,127,sizeof(f));
	f[0]=0;
	if (flag) doit();
	//doit();
	/*
	for (i=1;i&lt;=n;i++)
		for (j=0;j&lt;i;j++)
			f[i]=min(f[i],f[j]+(S+sumT[i]-sumT[j])*(sumF[n]-sumF[j]));
	*/
	q[tail=1]=0;
	for (i=1;i&lt;=n;i++)
	{
		double sss;
		LL k=q[head+2],j=q[head+1];
		//printf(&quot;%.3f\n&quot;,(fenzi(k)-fenzi(j))/(double)(sumF[k]-sumF[j]));
		while (tail&gt;head+1&amp;&amp;fenzi(k)-fenzi(j)&lt;=sumT[i]*(sumF[k]-sumF[j]))
		{
			++head;
			k=q[head+2],j=q[head+1];
			sss=(fenzi(k)-fenzi(j))/(double)(sumF[k]-sumF[j]);
		}
		//printf(&quot;%lld\n&quot;,sumT[i]);
		f[i]=f[j]+(S+sumT[i]-sumT[j])*(sumF[n]-sumF[j]);
		//printf(&quot;%lld\n&quot;,f[i]);
		k=q[tail],j=q[tail-1];
		//printf(&quot;%.3f\n&quot;,(fenzi(k)-fenzi(j))/(double)(sumF[k]-sumF[j]));
		while (tail&gt;head+1&amp;&amp;(fenzi(i)-fenzi(k))*(sumF[k]-sumF[j])&lt;=(fenzi(k)-fenzi(j))*(sumF[i]-sumF[k]))
		{
			--tail;
			k=q[tail],j=q[tail-1];
		}
		q[++tail]=i;
	}
	printf(&quot;%lld\n&quot;,f[n]);
	return 0;
}
<pre><h2>Problem2726</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;iostream&gt;
using namespace std;
#define LL long long
#define sm 1e-7
LL n,i,j,head,tail;
LL T[1100000],F[1100000],sumT[1100000],sumF[1100000],f[1100000],q[1100000];
LL S;
bool flag;
double K[1100000];
LL min(LL a,LL b) {return a&lt;b?a:b;}
LL fenzi(LL i) {return f[i]-S*sumF[i]+sumT[i]*(sumF[i]-sumF[n]);}
int find(LL x)
{
	//for (int ii=1;ii&lt;=tail;ii++) printf(&quot;%.3f &quot;,K[ii]);
	int res=tail;
	int l=1,r=tail;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (K[mid]-x&lt;sm) res=mid,l=mid+1;
		else r=mid-1;
	}
	return q[res];
}
void doit()
{
	K[1]=-99999*99999;
	q[++tail]=0;
	for (i=1;i&lt;=n;i++)
	{
		//for (int ii=1;ii&lt;=tail;ii++) printf(&quot;%.3f &quot;,K[ii]);
		//cout&lt;&lt;0&lt;&lt;endl;
		if (i==4)
		{
		//	printf(&quot;sumT:  %lld\n&quot;,sumT[i]);
			++i;
			--i;
		}
		//printf(&quot;sumT:  %lld\n&quot;,sumT[i]);
		j=find(sumT[i]);
		//printf(&quot;%lld\n&quot;,j);
		f[i]=f[j]+(S+sumT[i]-sumT[j])*(sumF[n]-sumF[j]);
	//	printf(&quot;%lld\n&quot;,f[i]);
		int k=q[tail],j=q[tail-1];
		while (tail&gt;head+1&amp;&amp;(fenzi(i)-fenzi(k))*(sumF[k]-sumF[j])&lt;=(fenzi(k)-fenzi(j))*(sumF[i]-sumF[k]))
		{
			--tail;
			k=q[tail],j=q[tail-1];
		}
		if (sumF[q[tail]]==sumF[i]) continue;
		q[++tail]=i;
		K[tail]=(fenzi(q[tail])-fenzi(q[tail-1]))/(double)(sumF[q[tail]]-sumF[q[tail-1]]);
		//for (int ii=1;ii&lt;=tail;ii++) printf(&quot;%.3f &quot;,K[ii]);printf(&quot;\n&quot;);
		//printf(&quot;\n&quot;);
		//for (int ii=1;ii&lt;=tail;ii++) printf(&quot;%.3f &quot;,K[ii]);printf(&quot;\n&quot;);
	}
	printf(&quot;%lld\n&quot;,f[n]);
	exit(0);
}
int main()
{
	//freopen(&quot;2726.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2726.out&quot;,&quot;w&quot;,stdout);
	//freopen(&quot;2726.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2726.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld%lld&quot;,&amp;n,&amp;S);
	sumF[0]=sumT[0]=0;
	flag=0;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%lld%lld&quot;,&amp;T[i],&amp;F[i]),sumT[i]=sumT[i-1]+T[i],sumF[i]=sumF[i-1]+F[i];
		if (T[i]&lt;0) flag=1;
	}
	memset(f,127,sizeof(f));
	f[0]=0;
	if (flag) doit();
	doit();
	/*
	for (i=1;i&lt;=n;i++)
		for (j=0;j&lt;i;j++)
			f[i]=min(f[i],f[j]+(S+sumT[i]-sumT[j])*(sumF[n]-sumF[j]));
	*/
	q[tail=1]=0;
	for (i=1;i&lt;=n;i++)
	{
		double sss;
		LL k=q[head+2],j=q[head+1];
		//printf(&quot;%.3f\n&quot;,(fenzi(k)-fenzi(j))/(double)(sumF[k]-sumF[j]));
		while (tail&gt;head+1&amp;&amp;fenzi(k)-fenzi(j)&lt;=sumT[i]*(sumF[k]-sumF[j]))
		{
			++head;
			k=q[head+2],j=q[head+1];
			sss=(fenzi(k)-fenzi(j))/(double)(sumF[k]-sumF[j]);
		}
		//printf(&quot;%lld\n&quot;,sumT[i]);
		f[i]=f[j]+(S+sumT[i]-sumT[j])*(sumF[n]-sumF[j]);
		//printf(&quot;%lld\n&quot;,f[i]);
		k=q[tail],j=q[tail-1];
		//printf(&quot;%.3f\n&quot;,(fenzi(k)-fenzi(j))/(double)(sumF[k]-sumF[j]));
		while (tail&gt;head+1&amp;&amp;(fenzi(i)-fenzi(k))*(sumF[k]-sumF[j])&lt;=(fenzi(k)-fenzi(j))*(sumF[i]-sumF[k]))
		{
			--tail;
			k=q[tail],j=q[tail-1];
		}
		q[++tail]=i;
	}
	printf(&quot;%lld\n&quot;,f[n]);
	return 0;
}
<pre><h2>Problem2727</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define h(i,j) (((i)-1)*m+(j))
#define mo 1000000009
#define NN 1501111
#define LL long long
#define ln printf(&quot;\n&quot;)
int down[NN],C[NN];
int n,m,num;
bool is[NN],qwe=false;
struct BIT
{
	LL c[10011];
	int b[10011];
	void change(int i,LL x)
	{
		b[++b[0]]=i;
		for (;i&lt;=m;i+=(i&amp;-i)) c[i]+=x;
	}
	LL getsum(int i)
	{
		LL res=0;
		for (;i;i-=(i&amp;-i)) res+=c[i];
		return res%mo;
	}
	void clear()
	{
		for (int i=1;i&lt;=b[0];i++)
			for (int j=b[i];j&lt;=m;j+=(j&amp;-j)) c[j]=0;
		b[0]=0;
	}
} c1,c2,c3;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	scanf(&quot;%d&quot;,&amp;num);
	int i,j,x,y;
	for (i=1;i&lt;=num;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		is[h(x,y)]=true;
	}
	for (i=1;i&lt;=n;i++)
	{
		int now=0;
		for (j=1;j&lt;=m;j++)
		{
			int t=h(i,j);
			if (is[t]) now=j;
			else C[t]=j-now-1;
		}
		now=m+1;
		for (j=m;j&gt;0;j--)
		{
			int t=h(i,j);
			if (is[t]) now=j;
			else if (now-j-1&lt;C[t]) C[t]=now-j-1;
		}
	}
	for (i=n;i&gt;0;i--)
		for (j=1;j&lt;=m;j++)
		{
			int t=h(i,j);
			if (is[t]) down[t]=-1;
			else if (i==n) down[t]=0;
			else down[t]=down[h(i+1,j)]+1;
		}
	//printf(&quot;C:\n&quot;);for(int i=1;i&lt;=n;i++){for(int j=1;j&lt;=m;j++)printf(&quot;%d &quot;,C[h(i,j)]);ln;}ln;
	//printf(&quot;down:\n&quot;);for(int i=1;i&lt;=n;i++){for(int j=1;j&lt;=m;j++)printf(&quot;%d &quot;,down[h(i,j)]);ln;}ln;
	LL ans=0;
	for (j=1;j&lt;=m;j++)
	{
		c1.clear(),c2.clear(),c3.clear();
		if (j==5) qwe=true;
		int top=0;
		for (i=1;i&lt;=n;i++)
		{
			int t=h(i,j);
			if (is[t])
			{
				top=i;
				c1.clear(),c2.clear(),c3.clear();
				//if (qwe) printf(&quot;wrong\n&quot;);
				continue;
			}
			//if(qwe)printf(&quot;getsum %d: %lld %lld %lld\n&quot;,i,c1.getsum(C[t]),c2.getsum(C[t]),c3.getsum(m)-c3.getsum(C[t]));
			ans+=c1.getsum(C[t])*down[t];
			ans+=c2.getsum(C[t])*C[t]*down[t];
			ans+=(c3.getsum(m)-c3.getsum(C[t]))*C[t]*(C[t]-1)/2*down[t];
			//if (qwe)printf(&quot;%lld\n&quot;,c3.getsum(m));if (qwe)printf(&quot;ans=%lld\n&quot;,ans);
			if (ans&gt;mo) ans%=mo;
			if (i==1) continue;
			t=h(i-1,j);
			if (!is[t]&amp;&amp;C[t])
			{
				//if(qwe)printf(&quot;change %d:  %d %d %d\n&quot;,i,(-C[t]*C[t]-C[t])/2*(i-1-top-1),C[t]*(i-1-top-1),i-1-top-1);
				c1.change(C[t],(LL)(-C[t]*C[t]-C[t])/2*(i-1-top-1));
				c2.change(C[t],C[t]*(i-1-top-1));
				c3.change(C[t],i-1-top-1);
			}
		}
		qwe=false;
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2727</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define h(i,j) (((i)-1)*m+(j))
#define mo 1000000009
#define NN 1301111
#define LL long long
int down[NN],C[NN];
int n,m,num;
bool is[NN];
struct BIT
{
	LL c[10011];
	int b[10011];
	void change(int i,LL x)
	{
		b[++b[0]]=i;
		for (;i&lt;=m;i+=(i&amp;-i)) c[i]+=x;
	}
	LL getsum(int i)
	{
		LL res=0;
		for (;i;i-=(i&amp;-i)) res+=c[i];
		return res%mo;
	}
	void clear()
	{
		for (int i=1;i&lt;=b[0];i++)
			for (int j=b[i];j&lt;=m;j+=(j&amp;-j)) c[j]=0;
		b[0]=0;
	}
} c1,c2,c3;
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	scanf(&quot;%d&quot;,&amp;num);
	int i,j,x,y;
	for (i=1;i&lt;=num;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		is[h(x,y)]=true;
	}
	for (i=1;i&lt;=n;i++)
	{
		int now=0;
		for (j=1;j&lt;=m;j++)
		{
			int t=h(i,j);
			if (is[t]) now=j;
			else C[t]=j-now-1;
		}
		now=m+1;
		for (j=m;j&gt;0;j--)
		{
			int t=h(i,j);
			if (is[t]) now=j;
			else if (now-j-1&lt;C[t]) C[t]=now-j-1;
		}
	}
	for (i=n;i&gt;0;i--)
		for (j=1;j&lt;=m;j++)
		{
			int t=h(i,j);
			if (is[t]) down[t]=-1;
			else if (i==n) down[t]=0;
			else down[t]=down[h(i+1,j)]+1;
		}
	LL ans=0;
	for (j=1;j&lt;=m;j++)
	{
		c1.clear(),c2.clear(),c3.clear();
		int top=0;
		for (i=1;i&lt;=n;i++)
		{
			int t=h(i,j);
			if (is[t])
			{
				top=i;
				c1.clear(),c2.clear(),c3.clear();
				continue;
			}
			ans+=c1.getsum(C[t])*down[t];
			ans+=c2.getsum(C[t])*C[t]*down[t];
			ans+=(c3.getsum(m)-c3.getsum(C[t]))*C[t]*(C[t]-1)/2*down[t];
			if (ans&gt;mo) ans%=mo;
			if (i==1) continue;
			t=h(i-1,j);
			if (!is[t]&amp;&amp;C[t])
			{
				c1.change(C[t],(LL)(-C[t]*C[t]-C[t])/2*(i-1-top-1));
				c2.change(C[t],C[t]*(i-1-top-1));
				c3.change(C[t],i-1-top-1);
			}
		}
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2727</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define h(i,j) (((i)-1)*m+(j))
#define mo 1000000009
#define NN 1201111
#define LL long long
int down[NN],C[NN],up[NN];
int n,m,num;
bool is[NN];
struct BIT
{
	LL c[10011];
	int b[10011];
	void change(int i,LL x)
	{
		b[++b[0]]=i;
		for (;i&lt;=m;i+=(i&amp;-i)) c[i]+=x;
	}
	LL getsum(int i)
	{
		LL res=0;
		for (;i;i-=(i&amp;-i)) res+=c[i];
		return res%mo;
	}
	void clear()
	{
		for (int i=1;i&lt;=b[0];i++)
			for (int j=b[i];j&lt;=m;j+=(j&amp;-j)) c[j]=0;
		b[0]=0;
	}
} c1,c2,c3;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	scanf(&quot;%d&quot;,&amp;num);
	int i,j,x,y;
	for (i=1;i&lt;=num;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		is[h(x,y)]=true;
	}
	for (i=1;i&lt;=n;i++)
	{
		int now=0;
		for (j=1;j&lt;=m;j++)
		{
			int t=h(i,j);
			if (is[t]) now=j,up[t]=-1;
			else
			{
				C[t]=j-now-1;
				if (i==1) up[t]=0;
				else up[t]=up[h(i-1,j)]+1;
			}
		}
		now=m+1;
		for (j=m;j&gt;0;j--)
		{
			int t=h(i,j);
			if (is[t]) now=j;
			else if (now-j-1&lt;C[t]) C[t]=now-j-1;
		}
	}
	for (i=n;i&gt;0;i--)
		for (j=1;j&lt;=m;j++)
		{
			int t=h(i,j);
			if (is[t]) down[t]=-1;
			else if (i==n) down[t]=0;
			else down[t]=down[h(i+1,j)]+1;
		}
	LL ans=0;
	for (j=1;j&lt;=m;j++)
	{
		c1.clear(),c2.clear(),c3.clear();
		int top=0;
		for (i=1;i&lt;=n;i++)
		{
			int t=h(i,j);
			if (is[t])
			{
				top=i;
				c1.clear(),c2.clear(),c3.clear();
				continue;
			}
			ans+=c1.getsum(C[t])*down[t];
			ans+=c2.getsum(C[t])*C[t]*down[t];
			ans+=(c3.getsum(m)-c3.getsum(C[t]))*C[t]*(C[t]-1)/2*down[t];
			if (ans&gt;mo) ans%=mo;
			if (i==1) continue;
			t=h(i-1,j);
			if (!is[t]&amp;&amp;C[t])
			{
				c1.change(C[t],(LL)(-C[t]*C[t]-C[t])/2*up[t]);
				c2.change(C[t],C[t]*up[t]);
				c3.change(C[t],up[t]);
			}
		}
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2728</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
#define LL long long
LL er[63],a[1005],b[63],L,R;
int n,K,cnt;
bool vt[63];
LL calc(LL n)
{
	if (n==-1) return -1;
	LL now=0,res=0;
	for (int i=cnt;i;i--)
		if ((now|b[i])&lt;=n)
			now|=b[i],res+=er[i-1];
	return res;
}
int main()
{
	int i,j;
	scanf(&quot;%d%d%lld%lld&quot;,&amp;n,&amp;K,&amp;L,&amp;R);
	for (i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]);
	for (er[0]=1,i=1;i&lt;=61;i++) er[i]=er[i-1]&lt;&lt;1;
	LL all=er[K]-1;
	for (i=1;i&lt;=K;i++) if (!vt[i])
	{
		LL tmp=all;
		for (j=1;j&lt;=n;j++)
			if (a[j]&amp;er[i-1]) tmp&amp;=a[j]&amp;all;
			else tmp&amp;=(~a[j])&amp;all;
		for (j=1;j&lt;=K;j++)
			if (tmp&amp;er[j-1]) vt[j]=true;
		b[++cnt]=tmp;
	}
	sort(b+1,b+cnt+1);
	printf(&quot;%lld\n&quot;,calc(R)-calc(L-1));
	return 0;
}
<pre><h2>Problem2729</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int n,m;
struct number
{
	int m[20001],l;
	void clear() {memset(m,0,sizeof(m));l=1;}
	void out()
	{
		for (int i=l;i;i--) printf(&quot;%d&quot;,m[i]);
		printf(&quot;\n&quot;);
	}
	friend number operator +(number a,number b)
	{
		int i;
		if (a.l&lt;b.l) {number t=a;a=b;b=t;}
		for (i=1;i&lt;=b.l;i++) a.m[i]+=b.m[i];
		for (i=1;i&lt;a.l;i++) if (a.m[i]&gt;9)
		{
			a.m[i+1]+=a.m[i]/10;
			a.m[i]%=10;
		}		
		while (a.m[a.l]&gt;9)
		{
			a.m[a.l+1]=a.m[a.l]/10;
			a.m[a.l]%=10;
			a.l++;
		}
		return a;
	}
	friend number operator *(number a,int x)
	{
		int i;
		for (i=1;i&lt;=a.l;i++) a.m[i]*=x;
		for (i=1;i&lt;a.l;i++) if (a.m[i]&gt;9)
		{
			a.m[i+1]+=a.m[i]/10;
			a.m[i]%=10;
		}		
		while (a.m[a.l]&gt;9)
		{
			a.m[a.l+1]=a.m[a.l]/10;
			a.m[a.l]%=10;
			a.l++;
		}
		return a;
	}
	friend number operator *(number a,number b)
	{
		int i,j;
		number c;c.clear();
		for (i=1;i&lt;=a.l;i++)
			for (j=1;j&lt;=b.l;j++)
				c.m[i+j-1]+=a.m[i]*b.m[j];
		c.l=a.l+b.l-1;
		for (i=1;i&lt;c.l;i++) if (c.m[i]&gt;9)
		{
			c.m[i+1]+=c.m[i]/10;
			c.m[i]%=10;
		}		
		while (c.m[a.l]&gt;9)
		{
			c.m[c.l+1]=c.m[c.l]/10;
			c.m[c.l]%=10;
			c.l++;
		}
		while (c.m[c.l]==0&amp;&amp;c.l&gt;1) c.l--;
		return c;
	}
};
number jiecheng(int t)
{
	number x;x.clear();
	x.m[1]=1;
	for (int i=1;i&lt;=t;i++) x=x*i;
	return x;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	if (n==0||n+2&lt;m-1) {printf(&quot;0\n&quot;);return 0;}
	int i;
	//printf(&quot;%d\n&quot;,jiecheng(m).l);
	number x=jiecheng(n)*m;
	x=x*2*(n+1);
	for (i=n-m+4;i&lt;=n+2;i++) x=x*i;
	number y=jiecheng(n);
	y=y*n*(n+1);
	for (i=n+3-m+1;i&lt;=n+3;i++) y=y*i;
	x=x+y;
	x.out();
	return 0;
}
<pre><h2>Problem2730</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 1100
int o[NN],low[NN],dfn[NN],fa[NN],aa[NN*10][2],vvv[NN];
int n,m,ans1,dian,num,TIME,tot;
long long ans2;
bool vt[NN],flag[NN];
int min(int a,int b) {return a&lt;b?a:b;}
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
void dfs(int v)
{
	vt[v]=true;
	dfn[v]=low[v]=++TIME;
	int tmp=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		if (vt[y]) low[v]=min(low[v],dfn[y]);
		else
		{
			fa[y]=v;
			dfs(y);
			low[v]=min(low[v],low[y]);
			if (low[y]&gt;=dfn[v]) ++tmp;
		}
	}
	if ((v==1&amp;&amp;tmp&gt;1)||(v!=1&amp;&amp;tmp&gt;0)) flag[v]=true;
}
void dfs2(int v)
{
	vt[v]=true;
	++dian;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (vt[y]) continue;
		if (flag[y])
		{
			if (vvv[y]==TIME) continue;
			vvv[y]=TIME;
			num++;
			dian++;
			continue;
		}
		dfs2(y);
	}
}
void clear()
{
	memset(o,0,sizeof(o));
	tot=1;
	memset(vvv,0,sizeof(vvv));
	memset(vt,0,sizeof(vt));
	memset(flag,0,sizeof(flag));
	memset(fa,0,sizeof(fa));
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (int tc=0;;)
	{
		//printf(&quot;\n-------------------------------------------\n&quot;);
		scanf(&quot;%d&quot;,&amp;m);
		if (m==0) break;
		clear();
		n=0;
		int i,x,y;
		for (i=1;i&lt;=m;i++)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			if (x&gt;n) n=x;
			if (y&gt;n) n=y;
			addedge(x,y);
			addedge(y,x);
		}
		for (i=1;i&lt;=n;i++) if (!vt[i]) dfs(i);
		//for (i=1;i&lt;=n;i++) if (flag[i]) printf(&quot;%d\n&quot;,i);
		int tmp=0;
		for (i=1;i&lt;=n;i++) if (flag[i]) ++tmp;
		if (tmp==0) {printf(&quot;Case %d: %d %lld\n&quot;,++tc,2,(long long)n*(n-1)/2);continue;}
		ans1=0,ans2=1;
		TIME=0;
		memset(vt,0,sizeof(vt));
		for (i=1;i&lt;=n;i++)
			if (!vt[i]&amp;&amp;!flag[i])
			{
				++TIME;
				dian=0;
				num=0;
				dfs2(i);
				if (num==2) continue;
				ans1++;
				ans2*=dian-1;
			}
		printf(&quot;Case %d: %d %lld\n&quot;,++tc,ans1,ans2);
	}
	return 0;
}
<pre><h2>Problem2731</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
int b[10000000];
int n,cnt,num;
bool vt[4000005];
struct info
{
	int x,y,d;
} a[10011];
struct ppt
{
	int w;
	bool kind;
	ppt(int a=0,bool b=0) {w=a,kind=b;}
	friend bool operator &lt;(ppt a,ppt b) {return a.w&lt;b.w;}
} c[20011];
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	int i,j;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;a[i].x,&amp;a[i].y,&amp;a[i].d);
		a[i].x&lt;&lt;=1,a[i].y&lt;&lt;=1,a[i].d&lt;&lt;=1;
	}
	for (i=1;i&lt;=n;i++)
	{
		b[++cnt]=a[i].x;vt[a[i].x]=true;
		b[++cnt]=a[i].x+a[i].d;vt[a[i].x+a[i].d]=true;
	}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++) if (i!=j)
		{
			int tmp=a[i].x+a[i].y+a[i].d;
			int x=tmp-a[j].y;
			if (a[j].x&lt;x&amp;&amp;x&lt;a[j].x+a[j].d&amp;&amp;!vt[x]) b[++cnt]=x;
		}
	sort(b+1,b+cnt+1);
	int t=1;
	for (i=2;i&lt;=cnt;i++)
		if (b[i]!=b[t]) b[++t]=b[i];
	cnt=t;
	long long ans=0;
	for (int ii=1;ii&lt;cnt;ii++)
	{
		int xx=(b[ii+1]+b[ii])&gt;&gt;1;
		num=0;
		for (i=1;i&lt;=n;i++)
			if (a[i].x&lt;xx&amp;&amp;xx&lt;a[i].x+a[i].d)
			{
				c[++num]=ppt(a[i].y,true);
				c[++num]=ppt(a[i].y+a[i].d-(xx-a[i].x),false);
			}
		sort(c+1,c+num+1);
		int t=0,res=0;
		for (i=1;i&lt;=num;i++)
		{
			if (c[i].kind)
			{
				t++;
				if (t==1) res-=c[i].w;
			}
			else
			{
				t--;
				if (t==0) res+=c[i].w;
			}
		}
		ans+=(long long)(b[ii+1]-b[ii])*res;
	}
	printf(&quot;%.1f\n&quot;,ans*1.0/4);
	return 0;
}
<pre><h2>Problem2731</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
int b[5000005];
int n,cnt,num;
bool vt[4000005];
struct info
{
	int x,y,d;
} a[10011];
struct ppt
{
	int w;
	bool kind;
	ppt(int a=0,bool b=0) {w=a,kind=b;}
	friend bool operator &lt;(ppt a,ppt b) {return a.w&lt;b.w;}
} c[20011];
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	int i,j;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;a[i].x,&amp;a[i].y,&amp;a[i].d);
		a[i].x&lt;&lt;=1,a[i].y&lt;&lt;=1,a[i].d&lt;&lt;=1;
	}
	for (i=1;i&lt;=n;i++)
	{
		b[++cnt]=a[i].x;vt[a[i].x]=true;
		b[++cnt]=a[i].x+a[i].d;vt[a[i].x+a[i].d]=true;
	}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++) if (i!=j)
		{
			int tmp=a[i].x+a[i].y+a[i].d;
			int x=tmp-a[j].y;
			if (a[j].x&lt;x&amp;&amp;x&lt;a[j].x+a[j].d&amp;&amp;!vt[x]) b[++cnt]=x,vt[x]=true;
		}
	sort(b+1,b+cnt+1);
	int t=1;
	for (i=2;i&lt;=cnt;i++)
		if (b[i]!=b[t]) b[++t]=b[i];
	cnt=t;
	long long ans=0;
	for (int ii=1;ii&lt;cnt;ii++)
	{
		int xx=(b[ii+1]+b[ii])&gt;&gt;1;
		num=0;
		for (i=1;i&lt;=n;i++)
			if (a[i].x&lt;xx&amp;&amp;xx&lt;a[i].x+a[i].d)
			{
				c[++num]=ppt(a[i].y,true);
				c[++num]=ppt(a[i].y+a[i].d-(xx-a[i].x),false);
			}
		sort(c+1,c+num+1);
		int t=0,res=0;
		for (i=1;i&lt;=num;i++)
		{
			if (c[i].kind)
			{
				t++;
				if (t==1) res-=c[i].w;
			}
			else
			{
				t--;
				if (t==0) res+=c[i].w;
			}
		}
		ans+=(long long)(b[ii+1]-b[ii])*res;
	}
	printf(&quot;%.1f\n&quot;,ans*1.0/4);
	return 0;
}
<pre><h2>Problem2732</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 99999999
#define NN 210000
#define LD long double
#define DD double
int cc[2],n,now;
const LD eps=1e-18;
struct point
{
	LD x,y;
	friend point operator -(point a,point b) {a.x-=b.x;a.y-=b.y;return a;}
	friend point operator +(point a,point b) {a.x+=b.x,a.y+=b.y;return a;}
	friend point operator *(LD t,point a) {a.x*=t,a.y*=t;return a;}
};
point a[2][NN*4];
LD det(point a,point b) {return a.x*b.y-b.x*a.y;}
bool linesegxj(point P,point v,point A,point B)
{
	return det(A-P,v)*det(B-P,v)&lt;eps;
}
point linejd(point P,point v,point Q,point w)
{
	point u=P-Q;
	LD t=det(w,u)/det(v,w);
	return P+t*v;
}
void work(point P,point v)
{
	cc[now]++;
	a[now][cc[now]]=a[now][1];
	now^=1;
	cc[now]=0;
	for (int i=1;i&lt;=cc[now^1]-1;i++)
	{
		if (det(a[now^1][i]-P,v)&gt;-eps) a[now][++cc[now]]=a[now^1][i];
		if (linesegxj(P,v,a[now^1][i],a[now^1][i+1]))
			a[now][++cc[now]]=linejd(P,v,a[now^1][i],a[now^1][i+1]-a[now^1][i]);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	cc[0]=4;
	a[0][1].x=-inf,a[0][1].y=0;
	a[0][2].x=0,a[0][2].y=0;
	a[0][3].x=0,a[0][3].y=inf;
	a[0][4].x=-inf,a[0][4].y=inf;
	now=0;
	for (int i=1;i&lt;=n;i++)
	{
		//for (int j=1;j&lt;=cc[now];j++) printf(&quot;%.3f %.3f  &quot;,(DD)a[now][j].x,(DD)a[now][j].y);printf(&quot;\n&quot;);
		int x,y1,y2;
		point t1,t2;
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y1,&amp;y2);
		t1.x=0,t1.y=y1*1.0/x;
		t2.x=1,t2.y=-1*x+y1*1.0/x;
		//printf(&quot;%.3f %.3f %.3f %.3f\n&quot;,(DD)t1.x,(DD)t1.y,(DD)t2.x,(DD)t2.y);
		work(t1,t1-t2);
		t1.x=0,t1.y=y2*1.0/x;
		t2.x=1,t2.y=-1*x+y2*1.0/x;
		work(t1,t2-t1);
		//printf(&quot;%.3f %.3f %.3f %.3f\n&quot;,(DD)t1.x,(DD)t1.y,(DD)t2.x,(DD)t2.y);
		if (cc[now]&lt;=2) {printf(&quot;%d\n&quot;,i-1);return 0;}
	}
	printf(&quot;%d\n&quot;,n);
	return 0;
}
<pre><h2>Problem2732</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 99999999
#define NN 210000
#define LD long double
int cc[2],n,now;
const LD eps=1e-18;
struct point
{
	LD x,y;
	friend point operator -(point a,point b) {a.x-=b.x;a.y-=b.y;return a;}
	friend point operator +(point a,point b) {a.x+=b.x,a.y+=b.y;return a;}
	friend point operator *(LD t,point a) {a.x*=t,a.y*=t;return a;}
};
point a[2][NN*4];
LD det(point a,point b) {return a.x*b.y-b.x*a.y;}
bool linesegxj(point P,point v,point A,point B)
{
	return det(A-P,v)*det(B-P,v)&lt;eps;
}
point linejd(point P,point v,point Q,point w)
{
	point u=P-Q;
	LD t=det(w,u)/det(v,w);
	return P+t*v;
}
void work(point P,point v)
{
	cc[now]++;
	a[now][cc[now]]=a[now][1];
	now^=1;
	cc[now]=0;
	for (int i=1;i&lt;=cc[now^1]-1;i++)
	{
		if (det(a[now^1][i]-P,v)&gt;-eps) a[now][++cc[now]]=a[now^1][i];
		if (linesegxj(P,v,a[now^1][i],a[now^1][i+1]))
			a[now][++cc[now]]=linejd(P,v,a[now^1][i],a[now^1][i+1]-a[now^1][i]);
	}
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	cc[0]=4;
	a[0][1].x=-inf,a[0][1].y=0;
	a[0][2].x=0,a[0][2].y=0;
	a[0][3].x=0,a[0][3].y=inf;
	a[0][4].x=-inf,a[0][4].y=inf;
	now=0;
	for (int i=1;i&lt;=n;i++)
	{
		int x,y1,y2;
		point t1,t2;
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y1,&amp;y2);
		t1.x=0,t1.y=y1*1.0/x;
		t2.x=1,t2.y=-1*x+y1*1.0/x;
		work(t1,t1-t2);
		t1.x=0,t1.y=y2*1.0/x;
		t2.x=1,t2.y=-1*x+y2*1.0/x;
		work(t1,t2-t1);
		if (cc[now]&lt;=2) {printf(&quot;%d\n&quot;,i-1);return 0;}
	}
	printf(&quot;%d\n&quot;,n);
	return 0;
}
<pre><h2>Problem2732</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 99999999
#define NN 210000
#define LD long double
int cc[2],n,now;
const LD eps=1e-18;
struct point
{
	LD x,y;
	friend point operator -(point a,point b) {a.x-=b.x;a.y-=b.y;return a;}
	friend point operator +(point a,point b) {a.x+=b.x,a.y+=b.y;return a;}
	friend point operator *(LD t,point a) {a.x*=t,a.y*=t;return a;}
};
point a[2][NN*4];
LD det(point a,point b) {return a.x*b.y-b.x*a.y;}
bool linesegxj(point P,point v,point A,point B)
{
	return det(A-P,v)*det(B-P,v)&lt;eps;
}
point linejd(point P,point v,point Q,point w)
{
	point u=P-Q;
	LD t=det(w,u)/det(v,w);
	return P+t*v;
}
void work(point P,point v)
{
	cc[now]++;
	a[now][cc[now]]=a[now][1];
	now^=1;
	cc[now]=0;
	for (int i=1;i&lt;=cc[now^1]-1;i++)
	{
		if (det(a[now^1][i]-P,v)&gt;-eps) a[now][++cc[now]]=a[now^1][i];
		if (linesegxj(P,v,a[now^1][i],a[now^1][i+1]))
			a[now][++cc[now]]=linejd(P,v,a[now^1][i],a[now^1][i+1]-a[now^1][i]);
	}
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	cc[0]=4;
	a[0][1].x=-inf,a[0][1].y=-inf;
	a[0][2].x=inf,a[0][2].y=-inf;
	a[0][3].x=inf,a[0][3].y=inf;
	a[0][4].x=-inf,a[0][4].y=inf;
	now=0;
	for (int i=1;i&lt;=n;i++)
	{
		int x,y1,y2;
		point t1,t2;
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y1,&amp;y2);
		t1.x=0,t1.y=y1*1.0/x;
		t2.x=1,t2.y=-1*x+y1*1.0/x;
		work(t1,t1-t2);
		t1.x=0,t1.y=y2*1.0/x;
		t2.x=1,t2.y=-1*x+y2*1.0/x;
		work(t1,t2-t1);
		if (cc[now]&lt;=2) {printf(&quot;%d\n&quot;,i-1);return 0;}
	}
	printf(&quot;%d\n&quot;,n);
	return 0;
}
<pre><h2>Problem2732</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 99999999
#define NN 210000
#define LD long double
int cc[2],n,now;
const LD eps=1e-18;
struct point
{
	LD x,y;
	friend point operator -(point a,point b) {a.x-=b.x;a.y-=b.y;return a;}
	friend point operator +(point a,point b) {a.x+=b.x,a.y+=b.y;return a;}
	friend point operator *(LD t,point a) {a.x*=t,a.y*=t;return a;}
};
point a[2][NN*4];
LD det(point a,point b) {return a.x*b.y-b.x*a.y;}
bool linesegxj(point P,point v,point A,point B)
{
	return det(A-P,v)*det(B-P,v)&lt;eps;
}
point linejd(point P,point v,point Q,point w)
{
	point u=P-Q;
	LD t=det(w,u)/det(v,w);
	return P+t*v;
}
void work(point P,point v)
{
	cc[now]++;
	a[now][cc[now]]=a[now][1];
	now^=1;
	cc[now]=0;
	for (int i=1;i&lt;=cc[now^1]-1;i++)
	{
		if (det(a[now^1][i]-P,v)&gt;-eps) a[now][++cc[now]]=a[now^1][i];
		if (linesegxj(P,v,a[now^1][i],a[now^1][i+1]))
			a[now][++cc[now]]=linejd(P,v,a[now^1][i],a[now^1][i+1]-a[now^1][i]);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	cc[0]=4;
	a[0][1].x=-inf,a[0][1].y=0;
	a[0][2].x=0,a[0][2].y=0;
	a[0][3].x=0,a[0][3].y=inf;
	a[0][4].x=-inf,a[0][4].y=inf;
	now=0;
	for (int i=1;i&lt;=n;i++)
	{
		int x,y1,y2;
		point t1,t2;
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y1,&amp;y2);
		t1.x=0,t1.y=y1*1.0/x;
		t2.x=1,t2.y=-x+y1*1.0/x;
		work(t1,t1-t2);
		t1.x=0,t1.y=y2*1.0/x;
		t2.x=1,t2.y=-x+y2*1.0/x;
		work(t1,t2-t1);
		if (cc[now]&lt;=2) {printf(&quot;%d\n&quot;,i-1);return 0;}
	}
	printf(&quot;%d\n&quot;,n);
	return 0;
}
<pre><h2>Problem2732</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 99999999
#define NN 210000
#define LD double
int cc[2],n,now;
const LD eps=1e-18;
struct point
{
	LD x,y;
	friend point operator -(point a,point b) {a.x-=b.x;a.y-=b.y;return a;}
	friend point operator +(point a,point b) {a.x+=b.x,a.y+=b.y;return a;}
	friend point operator *(LD t,point a) {a.x*=t,a.y*=t;return a;}
};
point a[2][NN*4];
LD det(point a,point b) {return a.x*b.y-b.x*a.y;}
bool linesegxj(point P,point v,point A,point B)
{
	return det(A-P,v)*det(B-P,v)&lt;eps;
}
point linejd(point P,point v,point Q,point w)
{
	point u=P-Q;
	LD t=det(w,u)/det(v,w);
	return P+t*v;
}
void work(point P,point v)
{
	cc[now]++;
	a[now][cc[now]]=a[now][1];
	now^=1;
	cc[now]=0;
	for (int i=1;i&lt;=cc[now^1]-1;i++)
	{
		if (det(a[now^1][i]-P,v)&gt;-eps) a[now][++cc[now]]=a[now^1][i];
		if (linesegxj(P,v,a[now^1][i],a[now^1][i+1]))
			a[now][++cc[now]]=linejd(P,v,a[now^1][i],a[now^1][i+1]-a[now^1][i]);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	cc[0]=4;
	a[0][1].x=-inf,a[0][1].y=0;
	a[0][2].x=0,a[0][2].y=0;
	a[0][3].x=0,a[0][3].y=inf;
	a[0][4].x=-inf,a[0][4].y=inf;
	now=0;
	for (int i=1;i&lt;=n;i++)
	{
		int x,y1,y2;
		point t1,t2;
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y1,&amp;y2);
		t1.x=0,t1.y=y1*1.0/x;
		t2.x=1,t2.y=-x+y1*1.0/x;
		work(t1,t1-t2);
		t1.x=0,t1.y=y2*1.0/x;
		t2.x=1,t2.y=-x+y2*1.0/x;
		work(t1,t2-t1);
		if (cc[now]&lt;=2) {printf(&quot;%d\n&quot;,i-1);return 0;}
	}
	printf(&quot;%d\n&quot;,n);
	return 0;
}
<pre><h2>Problem2732</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 99999999
#define NN 210000
#define LD double
int cc[2],n,now;
const LD eps=1e-18;
struct point
{
	LD x,y;
	friend point operator -(point a,point b) {a.x-=b.x;a.y-=b.y;return a;}
	friend point operator +(point a,point b) {a.x+=b.x,a.y+=b.y;return a;}
	friend point operator *(LD t,point a) {a.x*=t,a.y*=t;return a;}
};
point a[2][NN*4];
LD det(point a,point b) {return a.x*b.y-b.x*a.y;}
bool linesegxj(point P,point v,point A,point B)
{
	return det(A-P,v)*det(B-P,v)&lt;eps;
}
point linejd(point P,point v,point Q,point w)
{
	point u=P-Q;
	LD t=det(w,u)/det(v,w);
	return P+t*v;
}
void work(point P,point v)
{
	cc[now]++;
	a[now][cc[now]]=a[now][1];
	now^=1;
	cc[now]=0;
	for (int i=1;i&lt;=cc[now^1]-1;i++)
	{
		if (det(a[now^1][i]-P,v)&gt;-eps) a[now][++cc[now]]=a[now^1][i];
		if (linesegxj(P,v,a[now^1][i],a[now^1][i+1]))
			a[now][++cc[now]]=linejd(P,v,a[now^1][i],a[now^1][i+1]-a[now^1][i]);
	}
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	cc[0]=4;
	a[0][1].x=-inf,a[0][1].y=0;
	a[0][2].x=0,a[0][2].y=0;
	a[0][3].x=0,a[0][3].y=inf;
	a[0][4].x=-inf,a[0][4].y=inf;
	now=0;
	for (int i=1;i&lt;=n;i++)
	{
		int x,y1,y2;
		point t1,t2;
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y1,&amp;y2);
		t1.x=0,t1.y=y1*1.0/x;
		t2.x=1,t2.y=-x+y1*1.0/x;
		work(t1,t1-t2);
		t1.x=0,t1.y=y2*1.0/x;
		t2.x=1,t2.y=-x+y2*1.0/x;
		work(t1,t2-t1);
		if (cc[now]&lt;=2) {printf(&quot;%d\n&quot;,i-1);return 0;}
	}
	printf(&quot;%d\n&quot;,n);
	return 0;
}
<pre><h2>Problem2732</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 99999999
#define NN 210000
#define LD double
int cc[2],n,now;
const LD eps=1e-18;
struct point
{
	LD x,y;
	friend point operator -(point a,point b) {a.x-=b.x;a.y-=b.y;return a;}
	friend point operator +(point a,point b) {a.x+=b.x,a.y+=b.y;return a;}
	friend point operator *(LD t,point a) {a.x*=t,a.y*=t;return a;}
};
point a[2][NN*10];
LD det(point a,point b) {return a.x*b.y-b.x*a.y;}
bool linesegxj(point P,point v,point A,point B)
{
	return det(A-P,v)*det(B-P,v)&lt;eps;
}
point linejd(point P,point v,point Q,point w)
{
	point u=P-Q;
	LD t=det(w,u)/det(v,w);
	return P+t*v;
}
void work(point P,point v)
{
	cc[now]++;
	a[now][cc[now]]=a[now][1];
	now^=1;
	cc[now]=0;
	for (int i=1;i&lt;=cc[now^1]-1;i++)
	{
		if (det(a[now^1][i]-P,v)&gt;-eps) a[now][++cc[now]]=a[now^1][i];
		if (linesegxj(P,v,a[now^1][i],a[now^1][i+1]))
			a[now][++cc[now]]=linejd(P,v,a[now^1][i],a[now^1][i+1]-a[now^1][i]);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	cc[0]=4;
	a[0][1].x=-inf,a[0][1].y=0;
	a[0][2].x=0,a[0][2].y=0;
	a[0][3].x=0,a[0][3].y=inf;
	a[0][4].x=-inf,a[0][4].y=inf;
	now=0;
	for (int i=1;i&lt;=n;i++)
	{
		int x,y1,y2;
		point t1,t2;
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y1,&amp;y2);
		t1.x=0,t1.y=y1*1.0/x;
		t2.x=1,t2.y=-x+y1*1.0/x;
		work(t1,t1-t2);
		t1.x=0,t1.y=y2*1.0/x;
		t2.x=1,t2.y=-x+y2*1.0/x;
		work(t1,t2-t1);
		if (cc[now]&lt;=2) {printf(&quot;%d\n&quot;,i-1);return 0;}
	}
	printf(&quot;%d\n&quot;,n);
	return 0;
}
<pre><h2>Problem2732</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 99999999
#define NN 210000
#define LD double
int cc[2],n,now;
const LD eps=1e-18;
struct point
{
    LD x,y;
    friend point operator -(point a,point b) {a.x-=b.x;a.y-=b.y;return a;}
    friend point operator +(point a,point b) {a.x+=b.x,a.y+=b.y;return a;}
    friend point operator *(LD t,point a) {a.x*=t,a.y*=t;return a;}
};
point a[2][NN*4];
LD det(point a,point b) {return a.x*b.y-b.x*a.y;}
bool linesegxj(point P,point v,point A,point B)
{
    return det(A-P,v)*det(B-P,v)&lt;-eps;
}
point linejd(point P,point v,point Q,point w)
{
    point u=P-Q;
    LD t=det(w,u)/det(v,w);
    return P+t*v;
}
void work(point P,point v)
{
    cc[now]++;
    a[now][cc[now]]=a[now][1];
    now^=1;
    cc[now]=0;
    for (int i=1;i&lt;=cc[now^1]-1;i++)
    {
        if (det(a[now^1][i]-P,v)&gt;-eps) a[now][++cc[now]]=a[now^1][i];
        if (linesegxj(P,v,a[now^1][i],a[now^1][i+1]))
            a[now][++cc[now]]=linejd(P,v,a[now^1][i],a[now^1][i+1]-a[now^1][i]);
    }
}
int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    cc[0]=4;
    a[0][1].x=-inf,a[0][1].y=0;
    a[0][2].x=0,a[0][2].y=0;
    a[0][3].x=0,a[0][3].y=inf;
    a[0][4].x=-inf,a[0][4].y=inf;
    now=0;
    for (int i=1;i&lt;=n;i++)
    {
        int x,y1,y2;
        point t1,t2;
        scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y1,&amp;y2);
        t1.x=0,t1.y=y1*1.0/x;
        t2.x=1,t2.y=-x+y1*1.0/x;
        work(t1,t1-t2);
        t1.x=0,t1.y=y2*1.0/x;
        t2.x=1,t2.y=-x+y2*1.0/x;
        work(t1,t2-t1);
        if (cc[now]&lt;=2) {printf(&quot;%d\n&quot;,i-1);return 0;}
    }
    printf(&quot;%d\n&quot;,n);
    return 0;
}<pre><h2>Problem2732</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 99999999
#define NN 210000
#define LD double
int cc[2],n,now;
const LD eps=1e-16;
struct point
{
    LD x,y;
    friend point operator -(point a,point b) {a.x-=b.x;a.y-=b.y;return a;}
    friend point operator +(point a,point b) {a.x+=b.x,a.y+=b.y;return a;}
    friend point operator *(LD t,point a) {a.x*=t,a.y*=t;return a;}
};
point a[2][NN*4];
LD det(point a,point b) {return a.x*b.y-b.x*a.y;}
bool linesegxj(point P,point v,point A,point B)
{
    return det(A-P,v)*det(B-P,v)&lt;-eps;
}
point linejd(point P,point v,point Q,point w)
{
    point u=P-Q;
    LD t=det(w,u)/det(v,w);
    return P+t*v;
}
void work(point P,point v)
{
    cc[now]++;
    a[now][cc[now]]=a[now][1];
    now^=1;
    cc[now]=0;
    for (int i=1;i&lt;=cc[now^1]-1;i++)
    {
        if (det(a[now^1][i]-P,v)&gt;-eps) a[now][++cc[now]]=a[now^1][i];
        if (linesegxj(P,v,a[now^1][i],a[now^1][i+1]))
            a[now][++cc[now]]=linejd(P,v,a[now^1][i],a[now^1][i+1]-a[now^1][i]);
    }
}
int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    cc[0]=4;
    a[0][1].x=-inf,a[0][1].y=0;
    a[0][2].x=0,a[0][2].y=0;
    a[0][3].x=0,a[0][3].y=inf;
    a[0][4].x=-inf,a[0][4].y=inf;
    now=0;
    for (int i=1;i&lt;=n;i++)
    {
        int x,y1,y2;
        point t1,t2;
        scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y1,&amp;y2);
        t1.x=0,t1.y=y1*1.0/x;
        t2.x=1,t2.y=-x+y1*1.0/x;
        work(t1,t1-t2);
        t1.x=0,t1.y=y2*1.0/x;
        t2.x=1,t2.y=-x+y2*1.0/x;
        work(t1,t2-t1);
        if (cc[now]&lt;=2) {printf(&quot;%d\n&quot;,i-1);return 0;}
    }
    printf(&quot;%d\n&quot;,n);
    return 0;
}<pre><h2>Problem2732</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 99999999
#define NN 210000
#define LD double
int cc[2],n,now;
const LD eps=1e-16;
struct point
{
    LD x,y;
    friend point operator -(point a,point b) {a.x-=b.x;a.y-=b.y;return a;}
    friend point operator +(point a,point b) {a.x+=b.x,a.y+=b.y;return a;}
    friend point operator *(LD t,point a) {a.x*=t,a.y*=t;return a;}
};
point a[2][NN*4];
LD det(point a,point b) {return a.x*b.y-b.x*a.y;}
bool linesegxj(point P,point v,point A,point B)
{
    return det(A-P,v)*det(B-P,v)&lt;-eps;
}
point linejd(point P,point v,point Q,point w)
{
    point u=P-Q;
    LD t=det(w,u)/det(v,w);
    return P+t*v;
}
void work(point P,point v)
{
    cc[now]++;
    a[now][cc[now]]=a[now][1];
    now^=1;
    cc[now]=0;
    for (int i=1;i&lt;=cc[now^1]-1;i++)
    {
        if (det(a[now^1][i]-P,v)&gt;-eps) a[now][++cc[now]]=a[now^1][i];
        if (linesegxj(P,v,a[now^1][i],a[now^1][i+1]))
            a[now][++cc[now]]=linejd(P,v,a[now^1][i],a[now^1][i+1]-a[now^1][i]);
    }
}
int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    cc[0]=4;
    a[0][1].x=-inf,a[0][1].y=0;
    a[0][2].x=0,a[0][2].y=0;
    a[0][3].x=0,a[0][3].y=inf;
    a[0][4].x=-inf,a[0][4].y=inf;
    now=0;
    for (int i=1;i&lt;=n;i++)
    {
        int x,y1,y2;
        point t1,t2;
        scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y1,&amp;y2);
        t1.x=0,t1.y=y1*1.0/x;
        t2.x=1,t2.y=-x+y1*1.0/x;
        work(t1,t1-t2);
        t1.x=0,t1.y=y2*1.0/x;
        t2.x=1,t2.y=-x+y2*1.0/x;
        work(t1,t2-t1);
        if (cc[now]&lt;=2) {printf(&quot;%d\n&quot;,i-1);return 0;}
    }
    printf(&quot;%d\n&quot;,n);
    return 0;
}
<pre><h2>Problem2732</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 99999999
#define NN 210000
#define LD long double
int cc[2],n,now;
const LD eps=1e-18;
struct point
{
    LD x,y;
    friend point operator -(point a,point b) {a.x-=b.x;a.y-=b.y;return a;}
    friend point operator +(point a,point b) {a.x+=b.x,a.y+=b.y;return a;}
    friend point operator *(LD t,point a) {a.x*=t,a.y*=t;return a;}
};
point a[2][NN*4];
LD det(point a,point b) {return a.x*b.y-b.x*a.y;}
bool linesegxj(point P,point v,point A,point B)
{
    return det(A-P,v)*det(B-P,v)&lt;eps;
}
point linejd(point P,point v,point Q,point w)
{
    point u=P-Q;
    LD t=det(w,u)/det(v,w);
    return P+t*v;
}
void work(point P,point v)
{
    cc[now]++;
    a[now][cc[now]]=a[now][1];
    now^=1;
    cc[now]=0;
    for (int i=1;i&lt;=cc[now^1]-1;i++)
    {
        if (det(a[now^1][i]-P,v)&gt;-eps) a[now][++cc[now]]=a[now^1][i];
        if (linesegxj(P,v,a[now^1][i],a[now^1][i+1]))
            a[now][++cc[now]]=linejd(P,v,a[now^1][i],a[now^1][i+1]-a[now^1][i]);
    }
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d&quot;,&amp;n);
    cc[0]=4;
    a[0][1].x=-inf,a[0][1].y=0;
    a[0][2].x=0,a[0][2].y=0;
    a[0][3].x=0,a[0][3].y=inf;
    a[0][4].x=-inf,a[0][4].y=inf;
    now=0;
    for (int i=1;i&lt;=n;i++)
    {
        int x,y1,y2;
        point t1,t2;
        scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y1,&amp;y2);
        t1.x=0,t1.y=y1*1.0/x;
        t2.x=0.1,t2.y=-0.1*x+y1*1.0/x;
        work(t1,t1-t2);
        t1.x=0,t1.y=y2*1.0/x;
        t2.x=0.1,t2.y=-0.1*x+y2*1.0/x;
        work(t1,t2-t1);
        if (cc[now]&lt;=2) {printf(&quot;%d\n&quot;,i-1);return 0;}
    }
    printf(&quot;%d\n&quot;,n);
    return 0;
}
<pre><h2>Problem2733</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define NN 101111
#define ln printf(&quot;\n&quot;)
int son[NN][2],fa[NN],size[NN],key[NN];
int n,m;
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
void update(int v)
{
	size[v]=size[son[v][0]]+size[son[v][1]]+1;
}
void rotate(int t,int p)
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
}
void ins(int &amp;t,int v,int ff)
{
	if (!t)
	{
		t=v;
		fa[t]=ff;
		splay(t,0);
		return;
	}
	if (key[v]&gt;key[t]) ins(son[t][1],v,t);
	else ins(son[t][0],v,t);
}
void del(int t,int id)
{
	if (!t) return;
	del(son[t][0],id);
	del(son[t][1],id);
	son[t][0]=son[t][1]=fa[t]=0;
	ins(id,t,0);
	splay(id,0);
}
int select(int t,int K)
{
	for (;t;)
	{
		if (K==size[son[t][0]]+1) return t;
		if (K&lt;=size[son[t][0]]) t=son[t][0];
		else K-=(size[son[t][0]]+1),t=son[t][1];
	}
}
void zhong(int t)
{
	if (!t) return;
	zhong(son[t][0]);
	printf(&quot;%d &quot;,t);
	zhong(son[t][1]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;key[i]),size[i]=1;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		splay(x,0);
		splay(y,0);
		if (size[x]&lt;size[y]) {int t=x;x=y;y=t;}
		del(y,x);
	}
	//for (int i=1;i&lt;=n;i++) if (fa[i]==0) zhong(i),ln;ln;
	scanf(&quot;%d&quot;,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		char ch=getchar();
		while (ch!='Q'&amp;&amp;ch!='B') ch=getchar();
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		if (ch=='B')
		{
			splay(x,0);
			splay(y,0);
			if (size[x]&lt;size[y]) {int t=x;x=y;y=t;}
			del(y,x);
		}
		else
		{
			splay(x,0);
			if (size[x]&lt;y) printf(&quot;-1\n&quot;);
			else printf(&quot;%d\n&quot;,select(x,y));
		}
	}
	return 0;
}
<pre><h2>Problem2734</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define all(x) ((1&lt;&lt;(x))-1)
#define mo 1000000001
#define LL long long
LL n;
LL f[20][3333];
bool flag[101111];
bool pan1(LL S)//S本身是否合法
{
	if ((S&amp;(S&gt;&gt;1))||(S&amp;(S&lt;&lt;1))) return false;
	return true;
}
bool pan2(LL S,LL n,LL T,LL m)
{
	T=T&gt;&gt;(m-n);
	if (S&amp;T) return false;
	return true;
}
LL calc(LL x)
{
	//printf(&quot;x=%lld\n&quot;,x);
	//f[i][S]=sigma(f[i-1][T])  ans=sigma(f[n][S])
	LL t=1,i,j,num,S,T,last;
	for (j=x;j&lt;=n;j*=3,t++) flag[j]=true;
	t--;
	for (S=0;S&lt;=all(t);S++) if (pan1(S)) f[1][S]=1;
	last=x,num=t;
	for (i=2;;i++)
	{
		x=last*2;
		if (x&gt;n) break;
		t=1;
		for (j=x;j&lt;=n;j*=3,t++) flag[j]=true;
		t--;
		for (S=0;S&lt;=all(t);S++) if (pan1(S))
		{
			f[i][S]=0;
			for (T=0;T&lt;=all(num);T++)
				if (pan2(S,t,T,num))
				{
					f[i][S]+=f[i-1][T];
					if (f[i][S]&gt;mo) f[i][S]-=mo;
				}
			//printf(&quot;f[%lld][%lld]=%lld\n&quot;,i,S,f[i][S]);
		}
		last=x,num=t;
	}
	i--;
	//printf(&quot;i=%lld\n&quot;,i);
	LL res=0;
	for (S=0;S&lt;=all(num);S++) res+=f[i][S],res%=mo;
	return res%mo;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld&quot;,&amp;n);
	LL ans=1;
	for (LL i=1;i&lt;=n;i++)
		if (!flag[i]) ans=ans*calc(i)%mo;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2734</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define all(x) ((1&lt;&lt;(x))-1)
#define mo 1000000001
#define LL long long
int n;
int f[20][2555];
bool flag[101111];
bool pan1(int S)//S本身是否合法
{
	if ((S&amp;(S&gt;&gt;1))||(S&amp;(S&lt;&lt;1))) return false;
	return true;
}
bool pan2(int S,int n,int T,int m)
{
	T=T&gt;&gt;(m-n);
	if (S&amp;T) return false;
	return true;
}
int calc(int x)
{
	//printf(&quot;x=%d\n&quot;,x);
	//f[i][S]=sigma(f[i-1][T])  ans=sigma(f[n][S])
	int t=1,i,j,num,S,T,last;
	for (j=x;j&lt;=n;j*=3,t++) flag[j]=true;
	t--;
	for (S=0;S&lt;=all(t);S++) if (pan1(S)) f[1][S]=1;
	last=x,num=t;
	for (i=2;;i++)
	{
		x=last*2;
		if (x&gt;n) break;
		t=1;
		for (j=x;j&lt;=n;j*=3,t++) flag[j]=true;
		t--;
		for (S=0;S&lt;=all(t);S++) if (pan1(S))
		{
			f[i][S]=0;
			for (T=0;T&lt;=all(num);T++)
				if (pan2(S,t,T,num))
				{
					f[i][S]+=f[i-1][T];
					if (f[i][S]&gt;mo) f[i][S]-=mo;
				}
			//printf(&quot;f[%d][%d]=%lld\n&quot;,i,S,f[i][S]);
		}
		last=x,num=t;
	}
	i--;
	//printf(&quot;i=%d\n&quot;,i);
	LL res=0;
	for (S=0;S&lt;=all(num);S++) res+=f[i][S];
	return res%mo;
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	LL ans=1;
	for (int i=1;i&lt;=n;i++)
		if (!flag[i]) ans=ans*calc(i)%mo;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2734</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define all(x) ((1&lt;&lt;(x))-1)
#define mo 1000000001
#define LL long long
int n;
int f[18][2055];
bool flag[101111];
int calc(int x)
{
	int t=1,i,j,num,S,T,last;
	for (j=x;j&lt;=n;j*=3,t++) flag[j]=true;
	t--;
	for (S=0;S&lt;=all(t);S++)
		if (!((S&amp;(S&gt;&gt;1))||(S&amp;(S&lt;&lt;1)))) f[1][S]=1;
	last=x,num=t;
	for (i=2;;i++)
	{
		x=last&lt;&lt;1;
		if (x&gt;n) break;
		t=1;
		for (j=x;j&lt;=n;j*=3,t++) flag[j]=true;
		t--;
		for (S=0;S&lt;=all(t);S++)
			if (!((S&amp;(S&gt;&gt;1))||(S&amp;(S&lt;&lt;1))))
			{
				f[i][S]=0;
				for (T=0;T&lt;=all(num);T++)
					if (!(S&amp;(T&gt;&gt;(num-t))))
					{
						f[i][S]+=f[i-1][T];
						if (f[i][S]&gt;mo) f[i][S]-=mo;
					}
			}
		last=x,num=t;
	}
	i--;
	LL res=0;
	for (S=0;S&lt;=all(num);S++) res+=f[i][S];
	return res%mo;
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	LL ans=1;
	for (int i=1;i&lt;=n;i++)
		if (!flag[i]) ans=ans*calc(i)%mo;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2738</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 999999999
#define ln printf(&quot;\n&quot;)
const int NN=511;
int c[NN][NN],id[501111],id1[501111],id2[501111],ans[501111],b[501111],now[501111];
int n,m,tot;
struct info
{
	int kind,x1,y1,x2,y2,val;
	void out(){printf(&quot;kind=%d x1=%d y1=%d x2=%d y2=%d val=%d\n&quot;,kind,x1,y1,x2,y2,val);}
} q[501111];
void change(int i,int j,int x)
{
	if (i&lt;1||j&lt;1) return;
	int jj=j;
	for (;i&lt;=505;i+=i&amp;-i)
		for (j=jj;j&lt;=505;j+=j&amp;-j) c[i][j]+=x;
}
int getsum(int i,int j)
{
	int res=0,jj=j;
	for (;i;i-=i&amp;-i)
		for (j=jj;j;j-=j&amp;-j) res+=c[i][j];
	return res;
}
void solve(int head,int tail,int l,int r)
{
	if (head&gt;tail) return;
	//printf(&quot;\n-------- solve %d %d %d %d --------------------------------------\n&quot;,head,tail,l,r);
	//for (int i=head;i&lt;=tail;i++) printf(&quot;%d &quot;,id[i]);ln;
	int i,j,k,t;
	if (l==r)
	{
		for (i=head;i&lt;=tail;i++) ans[id[i]]=l;
		return;
	}
	bool flag=false;
	for (i=head;i&lt;=tail;i++)
		if (q[id[i]].kind==2) flag=true;
	if (!flag) return;
	int mid=(l+r)&gt;&gt;1;
	for (i=head;i&lt;=tail;i++)
	{
		t=id[i];
		if (q[t].kind==1)
		{
			if (q[t].val&lt;=mid) change(q[t].x1,q[t].y1,1);
		}
		else
		{
			int x1=q[t].x1,x2=q[t].x2,y1=q[t].y1,y2=q[t].y2;
			b[t]=getsum(x2,y2)-getsum(x1-1,y2)-getsum(x2,y1-1)+getsum(x1-1,y1-1);
		}
	}
	//for (i=1;i&lt;=tot;i++) printf(&quot;%d &quot;,b[i]);
	for (i=head;i&lt;=tail;i++)
	{
		t=id[i];
		if (q[t].kind==1&amp;&amp;q[t].val&lt;=mid) change(q[t].x1,q[t].y1,-1);
	}
	for (i=j=0,k=head;k&lt;=tail;k++)
	{
		t=id[k];
		if (q[t].kind==1)
			if (q[t].val&lt;=mid) id1[++i]=t;
			else id2[++j]=t;
		else
			if (now[t]+b[t]&gt;=q[t].val) id1[++i]=t;
			else now[t]+=b[t],id2[++j]=t;
	}
	for (k=1;k&lt;=i;k++) id[head+k-1]=id1[k];
	for (k=1;k&lt;=j;k++) id[head+i+k-1]=id2[k];
	solve(head,head+i-1,l,mid);
	solve(head+i,tail,mid+1,r);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j,x,x1,x2,y1,y2,K;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			tot++;
			q[tot].kind=1,q[tot].x1=i,q[tot].y1=j;
			q[tot].val=x;
			id[tot]=tot;
		}
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;K);
		tot++;
		q[tot].kind=2,q[tot].x1=x1,q[tot].y1=y1;
		q[tot].x2=x2,q[tot].y2=y2;
		q[tot].val=K;
		id[tot]=tot;
	}
	//for (i=1;i&lt;=tot;i++) q[i].out();
	solve(1,tot,0,inf);
	for (i=1;i&lt;=tot;i++)
		if (q[i].kind==2) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem2741</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
const int NN=102111,AA=3001111;
int size[AA],son[AA][2],a[NN],root[NN],st[NN],ed[NN],belong[NN],f[211][211];
int n,m,TTT,blo,cnt;
int qq=31;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	while (ch&lt;'0'||ch&gt;'9')
		{if (ch=='-') f=true;ch=getchar();}
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
	if (f) x=-x;
}
void ins(int &amp;v,int u,int x,int k)
{
	if (k&lt;0) return;
	if (v==0) v=++TTT;
	//printf(&quot;ins %d %d %d %d\n&quot;,v,u,x,k);
	size[v]=size[u]+1;
	int t=x&amp;(1&lt;&lt;(k-1));
	if (t)
	{
		son[v][0]=son[u][0];
		ins(son[v][1],son[u][1],x,k-1);
	}
	else
	{
		son[v][1]=son[u][1];
		ins(son[v][0],son[u][0],x,k-1);
	}
}
int find(int v,int u,int x,int k)
{
	if (k==0) return 0;
	//printf(&quot;find %d %d %d %d\n&quot;,v,u,x,k);
	int t=(x&amp;(1&lt;&lt;(k-1)))&gt;0;
	int tmp=size[son[v][t^1]]-size[son[u][t^1]];
	if (tmp) return (1&lt;&lt;(k-1))+find(son[v][t^1],son[u][t^1],x,k-1);
	else return find(son[v][t],son[u][t],x,k-1);
}
void prepare()
{
	blo=(int)sqrt(n)+1;
	//printf(&quot;blo=%d\n&quot;,blo);
	int i,j,k;
	for (i=1;i&lt;=n;i+=blo)
	{
		cnt++;
		st[cnt]=i,ed[cnt]=min(i+blo-1,n);
		for (j=st[cnt];j&lt;=ed[cnt];j++) belong[j]=cnt;
	}
	for (i=1;i&lt;=cnt;i++)
	{
		int ans=0;
		for (j=i;j&lt;=cnt;j++)
		{
			for (k=st[j];k&lt;=ed[j];k++)
				ans=max(ans,find(root[k-1],root[st[i]-1],a[k],qq));
			f[i][j]=ans;
		}
	}
	//printf(&quot;%d %d %d\n&quot;,f[1][1],f[1][2],f[2][2]);
	//printf(&quot;\n------------------- prepare end -----------------------------------------\n&quot;);
}
int work(int l,int r)
{
	int L=belong[l],R=belong[r],i;
	if (R-L&lt;=1)
	{
		int res=0;
		for (i=l;i&lt;=r;i++)
			res=max(res,find(root[r],root[l-1],a[i],qq));
		return res;
	}
	int res=f[L+1][R-1];
	for (i=l;i&lt;st[L+1];i++)
		res=max(res,find(root[r],root[l-1],a[i],qq));
	for (i=r;i&gt;ed[R-1];i--)
		res=max(res,find(root[r],root[l-1],a[i],qq));
	return res;
}
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	int i,x,y;
	for (i=1;i&lt;=n;i++)
	{
		read(a[i]);
		a[i]^=a[i-1];
		ins(root[i],root[i-1],a[i],qq);
	}
	//printf(&quot;root &quot;);for(i=1;i&lt;=n;i++)printf(&quot;%d &quot;,root[i]);ln;for(i=1;i&lt;=TTT;i++)printf(&quot;%d %d\n&quot;,son[i][0],son[i][1]);
	prepare();
	int lastans=0;
	for (i=1;i&lt;=m;i++)
	{
		read(x),read(y);
		x=((LL)x+lastans)%n+1,y=((LL)y+lastans)%n+1;
		if (x&gt;y) {int t=x;x=y;y=t;}
		x--;
		printf(&quot;%d\n&quot;,lastans=work(x,y));
	}
	return 0;
}<pre><h2>Problem2741</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
const int NN=12111,AA=3001111;
int size[AA],son[AA][2],a[NN],root[NN],st[NN],ed[NN],belong[NN],f[211][211];
int n,m,TTT,blo,cnt;
int qq=31;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	while (ch&lt;'0'||ch&gt;'9')
		{if (ch=='-') f=true;ch=getchar();}
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
	if (f) x=-x;
}
void ins(int &amp;v,int u,int x,int k)
{
	if (k&lt;0) return;
	if (v==0) v=++TTT;
	//printf(&quot;ins %d %d %d %d\n&quot;,v,u,x,k);
	size[v]=size[u]+1;
	int t=x&amp;(1&lt;&lt;(k-1));
	if (t)
	{
		son[v][0]=son[u][0];
		ins(son[v][1],son[u][1],x,k-1);
	}
	else
	{
		son[v][1]=son[u][1];
		ins(son[v][0],son[u][0],x,k-1);
	}
}
int find(int v,int u,int x,int k)
{
	if (k==0) return 0;
	//printf(&quot;find %d %d %d %d\n&quot;,v,u,x,k);
	int t=(x&amp;(1&lt;&lt;(k-1)))&gt;0;
	int tmp=size[son[v][t^1]]-size[son[u][t^1]];
	if (tmp) return (1&lt;&lt;(k-1))+find(son[v][t^1],son[u][t^1],x,k-1);
	else return find(son[v][t],son[u][t],x,k-1);
}
void prepare()
{
	blo=(int)sqrt(n)+1;
	//printf(&quot;blo=%d\n&quot;,blo);
	int i,j,k;
	for (i=1;i&lt;=n;i+=blo)
	{
		cnt++;
		st[cnt]=i,ed[cnt]=min(i+blo-1,n);
		for (j=st[cnt];j&lt;=ed[cnt];j++) belong[j]=cnt;
	}
	for (i=1;i&lt;=cnt;i++)
	{
		int ans=0;
		for (j=i;j&lt;=cnt;j++)
		{
			for (k=st[j];k&lt;=ed[j];k++)
				ans=max(ans,find(root[k-1],root[st[i]-1],a[k],qq));
			f[i][j]=ans;
		}
	}
	//printf(&quot;%d %d %d\n&quot;,f[1][1],f[1][2],f[2][2]);
	//printf(&quot;\n------------------- prepare end -----------------------------------------\n&quot;);
}
int work(int l,int r)
{
	int L=belong[l],R=belong[r],i;
	if (R-L&lt;=1)
	{
		int res=0;
		for (i=l;i&lt;=r;i++)
			res=max(res,find(root[r],root[l-1],a[i],qq));
		return res;
	}
	int res=f[L+1][R-1];
	for (i=l;i&lt;st[L+1];i++)
		res=max(res,find(root[r],root[l-1],a[i],qq));
	for (i=r;i&gt;ed[R-1];i--)
		res=max(res,find(root[r],root[l-1],a[i],qq));
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	int i,x,y;
	for (i=1;i&lt;=n;i++)
	{
		read(a[i]);
		a[i]^=a[i-1];
		ins(root[i],root[i-1],a[i],qq);
	}
	//printf(&quot;root &quot;);for(i=1;i&lt;=n;i++)printf(&quot;%d &quot;,root[i]);ln;for(i=1;i&lt;=TTT;i++)printf(&quot;%d %d\n&quot;,son[i][0],son[i][1]);
	prepare();
	int lastans=0;
	for (i=1;i&lt;=m;i++)
	{
		read(x),read(y);
		x=((LL)x+lastans)%n+1,y=((LL)y+lastans)%n+1;
		if (x&gt;y) {int t=x;x=y;y=t;}
		x--;
		printf(&quot;%d\n&quot;,lastans=work(x,y));
	}
	return 0;
}<pre><h2>Problem2741</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
const int NN=12111,AA=401111;
int size[AA],son[AA][2],a[NN],root[NN],st[NN],ed[NN],belong[NN],f[211][211];
int n,m,TTT,blo,cnt;
int qq=31;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	while (ch&lt;'0'||ch&gt;'9')
		{if (ch=='-') f=true;ch=getchar();}
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
	if (f) x=-x;
}
void ins(int &amp;v,int u,int x,int k)
{
	if (k&lt;0) return;
	if (v==0) v=++TTT;
	//printf(&quot;ins %d %d %d %d\n&quot;,v,u,x,k);
	size[v]=size[u]+1;
	int t=x&amp;(1&lt;&lt;(k-1));
	if (t)
	{
		son[v][0]=son[u][0];
		ins(son[v][1],son[u][1],x,k-1);
	}
	else
	{
		son[v][1]=son[u][1];
		ins(son[v][0],son[u][0],x,k-1);
	}
}
int find(int v,int u,int x,int k)
{
	if (k==0) return 0;
	//printf(&quot;find %d %d %d %d\n&quot;,v,u,x,k);
	int t=(x&amp;(1&lt;&lt;(k-1)))&gt;0;
	int tmp=size[son[v][t^1]]-size[son[u][t^1]];
	if (tmp) return (1&lt;&lt;(k-1))+find(son[v][t^1],son[u][t^1],x,k-1);
	else return find(son[v][t],son[u][t],x,k-1);
}
void prepare()
{
	blo=(int)sqrt(n)+1;
	//printf(&quot;blo=%d\n&quot;,blo);
	int i,j,k;
	for (i=1;i&lt;=n;i+=blo)
	{
		cnt++;
		st[cnt]=i,ed[cnt]=min(i+blo-1,n);
		for (j=st[cnt];j&lt;=ed[cnt];j++) belong[j]=cnt;
	}
	for (i=1;i&lt;=cnt;i++)
	{
		int ans=0;
		for (j=i;j&lt;=cnt;j++)
		{
			for (k=st[j];k&lt;=ed[j];k++)
				ans=max(ans,find(root[k-1],root[st[i]-1],a[k],qq));
			f[i][j]=ans;
		}
	}
	//printf(&quot;%d %d %d\n&quot;,f[1][1],f[1][2],f[2][2]);
	//printf(&quot;\n------------------- prepare end -----------------------------------------\n&quot;);
}
int work(int l,int r)
{
	int L=belong[l],R=belong[r],i;
	if (R-L&lt;=1)
	{
		int res=0;
		for (i=l;i&lt;=r;i++)
			res=max(res,find(root[r],root[l-1],a[i],qq));
		return res;
	}
	int res=f[L+1][R-1];
	for (i=l;i&lt;st[L+1];i++)
		res=max(res,find(root[r],root[l-1],a[i],qq));
	for (i=r;i&gt;ed[R-1];i--)
		res=max(res,find(root[r],root[l-1],a[i],qq));
	return res;
}
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	int i,x,y;
	for (i=1;i&lt;=n;i++)
	{
		read(a[i]);
		a[i]^=a[i-1];
		ins(root[i],root[i-1],a[i],qq);
	}
	//printf(&quot;root &quot;);for(i=1;i&lt;=n;i++)printf(&quot;%d &quot;,root[i]);ln;for(i=1;i&lt;=TTT;i++)printf(&quot;%d %d\n&quot;,son[i][0],son[i][1]);
	prepare();
	int lastans=0;
	for (i=1;i&lt;=m;i++)
	{
		read(x),read(y);
		x=((LL)x+lastans)%n+1,y=((LL)y+lastans)%n+1;
		if (x&gt;y) {int t=x;x=y;y=t;}
		x--;
		printf(&quot;%d\n&quot;,lastans=work(x,y));
	}
	return 0;
}<pre><h2>Problem2754</h2><pre>#include&lt;cstdio&gt;
#include&lt;map&gt;
#include&lt;set&gt;
using namespace std;
#define fi first
#define se second
const int AA=201111;
int que[AA],num[AA],o[AA],aa[AA][2],s[AA],fail[AA];
int n,m,tot,TTT;
set&lt;int&gt; S[AA];
map&lt;int,int&gt; son[AA];
inline void read(int &amp;x)
{
	x=0;bool f=false;char ch=getchar();
	while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar();
	if (ch=='-') f=true,ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
	if (f) x=-x;
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void ins(int len,int f,bool kind)
{
	int now=1;
	for (int i=1;i&lt;=len;i++)
	{
		int t=s[i];
		if (son[now].count(t)) now=son[now][t];
		else now=son[now][t]=++TTT;
		if (kind) S[now].insert(f);
	}
	if (!kind)
	{
		num[now]++;
		addedge(now,f);
	}
}
void build()
{
	int head=0,tail=1;
	map&lt;int,int&gt;::iterator it;
	que[1]=1;
	while (head&lt;tail)
	{
		int x=que[++head];
		for (it=son[x].begin();it!=son[x].end();it++)
		{
			int t=(*it).fi,y=(*it).se;
			int tmp=fail[x];
			while (tmp&amp;&amp;!son[tmp].count(t)) tmp=fail[tmp];
			if (tmp) fail[y]=son[tmp][t];
			else fail[y]=1;
			que[++tail]=y;
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,j,x;
	read(n),read(m);
	TTT=1;
	for (i=1;i&lt;=n;i++)
	{
		read(x);
		for (j=1;j&lt;=x;j++) read(s[j]);
		ins(x,i,true);
		read(x);
		for (j=1;j&lt;=x;j++) read(s[j]);
		ins(x,i,true);
	}
	for (i=1;i&lt;=m;i++)
	{
		read(x);
		for (j=1;j&lt;=x;j++) read(s[j]);
		ins(x,i,false);
	}
	build();
	static int ans1[AA],ans2[AA];
	for (i=TTT;i;i--)
	{
		int x=que[i];
		set&lt;int&gt;::iterator it;
		if (num[x])
		{
			for (int p=o[x];p;p=aa[p][0])
				ans1[aa[p][1]]=S[x].size();
			for (it=S[x].begin();it!=S[x].end();it++)
				ans2[*it]+=num[x];
		}
		set&lt;int&gt; &amp;S1=S[fail[x]];
		set&lt;int&gt; &amp;S2=S[x];
		if (S1.size()&lt;S2.size()) swap(S1,S2);
		for (it=S2.begin();it!=S2.end();it++) S1.insert(*it);
		S2.clear();
	}
	for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans1[i]);
	for (i=1;i&lt;=n;i++) printf(i==n?&quot;%d\n&quot;:&quot;%d &quot;,ans2[i]);
	return 0;
}<pre><h2>Problem2761</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int NN=50111;
int tes,n,root,TTT;
struct splaynode
{
	int fa,s[2],key;
} T[NN];
inline void rotate(int t,int p)
{
	int y=T[t].fa;
	if (T[y].fa)
	{
		if (y==T[T[y].fa].s[0]) T[T[y].fa].s[0]=t;
		else T[T[y].fa].s[1]=t;
	}
	T[t].fa=T[y].fa;
	T[y].s[p^1]=T[t].s[p];
	if (T[t].s[p]) T[T[t].s[p]].fa=y;
	T[t].s[p]=y;
	T[y].fa=t;
}
void splay(int t,int ff)
{
	while (T[t].fa!=ff)
	{
		int y=T[t].fa;
		if (T[y].fa==ff)
			if (t==T[y].s[0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==T[T[y].fa].s[0])
				if (t==T[y].s[0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==T[y].s[1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
}
bool find(int x)
{
	int t=root;
	while (t)
	{
		if (T[t].key==x) return true;
		if (x&lt;T[t].key) t=T[t].s[0];
		else t=T[t].s[1];
	}
	return false;
}
void ins(int &amp;v,int x,int ff)
{
	if (v==0)
	{
		v=++TTT;
		T[v].key=x;
		T[v].fa=ff;
		T[v].s[0]=T[v].s[1]=0;
		splay(v,0);
	}
	else if (x&lt;T[v].key) ins(T[v].s[0],x,v);
	else ins(T[v].s[1],x,v);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		root=0;TTT=0;
		int i,x,t=0;
		for (i=1;i&lt;=n;i++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			if (find(x)) continue;
			ins(root,x,0);
			printf(++t==1?&quot;%d&quot;:&quot; %d&quot;,x);
		}
		printf(&quot;\n&quot;);
	}
	return 0;
}<pre><h2>Problem2763</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
#define inf 1000000005
#define h(x,t) (((t)-1)*n+(x))
const int NN=11111,MM=51111;
int o[NN*11],aa[MM*11*4][3],dist[NN*11];
int n,m,K,S,T,tot;
bool vt[NN*11];
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
struct ppt
{
	int v,d;
	ppt(int a=0,int b=0) {v=a;d=b;}
	friend bool operator &lt;(ppt a,ppt b) {return a.d&gt;b.d;}
};
priority_queue&lt;ppt&gt; Q;
void dij()
{
	for (int i=1;i&lt;=n*K;i++) dist[i]=inf;
	dist[S]=0;
	Q.push(ppt(S,0));
	while (!Q.empty())
	{
		ppt tmp=Q.top();Q.pop();
		int v=tmp.v,d=tmp.d;
		if (vt[v]) continue;
		vt[v]=true;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (dist[y]&gt;d+aa[p][2])
				dist[y]=d+aa[p][2],Q.push(ppt(y,dist[y]));
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d%d%d&quot;,&amp;n,&amp;m,&amp;K,&amp;S,&amp;T);
	K++,S++,T++;
	int i,j,x,y,z;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		x++,y++;
		for (j=1;j&lt;=K;j++)
		{
			addedge(h(x,j),h(y,j),z);
			addedge(h(y,j),h(x,j),z);
			if (j&lt;K)
			{
				addedge(h(x,j),h(y,j+1),0);
				addedge(h(y,j),h(x,j+1),0);
			}
		}
	}
	T=h(T,K);
	dij();
	printf(&quot;%d\n&quot;,dist[T]);
	return 0;
}<pre><h2>Problem2768</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf=99999999;
int o[100000],deep[100000],q[100000],aa[1000000][3];
int head,tail,tot,n,m,x,y,i,S,T,ans;
int min(int a,int b) {return a&lt;b?a:b;}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v)
{
	addedge(p,q,v);
	addedge(q,p,0);
}
void bfs()
{
	head=0,tail=0;
	memset(deep,0,sizeof(deep[0])*(T+10));
	deep[S]=1;
	q[++tail]=S;
	while (head&lt;tail)
	{
		x=q[++head];
		int p=o[x];
		while (p)
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y])
			{
				deep[y]=deep[x]+1;
				q[++tail]=y;
			}
			p=aa[p][0];
		}
	}
}
int dfs(int v,int flow)
{
	if (v==T) return flow;
	int res=0,p=o[v];
	while (p)
	{
		int y=aa[p][1];
		if (deep[y]==deep[v]+1&amp;&amp;aa[p][2])
		{
			int tmp=dfs(y,min(aa[p][2],flow));
			if (!tmp) deep[y]=inf;
			flow-=tmp;
			aa[p][2]-=tmp;
			aa[p^1][2]+=tmp;
			res+=tmp;
			if (!flow) break;
		}
		p=aa[p][0];
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	tot=1;
	S=n+1,T=S+1;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		if (x) add(S,i,1);
		else add(i,T,1);
	}
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		add(x,y,1);
		add(y,x,1);
	}
	ans=0;
	bfs();
	while (deep[T])
	{
		ans+=dfs(S,inf);
		bfs();
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem2795</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define M 500500
#define BASE 157
using namespace std;
typedef unsigned long long ll;
int n,m,ans,cnt[26][M];
char s[M];
ll sum[M],power[M];
void Check(int x,int y,int times)
{
	int len=(y-x+1)-(y-x+1)/times;
	ll hash1=sum[x+len-1]-sum[x-1]*power[len];
	ll hash2=sum[y]-sum[y-len]*power[len];
	if(hash1==hash2)
		ans=max(ans,times);
}
void Query(int x,int y)
{
	int i,gcd=(y-x+1);
	ans=0;
	for(i=0;i&lt;26;i++)
		gcd=__gcd(gcd,cnt[i][y]-cnt[i][x-1]);
	for(i=1;i*i&lt;=gcd;i++)
		if(gcd%i==0)
			Check(x,y,i),Check(x,y,gcd/i);
}
int main()
{
	int i,j,x,y;
	cin&gt;&gt;n;
	scanf(&quot;%s&quot;,s+1);
	for(i=1;i&lt;=n;i++)
		sum[i]=sum[i-1]*BASE+s[i];
	for(power[0]=1,i=1;i&lt;=n;i++)
		power[i]=power[i-1]*BASE;
	for(j=0;j&lt;26;j++)
		for(i=1;i&lt;=n;i++)
			cnt[j][i]=cnt[j][i-1]+(s[i]-'a'==j);
	cin&gt;&gt;m;
	for(i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		Query(x,y);
		printf(&quot;%d\n&quot;,(y-x+1)/ans);
	}
	return 0;
}
<pre><h2>Problem2802</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
typedef pair&lt;int,int&gt; pii;
const int NN=251111;
int a[NN],b[NN];
int n;
priority_queue&lt;pii&gt; Q;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;b[i]);
	LL now=0;
	int ans=0;
	for (i=1;i&lt;=n;i++)
	{
		now+=a[i];
		if (now&gt;=b[i])
		{
			ans++;
			Q.push(make_pair(b[i],i));
			now-=b[i];
		}
		else if (!Q.empty()&amp;&amp;b[i]&lt;Q.top().first)
		{
			now+=Q.top().first;
			Q.pop();
			now-=b[i];
			Q.push(make_pair(b[i],i));
		}
	}
	printf(&quot;%d\n&quot;,ans);
	static int temp[NN];
	int num=0;
	for (;!Q.empty();Q.pop()) temp[++num]=Q.top().second;
	sort(temp+1,temp+num+1);
	for (i=1;i&lt;=num;i++)
		printf(i==num?&quot;%d\n&quot;:&quot;%d &quot;,temp[i]);
	return 0;
}<pre><h2>Problem2806</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const double eps=1e-7;
const int NN=2401111;
int son[NN][3],pre[NN],val[NN],f[NN],g[NN];
int n,m,last,TTT;
char s[NN];
struct ppt
{
	int id,w;
	ppt(int a=0,int b=0) {id=a,w=b;}
} q[NN];
void add(int x)
{
	int p=last,end=++TTT;
	last=end;
	val[end]=val[p]+1;
	for (;p!=-1&amp;&amp;!son[p][x];p=pre[p]) son[p][x]=end;
	if (p==-1) {pre[end]=0;return;}
	int q=son[p][x];
	if (val[q]==val[p]+1) {pre[end]=q;return;}
	int nq=++TTT;
	val[nq]=val[p]+1;
	pre[nq]=pre[q];
	pre[q]=pre[end]=nq;
	memcpy(son[nq],son[q],sizeof(son[q]));
	for (;p!=-1&amp;&amp;son[p][x]==q;p=pre[p]) son[p][x]=nq;
}
bool check(int L,int n)
{
	//printf(&quot;\n------------------ check %d %d ------------------------------------------------\n&quot;,L,n);
	int head=0,tail=0;
	for (int i=1;i&lt;=n;i++)
	{
		f[i]=f[i-1];
		if (i-L&gt;=0)
		{
			while (head&lt;tail&amp;&amp;q[tail].w&lt;f[i-L]-(i-L)) tail--;
			q[++tail]=ppt(i-L,f[i-L]-(i-L));
			//printf(&quot;push: %d\n&quot;,i-L);
		}
		//printf(&quot;tail=%d\n&quot;,tail);
		while (head&lt;tail&amp;&amp;q[head+1].id&lt;i-g[i]) head++;
		if (head&lt;tail&amp;&amp;q[head+1].w+i&gt;f[i]) f[i]=q[head+1].w+i;
		//printf(&quot;i=%d q[head+1].w=%d\n&quot;,i,q[head+1].w);
	}
	//for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,f[i]);ln;//printf(&quot;%d %d\n&quot;,10*f[n],9*n);
	if (10*f[n]&gt;=9*n) return true;
	return false;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	int i,j;
	pre[0]=-1;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%s\n&quot;,s+1);
		//printf(&quot;%s\n&quot;,s+1);
		int len=strlen(s+1);
		for (j=1;j&lt;=len;j++) add(s[j]-'0');
		add(2);
	}
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s\n&quot;,s+1);
		//printf(&quot;%s\n&quot;,s+1);
		int len=strlen(s+1);
		int now=0,x=0;
		for (j=1;j&lt;=len;j++)
		{
			int t=s[j]-'0';
			while (pre[x]!=-1&amp;&amp;!son[x][t])
				x=pre[x],now=val[x];
			if (son[x][t]) now++,x=son[x][t];
			g[j]=now;
		}
		//printf(&quot;g: &quot;);for (i=1;i&lt;=len;i++) printf(&quot;%d &quot;,g[i]);//ln;ln;
		int l=0,r=len,res=0;
		while (l&lt;=r)
		{
			int mid=(l+r)&gt;&gt;1;
			if (check(mid,len)) res=mid,l=mid+1;
			else r=mid-1;
		}
		printf(&quot;%d\n&quot;,res);
	}
	return 0;
}<pre><h2>Problem2806</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const double eps=1e-7;
const int NN=2401111;
int son[NN][3],pre[NN],val[NN],f[NN],g[NN];
int n,m,last,TTT;
char s[NN];
struct ppt
{
	int id,w;
	ppt(int a=0,int b=0) {id=a,w=b;}
} q[NN];
void add(int x)
{
	int p=last,end=++TTT;
	last=end;
	val[end]=val[p]+1;
	for (;p!=-1&amp;&amp;!son[p][x];p=pre[p]) son[p][x]=end;
	if (p==-1) {pre[end]=0;return;}
	int q=son[p][x];
	if (val[q]==val[p]+1) {pre[end]=q;return;}
	int nq=++TTT;
	val[nq]=val[p]+1;
	pre[nq]=pre[q];
	pre[q]=pre[end]=nq;
	memcpy(son[nq],son[q],sizeof(son[q]));
	for (;p!=-1&amp;&amp;son[p][x]==q;p=pre[p]) son[p][x]=nq;
}
bool check(int L,int n)
{
	int head=0,tail=0;
	for (int i=1;i&lt;=n;i++)
	{
		f[i]=f[i-1];
		if (i-L&gt;=0)
		{
			while (head&lt;tail&amp;&amp;q[tail].w&lt;f[i-L]-(i-L)) tail--;
			q[++tail]=ppt(i-L,f[i-L]-(i-L));
		}
		while (head&lt;tail&amp;&amp;q[head+1].id&lt;i-g[i]) head++;
		if (head&lt;tail&amp;&amp;q[head+1].w+i&gt;f[i]) f[i]=q[head+1].w+i;
	}
	if (10*f[n]&gt;=9*n) return true;
	return false;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	int i,j;
	pre[0]=-1;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%s\n&quot;,s+1);
		int len=strlen(s+1);
		for (j=1;j&lt;=len;j++) add(s[j]-'0');
		add(2);
	}
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s\n&quot;,s+1);
		int len=strlen(s+1);
		int now=0,x=0;
		for (j=1;j&lt;=len;j++)
		{
			int t=s[j]-'0';
			while (pre[x]!=-1&amp;&amp;!son[x][t])
				x=pre[x],now=val[x];
			if (son[x][t]) now++,x=son[x][t];
			g[j]=now;
		}
		int l=0,r=len,res=0;
		while (l&lt;=r)
		{
			int mid=(l+r)&gt;&gt;1;
			if (check(mid,len)) res=mid,l=mid+1;
			else r=mid-1;
		}
		printf(&quot;%d\n&quot;,res);
	}
	return 0;
}<pre><h2>Problem2809</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define LL long long
const int mn=110000;
int B[mn],root[mn],left[mn],right[mn],dist[mn];
LL C[mn],L[mn],sum[mn],S[mn];
int n,m,i;
LL ans;
LL max(LL a,LL b) {return a&gt;b?a:b;}
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
int merge(int x,int y)
{
	if (!x||!y) return x+y;
	if (C[x]&lt;C[y]) swap(x,y);
	right[x]=merge(right[x],y);
	sum[x]=sum[left[x]]+sum[right[x]]+C[x];
	S[x]=S[left[x]]+S[right[x]]+1;
	if (dist[left[x]]&lt;dist[right[x]]) swap(left[x],right[x]);
	dist[x]=dist[right[x]]+1;
	return x;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%lld%lld&quot;,&amp;B[i],&amp;C[i],&amp;L[i]);
		root[i]=i;
		left[i]=right[i]=0;
		dist[i]=1;
		sum[i]=C[i];
		S[i]=1;
	}
	for (i=n;i;i--)
	{
		while (sum[root[i]]&gt;m) root[i]=merge(left[root[i]],right[root[i]]);
		ans=max(ans,S[root[i]]*L[i]);
		if (B[i]) root[B[i]]=merge(root[B[i]],root[i]);
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2809</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define LL long long
const int mn=110000;
int B[mn],root[mn],left[mn],right[mn],dist[mn],S[mn];
LL C[mn],L[mn],sum[mn];
int n,m,i;
LL ans;
LL max(LL a,LL b) {return a&gt;b?a:b;}
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
int merge(int x,int y)
{
	if (!x||!y) return x+y;
	if (C[x]&lt;C[y]) swap(x,y);
	right[x]=merge(right[x],y);
	sum[x]=sum[left[x]]+sum[right[x]]+C[x];
	S[x]=S[left[x]]+S[right[x]]+1;
	if (dist[left[x]]&lt;dist[right[x]]) swap(left[x],right[x]);
	dist[x]=dist[right[x]]+1;
	return x;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%lld%lld&quot;,&amp;B[i],&amp;C[i],&amp;L[i]);
		root[i]=i;
		left[i]=right[i]=0;
		dist[i]=1;
		sum[i]=C[i];
		S[i]=1;
	}
	for (i=n;i;i--)
	{
		while (sum[root[i]]&gt;m) root[i]=merge(left[root[i]],right[root[i]]);
		ans=max(ans,S[root[i]]*L[i]);
		if (B[i]) root[B[i]]=merge(root[B[i]],root[i]);
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2809</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define LL long long
const int mn=110000;
int B[mn],root[mn],left[mn],right[mn],dist[mn],S[mn],C[mn];
LL L[mn],sum[mn];
int n,m,i;
LL ans;
LL max(LL a,LL b) {return a&gt;b?a:b;}
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
int merge(int x,int y)
{
	if (!x||!y) return x+y;
	if (C[x]&lt;C[y]) swap(x,y);
	right[x]=merge(right[x],y);
	sum[x]=sum[left[x]]+sum[right[x]]+C[x];
	S[x]=S[left[x]]+S[right[x]]+1;
	if (dist[left[x]]&lt;dist[right[x]]) swap(left[x],right[x]);
	dist[x]=dist[right[x]]+1;
	return x;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%lld%lld&quot;,&amp;B[i],&amp;C[i],&amp;L[i]);
		root[i]=i;
		left[i]=right[i]=0;
		dist[i]=1;
		sum[i]=C[i];
		S[i]=1;
	}
	for (i=n;i;i--)
	{
		while (sum[root[i]]&gt;m) root[i]=merge(left[root[i]],right[root[i]]);
		ans=max(ans,S[root[i]]*L[i]);
		if (B[i]) root[B[i]]=merge(root[B[i]],root[i]);
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2809</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define LL long long
const int mn=110000;
int B[mn],root[mn],left[mn],right[mn],dist[mn],S[mn],C[mn];
LL L[mn],sum[mn];
int n,m,i;
LL ans;
inline LL max(LL a,LL b) {return a&gt;b?a:b;}
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
int merge(int x,int y)
{
	if (!x||!y) return x+y;
	if (C[x]&lt;C[y]) swap(x,y);
	right[x]=merge(right[x],y);
	sum[x]=sum[left[x]]+sum[right[x]]+C[x];
	S[x]=S[left[x]]+S[right[x]]+1;
	if (dist[left[x]]&lt;dist[right[x]]) swap(left[x],right[x]);
	dist[x]=dist[right[x]]+1;
	return x;
}
int main()
{
//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%lld%lld&quot;,&amp;B[i],&amp;C[i],&amp;L[i]);
		root[i]=i;
		left[i]=right[i]=0;
		dist[i]=1;
		sum[i]=C[i];
		S[i]=1;
	}
	for (i=n;i;i--)
	{
		while (sum[root[i]]&gt;m) root[i]=merge(left[root[i]],right[root[i]]);
		ans=max(ans,S[root[i]]*L[i]);
		if (B[i]) root[B[i]]=merge(root[B[i]],root[i]);
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2809</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define LL long long
const int mn=110000;
int B[mn],root[mn],left[mn],right[mn],dist[mn],S[mn],C[mn];
LL L[mn],sum[mn];
int n,m,i;
LL ans;
LL max(LL a,LL b) {return a&gt;b?a:b;}
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
int merge(int x,int y)
{
	if (!x||!y) return x+y;
	if (C[x]&lt;C[y]) swap(x,y);
	right[x]=merge(right[x],y);
	sum[x]=sum[left[x]]+sum[right[x]]+C[x];
	S[x]=S[left[x]]+S[right[x]]+1;
	if (dist[left[x]]&lt;dist[right[x]]) swap(left[x],right[x]);
	dist[x]=dist[right[x]]+1;
	return x;
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%lld%lld&quot;,&amp;B[i],&amp;C[i],&amp;L[i]);
		root[i]=i;
		left[i]=right[i]=0;
		dist[i]=1;
		sum[i]=C[i];
		S[i]=1;
	}
	for (i=n;i;i--)
	{
		while (sum[root[i]]&gt;m) root[i]=merge(left[root[i]],right[root[i]]);
		ans=max(ans,S[root[i]]*L[i]);
		if (B[i]) root[B[i]]=merge(root[B[i]],root[i]);
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2812</h2><pre>main(){}<pre><h2>Problem2813</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
#define mo 1000000007
const LL NN=10000001;
bool vt[NN];
int num[NN],pr[NN],e[NN],d[NN],f[NN];
int Q,A,Q1,B,C;
int ans1,ans2;
void shai()
{
    vt[1]=true;
    f[1]=num[1]=1;
    int cnt=0;
    for (int i=1;i&lt;=10000000;i++)
    {
        if (!vt[i])
        {
            pr[++cnt]=i;
            num[i]=2;
            e[i]=1;
            d[i]=1;
            f[i]=((LL)i*i+1)%mo;
        }
        for (int j=1;j&lt;=cnt;j++)
        {
            int x=i*pr[j];
            if (x&gt;10000000) break;
            vt[x]=true;
            if (i%pr[j]==0)
            {
                num[x]=num[i]/(e[i]+1)*(e[i]+2);
                e[x]=e[i]+1;
                d[x]=d[i];
                f[x]=((LL)f[d[i]]+(LL)f[i]*pr[j]%mo*pr[j])%mo;
                break;
            }
            num[x]=num[i]*2;
            e[x]=1;
            d[x]=i;
            f[x]=(LL)f[i]*((LL)pr[j]*pr[j]%mo+1)%mo;
        }
    }
}
void work(LL i)
{
    if (i&amp;1)
    {
        ans1+=num[i]+1;
        ans2+=f[i]+4;
    }
    else
    {
        ans1+=num[i];
        ans2+=f[i];
    }
    if (ans1&gt;mo) ans1-=mo;
    if (ans2&gt;mo) ans2-=mo;
}
int main()
{
   // freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    shai();
    scanf(&quot;%d%d%d%d%d&quot;,&amp;Q,&amp;Q1,&amp;A,&amp;B,&amp;C);
    work(Q1);
    for (LL i=2;i&lt;=Q;i++)
    {
        Q1=((LL)Q1*A+B)%C+1;
        work(Q1);
    }
    ans1%=mo,ans2%=mo;
    printf(&quot;%d\n%d\n&quot;,ans1,ans2);
    return 0;
}<pre><h2>Problem2818</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const int NN=10001111;
int n,pr[NN],cnt;
LL phi[NN];
bool vt[NN];
void shai()
{
	vt[1]=true,phi[1]=1;
	for (int i=2;i&lt;=n;i++)
	{
		if (!vt[i]) pr[++cnt]=i,phi[i]=i-1;
		for (int j=1;j&lt;=cnt;j++)
		{
			int x=i*pr[j];
			if (x&gt;n) break;
			vt[x]=true;
			if (i%pr[j]==0) {phi[x]=phi[i]*pr[j];break;}
			else phi[x]=phi[i]*(pr[j]-1);
		}
	}
	for (int i=2;i&lt;=n;i++) phi[i]+=phi[i-1];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	shai();
	LL ans=0;
	for (int i=1;i&lt;=cnt;i++)
	{
		int x=pr[i];
		int m=n/x;
		ans+=(phi[m]&lt;&lt;1)-1;
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem2819</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define lc (v&lt;&lt;1)
#define rc (v&lt;&lt;1|1)
const int NN=501111;
int o[NN],aa[NN*2][2],w[NN],pos[NN],dy[NN],size[NN],deep[NN],up[NN];
int que[NN],fa[NN],hea[NN],tsum[NN&lt;&lt;2];
int n,m,tot=1,cnt,ww,ee;
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void makelian()
{
	int head=0,tail=1;
	que[1]=1;
	while (head&lt;tail)
	{
		int x=que[++head];
		size[x]=1;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[x]) continue;
			fa[y]=x;
			deep[y]=deep[x]+1;
			que[++tail]=y;
		}
	}
	for (int i=n;i;i--)
	{
		int x=que[i],tmp=0,mm=0;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[x]) continue;
			size[x]+=size[y];
			if (size[y]&gt;mm) mm=size[y],tmp=y;
		}
		hea[x]=tmp;
	}
	for (int i=1;i&lt;=n;i++)
	{
		int x=que[i];
		if (hea[fa[x]]==x) up[x]=up[fa[x]];
		else
		{
			up[x]=x;
			for (int y=x;y;y=hea[y])
			{
				pos[y]=++cnt;
				dy[cnt]=y;
			}
		}
	}
}
inline void update(int v)
{
	tsum[v]=tsum[lc]^tsum[rc];
}
void build(int v,int l,int r)
{
	if (r-l==1)
	{
		tsum[v]=w[dy[l]];
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(lc,l,mid);
	build(rc,mid,r);
	update(v);
}
void change(int v,int l,int r,int i,int x)
{
	if (r-l==1)
	{
		tsum[v]=x;
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid) change(lc,l,mid,i,x);
	else change(rc,mid,r,i,x);
	update(v);
}
int find(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tsum[v];
	int mid=(l+r)&gt;&gt;1,res=0;
	if (ww&lt;mid) res^=find(lc,l,mid);
	if (ee&gt;mid) res^=find(rc,mid,r);
	return res;
}
int work(int x,int y)
{
	int res=0;
	while (up[x]!=up[y])
	{
		if (deep[up[x]]&lt;deep[up[y]]) {int t=x;x=y;y=t;}
		ww=pos[up[x]],ee=pos[x]+1;
		res^=find(1,1,n+1);
		x=fa[up[x]];
	}
	if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
	ww=pos[y],ee=pos[x]+1;
	res^=find(1,1,n+1);
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;w[i]);
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	makelian();
	build(1,1,n+1);
	for (scanf(&quot;%d&quot;,&amp;m);m;m--)
	{
		char ch=getchar();
		while (ch!='Q'&amp;&amp;ch!='C') ch=getchar();
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		if (ch=='Q') printf(work(x,y)?&quot;Yes\n&quot;:&quot;No\n&quot;);
		else change(1,1,n+1,pos[x],y);
	}
	return 0;
}<pre><h2>Problem2819</h2><pre>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;ctime&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#define LL long long
#define N 500100
using namespace std;
int getint()
{
	int x=0,f=1;char ch=getchar();
	while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
struct orz
{
	int l,r,sum;
}t[4*N];
int a[2*N],next[2*N],last[2*N],tot,w[2*N];
int son[N],size[N],f[N],up[N],deep[N],pos[N],which[N],tt;
int n,m,q,ll,rr,cnt;
void add(int x,int y)
{
	a[++tot]=y;
	next[tot]=last[x];
	last[x]=tot;
}
void dfs1(int x)
{
	int mmax=0,num=0;
	size[x]=1;
	for (int j=last[x];j;j=next[j])
	if (a[j]!=f[x])
	{
		f[a[j]]=x;
		deep[a[j]]=deep[x]+1;
		dfs1(a[j]);
		size[x]+=size[a[j]];
		if (size[a[j]]&gt;mmax) {mmax=size[a[j]];num=a[j];}
	}
	son[x]=num;
}
void dfs2(int x)
{
	pos[x]=++tt;
	which[tt]=x;
	if (!son[x]) return;
	up[son[x]]=up[x];
	dfs2(son[x]);
	for (int j=last[x];j;j=next[j])
	if (a[j]!=f[x]&amp;&amp;a[j]!=son[x])
	{
		up[a[j]]=a[j];
		dfs2(a[j]);
	}
}
void update(int x)
{
	t[x].sum=t[x&lt;&lt;1].sum^t[x&lt;&lt;1|1].sum;
}
void build(int x,int l,int r)
{
	t[x].l=l;
	t[x].r=r;
	if (l==r)
	{
		t[x].sum=w[which[l]];
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(x&lt;&lt;1,l,mid);
	build(x&lt;&lt;1|1,mid+1,r);
	update(x);
}
void change(int x)
{
	if (t[x].l==t[x].r)
	{
		t[x].sum=rr;
		return;
	}
	int mid=(t[x].l+t[x].r)&gt;&gt;1;
	if (ll&lt;=mid) change(x&lt;&lt;1);else change(x&lt;&lt;1|1);
	update(x);
}
int query(int x,int l,int r)
{
	if (t[x].l==l&amp;&amp;t[x].r==r) return t[x].sum;
	int mid=(t[x].l+t[x].r)&gt;&gt;1;
	if (l&gt;mid) return query(x&lt;&lt;1|1,l,r);
	else if (r&lt;=mid) return query(x&lt;&lt;1,l,r);
	else return (query(x&lt;&lt;1,l,mid)^query(x&lt;&lt;1|1,mid+1,r));
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	int x,y;
	for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;w[i]);
	for (int i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		add(x,y);
		add(y,x);
	}
	deep[1]=1;
	up[1]=1;
	dfs1(1);
	dfs2(1);
	build(1,1,n);
	scanf(&quot;%d&quot;,&amp;q);
	for (int i=1;i&lt;=q;i++)
	{
		char ch=getchar();
		while (ch!='Q'&amp;&amp;ch!='C') ch=getchar();
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		if (ch=='Q')
		{
			int ans=0;
			while (up[x]!=up[y])
			{
				if (deep[up[x]]&lt;deep[up[y]]) swap(x,y);
				ll=pos[up[x]];
				rr=pos[x];
				ans^=query(1,ll,rr);
				x=f[up[x]];
			}
			if (deep[x]&gt;deep[y]) swap(x,y);
			ll=pos[x];
			rr=pos[y];
			ans^=query(1,ll,rr);
			if (ans==0) printf(&quot;No\n&quot;);else printf(&quot;Yes\n&quot;);
		}
		else 
		{
			ll=pos[x];
			rr=y;
			change(1);
		}
	}
}
<pre><h2>Problem2820</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
int pr[1001111],miu[10001111];
LL f[10001111],sum_f[10001111];
int tes,n,m,prcnt;
void shai()
{
	static bool vt[10001111];
	vt[1]=true;
	miu[1]=1;
	int i,j;
	for (i=2;i&lt;=10000000;i++)
	{
		if (!vt[i])
			pr[++prcnt]=i,miu[i]=-1;
		for (j=1;j&lt;=prcnt;j++)
		{
			int x=i*pr[j];
			if (x&gt;10000000) break;
			vt[x]=true;
			if (i%pr[j]==0)
				{miu[x]=0;break;}
			miu[x]=-miu[i];
		}
	}
	for (i=1;i&lt;=prcnt;i++)
		for (j=pr[i];j&lt;=10000000;j+=pr[i])
			f[j]+=miu[j/pr[i]];
	for (i=1;i&lt;=10000000;i++)
		sum_f[i]=sum_f[i-1]+f[i];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	shai();
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		if (n&gt;m) {int t=n;n=m;m=t;}
		int l,r;
		LL res=0;
		for (l=1;l&lt;=n;l=r+1)
		{
			r=min(n/(n/l),m/(m/l));
			res+=(LL)(sum_f[r]-sum_f[l-1])*(n/l)*(m/l);
		}
		printf(&quot;%lld\n&quot;,res);
	}
	return 0;
}<pre><h2>Problem2821</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
using namespace std;
int num[320][100005],belong[100005],begin[320],end[320],a[100005],temp[100005],f[320][320],vt[100005];
int n,c,m,cnt,lastans,i,j,k,block;
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
int getnum(int x,int L,int R) {return num[R][x]-num[L-1][x];}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;c,&amp;m); 
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	block=int(sqrt(n));
	for (i=1;i&lt;=n;i+=block)
	{
		cnt++;
		begin[cnt]=i;
		end[cnt]=i+block-1;
		for (j=begin[cnt];j&lt;=end[cnt];j++)
			if (j&lt;=n) belong[j]=cnt;
	}
	for (i=1;i&lt;=n;i++) num[belong[i]][a[i]]++;
	for (i=2;i&lt;=cnt;i++)
		for (j=1;j&lt;=c;j++) num[i][j]+=num[i-1][j];
	for (i=1;i&lt;=cnt;i++)
	{
		int res=0;
		for (j=1;j&lt;=c;j++) temp[j]=0;
		for (j=i;j&lt;=cnt;j++)
		{
			for (k=begin[j];k&lt;=end[j];k++)
			{
				if (k&gt;n) continue;
				if (temp[a[k]]&amp;1) temp[a[k]]++,res++;
				else if (temp[a[k]]!=0) temp[a[k]]++,res--;
				else temp[a[k]]++;
			}
			f[i][j]=res;
		}
	}
	lastans=0;
	for (;m;m--)
	{
		int l,r,j,res;
		scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
		l=(l+lastans)%n+1,r=(r+lastans)%n+1;
		if (l&gt;r) swap(l,r);
		if (belong[r]-belong[l]&lt;=1)
		{
			res=0;
			for (j=l;j&lt;=r;j++)
				if (vt[a[j]]!=m) vt[a[j]]=m,temp[a[j]]=1;
				else if (temp[a[j]]&amp;1) res++,temp[a[j]]++;
				else if (temp[a[j]]!=0) res--,temp[a[j]]++;
				else temp[a[j]]++;
			lastans=res;
			printf(&quot;%d\n&quot;,res);
			continue;
		}
		int L=belong[l]+1,R=belong[r]-1;
		res=f[L][R];
		for (j=l;j&lt;begin[L];j++)
			if (vt[a[j]]!=m)
			{
				vt[a[j]]=m;
				temp[a[j]]=getnum(a[j],L,R);
				if (temp[a[j]]&amp;1) res++,temp[a[j]]++;
				else if (temp[a[j]]!=0) res--,temp[a[j]]++;
				else temp[a[j]]++;
			}
			else
				if (temp[a[j]]&amp;1) res++,temp[a[j]]++;
				else if (temp[a[j]]!=0) res--,temp[a[j]]++;
				else temp[a[j]]++;
		for (j=end[R]+1;j&lt;=r;j++)
			if (vt[a[j]]!=m)
			{
				vt[a[j]]=m;
				temp[a[j]]=getnum(a[j],L,R);
				if (temp[a[j]]&amp;1) res++,temp[a[j]]++;
				else if (temp[a[j]]!=0) res--,temp[a[j]]++;
				else temp[a[j]]++;
			}
			else
				if (temp[a[j]]&amp;1) res++,temp[a[j]]++;
				else if (temp[a[j]]!=0) res--,temp[a[j]]++;
				else temp[a[j]]++;
		lastans=res;
		printf(&quot;%d\n&quot;,res);
	}
	return 0;
}
<pre><h2>Problem2821</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
using namespace std;
int num[320][100005],belong[100005],begin[320],end[320],a[100005],temp[100005],f[320][320],vt[100005];
int n,c,m,cnt,lastans,i,j,k,block;
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
int getnum(int x,int L,int R) {return num[R][x]-num[L-1][x];}
int main()
{
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;c,&amp;m); 
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	block=int(sqrt(n));
	for (i=1;i&lt;=n;i+=block)
	{
		cnt++;
		begin[cnt]=i;
		end[cnt]=i+block-1;
		for (j=begin[cnt];j&lt;=end[cnt];j++)
			if (j&lt;=n) belong[j]=cnt;
	}
	for (i=1;i&lt;=n;i++) num[belong[i]][a[i]]++;
	for (i=2;i&lt;=cnt;i++)
		for (j=1;j&lt;=c;j++) num[i][j]+=num[i-1][j];
	for (i=1;i&lt;=cnt;i++)
	{
		int res=0;
		for (j=i;j&lt;=cnt;j++)
		{
			for (k=begin[j];k&lt;=end[j];k++)
			{
				if (k&gt;n) continue;
				if (vt[a[k]]!=i) vt[a[k]]=i,temp[a[k]]=1;
				else if (temp[a[k]]&amp;1) temp[a[k]]++,res++;
				else if (temp[a[k]]!=0) temp[a[k]]++,res--;
				else temp[a[k]]++;
			}
			f[i][j]=res;
		}
	}
	memset(vt,0,sizeof(vt));
	lastans=0;
	for (;m;m--)
	{
		int l,r,j,res;
		scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
		l=(l+lastans)%n+1,r=(r+lastans)%n+1;
		if (l&gt;r) swap(l,r);
		if (belong[r]-belong[l]&lt;=1)
		{
			res=0;
			for (j=l;j&lt;=r;j++)
				if (vt[a[j]]!=m) vt[a[j]]=m,temp[a[j]]=1;
				else if (temp[a[j]]&amp;1) res++,temp[a[j]]++;
				else if (temp[a[j]]!=0) res--,temp[a[j]]++;
				else temp[a[j]]++;
			lastans=res;
			printf(&quot;%d\n&quot;,res);
			continue;
		}
		int L=belong[l]+1,R=belong[r]-1;
		res=f[L][R];
		for (j=l;j&lt;begin[L];j++)
			if (vt[a[j]]!=m)
			{
				vt[a[j]]=m;
				temp[a[j]]=getnum(a[j],L,R);
				if (temp[a[j]]&amp;1) res++,temp[a[j]]++;
				else if (temp[a[j]]!=0) res--,temp[a[j]]++;
				else temp[a[j]]++;
			}
			else
				if (temp[a[j]]&amp;1) res++,temp[a[j]]++;
				else if (temp[a[j]]!=0) res--,temp[a[j]]++;
				else temp[a[j]]++;
		for (j=end[R]+1;j&lt;=r;j++)
			if (vt[a[j]]!=m)
			{
				vt[a[j]]=m;
				temp[a[j]]=getnum(a[j],L,R);
				if (temp[a[j]]&amp;1) res++,temp[a[j]]++;
				else if (temp[a[j]]!=0) res--,temp[a[j]]++;
				else temp[a[j]]++;
			}
			else
				if (temp[a[j]]&amp;1) res++,temp[a[j]]++;
				else if (temp[a[j]]!=0) res--,temp[a[j]]++;
				else temp[a[j]]++;
		lastans=res;
		printf(&quot;%d\n&quot;,res);
	}
	return 0;
}
<pre><h2>Problem2827</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
const int NN=30011,MM=301111;
int where[NN],V[MM];
int n,m,tot;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
	if (f) x=-x;
}
struct point
{
	int x,y;
	inline void in() {read(x),read(y);}
	friend bool operator !=(const point &amp;a,const point &amp;b) {return a.x!=b.x||a.y!=b.y;}
	friend bool operator ==(const point &amp;a,const point &amp;b) {return a.x==b.x&amp;&amp;a.y==b.y;}
	friend bool operator &lt;(const point &amp;a,const point &amp;b)
	{
		if (a.x!=b.x) return a.x&lt;b.x;
		return a.y&lt;b.y;
	}
} pos[NN],go[MM],b[NN+MM];
int cha(point a)
{
	int l=1,r=tot;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (b[mid]==a) return mid;
		if (a&lt;b[mid]) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
struct splaynode
{
	int fa,s[2],tag1,tag2,tmax,sz,w,ans1,ans2;
	void out()
	{
		printf(&quot;tmax=%d sz=%d\n&quot;,tmax,sz);
	}
	inline void clear()
	{
		tag1=tag2=tmax=0;
		sz=1;
	}
	inline void make1(int x)
	{
		if (x&gt;tag1) tag1=x;
		if (x&gt;ans1) ans1=x;
	}
	inline void make2(int x)
	{
		if (x&gt;tag2) tag2=x;
		if (x&gt;ans2) ans2=x;
	}
} T[NN];
struct splaytree
{
	int root,id;
	inline void pushdown(int t)
	{
		int x=T[t].s[0],y=T[t].s[1];
		if (T[t].tag1)
		{
			if (x) T[x].make1(T[t].tag1);
			if (y) T[y].make1(T[t].tag1);
			T[t].tag1=0;
		}
		if (T[t].tag2)
		{
			if (x) T[x].make2(T[t].tag2);
			if (y) T[y].make2(T[t].tag2);
			T[t].tag2=0;
		}
	}
	inline void update(int t)
	{
		//printf(&quot;update(%d)\n&quot;,t);
		int x=T[t].s[0],y=T[t].s[1];
		T[t].tmax=max(T[t].w,max(T[x].tmax,T[y].tmax));
		T[t].sz=T[x].sz+T[y].sz+1;
	}
	inline void rotate(int t,int p)
	{
		int y=T[t].fa;
		pushdown(y),pushdown(t);
		if (T[y].fa)
		{
			if (y==T[T[y].fa].s[0]) T[T[y].fa].s[0]=t;
			else T[T[y].fa].s[1]=t;
		}
		T[t].fa=T[y].fa;
		T[y].s[p^1]=T[t].s[p];
		if (T[t].s[p]) T[T[t].s[p]].fa=y;
		T[t].s[p]=y;
		T[y].fa=t;
		update(y),update(t);
	}
	void splay(int t,int ff)
	{
		while (T[t].fa!=ff)
		{
			int y=T[t].fa;
			if (T[y].fa==ff)
				if (t==T[y].s[0]) rotate(t,1);
				else rotate(t,0);
			else
				if (y==T[T[y].fa].s[0])
					if (t==T[y].s[0]) rotate(y,1),rotate(t,1);
					else rotate(t,0),rotate(t,1);
				else
					if (t==T[y].s[1]) rotate(y,0),rotate(t,0);
					else rotate(t,1),rotate(t,0);
		}
		pushdown(t),update(t);
		if (ff==0) root=t;
	}
	void ins(int &amp;v,int t,int ff)
	{
		if (v==0)
		{
			v=t;
			//printf(&quot;ins %d %d %d\n&quot;,v,t,ff);
			T[t].fa=ff;
			T[t].s[0]=T[t].s[1]=0;
			T[t].clear();
			splay(t,0);
			return;
		}
		//printf(&quot;ins %d %d %d\n&quot;,v,t,ff);
		pushdown(v);
		if (t&lt;v) ins(T[v].s[0],t,v);
		else ins(T[v].s[1],t,v);
	}
	void ins(int t)
	{
		//printf(&quot;E[%d].ins(%d)\n&quot;,id,t);//printf(&quot;root: &quot;);T[root].out();
		T[t].ans1=max(T[t].ans1,T[root].tmax);
		T[t].ans2=max(T[t].ans2,T[root].sz);
		T[root].make1(T[t].w);
		T[root].make2(T[root].sz);
		ins(root,t,0);
		//printf(&quot;debug: &quot;);debug(root);ln;printf(&quot;root: &quot;);T[root].out();ln;
	}
	void del(int t)
	{
		//printf(&quot;E[%d].del(%d)\n&quot;,id,t);
		splay(t,0);
		if (!T[t].s[0]) {T[root=T[t].s[1]].fa=0;return;}
		if (!T[t].s[1]) {T[root=T[t].s[0]].fa=0;return;}
		int y=T[t].s[0];
		while (T[y].s[1]) y=T[y].s[1];
		splay(y,t);
		T[y].s[1]=T[t].s[1];
		T[T[t].s[1]].fa=y;
		root=y,T[y].fa=0;
		update(y);
	}
	void bianli(int t)
	{
		if (!t) return;
		pushdown(t);
		bianli(T[t].s[0]),bianli(T[t].s[1]);
	}
} E[NN+MM];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);
	int i;
	for (i=1;i&lt;=n;i++)
	{
		read(T[i].w),pos[i].in();
		b[++tot]=pos[i];
	}
	read(m);
	for (i=1;i&lt;=m;i++)
	{
		read(V[i]),go[i].in();
		b[++tot]=go[i];
	}
	sort(b+1,b+tot+1);
	int t=1;
	for (i=2;i&lt;=tot;i++)
		if (b[i]!=b[t]) b[++t]=b[i];
	tot=t;
	//printf(&quot;b:\n&quot;);for(i=1;i&lt;=tot;i++)printf(&quot;%d %d\n&quot;,b[i].x,b[i].y);ln;
	for (i=1;i&lt;=tot;i++) E[i].id=i;
	for(i=1;i&lt;=n;i++)
	{
		t=cha(pos[i]);
		E[t].ins(i);
		where[i]=t;
	}
	for (i=1;i&lt;=m;i++)
	{
		//printf(&quot;\n---------------------------------------------------------------------------\n&quot;);
		t=where[V[i]];
		E[t].del(V[i]);
		t=cha(go[i]);
		E[t].ins(V[i]);
		where[V[i]]=t;
	}
	for (i=1;i&lt;=tot;i++) E[i].bianli(E[i].root);
	for (i=1;i&lt;=n;i++)
		printf(&quot;%lld\n&quot;,(LL)T[i].ans1*T[i].ans2);
	return 0;
}<pre><h2>Problem2827</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int NN=30011,MM=301111;
int where[NN],V[MM];
int n,m,tot;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
	if (f) x=-x;
}
struct point
{
	int x,y;
	inline void in() {read(x),read(y);}
	friend bool operator !=(const point &amp;a,const point &amp;b) {return a.x!=b.x||a.y!=b.y;}
	friend bool operator ==(const point &amp;a,const point &amp;b) {return a.x==b.x&amp;&amp;a.y==b.y;}
	friend bool operator &lt;(const point &amp;a,const point &amp;b)
	{
		if (a.x!=b.x) return a.x&lt;b.x;
		return a.y&lt;b.y;
	}
} pos[NN],go[MM],b[NN+MM];
int cha(point a)
{
	int l=1,r=tot;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (b[mid]==a) return mid;
		if (a&lt;b[mid]) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
struct splaynode
{
	int fa,s[2],tag1,tag2,tmax,sz,w,ans1,ans2;
	inline void clear()
	{
		tag1=tag2=tmax=0;
		sz=1;
	}
	inline void make1(int x)
	{
		if (x&gt;tag1) tag1=x;
		if (x&gt;ans1) ans1=x;
	}
	inline void make2(int x)
	{
		if (x&gt;tag2) tag2=x;
		if (x&gt;ans2) ans2=x;
	}
} T[NN];
struct splaytree
{
	int root,id;
	inline void pushdown(int t)
	{
		int x=T[t].s[0],y=T[t].s[1];
		if (T[t].tag1)
		{
			if (x) T[x].make1(T[t].tag1);
			if (y) T[y].make1(T[t].tag1);
			T[t].tag1=0;
		}
		if (T[t].tag2)
		{
			if (x) T[x].make2(T[t].tag2);
			if (y) T[y].make2(T[t].tag2);
			T[t].tag2=0;
		}
	}
	inline void update(int t)
	{
		int x=T[t].s[0],y=T[t].s[1];
		T[t].tmax=max(T[t].w,max(T[x].tmax,T[y].tmax));
		T[t].sz=T[x].sz+T[y].sz+1;
	}
	inline void rotate(int t,int p)
	{
		int y=T[t].fa;
		pushdown(y),pushdown(t);
		if (T[y].fa)
		{
			if (y==T[T[y].fa].s[0]) T[T[y].fa].s[0]=t;
			else T[T[y].fa].s[1]=t;
		}
		T[t].fa=T[y].fa;
		T[y].s[p^1]=T[t].s[p];
		if (T[t].s[p]) T[T[t].s[p]].fa=y;
		T[t].s[p]=y;
		T[y].fa=t;
		update(y),update(t);
	}
	void splay(int t,int ff)
	{
		while (T[t].fa!=ff)
		{
			int y=T[t].fa;
			if (T[y].fa==ff)
				if (t==T[y].s[0]) rotate(t,1);
				else rotate(t,0);
			else
				if (y==T[T[y].fa].s[0])
					if (t==T[y].s[0]) rotate(y,1),rotate(t,1);
					else rotate(t,0),rotate(t,1);
				else
					if (t==T[y].s[1]) rotate(y,0),rotate(t,0);
					else rotate(t,1),rotate(t,0);
		}
		pushdown(t),update(t);
		if (ff==0) root=t;
	}
	void ins(int &amp;v,int t,int ff)
	{
		if (v==0)
		{
			v=t;
			T[t].fa=ff;
			T[t].s[0]=T[t].s[1]=0;
			T[t].clear();
			splay(t,0);
			return;
		}
		pushdown(v);
		if (t&lt;v) ins(T[v].s[0],t,v);
		else ins(T[v].s[1],t,v);
	}
	void ins(int t)
	{
		T[t].ans1=max(T[t].ans1,T[root].tmax);
		T[t].ans2=max(T[t].ans2,T[root].sz);
		T[root].make1(T[t].w);
		T[root].make2(T[root].sz);
		ins(root,t,0);
	}
	void del(int t)
	{
		splay(t,0);
		if (!T[t].s[0]) {T[root=T[t].s[1]].fa=0;return;}
		if (!T[t].s[1]) {T[root=T[t].s[0]].fa=0;return;}
		int y=T[t].s[0];
		while (T[y].s[1]) y=T[y].s[1];
		splay(y,t);
		T[y].s[1]=T[t].s[1];
		T[T[t].s[1]].fa=y;
		root=y,T[y].fa=0;
		update(y);
	}
	void bianli(int t)
	{
		if (!t) return;
		pushdown(t);
		bianli(T[t].s[0]),bianli(T[t].s[1]);
	}
} E[NN+MM];
int main()
{
	read(n);
	int i;
	for (i=1;i&lt;=n;i++)
	{
		read(T[i].w),pos[i].in();
		b[++tot]=pos[i];
	}
	read(m);
	for (i=1;i&lt;=m;i++)
	{
		read(V[i]),go[i].in();
		b[++tot]=go[i];
	}
	sort(b+1,b+tot+1);
	int t=1;
	for (i=2;i&lt;=tot;i++)
		if (b[i]!=b[t]) b[++t]=b[i];
	tot=t;
	for (i=1;i&lt;=tot;i++) E[i].id=i;
	for(i=1;i&lt;=n;i++)
	{
		t=cha(pos[i]);
		E[t].ins(i);
		where[i]=t;
	}
	for (i=1;i&lt;=m;i++)
	{
		t=where[V[i]];
		E[t].del(V[i]);
		t=cha(go[i]);
		E[t].ins(V[i]);
		where[V[i]]=t;
	}
	for (i=1;i&lt;=tot;i++) E[i].bianli(E[i].root);
	for (i=1;i&lt;=n;i++)
		printf(&quot;%lld\n&quot;,(LL)T[i].ans1*T[i].ans2);
	return 0;
}<pre><h2>Problem2829</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
typedef double DD;
const int NN=401111;
const DD eps=1e-8,pai=3.14159265358979;
int n,cnt;
DD A,B,R,ang[NN];
struct point
{
	DD x,y;
	point(DD a=0,DD b=0) {x=a,y=b;}
	void in() {scanf(&quot;%lf%lf&quot;,&amp;x,&amp;y);}
	void out() {printf(&quot;%.3f %.3f\n&quot;,x,y);}
	DD len() {return sqrt(x*x+y*y);}
	friend bool operator &lt;(point a,point b) {return fabs(a.x-b.x)&lt;eps?a.y-b.y&lt;-eps:a.x-b.x&lt;-eps;}
	friend point operator +(point a,point b) {a.x+=b.x;a.y+=b.y;return a;}
	friend point operator -(point a,point b) {a.x-=b.x;a.y-=b.y;return a;}
	friend DD operator %(point a,point b) {return a.x*b.y-b.x*a.y;}
} a[NN*4],b[NN*4];
point rotate(point a,DD sita)
{
	point tmp;
	tmp.x=a.x*cos(sita)-a.y*sin(sita);
	tmp.y=a.y*cos(sita)+a.x*sin(sita);
	return tmp;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	scanf(&quot;%lf%lf%lf&quot;,&amp;A,&amp;B,&amp;R);
	A-=2*R,B-=2*R;
	int i;
	for (i=1;i&lt;=n;i++)
	{
		point O;
		O.in();scanf(&quot;%lf&quot;,&amp;ang[i]);
		DD t1=B*0.5,t2=A*0.5;
		a[++cnt]=O+rotate(point(t1,t2),ang[i]);
		a[++cnt]=O+rotate(point(-t1,t2),ang[i]);
		a[++cnt]=O+rotate(point(-t1,-t2),ang[i]);
		a[++cnt]=O+rotate(point(t1,-t2),ang[i]);
	}
	//for (i=1;i&lt;=cnt;i++) a[i].out();ln;
	sort(a+1,a+cnt+1);
	int num=0;
	for (i=1;i&lt;=cnt;i++)
	{
		while (num&gt;1&amp;&amp;(b[num]-b[num-1])%(a[i]-b[num-1])&lt;eps) num--;
		b[++num]=a[i];
	}
	int t=num;
	for (i=cnt;i;i--)
	{
		while (num&gt;t&amp;&amp;(b[num]-b[num-1])%(a[i]-b[num-1])&lt;eps) num--;
		b[++num]=a[i];
	}
	//for (i=1;i&lt;num;i++) b[i].out();ln;
	DD ans=2*pai*R;
	for (i=1;i&lt;num;i++) ans+=(b[i+1]-b[i]).len();
	printf(&quot;%.2f\n&quot;,ans);
	return 0;
}<pre><h2>Problem2836</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
#define lc (v&lt;&lt;1)
#define rc (v&lt;&lt;1|1)
const int NN=101111;
int o[NN],aa[NN*2][2],size[NN],fa[NN],deep[NN],up[NN];
int st[NN],ed[NN],hea[NN];
int n,m,tot=1,cnt,ww,ee;
LL tsum[NN*4],tag[NN*4];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar()) x=x*10+ch-'0';
	if (f) x=-x;
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs1(int v)
{
	size[v]=1;
	int mm=0,tmp=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		dfs1(y);
		size[v]+=size[y];
		if (size[y]&gt;mm) mm=size[y],tmp=y;
	}
	hea[v]=tmp;
}
void dfs2(int v)
{
	st[v]=++cnt;
	if (hea[v])
	{
		up[hea[v]]=up[v];
		dfs2(hea[v]);
	}
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||y==hea[v]) continue;
		up[y]=y;
		dfs2(y);
	}
	ed[v]=cnt;
}
inline void add(int v,int l,int r,LL x)
{
	tag[v]+=x;
	tsum[v]+=x*(r-l);
}
inline void pushdown(int v,int l,int r,int mid)
{
	if (!tag[v]) return;
	add(lc,l,mid,tag[v]);
	add(rc,mid,r,tag[v]);
	tag[v]=0;
}
inline void update(int v)
{
	tsum[v]=tsum[lc]+tsum[rc];
}
void change(int v,int l,int r,LL x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		add(v,l,r,x);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	pushdown(v,l,r,mid);
	if (ww&lt;mid) change(lc,l,mid,x);
	if (ee&gt;mid) change(rc,mid,r,x);
	update(v);
}
LL find(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tsum[v];
	int mid=(l+r)&gt;&gt;1;LL res=0;
	pushdown(v,l,r,mid);
	if (ww&lt;mid) res+=find(lc,l,mid);
	if (ee&gt;mid) res+=find(rc,mid,r);
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y);
		x++,y++;
		addedge(x,y),addedge(y,x);
	}
	deep[1]=1;dfs1(1);
	up[1]=1;dfs2(1);
	for (read(m);m;m--)
	{
		char ch=getchar();
		while (ch!='A'&amp;&amp;ch!='Q') ch=getchar();
		if (ch=='A')
		{
			read(x),read(y),read(z);
			x++,y++;
			while (up[x]!=up[y])
			{
				if (deep[up[x]]&lt;deep[up[y]]) {int t=x;x=y;y=t;}
				ww=st[up[x]],ee=st[x]+1;
				change(1,1,n+1,z);
				x=fa[up[x]];
			}
			if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
			ww=st[y],ee=st[x]+1;
			change(1,1,n+1,z);
			x=fa[up[x]];
		}
		else
		{
			read(x);x++;
			ww=st[x],ee=ed[x]+1;
			LL res=find(1,1,n+1);
			printf(&quot;%lld\n&quot;,res);
		}
	}
	return 0;
}<pre><h2>Problem2836</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
#define ls (v&lt;&lt;1)
#define rs (v&lt;&lt;1|1)
#define ln printf(&quot;\n&quot;)
const int NN=100111;
int o[NN],aa[NN][2],size[NN],deep[NN],hea[NN],up[NN],st[NN],ed[NN],fa[NN];
int n,m,tot,cnt,ww,ee;
LL tag[NN&lt;&lt;2],tsum[NN&lt;&lt;2];
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);ln;}
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar());
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
}
inline void addedge(int p,int q)
{
	//printf(&quot;addedge %d %d\n&quot;,p,q);
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs1(int v)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		deep[y]=deep[v]+1;
		dfs1(y);
		size[v]+=size[y];
		if (size[y]&gt;size[hea[v]]) hea[v]=y;
	}
}
void dfs2(int v)
{
	st[v]=++cnt;
	if (hea[v])
	{
		up[hea[v]]=up[v];
		dfs2(hea[v]);
	}
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==hea[v]) continue;
		up[y]=y;
		dfs2(y);
	}
	ed[v]=cnt;
}
inline void add(int v,int l,int r,LL x)
{
	tag[v]+=x;
	tsum[v]+=x*(r-l);
}
inline void pushdown(int v,int l,int r,int mid)
{
	if (tag[v])
	{
		add(ls,l,mid,tag[v]);
		add(rs,mid,r,tag[v]);
		tag[v]=0;
	}
}
inline void update(int v)
{
	tsum[v]=tsum[ls]+tsum[rs];
}
void change(int v,int l,int r,int x)
{
	//printf(&quot;change %d %d %d %d\n&quot;,v,l,r,x);
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		add(v,l,r,x);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	pushdown(v,l,r,mid);
	if (ww&lt;mid) change(ls,l,mid,x);
	if (ee&gt;mid) change(rs,mid,r,x);
	update(v);
}
LL find(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tsum[v];
	int mid=(l+r)&gt;&gt;1;
	pushdown(v,l,r,mid);
	LL res=0;
	if (ww&lt;mid) res+=find(ls,l,mid);
	if (ee&gt;mid) res+=find(rs,mid,r);
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y);
		x++,y++;
		fa[y]=x;
		addedge(x,y);
	}
	deep[1]=1,dfs1(1);
	up[1]=1,dfs2(1);
	//printf(&quot;up &quot;);out(up,1,n);printf(&quot;st &quot;);out(st,1,n);printf(&quot;ed &quot;);out(ed,1,n);ln;
	for (read(m);m;m--)
	{
		char ch=getchar();
		while (ch!='A'&amp;&amp;ch!='Q') ch=getchar();
		if (ch=='A')
		{
			read(x),read(y),read(z);
			x++,y++;
			while (up[x]!=up[y])
			{
				if (deep[up[x]]&lt;deep[up[y]]) {int t=x;x=y;y=t;}
				ww=st[up[x]],ee=st[x]+1;
				change(1,1,n+1,z);
				x=fa[up[x]];
			}
			if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
			ww=st[y],ee=st[x]+1;
			change(1,1,n+1,z);
		}
		else
		{
			read(x);
			x++;
			ww=st[x],ee=ed[x]+1;
			printf(&quot;%lld\n&quot;,find(1,1,n+1));
		}
	}
	return 0;
}<pre><h2>Problem2839</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
#define mo 1000000007
int n,K;
LL fac[1001111],facinv[1001111],er[1001111];
LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
void shai()
{
	fac[0]=1;
	int i;
	for (i=1;i&lt;=n;i++)
		fac[i]=fac[i-1]*i%mo;
	facinv[n]=ksm(fac[n],mo-2,mo);
	for (i=n-1;i&gt;0;i--)
		facinv[i]=facinv[i+1]*(i+1)%mo;
	facinv[0]=1;
	er[0]=1;
	for (i=1;i&lt;=n;i++)
		er[i]=er[i-1]*2%(mo-1);
}
LL C(LL n,LL m)
{
	return fac[n]*facinv[m]%mo*facinv[n-m]%mo;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	shai();
	LL ans=0;
	//printf(&quot;%lld %lld\n&quot;,C(70,13),C(100,70));
	for (int i=n;i&gt;=K;i--)
	{
		LL tmp=C(i,K)*C(n,i)%mo*(ksm(2,er[n-i],mo)-1)%mo;
		if ((i-K)&amp;1) ans-=tmp;
		else ans+=tmp;
		ans%=mo;
		if (ans&lt;0) ans+=mo;
		//printf(&quot;i=%d %lld\n&quot;,i,ans);
	}
	if (ans&lt;0) ans+=mo;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem2844</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define mo 10086
int a[101111],er[101111];
int n,m,K;
void gause()
{
	m=0;int i,j;
	for (i=31;i;i--)
	{
		for (j=m+1;j&lt;=n;j++)
			if (a[j]&gt;&gt;(i-1)&amp;1) break;
		if (j==n+1) continue;
		m++;
		swap(a[j],a[m]);
		for (j=1;j&lt;=n;j++)
			if (j!=m&amp;&amp;(a[j]&gt;&gt;(i-1)&amp;1)) a[j]^=a[m];
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	er[0]=1;
	for (i=1;i&lt;=n;i++) er[i]=er[i-1]*2%mo;
	gause();
	scanf(&quot;%d&quot;,&amp;K);
	int now=0,ans=0;
	for (i=1;i&lt;=m;i++)
		if ((now^a[i])&lt;=K)
		{
			(ans+=er[m-i])%=mo;
			now^=a[i];
		}
	ans=(ans*er[n-m]+1)%mo;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem2875</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
LL n,m,a,c,g,X0;
inline LL mul(LL a,LL b)
{
	LL res=0;
	for (;b;b&gt;&gt;=1,a=(a+a)%m)
		if (b&amp;1) res=(res+a)%m;
	return res;
}
struct matrix
{
	LL mm[2][2];
	matrix() {memset(mm,0,sizeof(mm));}
	LL * operator [](int x) {return mm[x];}
	friend matrix operator *(matrix a,matrix b)
	{
		matrix c;
		for (int k=0;k&lt;2;k++)
			for (int i=0;i&lt;2;i++)
				for (int j=0;j&lt;2;j++)
					c[i][j]=(c[i][j]+mul(a[i][k],b[k][j]))%m;
		return c;
	}
	friend matrix operator ^(matrix a,LL b)
	{
		matrix res;
		res[0][0]=res[1][1]=1;
		for (;b;b&gt;&gt;=1,a=a*a)
			if (b&amp;1) res=res*a;
		return res;
	}
} A,B;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld%lld%lld%lld%lld%lld&quot;,&amp;m,&amp;a,&amp;c,&amp;X0,&amp;n,&amp;g);
	A[0][0]=a,A[1][0]=A[1][1]=1;
	A=A^n;
	B[0][0]=X0,B[0][1]=c;
	A=B*A;
	printf(&quot;%lld\n&quot;,A[0][0]%g);
	return 0;
}<pre><h2>Problem2876</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
#define sf scanf
#define pf printf
#define ps for(;;)
#define lp(i,a,b) for(int i=a;i&lt;=b;++i)
using namespace std;
int N; 
double E,S[10010],K[10010],Vw[10010]; 
double myabs(double a){ return a&lt;0?-a:a; } 
double calc(double phi,int f)
{ 
	double tmp=0; 
	lp(i,1,N)
	{ 
		double t=(max(Vw[i]/3.0*2,0.0)+1)*5,u; 
		while(myabs(u=(2*phi*K[i]*t*t*t-2*phi*K[i]*Vw[i]*t*t-1))&gt;1e-12) t=t-u/(6*phi*K[i]*t*t-4*phi*K[i]*Vw[i]*t); 
		if(f)tmp+=K[i]*(t-Vw[i])*(t-Vw[i])*S[i]; 
		else tmp+=S[i]/t; 
	} return tmp; 
} 
int main()
{ 
	sf(&quot;%d%lf&quot;,&amp;N,&amp;E); 
	lp(i,1,N)sf(&quot;%lf%lf%lf&quot;,&amp;S[i],&amp;K[i],&amp;Vw[i]); 
	double l=0,r=1; 
	while(calc(r,1)&gt;E)l=r,r*=2; 
	while(r-l&gt;1e-12)
	{ 
		if(calc((l+r)/2,1)&gt;E)l=(l+r)/2; 
		else r=(l+r)/2; 
	} 
	pf(&quot;%.12lf\n&quot;,calc(l,0)); //ps; return 0; 
}
<pre><h2>Problem2876</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
using namespace std;
int N; 
double E,S[10010],K[10010],Vw[10010]; 
double myabs(double a){ return a&lt;0?-a:a; } 
double calc(double phi,int f)
{ 
	double tmp=0; 
	for (int i=1;i&lt;=N;i++)
	{ 
		double t=(max(Vw[i]/3.0*2,0.0)+1)*5,u; 
		while(myabs(u=(2*phi*K[i]*t*t*t-2*phi*K[i]*Vw[i]*t*t-1))&gt;1e-12) t=t-u/(6*phi*K[i]*t*t-4*phi*K[i]*Vw[i]*t); 
		if(f)tmp+=K[i]*(t-Vw[i])*(t-Vw[i])*S[i]; 
		else tmp+=S[i]/t; 
	} return tmp; 
} 
int main()
{ 
	scanf(&quot;%d%lf&quot;,&amp;N,&amp;E); 
	for (int i=1;i&lt;=N;i++) scanf(&quot;%lf%lf%lf&quot;,&amp;S[i],&amp;K[i],&amp;Vw[i]); 
	double l=0,r=1; 
	while(calc(r,1)&gt;E)l=r,r*=2; 
	while(r-l&gt;1e-12)
	{ 
		if(calc((l+r)/2,1)&gt;E)l=(l+r)/2; 
		else r=(l+r)/2; 
	} 
	printf(&quot;%.12lf\n&quot;,calc(l,0)); //ps; return 0; 
}
<pre><h2>Problem2876</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
const int MAXN=10010;
typedef double ld;int n;
ld eu,s[MAXN],k[MAXN],v[MAXN],l,r,mid,t,eps=1e-12;
ld max(ld a,ld b){return a&gt;b?a:b;}
ld getx(int i,ld lmd)
{
    ld a=2.0*lmd*k[i],b=2.0*lmd*k[i]*v[i];
    ld t=max(0,v[i]*2.0/3.0)+1,u;
    for(;std::abs(u=(a*t-b)*t*t-1)&gt;eps;t-=u/((3*a*t-2*b)*t));
    return t;
}
bool check(ld lmd)
{
    ld f=0,x;t=0;
    for(int i=1;i&lt;=n;i++)
    {
        x=getx(i,lmd);
        f+=k[i]*s[i]*(x-v[i])*(x-v[i]);
        t+=s[i]/x;
    }
    return f&gt;eu;
}
int main()
{
    scanf(&quot;%d%lf&quot;,&amp;n,&amp;eu);int i;
    for(i=1;i&lt;=n;i++)scanf(&quot;%lf%lf%lf&quot;,&amp;s[i],&amp;k[i],&amp;v[i]);
    for(l=0,r=1;check(r);l=r,r*=2);
    for(;r-l&gt;eps;check(mid=(l+r)/2)?l=mid:r=mid);
    printf(&quot;%lf\n&quot;,t);
}
<pre><h2>Problem2876</h2><pre>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;


    
#define abs(x) ((x)&gt;=0?(x):-(x))
#define i64 long long
#define u32 unsigned int
#define u64 unsigned long long
#define clr(x,y) memset(x,y,sizeof(x))
#define CLR(x) x.clear()
#define ph(x) push(x)
#define pb(x) push_back(x)
#define Len(x) x.length()
#define SZ(x) x.size()
#define PI acos(-1.0)
#define sqr(x) ((x)*(x))
#define MP(x,y) make_pair(x,y)
#define EPS 1e-10
    
    
#define FOR0(i,x) for(i=0;i&lt;x;i++)
#define FOR1(i,x) for(i=1;i&lt;=x;i++)
#define FOR(i,a,b) for(i=a;i&lt;=b;i++)
#define FORL0(i,a) for(i=a;i&gt;=0;i--)
#define FORL1(i,a) for(i=a;i&gt;=1;i--)
#define FORL(i,a,b)for(i=a;i&gt;=b;i--)
    
    
#define rush() int CC;for(scanf(&quot;%d&quot;,&amp;CC);CC--;)
#define Rush(n)  while(scanf(&quot;%d&quot;,&amp;n)!=-1)
using namespace std;

    
void RD(int &amp;x){scanf(&quot;%d&quot;,&amp;x);}
void RD(i64 &amp;x){scanf(&quot;%lld&quot;,&amp;x);}
void RD(u64 &amp;x){scanf(&quot;%I64u&quot;,&amp;x);}
void RD(u32 &amp;x){scanf(&quot;%u&quot;,&amp;x);}
void RD(double &amp;x){scanf(&quot;%lf&quot;,&amp;x);}
void RD(int &amp;x,int &amp;y){scanf(&quot;%d%d&quot;,&amp;x,&amp;y);}
void RD(i64 &amp;x,i64 &amp;y){scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y);}
void RD(u32 &amp;x,u32 &amp;y){scanf(&quot;%u%u&quot;,&amp;x,&amp;y);}
void RD(double &amp;x,double &amp;y){scanf(&quot;%lf%lf&quot;,&amp;x,&amp;y);}
void RD(double &amp;x,double &amp;y,double &amp;z){scanf(&quot;%lf%lf%lf&quot;,&amp;x,&amp;y,&amp;z);}
void RD(int &amp;x,int &amp;y,int &amp;z){scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);}
void RD(i64 &amp;x,i64 &amp;y,i64 &amp;z){scanf(&quot;%lld%lld%lld&quot;,&amp;x,&amp;y,&amp;z);}
void RD(u32 &amp;x,u32 &amp;y,u32 &amp;z){scanf(&quot;%u%u%u&quot;,&amp;x,&amp;y,&amp;z);}
void RD(char &amp;x){x=getchar();}
void RD(char *s){scanf(&quot;%s&quot;,s);}
void RD(string &amp;s){cin&gt;&gt;s;}
    
    
void PR(int x) {printf(&quot;%d\n&quot;,x);}
void PR(int x,int y) {printf(&quot;%d %d\n&quot;,x,y);}
void PR(i64 x) {printf(&quot;%lld\n&quot;,x);}
void PR(i64 x,i64 y) {printf(&quot;%lld %lld\n&quot;,x,y);}
void PR(u32 x) {printf(&quot;%u\n&quot;,x);}
void PR(u64 x) {printf(&quot;%llu\n&quot;,x);}
void PR(double x) {printf(&quot;%.10lf\n&quot;,x);}
void PR(double x,double y) {printf(&quot;%.5lf %.5lf\n&quot;,x,y);}
void PR(char x) {printf(&quot;%c\n&quot;,x);}
void PR(char *x) {printf(&quot;%s\n&quot;,x);}
void PR(string x) {cout&lt;&lt;x&lt;&lt;endl;}


void upMin(int &amp;x,int y) {if(x&gt;y) x=y;}
void upMin(i64 &amp;x,i64 y) {if(x&gt;y) x=y;}
void upMin(double &amp;x,double y) {if(x&gt;y) x=y;}
void upMax(int &amp;x,int y) {if(x&lt;y) x=y;}
void upMax(i64 &amp;x,i64 y) {if(x&lt;y) x=y;}
void upMax(double &amp;x,double y) {if(x&lt;y) x=y;}
    
const int mod=19940417;
const i64 inf=((i64)1)&lt;&lt;60;
const double dinf=1e10;
const int INF=100000000;
const int N=10005;


int n;
double E,s[N],v[N],k[N],maxV[N],V[N];


double cal(double t,double k,double v,double low,double high)
{
    double mid,temp;
    while(high-low&gt;EPS)
    {
        mid=(low+high)/2;
        temp=2*t*k*(mid-v)*mid*mid+1;
        if(temp&gt;0.0) low=mid;
        else high=mid;
    }
    return low;
}


int main()
{
    RD(n); RD(E);
    int i,j;
    FOR1(i,n)
    {
        RD(s[i],k[i],v[i]);
        if(s[i]&gt;0) maxV[i]=sqrt(E/s[i]/k[i])+v[i];
        else maxV[i]=v[i];
    }
    double low=-1,high=0,mid,sum;
    FOR0(i,80)
    {
        mid=(low+high)/2;
        sum=0;
        FOR1(j,n)
        {
            V[j]=cal(mid,k[j],v[j],max(v[j],0.0000001),maxV[j]);
            sum+=s[j]*k[j]*sqr(V[j]-v[j]);
        }
        if(sum&gt;E) high=mid;
        else low=mid;
    }
    double ans=0;
    FOR1(i,n) ans+=s[i]/V[i];
    PR(ans);
}
<pre><h2>Problem2876</h2><pre>#include&lt;stdio.h&gt;
const int MAXN=10000+9;
const double EPS=1e-9;
int n;
double k[MAXN],v1[MAXN],v[MAXN];
void calc(double lambda)
{
        for(int i=0;i&lt;n;++i)
        {
                double l=v1[i],r=1e20;
                for(int c=0;c&lt;130;++c)
                {
                        double m=(l+r)*0.5;
                        (k[i]*m*m*(m-v1[i])&lt;lambda?l:r)=m;
                }
                v[i]=l;
        }
}
double s[MAXN],kms[MAXN];
int main()
{
        int i,c;
        double e;
        scanf(&quot;%d%lf&quot;,&amp;n,&amp;e);
        for(i=0;i&lt;n;++i)
        {
                scanf(&quot;%lf%lf%lf&quot;,s+i,k+i,v1+i);
                kms[i]=k[i]*s[i];
        }
        double l=0,r=1e9;
        for(c=0;c&lt;90;++c)
        {
                double m=(l+r)*0.5,sum=0;
                calc(m);
                for(i=0;i&lt;n;++i)
                        sum+=kms[i]*(v[i]-v1[i])*(v[i]-v1[i]);
                (sum&lt;e?l:r)=m;
        }
        double ans=0;
        for(i=0;i&lt;n;++i)
                ans+=s[i]/v[i];
        printf(&quot;%lf\n&quot;,ans);
        return 0;
}
<pre><h2>Problem2876</h2><pre>#include&lt;stdio.h&gt;
const int MAXN=10000+9;
const double EPS=1e-9;
int n;
double k[MAXN],v1[MAXN],v[MAXN];
void calc(double lambda)
{
        for(int i=0;i&lt;n;++i)
        {
                double l=v1[i],r=1e20;
                for(int c=0;c&lt;130;++c)
                {
                        double m=(l+r)*0.5;
                        (k[i]*m*m*(m-v1[i])&lt;lambda?l:r)=m;
                }
                v[i]=l;
        }
}
double s[MAXN],kms[MAXN];
int main()
{
        int i,c;
        double e;
        scanf(&quot;%d%lf&quot;,&amp;n,&amp;e);
        for(i=0;i&lt;n;++i)
        {
                scanf(&quot;%lf%lf%lf&quot;,s+i,k+i,v1+i);
                kms[i]=k[i]*s[i];
        }
        double l=0,r=1e15;
        for(c=0;c&lt;90;++c)
        {
                double m=(l+r)*0.5,sum=0;
                calc(m);
                for(i=0;i&lt;n;++i)
                        sum+=kms[i]*(v[i]-v1[i])*(v[i]-v1[i]);
                (sum&lt;e?l:r)=m;
        }
        double ans=0;
        for(i=0;i&lt;n;++i)
                ans+=s[i]/v[i];
        printf(&quot;%lf\n&quot;,ans);
        return 0;
}
<pre><h2>Problem2876</h2><pre>#include&lt;stdio.h&gt;
const int MAXN=10000+9;
const double EPS=1e-9;
int n;
double k[MAXN],v1[MAXN],v[MAXN];
void calc(double lambda)
{
        for(int i=0;i&lt;n;++i)
        {
                double l=v1[i],r=1e20;
                for(int c=0;c&lt;130;++c)
                {
                        double m=(l+r)*0.5;
                        (k[i]*m*m*(m-v1[i])&lt;lambda?l:r)=m;
                }
                v[i]=l;
        }
}
double s[MAXN],kms[MAXN];
int main()
{
        int i,c;
        double e;
        scanf(&quot;%d%lf&quot;,&amp;n,&amp;e);
        for(i=0;i&lt;n;++i)
        {
                scanf(&quot;%lf%lf%lf&quot;,s+i,k+i,v1+i);
                kms[i]=k[i]*s[i];
        }
        double l=0,r=1e15;
        while (r-l&gt;0.000000001)
        {
                double m=(l+r)*0.5,sum=0;
                calc(m);
                for(i=0;i&lt;n;++i)
                        sum+=kms[i]*(v[i]-v1[i])*(v[i]-v1[i]);
                (sum&lt;e?l:r)=m;
        }
        double ans=0;
        for(i=0;i&lt;n;++i)
                ans+=s[i]/v[i];
        printf(&quot;%lf\n&quot;,ans);
        return 0;
}
<pre><h2>Problem2876</h2><pre>#include&lt;stdio.h&gt;
const int MAXN=10000+9;
const double EPS=1e-9;
int n;
double k[MAXN],v1[MAXN],v[MAXN];
void calc(double lambda)
{
        for(int i=0;i&lt;n;++i)
        {
                double l=v1[i],r=1e20;
                for(int c=0;c&lt;130;++c)
                {
                        double m=(l+r)*0.5;
                        (k[i]*m*m*(m-v1[i])&lt;lambda?l:r)=m;
                }
                v[i]=l;
        }
}
double s[MAXN],kms[MAXN];
int main()
{
        int i,c;
        double e;
        scanf(&quot;%d%lf&quot;,&amp;n,&amp;e);
        for(i=0;i&lt;n;++i)
        {
                scanf(&quot;%lf%lf%lf&quot;,s+i,k+i,v1+i);
                kms[i]=k[i]*s[i];
        }
        double l=0,r=1e15;
        while (r-l&gt;0.1e-8)
        {
                double m=(l+r)*0.5,sum=0;
                calc(m);
                for(i=0;i&lt;n;++i)
                        sum+=kms[i]*(v[i]-v1[i])*(v[i]-v1[i]);
                (sum&lt;e?l:r)=m;
        }
        double ans=0;
        for(i=0;i&lt;n;++i)
                ans+=s[i]/v[i];
        printf(&quot;%lf\n&quot;,ans);
        return 0;
}
<pre><h2>Problem2876</h2><pre>#include&lt;stdio.h&gt;
const int MAXN=10000+9;
const double EPS=1e-9;
int n;
double k[MAXN],v1[MAXN],v[MAXN];
void calc(double lambda)
{
        for(int i=0;i&lt;n;++i)
        {
                double l=v1[i],r=1e20;
                while (r-l&gt;1e-11)
                {
                        double m=(l+r)*0.5;
                        (k[i]*m*m*(m-v1[i])&lt;lambda?l:r)=m;
                }
                v[i]=l;
        }
}
double s[MAXN],kms[MAXN];
int main()
{
        int i,c;
        double e;
        scanf(&quot;%d%lf&quot;,&amp;n,&amp;e);
        for(i=0;i&lt;n;++i)
        {
                scanf(&quot;%lf%lf%lf&quot;,s+i,k+i,v1+i);
                kms[i]=k[i]*s[i];
        }
        double l=0,r=1e15;
        while (r-l&gt;0.1e-8)
        {
                double m=(l+r)*0.5,sum=0;
                calc(m);
                for(i=0;i&lt;n;++i)
                        sum+=kms[i]*(v[i]-v1[i])*(v[i]-v1[i]);
                (sum&lt;e?l:r)=m;
        }
        double ans=0;
        for(i=0;i&lt;n;++i)
                ans+=s[i]/v[i];
        printf(&quot;%lf\n&quot;,ans);
        return 0;
}
<pre><h2>Problem2876</h2><pre>#include&lt;stdio.h&gt;
const int MAXN=10000+9;
const double EPS=1e-9;
int n;
double k[MAXN],v1[MAXN],v[MAXN];
void calc(double lambda)
{
        for(int i=0;i&lt;n;++i)
        {
                double l=v1[i],r=1e15;
                while (r-l&gt;1e-11)
                {
                        double m=(l+r)*0.5;
                        (k[i]*m*m*(m-v1[i])&lt;lambda?l:r)=m;
                }
                v[i]=l;
        }
}
double s[MAXN],kms[MAXN];
int main()
{
        int i,c;
        double e;
        scanf(&quot;%d%lf&quot;,&amp;n,&amp;e);
        for(i=0;i&lt;n;++i)
        {
                scanf(&quot;%lf%lf%lf&quot;,s+i,k+i,v1+i);
                kms[i]=k[i]*s[i];
        }
        double l=0,r=1e15;
        while (r-l&gt;0.1e-8)
        {
                double m=(l+r)*0.5,sum=0;
                calc(m);
                for(i=0;i&lt;n;++i)
                        sum+=kms[i]*(v[i]-v1[i])*(v[i]-v1[i]);
                (sum&lt;e?l:r)=m;
        }
        double ans=0;
        for(i=0;i&lt;n;++i)
                ans+=s[i]/v[i];
        printf(&quot;%lf\n&quot;,ans);
        return 0;
}
<pre><h2>Problem2876</h2><pre>#include&lt;stdio.h&gt;
const int MAXN=10000+9;
const double EPS=1e-9;
int n;
double k[MAXN],v1[MAXN],v[MAXN];
void calc(double lambda)
{
        for(int i=0;i&lt;n;++i)
        {
                double l=v1[i],r=1e20;
                for(int c=0;c&lt;200;++c)
                {
                        double m=(l+r)*0.5;
                        (k[i]*m*m*(m-v1[i])&lt;lambda?l:r)=m;
                }
                v[i]=l;
        }
}
double s[MAXN],kms[MAXN];
int main()
{
        int i,c;
        double e;
        scanf(&quot;%d%lf&quot;,&amp;n,&amp;e);
        for(i=0;i&lt;n;++i)
        {
                scanf(&quot;%lf%lf%lf&quot;,s+i,k+i,v1+i);
                kms[i]=k[i]*s[i];
        }
        double l=0,r=1e15;
        while (r-l&gt;0.1e-8)
        {
                double m=(l+r)*0.5,sum=0;
                calc(m);
                for(i=0;i&lt;n;++i)
                        sum+=kms[i]*(v[i]-v1[i])*(v[i]-v1[i]);
                (sum&lt;e?l:r)=m;
        }
        double ans=0;
        for(i=0;i&lt;n;++i)
                ans+=s[i]/v[i];
        printf(&quot;%lf\n&quot;,ans);
        return 0;
}
<pre><h2>Problem2876</h2><pre>#include&lt;stdio.h&gt;
const int MAXN=10000+9;
const double EPS=1e-9;
int n;
double k[MAXN],v1[MAXN],v[MAXN];
void calc(double lambda)
{
        for(int i=0;i&lt;n;++i)
        {
                double l=v1[i],r=1e9;
                for(int c=0;c&lt;200;++c)
                {
                        double m=(l+r)*0.5;
                        (k[i]*m*m*(m-v1[i])&lt;lambda?l:r)=m;
                }
                v[i]=l;
        }
}
double s[MAXN],kms[MAXN];
int main()
{
        int i,c;
        double e;
        scanf(&quot;%d%lf&quot;,&amp;n,&amp;e);
        for(i=0;i&lt;n;++i)
        {
                scanf(&quot;%lf%lf%lf&quot;,s+i,k+i,v1+i);
                kms[i]=k[i]*s[i];
        }
        double l=0,r=1e15;
        while (r-l&gt;0.1e-8)
        {
                double m=(l+r)*0.5,sum=0;
                calc(m);
                for(i=0;i&lt;n;++i)
                        sum+=kms[i]*(v[i]-v1[i])*(v[i]-v1[i]);
                (sum&lt;e?l:r)=m;
        }
        double ans=0;
        for(i=0;i&lt;n;++i)
                ans+=s[i]/v[i];
        printf(&quot;%lf\n&quot;,ans);
        return 0;
}
<pre><h2>Problem2876</h2><pre>#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
const double eps=1e-9;
const int maxn=10011;
double E,v[maxn],s[maxn],k[maxn],ans,left,right,mid,sum,aans,sum2;
int n;
double newton(double xx,double yy)
{
    yy*=xx;
    double last=99999,now;
    while (1)
    {
        now=last-(xx*last*last*last-yy*last*last-1)/(3*xx*last*last-2*yy*last);
        if (fabs(now-last)&lt;=eps) return now;
        last=now;
    }
}
int main()
{
    scanf(&quot;%d%lf&quot;,&amp;n,&amp;E);
    int i,j;
    for (i=1;i&lt;=n;i++) scanf(&quot;%lf%lf%lf&quot;,&amp;s[i],&amp;k[i],&amp;v[i]);
    left=0,right=99999;
    while (right-left&gt;1e-12)
    {
        mid=(left+right)/2;
        sum=sum2=0;
        for (i=1;i&lt;=n;i++)
        {
            ans=newton(2*mid*k[i],v[i]);
            sum+=s[i]/ans;
            sum2+=s[i]*k[i]*(ans-v[i])*(ans-v[i]);
        }
        if (E-sum2&gt;-eps) aans=sum,right=mid; else left=mid;
    }
    printf(&quot;%.8f\n&quot;,aans);
    return 0;
}
<pre><h2>Problem2876</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int n,i;
double s[110001],k[110001],v[110001],Eu;
double abs(double x) {return x&gt;0?x:-x;}
double newton(int i,double lanbda,double y)
{
	double last=99999,now;
	for (;;)
	{
		now=last-(2*lanbda*k[i]*last*last*last-2*lanbda*k[i]*last*last*y-1)/(6*lanbda*k[i]*last*last-4*lanbda*k[i]*last*y);
		if (abs(now-last)&lt;=1e-9) return now;
		last=now;
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%lf&quot;,&amp;n,&amp;Eu);
	for (i=1;i&lt;=n;i++) scanf(&quot;%lf%lf%lf&quot;,&amp;s[i],&amp;k[i],&amp;v[i]);
	double l=0,r=9999,ans;
	for (int TIME=0;TIME&lt;=200;TIME++)
	{
		double mid=(r+l)/2,sum1=0,sum2=0;
		for (int i=1;i&lt;=n;i++)
		{
			double res=newton(i,mid,v[i]);
			sum1+=s[i]/res;
			sum2+=s[i]*k[i]*(res-v[i])*(res-v[i]);
		}
		if (sum2&lt;=Eu) ans=sum1,r=mid;
		else l=mid;
	}
	printf(&quot;%lf\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2876</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int n,i;
double s[110001],k[110001],v[110001],Eu;
double abs(double x) {return x&gt;0?x:-x;}
double newton(int i,double lanbda,double y)
{
	double last=99999,now;
	for (;;)
	{
		now=last-(2*lanbda*k[i]*last*last*last-2*lanbda*k[i]*last*last*y-1)/(6*lanbda*k[i]*last*last-4*lanbda*k[i]*last*y);
		if (abs(now-last)&lt;=1e-9) return now;
		last=now;
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%lf&quot;,&amp;n,&amp;Eu);
	for (i=1;i&lt;=n;i++) scanf(&quot;%lf%lf%lf&quot;,&amp;s[i],&amp;k[i],&amp;v[i]);
	double l=0,r=1e9,ans;
	for (int TIME=0;TIME&lt;=200;TIME++)
	{
		double mid=(r+l)/2,sum1=0,sum2=0;
		for (int i=1;i&lt;=n;i++)
		{
			double res=newton(i,mid,v[i]);
			sum1+=s[i]/res;
			sum2+=s[i]*k[i]*(res-v[i])*(res-v[i]);
		}
		if (sum2&lt;=Eu) ans=sum1,r=mid;
		else l=mid;
	}
	printf(&quot;%lf\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2879</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
using namespace std;
const int inf=99999999;
int aa[30000000][4],o[300000],dist[300000],pre[300000],P[300000];
int t[2000][2000],q[3000000],cnt[300000],belong[300000],last[300000];
int n,m,ans,tot,S,T,head,tail,sum,i,j,now;
bool dl[300000];
int min(int a,int b) {return a&lt;b?a:b;}
void add(int p,int q,int v,int cost)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][3]=cost;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void addedge(int p,int q,int v,int cost)
{
	//printf(&quot;addedge:    %d %d %d %d\n&quot;,p,q,v,cost);
	add(p,q,v,cost);
	add(q,p,0,-cost);
}
void init()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;P[i]),sum+=P[i];
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;t[i][j]);
	S=n+m+1,T=S+1;
	now=T;
	tot=1;
	for (i=1;i&lt;=m;i++)
	{
		belong[i]=i;
		last[i]=i;
		cnt[i]=1;
		addedge(S,i,1,0);
		for (j=1;j&lt;=n;j++) addedge(i,j+m,1,t[j][i]);
	}
	for (i=1;i&lt;=n;i++) addedge(i+m,T,P[i],0);
}
bool relax(int x,int y,int v)
{
	if (dist[y]&gt;dist[x]+v)
	{
		dist[y]=dist[x]+v;
		return 1;
	}
	return 0;
}
bool spfa()
{
	head=tail=0;
	memset(dist,127,sizeof(dist[0])*(now+10));
	memset(dl,0,sizeof(dl[0])*(now+10));
	dist[S]=0;
	q[++tail]=S;
	dl[S]=1;
	while (head&lt;tail)
	{
		int x=q[++head];
		dl[x]=0;
		int p=o[x];
		while (p)
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;relax(x,y,aa[p][3]))
			{
				pre[y]=p;
				if (!dl[y]) q[++tail]=y,dl[y]=1;
			}
			p=aa[p][0];
		}
	}
	return dist[T]&lt;dist[0];
}
void addcost()
{
	int p=pre[T],flow=inf;
	while (p)
	{
		flow=min(flow,aa[p][2]);
		p=pre[aa[p^1][1]];
	}
	p=pre[T];
	while (p)
	{
		ans+=flow*aa[p][3];
		aa[p][2]-=flow;
		aa[p^1][2]+=flow;
		p=pre[aa[p^1][1]];
	}
}
void doit()
{
	for (;sum;sum--)
	{
		//printf(&quot;\n-----------------------------------------------------------------------------------\n&quot;);
		spfa();
		//for (int i=1;i&lt;=T;i++) printf(&quot;%d &quot;,dist[i]);printf(&quot;\n&quot;);
		addcost();
		int x,p=o[S],y=-1;
		while (p)
		{
			y=aa[p][1];
			if (last[belong[y]]==y&amp;&amp;aa[p][2]==0) break;
			p=aa[p][0];
		}
		x=belong[y];
		++cnt[x];
		int tmp=++now;
		last[x]=tmp;
		belong[tmp]=x;
		addedge(S,tmp,1,0);
		for (i=1;i&lt;=n;i++) addedge(tmp,i+m,1,t[i][x]*cnt[x]);
		//printf(&quot;%d\n&quot;,ans);
	}
	//printf(&quot;\n\nAt last:\n&quot;);
	printf(&quot;%d\n&quot;,ans);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	init();
	doit();
	return 0;
}
<pre><h2>Problem2882</h2><pre>#include&lt;cstdio&gt;
#include&lt;map&gt;
using namespace std;
#define fi first
#define se second
const int NN=1001111;
int pre[NN],val[NN],a[NN];
int n,last,TTT;
map&lt;int,int&gt; son[NN];
map&lt;int,int&gt;::iterator it;
void samadd(int x)
{
	int end=++TTT,p=last;
	last=end;
	val[end]=val[p]+1;
	for (;p!=-1&amp;&amp;!son[p].count(x);p=pre[p]) son[p][x]=end;
	if (p==-1) {pre[end]=0;return;}
	int q=son[p][x];
	if (val[q]==val[p]+1) {pre[end]=q;return;}
	int nq=++TTT;
	pre[nq]=pre[q];
	pre[q]=pre[end]=nq;
	for (it=son[q].begin();it!=son[q].end();it++)
		son[nq][(*it).fi]=(*it).se;
	for (;p!=-1&amp;&amp;son[p][x]==q;p=pre[p]) son[p][x]=nq;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	pre[0]=-1;
	int i,x;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		samadd(a[i]);
	}
	for (i=1;i&lt;n;i++) samadd(a[i]);
	x=0;
	for (i=1;i&lt;=n;i++)
	{
		it=son[x].begin();
		printf((i==n)?&quot;%d\n&quot;:&quot;%d &quot;,(*it).fi);
		x=(*it).se;
	}
	return 0;
}<pre><h2>Problem2916</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
int n,m,num[1005];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		num[x]++,num[y]++;
	}
	LL ans=(LL)n*(n-1)*(n-2)/6;
	LL tmp=0;
	for (i=1;i&lt;=n;i++)
		tmp+=(LL)num[i]*(n-num[i]-1);
	ans-=tmp&gt;&gt;1;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem2938</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int AA=31111;
int son[AA][2],q[AA],fail[AA],du[AA],o[AA],aa[AA*4][2],sta[AA];
int n,tot=1,TTT,top;
bool flag[AA];
char s[AA];
void ACins(int l)
{
	int now=1;
	for (int i=1;i&lt;=l;i++)
	{
		int t=s[i]-'0';
		if (son[now][t]) now=son[now][t];
		else now=son[now][t]=++TTT;
	}
	flag[now]=true;
}
void buildfail()
{
	int head=0,tail=1;
	q[1]=1;
	while (head&lt;tail)
	{
		int x=q[++head];
		flag[x]|=flag[fail[x]];
		for (int i=0;i&lt;=1;i++)
			if (!son[x][i]) son[x][i]=son[fail[x]][i];
			else
			{
				fail[son[x][i]]=son[fail[x]][i];
				q[++tail]=son[x][i];
			}
	}
}
void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
	du[q]++;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d\n&quot;,&amp;n);
	int i;
	for (i=0;i&lt;=1;i++) son[0][i]=1,son[1][i]=0;
	TTT=1;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s\n&quot;,s+1);
		ACins(strlen(s+1));
	}
	buildfail();
	//for (i=1;i&lt;=TTT;i++) printf(&quot;%d %d\n&quot;,son[i][0],son[i][1]);
	int m=TTT;
	for (i=1;i&lt;=m;i++) if (!flag[i])
	{
		if (!flag[son[i][0]]) addedge(i,son[i][0]);
		if (!flag[son[i][1]]) addedge(i,son[i][1]);
	}
	for (i=1;i&lt;=m;i++)
		if (du[i]==0) sta[++top]=i;
	while (top)
	{
		int x=sta[top--];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (--du[y]==0) sta[++top]=y;
		}
	}
	for (i=1;i&lt;=m;i++)
		if (du[i]) {printf(&quot;TAK\n&quot;);return 0;}
	printf(&quot;NIE\n&quot;);
	return 0;
}<pre><h2>Problem2938</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define NN 30100
using namespace std;
int n,cnt=1,son[NN][2],num[NN],q[NN],fail[NN];
bool f[NN],vis[NN];
char st[30009];
void insert(char *s,int k)
{
	int l=strlen(s);
	int now=1;
	for (int i=0;i&lt;l;i++)
	{
		int t=s[i]-'0';
		if (!son[now][t])
			son[now][t]=++cnt;
		now=son[now][t];
	}
	num[now]=1;
}

void acmach()
{
	int now=1;
	int l=0,r=1;
	q[1]=1;
	fail[1]=0;
	while(l&lt;r)
	{
		int now=q[++l];
		num[now]|=num[fail[now]];
		for (int i=0;i&lt;2;i++)		
			if (son[now][i])
			{
				q[++r]=son[now][i];
				int p=fail[now];
				while(!son[p][i])p=fail[p];
				fail[son[now][i]]=son[p][i];
			}
			else son[now][i]=son[fail[now]][i];
	}
}

bool dfs(int x)
{
	f[x]=vis[x]=1;
	for (int i=0;i&lt;2;i++)
	{
		int y=son[x][i];
		if (f[y])return 1;
		if(num[y]||vis[y])continue;
		if (dfs(y))return 1;
	}
	f[x]=0;
	return 0;
}

int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	son[0][0]=son[0][1]=1;
	scanf(&quot;%d&quot;,&amp;n);
	for (int i=1;i&lt;=n;i++)
		scanf(&quot;%s&quot;,st),insert(st,i);
	acmach();
	if (dfs(1))printf(&quot;TAK\n&quot;);
	else printf(&quot;NIE\n&quot;);
	return 0;
}<pre><h2>Problem2938</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define NN 30100
using namespace std;
int n,cnt=1,son[NN][2],num[NN],q[NN],fail[NN];
bool f[NN],vis[NN];
char st[30009];
void insert(char *s,int k)
{
	int l=strlen(s);
	int now=1;
	for (int i=0;i&lt;l;i++)
	{
		int t=s[i]-'0';
		if (!son[now][t])
			son[now][t]=++cnt;
		now=son[now][t];
	}
	num[now]=1;
}

void acmach()
{
	int now=1;
	int l=0,r=1;
	q[1]=1;
	fail[1]=0;
	while(l&lt;r)
	{
		int now=q[++l];
		num[now]|=num[fail[now]];
		for (int i=0;i&lt;2;i++)		
			if (son[now][i])
			{
				q[++r]=son[now][i];
				int p=fail[now];
				while(!son[p][i])p=fail[p];
				fail[son[now][i]]=son[p][i];
			}
			else son[now][i]=son[fail[now]][i];
	}
}

bool dfs(int x)
{
	f[x]=vis[x]=1;
	for (int i=0;i&lt;2;i++)
	{
		int y=son[x][i];
		if (f[y])return 1;
		if(num[y]||vis[y])continue;
		if (dfs(y))return 1;
	}
	f[x]=0;
	return 0;
}

int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	son[0][0]=son[0][1]=1;
	scanf(&quot;%d&quot;,&amp;n);
	for (int i=1;i&lt;=n;i++)
		scanf(&quot;%s&quot;,st),insert(st,i);
	acmach();
	if (dfs(1))printf(&quot;TAK&quot;);
	else printf(&quot;NIE&quot;);
	return 0;
}<pre><h2>Problem2938</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define NN 30100
using namespace std;
int n,cnt=1,son[NN][2],num[NN],q[NN],fail[NN];
bool f[NN],vis[NN];
char st[30009];
void insert(char *s,int k)
{
    int l=strlen(s);
    int now=1;
    for (int i=0;i&lt;l;i++)
    {
        int t=s[i]-'0';
        if (!son[now][t])
            son[now][t]=++cnt;
        now=son[now][t];
    }
    num[now]++;
}
 
void acmach()
{
    int now=1;
    int l=0,r=1;
    q[1]=1;
    fail[1]=0;
    while(l&lt;r)
    {
        int now=q[++l];
        num[now]+=num[fail[now]];
        for (int i=0;i&lt;2;i++)        
            if (son[now][i])
            {
                q[++r]=son[now][i];
                int p=fail[now];
                while(!son[p][i])p=fail[p];
                fail[son[now][i]]=son[p][i];
            }
            else son[now][i]=(fail[now])?son[fail[now]][i]:1;
    }
}
 
bool dfs(int x)
{
    f[x]=vis[x]=1;
    for (int i=0;i&lt;2;i++)
    {
        int y=son[x][i];
        if (f[y])return 1;
        if(num[y]||vis[y])continue;
        if (dfs(y))return 1;
    }
    f[x]=0;
    return 0;
}
 
int main()
{
 // freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
    son[0][0]=son[0][1]=1;
    scanf(&quot;%d&quot;,&amp;n);
    for (int i=1;i&lt;=n;i++)
        scanf(&quot;%s&quot;,st),insert(st,i);
    acmach();
    if (dfs(1))printf(&quot;TAK&quot;);
    else printf(&quot;NIE&quot;);
    return 0;
}<pre><h2>Problem2946</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=201111;
int pre[NN],son[NN][26],val[NN],sum[NN],b[NN],f[NN],g[NN];
int last,TTT;
char s[NN];
void out(int*a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
void add(int x)
{
	int p=last,end=++TTT;
	last=end;
	val[end]=val[p]+1;
	for (;p!=-1&amp;&amp;!son[p][x];p=pre[p]) son[p][x]=end;
	if (p==-1) {pre[end]=0;return;}
	int q=son[p][x];
	if (val[q]==val[p]+1) {pre[end]=q;return;}
	int nq=++TTT;
	val[nq]=val[p]+1;
	pre[nq]=pre[q];
	pre[q]=pre[end]=nq;
	memcpy(son[nq],son[q],sizeof(son[q]));
	for (;p!=-1&amp;&amp;son[p][x]==q;p=pre[p]) son[p][x]=nq;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int xx;scanf(&quot;%d\n&quot;,&amp;xx);
	scanf(&quot;%s\n&quot;,s+1);
	//printf(&quot;%s\n&quot;,s+1);
	int n=strlen(s+1);
	pre[0]=-1;
	int i;
	for (i=1;i&lt;=n;i++) add(s[i]-'a');
	for (i=1;i&lt;=TTT;i++) sum[val[i]]++;
	for (i=2;i&lt;=n;i++) sum[i]+=sum[i-1];
	for (i=TTT;i;i--) b[sum[val[i]]--]=i;
	for (i=1;i&lt;=TTT;i++) f[i]=val[i];
	//printf(&quot;TTT=%d\n&quot;,TTT);for(i=0;i&lt;=TTT;i++){for(int j=0;j&lt;3;j++)printf(&quot;%d &quot;,son[i][j]);ln;}ln;
	while (scanf(&quot;%s\n&quot;,s+1)!=EOF)
	{
		//printf(&quot;%s\n&quot;,s+1);
		//printf(&quot;\n--------------------------------------------------------------\n&quot;);
		for (i=1;i&lt;=TTT;i++) g[i]=0;
		n=strlen(s+1);
		int p=0,now=0;
		for (i=1;i&lt;=n;i++)
		{
			int x=s[i]-'a';
			if (son[p][x]) now++,p=son[p][x];
			else
			{
				while (p!=-1&amp;&amp;!son[p][x]) p=pre[p];
				if (p==-1) now=p=0;
				else now=val[p]+1,p=son[p][x];
			}
			if (now&gt;g[p]) g[p]=now;
			//printf(&quot;%d %d\n&quot;,p,now);
		}
		//out(g,0,TTT);
		for (i=TTT;i;i--)
		{
			int x=b[i];
			if (pre[x]!=-1&amp;&amp;g[x]&gt;g[pre[x]])
				g[pre[x]]=min(val[pre[x]],g[x]);
		}
		for (i=1;i&lt;=TTT;i++)
			if (g[i]&lt;f[i]) f[i]=g[i];
	}
	int ans=0;
	for (i=1;i&lt;=TTT;i++)
		if (f[i]&gt;ans) ans=f[i];
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem2946</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=401111;
int sum[NN],sa[NN],sa2[NN],wv[NN],height[NN],rank[NN],fa[NN];
int o[NN],aa[NN][2],key[NN],s[NN],id[NN];
int n,tot=1;
char ss[NN];
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
int getfa(int x) {return fa[x]==x?x:fa[x]=getfa(fa[x]);}
void suffix_array(int *r,int n,int m)
{
	int i,j,p,*x=rank,*y=sa2,*t;
	for (i=0;i&lt;=m;i++) sum[i]=0;
	for (i=1;i&lt;=n;i++) sum[x[i]=r[i]]++;
	for (i=1;i&lt;=m;i++) sum[i]+=sum[i-1];
	for (i=n;i;i--) sa[sum[x[i]]--]=i;
	for (j=p=1;p&lt;n;j&lt;&lt;=1,m=p)
	{
		for (i=n-j+1,p=0;i&lt;=n;i++) y[++p]=i;
		for (i=1;i&lt;=n;i++) if (sa[i]&gt;j) y[++p]=sa[i]-j;
		for (i=0;i&lt;=m;i++) sum[i]=0;
		for (i=1;i&lt;=n;i++) sum[wv[i]=x[y[i]]]++;
		for (i=1;i&lt;=m;i++) sum[i]+=sum[i-1];
		for (i=n;i;i--) sa[sum[wv[i]]--]=y[i];
		for (t=x,x=y,y=t,i=2,x[sa[1]]=p=1;i&lt;=n;i++)
			x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+j]==y[sa[i-1]+j])?p:++p;
	}
	for (i=1;i&lt;=n;i++) rank[i]=x[i];
	for (p=0,i=1;i&lt;=n;i++) if (x[i]&gt;1)
	{
		j=sa[x[i]-1];
		while (r[i+p]==r[j+p]) p++;
		height[x[i]]=p;
		if (p) p--;
	}
}
void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d\n&quot;,&amp;n);
	int all=(1&lt;&lt;n)-1;
	//printf(&quot;all=%d\n&quot;,all);
	int t=0,i,tmp=255;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s\n&quot;,ss+1);
		int l=strlen(ss+1);
		for (int ii=1;ii&lt;=l;ii++) s[++t]=ss[ii],id[t]=i;
		s[++t]=++tmp;
		id[t]=n+1;
	}
	//for (i=1;i&lt;=t;i++) printf(&quot;%d &quot;,s[i]);ln;
	suffix_array(s,t,1000);
	//for (i=1;i&lt;=t;i++) printf(&quot;%d &quot;,height[i]);ln;
	for (i=1;i&lt;=t;i++)
	{
		fa[i]=i,key[i]=1&lt;&lt;(id[sa[i]]-1);
		addedge(height[i],i);
	}
	//ln;printf(&quot;key: &quot;);out(key,1,t);
	int ans;
	for (ans=2000;ans;ans--)
	{
		for (int p=o[ans];p;p=aa[p][0])
		{
			int y=aa[p][1];
			int x=y-1;
			x=getfa(x),y=getfa(y);
			fa[x]=y,key[y]|=key[x];
			if ((key[y]&amp;all)==all) {printf(&quot;%d\n&quot;,ans);return 0;}
		}
	}
	printf(&quot;0\n&quot;);
	return 0;
}<pre><h2>Problem2947</h2><pre>#include &lt;set&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
int n,m;
long long ans;
multiset&lt;int&gt; s;
int main()
{
	int i,j,x;
	cin&gt;&gt;n;
	for(i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;m);
		for(j=1;j&lt;=m;j++)
			scanf(&quot;%d&quot;,&amp;x),s.insert(x);
		multiset&lt;int&gt;::iterator it=s.begin();
		ans-=*it;s.erase(it);
		it=s.end();it--;
		ans+=*it;s.erase(it);
	}
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}
<pre><h2>Problem2947</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=1001111;
int fa[NN],size[NN],son[NN][2],num[NN],key[NN],b[NN];
int n,K,TTT,cnt,need,root,H,totnum;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
	if (f) x=-x;
}
inline bool balance(int v)
{
	double tmp=0.7*size[v];
	return (double)size[son[v][0]]&lt;tmp&amp;&amp;(double)size[son[v][1]]&lt;tmp;
}
inline void update(int v)
{
	size[v]=size[son[v][0]]+size[son[v][1]]+num[v];
}
void ins(int &amp;v,int x,int f)
{
	if (v==0)
	{
		v=++TTT;
		key[v]=x;
		num[v]=size[v]=1;
		fa[v]=f;
	}
	else if (x==key[v])
		num[v]++,size[v]++;
	else
	{
		if (x&lt;key[v]) ins(son[v][0],x,v);
		else ins(son[v][1],x,v);
		update(v);
		if (!balance(v)) need=v;
	}
}
void bianli(int v)
{
	if (son[v][0]) bianli(son[v][0]);
	b[++cnt]=v;
	if (son[v][1]) bianli(son[v][1]);
}
int build(int l,int r)
{
	int mid=(l+r)&gt;&gt;1;
	int v=b[mid];
	if (l&lt;mid)
		son[v][0]=build(l,mid-1),fa[son[v][0]]=v;
	else son[v][0]=0;
	if (r&gt;mid)
		son[v][1]=build(mid+1,r),fa[son[v][1]]=v;
	else son[v][1]=0;
	update(v);
	return v;
}
void rebuild(int v)
{
	H++;
	//printf(&quot;======================= rebuild =========================\n&quot;);
	int f=fa[v],p=(son[f][1]==v);
	cnt=0;
	bianli(v);
	totnum+=cnt;
	int t=build(1,cnt);
	fa[t]=f,son[f][p]=t;
	if (v==root) root=t;
}
inline void goup(int v)
{
	for (;v;v=fa[v]) update(v);
}
void del(int v)
{
	if (num[v]&gt;1)
	{
		num[v]--;
		goup(v);
		return;
	}
	int f=fa[v],p=(son[f][1]==v);
	if (!son[v][0])
	{
		son[f][p]=son[v][1],fa[son[v][1]]=f;
		if (v==root) root=son[v][1];
		goup(son[v][1]);
		return;
	}
	if (!son[v][1])
	{
		son[f][p]=son[v][0],fa[son[v][0]]=f;
		if (v==root) root=son[v][0];
		goup(son[v][0]);
		return;
	}
	int x=son[v][0];
	while (son[x][1]) x=son[x][1];
	int t=(fa[x]==v)?x:fa[x];
	key[v]=key[x],num[v]=num[x];
	if (x==son[fa[x]][0]) son[fa[x]][0]=0;
	else son[fa[x]][1]=0;
	goup(t);
}
int getmin()
{
	int t=root;
	while (son[t][0]) t=son[t][0];
	int tmp=key[t];
	del(t);
	return tmp;
}
int getmax()
{
	int t=root;
	while (son[t][1]) t=son[t][1];
	int tmp=key[t];
	del(t);
	return tmp;
}
void debug(int v)
{
	if (v==0) return;
	debug(son[v][0]);
	printf(&quot;%d &quot;,key[v]);
	debug(son[v][1]);
}
void outtree()
{
	int i;ln;printf(&quot;root=%d\n&quot;,root);
	printf(&quot;fa &quot;);for (i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,fa[i]);ln;
	printf(&quot;key &quot;);for(i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,key[i]);ln;
	for (i=1;i&lt;=TTT;i++) printf(&quot;%d %d   &quot;,son[i][0],son[i][1]);ln;ln;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);
	long long ans=0;
	for (int i=1;i&lt;=n;i++)
	{
		//printf(&quot;\n----------------------------------------------------------------\n&quot;);
		for (read(K);K;K--)
		{
			int x;
			read(x);
			need=0;
			ins(root,x,0);
			if (need) rebuild(need);
		}
		//outtree();
		//printf(&quot;debug &quot;);debug(root);ln;
		int t1=getmax();
		//outtree();
		//printf(&quot;debug &quot;);debug(root);ln;
		int t2=getmin();
		//printf(&quot;max=%d min=%d\n&quot;,t1,t2);
		ans+=t1-t2;
		//printf(&quot;debug &quot;);debug(root);ln;
		//outtree();
	}
	//ln;ln;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem2947</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=1001111;
int fa[NN],size[NN],son[NN][2],num[NN],key[NN],b[NN];
int n,K,TTT,cnt,need,root,H,totnum;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
	if (f) x=-x;
}
inline bool balance(int v)
{
	double tmp=0.7*size[v];
	return (double)size[son[v][0]]&lt;tmp&amp;&amp;(double)size[son[v][1]]&lt;tmp;
}
inline void update(int v)
{
	size[v]=size[son[v][0]]+size[son[v][1]]+num[v];
}
void ins(int &amp;v,int x,int f)
{
	if (v==0)
	{
		v=++TTT;
		key[v]=x;
		num[v]=size[v]=1;
		fa[v]=f;
	}
	else if (x==key[v])
		num[v]++,size[v]++;
	else
	{
		if (x&lt;key[v]) ins(son[v][0],x,v);
		else ins(son[v][1],x,v);
		update(v);
		if (!balance(v)) need=v;
	}
}
void bianli(int v)
{
	if (son[v][0]) bianli(son[v][0]);
	b[++cnt]=v;
	if (son[v][1]) bianli(son[v][1]);
}
int build(int l,int r)
{
	int mid=(l+r)&gt;&gt;1;
	int v=b[mid];
	if (l&lt;mid)
		son[v][0]=build(l,mid-1),fa[son[v][0]]=v;
	else son[v][0]=0;
	if (r&gt;mid)
		son[v][1]=build(mid+1,r),fa[son[v][1]]=v;
	else son[v][1]=0;
	update(v);
	return v;
}
void rebuild(int v)
{
	H++;
	int f=fa[v],p=(son[f][1]==v);
	cnt=0;
	bianli(v);
	totnum+=cnt;
	int t=build(1,cnt);
	fa[t]=f,son[f][p]=t;
	if (v==root) root=t;
}
inline void goup(int v)
{
	for (;v;v=fa[v]) update(v);
}
void del(int v)
{
	if (num[v]&gt;1)
	{
		num[v]--;
		goup(v);
		return;
	}
	int f=fa[v],p=(son[f][1]==v);
	if (!son[v][0])
	{
		son[f][p]=son[v][1],fa[son[v][1]]=f;
		if (v==root) root=son[v][1];
		goup(son[v][1]);
		return;
	}
	if (!son[v][1])
	{
		son[f][p]=son[v][0],fa[son[v][0]]=f;
		if (v==root) root=son[v][0];
		goup(son[v][0]);
		return;
	}
	int x=son[v][0];
	while (son[x][1]) x=son[x][1];
	int t=(fa[x]==v)?x:fa[x];
	key[v]=key[x],num[v]=num[x];
	if (x==son[fa[x]][0]) son[fa[x]][0]=0;
	else son[fa[x]][1]=0;
	goup(t);
}
int getmin()
{
	int t=root;
	while (son[t][0]) t=son[t][0];
	int tmp=key[t];
	del(t);
	return tmp;
}
int getmax()
{
	int t=root;
	while (son[t][1]) t=son[t][1];
	int tmp=key[t];
	del(t);
	return tmp;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);
	long long ans=0;
	for (int i=1;i&lt;=n;i++)
	{
		for (read(K);K;K--)
		{
			int x;
			read(x);
			need=0;
			ins(root,x,0);
			if (need) rebuild(need);
		}
		ans+=getmax()-getmin();
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem2947</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=1001111;
int fa[NN],size[NN],son[NN][2],num[NN],key[NN],b[NN];
int n,K,TTT,cnt,need,root,H,totnum;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
	if (f) x=-x;
}
inline bool balance(int v)
{
	double tmp=0.7*size[v];
	return (double)size[son[v][0]]&lt;tmp&amp;&amp;(double)size[son[v][1]]&lt;tmp;
}
inline void update(int v)
{
	size[v]=size[son[v][0]]+size[son[v][1]]+num[v];
}
void ins(int &amp;v,int x,int f)
{
	if (v==0)
	{
		v=++TTT;
		key[v]=x;
		num[v]=size[v]=1;
		fa[v]=f;
	}
	else if (x==key[v])
		num[v]++,size[v]++;
	else
	{
		if (x&lt;key[v]) ins(son[v][0],x,v);
		else ins(son[v][1],x,v);
		update(v);
		if (!balance(v)) need=v;
	}
}
void bianli(int v)
{
	if (son[v][0]) bianli(son[v][0]);
	b[++cnt]=v;
	if (son[v][1]) bianli(son[v][1]);
}
int build(int l,int r)
{
	int mid=(l+r)&gt;&gt;1;
	int v=b[mid];
	if (l&lt;mid)
		son[v][0]=build(l,mid-1),fa[son[v][0]]=v;
	else son[v][0]=0;
	if (r&gt;mid)
		son[v][1]=build(mid+1,r),fa[son[v][1]]=v;
	else son[v][1]=0;
	update(v);
	return v;
}
void rebuild(int v)
{
	H++;
	int f=fa[v],p=(son[f][1]==v);
	cnt=0;
	bianli(v);
	totnum+=cnt;
	int t=build(1,cnt);
	fa[t]=f,son[f][p]=t;
	if (v==root) root=t;
}
inline void goup(int v)
{
	for (;v;v=fa[v]) update(v);
}
void del(int v)
{
	if (num[v]&gt;1) {num[v]--;goup(v);return;}
	int f=fa[v],p=(son[f][1]==v);
	if (!son[v][0]||!son[v][1])
	{
		int t=son[v][0]+son[v][1];
		son[f][p]=t,fa[t]=f;
		if (v==root) root=t;
		return;
	}
	int x=son[v][0];
	while (son[x][1]) x=son[x][1];
	int t=(fa[x]==v)?x:fa[x];
	key[v]=key[x],num[v]=num[x];
	if (x==son[fa[x]][0]) son[fa[x]][0]=0;
	else son[fa[x]][1]=0;
	goup(t);
}
int getmin()
{
	int t=root;
	while (son[t][0]) t=son[t][0];
	int tmp=key[t];
	del(t);
	return tmp;
}
int getmax()
{
	int t=root;
	while (son[t][1]) t=son[t][1];
	int tmp=key[t];
	del(t);
	return tmp;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);
	long long ans=0;
	for (int i=1;i&lt;=n;i++)
	{
		for (read(K);K;K--)
		{
			int x;
			read(x);
			need=0;
			ins(root,x,0);
			if (need) rebuild(need);
		}
		ans+=getmax()-getmin();
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem2947</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int NN=1001111;
int fa[NN],size[NN],son[NN][2],num[NN],key[NN],b[NN];
int n,K,TTT,cnt,need,root;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
	if (f) x=-x;
}
inline bool balance(int v)
{
	double tmp=0.7*size[v];
	return (double)size[son[v][0]]&lt;tmp&amp;&amp;(double)size[son[v][1]]&lt;tmp;
}
inline void update(int v)
{
	size[v]=size[son[v][0]]+size[son[v][1]]+num[v];
}
void ins(int &amp;v,int x,int f)
{
	if (v==0)
	{
		v=++TTT;
		key[v]=x;
		num[v]=size[v]=1;
		fa[v]=f;
	}
	else if (x==key[v])
		num[v]++,size[v]++;
	else
	{
		if (x&lt;key[v]) ins(son[v][0],x,v);
		else ins(son[v][1],x,v);
		update(v);
		if (!balance(v)) need=v;
	}
}
void bianli(int v)
{
	if (son[v][0]) bianli(son[v][0]);
	b[++cnt]=v;
	if (son[v][1]) bianli(son[v][1]);
}
int build(int l,int r)
{
	int mid=(l+r)&gt;&gt;1;
	int v=b[mid];
	if (l&lt;mid)
		son[v][0]=build(l,mid-1),fa[son[v][0]]=v;
	else son[v][0]=0;
	if (r&gt;mid)
		son[v][1]=build(mid+1,r),fa[son[v][1]]=v;
	else son[v][1]=0;
	update(v);
	return v;
}
void rebuild(int v)
{
	int f=fa[v],p=(son[f][1]==v);
	cnt=0;
	bianli(v);
	int t=build(1,cnt);
	fa[t]=f,son[f][p]=t;
	if (v==root) root=t;
}
inline void goup(int v)
{
	for (;v;v=fa[v]) update(v);
}
void del(int v)
{
	if (num[v]&gt;1) {num[v]--;goup(v);return;}
	int f=fa[v],p=(son[f][1]==v);
	if (!son[v][0]||!son[v][1])
	{
		int t=son[v][0]+son[v][1];
		son[f][p]=t,fa[t]=f;
		if (v==root) root=t;
		return;
	}
	int x=son[v][0];
	while (son[x][1]) x=son[x][1];
	key[v]=key[x],num[v]=num[x];
	if (x==son[fa[x]][0]) son[fa[x]][0]=0;
	else son[fa[x]][1]=0;
	goup(fa[x]);
}
int getmin()
{
	int t=root;
	while (son[t][0]) t=son[t][0];
	int tmp=key[t];
	del(t);
	return tmp;
}
int getmax()
{
	int t=root;
	while (son[t][1]) t=son[t][1];
	int tmp=key[t];
	del(t);
	return tmp;
}
int main()
{
	read(n);
	int i,x;
	long long ans=0;
	for (i=1;i&lt;=n;i++)
	{
		for (read(K);K;K--)
		{
			read(x);
			need=0;
			ins(root,x,0);
			if (need) rebuild(need);
		}
		ans+=getmax()-getmin();
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem2947</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int NN=1001111;
int fa[NN],size[NN],son[NN][2],num[NN],key[NN],b[NN];
int n,K,TTT,cnt,need,root;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
	if (f) x=-x;
}
inline bool balance(int v)
{
	double tmp=0.7*size[v];
	return (double)size[son[v][0]]&lt;tmp&amp;&amp;(double)size[son[v][1]]&lt;tmp;
}
inline void update(int v)
{
	size[v]=size[son[v][0]]+size[son[v][1]]+num[v];
}
void ins(int &amp;v,int x,int f)
{
	if (v==0)
	{
		v=++TTT;
		key[v]=x;
		num[v]=size[v]=1;
		fa[v]=f;
	}
	else if (x==key[v])
		num[v]++,size[v]++;
	else
	{
		if (x&lt;key[v]) ins(son[v][0],x,v);
		else ins(son[v][1],x,v);
		update(v);
		if (!balance(v)) need=v;
	}
}
void bianli(int v)
{
	if (son[v][0]) bianli(son[v][0]);
	b[++cnt]=v;
	if (son[v][1]) bianli(son[v][1]);
}
int build(int l,int r)
{
	int mid=(l+r)&gt;&gt;1;
	int v=b[mid];
	if (l&lt;mid)
		son[v][0]=build(l,mid-1),fa[son[v][0]]=v;
	else son[v][0]=0;
	if (r&gt;mid)
		son[v][1]=build(mid+1,r),fa[son[v][1]]=v;
	else son[v][1]=0;
	update(v);
	return v;
}
void rebuild(int v)
{
	int f=fa[v],p=(son[f][1]==v);
	cnt=0;
	bianli(v);
	int t=build(1,cnt);
	fa[t]=f,son[f][p]=t;
	if (v==root) root=t;
}
inline void goup(int v)
{
	for (;v;v=fa[v]) update(v);
}
void del(int v)
{
	if (num[v]&gt;1) {num[v]--;goup(v);return;}
	int f=fa[v],p=(son[f][1]==v);
	if (!son[v][0]||!son[v][1])
	{
		int t=son[v][0]+son[v][1];
		son[f][p]=t,fa[t]=f;
		if (v==root) root=t;
		goup(t);
		return;
	}
	int x=son[v][0];
	while (son[x][1]) x=son[x][1];
	key[v]=key[x],num[v]=num[x];
	if (x==son[fa[x]][0]) son[fa[x]][0]=0;
	else son[fa[x]][1]=0;
	goup(fa[x]);
}
int getmin()
{
	int t=root;
	while (son[t][0]) t=son[t][0];
	int tmp=key[t];
	del(t);
	return tmp;
}
int getmax()
{
	int t=root;
	while (son[t][1]) t=son[t][1];
	int tmp=key[t];
	del(t);
	return tmp;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);
	int i,x;
	long long ans=0;
	for (i=1;i&lt;=n;i++)
	{
		for (read(K);K;K--)
		{
			read(x);
			need=0;
			ins(root,x,0);
			if (need) rebuild(need);
		}
		ans+=getmax()-getmin();
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem2956</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
#define inf 1000000000
#define mod 19940417
#define ine 3323403
#define ll long long
using namespace std;
inline int read()
{
    int x=0;char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9')ch=getchar();
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
    return x;
}
ll n,m,ans;
ll sum(ll a,ll b)
{
	return (b-a+1)*(a+b)/2%mod;
}
ll sum2(ll x)
{
    return x*(x+1)%mod*(2*x+1)%mod*ine%mod;
}
ll cal(ll n)
{
	ll tmp=0;
	for(ll i=1,j;i&lt;=n;i=j+1)
	{
		j=n/(n/i);
		tmp=(tmp+n*(j-i+1)%mod-sum(i,j)*(n/i))%mod;
	}
	return (tmp+mod)%mod;
}
int main()
{//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
	n=read();m=read();
    ans=cal(n)*cal(m)%mod;
    //printf(&quot;%lld\n&quot;,ans);
	if(n&gt;m)swap(n,m);
	ll s1,s2,s3;
	for(int i=1,j;i&lt;=n;i=j+1)
	{
		j=min(n/(n/i),m/(m/i));
		s1=n*m%mod*(j-i+1)%mod;
		s2=(n/i)*(m/i)%mod*(sum2(j)-sum2(i-1)+mod)%mod;
		s3=(n/i*m+m/i*n)%mod*sum(i,j)%mod;
		ans=(ans-(s1+s2-s3)%mod+mod)%mod;
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem2957</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
#define ls (v&lt;&lt;1)
#define rs (v&lt;&lt;1|1)
const int NN=100111;
int tnum[NN&lt;&lt;2];
int n,m;
DD tmax[NN&lt;&lt;2];
int calc(int v,int l,int r,DD x)
{
	if (r-l==1) return tmax[v]&gt;x;
	int mid=(l+r)&gt;&gt;1;
	if (x&gt;=tmax[ls]) return calc(rs,mid,r,x);
	else return tnum[v]-tnum[ls]+calc(ls,l,mid,x);
}
void change(int v,int l,int r,int i,DD x)
{
	if (r-l==1)
	{
		tmax[v]=x;
		tnum[v]=1;
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid) change(ls,l,mid,i,x);
	else change(rs,mid,r,i,x);
	tmax[v]=max(tmax[ls],tmax[rs]);
	tnum[v]=tnum[ls]+calc(rs,mid,r,tmax[ls]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (;m;m--)
	{
		int x,y;
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		change(1,1,n+1,x,(DD)y/x);
		printf(&quot;%d\n&quot;,tnum[1]);
	}
	return 0;
}<pre><h2>Problem2959</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=301111;
int w[NN],b[NN];
int n,m,TTT,cnt;
inline void read(int &amp;x)
{
    x=0;char ch=getchar();
    while (ch&lt;'0'||ch&gt;'9') ch=getchar();
    while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
struct Bcj
{
    int fa[NN];
    int find(int x) {return fa[x]==x?x:fa[x]=find(fa[x]);}
} bcj,zh;
struct splaynode
{
	int fa,s[2],sum;
	bool tag,r;
} T[NN];
inline void rev(int t)
{
    T[t].tag^=1;
    swap(T[t].s[0],T[t].s[1]);
}
inline void pushdown(int t)
{
    if (T[t].tag)
    {
        rev(T[t].s[0]);
        rev(T[t].s[1]);
        T[t].tag=false;
    }
}
inline void update(int t)
{
    T[t].sum=T[T[t].s[0]].sum+T[T[t].s[1]].sum+w[t];
}
inline void rotate(int t,int p)
{
    int y=T[t].fa;
    pushdown(y),pushdown(t);
    if (T[y].r) T[y].r=false,T[t].r=true;
    else if (y==T[T[y].fa].s[0]) T[T[y].fa].s[0]=t;
    else T[T[y].fa].s[1]=t;
    T[t].fa=T[y].fa;
    T[y].s[p^1]=T[t].s[p];
    if (T[t].s[p]) T[T[t].s[p]].fa=y;
    T[t].s[p]=y;
    T[y].fa=t;
    update(y),update(t);
}
void splay(int t)
{
    while (!T[t].r)
    {
    	T[t].fa=bcj.find(T[t].fa);
        int y=T[t].fa;
        T[y].fa=bcj.find(T[y].fa);
        if (T[y].r)
            if (t==T[y].s[0]) rotate(t,1);
            else rotate(t,0);
        else
            if (y==T[T[y].fa].s[0])
                if (t==T[y].s[0]) rotate(y,1),rotate(t,1);
                else rotate(t,0),rotate(t,1);
            else
                if (t==T[y].s[1]) rotate(y,0),rotate(t,0);
                else rotate(t,1),rotate(t,0);
    }
    update(t);
}
void access(int x)
{
    int y=0;
    for (;x;y=x,x=T[x].fa)
    {
        splay(x);
        pushdown(x);
        T[T[x].s[1]].r=true;
        T[x].s[1]=y;
        T[y].r=false;
        update(x);
        T[x].fa=bcj.find(T[x].fa);
    }
}
void makeroot(int x)
{
    access(x);
    splay(x);
    rev(x);
}
void link(int x,int y)
{
    //printf(&quot;link %d %d\n&quot;,x,y);
    makeroot(x);
    splay(x);
    T[x].fa=y;
}
void cut(int x,int y)
{
    //printf(&quot;cut %d %d\n&quot;,x,y);
    makeroot(x);
    access(y);
    splay(y);
    T[x].r=true;
    T[x].fa=T[y].s[0]=0;
}
int getroot(int x)
{
    access(x);
    splay(x);
    pushdown(x);
    while (T[x].s[0])
    {
        x=T[x].s[0];
        pushdown(x);
    }
    return x;
}
void find(int t)
{
    pushdown(t);
    if (T[t].s[0]) find(T[t].s[0]);
    b[++cnt]=t;
    if (T[t].s[1]) find(T[t].s[1]);
}
int main()
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    read(n),read(m);
    int i,x,y,z;
    for (i=1;i&lt;=n;i++) read(w[i]);
    for (i=1;i&lt;=n;i++)
		zh.fa[i]=i,bcj.fa[i]=i,T[i].r=true;
    TTT=n;
    for (;m;m--)
    {
        //printf(&quot;\n-----------------------------------------------------------------\n&quot;);
        read(z),read(x),read(y);
        if (z==1)
        {
            x=bcj.find(x),y=bcj.find(y);
            if (zh.find(x)!=zh.find(y))
            {
            	zh.fa[zh.find(x)]=y;
                link(x,y);
                continue;
            }
            if (x==y) continue;
            makeroot(x);
            access(y);splay(y);
            cnt=0;
            find(y);
            int t=++TTT;
            T[t].r=true;
            zh.fa[t]=b[1];
            for (i=1;i&lt;=cnt;i++)
			{
				w[t]+=w[b[i]];
				bcj.fa[b[i]]=t;
			}
            bcj.fa[t]=t;
        }
        else if (z==2)
        {
            int t=bcj.find(x);
            w[t]+=y-w[x];
            w[x]=y;
            splay(t);
        }
        else
        {
            x=bcj.find(x),y=bcj.find(y);           
			if (zh.find(x)!=zh.find(y)) printf(&quot;-1\n&quot;);
            else
            {
                makeroot(x);
                access(y);splay(y);
                printf(&quot;%d\n&quot;,T[y].sum);
            }
        }
    }
    return 0;
}<pre><h2>Problem2959</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int NN=301111;
int w[NN],b[NN];
int n,m,TTT,cnt;
inline void read(int &amp;x)
{
    x=0;char ch=getchar();
    while (ch&lt;'0'||ch&gt;'9') ch=getchar();
    while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
struct Bcj
{
    int fa[NN];
    int find(int x) {return fa[x]==x?x:fa[x]=find(fa[x]);}
} bcj,zh;
struct splaynode
{
	int fa,s[2],sum;
	bool tag,r;
} T[NN];
inline void rev(int t)
{
    T[t].tag^=1;
    swap(T[t].s[0],T[t].s[1]);
}
inline void pushdown(int t)
{
    if (T[t].tag)
    {
        rev(T[t].s[0]);
        rev(T[t].s[1]);
        T[t].tag=false;
    }
}
inline void update(int t)
{
    T[t].sum=T[T[t].s[0]].sum+T[T[t].s[1]].sum+w[t];
}
inline void rotate(int t,int p)
{
    int y=T[t].fa;
    pushdown(y),pushdown(t);
    if (T[y].r) T[y].r=false,T[t].r=true;
    else if (y==T[T[y].fa].s[0]) T[T[y].fa].s[0]=t;
    else T[T[y].fa].s[1]=t;
    T[t].fa=T[y].fa;
    T[y].s[p^1]=T[t].s[p];
    if (T[t].s[p]) T[T[t].s[p]].fa=y;
    T[t].s[p]=y;
    T[y].fa=t;
    update(y),update(t);
}
void splay(int t)
{
    while (!T[t].r)
    {
    	T[t].fa=bcj.find(T[t].fa);
        int y=T[t].fa;
        T[y].fa=bcj.find(T[y].fa);
        if (T[y].r)
            if (t==T[y].s[0]) rotate(t,1);
            else rotate(t,0);
        else
            if (y==T[T[y].fa].s[0])
                if (t==T[y].s[0]) rotate(y,1),rotate(t,1);
                else rotate(t,0),rotate(t,1);
            else
                if (t==T[y].s[1]) rotate(y,0),rotate(t,0);
                else rotate(t,1),rotate(t,0);
    }
    update(t);
}
void access(int x)
{
    int y=0;
    for (;x;y=x,x=T[x].fa)
    {
        splay(x);
        pushdown(x);
        T[T[x].s[1]].r=true;
        T[x].s[1]=y;
        T[y].r=false;
        update(x);
        T[x].fa=bcj.find(T[x].fa);
    }
}
void makeroot(int x)
{
    access(x);
    splay(x);
    rev(x);
}
void link(int x,int y)
{
    makeroot(x);
    splay(x);
    T[x].fa=y;
}
int getroot(int x)
{
    access(x);
    splay(x);
    pushdown(x);
    while (T[x].s[0])
    {
        x=T[x].s[0];
        pushdown(x);
    }
    return x;
}
void find(int t)
{
    pushdown(t);
    if (T[t].s[0]) find(T[t].s[0]);
    b[++cnt]=t;
    if (T[t].s[1]) find(T[t].s[1]);
}
int main()
{
    read(n),read(m);
    int i,x,y,z;
    for (i=1;i&lt;=n;i++) read(w[i]);
    for (i=1;i&lt;=n;i++)
		zh.fa[i]=i,bcj.fa[i]=i,T[i].r=true;
    TTT=n;
    for (;m;m--)
    {
        read(z),read(x),read(y);
        if (z==1)
        {
            x=bcj.find(x),y=bcj.find(y);
            if (zh.find(x)!=zh.find(y))
            {
            	zh.fa[zh.find(x)]=y;
                link(x,y);
                continue;
            }
            if (x==y) continue;
            makeroot(x);
            access(y);splay(y);
            cnt=0;
            find(y);
            int t=++TTT;
            T[t].r=true;
            zh.fa[t]=b[1];
            for (i=1;i&lt;=cnt;i++)
			{
				w[t]+=w[b[i]];
				bcj.fa[b[i]]=t;
			}
            bcj.fa[t]=t;
        }
        else if (z==2)
        {
            int t=bcj.find(x);
            w[t]+=y-w[x];
            w[x]=y;
            splay(t);
        }
        else
        {
            x=bcj.find(x),y=bcj.find(y);           
			if (zh.find(x)!=zh.find(y)) printf(&quot;-1\n&quot;);
            else
            {
                makeroot(x);
                access(y);splay(y);
                printf(&quot;%d\n&quot;,T[y].sum);
            }
        }
    }
    return 0;
}<pre><h2>Problem2961</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
#define ln printf(&quot;\n&quot;)
const DD eps=1e-7;
const int NN=501111;
int id[NN],id2[NN];
int n;
bool ans[NN];
inline int dcmp(DD x)
{
	if (fabs(x)&lt;eps) return 0;
	return x&lt;0?-1:1;
}
struct point
{
	DD x,y;
	point(DD a=0,DD b=0) {x=a;y=b;}
	void out() {printf(&quot;x=%.3f y=%.3f\n&quot;,x,y);}
	friend point operator -(point a,point b) {return point(a.x-b.x,a.y-b.y);}
	friend DD operator %(point a,point b) {return a.x*b.y-b.x*a.y;}
} c[NN&lt;&lt;1],b[NN];
struct info
{
	bool kind;
	DD x,y,sita;
	point P,v;
	void in()
	{
		char ch=getchar();
		while (ch!='0'&amp;&amp;ch!='1') ch=getchar();
		kind=(ch=='1');
		scanf(&quot;%lf%lf&quot;,&amp;x,&amp;y);
		if (!kind) return;
		if (dcmp(x)==0) P=point(0,y/2),v=point(10000,0);
		else if (dcmp(y)==0) P=point(x/2,0),v=point(0,-10000);
		else
		{
			DD tmp=x*x+y*y;
			point t1=point(tmp/(2*x),0),t2=point(0,tmp/(2*y));
			P=t2,v=t2-t1;
			if (y&gt;eps&amp;&amp;v.x&lt;-eps) v.x=-v.x,v.y=-v.y;
			if (y&lt;-eps&amp;&amp;v.x&gt;eps) v.x=-v.x,v.y=-v.y;
		}
		sita=atan2(v.y,v.x);
	}
	void out()
	{
		printf(&quot;\nkind=%d x=%.3f y=%.3f\n&quot;,kind,x,y);
		printf(&quot;P: %.3f %.3f    v: %.3f %.3f  sita=%.3f\n&quot;,P.x,P.y,v.x,v.y,sita);
	}
} q[NN];
inline bool cmp(const int &amp;a,const int &amp;b)
{
	return q[a].sita&lt;q[b].sita;
}
void cdq(int l,int r)
{
	if (l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if (id[k]&lt;=mid) id2[i++]=id[k];
		else id2[j++]=id[k];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
	cdq(l,mid);
	//printf(&quot;\n----------------------- cdq %d %d %d ----------------------------------\n&quot;,l,r,mid);
	//printf(&quot;id &quot;);for(i=l;i&lt;=r;i++) printf(&quot;%d &quot;,id[i]);ln;
	int cnt=0;
	for (i=l;i&lt;=mid;i++)
	{
		int t=id[i];
		if (!q[t].kind) b[++cnt]=point(q[t].x,q[t].y);
	}
	//printf(&quot;b:\n&quot;);for(i=1;i&lt;=cnt;i++)b[i].out();ln;
	int n=0;
	for (i=1;i&lt;=cnt;i++)
	{
		while (n&gt;1&amp;&amp;(b[i]-c[n-1])%(c[n]-c[n-1])&gt;-eps) n--;
		c[++n]=b[i];
	}
	int t=n;
	for (i=cnt;i;i--)
	{
		while (n&gt;t&amp;&amp;(b[i]-c[n-1])%(c[n]-c[n-1])&gt;-eps) n--;
		c[++n]=b[i];
	}
	//printf(&quot;c:\n&quot;);for(i=1;i&lt;=n;i++) c[i].out();ln;
	int now=1;
	if (n&gt;0) for (i=mid+1;i&lt;=r;i++)
	{
		int t=id[i];
		if (!q[t].kind) continue;
		while (now&lt;n&amp;&amp;(c[now+1]-c[now])%q[t].v&gt;eps) now++;
		if (q[t].v%(c[now]-q[t].P)&lt;-eps) ans[t]=false;
	}
	cdq(mid+1,r);
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if ((i&lt;=mid&amp;&amp;q[id[i]].x&lt;q[id[j]].x)||j&gt;r) id2[k]=id[i++];
		else id2[k]=id[j++];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i;
	for (i=1;i&lt;=n;i++) q[i].in();
	//for (i=1;i&lt;=n;i++) q[i].out();
	for (i=1;i&lt;=n;i++) id[i]=i,ans[i]=true;
	sort(id+1,id+n+1,cmp);
	//ln;for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,id[i]);ln;
	cdq(1,n);
	//printf(&quot;\n\n~~~~~~~~~~~~~~~~~~~ output ~~~~~~~~~~~~~~~~~~~~~\n&quot;);
	bool exist=false;
	for (i=1;i&lt;=n;i++)
	{
		if (!q[i].kind) exist=true;
		else printf((exist&amp;&amp;ans[i])?&quot;Yes\n&quot;:&quot;No\n&quot;);
	}
	return 0;
}<pre><h2>Problem2961</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
const DD eps=1e-7;
const int NN=501111;
int id[NN],id2[NN];
int n;
bool ans[NN];
inline int dcmp(DD x)
{
	if (fabs(x)&lt;eps) return 0;
	return x&lt;0?-1:1;
}
struct point
{
	DD x,y;
	point(DD a=0,DD b=0) {x=a;y=b;}
	friend point operator -(point a,point b) {return point(a.x-b.x,a.y-b.y);}
	friend DD operator %(point a,point b) {return a.x*b.y-b.x*a.y;}
} c[NN&lt;&lt;1],b[NN];
struct info
{
	bool kind;
	DD x,y,sita;
	point P,v;
	void in()
	{
		char ch=getchar();
		while (ch!='0'&amp;&amp;ch!='1') ch=getchar();
		kind=(ch=='1');
		scanf(&quot;%lf%lf&quot;,&amp;x,&amp;y);
		if (!kind) return;
		if (dcmp(x)==0) P=point(0,y/2),v=point(10000,0);
		else if (dcmp(y)==0) P=point(x/2,0),v=point(0,-10000);
		else
		{
			DD tmp=x*x+y*y;
			point t1=point(tmp/(2*x),0),t2=point(0,tmp/(2*y));
			P=t2,v=t2-t1;
			if (y&gt;eps&amp;&amp;v.x&lt;-eps) v.x=-v.x,v.y=-v.y;
			if (y&lt;-eps&amp;&amp;v.x&gt;eps) v.x=-v.x,v.y=-v.y;
		}
		sita=atan2(v.y,v.x);
	}
} q[NN];
inline bool cmp(const int &amp;a,const int &amp;b)
{
	return q[a].sita&lt;q[b].sita;
}
void cdq(int l,int r)
{
	if (l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if (id[k]&lt;=mid) id2[i++]=id[k];
		else id2[j++]=id[k];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
	cdq(l,mid);
	int cnt=0;
	for (i=l;i&lt;=mid;i++)
	{
		int t=id[i];
		if (!q[t].kind) b[++cnt]=point(q[t].x,q[t].y);
	}
	int n=0;
	for (i=1;i&lt;=cnt;i++)
	{
		while (n&gt;1&amp;&amp;(b[i]-c[n-1])%(c[n]-c[n-1])&gt;-eps) n--;
		c[++n]=b[i];
	}
	int t=n;
	for (i=cnt;i;i--)
	{
		while (n&gt;t&amp;&amp;(b[i]-c[n-1])%(c[n]-c[n-1])&gt;-eps) n--;
		c[++n]=b[i];
	}
	int now=1;
	if (n&gt;0) for (i=mid+1;i&lt;=r;i++)
	{
		int t=id[i];
		if (!q[t].kind) continue;
		while (now&lt;n&amp;&amp;(c[now+1]-c[now])%q[t].v&gt;eps) now++;
		if (q[t].v%(c[now]-q[t].P)&lt;-eps) ans[t]=false;
	}
	cdq(mid+1,r);
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if ((i&lt;=mid&amp;&amp;q[id[i]].x&lt;q[id[j]].x)||j&gt;r) id2[k]=id[i++];
		else id2[k]=id[j++];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	int i;
	for (i=1;i&lt;=n;i++) q[i].in();
	for (i=1;i&lt;=n;i++) id[i]=i,ans[i]=true;
	sort(id+1,id+n+1,cmp);
	cdq(1,n);
	bool exist=false;
	for (i=1;i&lt;=n;i++)
	{
		if (!q[i].kind) exist=true;
		else printf((exist&amp;&amp;ans[i])?&quot;Yes\n&quot;:&quot;No\n&quot;);
	}
	return 0;
}<pre><h2>Problem2961</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
const DD eps=1e-7;
const int NN=501111;
int id[NN],id2[NN];
int n;
bool ans[NN];
inline int dcmp(DD x)
{
	if (fabs(x)&lt;eps) return 0;
	return x&lt;0?-1:1;
}
struct point
{
	DD x,y;
	point(DD a=0,DD b=0) {x=a;y=b;}
	friend point operator -(const point &amp;a,const point &amp;b) {return point(a.x-b.x,a.y-b.y);}
	friend DD operator %(const point &amp;a,const point &amp;b) {return a.x*b.y-b.x*a.y;}
} c[NN&lt;&lt;1],b[NN];
struct info
{
	bool kind;
	DD x,y,sita;
	point P,v;
	void in()
	{
		char ch=getchar();
		while (ch!='0'&amp;&amp;ch!='1') ch=getchar();
		kind=(ch=='1');
		scanf(&quot;%lf%lf&quot;,&amp;x,&amp;y);
		if (!kind) return;
		if (dcmp(x)==0) P=point(0,y/2),v=point(10000,0);
		else if (dcmp(y)==0) P=point(x/2,0),v=point(0,-10000);
		else
		{
			DD tmp=x*x+y*y;
			point t1=point(tmp/(2*x),0),t2=point(0,tmp/(2*y));
			P=t2,v=t2-t1;
			if (y&gt;eps&amp;&amp;v.x&lt;-eps) v.x=-v.x,v.y=-v.y;
			if (y&lt;-eps&amp;&amp;v.x&gt;eps) v.x=-v.x,v.y=-v.y;
		}
		sita=atan2(v.y,v.x);
	}
} q[NN];
inline bool cmp(const int &amp;a,const int &amp;b)
{
	return q[a].sita&lt;q[b].sita;
}
void cdq(int l,int r)
{
	if (l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if (id[k]&lt;=mid) id2[i++]=id[k];
		else id2[j++]=id[k];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
	cdq(l,mid);
	int cnt=0;
	for (i=l;i&lt;=mid;i++)
	{
		int t=id[i];
		if (!q[t].kind) b[++cnt]=point(q[t].x,q[t].y);
	}
	int n=0;
	for (i=1;i&lt;=cnt;i++)
	{
		while (n&gt;1&amp;&amp;(b[i]-c[n-1])%(c[n]-c[n-1])&gt;-eps) n--;
		c[++n]=b[i];
	}
	int t=n;
	for (i=cnt;i;i--)
	{
		while (n&gt;t&amp;&amp;(b[i]-c[n-1])%(c[n]-c[n-1])&gt;-eps) n--;
		c[++n]=b[i];
	}
	int now=1;
	if (n&gt;0) for (i=mid+1;i&lt;=r;i++)
	{
		int t=id[i];
		if (!q[t].kind) continue;
		while (now&lt;n&amp;&amp;(c[now+1]-c[now])%q[t].v&gt;eps) now++;
		if (q[t].v%(c[now]-q[t].P)&lt;-eps) ans[t]=false;
	}
	cdq(mid+1,r);
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if ((i&lt;=mid&amp;&amp;q[id[i]].x&lt;q[id[j]].x)||j&gt;r) id2[k]=id[i++];
		else id2[k]=id[j++];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	int i;
	for (i=1;i&lt;=n;i++) q[i].in();
	for (i=1;i&lt;=n;i++) id[i]=i,ans[i]=true;
	sort(id+1,id+n+1,cmp);
	cdq(1,n);
	bool exist=false;
	for (i=1;i&lt;=n;i++)
	{
		if (!q[i].kind) exist=true;
		else printf((exist&amp;&amp;ans[i])?&quot;Yes\n&quot;:&quot;No\n&quot;);
	}
	return 0;
}<pre><h2>Problem2982</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
#define mo 10007
int fac[mo];
int n,m,tes;
LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (a%=c;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
int C(int n,int m)
{
	if (n&lt;m) return 0;
	if (m==0) return 1;
	return (LL)fac[n]*ksm((LL)fac[m]*fac[n-m],mo-2,mo)%mo;
}
int lucas(int n,int m)
{
	if (n&lt;m) return 0;
	if (m==0) return 1;
	return (LL)C(n%mo,m%mo)*lucas(n/mo,m/mo)%mo;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	fac[0]=1;
	for (int i=1;i&lt;mo;i++)
		fac[i]=(LL)fac[i-1]*i%mo;
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		printf(&quot;%d\n&quot;,lucas(n,m));
	}
	return 0;
}<pre><h2>Problem2987</h2><pre>#include&lt;iostream&gt;
using namespace std;
typedef long long LL;
inline LL f(LL x) {return x*(x+1)/2;}
LL work(LL a,LL b,LL c,LL n)
{
	if (!c) return 0;
	LL t=(b/c+(b%c?1:0))*c-b;
	return (a/c)*f(n)-(b/c+(b%c?1:0))*n+n*(((a%c)*n+t)/c)-work(c,t+1,a%c,((a%c)*n+t)/c);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	LL a,b,c;
	cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
	c+=a+b;
	cout&lt;&lt;-work(a,c+1,b,c/a)-c/a&lt;&lt;endl;
	return 0;
}<pre><h2>Problem2987</h2><pre>#include&lt;iostream&gt;
using namespace std;
typedef long long LL;
inline LL f(LL x) {return x*(x+1)/2;}
LL work(LL a,LL b,LL c,LL n)
{
	if (!c) return 0;
	LL t=(b/c+(b%c?1:0))*c-b;
	return (a/c)*f(n)-(b/c+(b%c?1:0))*n+n*((a%c*n+t)/c)-work(c,t+1,a%c,((a%c)*n+t)/c);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
	LL a,b,c;
	cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
	c+=a+b;
	cout&lt;&lt;-work(a,c+1,b,c/a)-c/a&lt;&lt;endl;
	return 0;
}<pre><h2>Problem2987</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
using namespace std;
typedef long long LL;
LL chu(LL a,LL b)
{
	if (a&lt;0) return a/b-((a%b)?1:0);
	return a/b;
}
LL work(LL a,LL b,LL c,LL n)
{
	if (c==0) return 0;
	LL res=n*(n+1)/2*(a/c)+n*(b/c);
	a%=c,b%=c;
	if (b&lt;0) b+=c,res-=n;
	LL km=chu(a*n+b,c);
	return res+km*n-work(c,-b-1,a,km);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	//LL a,b,c,d;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;
	//cout&lt;&lt;work(a,b,c,d)&lt;&lt;endl;
	//cout&lt;&lt;work(9,9,7,9)&lt;&lt;endl;
	LL A,B,C;
	cin&gt;&gt;A&gt;&gt;B&gt;&gt;C;
	C+=A+B;
	cout&lt;&lt;-work(B,-(C+1),A,C/B)-C/B&lt;&lt;endl;
	return 0;
}<pre><h2>Problem2987</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
using namespace std;
typedef long long LL;
LL chu(LL a,LL b)
{
	if (a&lt;0) return a/b-((a%b)?1:0);
	return a/b;
}
LL work(LL n,LL a,LL b,LL c)
{
	if (c==0) return 0;
	LL res=n*(n+1)/2*(a/c)+n*(b/c);
	a%=c,b%=c;
	if (a&lt;0) a+=c,res-=n*(n+1)/2;
	if (b&lt;0) b+=c,res-=n;
	LL km=chu(a*n+b,c);
	return res+km*n-work(km,c,-b-1,a);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	LL A,B,C;
	cin&gt;&gt;A&gt;&gt;B&gt;&gt;C;
	C+=A+B;
	cout&lt;&lt;work(C/B,-B,C,A)&lt;&lt;endl;
	return 0;
}<pre><h2>Problem2987</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
using namespace std;
typedef long long LL;
LL work(LL n,LL a,LL b,LL c)
{
	if (c==0) return 0;
	LL res=n*(n+1)/2*(a/c)+n*(b/c);
	a%=c,b%=c;
	if (a&lt;0) a+=c,res-=n*(n+1)/2;
	if (b&lt;0) b+=c,res-=n;
	LL n2=(a*n+b)/c;
	return res+n2*n-work(n2,c,-b-1,a);
}
int main()
{
	LL A,B,C;
	cin&gt;&gt;A&gt;&gt;B&gt;&gt;C;
	C+=A+B;
	cout&lt;&lt;work(C/B,-B,C,A)&lt;&lt;endl;
	return 0;
}<pre><h2>Problem2987</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
LL work(LL n,LL A,LL B,LL C)
{
	if (!C) return 0;
	LL res=n*(n+1)/2*(A/C)+n*(B/C);
	A%=C,B%=C;
	if (A&lt;0) A+=C,res-=n*(n+1)/2;
	if (B&lt;0) B+=C,res-=n;
	LL km=(A*n+B)/C;
	return res+n*km-work(km,C,-B-1,A);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	LL A,B,C;
	scanf(&quot;%lld%lld%lld&quot;,&amp;A,&amp;B,&amp;C);
	C+=A+B;
	printf(&quot;%lld\n&quot;,work(C/B,-B,C,A));
	return 0;
}<pre><h2>Problem3014</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
typedef unsigned int UN;
#define inf 999999999
#define ln printf(&quot;\n&quot;)
#define pb push_back
const int NN=40111;
int w[NN],ceng[NN],size[NN],fa[NN];
int now_sum[NN],max_sum[NN],min_sum[NN],vt1[NN],vt2[NN],a1[NN],a2[NN];
int n,tot=1,TIME1,TIME2,maxdeep,ans;
vector&lt;int&gt; go[NN];
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);ln;}
void calcsize(int v)
{
	size[v]=1;
	for (UN p=0;p&lt;go[v].size();p++)
	{
		int y=go[v][p];
		if (y==fa[v]||ceng[y]&lt;ceng[v]) continue;
		fa[y]=v;
		calcsize(y);
		size[v]+=size[y];
	}
}
int getcore(int v)
{
	fa[v]=0,calcsize(v);
	for (;;)
	{
		bool flag=false;
		for (UN p=0;p&lt;go[v].size();p++)
		{
			int y=go[v][p];
			if (ceng[y]&lt;ceng[v]) continue;
			//printf(&quot;v=%d y=%d size[v]=%d size[y]=%d\n&quot;,v,y,size[v],size[y]);
			if (size[y]&lt;&lt;1&gt;size[v])
			{
				size[v]-=size[y];
				size[y]+=size[v];
				v=y;flag=true;break;
			}
		}
		if (!flag) break;
	}
	return v;
}
void dfs1(int v)
{
	//printf(&quot;dfs1 %d\n&quot;,v);
	now_sum[v]=now_sum[fa[v]]+w[v];
	max_sum[v]=max(max_sum[fa[v]],now_sum[v]);
	min_sum[v]=min(min_sum[fa[v]],now_sum[v]);
	//printf(&quot;now_sum=%d max_sum=%d min_sum=%d\n&quot;,now_sum[v],max_sum[v],min_sum[v]);
	if (now_sum[v]-min_sum[v]&lt;=0)
	{
		if (vt2[-now_sum[v]]==TIME2)
			a2[-now_sum[v]]=max(a2[-now_sum[v]],-(now_sum[v]-max_sum[v]));
		else
		{
			vt2[-now_sum[v]]=TIME2;
			a2[-now_sum[v]]=-(now_sum[v]-max_sum[v]);
		}
	}
	maxdeep=max(maxdeep,-now_sum[v]);
	for (UN p=0;p&lt;go[v].size();p++)
	{
		int y=go[v][p];
		if (y==fa[v]||ceng[y]&lt;ceng[v]) continue;
		fa[y]=v;
		dfs1(y);
	}
}
void renewans()
{
	for (int i=0;i&lt;=maxdeep;i++)
		if (vt1[i]==TIME1&amp;&amp;vt2[i]==TIME2)
			ans=max(ans,max(a1[i],a2[i]));
}
void dfs2(int v)
{
	//printf(&quot;dfs2 %d\n&quot;,v);
	now_sum[v]=now_sum[fa[v]]+w[v];
	max_sum[v]=max(max_sum[fa[v]],now_sum[v]);
	min_sum[v]=min(min_sum[fa[v]],now_sum[v]);
	//printf(&quot;now_sum=%d max_sum=%d min_sum=%d\n&quot;,now_sum[v],max_sum[v],min_sum[v]);
	if (now_sum[v]-max_sum[v]&gt;=0)
	{
		if (vt1[now_sum[v]]==TIME1)
			a1[now_sum[v]]=max(a1[now_sum[v]],now_sum[v]-min_sum[v]);
		else
		{
			vt1[now_sum[v]]=TIME1;
			a1[now_sum[v]]=now_sum[v]-min_sum[v];
		}
	}
	for (UN p=0;p&lt;go[v].size();p++)
	{
		int y=go[v][p];
		if (y==fa[v]||ceng[y]&lt;ceng[v]) continue;
		dfs2(y);
	}
}
void work(int v)
{
	//printf(&quot;\n------------------------------- work %d ------------------------------\n&quot;,v);
	TIME1++;
	if (w[v]==1)
		vt1[1]=TIME1,a1[1]=1;
	//printf(&quot;TIME1=%d\n&quot;,TIME1);printf(&quot;vt1 &quot;);out(vt1,0,10);printf(&quot;a1 &quot;);out(a1,0,10);ln;
	for (UN p=0;p&lt;go[v].size();p++)
	{
		int y=go[v][p];
		if (ceng[y]&lt;ceng[v]) continue;
		//printf(&quot;````````````` y=%d ```````````````\n&quot;,y);
		TIME2++;
		maxdeep=-inf;
		now_sum[v]=min_sum[v]=max_sum[v]=0;
		fa[y]=v;
		dfs1(y);
		//printf(&quot;TIME2=%d\n&quot;,TIME2);printf(&quot;vt2 &quot;);out(vt2,0,10);printf(&quot;a2 &quot;);out(a2,0,10);ln;
		renewans();
		now_sum[v]=w[v];
		min_sum[v]=min(w[v],0);
		max_sum[v]=max(w[v],0);
		dfs2(y);
		//ln;printf(&quot;vt1 &quot;);out(vt1,0,10);printf(&quot;a1 &quot;);out(a1,0,10);ln;
	}
	TIME1++;
	if (w[v]==1)
		vt1[1]=TIME1,a1[1]=1;
	//ln;printf(&quot;TIME1=%d\n&quot;,TIME1);printf(&quot;vt1 &quot;);out(vt1,0,10);printf(&quot;a1 &quot;);out(a1,0,10);
	for (int p=go[v].size()-1;p&gt;=0;p--)
	{
		int y=go[v][p];
		if (ceng[y]&lt;ceng[v]) continue;
		//printf(&quot;````````````` y=%d ```````````````\n&quot;,y);
		TIME2++;
		maxdeep=-inf;
		now_sum[v]=min_sum[v]=max_sum[v]=0;
		fa[y]=v;
		dfs1(y);
		//printf(&quot;TIME2=%d\n&quot;,TIME2);printf(&quot;vt2 &quot;);out(vt2,0,10);printf(&quot;a2 &quot;);out(a2,0,10);
		renewans();
		now_sum[v]=w[v];
		min_sum[v]=min(w[v],0);
		max_sum[v]=max(w[v],0);
		dfs2(y);
	}
	//ln;ln;
	if (w[v]==-1)
	{
		TIME1++;
		for (UN p=0;p&lt;go[v].size();p++)
		{
			int y=go[v][p];
			if (ceng[y]&lt;ceng[v]) continue;
			now_sum[v]=min_sum[v]=max_sum[v]=0;
			fa[y]=v;
			dfs2(y);
		}
		//printf(&quot;TIME1=%d\n&quot;,TIME1);printf(&quot;vt1 &quot;);out(vt1,0,10);printf(&quot;a1 &quot;);out(a1,0,10);
		if (vt1[1]==TIME1) ans=max(ans,a1[1]);
	}
	for (UN p=0;p&lt;go[v].size();p++)
	{
		int y=go[v][p];
		if (ceng[y]&lt;ceng[v]) continue;
		y=getcore(y);
		ceng[y]=ceng[v]+1;
		work(y);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x;
	for (i=2;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		go[x].pb(i),go[i].pb(x);
	}
	for (i=1;i&lt;=n;i++)
	{
		char ch=getchar();
		while (ch!='('&amp;&amp;ch!=')') ch=getchar();
		w[i]=(ch=='(')?1:-1;
	}
	memset(ceng,60,sizeof(ceng));
	int t=getcore(1);
	ceng[t]=1;
	work(t);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3028</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define mo 10007
int n,ans;
char ch;
int ksm(int a,int b)
{
	int res=1;
	for (;b;b&gt;&gt;=1,a=a*a%mo) if (b&amp;1) res=res*a%mo;
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (ch=getchar();ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar()) n=(n*10+ch-'0')%mo;
	ans=n*(n+1)%mo;
	ans=ans*(n+2)%mo;
	ans=ans*ksm(6,mo-2)%mo;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3028</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define mo 10007
int n,ans;
char ch;
int ksm(int a,int b)
{
	int res=1;
	for (;b;b&gt;&gt;=1,a=a*a%mo) if (b&amp;1) res=res*a%mo;
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	for (ch=getchar();ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar()) n=(n*10+ch-'0')%mo;
	ans=n*(n+1)%mo;
	ans=ans*(n+2)%mo;
	ans=ans*ksm(6,mo-2)%mo;
	printf(&quot;%d\n&quot;,ans);
	//for (int i=1;i&lt;=500;i++) printf(&quot;%d\n&quot;,i);
	freopen(&quot;CON&quot;,&quot;r&quot;,stdin);getchar();
	return 0;
}<pre><h2>Problem3028</h2><pre>#include&lt;stdio.h&gt;
#define mod 10007
int n;
void in(int &amp;TEMP){
	int EPX;
	for(TEMP=getchar();TEMP&lt;48||TEMP&gt;57;TEMP=getchar());
	for(TEMP^=48,EPX=getchar();EPX&lt;58&amp;&amp;EPX&gt;47;EPX=getchar())
		TEMP=(TEMP&lt;&lt;3)+(TEMP&lt;&lt;1)+(EPX^48),TEMP%=mod;
}
int POW(int x,int y){
	int an=1;
	while(y){
		if(y&amp;1) an=an*x%mod;
		x=x*x%mod,y&gt;&gt;=1;
	}
	return an;
}
int main(){
	in(n);n=n*(n+1)%mod*(n+2)%mod*POW(6,mod-2)%mod;
	printf(&quot;%d&quot;,n);
}<pre><h2>Problem3038</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
using namespace std;
typedef long long LL;
const int NN=101111;
int n,m,fa[NN];
LL c[NN];
int getfa(int x) {return fa[x]==x?x:fa[x]=getfa(fa[x]);}
void change(int i,LL x)
{
    for (;i&lt;=n;i+=(i&amp;-i)) c[i]+=x;
}
LL getsum(int i)
{
    LL res=0;
    for (;i;i-=(i&amp;-i)) res+=c[i];
    return res;
}
LL read()
{
    LL res=0;
    char ch=getchar();
    while (ch&lt;'0'||ch&gt;'9') ch=getchar();
    for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar()) res=res*10+ch-'0';
    return res;
}
int main()
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    n=read();
    LL i,x,y,z;
    for (i=1;i&lt;=n;i++)
    {
        x=read();
        change(i,x);
        fa[i]=i;
    }
    fa[n+1]=n+1;
    m=read();
    for (i=1;i&lt;=m;i++)
    {
        x=read(),y=read(),z=read();
        if (y&gt;z) {LL t=y;y=z;z=t;}
        if (x==1) printf(&quot;%lld\n&quot;,getsum(z)-getsum(y-1));
        else
        {
            LL k=getfa(y);
            while (k&lt;=z)
            {
                x=getsum(k)-getsum(k-1);
                y=(LL)sqrt(x);
                change(k,y-x);
                if (x&lt;=1) fa[k]=k+1;
                k=getfa(k+1);
            }
        }
    }
    return 0;
}<pre><h2>Problem3039</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int mn=1100;
int ll[mn][mn],left[mn][mn],rr[mn][mn],right[mn][mn],up[mn][mn],a[mn][mn];
int i,j,n,m,ans,tt,now;
char ch;
int max(int a,int b) {return a&gt;b?a:b;}
int min(int a,int b) {return a&lt;b?a:b;}
void init()
{
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;i++)
	{
		for (j=1;j&lt;m;j++)
		{
			scanf(&quot;%c &quot;,&amp;ch);
			a[i][j]=ch=='F'?0:1;
		}
		scanf(&quot;%c\n&quot;,&amp;ch);
		a[i][m]=ch=='F'?0:1;
	}
	scanf(&quot;\n&quot;);
}
void doit()
{
	memset(left,0,sizeof(left));
	memset(right,127,sizeof(right));
	ans=0;
	for (i=1;i&lt;=n;i++)
	{
		now=0;
		for (j=1;j&lt;=m;j++)
			if (a[i][j])
			{
				up[i][j]=left[i][j]=0;
				now=j;
			}
			else
			{
				up[i][j]=up[i-1][j]+1;
				left[i][j]=max(left[i-1][j],now+1);
			}
		now=m+1;
		for (j=m;j;j--)
			if (a[i][j])
			{
				right[i][j]=n+1;
				now=j;
			}
			else
			{
				right[i][j]=min(right[i-1][j],now-1);
				ans=max(ans,up[i][j]*(right[i][j]-left[i][j]+1));
			}
	}
	printf(&quot;%d\n&quot;,ans*3);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	//scanf(&quot;%d&quot;,&amp;tt);
	tt=1;
	for (;tt;tt--)
	{
		init();
		doit();
	}
	return 0;
}
<pre><h2>Problem3052</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
typedef pair&lt;int,int&gt; pii;
#define mp make_pair
#define fi first
#define se second
#define ln printf(&quot;\n&quot;)
const int NN=100111;
int o[NN],aa[NN&lt;&lt;1][2],dfn[NN],up[NN],size[NN],fa1[NN],fa2[NN],color[NN],color0[NN],W[NN],V[NN];
int n,m,Q,tot=1,TIME,n1,n2,blo,root1,root2;
bool vt[NN];
pair&lt;int,pii&gt; mdf[NN];
LL ans[NN];
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs(int v)
{
	dfn[v]=++TIME;
	size[up[v]]++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa1[v]) continue;
		fa1[y]=fa2[y]=v;
		if (size[up[v]]&lt;blo) up[y]=up[v];
		else up[y]=y;
		dfs(y);
	}
}
struct ppt
{
	int id,u,v,t;
	ppt(int a=0,int b=0,int c=0,int d=0) {id=a;u=b;v=c;t=d;}
	void out() {printf(&quot;id=%d u=%d v=%d t=%d\n&quot;,id,u,v,t);}
	friend bool operator &lt;(const ppt &amp;a,const ppt &amp;b)
	{
		if (up[a.u]!=up[b.u]) return up[a.u]&lt;up[b.u];
		if (up[a.v]!=up[b.v]) return up[a.v]&lt;up[b.v];
		return a.t&lt;b.t;
	}
} qry[NN];
struct Now
{
	int num[NN];LL res;
	void add(int v)
	{
		int c=color[v];
		num[c]++,res+=(LL)W[num[c]]*V[c];
		//printf(&quot;now.add(%d)\n&quot;,v);printf(&quot;res=%I64d\n&quot;,res);
	}
	void del(int v)
	{
		int c=color[v];
		res-=(LL)W[num[c]]*V[c],num[c]--;
		//printf(&quot;now.del(%d)\n&quot;,v);printf(&quot;res=%I64d\n&quot;,res);
	}
} now;
void work(int *fa,int u,int v)
{
	for (;!vt[v];v=fa[v])
	{
		vt[v]=true;
		now.add(v);
	}
	for (;u!=v;u=fa[u])
	{
		vt[u]=false;
		now.del(u);
	}
}
void changeroot(int *fa,int &amp;root,int v)
{
	int x=fa[v],y=fa[x];
	root=v,fa[v]=0;
	for (;x;v=x,x=y,y=fa[y]) fa[x]=v;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m),read(Q);
	blo=(int)pow(n,2.0/3)+1;
	int i,j,x,y,z;
	for (i=1;i&lt;=m;i++) read(V[i]);
	for (i=1;i&lt;=n;i++) read(W[i]);
	//printf(&quot;V &quot;);out(V,1,m);printf(&quot;W &quot;);out(W,1,n);ln;
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y);
		addedge(x,y),addedge(y,x);
	}
	dfs(1);
	for (i=1;i&lt;=n;i++)
		read(color0[i]),color[i]=color0[i];
	for (i=1;i&lt;=Q;i++)
	{
		read(z),read(x),read(y);
		if (z==0)
		{
			mdf[++n1]=mp(x,mp(color[x],y));
			color[x]=y;
		}
		else
		{
			if (dfn[x]&gt;dfn[y]) {int t=x;x=y;y=t;}
			qry[++n2]=ppt(i,x,y,n1);
		}
	}
	sort(qry+1,qry+n2+1);
	//printf(&quot;qry:\n&quot;);for(i=1;i&lt;=n2;i++)qry[i].out();ln;
	for (i=1;i&lt;=n;i++) color[i]=color0[i];
	root1=root2=1;
	now.add(1);
	vt[1]=true;
	int pret=0;
	for (i=1;i&lt;=n2;i++)
	{
		int u=qry[i].u,v=qry[i].v,t=qry[i].t;
		//printf(&quot;\n------------------------- u=%d v=%d t=%d ---------------------------\n&quot;,u,v,t);
		if (pret&lt;t)
			for (j=pret+1;j&lt;=t;j++)
			{
				int x=mdf[j].fi,y=mdf[j].se.se;
				if (vt[x]) now.del(x);
				color[x]=y;
				if (vt[x]) now.add(x);
			}
		else
			for (j=pret;j&gt;t;j--)
			{
				int x=mdf[j].fi,y=mdf[j].se.fi;
				if (vt[x]) now.del(x);
				color[x]=y;
				if (vt[x]) now.add(x);
			}
		//printf(&quot;===============================\n&quot;);
		work(fa1,root2,v);
		changeroot(fa2,root2,v);
		work(fa2,root1,u);
		changeroot(fa1,root1,u);
		ans[qry[i].id]=now.res;
		pret=t;
	}
	for (i=1;i&lt;=Q;i++)
		if (ans[i]) printf(&quot;%lld\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem3052</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
typedef pair&lt;int,int&gt; pii;
#define mp make_pair
#define fi first
#define se second
const int NN=100111;
int o[NN],aa[NN&lt;&lt;1][2],dfn[NN],up[NN],size[NN],fa1[NN],fa2[NN],color[NN],color0[NN],W[NN],V[NN];
int n,m,Q,tot=1,TIME,n1,n2,blo,root1,root2;
bool vt[NN];
pair&lt;int,pii&gt; mdf[NN];
LL ans[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs(int v)
{
	dfn[v]=++TIME;
	size[up[v]]++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa1[v]) continue;
		fa1[y]=fa2[y]=v;
		if (size[up[v]]&lt;blo) up[y]=up[v];
		else up[y]=y;
		dfs(y);
	}
}
struct ppt
{
	int id,u,v,t;
	ppt(int a=0,int b=0,int c=0,int d=0) {id=a;u=b;v=c;t=d;}
	friend bool operator &lt;(const ppt &amp;a,const ppt &amp;b)
	{
		if (up[a.u]!=up[b.u]) return up[a.u]&lt;up[b.u];
		if (up[a.v]!=up[b.v]) return up[a.v]&lt;up[b.v];
		return a.t&lt;b.t;
	}
} qry[NN];
struct Now
{
	int num[NN];LL res;
	void add(int v)
	{
		int c=color[v];
		num[c]++,res+=(LL)W[num[c]]*V[c];
	}
	void del(int v)
	{
		int c=color[v];
		res-=(LL)W[num[c]]*V[c],num[c]--;
	}
} now;
void work(int *fa,int u,int v)
{
	for (;!vt[v];v=fa[v])
	{
		vt[v]=true;
		now.add(v);
	}
	for (;u!=v;u=fa[u])
	{
		vt[u]=false;
		now.del(u);
	}
}
void changeroot(int *fa,int &amp;root,int v)
{
	int x=fa[v],y=fa[x];
	root=v,fa[v]=0;
	for (;x;v=x,x=y,y=fa[y]) fa[x]=v;
}
int main()
{
	read(n),read(m),read(Q);
	blo=(int)pow(n,2.0/3)+1;
	int i,j,x,y,z;
	for (i=1;i&lt;=m;i++) read(V[i]);
	for (i=1;i&lt;=n;i++) read(W[i]);
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y);
		addedge(x,y),addedge(y,x);
	}
	dfs(1);
	for (i=1;i&lt;=n;i++)
		read(color0[i]),color[i]=color0[i];
	for (i=1;i&lt;=Q;i++)
	{
		read(z),read(x),read(y);
		if (z==0)
		{
			mdf[++n1]=mp(x,mp(color[x],y));
			color[x]=y;
		}
		else
		{
			if (dfn[x]&gt;dfn[y]) {int t=x;x=y;y=t;}
			qry[++n2]=ppt(i,x,y,n1);
		}
	}
	sort(qry+1,qry+n2+1);
	for (i=1;i&lt;=n;i++) color[i]=color0[i];
	root1=root2=1;
	now.add(1);
	vt[1]=true;
	int pret=0;
	for (i=1;i&lt;=n2;i++)
	{
		int u=qry[i].u,v=qry[i].v,t=qry[i].t;
		if (pret&lt;t)
			for (j=pret+1;j&lt;=t;j++)
			{
				int x=mdf[j].fi,y=mdf[j].se.se;
				if (vt[x]) now.del(x);
				color[x]=y;
				if (vt[x]) now.add(x);
			}
		else
			for (j=pret;j&gt;t;j--)
			{
				int x=mdf[j].fi,y=mdf[j].se.fi;
				if (vt[x]) now.del(x);
				color[x]=y;
				if (vt[x]) now.add(x);
			}
		work(fa1,root2,v);
		changeroot(fa2,root2,v);
		work(fa2,root1,u);
		changeroot(fa1,root1,u);
		ans[qry[i].id]=now.res;
		pret=t;
	}
	for (i=1;i&lt;=Q;i++)
		if (ans[i]) printf(&quot;%lld\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem3052</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
typedef pair&lt;int,int&gt; pii;
#define mp make_pair
#define fi first
#define se second
const int NN=100111;
int o[NN],aa[NN&lt;&lt;1][2],dfn[NN],up[NN],size[NN],fa1[NN],fa2[NN],color[NN],color0[NN],W[NN],V[NN];
int n,m,Q,tot=1,TIME,n1,n2,blo,root1,root2;
bool vt[NN];
pair&lt;int,pii&gt; mdf[NN];
LL ans[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs(int v)
{
	dfn[v]=++TIME;
	size[up[v]]++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa1[v]) continue;
		fa1[y]=fa2[y]=v;
		if (size[up[v]]&lt;blo) up[y]=up[v];
		else up[y]=y;
		dfs(y);
	}
}
struct ppt
{
	int id,u,v,t;
	ppt(int a=0,int b=0,int c=0,int d=0) {id=a;u=b;v=c;t=d;}
	friend bool operator &lt;(const ppt &amp;a,const ppt &amp;b)
	{
		if (up[a.u]!=up[b.u]) return up[a.u]&lt;up[b.u];
		if (up[a.v]!=up[b.v]) return up[a.v]&lt;up[b.v];
		return a.t&lt;b.t;
	}
} qry[NN];
struct Now
{
	int num[NN];LL res;
	void add(int v)
	{
		int c=color[v];
		num[c]++,res+=(LL)W[num[c]]*V[c];
	}
	void del(int v)
	{
		int c=color[v];
		res-=(LL)W[num[c]]*V[c],num[c]--;
	}
} now;
void work(int *fa,int u,int v)
{
	for (;!vt[v];v=fa[v])
	{
		vt[v]=true;
		now.add(v);
	}
	for (;u!=v;u=fa[u])
	{
		vt[u]=false;
		now.del(u);
	}
}
void changeroot(int *fa,int &amp;root,int v)
{
	int x=fa[v],y=fa[x];
	root=v,fa[v]=0;
	for (;x;v=x,x=y,y=fa[y]) fa[x]=v;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m),read(Q);
	blo=(int)pow(n,2.0/3)+1;
	int i,j,x,y,z;
	for (i=1;i&lt;=m;i++) read(V[i]);
	for (i=1;i&lt;=n;i++) read(W[i]);
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y);
		addedge(x,y),addedge(y,x);
	}
	dfs(1);
	for (i=1;i&lt;=n;i++)
		read(color0[i]),color[i]=color0[i];
	for (i=1;i&lt;=Q;i++)
	{
		read(z),read(x),read(y);
		if (z==0)
		{
			mdf[++n1]=mp(x,mp(color[x],y));
			color[x]=y;
		}
		else
		{
			if (dfn[x]&gt;dfn[y]) {int t=x;x=y;y=t;}
			qry[++n2]=ppt(i,x,y,n1);
		}
	}
	sort(qry+1,qry+n2+1);
	for (i=1;i&lt;=n;i++) color[i]=color0[i];
	root1=root2=1;
	now.add(1);
	vt[1]=true;
	int pret=0;
	for (i=1;i&lt;=n2;i++)
	{
		int u=qry[i].u,v=qry[i].v,t=qry[i].t;
		if (pret&lt;t)
			for (j=pret+1;j&lt;=t;j++)
			{
				int x=mdf[j].fi,y=mdf[j].se.se;
				if (vt[x]) now.del(x);
				color[x]=y;
				if (vt[x]) now.add(x);
			}
		else
			for (j=pret;j&gt;t;j--)
			{
				int x=mdf[j].fi,y=mdf[j].se.fi;
				if (vt[x]) now.del(x);
				color[x]=y;
				if (vt[x]) now.add(x);
			}
		work(fa1,root2,v);
		changeroot(fa2,root2,v);
		work(fa2,root1,u);
		changeroot(fa1,root1,u);
		ans[qry[i].id]=now.res;
		pret=t;
	}
	for (i=1;i&lt;=Q;i++)
		if (ans[i]) printf(&quot;%lld\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem3052</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;

#define maxn 100010

using namespace std;

typedef long long ll;
int n,m,p,belong[maxn],dfn[maxn],tot,b[maxn],num,sta[maxn],top,dep[maxn],fa[maxn][20];
int blo,blonum,f[maxn],col[maxn],pre[maxn],s1,s2;
ll Ans[maxn],ans,v[maxn],w[maxn];
bool vis[maxn];

inline int read()
{
	int ret=0;char ch=getchar();
	while(ch&lt;'!') ch=getchar();
	while(ch&gt;'!') ret=ret*10+ch-'0',ch=getchar();
	return ret;
}

struct query{
	int x,y,id,pre;
	friend bool operator &lt; (const query &amp;a,const query &amp;b){
		if(belong[a.x]==belong[b.x]){
			if(dfn[a.y]==dfn[b.y]) return a.id&lt;b.id;
			return dfn[a.y]&lt;dfn[b.y];
		}
		return belong[a.x]&lt;belong[b.x];
	}
}q[maxn],c[maxn];

struct edge{
	int x,y,last;
}a[maxn&lt;&lt;1];

void add(int x,int y)
{
	tot++;
	a[tot]=(edge){x,y,b[x]};
	b[x]=tot;
}

int dfs(int x)
{
	for(int i=1;i&lt;=17;i++) fa[x][i]=fa[fa[x][i-1]][i-1];
	dfn[x]=++num;int siz=0;
	for(int i=b[x];i;i=a[i].last){
		int v=a[i].y;
		if(!dfn[v]){
			fa[v][0]=x;
			dep[v]=dep[x]+1;
			siz+=dfs(v);
			if(siz&gt;=blo){
				++blonum;
				for(int k=1;k&lt;=siz;k++) belong[sta[top--]]=blonum;
				siz=0;
			}
		}
	}
	sta[++top]=x;
	return siz+1;
}

int lca(int x,int y)
{
	if(dep[x]&lt;dep[y]) swap(x,y);
	for(int i=17;i&gt;=0;i--) if(dep[fa[x][i]]&gt;=dep[y]) x=fa[x][i];
	if(x==y) return x;
	for(int i=17;i&gt;=0;i--) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}

void change(int x,int c)
{
	if(vis[x]){
		ans-=v[f[col[x]]]*w[col[x]];
		f[col[x]]--;
		col[x]=c;
		f[col[x]]++;
		ans+=v[f[col[x]]]*w[col[x]];
	}else col[x]=c;
}

void reserve(int x)
{
	if(vis[x]){
		ans-=v[f[col[x]]]*w[col[x]];
		f[col[x]]--;
		vis[x]=0;
	}else{
		f[col[x]]++;
		ans+=v[f[col[x]]]*w[col[x]];
		vis[x]=1;
	}
}

void solve(int x,int y)
{
	
	while(x!=y){
		if(dep[x]&gt;dep[y]) reserve(x),x=fa[x][0];
		else reserve(y),y=fa[y][0];
	}
}

bool cmp(const query &amp;a,const query &amp;b)
{
	return a.id&lt;b.id;
}

int main()
{
	n=read(),m=read(),p=read();
	blo=sqrt(n);
	for(int i=1;i&lt;=m;i++) w[i]=(ll)read();
	for(int i=1;i&lt;=n;i++) v[i]=(ll)read();
	for(int i=1;i&lt;n;i++){
		int x=read(),y=read();
		add(x,y);add(y,x);
	}
	dep[1]=1;
	dfs(1);
	++blonum;
	while(top) belong[sta[top--]]=blonum;
	for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;col[i]),pre[i]=col[i];
	for(int i=1;i&lt;=p;i++){
		int cmd=read(),x=read(),y=read();
		if(cmd){
			q[++s1]=(query){x,y,i};
		}else{
			c[++s2]=(query){x,y,i};
			c[s2].pre=pre[x];pre[x]=y;
		}
	}
	int now=1;
	sort(q+1,q+s1+1);
	while(c[now].id&lt;q[1].id&amp;&amp;now&lt;=s2) change(c[now].x,c[now].y),now++;
	solve(q[1].x,q[1].y);
	int t=lca(q[1].x,q[1].y);
	reserve(t);
	Ans[q[1].id]=ans;
	reserve(t);
	for(int i=2;i&lt;=s1;i++){
		if(q[i-1].id&lt;q[i].id){
			while(now&lt;=s2&amp;&amp;c[now].id&lt;=q[i].id) change(c[now].x,c[now].y),now++;
		}else{
			while(now-1&gt;0&amp;&amp;c[now-1].id&gt;q[i].id) change(c[now-1].x,c[now-1].pre),now--;
		}
		solve(q[i-1].x,q[i].x);
		solve(q[i-1].y,q[i].y);
		t=lca(q[i].x,q[i].y);
		reserve(t);
		Ans[q[i].id]=ans;
		reserve(t);
	}
	sort(q+1,q+s1+1,cmp);
	for(int i=1;i&lt;=s1;i++){
		 printf(&quot;%lld\n&quot;,Ans[q[i].id]);
	}
	return 0;
}<pre><h2>Problem3052</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;

#define maxn 100010

using namespace std;

typedef long long ll;
int n,m,p,belong[maxn],dfn[maxn],tot,b[maxn],num,sta[maxn],top,dep[maxn],fa[maxn][20];
int blo,blonum,f[maxn],col[maxn],pre[maxn],s1,s2;
ll Ans[maxn],ans,v[maxn],w[maxn];
bool vis[maxn];

inline int read()
{
	int ret=0;char ch=getchar();
	while(ch&lt;'!') ch=getchar();
	while(ch&gt;'!') ret=ret*10+ch-'0',ch=getchar();
	return ret;
}

struct query{
	int x,y,id,pre;
	friend bool operator &lt; (const query &amp;a,const query &amp;b){
		if(belong[a.x]==belong[b.x]){
			if(dfn[a.y]==dfn[b.y]) return a.id&lt;b.id;
			return dfn[a.y]&lt;dfn[b.y];
		}
		return belong[a.x]&lt;belong[b.x];
	}
}q[maxn],c[maxn];

struct edge{
	int x,y,last;
}a[maxn&lt;&lt;1];

void add(int x,int y)
{
	tot++;
	a[tot]=(edge){x,y,b[x]};
	b[x]=tot;
}

int dfs(int x)
{
	for(int i=1;i&lt;=17;i++) fa[x][i]=fa[fa[x][i-1]][i-1];
	dfn[x]=++num;int siz=0;
	for(int i=b[x];i;i=a[i].last){
		int v=a[i].y;
		if(!dfn[v]){
			fa[v][0]=x;
			dep[v]=dep[x]+1;
			siz+=dfs(v);
			if(siz&gt;=blo){
				++blonum;
				for(int k=1;k&lt;=siz;k++) belong[sta[top--]]=blonum;
				siz=0;
			}
		}
	}
	sta[++top]=x;
	return siz+1;
}

int lca(int x,int y)
{
	if(dep[x]&lt;dep[y]) swap(x,y);
	for(int i=17;i&gt;=0;i--) if(dep[fa[x][i]]&gt;=dep[y]) x=fa[x][i];
	if(x==y) return x;
	for(int i=17;i&gt;=0;i--) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}

void change(int x,int c)
{
	if(vis[x]){
		ans-=v[f[col[x]]]*w[col[x]];
		f[col[x]]--;
		col[x]=c;
		f[col[x]]++;
		ans+=v[f[col[x]]]*w[col[x]];
	}else col[x]=c;
}

void reserve(int x)
{
	if(vis[x]){
		ans-=v[f[col[x]]]*w[col[x]];
		f[col[x]]--;
		vis[x]=0;
	}else{
		f[col[x]]++;
		ans+=v[f[col[x]]]*w[col[x]];
		vis[x]=1;
	}
}

void solve(int x,int y)
{
	
	while(x!=y){
		if(dep[x]&gt;dep[y]) reserve(x),x=fa[x][0];
		else reserve(y),y=fa[y][0];
	}
}

bool cmp(const query &amp;a,const query &amp;b)
{
	return a.id&lt;b.id;
}

int main()
{
	n=read(),m=read(),p=read();
	blo=1500;
	for(int i=1;i&lt;=m;i++) w[i]=(ll)read();
	for(int i=1;i&lt;=n;i++) v[i]=(ll)read();
	for(int i=1;i&lt;n;i++){
		int x=read(),y=read();
		add(x,y);add(y,x);
	}
	dep[1]=1;
	dfs(1);
	++blonum;
	while(top) belong[sta[top--]]=blonum;
	for(int i=1;i&lt;=n;i++) col[i]=read(),pre[i]=col[i];
	for(int i=1;i&lt;=p;i++){
		int cmd=read(),x=read(),y=read();
		if(cmd){
			q[++s1]=(query){x,y,i};
		}else{
			c[++s2]=(query){x,y,i};
			c[s2].pre=pre[x];pre[x]=y;
		}
	}
	int now=1;
	sort(q+1,q+s1+1);
	while(c[now].id&lt;q[1].id&amp;&amp;now&lt;=s2) change(c[now].x,c[now].y),now++;
	solve(q[1].x,q[1].y);
	int t=lca(q[1].x,q[1].y);
	reserve(t);
	Ans[q[1].id]=ans;
	reserve(t);
	for(int i=2;i&lt;=s1;i++){
		solve(q[i-1].x,q[i].x);
		solve(q[i-1].y,q[i].y);
		if(q[i-1].id&lt;q[i].id){
			while(now&lt;=s2&amp;&amp;c[now].id&lt;=q[i].id) change(c[now].x,c[now].y),now++;
		}else{
			while(now-1&gt;0&amp;&amp;c[now-1].id&gt;q[i].id) change(c[now-1].x,c[now-1].pre),now--;
		}
		t=lca(q[i].x,q[i].y);
		reserve(t);
		Ans[q[i].id]=ans;
		reserve(t);
	}
	sort(q+1,q+s1+1,cmp);
	for(int i=1;i&lt;=s1;i++){
		 printf(&quot;%lld\n&quot;,Ans[q[i].id]);
	}
	return 0;
}
<pre><h2>Problem3052</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;

#define maxn 100010

using namespace std;

typedef long long ll;
int n,m,p,belong[maxn],dfn[maxn],tot,b[maxn],num,sta[maxn],top,dep[maxn],fa[maxn][20];
int blo,blonum,f[maxn],col[maxn],pre[maxn],s1,s2;
ll Ans[maxn],ans,v[maxn],w[maxn];
bool vis[maxn];

inline int read()
{
	int ret=0;char ch=getchar();
	while(ch&lt;'!') ch=getchar();
	while(ch&gt;'!') ret=ret*10+ch-'0',ch=getchar();
	return ret;
}

struct query{
	int x,y,id,pre;
	friend bool operator &lt; (const query &amp;a,const query &amp;b){
		if(belong[a.x]==belong[b.x]){
			if(belong[a.y]==belong[b.y]) return a.id&lt;b.id;
			return belong[a.y]&lt;belong[b.y];
		}
		return belong[a.x]&lt;belong[b.x];
	}
}q[maxn],c[maxn];

struct edge{
	int x,y,last;
}a[maxn&lt;&lt;1];

void add(int x,int y)
{
	tot++;
	a[tot]=(edge){x,y,b[x]};
	b[x]=tot;
}

int dfs(int x)
{
	for(int i=1;i&lt;=17;i++) fa[x][i]=fa[fa[x][i-1]][i-1];
	dfn[x]=++num;int siz=0;
	for(int i=b[x];i;i=a[i].last){
		int v=a[i].y;
		if(!dfn[v]){
			fa[v][0]=x;
			dep[v]=dep[x]+1;
			siz+=dfs(v);
			if(siz&gt;=blo){
				++blonum;
				for(int k=1;k&lt;=siz;k++) belong[sta[top--]]=blonum;
				siz=0;
			}
		}
	}
	sta[++top]=x;
	return siz+1;
}

int lca(int x,int y)
{
	if(dep[x]&lt;dep[y]) swap(x,y);
	for(int i=17;i&gt;=0;i--) if(dep[fa[x][i]]&gt;=dep[y]) x=fa[x][i];
	if(x==y) return x;
	for(int i=17;i&gt;=0;i--) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}

void change(int x,int c)
{
	if(vis[x]){
		ans-=v[f[col[x]]]*w[col[x]];
		f[col[x]]--;
		col[x]=c;
		f[col[x]]++;
		ans+=v[f[col[x]]]*w[col[x]];
	}else col[x]=c;
}

void reserve(int x)
{
	if(vis[x]){
		ans-=v[f[col[x]]]*w[col[x]];
		f[col[x]]--;
		vis[x]=0;
	}else{
		f[col[x]]++;
		ans+=v[f[col[x]]]*w[col[x]];
		vis[x]=1;
	}
}

void solve(int x,int y)
{
	
	while(x!=y){
		if(dep[x]&gt;dep[y]) reserve(x),x=fa[x][0];
		else reserve(y),y=fa[y][0];
	}
}

bool cmp(const query &amp;a,const query &amp;b)
{
	return a.id&lt;b.id;
}

int main()
{
	n=read(),m=read(),p=read();
	blo=1500;
	for(int i=1;i&lt;=m;i++) w[i]=(ll)read();
	for(int i=1;i&lt;=n;i++) v[i]=(ll)read();
	for(int i=1;i&lt;n;i++){
		int x=read(),y=read();
		add(x,y);add(y,x);
	}
	dep[1]=1;
	dfs(1);
	++blonum;
	while(top) belong[sta[top--]]=blonum;
	for(int i=1;i&lt;=n;i++) col[i]=read(),pre[i]=col[i];
	for(int i=1;i&lt;=p;i++){
		int cmd=read(),x=read(),y=read();
		if(cmd){
			q[++s1]=(query){x,y,i};
		}else{
			c[++s2]=(query){x,y,i};
			c[s2].pre=pre[x];pre[x]=y;
		}
	}
	int now=1;
	sort(q+1,q+s1+1);
	while(c[now].id&lt;q[1].id&amp;&amp;now&lt;=s2) change(c[now].x,c[now].y),now++;
	solve(q[1].x,q[1].y);
	int t=lca(q[1].x,q[1].y);
	reserve(t);
	Ans[q[1].id]=ans;
	reserve(t);
	for(int i=2;i&lt;=s1;i++){
		solve(q[i-1].x,q[i].x);
		solve(q[i-1].y,q[i].y);
		if(q[i-1].id&lt;q[i].id){
			while(now&lt;=s2&amp;&amp;c[now].id&lt;=q[i].id) change(c[now].x,c[now].y),now++;
		}else{
			while(now-1&gt;0&amp;&amp;c[now-1].id&gt;q[i].id) change(c[now-1].x,c[now-1].pre),now--;
		}
		t=lca(q[i].x,q[i].y);
		reserve(t);
		Ans[q[i].id]=ans;
		reserve(t);
	}
	sort(q+1,q+s1+1,cmp);
	for(int i=1;i&lt;=s1;i++){
		 printf(&quot;%lld\n&quot;,Ans[q[i].id]);
	}
	return 0;
}<pre><h2>Problem3052</h2><pre>
#define MAXN 100010UL
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define ll long long

using namespace std;

int n, m, t, q, num, cnt, fv[MAXN][2], pr[MAXN], bin[30], ti[MAXN], blo, hd, sta[MAXN], bg[MAXN], d[MAXN], dfn[MAXN], sn[MAXN], w[MAXN], v[MAXN], c[MAXN], fa[MAXN][20];
bool vis[MAXN];
ll ans, Ans[MAXN];

struct ME {
	int hou, nt;
}sg[MAXN&lt;&lt;1];

struct RING {
	int lt, rt, id, t;
}st[MAXN];

inline void Add(int x, int y) {
	sg[++ t].hou = y;
	sg[t].nt = d[x];
	d[x] = t;
	return;
}

int Dfs(int x, int dep) {
	sn[x] = dep, dfn[x] = ++ num;
	int se = 0;
	for(int i = 1 ; bin[i] &lt;= sn[x] ; ++ i) fa[x][i] = fa[fa[x][i-1]][i-1];
	for(int i = d[x] ; i != -1 ; i = sg[i].nt) {
		if(!sn[sg[i].hou]) {
			fa[sg[i].hou][0] = x;
			se += Dfs(sg[i].hou, dep+1);
			if(se&gt;=blo) {
				++ cnt;
				for(int j = 1 ; j &lt;= se ; ++ j) bg[sta[hd --]] = cnt;
				se = 0;
			}
		}
	}
	sta[++ hd] = x;
	return se+1;
}

inline bool Comp(RING x, RING y) {
	if(bg[x.lt]==bg[y.lt]&amp;&amp;bg[x.rt]==bg[y.rt]) return x.id&lt;y.id;
	return bg[x.lt]==bg[y.lt]?bg[x.rt]&lt;bg[y.rt]:bg[x.lt]&lt;bg[y.lt];
}

inline void Reverse(int x) {
	if(!vis[x]) {
		vis[x] = true;
		ans += (ll)w[++ ti[c[x]]]*(ll)v[c[x]];
	} else {
		vis[x] = false;
		ans -= (ll)w[ti[c[x]] --]*(ll)v[c[x]];
	}
	return;
}

inline void Change(int x, int y) {
	if(vis[x]) {
		ans -= (ll)w[ti[c[x]] --]*(ll)v[c[x]];
		c[x] = y;
		ans += (ll)w[++ ti[c[x]]]*(ll)v[c[x]];
	} else c[x] = y;
	return;
}

inline void Solve(int x, int y) {
	while(x!=y) {
		if(sn[x]&gt;sn[y]) Reverse(x), x = fa[x][0];
		else Reverse(y), y = fa[y][0];
	}
	return;
}

inline int Get_lca(int x, int y) {
	if(sn[x]&lt;sn[y]) swap(x, y);
	int j;
	for(j = 0 ; bin[j]&lt;=sn[x] ; ++ j);
	-- j;
	for(int i = j ; i &gt;= 0 ; -- i) if(sn[fa[x][i]]&gt;=sn[y]) x = fa[x][i];
	if(x==y) return x;
	for(int i = j ; i &gt;= 0 ; -- i) if(fa[x][i]!=fa[y][i]) x = fa[x][i], y = fa[y][i];
	return fa[x][0];
}

int main() {
//	freopen(&quot;park.in&quot;, &quot;r&quot;, stdin);
//	freopen(&quot;park.out&quot;, &quot;w&quot;, stdout);
	int __size__ = 30 &lt;&lt; 20;
	char *__p__ = (char*)malloc(__size__) + __size__;
	__asm__(&quot;movl %0, %%esp\n&quot; :: &quot;r&quot;(__p__));
	memset(d, -1, sizeof(d));
	bin[0] = 1;
	for(int i = 1 ; i &lt;= 20 ; ++ i) bin[i] = bin[i-1]&lt;&lt;1;
	int x, y, z;
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q);
	for(int i = 1 ; i &lt;= m ; ++ i) scanf(&quot;%d&quot;, &amp;v[i]);
	for(int i = 1 ; i &lt;= n ; ++ i) scanf(&quot;%d&quot;, &amp;w[i]);
	for(int i = 1 ; i &lt; n ; ++ i) {
		scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
		Add(x, y), Add(y, x);
	}
	blo = 1500, Dfs(1, 1);
//	for(int i = 1 ; i &lt;= 10000 ; ++ i) printf(&quot;bg[%d] = %d %d %d\n&quot;, i, bg[i], blo, n);
	num = t = 0;
	for(int i = 1 ; i &lt;= n ; ++ i) scanf(&quot;%d&quot;, &amp;c[i]);
	for(int i = 1 ; i &lt;= q ; ++ i) {
		scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);
		if(x==0) ++ t, fv[t][0] = y, fv[t][1] = z;
		else {
			if(bg[y]&gt;bg[z]) swap(y, z);
			++ num, st[num].lt = y, st[num].rt = z, st[num].t = t, st[num].id = num;
		}
	}
	sort(st+1, st+num+1, Comp);
	int anc = Get_lca(st[1].lt, st[1].rt);
	Solve(st[1].lt, st[1].rt);
	for(int i = 1 ; i &lt;= st[1].t ; ++ i) pr[i] = c[fv[i][0]], Change(fv[i][0], fv[i][1]);
	Reverse(anc), Ans[st[1].id] = ans, Reverse(anc);
	int tt = st[1].t;
	for(int i = 2 ; i &lt;= num ; ++ i) {
	//	printf(&quot;i = %d\n&quot;, i);
		Solve(st[i-1].lt, st[i].lt);
		Solve(st[i-1].rt, st[i].rt);
		anc = Get_lca(st[i].lt, st[i].rt);
		while(tt&gt;st[i].t) {
			Change(fv[tt][0], pr[tt]);
			-- tt;
		}
		while(tt&lt;st[i].t) {
			++ tt;
			pr[tt] = c[fv[tt][0]];
			Change(fv[tt][0], fv[tt][1]);
		}
		Reverse(anc), Ans[st[i].id] = ans, Reverse(anc);
	}
	for(int i = 1 ; i &lt;= num ; ++ i) printf(&quot;%lld\n&quot;, Ans[i]);
//	while(1);
	return 0;
}
<pre><h2>Problem3056</h2><pre>main(){}<pre><h2>Problem3065</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int fw=70011,NN=fw,AA=20000000;
int size[NN],lc[NN],rc[NN],key[NN],b[NN],fa[NN];
int n,m,TTT1,TTT2,need,cnt,root;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9')
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar();
}
struct segnode
{
	int ls,rs,size;
	void clear() {ls=rs=size=0;}
} T[AA];
struct Huishouzhan
{
	vector&lt;int&gt; a;
	void push(int v)
	{
		T[v].clear();
		a.push_back(v);
	}
	int go()
	{
		if (!a.empty())
		{
			int tmp=a.back();
			a.pop_back();
			return tmp;
		}
		else return ++TTT2;
	}
} box;
struct Seg
{
	int root;
	void ins(int &amp;v,int l,int r,int x,int kind)
	{
		if (!v) v=box.go();
		T[v].size+=kind;
		if (r-l==1) return;
		int mid=(l+r)&gt;&gt;1;
		if (x&lt;mid) ins(T[v].ls,l,mid,x,kind);
		else ins(T[v].rs,mid,r,x,kind);
	}
	void huishou(int v)
	{
		if (!v) return;
		huishou(T[v].ls),huishou(T[v].rs);
		box.push(v);
	}
	int rank(int v,int l,int r,int x)
	{
		//printf(&quot;seg rank %d %d %d %d\n&quot;,v,l,r,x);
		if (!v) return 0;
		if (r&lt;=x) return T[v].size;
		int mid=(l+r)&gt;&gt;1;
		int res=rank(T[v].ls,l,mid,x);
		if (x&gt;mid) res+=rank(T[v].rs,mid,r,x);
		return res;
	}
	void ins(int x) {ins(root,0,fw,x,1);}
	void del(int x) {ins(root,0,fw,x,-1);}
	void huishou() {huishou(root);root=0;}
	int rank(int x) {return rank(root,0,fw,x);}
} E[NN];
inline void update(int v)
{
	size[v]=size[lc[v]]+size[rc[v]]+1;
}
int build(int l,int r)
{
	int mid=(l+r)&gt;&gt;1;
	int v=b[mid];
	E[v].huishou();
	for (int i=l;i&lt;=r;i++)
		E[v].ins(key[b[i]]);//,printf(&quot;E[%d].ins(%d)\n&quot;,v,key[b[mid]]);
	lc[v]=rc[v]=0;
	if (l&lt;mid) lc[v]=build(l,mid-1),fa[lc[v]]=v;
	if (r&gt;mid) rc[v]=build(mid+1,r),fa[rc[v]]=v;
	update(v);
	//printf(&quot;v=%d lc=%d rc=%d\n&quot;,v,lc[v],rc[v]);
	return v;
}
int rank(int v,int x,int y)//v的子树的前x个里有几个比y小 
{
	//printf(&quot;rank %d %d %d\n&quot;,v,x,y);
	if (!v||!x) return 0;
	int tmp=size[lc[v]];
	//printf(&quot;tmp=%d\n&quot;,tmp);
	if (x&lt;=tmp) return rank(lc[v],x,y);
	int res=E[lc[v]].rank(y);
	//printf(&quot;res=%d\n&quot;,res);printf(&quot;key[v]=%d\n&quot;,key[v]);
	if (key[v]&lt;y) res++;
	return res+rank(rc[v],x-tmp-1,y);
}
int find(int v,int x)
{
	int tmp=size[lc[v]];
	if (x&lt;=tmp) return find(lc[v],x);
	if (x==tmp+1) return key[v];
	return find(rc[v],x-tmp-1);
}
void modify(int v,int x,int pre,int now)
{
	//printf(&quot;modify %d %d %d %d\n&quot;,v,x,pre,now);
	E[v].del(pre),E[v].ins(now);
	int tmp=size[lc[v]];
	if (x&lt;=tmp) modify(lc[v],x,pre,now);
	else if (x==tmp+1) key[v]=now;
	else modify(rc[v],x-tmp-1,pre,now);
}
inline bool balance(int v)
{
	double tmp=size[v]*0.8;
	return size[lc[v]]&lt;tmp&amp;&amp;size[rc[v]]&lt;tmp;
}
void ins(int &amp;v,int x,int y,int ff)
{
	if (v==0)
	{
		v=++TTT1;
		key[v]=y;
		fa[v]=ff;
		size[v]=1;
		E[v].ins(y);
		return;
	}
	//printf(&quot;ins %d %d %d %d\n&quot;,v,x,y,ff);
	E[v].ins(y);
	int tmp=size[lc[v]];
	if (x&lt;=tmp) ins(lc[v],x,y,v);
	else ins(rc[v],x-tmp-1,y,v);
	update(v);
	if (!balance(v)) need=v;
}
void bianli(int v)
{
	if (lc[v]) bianli(lc[v]);
	b[++cnt]=v;
	if (rc[v]) bianli(rc[v]);
}
void rebuild(int v)
{
	cnt=0;
	bianli(v);
	int f=fa[v],p=(v==rc[f]),t=build(1,cnt);
	//printf(&quot;b &quot;);for(int i=1;i&lt;=cnt;i++) printf(&quot;%d &quot;,b[i]);ln;
	fa[t]=f;
	if (p) rc[f]=t;else lc[f]=t;
	if (v==root) root=t;
}
void debug(int v)
{
	if (v==0) return;
	printf(&quot;v=%d key=%d  lc=%d rc=%d fa=%d\n&quot;,v,key[v],lc[v],rc[v],fa[v]);
	debug(lc[v]),debug(rc[v]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);
	int i,x,y,K;
	for (i=1;i&lt;=n;i++)
		read(key[i]),b[i]=i,
	TTT1=n;
	root=build(1,n);
	int lastans=0;
	for (read(m);m;m--)
	{
		char ch=getchar();
		while (ch!='I'&amp;&amp;ch!='M'&amp;&amp;ch!='Q') ch=getchar();
		//printf(&quot;\n----------------------------- ch=%c --------------------------------------\n&quot;,ch);
		//printf(&quot;debug:\n&quot;);debug(root);
		read(x),read(y);
		x^=lastans,y^=lastans;
		if (ch=='Q')
		{
			read(K);
			K^=lastans;
			int l=0,r=fw,res=-1;
			while (l&lt;=r)
			{
				int mid=(l+r)&gt;&gt;1;
				int t1=rank(root,y,mid),t2=rank(root,x-1,mid);
				//printf(&quot;l=%d r=%d mid=%d t1=%d t2=%d\n&quot;,l,r,mid,t1,t2);
				int tmp=t1-t2;
				if (tmp+1&lt;=K) res=mid,l=mid+1;
				else r=mid-1;
			}
			printf(&quot;%d\n&quot;,lastans=res);
		}
		else if (ch=='M')
		{
			int preval=find(root,x);
			//printf(&quot;preval=%d\n&quot;,preval);
			modify(root,x,preval,y);
			//printf(&quot;debug:\n&quot;);debug(root);
		}
		else
		{
			need=0;
			ins(root,x-1,y,0);
			//printf(&quot;debug:\n&quot;);debug(root);printf(&quot;need=%d\n&quot;,need);
			if (need) rebuild(need);
		}
	}
	return 0;
}<pre><h2>Problem3065</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int fw=70011,NN=fw,AA=20000000;
int size[NN],lc[NN],rc[NN],key[NN],b[NN],fa[NN];
int n,m,TTT1,TTT2,need,cnt,root;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9')
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar();
}
struct segnode
{
	int ls,rs,size;
	void clear() {ls=rs=size=0;}
} T[AA];
struct Huishouzhan
{
	vector&lt;int&gt; a;
	void push(int v)
	{
		T[v].clear();
		a.push_back(v);
	}
	int go()
	{
		if (!a.empty())
		{
			int tmp=a.back();
			a.pop_back();
			return tmp;
		}
		else return ++TTT2;
	}
} box;
struct Seg
{
	int root;
	void ins(int &amp;v,int l,int r,int x,int kind)
	{
		if (!v) v=box.go();
		T[v].size+=kind;
		if (r-l==1) return;
		int mid=(l+r)&gt;&gt;1;
		if (x&lt;mid) ins(T[v].ls,l,mid,x,kind);
		else ins(T[v].rs,mid,r,x,kind);
	}
	void huishou(int v)
	{
		if (!v) return;
		huishou(T[v].ls),huishou(T[v].rs);
		box.push(v);
	}
	int rank(int v,int l,int r,int x)
	{
		if (!v) return 0;
		if (r&lt;=x) return T[v].size;
		int mid=(l+r)&gt;&gt;1;
		int res=rank(T[v].ls,l,mid,x);
		if (x&gt;mid) res+=rank(T[v].rs,mid,r,x);
		return res;
	}
	void ins(int x) {ins(root,0,fw,x,1);}
	void del(int x) {ins(root,0,fw,x,-1);}
	void huishou() {huishou(root);root=0;}
	int rank(int x) {return rank(root,0,fw,x);}
} E[NN];
inline void update(int v)
{
	size[v]=size[lc[v]]+size[rc[v]]+1;
}
int build(int l,int r)
{
	int mid=(l+r)&gt;&gt;1;
	int v=b[mid];
	E[v].huishou();
	for (int i=l;i&lt;=r;i++)
		E[v].ins(key[b[i]]);
	lc[v]=rc[v]=0;
	if (l&lt;mid) lc[v]=build(l,mid-1),fa[lc[v]]=v;
	if (r&gt;mid) rc[v]=build(mid+1,r),fa[rc[v]]=v;
	update(v);
	return v;
}
int rank(int v,int x,int y)
{
	if (!v||!x) return 0;
	int tmp=size[lc[v]];
	if (x&lt;=tmp) return rank(lc[v],x,y);
	int res=E[lc[v]].rank(y);
	if (key[v]&lt;y) res++;
	return res+rank(rc[v],x-tmp-1,y);
}
int find(int v,int x)
{
	int tmp=size[lc[v]];
	if (x&lt;=tmp) return find(lc[v],x);
	if (x==tmp+1) return key[v];
	return find(rc[v],x-tmp-1);
}
void modify(int v,int x,int pre,int now)
{
	E[v].del(pre),E[v].ins(now);
	int tmp=size[lc[v]];
	if (x&lt;=tmp) modify(lc[v],x,pre,now);
	else if (x==tmp+1) key[v]=now;
	else modify(rc[v],x-tmp-1,pre,now);
}
inline bool balance(int v)
{
	double tmp=size[v]*0.8;
	return size[lc[v]]&lt;tmp&amp;&amp;size[rc[v]]&lt;tmp;
}
void ins(int &amp;v,int x,int y,int ff)
{
	if (v==0)
	{
		v=++TTT1;
		key[v]=y;
		fa[v]=ff;
		size[v]=1;
		E[v].ins(y);
		return;
	}
	E[v].ins(y);
	int tmp=size[lc[v]];
	if (x&lt;=tmp) ins(lc[v],x,y,v);
	else ins(rc[v],x-tmp-1,y,v);
	update(v);
	if (!balance(v)) need=v;
}
void bianli(int v)
{
	if (lc[v]) bianli(lc[v]);
	b[++cnt]=v;
	if (rc[v]) bianli(rc[v]);
}
void rebuild(int v)
{
	cnt=0;
	bianli(v);
	int f=fa[v],p=(v==rc[f]),t=build(1,cnt);
	fa[t]=f;
	if (p) rc[f]=t;else lc[f]=t;
	if (v==root) root=t;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);
	int i,x,y,K;
	for (i=1;i&lt;=n;i++)
		read(key[i]),b[i]=i,
	TTT1=n;
	root=build(1,n);
	int lastans=0;
	for (read(m);m;m--)
	{
		char ch=getchar();
		while (ch!='I'&amp;&amp;ch!='M'&amp;&amp;ch!='Q') ch=getchar();
		read(x),read(y);
		x^=lastans,y^=lastans;
		if (ch=='Q')
		{
			read(K);
			K^=lastans;
			int l=0,r=fw,res=-1;
			while (l&lt;=r)
			{
				int mid=(l+r)&gt;&gt;1;
				int t1=rank(root,y,mid),t2=rank(root,x-1,mid);
				int tmp=t1-t2;
				if (tmp+1&lt;=K) res=mid,l=mid+1;
				else r=mid-1;
			}
			printf(&quot;%d\n&quot;,lastans=res);
		}
		else if (ch=='M')
		{
			int preval=find(root,x);
			modify(root,x,preval,y);
		}
		else
		{
			need=0;
			ins(root,x-1,y,0);
			if (need) rebuild(need);
		}
	}
	return 0;
}<pre><h2>Problem3065</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef double DD;
 const DD alfa=0.8;
const int NN=70111,AA=20000111;
int b[NN],key[NN],lc[NN],rc[NN],size[NN],fa[NN],A[NN],B[NN],cur[NN];
int n,m,TTT1,TTT2,n1,n2,root,need,cnt;
struct segnode
{
	int lc,rc,sz;
	inline void clear() {lc=rc=sz=0;}
} T[AA];
struct segnode_huishouzhan
{
	int sta[5000000],top;
	inline void push(int v)
	{
		T[v].clear();
		sta[++top]=v;
	}
	inline int getnext()
	{
		if (top) return sta[top--];
		return ++TTT2;
	}
} box;
struct segment_tree
{
	int root;
	void ins(int &amp;v,int l,int r,int x,int kind)
	{
		if (!v) v=box.getnext();
		T[v].sz+=kind;
		if (r-l==1) return;
		int mid=(l+r)&gt;&gt;1;
		if (x&lt;mid) ins(T[v].lc,l,mid,x,kind);
		else ins(T[v].rc,mid,r,x,kind);
	}
	void huishou(int t)
	{
		if (!t) return;
		huishou(T[t].lc),huishou(T[t].rc);
		box.push(t);
	}
	inline void ins(int x) {ins(root,0,70001,x,1);}
	inline void del(int x) {ins(root,0,70001,x,-1);}
	inline void huishou() {huishou(root);root=0;}
} E[NN];
inline void update(int t)
{
	size[t]=size[lc[t]]+size[rc[t]]+1;
}
int build(int l,int r)
{
	int mid=(l+r)&gt;&gt;1,v=b[mid];
	for (int i=l;i&lt;=r;i++)
		E[v].ins(key[b[i]]);
	lc[v]=rc[v]=0;
	if (l&lt;mid)
	{
		lc[v]=build(l,mid-1);
		fa[lc[v]]=v;
	}
	if (mid&lt;r)
	{
		rc[v]=build(mid+1,r);
		fa[rc[v]]=v;
	}
	update(v);
	return v;
}
void getjiedian(int t,int l,int r)
{
	if (!t) return;
	if (l==1&amp;&amp;r==size[t]) {B[++n2]=t;return;}
	int tmp=size[lc[t]];
	if (r&lt;=tmp) {getjiedian(lc[t],l,r);return;}
	if (l&gt;tmp+1) {getjiedian(rc[t],l-tmp-1,r-tmp-1);return;}
	A[++n1]=t;
	getjiedian(lc[t],l,tmp);
	getjiedian(rc[t],1,r-tmp-1);
}
int getans(int L,int R,int K)
{
	n1=n2=0;
	getjiedian(root,L,R);
	int i;
	E[70001].huishou();
	for (i=1;i&lt;=n1;i++) E[70001].ins(key[A[i]]);
	B[++n2]=70001;
	for (i=1;i&lt;=n2;i++) cur[B[i]]=E[B[i]].root;
	int l=0,r=70001;
	while (r-l&gt;1)
	{
		int mid=(l+r)&gt;&gt;1,tmp=0;
		for (i=1;i&lt;=n2;i++)
			tmp+=T[T[cur[B[i]]].lc].sz;
		if (K&lt;=tmp)
		{
			r=mid;
			r=mid;
			for (i=1;i&lt;=n2;i++)
				cur[B[i]]=T[cur[B[i]]].lc;
		}
		else
		{
			K-=tmp;
			l=mid;
			for (i=1;i&lt;=n2;i++)
				cur[B[i]]=T[cur[B[i]]].rc;
		}
	}
	return l;
}
int findval(int t,int pos)
{
	int tmp=size[lc[t]];
	if (pos&lt;=tmp) return findval(lc[t],pos);
	else if (pos==tmp+1) return key[t];
	else return findval(rc[t],pos-tmp-1);
}
void modify(int t,int pos,int x,int y)
{
	E[t].del(x);
	E[t].ins(y);
	int tmp=size[lc[t]];
	if (pos&lt;=tmp) modify(lc[t],pos,x,y);
	else if (pos==tmp+1) key[t]=y;
	else modify(rc[t],pos-tmp-1,x,y);
}
inline bool balance(int v)
{
	DD tmp=size[v]*alfa;
	return size[lc[v]]&lt;=tmp&amp;&amp;size[rc[v]]&lt;=tmp;
}
void ins(int &amp;v,int pos,int x,int ff)
{
	if (!v)
	{
		v=++TTT1;
		key[v]=x;
		fa[v]=ff;
		size[v]=1;
		E[v].ins(x);
		return;
	}
	E[v].ins(x);
	int tmp=size[lc[v]];
	if (pos&lt;=tmp) ins(lc[v],pos,x,v);
	else ins(rc[v],pos-tmp-1,x,v);
	update(v);
	if (!balance(v)) need=v;
}
void bianli(int v)
{
	if (lc[v]) bianli(lc[v]);
	b[++cnt]=v;
	E[v].huishou();
	if (rc[v]) bianli(rc[v]);
}
void rebuild(int v)
{
	int ff=fa[v];
	bool p=(v==lc[ff]);
	cnt=0;
	bianli(v);
	int t=build(1,cnt);
	fa[t]=ff;
	if (p) lc[ff]=t;
	else rc[ff]=t;
	if (v==root) root=t;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y,l,r,K;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;key[i]);
		b[i]=i;
	}
	root=build(1,n);
	TTT1=n;
	int lastans=0;
	for (scanf(&quot;%d&quot;,&amp;m);m;m--)
	{
		char ch=getchar();
		while (ch!='Q'&amp;&amp;ch!='M'&amp;&amp;ch!='I') ch=getchar();
		if (ch=='Q')
		{
			scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;K);
			l^=lastans,r^=lastans,K^=lastans;
			printf(&quot;%d\n&quot;,lastans=getans(l,r,K));
		}
		else if (ch=='M')
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x^=lastans,y^=lastans;
			int preval=findval(root,x);
			modify(root,x,preval,y);
		}
		else
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x^=lastans,y^=lastans;
			need=0;
			ins(root,x-1,y,0);
			if (need) rebuild(need);
		}
	}
	return 0;
}<pre><h2>Problem3065</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef double DD;
 const DD alfa=0.8;
const int NN=70111,AA=20000111;
int b[NN],key[NN],lc[NN],rc[NN],size[NN],fa[NN],A[NN],B[NN],cur[NN];
int n,m,TTT1,TTT2,n1,n2,root,need,cnt;
struct segnode
{
	int lc,rc,sz;
	inline void clear() {lc=rc=sz=0;}
} T[AA];
struct segnode_huishouzhan
{
	int sta[5000000],top;
	inline void push(int v)
	{
		T[v].clear();
		sta[++top]=v;
	}
	inline int getnext()
	{
		if (top) return sta[top--];
		return ++TTT2;
	}
} box;
struct segment_tree
{
	int root;
	void ins(int &amp;v,int l,int r,int x,int kind)
	{
		if (!v) v=box.getnext();
		T[v].sz+=kind;
		if (r-l==1) return;
		int mid=(l+r)&gt;&gt;1;
		if (x&lt;mid) ins(T[v].lc,l,mid,x,kind);
		else ins(T[v].rc,mid,r,x,kind);
	}
	void huishou(int t)
	{
		if (!t) return;
		huishou(T[t].lc),huishou(T[t].rc);
		box.push(t);
	}
	inline void ins(int x) {ins(root,0,70001,x,1);}
	inline void del(int x) {ins(root,0,70001,x,-1);}
	inline void huishou() {huishou(root);root=0;}
} E[NN];
inline void update(int t)
{
	size[t]=size[lc[t]]+size[rc[t]]+1;
}
int build(int l,int r)
{
	int mid=(l+r)&gt;&gt;1,v=b[mid];
	for (int i=l;i&lt;=r;i++)
		E[v].ins(key[b[i]]);
	lc[v]=rc[v]=0;
	if (l&lt;mid)
	{
		lc[v]=build(l,mid-1);
		fa[lc[v]]=v;
	}
	if (mid&lt;r)
	{
		rc[v]=build(mid+1,r);
		fa[rc[v]]=v;
	}
	update(v);
	return v;
}
void getjiedian(int t,int l,int r)
{
	if (!t) return;
	if (l==1&amp;&amp;r==size[t]) {B[++n2]=t;return;}
	int tmp=size[lc[t]];
	if (r&lt;=tmp) {getjiedian(lc[t],l,r);return;}
	if (l&gt;tmp+1) {getjiedian(rc[t],l-tmp-1,r-tmp-1);return;}
	A[++n1]=t;
	getjiedian(lc[t],l,tmp);
	getjiedian(rc[t],1,r-tmp-1);
}
int getans(int L,int R,int K)
{
	n1=n2=0;
	getjiedian(root,L,R);
	int i;
	E[70001].huishou();
	for (i=1;i&lt;=n1;i++) E[70001].ins(key[A[i]]);
	B[++n2]=70001;
	for (i=1;i&lt;=n2;i++) cur[B[i]]=E[B[i]].root;
	int l=0,r=70001;
	while (r-l&gt;1)
	{
		int mid=(l+r)&gt;&gt;1,tmp=0;
		for (i=1;i&lt;=n2;i++)
			tmp+=T[T[cur[B[i]]].lc].sz;
		if (K&lt;=tmp)
		{
			r=mid;
			r=mid;
			for (i=1;i&lt;=n2;i++)
				cur[B[i]]=T[cur[B[i]]].lc;
		}
		else
		{
			K-=tmp;
			l=mid;
			for (i=1;i&lt;=n2;i++)
				cur[B[i]]=T[cur[B[i]]].rc;
		}
	}
	return l;
}
int findval(int t,int pos)
{
	int tmp=size[lc[t]];
	if (pos&lt;=tmp) return findval(lc[t],pos);
	else if (pos==tmp+1) return key[t];
	else return findval(rc[t],pos-tmp-1);
}
void modify(int t,int pos,int x,int y)
{
	E[t].del(x);
	E[t].ins(y);
	int tmp=size[lc[t]];
	if (pos&lt;=tmp) modify(lc[t],pos,x,y);
	else if (pos==tmp+1) key[t]=y;
	else modify(rc[t],pos-tmp-1,x,y);
}
inline bool balance(int v)
{
	DD tmp=size[v]*alfa;
	return size[lc[v]]&lt;=tmp&amp;&amp;size[rc[v]]&lt;=tmp;
}
void ins(int &amp;v,int pos,int x,int ff)
{
	if (!v)
	{
		v=++TTT1;
		key[v]=x;
		fa[v]=ff;
		size[v]=1;
		E[v].ins(x);
		return;
	}
	E[v].ins(x);
	int tmp=size[lc[v]];
	if (pos&lt;=tmp) ins(lc[v],pos,x,v);
	else ins(rc[v],pos-tmp-1,x,v);
	update(v);
	if (!balance(v)) need=v;
}
void bianli(int v)
{
	if (lc[v]) bianli(lc[v]);
	b[++cnt]=v;
	E[v].huishou();
	if (rc[v]) bianli(rc[v]);
}
void rebuild(int v)
{
	int ff=fa[v];
	bool p=(v==lc[ff]);
	cnt=0;
	bianli(v);
	int t=build(1,cnt);
	fa[t]=ff;
	if (p) lc[ff]=t;
	else rc[ff]=t;
	if (v==root) root=t;
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y,l,r,K;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;key[i]);
		b[i]=i;
	}
	root=build(1,n);
	TTT1=n;
	int lastans=0;
	for (scanf(&quot;%d&quot;,&amp;m);m;m--)
	{
		char ch=getchar();
		while (ch!='Q'&amp;&amp;ch!='M'&amp;&amp;ch!='I') ch=getchar();
		if (ch=='Q')
		{
			scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;K);
			l^=lastans,r^=lastans,K^=lastans;
			printf(&quot;%d\n&quot;,lastans=getans(l,r,K));
		}
		else if (ch=='M')
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x^=lastans,y^=lastans;
			int preval=findval(root,x);
			modify(root,x,preval,y);
		}
		else
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x^=lastans,y^=lastans;
			need=0;
			ins(root,x-1,y,0);
			if (need) rebuild(need);
		}
	}
	return 0;
}<pre><h2>Problem3083</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 1999999999
#define lc (v&lt;&lt;1)
#define rc (v&lt;&lt;1|1)
const int NN=101111;
int o[NN],aa[NN&lt;&lt;1][2],size[NN],dep[NN],fa[NN],hea[NN],up[NN],st[NN],ed[NN];
int pos[NN],dy[NN],w[NN],tmin[NN*4],tag[NN*4],f[19][NN];
int n,m,tot=1,cnt,ww,ee,nowrt;
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs1(int v)
{
	size[v]=1;
	int tmp=0,mm=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dep[y]=dep[v]+1;
		dfs1(y);
		size[v]+=size[y];
		if (size[y]&gt;mm) mm=size[y],tmp=y;
	}
	hea[v]=tmp;
}
void dfs2(int v)
{
	st[v]=cnt+1;
	pos[v]=++cnt;
	dy[cnt]=v;
	if (hea[v])
	{
		up[hea[v]]=up[v];
		dfs2(hea[v]);
	}
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==hea[v]||y==fa[v]) continue;
		up[y]=y;
		dfs2(y);
	}
	ed[v]=cnt;
}
int getlca(int x,int y)
{
	if (dep[x]&lt;dep[y]) {int t=x;x=y;y=t;}
	for (int i=18;i&gt;=0;i--)
		if (dep[f[i][x]]&gt;=dep[y]) x=f[i][x];
	if (x==y) return x;
	for (int i=18;i&gt;=0;i--)
		if (f[i][x]!=f[i][y]) x=f[i][x],y=f[i][y];
	return f[0][x];
}
inline void make(int v,int x)
{
	tag[v]=x;
	tmin[v]=x;
}
inline void pushdown(int v)
{
	if (tag[v]==-inf) return;
	make(lc,tag[v]),make(rc,tag[v]);
	tag[v]=-inf;
}
inline void update(int v)
{
	tmin[v]=min(tmin[lc],tmin[rc]);
}
void build(int v,int l,int r)
{
	tag[v]=-inf;
	if (r-l==1)
	{
		tmin[v]=w[dy[l]];
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(lc,l,mid);
	build(rc,mid,r);
	update(v);
}
void change(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		make(v,x);
		return;
	}
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) change(lc,l,mid,x);
	if (ee&gt;mid) change(rc,mid,r,x);
	update(v);
}
int find(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tmin[v];
	pushdown(v);
	int mid=(l+r)&gt;&gt;1,res=inf;
	if (ww&lt;mid) res=find(lc,l,mid);
	if (ee&gt;mid) res=min(res,find(rc,mid,r));
	return res;
}
int main()
{
	//、、freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	dep[1]=1,dfs1(1);
	up[1]=1,dfs2(1);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;w[i]);
	build(1,1,n+1);
	for (i=1;i&lt;=n;i++) f[0][i]=fa[i];
	for (j=1;j&lt;=18;j++)
		for (i=1;i&lt;=n;i++) f[j][i]=f[j-1][f[j-1][i]];
	scanf(&quot;%d&quot;,&amp;nowrt);
	for (;m;m--)
	{
		//printf(&quot;\n--------------------------------------------------------------------\n&quot;);
		scanf(&quot;%d&quot;,&amp;x);
		if (x==1) scanf(&quot;%d&quot;,&amp;nowrt);
		else if (x==2)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			while (up[x]!=up[y])
			{
				if (dep[up[x]]&lt;dep[up[y]]) {int t=x;x=y;y=t;}
				ww=pos[up[x]],ee=pos[x]+1;
				change(1,1,n+1,z);
				x=fa[up[x]];
			}
			if (dep[x]&lt;dep[y]) {int t=x;x=y;y=t;}
			ww=pos[y],ee=pos[x]+1;
			if (ww&lt;ee) change(1,1,n+1,z);
		}
		else
		{
			scanf(&quot;%d&quot;,&amp;x);
			if (x==nowrt) {printf(&quot;%d\n&quot;,tmin[1]);continue;}
			int lca=getlca(x,nowrt);
			if (lca==nowrt||(lca!=nowrt&amp;&amp;lca!=x))
			{
				ww=st[x],ee=ed[x]+1;
				printf(&quot;%d\n&quot;,find(1,1,n+1));
			}
			else
			{
				y=nowrt;
				for (i=18;i&gt;=0;i--)
					if (dep[f[i][y]]&gt;dep[x]) y=f[i][y];
				int res=inf;
				ww=1,ee=st[y];
				if (ww&lt;ee) res=find(1,1,n+1);
				ww=ed[y]+1,ee=n+1;
				if (ww&lt;ee) res=min(res,find(1,1,n+1));
				printf(&quot;%d\n&quot;,res);
			}
		}
	}
	return 0;
}<pre><h2>Problem3091</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
const int NN=50005;
int fa[NN],son[NN][2],o[NN],aa[NN*2][2],size[NN];
int n,m,tot;
LL sum[NN],lt[NN],rt[NN],tag[NN],key[NN],ss[NN];
bool rrr[NN],tag0[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	while (ch&lt;'0'||ch&gt;'9')
		{if (ch=='-') f=true;ch=getchar();}
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
	if (f) x=-x;
}
inline void read(LL &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	while (ch&lt;'0'||ch&gt;'9')
		{if (ch=='-') f=true;ch=getchar();}
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
	if (f) x=-x;
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void bfs()
{
	static int que[NN];
	int head=0,tail=1;
	que[1]=1;
	while (head&lt;tail)
	{
		int x=que[++head];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[x]) continue;
			fa[y]=x;
			que[++tail]=y;
		}
	}
}
inline void rev(int t)
{
	tag0[t]=!tag0[t];
	swap(son[t][0],son[t][1]);
	swap(lt[t],rt[t]);
}
inline void add(int t,LL x)
{
	tag[t]+=x;key[t]+=x;
	int n=size[t];
	sum[t]+=x*n*(n+1)*(n+2)/6;
	lt[t]+=x*n*(n+1)/2;
	rt[t]+=x*n*(n+1)/2;
	ss[t]+=x*n;
}
inline void pushdown(int t)
{
	int x=son[t][0],y=son[t][1];
	if (tag0[t])
	{
		rev(x),rev(y);
		tag0[t]=false;
	}
	if (tag[t])
	{
		add(x,tag[t]),add(y,tag[t]);
		tag[t]=0;
	}
}
inline void update(int t)
{
	int x=son[t][0],y=son[t][1];
	size[t]=size[x]+size[y]+1;
	sum[t]=sum[x]+lt[x]*(size[y]+1)+sum[y]+rt[y]*(size[x]+1)+key[t]*(size[x]+1)*(size[y]+1);
	lt[t]=lt[x]+key[t]*(size[x]+1)+lt[y]+ss[y]*(size[x]+1);
	rt[t]=rt[y]+key[t]*(size[y]+1)+rt[x]+ss[x]*(size[y]+1);
	ss[t]=ss[x]+ss[y]+key[t];
}
inline void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
	else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
}
void access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
}
void makeroot(int x)
{
	access(x);
	splay(x);
	rev(x);
}
int getroot(int x)
{
	access(x);
	splay(x);
	while (son[x][0])
	{
		pushdown(x);
		x=son[x][0];
	}
	return x;
}
void link(int x,int y)
{
	if (getroot(x)==getroot(y)) return;
	makeroot(x);
	splay(x);
	fa[x]=y;
}
void cut(int x,int y)
{
	makeroot(x);
	access(y),splay(y);
	if (size[y]!=2||fa[x]!=y||son[y][0]!=x) return;
	rrr[x]=true;
	fa[x]=son[y][0]=0;
}
LL gcd(LL a,LL b) {return !b?a:gcd(b,a%b);}
void debug(int t)
{
	if (t==0) return;
	pushdown(t);
	debug(son[t][0]);
	printf(&quot;%d &quot;,t);
	debug(son[t][1]);
	//update(t);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);read(m);
	int i,x,y,z,kind;
	for (i=1;i&lt;=n;i++) read(key[i]);
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y);
		addedge(x,y),addedge(y,x);
	}
	bfs();
	for (i=1;i&lt;=n;i++)
	{
		rrr[i]=true;
		sum[i]=lt[i]=rt[i]=ss[i]=key[i];
	}
	for (;m;m--)
	{
		//printf(&quot;\n-------------------------------------------------------------------------\n&quot;);
		read(kind);read(x),read(y);
		if (kind==1) cut(x,y);
		else if (kind==2) link(x,y);
		else if (kind==3)
		{
			read(z);
			if (getroot(x)!=getroot(y)) continue;
			makeroot(x);
			access(y),splay(y);
			add(y,z);
		}
		else
		{
			if (getroot(x)!=getroot(y)) {printf(&quot;-1\n&quot;);continue;}
			makeroot(x);
			access(y),splay(y);
			//debug(y);ln;
			LL fz=sum[y],fm=size[y]*(size[y]+1)/2;
			LL t=gcd(fz,fm);
			printf(&quot;%lld/%lld\n&quot;,fz/t,fm/t);
		}
	}
	return 0;
}<pre><h2>Problem3093</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int n,p,q,tc;
int main()
{
	while (scanf(&quot;%d%d%d&quot;,&amp;n,&amp;p,&amp;q)!=EOF) printf(&quot;Case %d: %.4f\n&quot;,++tc,(double)(q+1)/(p+2));
}<pre><h2>Problem3093</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int n,p,q,tc;
int main()
{
	while (scanf(&quot;%d%d%d&quot;,&amp;n,&amp;p,&amp;q)!=EOF) printf(&quot;Case %d: %.4f\n&quot;,++tc,(double)(q+1)/(p+2));
	return 0;
}<pre><h2>Problem3093</h2><pre>#include&lt;cstdio&gt;
using namespace std;

int main()
{
	int t=0,n,p,q;
	while (scanf(&quot;%d%d%d&quot;,&amp;n,&amp;p,&amp;q)!=EOF)
		printf(&quot;Case %d: %.4f\n&quot;,++t,1.0*(q+1)/(p+2));
	return 0;
}<pre><h2>Problem3110</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N = 1E5+10;
typedef long long ll;
struct Data{
	int i,t,a,b,c;
}ask[N*2],tmp[N];
int n,m,data[N],list[N*2],ans[N];
namespace tr{
	ll tree[2][N];
	void push(int t,int x,int val){for(;x&lt;=n+1;x+=x&amp;-x)tree[t][x] += val;}
	ll get(int t,int x){ll re=0;for(;x;x-=x&amp;-x)re += tree[t][x];return re;}
	int query(int l,int r){
		ll tmp=0;
		tmp = (get(0,r) - get(0,l-1))*(r+1) - (get(1,r)-get(1,l-1)) + get(0,l-1)*(r-l+1);
		return tmp;
	}
	void add(int l,int r,int val){
		push(0,l,val);
		push(0,r+1,-val);
		push(1,l,l*val);
		push(1,r+1,(r+1)*-val);
	}
}
short v[N],va[N];
bool Select(Data &amp;a){return !v[a.i];}
void solve(int la,int ra,int ld,int rd){
	using namespace tr;
	int mid = (ld+rd)/2,mida,i;
	if(ld==rd){
		for(i=la;i&lt;=ra;i++)
		if(ask[i].t==2) ans[ask[i].i] = list[ld];
		return;
	}
	for(i=la;i&lt;=ra;i++){
		if(ask[i].t==1){
			if(ask[i].c &gt; mid)add(ask[i].a,ask[i].b,1),v[ask[i].i]=1;
			else v[ask[i].i]=0;
		}else{
			int tmp=0;
			tmp = query(ask[i].a,ask[i].b);
			if(ask[i].c &lt;= tmp)v[ask[i].i]=1;
			else v[ask[i].i]=0,ask[i].c -= tmp;
		}
	}
	for(i=la;i&lt;=ra;i++)
	if(ask[i].t==1 &amp;&amp; ask[i].c &gt; mid)add(ask[i].a,ask[i].b,-1);
	mida = std::stable_partition(ask+la,ask+1+ra,Select)-ask-1;
	solve(la,mida,ld,mid);
	solve(mida+1,ra,mid+1,rd);
}
int main(){
	int i,j,a,b,c;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(i=1;i&lt;=m;i++){
		scanf(&quot;%d%d%d%d&quot;,&amp;j,&amp;a,&amp;b,&amp;c);
		ask[i] = (Data){i,j,a,b,c};
		if(ask[i].t==1)list[++list[0]] = c;
		else va[i]=1;
	}
	sort(list+1,list+1+list[0]);
	list[0] = unique(list+1,list+1+list[0]) - list - 1;
	for(i=1;i&lt;=m;i++)
	if(ask[i].t == 1)
		ask[i].c = lower_bound(list+1,list+1+list[0],ask[i].c)-list;
	solve(1,m,1,list[0]);
	for(i=1;i&lt;=m;i++)if(va[i])printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem3110</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N = 1E5+10;
typedef int ll;
struct Data{
	int i,t,a,b,c;
}ask[N*2],tmp[N];
int n,m,data[N],list[N*2],ans[N];
namespace tr{
	ll tree[2][N];
	void push(int t,int x,int val){for(;x&lt;=n+1;x+=x&amp;-x)tree[t][x] += val;}
	ll get(int t,int x){ll re=0;for(;x;x-=x&amp;-x)re += tree[t][x];return re;}
	int query(int l,int r){
		ll tmp=0;
		tmp = (get(0,r) - get(0,l-1))*(r+1) - (get(1,r)-get(1,l-1)) + get(0,l-1)*(r-l+1);
		return tmp;
	}
	void add(int l,int r,int val){
		push(0,l,val);
		push(0,r+1,-val);
		push(1,l,l*val);
		push(1,r+1,(r+1)*-val);
	}
}
short v[N],va[N];
bool Select(Data &amp;a){return !v[a.i];}
void solve(int la,int ra,int ld,int rd){
	using namespace tr;
	int mid = (ld+rd)/2,mida,i;
	if(ld==rd){
		for(i=la;i&lt;=ra;i++)
		if(ask[i].t==2) ans[ask[i].i] = list[ld];
		return;
	}
	for(i=la;i&lt;=ra;i++){
		if(ask[i].t==1){
			if(ask[i].c &gt; mid)add(ask[i].a,ask[i].b,1),v[ask[i].i]=1;
			else v[ask[i].i]=0;
		}else{
			int tmp=0;
			tmp = query(ask[i].a,ask[i].b);
			if(ask[i].c &lt;= tmp)v[ask[i].i]=1;
			else v[ask[i].i]=0,ask[i].c -= tmp;
		}
	}
	for(i=la;i&lt;=ra;i++)
	if(ask[i].t==1 &amp;&amp; ask[i].c &gt; mid)add(ask[i].a,ask[i].b,-1);
	mida = std::stable_partition(ask+la,ask+1+ra,Select)-ask-1;
	solve(la,mida,ld,mid);
	solve(mida+1,ra,mid+1,rd);
}
int main(){
	int i,j,a,b,c;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(i=1;i&lt;=m;i++){
		scanf(&quot;%d%d%d%d&quot;,&amp;j,&amp;a,&amp;b,&amp;c);
		ask[i] = (Data){i,j,a,b,c};
		if(ask[i].t==1)list[++list[0]] = c;
		else va[i]=1;
	}
	sort(list+1,list+1+list[0]);
	list[0] = unique(list+1,list+1+list[0]) - list - 1;
	for(i=1;i&lt;=m;i++)
	if(ask[i].t == 1)
		ask[i].c = lower_bound(list+1,list+1+list[0],ask[i].c)-list;
	solve(1,m,1,list[0]);
	for(i=1;i&lt;=m;i++)if(va[i])printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem3110</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define lc(v) (v&lt;&lt;1)
#define rc(v) ((v&lt;&lt;1)+1)
#define NN 51111
int tag[NN*4],tsum[NN*4],ans[NN],id[NN],id1[NN],id2[NN],kind[NN],a[NN],b[NN],C[NN],d[NN],have[NN],li[NN];
int n,m,ww,ee,num;
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);printf(&quot;\n&quot;);}
void pushdown(int v,int l,int r,int mid)
{
	if (tag[v]==0) return;
	int x=lc(v),y=rc(v);
	tag[x]+=tag[v],tsum[x]+=tag[v]*(mid-l);
	tag[y]+=tag[v],tsum[y]+=tag[v]*(r-mid);
	tag[v]=0;
}
void update(int v)
{
	tsum[v]=tsum[lc(v)]+tsum[rc(v)];
}
void change(int v,int l,int r,bool kind)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		if (kind) tag[v]++,tsum[v]+=r-l;
		else tag[v]--,tsum[v]-=r-l;
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	pushdown(v,l,r,mid);
	if (ww&lt;mid) change(lc(v),l,mid,kind);
	if (ee&gt;mid) change(rc(v),mid,r,kind);
	update(v);
}
int find(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tsum[v];
	int mid=(l+r)&gt;&gt;1,res=0;
	pushdown(v,l,r,mid);
	if (ww&lt;mid) res+=find(lc(v),l,mid);
	if (ee&gt;mid) res+=find(rc(v),mid,r);
	return res;
}
void solve(int head,int tail,int l,int r)
{
	//memset(id1,0,sizeof(id1));memset(id2,0,sizeof(id2));//删掉！
	if (head&gt;tail) return;
	//printf(&quot;\n\n-------- head=%d tail=%d l=%d r=%d mid=%d----------------\n&quot;,head,tail,l,r,(l+r)/2);
	if (l==r)
	{
		for (int i=head;i&lt;=tail;i++) ans[id[i]]=l;
		return;
	}
	int mid=(l+r)&gt;&gt;1,i,j,k,t;
	for (i=head;i&lt;=tail;i++)
	{
		t=id[i];
		ww=a[t],ee=b[t]+1;
		if (kind[t]==1&amp;&amp;C[t]&gt;mid) change(1,1,n+1,true);
		else d[t]=find(1,1,n+1);
	}
	//printf(&quot;d &quot;);out(d,1,m);
	for (i=head;i&lt;=tail;i++)
	{
		t=id[i];
		ww=a[t],ee=b[t]+1;
		if (kind[t]==1&amp;&amp;C[t]&gt;mid) change(1,1,n+1,false);
	}
	for (i=j=0,k=head;k&lt;=tail;k++)
	{
		t=id[k];
		if (kind[t]==1)
			if (C[t]&lt;=mid) id1[++i]=t;
			else id2[++j]=t;
		else if (have[t]+d[t]&gt;=C[t]) id2[++j]=t;
		else have[t]+=d[t],id1[++i]=t;
	}
	//printf(&quot;have &quot;);out(have,1,m);
	//printf(&quot;id1 &quot;);out(id1,1,m);printf(&quot;id2 &quot;);out(id2,1,m);
	t=head;
	for (k=1;k&lt;=i;k++) id[t++]=id1[k];
	for (k=1;k&lt;=j;k++) id[t++]=id2[k];
	solve(head,head+i-1,l,mid);
	solve(head+i,tail,mid+1,r);
}
int cha(int x)
{
	int l=1,r=num;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (li[mid]==x) return mid;
		if (li[mid]&gt;x) r=mid-1;
		else l=mid+1;
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;kind[i],&amp;a[i],&amp;b[i],&amp;C[i]);
		id[i]=i;
		if (kind[i]==1) li[++li[0]]=C[i];
	}
	sort(li+1,li+li[0]+1);
	for (num=1,i=2;i&lt;=li[0];i++)
		if (li[i]!=li[num]) li[++num]=li[i];
	for (i=1;i&lt;=m;i++)
		if (kind[i]==1) C[i]=cha(C[i]);
	//for (i=1;i&lt;=m;i++) printf(&quot;%d: kind=%d a=%d b=%d C=%d\n&quot;,i,kind[i],a[i],b[i],C[i]);
	solve(1,m,1,num);
	for (i=1;i&lt;=m;i++)
		if (kind[i]==2) printf(&quot;%d\n&quot;,li[ans[i]]);
	return 0;
}
<pre><h2>Problem3110</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
#define ls (v&lt;&lt;1)
#define rs (v&lt;&lt;1|1)
const int NN=50111;
int id[NN],id1[NN],id2[NN],ans[NN],tsum[NN&lt;&lt;2],tag[NN&lt;&lt;2],temp[NN],b[NN];
int n,m,ww,ee;
struct info
{
	int kind,l,r,k;
	inline void out() {printf(&quot;kind=%d l=%d r=%d k=%d\n&quot;,kind,l,r,k);}
} q[NN];
inline void add(int v,int l,int r,int x)
{
	tag[v]+=x;
	tsum[v]+=x*(r-l);
}
inline void pushdown(int v,int l,int r,int mid)
{
	if (tag[v])
	{
		add(ls,l,mid,tag[v]);
		add(rs,mid,r,tag[v]);
		tag[v]=0;
	}
}
inline void update(int v)
{
	tsum[v]=tsum[ls]+tsum[rs];
}
void change(int v,int l,int r,int kind)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		add(v,l,r,kind);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	pushdown(v,l,r,mid);
	if (ww&lt;mid) change(ls,l,mid,kind);
	if (ee&gt;mid) change(rs,mid,r,kind);
	update(v);
}
int find(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tsum[v];
	int mid=(l+r)&gt;&gt;1,res=0;
	pushdown(v,l,r,mid);
	if (ww&lt;mid) res+=find(ls,l,mid);
	if (ee&gt;mid) res+=find(rs,mid,r);
	return res;
}
void work(int head,int tail,int l,int r)
{
	if (head&gt;tail) return;
	bool flag=false;
	for (int i=head;i&lt;=tail;i++)
		if (q[id[i]].kind==2) flag=true;
	if (!flag) return;
	//printf(&quot;\n----------------- work %d %d %d %d --------------------------------\n&quot;,head,tail,l,r);
	//printf(&quot;id &quot;);for(int i=head;i&lt;=tail;i++)printf(&quot;%d &quot;,id[i]);ln;
	if (l==r)
	{
		for (int i=head;i&lt;=tail;i++) ans[id[i]]=l;
		return;
	}
	int mid=(l+r)&gt;&gt;1,i;
	for (i=head;i&lt;=tail;i++)
	{
		int t=id[i];
		ww=q[t].l,ee=q[t].r+1;
		if (q[t].kind==1&amp;&amp;q[t].k&gt;mid) change(1,1,n+1,1);
		else if (q[t].kind==2) temp[t]=find(1,1,n+1);
	}
	for (i=head;i&lt;=tail;i++)
		if (q[id[i]].kind==1&amp;&amp;q[id[i]].k&gt;mid)
		{
			ww=q[id[i]].l,ee=q[id[i]].r+1;
			change(1,1,n+1,-1);
		}
	int n1=0,n2=0;
	for (i=head;i&lt;=tail;i++)
	{
		int t=id[i];
		if (q[t].kind==1)
		{
			if (q[t].k&lt;=mid) id1[++n1]=t;
			else id2[++n2]=t;
		}
		else if (q[t].kind==2)
		{
			if (q[t].k&lt;=temp[t]) id2[++n2]=t;
			else q[t].k-=temp[t],id1[++n1]=t;
		}
	}
	int t=head;
	for (i=1;i&lt;=n1;i++) id[t++]=id1[i];
	for (i=1;i&lt;=n2;i++) id[t++]=id2[i];
	work(head,head+n1-1,l,mid);
	work(head+n1,tail,mid+1,r);
}
inline int cha(int x)
{
	int l=1,r=b[0];
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (b[mid]==x) return mid;
		if (x&lt;b[mid]) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;q[i].kind,&amp;q[i].l,&amp;q[i].r,&amp;q[i].k);
		if (q[i].kind==1) b[++b[0]]=q[i].k;
	}
	sort(b+1,b+b[0]+1);
	for (i=1;i&lt;=m;i++)
		if (q[i].kind==1) q[i].k=cha(q[i].k);
	//for (i=1;i&lt;=m;i++) q[i].out();
	for (i=1;i&lt;=m;i++) id[i]=i;
	work(1,m,1,b[0]);
	for (i=1;i&lt;=m;i++)
		if (q[i].kind==2) printf(&quot;%d\n&quot;,b[ans[i]]);
	return 0;
}<pre><h2>Problem3110</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ls (v&lt;&lt;1)
#define rs (v&lt;&lt;1|1)
const int NN=50111;
int id[NN],id1[NN],id2[NN],ans[NN],tsum[NN&lt;&lt;2],tag[NN&lt;&lt;2],temp[NN],b[NN];
int n,m,ww,ee;
struct info
{
	int kind,l,r,k;
} q[NN];
inline void add(int v,int l,int r,int x)
{
	tag[v]+=x;
	tsum[v]+=x*(r-l);
}
inline void pushdown(int v,int l,int r,int mid)
{
	if (tag[v])
	{
		add(ls,l,mid,tag[v]);
		add(rs,mid,r,tag[v]);
		tag[v]=0;
	}
}
inline void update(int v)
{
	tsum[v]=tsum[ls]+tsum[rs];
}
void change(int v,int l,int r,int kind)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		add(v,l,r,kind);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	pushdown(v,l,r,mid);
	if (ww&lt;mid) change(ls,l,mid,kind);
	if (ee&gt;mid) change(rs,mid,r,kind);
	update(v);
}
int find(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tsum[v];
	int mid=(l+r)&gt;&gt;1,res=0;
	pushdown(v,l,r,mid);
	if (ww&lt;mid) res+=find(ls,l,mid);
	if (ee&gt;mid) res+=find(rs,mid,r);
	return res;
}
void work(int head,int tail,int l,int r)
{
	if (head&gt;tail) return;
	bool flag=false;
	for (int i=head;i&lt;=tail;i++)
		if (q[id[i]].kind==2) flag=true;
	if (!flag) return;
	if (l==r)
	{
		for (int i=head;i&lt;=tail;i++) ans[id[i]]=l;
		return;
	}
	int mid=(l+r)&gt;&gt;1,i;
	for (i=head;i&lt;=tail;i++)
	{
		int t=id[i];
		ww=q[t].l,ee=q[t].r+1;
		if (q[t].kind==1&amp;&amp;q[t].k&gt;mid) change(1,1,n+1,1);
		else if (q[t].kind==2) temp[t]=find(1,1,n+1);
	}
	for (i=head;i&lt;=tail;i++)
		if (q[id[i]].kind==1&amp;&amp;q[id[i]].k&gt;mid)
		{
			ww=q[id[i]].l,ee=q[id[i]].r+1;
			change(1,1,n+1,-1);
		}
	int n1=0,n2=0;
	for (i=head;i&lt;=tail;i++)
	{
		int t=id[i];
		if (q[t].kind==1)
		{
			if (q[t].k&lt;=mid) id1[++n1]=t;
			else id2[++n2]=t;
		}
		else if (q[t].kind==2)
		{
			if (q[t].k&lt;=temp[t]) id2[++n2]=t;
			else q[t].k-=temp[t],id1[++n1]=t;
		}
	}
	int t=head;
	for (i=1;i&lt;=n1;i++) id[t++]=id1[i];
	for (i=1;i&lt;=n2;i++) id[t++]=id2[i];
	work(head,head+n1-1,l,mid);
	work(head+n1,tail,mid+1,r);
}
inline int cha(int x)
{
	int l=1,r=b[0];
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (b[mid]==x) return mid;
		if (x&lt;b[mid]) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;q[i].kind,&amp;q[i].l,&amp;q[i].r,&amp;q[i].k);
		if (q[i].kind==1) b[++b[0]]=q[i].k;
	}
	sort(b+1,b+b[0]+1);
	for (i=1;i&lt;=m;i++)
		if (q[i].kind==1) q[i].k=cha(q[i].k);
	for (i=1;i&lt;=m;i++) id[i]=i;
	work(1,m,1,b[0]);
	for (i=1;i&lt;=m;i++)
		if (q[i].kind==2) printf(&quot;%d\n&quot;,b[ans[i]]);
	return 0;
}<pre><h2>Problem3110</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ls (v&lt;&lt;1)
#define rs (v&lt;&lt;1|1)
const int NN=50111;
int id[NN],id1[NN],id2[NN],ans[NN],tsum[NN&lt;&lt;2],tag[NN&lt;&lt;2],temp[NN];
int n,m,ww,ee;
struct info
{
	int kind,l,r,k;
} q[NN];
inline void add(int v,int l,int r,int x)
{
	tag[v]+=x;
	tsum[v]+=x*(r-l);
}
inline void pushdown(int v,int l,int r,int mid)
{
	if (tag[v])
	{
		add(ls,l,mid,tag[v]);
		add(rs,mid,r,tag[v]);
		tag[v]=0;
	}
}
inline void update(int v)
{
	tsum[v]=tsum[ls]+tsum[rs];
}
void change(int v,int l,int r,int kind)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		add(v,l,r,kind);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	pushdown(v,l,r,mid);
	if (ww&lt;mid) change(ls,l,mid,kind);
	if (ee&gt;mid) change(rs,mid,r,kind);
	update(v);
}
int find(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tsum[v];
	int mid=(l+r)&gt;&gt;1,res=0;
	pushdown(v,l,r,mid);
	if (ww&lt;mid) res+=find(ls,l,mid);
	if (ee&gt;mid) res+=find(rs,mid,r);
	return res;
}
void work(int head,int tail,int l,int r)
{
	if (head&gt;tail) return;
	bool flag=false;
	for (int i=head;i&lt;=tail;i++)
		if (q[id[i]].kind==2) flag=true;
	if (!flag) return;
	if (l==r)
	{
		for (int i=head;i&lt;=tail;i++) ans[id[i]]=l;
		return;
	}
	int mid=(l+r)&gt;&gt;1,i;
	for (i=head;i&lt;=tail;i++)
	{
		int t=id[i];
		ww=q[t].l,ee=q[t].r+1;
		if (q[t].kind==1&amp;&amp;q[t].k&gt;mid) change(1,1,n+1,1);
		else if (q[t].kind==2) temp[t]=find(1,1,n+1);
	}
	for (i=head;i&lt;=tail;i++)
		if (q[id[i]].kind==1&amp;&amp;q[id[i]].k&gt;mid)
		{
			ww=q[id[i]].l,ee=q[id[i]].r+1;
			change(1,1,n+1,-1);
		}
	int n1=0,n2=0;
	for (i=head;i&lt;=tail;i++)
	{
		int t=id[i];
		if (q[t].kind==1)
		{
			if (q[t].k&lt;=mid) id1[++n1]=t;
			else id2[++n2]=t;
		}
		else if (q[t].kind==2)
		{
			if (q[t].k&lt;=temp[t]) id2[++n2]=t;
			else q[t].k-=temp[t],id1[++n1]=t;
		}
	}
	int t=head;
	for (i=1;i&lt;=n1;i++) id[t++]=id1[i];
	for (i=1;i&lt;=n2;i++) id[t++]=id2[i];
	work(head,head+n1-1,l,mid);
	work(head+n1,tail,mid+1,r);
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i;
	for (i=1;i&lt;=m;i++)
		scanf(&quot;%d%d%d%d&quot;,&amp;q[i].kind,&amp;q[i].l,&amp;q[i].r,&amp;q[i].k);
	for (i=1;i&lt;=m;i++) id[i]=i;
	work(1,m,-n,n);
	for (i=1;i&lt;=m;i++)
		if (q[i].kind==2) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem3112</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;iostream&gt;

#define eps 1e-8
#define INF 1e18
#define maxn 1010
#define maxm 10010

using namespace std;

int n,m;

namespace Lp{
	double A[maxn][maxm],c[maxm],b[maxn],v;
	void pivot(int l,int e){
		b[l]/=A[l][e];
		for(int i=1;i&lt;=n;i++) if(i!=e) A[l][i]/=A[l][e];
		A[l][e]=1.0/A[l][e];
		for(int i=1;i&lt;=m;i++){
			if(i!=l&amp;&amp;fabs(A[i][e])&gt;eps){
				b[i]-=b[l]*A[i][e];
				for(int j=1;j&lt;=n;j++){
					if(j!=e) A[i][j]-=A[l][j]*A[i][e];
				}
				A[i][e]=-A[i][e]*A[l][e];
			}
		}
		v+=c[e]*b[l];
		for(int i=1;i&lt;=n;i++) if(i!=e) c[i]-=A[l][i]*c[e];
		c[e]=-c[e]*A[l][e];
	}
	double Simplex(){
		int i,l,e;
		while(1){	
			for(i=1;i&lt;=n;i++) if(c[i]&gt;eps) break;
			if((e=i)==n+1) return v;
			double tmp=INF;
			for(int i=1;i&lt;=m;i++)
				if(A[i][e]&gt;eps&amp;&amp;b[i]/A[i][e]&lt;tmp)
					l=i,tmp=b[i]/A[i][e];
			if(tmp==INF) return INF;
			pivot(l,e);
		}
	}
}

int main()
{
	using namespace Lp;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++) scanf(&quot;%lf&quot;,&amp;b[i]);
	for(int i=1;i&lt;=m;i++){
		int l,r,x;
		scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;x);
		for(int j=l;j&lt;=r;j++) A[j][i]=1;
		c[i]=x;
	}
	swap(n,m);
	double ans=Simplex();
	printf(&quot;%d\n&quot;,(int)(ans+0.5));
	return 0;
}
<pre><h2>Problem3120</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define mo 1000000007
#define mp make_pair
#define fi first
#define se second
#define ln printf(&quot;\n&quot;)
int n,Q,P,cnt;
LL m,C[9][9];
struct matrix
{
	int qq[201][201];
	matrix() {memset(qq,0,sizeof(qq));}
	int * operator [](int x) {return qq[x];}
	friend matrix operator *(matrix a,matrix b)
	{
		matrix c;
		for (int k=1;k&lt;=cnt;k++)
			for (int i=1;i&lt;=cnt;i++) if (a[i][k])
				for (int j=1;j&lt;=cnt;j++) if (b[k][j])
				{
					c[i][j]+=(LL)a[i][k]*b[k][j]%mo;
					if (c[i][j]&gt;=mo) c[i][j]-=mo;
				}
		return c;
	}
	friend matrix operator ^(matrix a,LL b)
	{
		matrix res;
		for (int i=1;i&lt;=cnt;i++) res[i][i]=1;
		for (;b;b&gt;&gt;=1,a=a*a)
			if (b&amp;1) res=res*a;
		return res;
	}
} a,ans;
LL work1()
{
	int i,j;
	static int hao[10][5];
	memset(hao,-1,sizeof(hao));
	for (i=0;i&lt;=n;i++)
		for (j=0;j&lt;=Q;j++) hao[i][j]=++cnt;
	for (i=0;i&lt;=n;i++) 
		for (j=0;j&lt;=Q;j++)
		{
			int t=hao[i][j];
			for (int l=0;l&lt;=i;l++)
			{
				LL tmp=C[i][l];
				int t2;
				if (l==0&amp;&amp;i==n) t2=hao[0][j+1];
				else t2=hao[l+n-i][j];
				if (t2!=-1)
				{
					a[t][t2]+=tmp;
					if (a[t][t2]&gt;=mo) a[t][t2]-=mo;
				}
				//if (t2!=-1) printf(&quot;(%d,%d) -&gt; (%d,%d)\n&quot;,i,j,b[t2].fi,b[t2].se);
			}
		}
	a=a^m;
	int t=hao[n][0];
	ans[1][t]=1;
	ans=ans*a;
	LL res=0;
	for (i=1;i&lt;=cnt;i++)
	{
		res+=ans[1][i];
		if (res&gt;=mo) res-=mo;
	}
	return res;
}
LL work2()
{
	static int hao[10][10][5];
	memset(hao,-1,sizeof(hao));
	int i,j,k;
	for (i=0;i&lt;=n;i++)
		for (j=0;j+i&lt;=n;j++)
			for (k=0;k&lt;=Q;k++) hao[i][j][k]=++cnt;
	for (i=0;i&lt;=n;i++)
		for (j=0;j+i&lt;=n;j++)
			for (k=0;k&lt;=Q;k++)
			{
				int t=hao[i][j][k];
				for (int n1=0;n1&lt;=i;n1++)
					for (int n2=0;n2&lt;=j;n2++)
					{
						LL tmp=C[i][n1]*C[j][n2]%mo;
						int t2;
						if (n1+n2==n) t2=hao[i-n1+n-i-n2][n1][k+1];
						else t2=hao[i-n1+n-i-n2][n1][k];
						if (t2!=-1)
						{
							a[t][t2]+=tmp;
							if (a[t][t2]&gt;=mo) a[t][t2]-=mo;
						}
					}
			}
	a=a^m;
	int t=hao[n][0][0];
	ans[1][t]=1;
	ans=ans*a;
	LL res=0;
	for (i=1;i&lt;=cnt;i++)
	{
		res+=ans[1][i];
		if (res&gt;=mo) res-=mo;
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;P&gt;&gt;Q;
	if (P==0) {printf(&quot;0\n&quot;);return 0;}
	if (P==1) {printf(&quot;1\n&quot;);return 0;}
	C[0][0]=1;
	for (int i=1;i&lt;=8;i++)
		for (int j=0;j&lt;=8;j++)
		{
			if (j==0) C[i][j]=1;
			else C[i][j]=C[i-1][j-1]+C[i-1][j];
		}
	if (P==2) cout&lt;&lt;work1()&lt;&lt;endl;
	else cout&lt;&lt;work2()&lt;&lt;endl;
	return 0;
}<pre><h2>Problem3120</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
typedef long long LL;
#define mo 1000000007
int n,P,Q,cnt,C[10][10];
LL m;
struct matrix
{
	int qq[201][201];
	matrix() {memset(qq,0,sizeof(qq));}
	int * operator [](int x) {return qq[x];}
	friend matrix operator *(matrix a,matrix b)
	{
		matrix c;
		for (int k=1;k&lt;=cnt;k++)
			for (int i=1;i&lt;=cnt;i++) if (a[i][k])
				for (int j=1;j&lt;=cnt;j++) if (b[k][j])
				{
					c[i][j]+=(LL)a[i][k]*b[k][j]%mo;
					if (c[i][j]&gt;=mo) c[i][j]-=mo;
				}
		return c;
	}
	friend matrix operator ^(matrix a,LL b)
	{
		matrix res;
		for (int i=1;i&lt;=cnt;i++) res[i][i]=1;
		for (;b;b&gt;&gt;=1,a=a*a)
			if (b&amp;1) res=res*a;
		return res;
	}
} a,ans;
int work2()
{
	static int hao[10][10];
	int i,j,k;
	memset(hao,-1,sizeof(hao));
	for (i=0;i&lt;=n;i++)
		for (j=0;j&lt;=Q;j++) hao[i][j]=++cnt;
	for (i=0;i&lt;=n;i++)
		for (j=0;j&lt;=Q;j++)
		{
			int t=hao[i][j];
			for (k=0;k&lt;=i;k++)
			{
				int tmp=C[i][k];
				int i2=(n-i)+k;
				int j2=(i2==0)?j+1:j;
				int t2=hao[i2][j2];
				if (t2!=-1)
				{
					a[t][t2]+=tmp;
					if (a[t][t2]&gt;=mo) a[t][t2]-=mo;
				}
			}
		}
	a=a^m;
	ans[1][hao[n][0]]=1;
	ans=ans*a;
	LL res=0;
	for (i=1;i&lt;=cnt;i++)
	{
		res+=ans[1][i];
		if (res&gt;=mo) res-=mo;
	}
	return res;
}
int work3()
{
	static int hao[10][10][10];
	int i,j,k,n1,n2;
	memset(hao,-1,sizeof(hao));
	for (i=0;i&lt;=n;i++)
		for (j=0;j+i&lt;=n;j++)
			for (k=0;k&lt;=Q;k++) hao[i][j][k]=++cnt;
	for (i=0;i&lt;=n;i++)
		for (j=0;j+i&lt;=n;j++)
			for (k=0;k&lt;=Q;k++)
			{
				int t=hao[i][j][k];
				for (n1=0;n1&lt;=i;n1++)
					for (n2=0;n2&lt;=j;n2++)
					{
						int tmp=(LL)C[i][n1]*C[j][n2];
						int i2=n1+n2+(n-i-j);
						int j2=i-n1;
						int k2=(i2==0)?k+1:k;
						//printf(&quot;%d %d %d -&gt; %d %d %d\n&quot;,i,j,k,i2,j2,k2);
						int t2=hao[i2][j2][k2];
						if (t2!=-1)
						{
							a[t][t2]+=tmp;
							if (a[t][t2]&gt;=mo) a[t][t2]-=mo;
						}
					}
			}
	a=a^m;
	ans[1][hao[n][0][0]]=1;
	ans=ans*a;
	LL res=0;
	for (i=1;i&lt;=cnt;i++)
	{
		res+=ans[1][i];
		if (res&gt;=mo) res-=mo;
	}
	return res;
}
int main()
{
	//freopen(&quot;line.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;line.out&quot;,&quot;w&quot;,stdout);
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;P&gt;&gt;Q;
	if (P==0) {printf(&quot;0\n&quot;);return 0;}
	if (P==1) {printf(&quot;1\n&quot;);return 0;}
	C[0][0]=1;
	for (int i=1;i&lt;=8;i++)
	{
		C[i][0]=1;
		for (int j=1;j&lt;=i;j++)
			C[i][j]=C[i-1][j-1]+C[i-1][j];
	}
	if (P==2) cout&lt;&lt;work2()&lt;&lt;endl;
	else cout&lt;&lt;work3()&lt;&lt;endl;
	return 0;
}<pre><h2>Problem3122</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define LL long long
LL X1,A,B,t,mo,TC,f[1000000];
struct Baby
{
	LL k;
	int id;
	friend bool operator &lt;(Baby a,Baby b) {return a.k&lt;b.k;}
} c[1000000];
LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (;b;b&gt;&gt;=1,a=a*a%c) if (b&amp;1) res=res*a%c;
	return res;
}
LL bsgs(LL a,LL b,LL p)
{
	//printf(&quot;bsgs=========\n&quot;);
	//printf(&quot;%lld %lld %lld\n&quot;,a,b,p);
	LL m,num,i,l,r,mid,tmp;
	m=(int)sqrt(p)+1;
	//printf(&quot;m=%lld\n&quot;,m);
	f[0]=1;
	c[0].id=0,c[0].k=f[0];
	for (i=1;i&lt;=m;i++)
	{
		f[i]=f[i-1]*a%p;
		c[i].id=i,c[i].k=f[i];
	}
	sort(c,c+m+1);
	num=0;
	for (i=1;i&lt;=m;i++)
		if (c[i].k!=c[num].k) c[++num]=c[i];
		else if (c[i].k==c[num].k&amp;&amp;c[i].id&lt;c[num].id) c[num].id=c[i].id;
	//for (i=0;i&lt;=num;i++) printf(&quot;%lld %lld\n&quot;,c[i].k,c[i].id);
	for (i=0;i&lt;=m;i++)
	{
		tmp=ksm(a,i*m,p);
		if (tmp==0)
			if (b==0) return i*m;
			else return -2;
		tmp=b*ksm(tmp,p-2,p)%p;
		//printf(&quot;tmp=%lld\n&quot;,tmp);
		l=0,r=num;
		while (l&lt;=r)
		{
			mid=(l+r)&gt;&gt;1;
			if (c[mid].k==tmp) return i*m+c[mid].id;
			if (c[mid].k&gt;tmp) r=mid-1;
			else l=mid+1;
		}
	}
	return -2;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	//freopen(&quot;random.in&quot;,&quot;r&quot;,stdin);freopen(&quot;random.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%lld&quot;,&amp;TC);TC;TC--)
	{
		//printf(&quot;\n----------------------------------------------------------\n&quot;);
		scanf(&quot;%lld%lld%lld%lld%lld&quot;,&amp;mo,&amp;A,&amp;B,&amp;X1,&amp;t);
		//printf(&quot;%I64d %I64d %I64d %I64d %I64d\n&quot;,mo,A,B,X1,t);
		if (X1==t) {printf(&quot;%d\n&quot;,1);continue;}
		if (A==0)
		{
			printf(&quot;%d\n&quot;,B==t?2:-1);
			continue;
		}
		if (A==1)
		{
			LL tmp=(t-X1)%mo;
			if (tmp&lt;0) tmp+=mo;
			if (B==0) printf(&quot;-1\n&quot;);
			else
			{
				LL tmp=t-X1;
				tmp=tmp*ksm(B,mo-2,mo)%mo;
				if (tmp&lt;0) tmp+=mo;
				printf(&quot;%lld\n&quot;,tmp+1);
			}
			continue;
		}
		LL Y=(t+B*ksm(A-1,mo-2,mo))%mo;
		//printf(&quot;Y=%lld\n&quot;,Y);
		//printf(&quot;%lld\n&quot;,X1+B*ksm(A-1,mo-2,mo)%mo);
		//printf(&quot;%lld\n&quot;,ksm(4,mo-2,mo));
		Y=Y*ksm(X1+B*ksm(A-1,mo-2,mo)%mo,mo-2,mo)%mo;
		//printf(&quot;Y=%lld\n&quot;,Y);
		LL ans=bsgs(A,Y,mo)+1;
		//printf(&quot;%lld &quot;,TC);
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}
<pre><h2>Problem3122</h2><pre>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;
#define ll long long
inline ll POW(ll x,ll y,ll mod){
	for(ll z=1;;x=x*x%mod,y&gt;&gt;=1)
	    if(y&amp;1) z=z*x%mod;
	    else if(!y) return z;
}
inline int GCD(int a,int b){
	for(int c;b;c=b,b=a%b,a=c);
	return a;
}
inline void EXGCD(ll a,ll b,ll &amp;x,ll &amp;y){
	if(!b){x=1,y=0;return;}
	else EXGCD(b,a%b,y,x),y-=a/b*x;
}
int cnt,hash[100007],num[100007],ci[100007];
inline void add(int x,int shu){
	int pos=x%100007;
	while(hash[pos]&amp;&amp;num[hash[pos]]!=x) pos=(pos+1)%100007;
	if(num[hash[pos]]==x&amp;&amp;ci[hash[pos]]&gt;shu) ci[hash[pos]]=shu;
	if(!hash[pos]) hash[pos]=++cnt,num[cnt]=x,ci[cnt]=shu;
}
inline int find(int x){
	int pos=x%100007;
	while(hash[pos]&amp;&amp;num[hash[pos]]!=x) pos=(pos+1)%100007;
	if(hash[pos]) return ci[hash[pos]];
	return -1;
}
inline int BSGS(int A,int B,int C){
	ll i,j,k,m=sqrt(C)+1,x,y;
	cnt=0,memset(hash,0,sizeof(hash));
	for(i=0,j=1;i&lt;m;++i,j=j*A%C) add(j,i);
	for(i=0,k=1;i&lt;m;++i,k=k*j%C){
		EXGCD(k,C,x,y);
		x=(x*B%C+C)%C;
		if(~(x=find(x))) return i*m+x;
	}
	return -1;
}
int main(){
	int T,P,a,b,x1,t,A,B,C,ANS;ll x,y;
	for(scanf(&quot;%d&quot;,&amp;T);T--;){
		scanf(&quot;%d%d%d%d%d&quot;,&amp;P,&amp;a,&amp;b,&amp;x1,&amp;t);
		if(x1==t) puts(&quot;1&quot;);
		else if(a==0){
			if(b==t) puts(&quot;2&quot;);
			else puts(&quot;-1&quot;);
		}
		else if(a==1){
			if(!b) puts(&quot;-1&quot;);
			else{
				EXGCD(b,P,x,y);
				x=(x*(t-x1)%P+P)%P;
				printf(&quot;%lld\n&quot;,x+1);
			}
		}else{
			x=POW(a-1,P-2,P)*b%P;
			A=a,C=P;
			B=POW(x1+x,P-2,P)*(x+t)%P;
			if(~(ANS=BSGS(A%C,B,C))) printf(&quot;%d\n&quot;,ANS+1);
			else puts(&quot;-1&quot;);
		}
	}
}<pre><h2>Problem3123</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 2000000000
int lc[15000000],rc[15000000],num[15000000],aa[1000000][2],o[80005];
int root[80005],S[80005],deep[80005],fa[80005][18],w[80005];
int n,m,tot,SIZE,T,lastans;
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void ins(int &amp;v,int pos,int ll,int rr,int x)
{
	if (!v) v=++SIZE;
	num[v]=num[pos]+1;
	if (rr-ll==1) return;
	int mid=(ll+rr)&gt;&gt;1;
	if (x&lt;mid)
	{
		rc[v]=rc[pos];
		ins(lc[v],lc[pos],ll,mid,x);
	}
	else
	{
		lc[v]=lc[pos];
		ins(rc[v],rc[pos],mid,rr,x);
	}
}
void buildtree(int v,int ROOT)
{
	S[ROOT]++;
	ins(root[v],root[fa[v][0]],0,inf,w[v]);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y!=fa[v][0])
		{
			deep[y]=deep[v]+1;
			fa[y][0]=v;
			buildtree(y,ROOT);
		}
	}
}
int getlca(int x,int y)
{
	if (deep[x]&lt;deep[y]) swap(x,y);
	for (int i=17;i&gt;=0;i--)
		if (deep[fa[x][i]]&gt;=deep[y]) x=fa[x][i];
	if (x==y) return x;
	for (int i=17;i&gt;=0;i--)
		if (fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}
int find(int a,int b,int c,int d,int ll,int rr,int K)
{
	if (rr-ll==1) return ll;
	int mid=(ll+rr)&gt;&gt;1;
	int tmp=num[lc[a]]+num[lc[b]]-num[lc[c]]-num[lc[d]];
	if (K&lt;=tmp) return find(lc[a],lc[b],lc[c],lc[d],ll,mid,K);
	else return find(rc[a],rc[b],rc[c],rc[d],mid,rr,K-tmp);
}
int getroot(int x)
{
	for (int i=17;i&gt;=0;i--)
		if (fa[x][i]!=0) x=fa[x][i];
	return x;
}
void recalcfa(int v)
{
	deep[v]=deep[fa[v][0]]+1;
	for (int j=1;j&lt;=17;j++) fa[v][j]=fa[fa[v][j-1]][j-1];
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y!=fa[v][0]) recalcfa(y);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int x,y,K,i,j;
	scanf(&quot;%d&quot;,&amp;x);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;T);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;w[i]);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y);
		addedge(y,x);
	}
	for (i=1;i&lt;=n;i++)
		if (fa[i][0]==0) deep[i]=1,buildtree(i,i);
	for (j=1;j&lt;=17;j++)
		for (i=1;i&lt;=n;i++) fa[i][j]=fa[fa[i][j-1]][j-1];
	//for (i=1;i&lt;=n;i++){printf(&quot;i=%d :&quot;,i);for (j=0;j&lt;=17;j++) printf(&quot;%d &quot;,fa[i][j]);printf(&quot;\n&quot;);}
	lastans=0;
	for (;T;T--)
	{
		//printf(&quot;\n----------------------------------------------------------------\n&quot;);
		char ch='1';
		while (ch!='Q'&amp;&amp;ch!='L') scanf(&quot;%c&quot;,&amp;ch);
		//printf(&quot;ch: %c\n&quot;,ch);
		if (ch=='Q')
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;K);
			x^=lastans,y^=lastans,K^=lastans;
			//printf(&quot;%d %d\n&quot;,x,y);
			int lca=getlca(x,y);
			//printf(&quot;lca= %d\n&quot;,lca);
			int tt=fa[lca][0];
			lastans=find(root[x],root[y],root[lca],root[tt],0,inf,K);
			printf(&quot;%d\n&quot;,lastans);
		}
		else
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x^=lastans,y^=lastans;
			int xx=getroot(x);
			int yy=getroot(y);
			//printf(&quot;%d %d\n&quot;,x,y);
			//printf(&quot;%d %d\n&quot;,xx,yy);
			if (S[xx]&lt;S[yy]) swap(x,y),swap(xx,yy);
			S[y]=S[yy];
			int t1=y,t2=fa[t1][0],t3=fa[t2][0];
			for (;t3;t1=t2,t2=t3,t3=fa[t3][0]) fa[t2][0]=t1;
			if (t2!=0) fa[t2][0]=t1;
			addedge(x,y);
			addedge(y,x);
			buildtree(x,xx);
			recalcfa(y);
			S[xx]+=S[y],S[y]=0;
		}
	}
	return 0;
}
<pre><h2>Problem3123</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define inf 2000000000
int lc[15000000],rc[15000000],num[15000000],aa[1000000][2],o[80005];
int root[80005],S[80005],deep[80005],fa[80005][18],w[80005];
int n,m,tot,SIZE,T,lastans;
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void ins(int &amp;v,int pos,int ll,int rr,int x)
{
	if (!v) v=++SIZE;
	num[v]=num[pos]+1;
	if (rr-ll==1) return;
	int mid=(ll+rr)&gt;&gt;1;
	if (x&lt;mid)
	{
		rc[v]=rc[pos];
		ins(lc[v],lc[pos],ll,mid,x);
	}
	else
	{
		lc[v]=lc[pos];
		ins(rc[v],rc[pos],mid,rr,x);
	}
}
void buildtree(int v,int ROOT)
{
	S[ROOT]++;
	ins(root[v],root[fa[v][0]],0,inf,w[v]);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y!=fa[v][0])
		{
			deep[y]=deep[v]+1;
			fa[y][0]=v;
			buildtree(y,ROOT);
		}
	}
}
int getlca(int x,int y)
{
	if (deep[x]&lt;deep[y]) swap(x,y);
	for (int i=17;i&gt;=0;i--)
		if (deep[fa[x][i]]&gt;=deep[y]) x=fa[x][i];
	if (x==y) return x;
	for (int i=17;i&gt;=0;i--)
		if (fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}
int find(int a,int b,int c,int d,int ll,int rr,int K)
{
	if (rr-ll==1) return ll;
	int mid=(ll+rr)&gt;&gt;1;
	int tmp=num[lc[a]]+num[lc[b]]-num[lc[c]]-num[lc[d]];
	if (K&lt;=tmp) return find(lc[a],lc[b],lc[c],lc[d],ll,mid,K);
	else return find(rc[a],rc[b],rc[c],rc[d],mid,rr,K-tmp);
}
int getroot(int x)
{
	for (int i=17;i&gt;=0;i--)
		if (fa[x][i]!=0) x=fa[x][i];
	return x;
}
void recalcfa(int v)
{
	deep[v]=deep[fa[v][0]]+1;
	for (int j=1;j&lt;=17;j++) fa[v][j]=fa[fa[v][j-1]][j-1];
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y!=fa[v][0]) recalcfa(y);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int x,y,K,i,j;
	scanf(&quot;%d&quot;,&amp;x);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;T);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;w[i]);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y);
		addedge(y,x);
	}
	for (i=1;i&lt;=n;i++)
		if (fa[i][0]==0) deep[i]=1,buildtree(i,i);
	for (j=1;j&lt;=17;j++)
		for (i=1;i&lt;=n;i++) fa[i][j]=fa[fa[i][j-1]][j-1];
	//for (i=1;i&lt;=n;i++){printf(&quot;i=%d :&quot;,i);for (j=0;j&lt;=17;j++) printf(&quot;%d &quot;,fa[i][j]);printf(&quot;\n&quot;);}
	lastans=0;
	for (;T;T--)
	{
		//printf(&quot;\n----------------------------------------------------------------\n&quot;);
		char ch='1';
		while (ch!='Q'&amp;&amp;ch!='L') scanf(&quot;%c&quot;,&amp;ch);
		//printf(&quot;ch: %c\n&quot;,ch);
		if (ch=='Q')
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;K);
			x^=lastans,y^=lastans,K^=lastans;
			//printf(&quot;%d %d\n&quot;,x,y);
			int lca=getlca(x,y);
			//printf(&quot;lca= %d\n&quot;,lca);
			int tt=fa[lca][0];
			lastans=find(root[x],root[y],root[lca],root[tt],0,inf,K);
			printf(&quot;%d\n&quot;,lastans);
		}
		else
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x^=lastans,y^=lastans;
			int xx=getroot(x);
			int yy=getroot(y);
			//printf(&quot;%d %d\n&quot;,x,y);
			//printf(&quot;%d %d\n&quot;,xx,yy);
			if (S[xx]&lt;S[yy]) swap(x,y),swap(xx,yy);
			S[y]=S[yy];
			int t1=y,t2=fa[t1][0],t3=fa[t2][0];
			for (;t3;t1=t2,t2=t3,t3=fa[t3][0]) fa[t2][0]=t1;
			if (t2!=0) fa[t2][0]=t1;
			addedge(x,y);
			addedge(y,x);
			buildtree(x,xx);
			recalcfa(y);
			//S[xx]+=S[y],S[y]=0;
		}
	}
	return 0;
}
<pre><h2>Problem3124</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define maa(a,b) (a&gt;b?a:b)
#define mii(a,b) (a&lt;b?a:b)
#define ln printf(&quot;\n&quot;)
const int NN=201111;
typedef long long LL;
int n,tot,TIME,b[NN],q[NN],vt[NN],o[NN],aa[NN*2][3],pre[NN];
LL dist[NN],dd[NN];
bool flag[NN];
void bfs(int v)
{
	memset(dist,0,sizeof(dist));
	memset(pre,0,sizeof(pre));
	TIME++;
	int head=0,tail=1;
	q[1]=v;
	vt[v]=TIME;
	while (head&lt;tail)
	{
		int x=q[++head];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (vt[y]!=TIME)
			{
				vt[y]=TIME;
				dist[y]=dist[x]+aa[p][2];
				pre[y]=x;
				q[++tail]=y;
			}
		}
	}
}
LL bfs2(int v)
{
	LL res=0;
	int head=0,tail=0;
	TIME++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (flag[y]) continue;
		dist[y]=aa[p][2];
		vt[y]=TIME;
		q[++tail]=y;
	}
	while (head&lt;tail)
	{
		int x=q[++head];
		if (dist[x]&gt;res) res=dist[x];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (vt[y]==TIME||flag[y]) continue;
			vt[y]=TIME;
			dist[y]=dist[x]+aa[p][2];
			q[++tail]=y;
		}
	}
	return res;
}
void addedge(int p,int q,int v)
{
	//printf(&quot;add  %d %d %d\n&quot;,p,q,v);
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	//freopen(&quot;diameter.in&quot;,&quot;r&quot;,stdin);freopen(&quot;diameter.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
	}
	bfs(1);
	LL mm=0;
	int mi;
	for (i=1;i&lt;=n;i++)
		if (dist[i]&gt;mm) mm=dist[i],mi=i;
	//printf(&quot;dist &quot;);for(i=1;i&lt;=n;i++)printf(&quot;%I64d &quot;,dist[i]);ln;
	bfs(mi);
	//printf(&quot;dist &quot;);for(i=1;i&lt;=n;i++)printf(&quot;%I64d &quot;,dist[i]);ln;
	mm=0;
	for (i=1;i&lt;=n;i++)
		if (dist[i]&gt;mm) mm=dist[i],mi=i;
	LL ans1=mm;
	int num=0;
	for (x=mi;x;x=pre[x]) b[++num]=x,flag[x]=true;
	for (i=1;i*2&lt;=num;i++) {int t=b[i];b[i]=b[num-i+1];b[num-i+1]=t;}
	for (i=1;i&lt;=num;i++) dd[i]=dist[b[i]];
	int l=1,r=num;
	for (i=1;i&lt;=num;i++)
	{
		LL tmp=bfs2(b[i]);
		if (tmp==dd[i]) l=maa(l,i);
		if (tmp==ans1-dd[i]) r=mii(i,r);
	}
	printf(&quot;%lld\n&quot;,ans1);
	if (l&gt;r) printf(&quot;0\n&quot;);else printf(&quot;%d\n&quot;,r-l);
	return 0;
}<pre><h2>Problem3129</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
using namespace std;
#define LL long long
int TC,n,n1,n2,m,tot,a[1000000];
LL P,P2,all,ttt,f[1000000],pp[1000000],phi[1000000],prime[1000000],ee[1000000];
struct ppt
{
	LL u,t;
};
LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (;b;b&gt;&gt;=1,a=a*a%c) if (b&amp;1) res=res*a%c;
	return res;
}
void prepare()
{
	P2=P;
	//printf(&quot;%lld\n&quot;,P);
	LL i,tmp;
	for (i=2,tmp=(int)sqrt(P)+1;i&lt;=tmp;i++)
		if (P2%i==0)
		{
			//printf(&quot;i=%d\n&quot;,i);
			prime[++tot]=i;
			for (pp[tot]=1;P2%i==0;P2/=i) pp[tot]*=i;
			phi[tot]=pp[tot]-pp[tot]/i;
			ee[tot]=P/pp[tot]*ksm(P/pp[tot],phi[tot]-1,pp[tot])%P;
		}
	//printf(&quot;%d\n&quot;,0);
	if (P2&gt;1)
	{
		i=P2;
		prime[++tot]=i;
		for (pp[tot]=1;P2%i==0;P2/=i) pp[tot]*=i;
		phi[tot]=pp[tot]-pp[tot]/i;
		ee[tot]=P/pp[tot]*ksm(P/pp[tot],phi[tot]-1,pp[tot])%P;
	}
}
ppt calc(LL n,LL prime,LL pp)
{
	ppt res;
	res.u=0,res.t=1;
	for (;n;)
	{
		res.u+=n/prime;
		res.t=res.t*ksm(f[pp-1],n/pp,pp)%pp;
		res.t=res.t*f[n%pp]%pp;
		n/=prime;
	}
	return res;
}
LL C(LL n,LL m)
{
	if (n&lt;m) return 0;
	LL i,j,ss,tt,ans;
	ans=0;
	for (i=1;i&lt;=tot;i++)
	{
		f[0]=f[1]=1;
		for (j=2;j&lt;=pp[i];j++)
			if (j%prime[i]) f[j]=f[j-1]*j%pp[i];
			else f[j]=f[j-1];
		ppt tmp=calc(n,prime[i],pp[i]);
		ss=tmp.u,tt=tmp.t;
		tmp=calc(m,prime[i],pp[i]);
		ss-=tmp.u,tt=tt*ksm(tmp.t,phi[i]-1,pp[i])%pp[i];
		tmp=calc(n-m,prime[i],pp[i]);
		ss-=tmp.u,tt=tt*ksm(tmp.t,phi[i]-1,pp[i])%pp[i];
		ans=(ans+tt*ksm(prime[i],ss,pp[i])%P*ee[i])%P;
	}
	return ans;
}
void dfs(int t,int num)
{
	//printf(&quot;t=%d\n&quot;,t);
	//printf(&quot;n1=%d\n&quot;,n1);
	//printf(&quot;ttt=%lld\n&quot;,ttt);
	if (t==n1+1) return;
	dfs(t+1,num);
	m-=a[t];
	num++;
	//printf(&quot;%d %d\n&quot;,m-1,n-1);
	if (num&amp;1) ttt=(ttt+C(m-1,n-1))%P;
	else ttt=(ttt-C(m-1,n-1))%P;
	dfs(t+1,num);
	num--;
	m+=a[t];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%lld&quot;,&amp;TC,&amp;P);
	prepare();
	//printf(&quot;C(7,3)=%lld\n&quot;,C(7,3));
	for (;TC;TC--)
	{
		//printf(&quot;\n-------------------------------------------------------\n&quot;);
		int i;
		scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;n1,&amp;n2,&amp;m);
		for (i=1;i&lt;=n1;i++) scanf(&quot;%d&quot;,&amp;a[i]);
		for (i=n1+1;i&lt;=n1+n2;i++)
		{
			scanf(&quot;%d&quot;,&amp;a[i]);
			m-=(a[i]-1);
		}
		if (n1==0&amp;&amp;n2==0)
		{
			printf(&quot;%lld\n&quot;,C(m-1,n-1));
			continue;
		}
		all=C(m-1,n-1);
		//printf(&quot;all=%lld\n&quot;,all);
		ttt=0;
		dfs(1,0);
		//printf(&quot;ttt=%lld\n&quot;,ttt);
		printf(&quot;%lld\n&quot;,((all-ttt)%P+P)%P);
	}
	return 0;
}
<pre><h2>Problem3130</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
#define inf 999999999
#define mii(a,b) ((a)&lt;(b)?(a):(b))
typedef double DD;
const DD eps=1e-7;
const int NN=1011,MM=10111;
int o[NN],aa[MM*2][2],deep[NN],q[NN],cur[NN];
int n,m,P,tot,iii;
DD cc[MM*2];
struct edge{int a,b,w;} e[MM];
bool bfs()
{
	memset(deep,0,sizeof(deep));
	deep[1]=1;
	int head=0,tail=1;
	q[1]=1;
	while (head&lt;tail)
	{
		int x=q[++head];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (!deep[y]&amp;&amp;cc[p]&gt;eps)
			{
				deep[y]=deep[x]+1;
				q[++tail]=y;
				//if (y==n) printf(&quot;cc==%.3f\n&quot;,cc[p]);
			}
		}
	}
	for (int i=1;i&lt;=n;i++) cur[i]=o[i];
	return deep[n];
}
DD dfs(int v,DD ff)
{
	if (v==n) return ff;
	DD res=0;
	for (int &amp;p=cur[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (cc[p]&lt;eps||deep[y]!=deep[v]+1) continue;
		DD tmp=dfs(y,mii(cc[p],ff));
		ff-=tmp;
		cc[p]-=tmp;
		cc[p^1]+=tmp;
		res+=tmp;
		if (ff&lt;eps) break;
	}
	return res;
}
void addedge(int p,int q,DD v)
{
	tot++;
	aa[tot][1]=q;
	cc[tot]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,DD v)
{
	addedge(p,q,v);
	addedge(q,p,0);
}
DD dinic(DD mid)
{
	//printf(&quot;dinic %.3f\n&quot;,mid);
	memset(o,0,sizeof(o));
	tot=1;
	for (int i=1;i&lt;=m;i++) add(e[i].a,e[i].b,mii(e[i].w,mid));
	//printf(&quot;tot=%d\n&quot;,tot);
	DD res=0;
	while (bfs())
	{
		//printf(&quot;deep[n]=%d\n&quot;,deep[n]);
		res+=dfs(1,inf);
		//printf(&quot;res=%.3f\n&quot;,res);
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;P);
	for (int i=1;i&lt;=m;i++) scanf(&quot;%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
	DD maxflow=dinic(inf),ans=inf;
	DD l=0,r=inf;
	while (r-l&gt;1e-6)
	{
		DD mid=(l+r)*0.5;
		if (fabs(dinic(mid)-maxflow)&lt;eps) r=mid,ans=mid;
		else l=mid;
	}
	printf(&quot;%.0f\n%.5f\n&quot;,maxflow,P*ans);
	return 0;
}<pre><h2>Problem3130</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
const double eps=1e-5;
const double feps=1e-7;
struct node
{
       int point,link;
       double c,f;
}list[2000],list1[2000];
int v[1001],vv[1001],q[1001],d[1001];
bool vis[1001];
int n,m,p,num;
double maxflow;
void join(int x,int y,double c)
{
     num++; list[num].point=y; list[num].c=c; list[num].f=0; list[num].link=v[x]; v[x]=num;
}
bool bfs()
{
     int h,t,x,i;
     memset(vis,false,sizeof(vis));
     h=0; t=1; q[1]=1; d[1]=0; vis[1]=true;
     while (h&lt;t)
     {
           h++; x=q[h]; i=v[x];
           while (i!=-1)
           {
                 if ((!vis[list[i].point])&amp;&amp;(list[i].c&gt;list[i].f))
                 {
                    vis[list[i].point]=true; t++; q[t]=list[i].point;
                    d[list[i].point]=d[x]+1;
                 }
                 i=list[i].link;
           }
     }
     for (i=1;i&lt;=n;i++) vv[i]=v[i];
     return vis[n];
}
double gmin(double x,double y)
{
       return x&lt;y?x:y;
}
double dfs(int i,double t)
{
       int &amp;j=vv[i];
       double tt,u;
       tt=t;
       if (i==n) return t;
       while (j!=-1)
       {
             if ((d[list[j].point]==d[i]+1)&amp;&amp;(list[j].c&gt;list[j].f))
             {
                u=dfs(list[j].point,gmin(t,list[j].c-list[j].f));
                list[j].f+=u; list[j^1].f-=u; t-=u;
             }
             if (fabs(t)&lt;feps) break;
             j=list[j].link;
       }
    return tt-t;
}
double dinic()
{
       double ans;
       ans=0;
       while (bfs()) ans+=dfs(1,1e7);
       return ans;
}
bool can(double x)
{
     int i;
     memcpy(list,list1,sizeof(list1));
     for (i=0;i&lt;=num;i++) list[i].c=gmin(list[i].c,x);
     return fabs(dinic()-maxflow)&lt;feps;
}
int main()
{
    int i,x,y;
    double z,h,t,mid;
    //freopen(&quot;costflow.in&quot;,&quot;r&quot;,stdin);freopen(&quot;costflow.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;p);
    memset(v,0xff,sizeof(v));
    num=-1;
    for (i=1;i&lt;=m;i++)
    {
        scanf(&quot;%d%d%lf&quot;,&amp;x,&amp;y,&amp;z);
        join(x,y,z); join(y,x,0);
    }
    memcpy(list1,list,sizeof(list));
    maxflow=dinic();
    h=0; t=100000;
    while (t-h&gt;eps)
    {
          mid=(h+t)/2;
          if (can(mid)) t=mid;
          else h=mid;
    }
    printf(&quot;%d\n%.4lf\n&quot;,int(maxflow),h*p); return 0;
}<pre><h2>Problem3131</h2><pre>#include &lt;cstdio&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;utility&gt;
#include &lt;algorithm&gt;
using namespace std;
 
#define rep(I,L,R) for(int I=(L),I##_E=(R);I&lt;=I##_E;++I)
 
typedef long long LL;
const LL modu = LL(1e9) + 7;
const int N = 200000;
 
typedef pair&lt;LL, int&gt; pi;
#define Px first
#define Py second
 
LL f[15][N], axis[N]; // len, 2, 3, 5, 7
int digits[20], len, acnt;
LL n;
int k;
 
inline void inc (LL &amp;x, LL y) {
    x = x + y;
}
void getAxis (LL cv, int cp) {
    if (cp == 5) {
        axis[++acnt] = cv;
        return;
    }
    if (cp == 1) {
        if (cv * 2 &lt;= n) getAxis(cv * 2, cp);
        getAxis(cv, 2);
    }
    else if (cp == 2) {
        if (cv * 3 &lt;= n) getAxis(cv * 3, cp);
        getAxis(cv, 3);
    }
    else if (cp == 3) {
        if (cv * 5 &lt;= n) getAxis(cv * 5, cp);
        getAxis(cv, 4);
    }
    else {
        if (cv * 7 &lt;= n) getAxis(cv * 7, cp);
        getAxis(cv, 5);
    }
}
inline int gp (LL x) { return lower_bound(axis + 1, axis + 1 + acnt, x) - axis; }
void init () {
	
    LL cn = n + 1;
    while (cn) digits[++len] = cn % 10, cn /= 10;
    getAxis(1, 1);
    //printf(&quot;%Id\n&quot;,acnt);
    sort(axis + 1, axis + 1 + acnt);
    f[0][gp(1)] = 1;
    for (int i = 0; i &lt;= 12; ++i) {
        for (int j = 1; j &lt;= acnt; ++j) {
			//printf(&quot;%d %d %d\n&quot;,i,j,f[i][j]);
            if (!f[i][j]) continue;
            for (int k = 1; k &lt;= 9; ++k)
                inc(f[i + 1][gp(axis[j] * k)], f[i][j]);
        }
    }
}
 
LL getCount (LL val) {
    LL res = 0, cv = val;
    for (int i = len - 1, idx = gp(cv); i &gt;= 1; --i)
        res += f[i][idx];
    for (int i = len; i &gt;= 1; --i) {
        for (int j = 1; j &lt; digits[i]; ++j) {
            if (cv % j == 0)
                res += f[i - 1][gp(cv / j)];
        }
        if (!digits[i] || cv % digits[i]) break;
        cv /= digits[i];
    }
    //printf(&quot;%I64d %I64d\n&quot;,val,res);
    return res;
} 
multiset&lt;LL&gt; pool;
void selectG () {
    for (int i = 1; i &lt;= acnt; ++i) {
        LL cr = getCount(axis[i]);
        if (cr &gt; 0) {
            if (pool.size() == k &amp;&amp; *pool.begin() &gt; cr) continue;
            if (pool.size() == k) {
                pool.erase(pool.begin());
            }
            pool.insert(cr);
        }
//      if (cr &lt; 0) throw;
    }
}
 
LL lis[N];
int pos[N];
priority_queue&lt;pi&gt; pque;
void solve () {
    int cnt = pool.size();
    for (multiset&lt;LL&gt;::iterator it = pool.begin(); it != pool.end(); ++it) {
        lis[cnt--] = *it;
    }
    //for (int i=1;i&lt;=acnt;i++) printf(&quot;%I64d\n&quot;,lis[i]);
    for (int i = 1; i &lt;= k; ++i) {
        pos[i] = 1;
        pque.push(pi((LL)lis[pos[i]] * lis[i], i));
    }
    LL res = 0;
    for (int i = 1; i &lt;= k; ++i) {
        pi z = pque.top(); pque.pop();
        res = (res + z.Px) % modu;
        if (++pos[z.Py] &gt; k) continue;
        pque.push(pi((LL)lis[pos[z.Py]] * lis[z.Py], z.Py));
    }
    printf(&quot;%lld\n&quot;, res);  
}
 
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%lld%d&quot;, &amp;n, &amp;k);
    if (! k) {
        printf(&quot;0\n&quot;);
        return 0;
    }
    init();
    selectG();
    solve();
    return 0;
}
<pre><h2>Problem3131</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
#define LL long long
#define mo 1000000007
LL b[300000],c[1000],num[300000],f[20][300000],now[300000];
LL n,K,i,j,k,tmp,cnt;
struct ppt
{
	LL w,id;
	ppt(LL x=0,LL y=0) {w=x,id=y;};
	friend bool operator &lt; (ppt a,ppt b) {return a.w&lt;b.w;}
};
priority_queue&lt;ppt&gt; Q;
void dfs(LL t,LL now)
{
	if (t==5) {b[++b[0]]=now;return;}
	else if (t==4)
	{
		if (now*7&lt;=n) dfs(t,now*7);
		dfs(t+1,now);
	}
	else if (t==3)
	{
		if (now*5&lt;=n) dfs(t,now*5);
		dfs(t+1,now);
	}
	else if (t==2)
	{
		if (now*3&lt;=n) dfs(t,now*3);
		dfs(t+1,now);
	}
	else
	{
		if (now*2&lt;=n) dfs(t,now*2);
		dfs(t+1,now);
	}
}
bool cmp(LL a,LL b) {return a&gt;b;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld%lld&quot;,&amp;n,&amp;K);
	if (!K) {printf(&quot;%d\n&quot;,0);return 0;}
	dfs(1,1);
	sort(b+1,b+b[0]+1);
	//printf(&quot;b[0]=%I64d\n&quot;,b[0]);
	//for (i=1;i&lt;=b[0];i++) printf(&quot;%I64d &quot;,b[i]);printf(&quot;\n&quot;);
	map&lt;LL,LL&gt; a;//a[x]表示x离散化后是几 
	for (i=1;i&lt;=b[0];i++) a[b[i]]=i;
	f[0][a[1]]=1;
	for (i=0;i&lt;=12;i++)
		for (j=1;j&lt;=b[0];j++)
		{
			//printf(&quot;%I64d %I64d %I64d\n&quot;,i,j,f[i][j]);
			if (!f[i][j]) continue;
			for (k=1;k&lt;=9;k++) f[i+1][a[b[j]*k]]+=f[i][j];
		}
	//f[i][j]表示i位数，乘积为j的方案数
	tmp=n+1,cnt=0;
	for (;tmp;tmp/=10) c[++cnt]=tmp%10;
	//printf(&quot;cnt=%I64d\n&quot;,cnt);for (i=1;i&lt;=cnt;i++) printf(&quot;%I64d &quot;,c[i]);printf(&quot;\n&quot;);
	for (i=1;i&lt;=b[0];i++)
	{
		num[i]=0,tmp=b[i];//num[i]表示第i个数有多少种 
		for (j=cnt-1;j;j--) num[i]+=f[j][i];
		for (j=cnt;j;j--)
		{
			for (k=1;k&lt;c[j];k++)
				if (tmp%k==0) num[i]+=f[j-1][a[tmp/k]];
			if (c[j]==0||tmp%c[j]) break;
			tmp/=c[j];
		}
	}
	sort(num+1,num+b[0]+1,cmp);
	//for (i=1;i&lt;=b[0];i++) printf(&quot;%I64d\n&quot;,num[i]);
	for (i=1;i&lt;=b[0];i++) now[i]=1,Q.push(ppt(num[i]*num[1],i));
	LL ans=0;
	for (;K;K--)
	{
		ppt tmp=Q.top();
		Q.pop();
		ans=(ans+tmp.w)%mo;
		//printf(&quot;%lld\n&quot;,ans);
		now[tmp.id]++;
		if (now[tmp.id]&gt;b[0]) continue;
		Q.push(ppt(num[tmp.id]*num[now[tmp.id]],tmp.id));
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem3131</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
#define LL long long
#define mo 1000000007
LL b[300000],c[1000],num[300000],f[20][300000],now[300000];
LL n,K,i,j,k,tmp,cnt;
struct ppt
{
	LL w,id;
	ppt(LL x=0,LL y=0) {w=x,id=y;};
	friend bool operator &lt; (ppt a,ppt b) {return a.w&lt;b.w;}
};
priority_queue&lt;ppt&gt; Q;
void dfs(LL t,LL now)
{
	if (t==5) {b[++b[0]]=now;return;}
	else if (t==4)
	{
		if (now*7&lt;=n) dfs(t,now*7);
		dfs(t+1,now);
	}
	else if (t==3)
	{
		if (now*5&lt;=n) dfs(t,now*5);
		dfs(t+1,now);
	}
	else if (t==2)
	{
		if (now*3&lt;=n) dfs(t,now*3);
		dfs(t+1,now);
	}
	else
	{
		if (now*2&lt;=n) dfs(t,now*2);
		dfs(t+1,now);
	}
}
bool cmp(LL a,LL b) {return a&gt;b;}
int main()
{
	scanf(&quot;%lld%lld&quot;,&amp;n,&amp;K);
	if (!K) {printf(&quot;%d\n&quot;,0);return 0;}
	dfs(1,1);
	sort(b+1,b+b[0]+1);
	map&lt;LL,LL&gt; a;
	for (i=1;i&lt;=b[0];i++) a[b[i]]=i;
	f[0][a[1]]=1;
	for (i=0;i&lt;=12;i++)
		for (j=1;j&lt;=b[0];j++)
		{
			if (!f[i][j]) continue;
			for (k=1;k&lt;=9;k++) f[i+1][a[b[j]*k]]+=f[i][j];
		}
	tmp=n+1,cnt=0;
	for (;tmp;tmp/=10) c[++cnt]=tmp%10;
	for (i=1;i&lt;=b[0];i++)
	{
		num[i]=0,tmp=b[i];
		for (j=cnt-1;j;j--) num[i]+=f[j][i];
		for (j=cnt;j;j--)
		{
			for (k=1;k&lt;c[j];k++)
				if (tmp%k==0) num[i]+=f[j-1][a[tmp/k]];
			if (c[j]==0||tmp%c[j]) break;
			tmp/=c[j];
		}
	}
	sort(num+1,num+b[0]+1,cmp);
	for (i=1;i&lt;=b[0];i++) now[i]=1,Q.push(ppt(num[i]*num[1],i));
	LL ans=0;
	for (;K;K--)
	{
		ppt tmp=Q.top();
		Q.pop();
		ans=(ans+tmp.w)%mo;
		now[tmp.id]++;
		if (now[tmp.id]&gt;b[0]) continue;
		Q.push(ppt(num[tmp.id]*num[now[tmp.id]],tmp.id));
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem3131</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
#define LL long long
#define mo 1000000007
LL b[3000000],c[1000],num[300000],f[20][300000],now[3000000];
LL n,K,i,j,k,tmp,cnt;
struct ppt
{
	LL w,id;
	ppt(LL x=0,LL y=0) {w=x,id=y;};
	friend bool operator &lt; (ppt a,ppt b) {return a.w&lt;b.w;}
};
priority_queue&lt;ppt&gt; Q;
void dfs(LL t,LL now)
{
	if (t==5) {b[++b[0]]=now;return;}
	else if (t==4)
	{
		if (now*7&lt;=n) dfs(t,now*7);
		dfs(t+1,now);
	}
	else if (t==3)
	{
		if (now*5&lt;=n) dfs(t,now*5);
		dfs(t+1,now);
	}
	else if (t==2)
	{
		if (now*3&lt;=n) dfs(t,now*3);
		dfs(t+1,now);
	}
	else
	{
		if (now*2&lt;=n) dfs(t,now*2);
		dfs(t+1,now);
	}
}
bool cmp(LL a,LL b) {return a&gt;b;}
int main()
{
	scanf(&quot;%lld%lld&quot;,&amp;n,&amp;K);
	if (!K) {printf(&quot;%d\n&quot;,0);return 0;}
	dfs(1,1);
	sort(b+1,b+b[0]+1);
	map&lt;LL,LL&gt; a;
	for (i=1;i&lt;=b[0];i++) a[b[i]]=i;
	f[0][a[1]]=1;
	for (i=0;i&lt;=12;i++)
		for (j=1;j&lt;=b[0];j++)
		{
			if (!f[i][j]) continue;
			for (k=1;k&lt;=9;k++) f[i+1][a[b[j]*k]]+=f[i][j];
		}
	tmp=n+1,cnt=0;
	for (;tmp;tmp/=10) c[++cnt]=tmp%10;
	for (i=1;i&lt;=b[0];i++)
	{
		num[i]=0,tmp=b[i];
		for (j=cnt-1;j;j--) num[i]+=f[j][i];
		for (j=cnt;j;j--)
		{
			for (k=1;k&lt;c[j];k++)
				if (tmp%k==0) num[i]+=f[j-1][a[tmp/k]];
			if (c[j]==0||tmp%c[j]) break;
			tmp/=c[j];
		}
	}
	sort(num+1,num+b[0]+1,cmp);
	for (i=1;i&lt;=b[0];i++) now[i]=1,Q.push(ppt(num[i]*num[1],i));
	LL ans=0;
	for (;K;K--)
	{
		ppt tmp=Q.top();
		Q.pop();
		ans=(ans+tmp.w)%mo;
		now[tmp.id]++;
		if (now[tmp.id]&gt;b[0]) continue;
		Q.push(ppt(num[tmp.id]*num[now[tmp.id]],tmp.id));
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem3131</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
#define LL long long
#define mo 1000000007
LL b[3000000],c[1000],num[300000],f[20][300000],now[3000000];
LL n,K,i,j,k,tmp,cnt;
struct ppt
{
	LL w,id;
	ppt(LL x=0,LL y=0) {w=x,id=y;};
	friend bool operator &lt; (ppt a,ppt b) {return a.w&lt;b.w;}
};
priority_queue&lt;ppt&gt; Q;
void dfs(LL t,LL now)
{
	if (t==5) {b[++b[0]]=now;return;}
	else if (t==4)
	{
		if (now*7&lt;=n) dfs(t,now*7);
		dfs(t+1,now);
	}
	else if (t==3)
	{
		if (now*5&lt;=n) dfs(t,now*5);
		dfs(t+1,now);
	}
	else if (t==2)
	{
		if (now*3&lt;=n) dfs(t,now*3);
		dfs(t+1,now);
	}
	else
	{
		if (now*2&lt;=n) dfs(t,now*2);
		dfs(t+1,now);
	}
}
bool cmp(LL a,LL b) {return a&gt;b;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld%lld&quot;,&amp;n,&amp;K);
	if (!K) {printf(&quot;%d\n&quot;,0);return 0;}
	dfs(1,1);
	sort(b+1,b+b[0]+1);
	map&lt;LL,LL&gt; a;
	for (i=1;i&lt;=b[0];i++) a[b[i]]=i;
	f[0][a[1]]=1;
	for (i=1;i&lt;=12;i++)
		for (j=1;j&lt;=b[0];j++)
			for (k=1;k&lt;=9;k++)
				if (b[j]%k==0) f[i][j]+=f[i-1][a[b[j]/k]];
	tmp=n+1,cnt=0;
	for (;tmp;tmp/=10) c[++cnt]=tmp%10;
	for (i=1;i&lt;=b[0];i++)
	{
		num[i]=0,tmp=b[i];
		for (j=cnt-1;j;j--) num[i]+=f[j][i];
		for (j=cnt;j;j--)
		{
			for (k=1;k&lt;c[j];k++)
				if (tmp%k==0) num[i]+=f[j-1][a[tmp/k]];
			if (c[j]==0||tmp%c[j]) break;
			tmp/=c[j];
		}
	}
	sort(num+1,num+b[0]+1,cmp);
	for (i=1;i&lt;=b[0];i++) now[i]=1,Q.push(ppt(num[i]*num[1],i));
	LL ans=0;
	for (;K;K--)
	{
		ppt tmp=Q.top();
		Q.pop();
		ans=(ans+tmp.w)%mo;
		now[tmp.id]++;
		if (now[tmp.id]&gt;b[0]) continue;
		Q.push(ppt(num[tmp.id]*num[now[tmp.id]],tmp.id));
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem3132</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int NN=2055;
int n,m;
struct Binary_Index_Tree
{
	int c[NN+5][NN+5];
	void change(int i,int j,int x)
	{
		if (i&lt;1||j&lt;1) return;
		int ii=i,jj=j;
		for (i=ii;i&lt;NN;i+=(i&amp;-i))
			for (j=jj;j&lt;NN;j+=(j&amp;-j)) c[i][j]+=x;
	}
	int getsum(int i,int j)
	{
		int res=0,ii=i,jj=j;
		for (i=ii;i;i-=(i&amp;-i))
			for (j=jj;j;j-=(j&amp;-j)) res+=c[i][j];
		return res;
	}
} C1,C2,C3,C4;
void change(int x1,int y1,int x2,int y2,int k)
{
	C1.change(x1,y1,k),C1.change(x1,y2+1,-k);
	C1.change(x2+1,y1,-k),C1.change(x2+1,y2+1,k);
	C2.change(x1,y1,x1*k),C2.change(x1,y2+1,-x1*k);
	C2.change(x2+1,y1,-(x2+1)*k),C2.change(x2+1,y2+1,(x2+1)*k);
	C3.change(x1,y1,y1*k),C3.change(x1,y2+1,-(y2+1)*k);
	C3.change(x2+1,y1,-y1*k),C3.change(x2+1,y2+1,(y2+1)*k);
	C4.change(x1,y1,x1*y1*k),C4.change(x1,y2+1,-x1*(y2+1)*k);
	C4.change(x2+1,y1,-(x2+1)*y1*k),C4.change(x2+1,y2+1,(x2+1)*(y2+1)*k);
}
int getsum(int x,int y)
{
	return (x+1)*(y+1)*C1.getsum(x,y)-(y+1)*C2.getsum(x,y)-(x+1)*C3.getsum(x,y)+C4.getsum(x,y);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	char ch=getchar();
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	int x1,x2,y1,y2,x;
	while (scanf(&quot;%c &quot;,&amp;ch)!=EOF)
	{
		//printf(&quot;ch=%c\n&quot;,ch);
		if (ch=='L')
		{
			scanf(&quot;%d%d%d%d%d\n&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;x);
			change(x1,y1,x2,y2,x);
		}
		else
		{
			scanf(&quot;%d%d%d%d\n&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);
			int res=getsum(x2,y2)-getsum(x1-1,y2)-getsum(x2,y1-1)+getsum(x1-1,y1-1);
			printf(&quot;%d\n&quot;,res);
		}
	}
	return 0;
}<pre><h2>Problem3140</h2><pre>var
  pos:array[1..5000,1..3]of longint;
  a:array[1..2000000,1..2]of longint;
  o,match:array[1..50000]of longint;
  vt,flag,yes:array[1..5000]of boolean;
  num,a0,b0,c0,ans,tt,oo,i,j,k,x,tot,choose,res,time,bc:longint;
procedure init;
begin
  readln(a0,b0,c0);
  bc:=b0+c0;
  num:=0;
  fillchar(yes,sizeof(yes),false);
  for i:=1 to a0 do
    for j:=1 to b0 do
      begin
        for k:=1 to c0 do
          begin
            read(x);
            if x=0 then continue;
            inc(num);
            yes[i]:=true;
            pos[num,1]:=i;
            pos[num,2]:=j;
            pos[num,3]:=k;
          end;
        readln;
      end;
end;
procedure add(p,q:longint);
begin
  inc(tot);
  a[tot,1]:=q;
  a[tot,2]:=o[p];
  o[p]:=tot;
end;
function find(v:longint):boolean;
var p,y:longint;
begin
  vt[v]:=true;
  p:=o[v];
  while p&gt;0 do
    begin
      y:=a[p,1];
      if not vt[y] then
        begin
          vt[y]:=true;
          if(match[y]=0)or(find(match[y]))then
            begin
              match[y]:=v;
              match[v]:=y;
              exit(true);
            end;
        end;
      p:=a[p,2];
    end;
  exit(false);
end;
procedure check;
begin
  if choose&gt;ans then exit;
  tot:=0;
  for i:=1 to bc do o[i]:=0;
  for i:=1 to num do
    if not flag[pos[i,1]] then
      begin
        add(pos[i,2],pos[i,3]+b0);
        add(pos[i,3]+b0,pos[i,2]);
      end;
  for i:=1 to bc do match[i]:=0;
  res:=0;
  for i:=1 to bc do
    if match[i]=0 then
      begin
        for j:=1 to bc do vt[j]:=false;
        if find(i) then inc(res);
      end;
  if ans&gt;res+choose then ans:=res+choose;
  inc(time);
  //writeln(time);
  //for i:=1to a0 do if flag[i]then write(1)else write(0);writeln;
end;
procedure dfs(x:longint);
begin
  if time&gt;38000 then exit;
  if choose&gt;ans then exit;
  if x&gt;a0 then
    begin
      check;
      exit;
    end;
  dfs(x+1);
  if yes[x] then
    begin
      flag[x]:=true;
      inc(choose);
      dfs(x+1);
      flag[x]:=false;
      dec(choose);
    end;
end;
begin
  readln(tt);
  for oo:=1 to tt do
    begin
      init;
      for i:=1 to a0 do flag[i]:=false;
      choose:=0;
      ans:=maxlongint;
      time:=0;
      dfs(1);
      writeln(ans);
    end;
end.<pre><h2>Problem3142</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define LL long long
LL n,K,m,P,x,y;
LL ksm(LL a,LL b)
{
	LL res=1;
	for (;b;b&gt;&gt;=1,a=a*a%P) if (b&amp;1) res=res*a%P;
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld%lld%lld%lld&quot;,&amp;n,&amp;K,&amp;m,&amp;P);
	LL x=n%P*ksm(m,K-1)%P;
	LL y=ksm(m,K-2)*(K-1)%P*((m*(m+1)/2)%P);
	x-=y;
	x%=P;
	if (x&lt;0) x+=P;
	printf(&quot;%lld\n&quot;,x);
	return 0;
}
<pre><h2>Problem3143</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
#define DD double
#define sm 0
int du[510],i,n,m,j,k;
DD tmp,f[510],b[1000000],a[510][510];
struct bian{int a,b;} e[1000000];
DD fabs(DD x) {return x&gt;sm?x:x;}
void swap(DD &amp;a,DD &amp;b) {DD t=a;a=b;b=t;}
bool cmp(DD a,DD b) {return a-b&gt;sm;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;e[i].a,&amp;e[i].b);
		++du[e[i].a],++du[e[i].b];
	}
	memset(a,0,sizeof(a));
	for (i=1;i&lt;=n;i++)
	{
		a[i][i]=1;
		for (j=1;j&lt;=m;j++)
			if (e[j].a==i)
				if (e[j].b==n) continue;
				else a[i][e[j].b]+=-1.0/du[e[j].b];
			else if (e[j].b==i)
				if (e[j].a==n) continue;
				else a[i][e[j].a]+=-1.0/du[e[j].a];
		if (i==1) a[i][n+1]+=1;
	}
	//for (i=1;i&lt;=n;i++){for (j=1;j&lt;=n+1;j++) printf(&quot;%.3f &quot;,a[i][j]);printf(&quot;\n&quot;);}printf(&quot;----------------\n&quot;);
	for (i=1;i&lt;=n-1;i++)
	{
		int mj=i;
		tmp=fabs(a[i][i]);
		for (j=i+1;j&lt;=n;j++)
			if (fabs(a[j][i])-tmp&gt;sm) tmp=fabs(a[j][i]),mj=j;
		for (j=1;j&lt;=n+1;j++) swap(a[i][j],a[mj][j]);
		if (fabs(a[i][i])&lt;sm) continue;
		for (j=i+1;j&lt;=n;j++)
		{
			tmp=a[j][i]/a[i][i];
			for (k=i;k&lt;=n+1;k++)
				a[j][k]=a[i][k]*tmp-a[j][k];
		}
		//for (i=1;i&lt;=n;i++){for (j=1;j&lt;=n+1;j++) printf(&quot;%.3f &quot;,a[i][j]);printf(&quot;\n&quot;);}printf(&quot;----------------\n&quot;);
	}
	//for (i=1;i&lt;=n;i++){for (j=1;j&lt;=n+1;j++) printf(&quot;%.3f &quot;,a[i][j]);printf(&quot;\n&quot;);}printf(&quot;----------------\n&quot;);
	f[n]=a[n][n+1]/a[n][n];
	for (i=n-1;i;i--)
	{
		tmp=0;
		for (j=i+1;j&lt;=n;j++) tmp+=a[i][j]*f[j];
		f[i]=(a[i][n+1]-tmp)/a[i][i];
	}
	//for (i=1;i&lt;=n;i++) printf(&quot;%.3f &quot;,f[i]);printf(&quot;\n&quot;);
	for (i=1;i&lt;=m;i++)
	{
		b[i]=0;
		if (e[i].a!=n) b[i]+=f[e[i].a]/du[e[i].a];
		if (e[i].b!=n) b[i]+=f[e[i].b]/du[e[i].b];
	}
	sort(b+1,b+m+1,cmp);
	//for (i=1;i&lt;=m;i++) printf(&quot;%.3f &quot;,b[i]);printf(&quot;\n&quot;);
	DD ans=0;
	for (i=1;i&lt;=m;i++) ans+=i*b[i];
	printf(&quot;%.3f\n&quot;,ans);
	return 0;
}
<pre><h2>Problem3143</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
typedef double DD;
const DD eps=1e-7;
const int NN=505,MM=101111;
int n,m,du[NN];
DD a[NN][NN],X[NN];
struct edge
{
	int u,v;DD w;
	void in()
	{
		scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
		du[u]++,du[v]++;
	}
	void work()
	{
		if (u!=n) a[v][u]+=1.0/du[u];
		if (v!=n) a[u][v]+=1.0/du[v];
	}
	void calc()
	{
		if (u!=n) w+=X[u]/du[u];
		if (v!=n) w+=X[v]/du[v];
	}
	friend bool operator &lt;(edge a,edge b) {return a.w&gt;b.w;}
} e[MM];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j,k;
	for (i=1;i&lt;=m;i++) e[i].in();
	for (i=1;i&lt;=m;i++) e[i].work();
	for (i=1;i&lt;=n;i++) a[i][i]=-1;
	a[1][n+1]=-1;
	//for(i=1;i&lt;=n;i++){for(j=1;j&lt;=n+1;j++)printf(&quot;%.3f &quot;,a[i][j]);ln;}
	for (i=1;i&lt;n;i++)
	{
		int mj=i;DD tmp=fabs(a[i][i]);
		for (j=i+1;j&lt;=n;j++)
			if (fabs(a[j][i])&gt;tmp) tmp=fabs(a[j][i]),mj=j;
		if (mj!=i) for (j=i;j&lt;=n+1;j++) swap(a[i][j],a[mj][j]);
		if (tmp&lt;eps) continue;
		for (j=i+1;j&lt;=n;j++)
		{
			tmp=a[j][i]/a[i][i];
			for (k=i;k&lt;=n+1;k++) a[j][k]-=tmp*a[i][k];
		}
	}
	X[n]=a[n][n+1]/a[n][n];
	for (i=n-1;i;i--)
	{
		DD tmp=0;
		for (j=i+1;j&lt;=n;j++) tmp+=a[i][j]*X[j];
		X[i]=(a[i][n+1]-tmp)/a[i][i];
	}
	for (i=1;i&lt;=m;i++) e[i].calc();
	sort(e+1,e+m+1);
	DD ans=0;
	for (i=1;i&lt;=m;i++) ans+=e[i].w*i;
	printf(&quot;%.3f\n&quot;,ans);
	return 0;
}<pre><h2>Problem3144</h2><pre>#include &lt;cstdio&gt;
using namespace std;
const int maxn=45,maxtot=100000,maxm=maxtot*10,inf=999999999;
int sign[maxn][maxn][maxn],a[maxm],next[maxm],last[maxtot],f[maxm],d[maxtot],point[maxtot],mm;
int h,l,r,q[maxtot],s,t,dist,tot;
void build(int x,int y,int ff)
{
    a[++mm]=y;
    next[mm]=point[x];
    point[x]=mm;
    f[mm]=ff;
    a[++mm]=x;
    next[mm]=point[y];
    point[y]=mm;
}
bool bfs()
{
    int head=0,tail=1;
    for (int i=1;i&lt;=tot;i++) last[i]=point[i],d[i]=-1;
    q[1]=s,d[s]=0;
    int x,j;
    while (head&lt;tail)
    {
        x=q[++head];
        for (j=last[x];j;j=next[j]) if (f[j]&amp;&amp;d[a[j]]==-1) d[a[j]]=d[x]+1,q[++tail]=a[j];
    }
    return (d[t]!=-1);
}
int min(int x,int y)
{
    return (x&lt;y?x:y);
}
int find(int now,int flow)
{
    if (now==t) return flow;
    int dd=d[now],j,have=0,k;
    for (j=last[now];j;j=next[j]) if (f[j]&amp;&amp;d[a[j]]==dd+1)
    {
        k=find(a[j],min(flow,f[j]));
        flow-=k;
        have+=k;
        f[j]-=k;
        f[j^1]+=k;
        if (!flow) return have;
    }
    if (!have) d[now]=-1;
    return have;
}
int main()
{
    int x,y,z,i,j,k;
    scanf(&quot;%d %d %d&quot;,&amp;h,&amp;l,&amp;r);
    scanf(&quot;%d&quot;,&amp;dist);
    mm=1;
    for (i=1;i&lt;=r+1;i++)
        for (j=1;j&lt;=h;j++) for (k=1;k&lt;=l;k++) sign[i][j][k]=++tot;
    s=tot+1,t=s+1,tot+=2;
    for (i=1;i&lt;=r+1;i++) for (j=1;j&lt;=h;j++) for (k=1;k&lt;=l;k++)
    {
        if (i&lt;=r) scanf(&quot;%d&quot;,&amp;x);
        y=sign[i][j][k];
        if (i&lt;=r) build(y,sign[i+1][j][k],x);
        if (i&gt;dist&amp;&amp;i&lt;=r)
        {
            if (j&lt;h) build(y,sign[i-dist][j+1][k],inf);
            if (j&gt;1) build(y,sign[i-dist][j-1][k],inf);
            if (k&lt;l) build(y,sign[i-dist][j][k+1],inf);
            if (k&gt;1) build(y,sign[i-dist][j][k-1],inf);
        }
        if (i==1) build(s,y,inf);
        if (i==r+1) build(y,t,inf);
    }
    int tmp,ans=0;
    while(bfs()) for (tmp=find(s,inf);tmp;tmp=find(s,inf)) ans+=tmp;
    printf(&quot;%d\n&quot;,ans);
    return 0;
}<pre><h2>Problem3144</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf=99999999;
int aa[1500000][3],o[200000],deep[200000],hao[50][50][50],V[50][50][50],q[1000000];
int R,P,Q,D,tot,S,T,head,tail,i,j,k,num,ans;
int min(int a,int b) {return a&lt;b?a:b;}
void add(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void addedge(int p,int q,int v)
{
	add(p,q,v);
	add(q,p,0);
}
void init()
{
	scanf(&quot;%d%d%d&quot;,&amp;P,&amp;Q,&amp;R);
	scanf(&quot;%d&quot;,&amp;D);
	for (i=1;i&lt;=R;i++)
		for (j=1;j&lt;=P;j++)
			for (k=1;k&lt;=Q;k++)
			{
				hao[i][j][k]=++num;
				scanf(&quot;%d&quot;,&amp;V[i][j][k]);
			}
	S=++num,T=++num;
	tot=1;
	for (i=1;i&lt;=R;i++)
		for (j=1;j&lt;=P;j++)
			for (k=1;k&lt;=Q;k++)
			{
				if (i==R) addedge(hao[i][j][k],T,V[i][j][k]);
				else addedge(hao[i][j][k],hao[i+1][j][k],V[i][j][k]);
				if (i==1) addedge(S,hao[i][j][k],inf);
				if (i&gt;D)
				{
					addedge(hao[i][j][k],hao[i-D][j+1][k],inf);
					addedge(hao[i][j][k],hao[i-D][j-1][k],inf);
					addedge(hao[i][j][k],hao[i-D][j][k-1],inf);
					addedge(hao[i][j][k],hao[i-D][j][k+1],inf);
				}
			}
}
void bfs()
{
	head=tail=0;
	memset(deep,0,sizeof(deep[0])*(T+10));
	deep[S]=1;
	q[++tail]=S;
	while (head&lt;tail)
	{
		int x=q[++head];
		int p=o[x];
		while (p)
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y])
			{
				deep[y]=deep[x]+1;
				q[++tail]=y;
			}
			p=aa[p][0];
		}
	}
}
int dfs(int v,int flow)
{
	if (v==T) return flow;
	int res=0,p=o[v];
	while (p)
	{
		int y=aa[p][1];
		if (aa[p][2]&amp;&amp;deep[y]==deep[v]+1)
		{
			int tmp=dfs(y,min(flow,aa[p][2]));
			if (tmp==0) deep[y]=inf;
			flow-=tmp;
			aa[p][2]-=tmp;
			aa[p^1][2]+=tmp;
			res+=tmp;
			if (!flow) break;
		}
		p=aa[p][0];
	}
	return res;
}
void doit()
{
	bfs();
	while (deep[T]) ans+=dfs(S,inf),bfs();
	printf(&quot;%d\n&quot;,ans);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	init();
	doit();
	return 0;
}
<pre><h2>Problem3150</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
using namespace std;
#define DD double
const DD eps=1e-9;
int n,m;
DD f[111],win[111][111],a[111][111];
void swap(DD &amp;a,DD &amp;b) {DD t=a;a=b;b=t;}
void gaosi()
{
	int i,j,k,mj;
	DD tmp;
	for (tmp=1.0/(n-1),i=1;i&lt;=n-1;i++)
	{
		a[i][i]=1;
		for (j=1;j&lt;=n;j++)
			if (i!=j)
			{
				a[i][i]-=tmp*win[i][j];
				a[i][j]-=tmp*win[i][j];
			}
	}
	for (i=1;i&lt;=n+1;i++) a[n][i]=1;
	for (i=1;i&lt;n;i++)
	{
		tmp=fabs(a[i][i]),mj=i;
		for (j=i+1;j&lt;=n;j++)
			if (fabs(a[j][i])-tmp&gt;eps) tmp=fabs(a[j][i]),mj=j;
		for (j=i;j&lt;=n+1;j++) swap(a[i][j],a[mj][j]);
		if (tmp&lt;eps) continue;
		for (j=i+1;j&lt;=n;j++)
		{
			if (fabs(a[i][i])&lt;eps) continue;
			tmp=a[j][i]/a[i][i];
			for (k=i;k&lt;=n+1;k++) a[j][k]=a[i][k]*tmp-a[j][k];
		}
	}
	f[n]=a[n][n+1]/a[n][n];
	for (i=n-1;i;i--)
	{
		tmp=0;
		for (j=i+1;j&lt;=n;j++) tmp+=a[i][j]*f[j];
		f[i]=(a[i][n+1]-tmp)/a[i][i];
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++) scanf(&quot;%lf&quot;,&amp;win[i][j]);
	gaosi();
	for (i=1;i&lt;=m;i++)
	{
		DD ans=0;
		for (j=1;j&lt;=n;j++)
		{
			char ch='2';
			while (ch!='1'&amp;&amp;ch!='0') ch=getchar();
			if (ch=='1') ans+=f[j];
		}
		printf(&quot;%.8f\n&quot;,ans);
	}
	return 0;
}
<pre><h2>Problem3156</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const int NN=1000111;
int que[NN],a[NN];
int n;
LL f[NN],g[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar());
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);
	int i;
	for (i=1;i&lt;=n;i++) read(a[i]); 
	int head=0,tail=1;
	que[1]=0;
	for (i=1;i&lt;=n;i++)
	{
		//printf(&quot;\n--------------------------------------------------------------\n&quot;);
		int j=que[head+1],k=que[head+2];
		while (head&lt;tail-1&amp;&amp;g[k]-g[j]&lt;=2ll*i*(k-j))
		{
			head++;
			j=k,k=que[head+2];
		}
		f[i]=a[i]+f[j]+(LL)(i-j)*(i-j-1)/2;
		//printf(&quot;%d -&gt; %d\n&quot;,j,i);printf(&quot;f[%d]=%I64d\n&quot;,i,f[i]);
		g[i]=2*f[i]+(LL)i*i+i;
		j=que[tail-1],k=que[tail];
		while (head&lt;tail-1&amp;&amp;(g[i]-g[k])*(k-j)&lt;=(g[k]-g[j])*(i-k))
		{
			tail--;
			k=j,j=que[tail-1];
		}
		que[++tail]=i;
	}
	printf(&quot;%lld\n&quot;,f[n]);
	return 0;
}<pre><h2>Problem3156</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const int NN=1000111;
int que[NN],a[NN];
int n;
LL f[NN],g[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar());
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
}
int main()
{
	read(n);
	int i;
	for (i=1;i&lt;=n;i++) read(a[i]); 
	int head=0,tail=1;
	que[1]=0;
	for (i=1;i&lt;=n;i++)
	{
		int j=que[head+1],k=que[head+2];
		while (head&lt;tail-1&amp;&amp;g[k]-g[j]&lt;=2ll*i*(k-j))
		{
			head++;
			j=k,k=que[head+2];
		}
		f[i]=a[i]+f[j]+(LL)(i-j)*(i-j-1)/2;
		g[i]=2*f[i]+(LL)i*i+i;
		j=que[tail-1],k=que[tail];
		while (head&lt;tail-1&amp;&amp;(g[i]-g[k])*(k-j)&lt;=(g[k]-g[j])*(i-k))
		{
			tail--;
			k=j,j=que[tail-1];
		}
		que[++tail]=i;
	}
	printf(&quot;%lld\n&quot;,f[n]);
	return 0;
}<pre><h2>Problem3160</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
typedef long long LL;
#define mod 1000000007
#define ln printf(&quot;\n&quot;)
const DD pai=3.14159265358979;
const int NN=401111;
int n;
struct cp
{
	DD r,i;
	cp(DD a=0,DD b=0) {r=a;i=b;}
	friend cp operator +(cp a,cp b) {return cp(a.r+b.r,a.i+b.i);}
	friend cp operator -(cp a,cp b) {return cp(a.r-b.r,a.i-b.i);}
	friend cp operator *(cp a,cp b) {return cp(a.r*b.r-a.i*b.i,a.r*b.i+b.r*a.i);}
};
void fft(cp *a,int f,int N,int *rev)
{
	int i,j,k,p;
	for (i=0;i&lt;N;i++)
		if (i&lt;rev[i]) swap(a[i],a[rev[i]]);
	for (i=1;i&lt;N;i&lt;&lt;=1)
	{
		cp wn(cos(pai/i),f*sin(pai/i));
		for (p=i&lt;&lt;1,j=0;j&lt;N;j+=p)
		{
			cp w(1,0);
			for (k=0;k&lt;i;k++,w=w*wn)
			{
				cp x=a[j+k],y=w*a[j+k+i];
				a[j+k]=x+y,a[j+k+i]=x-y;
			}
		}
	}
	if (f==-1) for (i=0;i&lt;N;i++) a[i].r/=N;
}
void fang(int *ans,int n)
{
	static cp a[NN],b[NN];
	static int rev[NN];
	int i,N,L=0;
	n=n+n-1;
	for (N=1;N&lt;n;N&lt;&lt;=1) L++;
	for (i=0;i&lt;N;i++) a[i].r=a[i].i=b[i].r=b[i].i=0;
	for (i=0;i&lt;n;i++) a[i].r=b[i].r=ans[i];
	memset(rev,0,sizeof(rev));
	for (i=0;i&lt;N;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(L-1));
	fft(a,1,N,rev);
	fft(b,1,N,rev);
	for (i=0;i&lt;N;i++) a[i]=a[i]*b[i];
	fft(a,-1,N,rev);
	for (i=0;i&lt;n;i++) ans[i]=(int)(a[i].r+0.5);
}
int manacher(char *ss,int n)
{
	static char s[NN];
	static int p[NN];
	int i;
	s[0]='@';
	for (i=1;i&lt;=n;i++)
	{
		s[i*2-1]='#';
		s[i*2]=ss[i];
	}
	s[n*2+1]='#';
	int id=0,right=0,res=0;
	for (i=1;i&lt;=n*2;i++)
	{
		if (right&gt;i) p[i]=min(p[id*2-i],right-i);
		else p[i]=1;
		while (s[i+p[i]]==s[i-p[i]]) p[i]++;
		if (i+p[i]&gt;right) right=i+p[i],id=i;
		if (i&amp;1) res+=(p[i]-1)&gt;&gt;1;
		else res+=p[i]&gt;&gt;1;
		if (res&gt;mod) res-=mod;
	}
	return res;
}
inline int ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (a%=c;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	static char s[NN];
	static int a1[NN],a2[NN];
	scanf(&quot;%s&quot;,s+1);
	int i;
	n=strlen(s+1);
	for (i=1;i&lt;=n;i++) a1[i-1]=(s[i]=='a');
	fang(a1,n);
	for (i=1;i&lt;=n;i++) a2[i-1]=(s[i]=='b');
	fang(a2,n);
	//for (i=0;i&lt;n+n-1;i++) printf(&quot;%d &quot;,a2[i]);ln;
	int ans=0;
	for (i=0;i&lt;n+n-1;i++)
	{
		int t=(a1[i]+a2[i])&gt;&gt;1;
		if (i%2==0) t++;
		ans=(ans+ksm(2,t,mod)-1)%mod;
	}
	ans-=manacher(s,n);
	ans%=mod;if (ans&lt;0) ans+=mod;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3162</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define mo 1000000007
#define ln printf(&quot;\n&quot;)
const int NN=501111;
int o[NN],aa[NN&lt;&lt;1][2],que[NN],size[NN],fa[NN];
int n,tot=1;
LL inv[NN],f[NN],g[NN],h1[NN],h2[NN];
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9')
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar();
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (a%=c;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
void shai()
{
	static LL a[NN],b[NN];
	int i;
	a[0]=1;
	for (i=1;i&lt;=n;i++) a[i]=a[i-1]*i%mo;
	b[n+1]=1;
	for (i=n;i&gt;0;i--) b[i]=b[i+1]*i%mo;
	LL tmp=ksm(a[n],mo-2,mo);
	for (i=1;i&lt;=n;i++)
		inv[i]=a[i-1]*b[i+1]%mo*tmp%mo;
}
void bfs(int v)
{
	int head=0,tail=1;
	que[1]=v;
	while (head&lt;tail)
	{
		int x=que[++head];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[x]) continue;
			fa[y]=x;
			que[++tail]=y;
		}
	}
}
int getcore(int v)
{
	for (;;)
	{
		bool flag=false;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (size[y]&lt;&lt;1&gt;size[v])
			{
				size[v]-=size[y];
				size[y]+=size[v];
				v=y;flag=true;break;
			}
		}
		if (!flag) break;
	}
	return v;
}
LL C(LL n,int m)
{
	LL res=1;
	for (int i=1;i&lt;=m;i++)
		res=res*(n-i+1)%mo*inv[i]%mo;
	return res;
}
bool cmp(const int &amp;a,const int &amp;b)
{
	if (h1[a]!=h1[b]) return h1[a]&lt;h1[b];
	return h2[a]&lt;h2[b];
}
void DP(int n)
{
	for (int tt=n;tt;tt--)
	{
		int v=que[tt],cnt=0;
		static int b[NN];
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[v]) continue;
			b[++cnt]=y;
		}
		sort(b+1,b+cnt+1,cmp);
		//printf(&quot;\n--------------------- v=%d ------------------------\n&quot;,v);printf(&quot;b &quot;);out(b,1,cnt);
		h1[v]=23333333;
		h2[v]=19980723;
		int i,l,r;
		for (i=1;i&lt;=cnt;i++)
		{
			int t=h1[b[i]];
			h1[v]=(h1[v]*1000000009+t)^t;
			h1[v]=(h1[v]+t)*1551;
			h2[v]=(h2[v]^t)*598712371+t;
			h2[v]=(h2[v]*t)*46127-19;
		}
		f[v]=g[v]=1;
		for (l=1;l&lt;=cnt;l=r+1)
		{
			r=l;
			while (r&lt;=cnt&amp;&amp;h1[b[r]]==h1[b[l]]&amp;&amp;h2[b[r]]==h2[b[l]]) r++;
			r--;
			//printf(&quot;%d %d\n&quot;,l,r);
			int x=b[l];
			g[v]=g[v]*C(r-l+1+f[x]+g[x]-1,r-l+1)%mo;
			f[v]=f[v]*C(r-l+1+g[x]-1,r-l+1)%mo;
		}
	}
	//printf(&quot;h1 &quot;);for(int i=1;i&lt;=n;i++)printf(&quot;%I64d &quot;,h1[i]);ln;printf(&quot;h2 &quot;);for(int i=1;i&lt;=n;i++)printf(&quot;%I64d &quot;,h2[i]);ln;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);
	shai();
	int i,x,y;
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y);
		addedge(x,y),addedge(y,x);
	}
	bfs(1);
	for (i=n;i;i--)
	{
		int x=que[i];
		size[x]=1;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[x]) continue;
			size[x]+=size[y];
		}
	}
	int t=getcore(1);
	LL ans=0;
	bool flag=false;
	for (int p=o[t];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (size[y]&lt;&lt;1==size[t])
		{
			flag=true;
			aa[p][1]=aa[p^1][1]=n+1;
			addedge(n+1,t),addedge(n+1,y);
			fa[n+1]=0,bfs(n+1);
			DP(n+1);
			if (h1[t]==h1[y]&amp;&amp;h2[t]==h2[y])
				ans=(f[t]*g[y]%mo+C(g[t],2)+g[t])%mo;
			else ans=(f[t]*g[y]%mo+f[y]*g[t]%mo+g[y]*g[t]%mo)%mo;
			break;
		}
	}
	if (!flag)
	{
		fa[t]=0,bfs(t);
		//printf(&quot;que &quot;);for(i=1;i&lt;=n;i++) printf(&quot;%d &quot;,que[i]);ln;
		DP(n);
		ans=(f[t]+g[t])%mo;
	}
	//ln;ln;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem3162</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define mo 1000000007
const int NN=501111;
int o[NN],aa[NN&lt;&lt;1][2],que[NN],size[NN],fa[NN];
int n,tot=1;
LL inv[NN],f[NN],g[NN],h1[NN],h2[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9')
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar();
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (a%=c;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
void shai()
{
	static LL a[NN],b[NN];
	int i;
	a[0]=1;
	for (i=1;i&lt;=n;i++) a[i]=a[i-1]*i%mo;
	b[n+1]=1;
	for (i=n;i&gt;0;i--) b[i]=b[i+1]*i%mo;
	LL tmp=ksm(a[n],mo-2,mo);
	for (i=1;i&lt;=n;i++)
		inv[i]=a[i-1]*b[i+1]%mo*tmp%mo;
}
void bfs(int v)
{
	int head=0,tail=1;
	que[1]=v;
	while (head&lt;tail)
	{
		int x=que[++head];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[x]) continue;
			fa[y]=x;
			que[++tail]=y;
		}
	}
}
int getcore(int v)
{
	for (;;)
	{
		bool flag=false;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (size[y]&lt;&lt;1&gt;size[v])
			{
				size[v]-=size[y];
				size[y]+=size[v];
				v=y;flag=true;break;
			}
		}
		if (!flag) break;
	}
	return v;
}
LL C(LL n,int m)
{
	LL res=1;
	for (int i=1;i&lt;=m;i++)
		res=res*(n-i+1)%mo*inv[i]%mo;
	return res;
}
bool cmp(const int &amp;a,const int &amp;b)
{
	if (h1[a]!=h1[b]) return h1[a]&lt;h1[b];
	return h2[a]&lt;h2[b];
}
void DP(int n)
{
	for (int tt=n;tt;tt--)
	{
		int v=que[tt],cnt=0;
		static int b[NN];
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[v]) continue;
			b[++cnt]=y;
		}
		sort(b+1,b+cnt+1,cmp);
		h1[v]=23333333;
		h2[v]=19980723;
		int i,l,r;
		for (i=1;i&lt;=cnt;i++)
		{
			int t=h1[b[i]];
			h1[v]=(h1[v]*1000000009+t)^t;
			h1[v]=(h1[v]+t)*1551;
			h2[v]=(h2[v]^t)*598712371+t;
			h2[v]=(h2[v]*t)*46127-19;
		}
		f[v]=g[v]=1;
		for (l=1;l&lt;=cnt;l=r+1)
		{
			r=l;
			while (r&lt;=cnt&amp;&amp;h1[b[r]]==h1[b[l]]&amp;&amp;h2[b[r]]==h2[b[l]]) r++;
			r--;
			int x=b[l];
			g[v]=g[v]*C(r-l+1+f[x]+g[x]-1,r-l+1)%mo;
			f[v]=f[v]*C(r-l+1+g[x]-1,r-l+1)%mo;
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);
	shai();
	int i,x,y;
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y);
		addedge(x,y),addedge(y,x);
	}
	bfs(1);
	for (i=n;i;i--)
	{
		int x=que[i];
		size[x]=1;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[x]) continue;
			size[x]+=size[y];
		}
	}
	int t=getcore(1);
	LL ans=0;
	bool flag=false;
	for (int p=o[t];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (size[y]&lt;&lt;1==size[t])
		{
			flag=true;
			aa[p][1]=aa[p^1][1]=n+1;
			addedge(n+1,t),addedge(n+1,y);
			fa[n+1]=0,bfs(n+1);
			DP(n+1);
			if (h1[t]==h1[y]&amp;&amp;h2[t]==h2[y])
				ans=(f[t]*g[y]%mo+C(g[t],2)+g[t])%mo;
			else ans=(f[t]*g[y]%mo+f[y]*g[t]%mo+g[y]*g[t]%mo)%mo;
			break;
		}
	}
	if (!flag)
	{
		fa[t]=0,bfs(t);
		DP(n);
		ans=(f[t]+g[t])%mo;
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem3168</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define mo 999911657
#define ln printf(&quot;\n&quot;)
const int NN=305;
int o[NN&lt;&lt;1],aa[NN*NN*2][2],vt[NN&lt;&lt;1],match[NN&lt;&lt;1];
int n,tot,TIME;
inline void addedge(int p,int q)
{
    tot++;
    aa[tot][1]=q;
    aa[tot][0]=o[p];
    o[p]=tot;
}
struct matrix
{
    LL qq[NN][NN];
    matrix() {memset(qq,0,sizeof(qq));}
    LL * operator [](int x) {return qq[x];}
    void in()
    {
        for (int i=1;i&lt;=n;i++)
            for (int j=1;j&lt;=n;j++)
                scanf(&quot;%lld&quot;,&amp;qq[i][j]);
    }
    friend matrix operator *(matrix a,matrix b)
    {
        matrix c;
        for (int k=1;k&lt;=n;k++)
            for (int i=1;i&lt;=n;i++)
                for (int j=1;j&lt;=n;j++)
                    (c[i][j]+=a[i][k]*b[k][j])%=mo;
        return c;
    }
} A,B,C;
LL ksm(LL a,LL b,LL c)
{
    LL res=1;
    for (;b;b&gt;&gt;=1,a=a*a%c)
        if (b&amp;1) res=res*a%c;
    return res;
}
matrix getinv(matrix a)
{
    matrix res;
    int i,j,k;
    for (i=1;i&lt;=n;i++) res[i][i]=1;
    for (i=1;i&lt;n;i++)
    {
        for (j=i;j&lt;=n;j++)
            if (a[j][i]) break;
        if (i!=j)
            for (k=1;k&lt;=n;k++)
            {
                swap(a[i][k],a[j][k]);
                swap(res[i][k],res[j][k]);
            }
        LL inv=ksm(a[i][i],mo-2,mo);
        for (j=i+1;j&lt;=n;j++)
        {
            LL tmp=a[j][i]*inv%mo;
            for (k=1;k&lt;=n;k++)
            {
                (a[j][k]-=a[i][k]*tmp)%=mo;
                (res[j][k]-=res[i][k]*tmp)%=mo;
            }
        }
    }
    for (i=1;i&lt;=n;i++)
    {
        LL inv=ksm(a[i][i],mo-2,mo);
        for (j=1;j&lt;=n;j++)
        {
            (a[i][j]*=inv)%=mo;
            (res[i][j]*=inv)%=mo;
        }
    }
    for (i=n;i;i--)
        for (j=n;j&gt;i;j--)
        {
            LL tmp=a[i][j];
            for (k=1;k&lt;=n;k++)
            {
                (a[i][k]-=a[j][k]*tmp)%=mo;
                (res[i][k]-=res[j][k]*tmp)%=mo;
            }
        }
    return res;
}
bool dfs(int v,int tt)
{
    //printf(&quot;dfs %d %d\n&quot;,v,tt);
    if (v&lt;tt) return false;
    vt[v]=TIME;
    for (int p=o[v];p;p=aa[p][0])
    {
        int y=aa[p][1];
        if (vt[y]==TIME) continue;
        vt[y]=TIME;
        if (!match[y]||dfs(match[y],tt))
        {
            match[v]=y,match[y]=v;
            return true;
        }
    }
    return false;
}
int main()
{
   //、、 freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d&quot;,&amp;n);
    A.in(),B.in();
    C=B*getinv(A);
    int i,j;
    //for(i=1;i&lt;=n;i++){for(j=1;j&lt;=n;j++)printf(&quot;%d &quot;,C[j][i]?1:0);ln;}ln;
    for (i=1;i&lt;=n;i++) for (j=1;j&lt;=n;j++)
        if (C[j][i]!=0)
        {
            addedge(i,j+n);
            addedge(j+n,i);
        }
    int ans=0;
    for (i=1;i&lt;=n&lt;&lt;1;i++) if (!match[i])
    {
        TIME++;
        if (dfs(i,0)) ans++;
    }
    if (ans&lt;n) {printf(&quot;NIE\n&quot;);return 0;}
    printf(&quot;TAK\n&quot;);
    //printf(&quot;match &quot;);for(i=1;i&lt;=n&lt;&lt;1;i++) printf(&quot;%d &quot;,match[i]);ln;ln;
    for (i=1;i&lt;=n;i++)
    {
        //printf(&quot;\n---------------------------------------------------------\n&quot;);
        static int b[NN];
        int cnt=0;
        for (int p=o[i];p;p=aa[p][0])
        {
            int y=aa[p][1];
            b[++cnt]=y;
        }
        sort(b+1,b+cnt+1);
        //printf(&quot;b &quot;);for(j=1;j&lt;=cnt;j++)printf(&quot;%d &quot;,b[j]);ln;
        int tmp=match[i];
        match[tmp]=0;
        for (j=1;j&lt;=cnt;j++)
        {
            int x=b[j];
            if (x==tmp) {match[x]=i;break;}
            int y=match[x];
            if (y&lt;i) continue;
            TIME++;
            vt[i]=vt[x]=TIME;
            if (dfs(y,i))
            {
                match[i]=x,match[x]=i;
                break;
            }
        }
    }
    for (i=1;i&lt;=n;i++) printf(&quot;%d\n&quot;,match[i]-n);
    return 0;
}<pre><h2>Problem3170</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int NN=101111;
int b[NN];
int n;
LL sum1[NN],sum2[NN];
struct ppt
{
	int x,y;
	void in()
	{
		int xx,yy;
		scanf(&quot;%d%d&quot;,&amp;xx,&amp;yy);
		x=xx+yy,y=xx-yy;
	}
	friend bool operator &lt;(ppt a,ppt b) {return a.x&lt;b.x;}
} q[NN];
int cha(int x)
{
	int l=1,r=n;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (b[mid]==x) return mid;
		if (b[mid]&gt;x) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i;
	for (i=1;i&lt;=n;i++) q[i].in(),b[i]=q[i].y;
	sort(q+1,q+n+1);
	for (i=1;i&lt;=n;i++) sum1[i]=sum1[i-1]+q[i].x;
	sort(b+1,b+n+1);
	for (i=1;i&lt;=n;i++) sum2[i]=sum2[i-1]+b[i];
	LL ans=(LL)1e18;
	for (i=1;i&lt;=n;i++)
	{
		LL tmp=(LL)q[i].x*(i-1)-sum1[i-1]-(LL)q[i].x*(n-i)+sum1[n]-sum1[i];
		int k=cha(q[i].y);
		tmp+=(LL)q[i].y*(k-1)-sum2[k-1]-(LL)q[i].y*(n-k)+sum2[n]-sum2[k];
		if (tmp&lt;ans) ans=tmp;
	}
	printf(&quot;%lld\n&quot;,ans&gt;&gt;1);
	return 0;
}<pre><h2>Problem3171</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf=99999999,dx[4]={-1,0,0,1},dy[4]={0,1,-1,0};
int aa[1000000][4],q[1000000],o[100000],dist[100000],a[1000][1000],pre[100000];
bool dl[100000];
int n,m,i,j,t,head,tail,S,T,tot,ans;
char ch;
int min(int a,int b) {return a&lt;b?a:b;}
void add(int p,int q,int v,int cost)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][3]=cost;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void addedge(int p,int q,int v,int cost)
{
	//printf(&quot;addedge:  %d %d %d %d\n&quot;,p,q,v,cost);
	add(p,q,v,cost);
	add(q,p,0,-cost);
}
void init()
{
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;i++,scanf(&quot;\n&quot;))
		for (j=1;j&lt;=m;j++)
		{
			scanf(&quot;%c&quot;,&amp;ch);
			if (ch=='U') a[i][j]=0;
			else if (ch=='R') a[i][j]=1;
			else if (ch=='L') a[i][j]=2;
			else a[i][j]=3;
		}
	//for (i=1;i&lt;=n;i++) {for (j=1;j&lt;=m;j++) printf(&quot;%d &quot;,a[i][j]);printf(&quot;\n&quot;);};
	S=n*m*2+1,T=S+1;
	tot=1;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			addedge(S,(i-1)*m+j+n*m,1,0);
			addedge((i-1)*m+j,T,1,0);
		}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
			for (t=0;t&lt;=3;t++)
			{
				int x=i+dx[t],y=j+dy[t];
				if (x&lt;1) x=n;
				if (x&gt;n) x=1;
				if (y&lt;1) y=m;
				if (y&gt;m) y=1;
				if (t==a[i][j]) addedge((i-1)*m+j+n*m,(x-1)*m+y,1,0);
				else addedge((i-1)*m+j+n*m,(x-1)*m+y,1,1);
			}
}
bool relax(int x,int y,int v)
{
	if (dist[y]&gt;dist[x]+v)
	{
		dist[y]=dist[x]+v;
		return 1;
	}
	return 0;
}
bool spfa()
{
	head=tail=0;
	memset(dist,127,sizeof(dist[0])*(T+10));
	memset(dl,0,sizeof(dl[0])*(T+10));
	dist[S]=1;
	q[++tail]=S;
	dl[S]=1;
	while (head&lt;tail)
	{
		int x=q[++head];
		dl[x]=0;
		int p=o[x];
		while (p)
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;relax(x,y,aa[p][3]))
			{
				pre[y]=p;
				if (!dl[y])
				{
					q[++tail]=y;
					dl[y]=1;
				}
			}
			p=aa[p][0];
		}
	}
	return dist[T]&lt;dist[0];
}
void addcost()
{
	int p=pre[T],flow=inf;
	while (p)
	{
		flow=min(flow,aa[p][2]);
		p=pre[aa[p^1][1]];
	}
	p=pre[T];
	while (p)
	{
		ans+=flow*aa[p][3];
		aa[p][2]-=flow;
		aa[p^1][2]+=flow;
		p=pre[aa[p^1][1]];
	}
}
void doit()
{
	for (ans=0;spfa();addcost());
	printf(&quot;%d\n&quot;,ans);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	init();
	doit();
	return 0;
}
<pre><h2>Problem3172</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define ML 3000000
int sum[ML],rank[ML],sa[ML],sa2[ML],f[ML][30],height[ML],s[ML],wv[ML],log[ML],pos[1000],ll[1000];
int n,N;
char ss[ML];
int min(int a,int b) {return a&lt;b?a:b;}
void suffix_array(int *r,int n,int m)
{
	int i,j,p,*x=rank,*y=sa2,*t;
	memset(x,-1,sizeof(x)*(n+100));
	memset(y,-1,sizeof(y)*(n+100));
	for (i=0;i&lt;m;i++) sum[i]=0;
	for (i=0;i&lt;n;i++) sum[x[i]=r[i]]++;
	for (i=1;i&lt;m;i++) sum[i]+=sum[i-1];
	for (i=n-1;i&gt;=0;i--) sa[--sum[x[i]]]=i;
	for (j=p=1;p&lt;n;j&lt;&lt;=1,m=p)
	{
		for (p=0,i=n-j;i&lt;n;i++) y[p++]=i;
		for (i=0;i&lt;n;i++) if (sa[i]&gt;=j) y[p++]=sa[i]-j;
		for (i=0;i&lt;n;i++) wv[i]=x[y[i]];
		for (i=0;i&lt;m;i++) sum[i]=0;
		for (i=0;i&lt;n;i++) sum[wv[i]]++;
		for (i=1;i&lt;m;i++) sum[i]+=sum[i-1];
		for (i=n-1;i&gt;=0;i--) sa[--sum[wv[i]]]=y[i];
		for (t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i&lt;n;i++)
			x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+j]==y[sa[i-1]+j])?p-1:p++;
	}
	for (i=0;i&lt;n;i++) rank[i]=x[i];
	p=0;
	for (i=0;i&lt;n;i++)
		if (x[i]!=0)
		{
			j=sa[x[i]-1];
			while (r[i+p]==r[j+p]) p++;
			height[x[i]]=p;
			if (p) p--;
		}
	//for (i=0;i&lt;n;i++){printf(&quot;%d: &quot;,i);for (j=sa[i];j&lt;n;j++) printf(&quot;%c&quot;,r[j]);printf(&quot;\n&quot;);}
	//printf(&quot;sa: &quot;);for (i=0;i&lt;n;i++) printf(&quot;%d &quot;,sa[i]);printf(&quot;\n&quot;);
	//printf(&quot;\nheight: &quot;);for (i=0;i&lt;n;i++) printf(&quot;%d &quot;,height[i]);printf(&quot;\n&quot;);
	//printf(&quot;x: &quot;);for (i=0;i&lt;n;i++) printf(&quot;%d &quot;,x[i]);printf(&quot;\n&quot;);
}
int getmin(int l,int r)
{
	int len=log[r-l+1];
	return min(f[l][len],f[r-(1&lt;&lt;len)+1][len]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;N);
	if (n==1) {printf(&quot;%d\n&quot;,1);return 0;}
	n=0;
	int i,j;
	for (i=1;i&lt;=N;i++)
	{
		scanf(&quot;%s&quot;,ss);
		s[n++]='@';
		ll[i]=strlen(ss);
		pos[i]=n;
		for (j=0;j&lt;ll[i];j++) s[n++]=ss[j];
	}
	//for (i=0;i&lt;n;i++) printf(&quot;%c&quot;,s[i]);printf(&quot;\n&quot;);
	suffix_array(s,n,256);
	for (i=0;i&lt;n;i++) f[i][0]=height[i];
	for (j=1;j&lt;25;j++)
		for (i=0;i&lt;n;i++)
			if (i+(1&lt;&lt;(j-1))&lt;n)
				f[i][j]=min(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]);
	log[1]=0;
	for (i=2;i&lt;=2500000;i++)
		if (i==(i&amp;-i)) log[i]=log[i-1]+1;
		else log[i]=log[i-1];
	for (i=1;i&lt;=N;i++)
	{
		//printf(&quot;\n----------------------------------------------------------\n&quot;);
		int k=rank[pos[i]];
		if (k==10)
		{
			k++;
			k--;
		}
		//printf(&quot;%d\n&quot;,k);
		int l=1,r=k;
		int left=k,right=k;
		while (l&lt;=r)
		{
			int mid=(l+r)&gt;&gt;1;
			if (getmin(mid,k)&gt;=ll[i]) left=mid-1,r=mid-1;
			else l=mid+1;
		}
		l=k,r=n-1;
		while (l&lt;=r)
		{
			int mid=(l+r)&gt;&gt;1;
			if (getmin(k+1,mid)&gt;=ll[i]) right=mid,l=mid+1;
			else r=mid-1;
		}
		printf(&quot;%d\n&quot;,right-left+1);
	}
	return 0;
}
<pre><h2>Problem3172</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 2100000
int son[NN][27],pre[NN],val[NN],f[NN],pos[NN],s[NN],sum[NN],b[NN];
int n,last,cnt,L;
char ss[NN];
void add(int x)
{
	int p=last;
	val[++cnt]=val[p]+1;
	int np=cnt;
	for (;p!=-1&amp;&amp;!son[p][x];p=pre[p]) son[p][x]=np;
	if (p==-1) {pre[p]=0,last=np;return;}
	int q=son[p][x];
	if (val[q]==val[p]+1) pre[np]=q;
	else
	{
		val[++cnt]=val[p]+1;
		int nq=cnt;
		memcpy(son[nq],son[q],sizeof(son[q]));
		pre[nq]=pre[q];
		pre[q]=pre[np]=nq;
		for (;p!=-1&amp;&amp;son[p][x]==q;p=pre[p]) son[p][x]=nq;
	}
	last=np;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d\n&quot;,&amp;n);
	int i,j,x;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s&quot;,ss+1);
		int len=strlen(ss+1);
		for (j=1;j&lt;=len;j++) s[++L]=ss[j]-'a';
		pos[i]=L;
		s[++L]=26;
	}
	pre[0]=-1;
	for (i=1;i&lt;=L;i++) add(s[i]);
	for (i=1;i&lt;=cnt;i++) sum[val[i]]++;
	for (i=2;i&lt;=L;i++) sum[i]+=sum[i-1];
	for (i=cnt;i;i--) b[sum[val[i]]--]=i;
	for (x=0,i=1;i&lt;=L;x=son[x][s[i]],i++) f[x]=1;
	for (i=cnt;i;i--) f[pre[b[i]]]+=f[b[i]];
	pos[0]=-1;
	for (i=1;i&lt;=n;i++)
	{
		x=0;
		for (j=pos[i-1]+2;j&lt;=pos[i];j++) x=son[x][s[j]];
		printf(&quot;%d\n&quot;,f[x]);
	}
	//freopen(&quot;CON&quot;,&quot;r&quot;,stdin);getchar();
	return 0;
}<pre><h2>Problem3172</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 2100000
int son[NN][27],pre[NN],val[NN],f[NN],pos[NN],s[NN],sum[NN],b[NN];
int n,last,cnt,L;
char ss[NN];
void add(int x)
{
	int p=last;
	val[++cnt]=val[p]+1;
	int np=cnt;
	for (;p!=-1&amp;&amp;!son[p][x];p=pre[p]) son[p][x]=np;
	if (p==-1) {pre[np]=0,last=np;return;}
	int q=son[p][x];
	if (val[q]==val[p]+1) pre[np]=q;
	else
	{
		val[++cnt]=val[p]+1;
		int nq=cnt;
		memcpy(son[nq],son[q],sizeof(son[q]));
		pre[nq]=pre[q];
		pre[q]=pre[np]=nq;
		for (;p!=-1&amp;&amp;son[p][x]==q;p=pre[p]) son[p][x]=nq;
	}
	last=np;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d\n&quot;,&amp;n);
	int i,j,x;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s&quot;,ss+1);
		int len=strlen(ss+1);
		for (j=1;j&lt;=len;j++) s[++L]=ss[j]-'a';
		pos[i]=L;
		s[++L]=26;
	}
	pre[0]=-1;
	for (i=1;i&lt;=L;i++) add(s[i]);
	for (i=1;i&lt;=cnt;i++) sum[val[i]]++;
	for (i=2;i&lt;=L;i++) sum[i]+=sum[i-1];
	for (i=cnt;i;i--) b[sum[val[i]]--]=i;
	for (x=0,i=1;i&lt;=L;x=son[x][s[i]],i++) f[x]=1;
	for (i=cnt;i;i--) f[pre[b[i]]]+=f[b[i]];
	pos[0]=-1;
	for (i=1;i&lt;=n;i++)
	{
		x=0;
		for (j=pos[i-1]+2;j&lt;=pos[i];j++) x=son[x][s[j]];
		printf(&quot;%d\n&quot;,f[x]);
	}
	//freopen(&quot;CON&quot;,&quot;r&quot;,stdin);getchar();
	return 0;
}<pre><h2>Problem3172</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 2100000
int son[NN][27],pre[NN],val[NN],f[NN],pos[NN],s[NN],sum[NN],b[NN];
int n,last,cnt,L;
char ss[NN];
void add(int x)
{
	int p=last;
	val[++cnt]=val[p]+1;
	int np=cnt;
	last=np;
	for (;p!=-1&amp;&amp;!son[p][x];p=pre[p]) son[p][x]=np;
	if (p==-1) {pre[np]=0;return;}
	int q=son[p][x];
	if (val[q]==val[p]+1) pre[np]=q;
	else
	{
		val[++cnt]=val[p]+1;
		int nq=cnt;
		memcpy(son[nq],son[q],sizeof(son[q]));
		pre[nq]=pre[q];
		pre[q]=pre[np]=nq;
		for (;p!=-1&amp;&amp;son[p][x]==q;p=pre[p]) son[p][x]=nq;
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d\n&quot;,&amp;n);
	int i,j,x;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s&quot;,ss+1);
		int len=strlen(ss+1);
		for (j=1;j&lt;=len;j++) s[++L]=ss[j]-'a';
		pos[i]=L;
		s[++L]=26;
	}
	pre[0]=-1;
	for (i=1;i&lt;=L;i++) add(s[i]);
	for (i=1;i&lt;=cnt;i++) sum[val[i]]++;
	for (i=2;i&lt;=L;i++) sum[i]+=sum[i-1];
	for (i=cnt;i;i--) b[sum[val[i]]--]=i;
	for (x=0,i=1;i&lt;=L;x=son[x][s[i]],i++) f[x]=1;
	for (i=cnt;i;i--) f[pre[b[i]]]+=f[b[i]];
	pos[0]=-1;
	for (i=1;i&lt;=n;i++)
	{
		x=0;
		for (j=pos[i-1]+2;j&lt;=pos[i];j++) x=son[x][s[j]];
		printf(&quot;%d\n&quot;,f[x]);
	}
	//freopen(&quot;CON&quot;,&quot;r&quot;,stdin);getchar();
	return 0;
}<pre><h2>Problem3172</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int NN=2001111;
int s[NN],pre[NN],val[NN],son[NN][27],f[NN],pos[NN],sum[NN],b[NN];
int n,TTT,L,last;
char ss[NN];
void add(int x)
{
	int p=last,end,nq;
	last=end=++TTT;
	val[end]=val[p]+1;
	for (;p!=-1&amp;&amp;!son[p][x];p=pre[p]) son[p][x]=end;
	if (p==-1) {pre[end]=0;return;}
	int q=son[p][x];
	if (val[q]==val[p]+1) {pre[end]=q;return;}
	nq=++TTT;
	val[nq]=val[p]+1;
	pre[nq]=pre[q];
	memcpy(son[nq],son[q],sizeof(son[q]));
	pre[q]=pre[end]=nq;
	for (;p!=-1&amp;&amp;son[p][x]==q;p=pre[p]) son[p][x]=nq;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d\n&quot;,&amp;n);
	int i,j,x;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s\n&quot;,ss+1);
		pos[i]=L+1;
		int l=strlen(ss+1);
		for (j=1;j&lt;=l;j++) s[++L]=ss[j]-'a';
		s[++L]=26;
	}
	pos[n+1]=L+1;
	pre[0]=-1;
	for (i=1;i&lt;=L;i++) add(s[i]);
	for (i=1;i&lt;=TTT;i++) sum[val[i]]++;
	for (i=1;i&lt;=L;i++) sum[i]+=sum[i-1];
	for (i=TTT;i;i--) b[sum[val[i]]--]=i;
	for (i=1,x=son[0][s[1]];i&lt;=L;i++,x=son[x][s[i]]) f[x]=1;
	for (i=TTT;i;i--) f[pre[b[i]]]+=f[b[i]];
	for (i=1;i&lt;=n;i++)
	{
		for (x=0,j=pos[i];j&lt;pos[i+1]-1;j++) x=son[x][s[j]];
		printf(&quot;%d\n&quot;,f[x]);
	}
	return 0;
}<pre><h2>Problem3172</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=2001111;
int pre[NN],sum[NN],val[NN],son[NN][27],s[NN],f[NN],b[NN],st[NN],ed[NN];
int n,L,TTT,last;
char ss[NN];
void add(int x)
{
	int end=++TTT,p=last;
	last=end;
	val[end]=val[p]+1;
	for (;p!=-1&amp;&amp;!son[p][x];p=pre[p]) son[p][x]=end;
	if (p==-1) {pre[end]=0;return;}
	int q=son[p][x];
	if (val[q]==val[p]+1) {pre[end]=q;return;}
	int nq=++TTT;
	val[nq]=val[p]+1;
	pre[nq]=pre[q];
	pre[q]=pre[end]=nq;
	memcpy(son[nq],son[q],sizeof(son[q]));
	for (;p!=-1&amp;&amp;son[p][x]==q;p=pre[p]) son[p][x]=nq;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d\n&quot;,&amp;n);
	int i,j;
	L=0;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s\n&quot;,ss+1);
		st[i]=L+1;
		int len=strlen(ss+1);
		for (j=1;j&lt;=len;j++) s[++L]=ss[j]-'a';
		ed[i]=L;
		s[++L]=26;
	}
	//for (i=1;i&lt;=L;i++) printf(&quot;%d &quot;,s[i]);ln;
	pre[0]=-1;
	for (i=1;i&lt;=L;i++) add(s[i]);
	for (i=0;i&lt;=L;i++) sum[i]=0;
	for (i=1;i&lt;=TTT;i++) sum[val[i]]++;
	for (i=1;i&lt;=L;i++) sum[i]+=sum[i-1];
	for (i=TTT;i;i--) b[sum[val[i]]--]=i;
	int x=0;
	for (i=1;i&lt;=L;i++) x=son[x][s[i]],f[x]=1;
	for (i=TTT;i;i--) f[pre[b[i]]]+=f[b[i]];
	for (i=1;i&lt;=n;i++)
	{
		x=0;
		for (j=st[i];j&lt;=ed[i];j++) x=son[x][s[j]];
		printf(&quot;%d\n&quot;,f[x]);
	}
	return 0;
}<pre><h2>Problem3172</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int NN=2001111;
int pre[NN],val[NN],son[NN][27],st[NN],ed[NN],right[NN];
int n,cnt,TTT,last;
char s[NN],ss[NN];
void samadd(int x)
{
	int end=++TTT,p=last;
	last=end;
	val[end]=val[p]+1;
	for (;p!=-1&amp;&amp;!son[p][x];p=pre[p]) son[p][x]=end;
	if (p==-1) {pre[end]=0;return;}
	int q=son[p][x];
	if (val[q]==val[p]+1) {pre[end]=q;return;}
	int nq=++TTT;
	val[nq]=val[p]+1;
	pre[nq]=pre[q];
	pre[q]=pre[end]=nq;
	memcpy(son[nq],son[q],sizeof(son[q]));
	for (;p!=-1&amp;&amp;son[p][x]==q;p=pre[p]) son[p][x]=nq;
}
void calcright()
{
	static int sum[NN],b[NN];
	int i;
	for (i=1;i&lt;=cnt;i++) sum[i]=0;
	for (i=1;i&lt;=TTT;i++) sum[val[i]]++;
	for (i=1;i&lt;=cnt;i++) sum[i]+=sum[i-1];
	for (i=TTT;i;i--) b[sum[val[i]]--]=i;
	int x=0;
	for (i=1;i&lt;=cnt;i++)
	{
		x=son[x][s[i]-'a'];
		right[x]=1;
	}
	for (i=TTT;i;i--)
		right[pre[b[i]]]+=right[b[i]];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d\n&quot;,&amp;n);
	pre[0]=-1;
	int i,j;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s\n&quot;,ss+1);
		int len=strlen(ss+1);
		st[i]=cnt+1,ed[i]=cnt+len;
		for (j=1;j&lt;=len;j++)
		{
			s[++cnt]=ss[j];
			samadd(s[cnt]-'a');
		}
		s[++cnt]='z'+1;
		samadd(s[cnt]-'a');
	}
	calcright();
	for (i=1;i&lt;=n;i++)
	{
		int x=0;
		for (j=st[i];j&lt;=ed[i];j++) x=son[x][s[j]-'a'];
		printf(&quot;%d\n&quot;,right[x]);
	}
	return 0;
}<pre><h2>Problem3173</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=101111;
int fa[NN],son[NN][2],size[NN],key[NN],c[NN],a[NN],f[NN],pos[NN];
int n,TTT,root;
inline void update(int t)
{
	size[t]=size[son[t][0]]+size[son[t][1]]+1;
}
inline void rotate(int t,int p)
{
	int y=fa[t];
	if (fa[y])
	{
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	}
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
	if (ff==0) root=t;
}
void ins(int &amp;v,int x,int pos,int ff)
{
	//printf(&quot;ins %d %d %d %d\n&quot;,v,x,pos,ff);
	if (v==0)
	{
		v=++TTT;
		fa[v]=ff;
		key[v]=x;
		size[v]=1;
		splay(v,0);
	}
	else if (pos&lt;=size[son[v][0]])
		ins(son[v][0],x,pos,v);
	else ins(son[v][1],x,pos-size[son[v][0]]-1,v);
}
void bianli(int v)
{
	if (!v) return;
	bianli(son[v][0]);
	a[++n]=key[v];
	bianli(son[v][1]);
}
inline void change(int i,int x)
{
	for (;i&lt;=n;i+=i&amp;-i)
		if (x&gt;c[i]) c[i]=x;
}
int getmax(int i)
{
	int res=0;
	for (;i;i-=i&amp;-i)
		if (c[i]&gt;res) res=c[i];
	return res;
}
void debug(int v)
{
	if (!v) return;
	debug(son[v][0]);
	printf(&quot;%d &quot;,key[v]);
	debug(son[v][1]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x;
	for (i=1;i&lt;=n;i++)
	{
		//printf(&quot;\n-------------------------------------------------------------\n&quot;);
		scanf(&quot;%d&quot;,&amp;x);
		ins(root,i,x,0);
		//printf(&quot;debug &quot;);debug(root);ln;
	}
	n=0;
	bianli(root);
	//ln;printf(&quot;a &quot;);for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,a[i]);ln;
	for (i=1;i&lt;=n;i++)
	{
		pos[a[i]]=i;
		f[i]=getmax(a[i])+1;
		change(a[i],f[i]);
	}
	//ln;printf(&quot;f &quot;);for(i=1;i&lt;=n;i++) printf(&quot;%d &quot;,f[i]);ln;
	int ans=0;
	for (i=1;i&lt;=n;i++)
	{
		if (f[pos[i]]&gt;ans) ans=f[pos[i]];
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem3196</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define lc(v) (v&lt;&lt;1)
#define rc(v) ((v&lt;&lt;1)+1)
const int inf=99999999,maxn=2100000;
int key[maxn],root[maxn],fa[maxn],son[maxn][2],S[maxn],num[maxn],a[maxn];
int n,m,aa,bb,x,i,size,ans,pos;
int max(int a,int b) {return a&gt;b?a:b;}
int min(int a,int b) {return a&lt;b?a:b;}
void update(int t)
{
	S[t]=S[son[t][0]]+S[son[t][1]]+num[t];
}
void rotate(int t,int p)
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
	update(y);
	update(t);
} 
void splay(int w,int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(t,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(t,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root[w]=t;
}
void ins(int w,int &amp;t,int x,int ff)
{
	if (t==0)
	{
		t=++size;
		fa[t]=ff;
		S[t]=num[t]=1;
		son[t][0]=son[t][1]=0;
		key[t]=x;
		splay(w,t,0);
		return;
	}
	++S[t];
	if (x==key[t]) ++num[t],splay(w,t,0);
	else if (x&lt;key[t]) ins(w,son[t][0],x,t);
	else ins(w,son[t][1],x,t);
}
void del(int w,int t,int x)
{
	for (;t;)
	{
		S[t]--;
		if (key[t]==x) {num[t]--;break;}
		t=son[t][x&gt;=key[t]];
	}
	splay(w,t,0);
	if (num[t]) return;
	if (son[t][0]==0) {root[w]=son[t][1];fa[root[w]]=0;return;}
	if (son[t][1]==0) {root[w]=son[t][0];fa[root[w]]=0;return;}
	int y;
	for (y=son[t][0];son[y][1];y=son[y][1]);
	splay(w,y,root[w]);
	son[y][1]=son[t][1];
	fa[son[t][1]]=y;
	fa[y]=0;
	update(y);
	root[w]=y;
}
void build(int v,int ll,int rr)
{
	for (int i=ll;i&lt;rr;i++) ins(v,root[v],a[i],0);
	if (rr-ll==1) return;
	int mid=(ll+rr)&gt;&gt;1;
	build(lc(v),ll,mid);
	build(rc(v),mid,rr);
}
int rank(int t,int x)
{
	int res=0;
	for (;t;)
	{
		//if (x==4) printf(&quot;rank: %d %d %d\n&quot;,key[t],key[son[t][0]],key[son[t][1]]);
		if (x&lt;key[t]) t=son[t][0];
		else if (x==key[t]) return res+S[son[t][0]];
		else res+=S[son[t][0]]+num[t],t=son[t][1];
	}
	return res;
}
int findrank(int v,int ll,int rr,int x)
{
	if (aa&lt;=ll&amp;&amp;rr&lt;=bb) return rank(root[v],x);
	int mid=(ll+rr)&gt;&gt;1,res=0;
	if (aa&lt;mid) res+=findrank(lc(v),ll,mid,x);
	if (bb&gt;mid) res+=findrank(rc(v),mid,rr,x);
	//if (x==4) printf(&quot;findrank:%d %d %d %d\n&quot;,v,ll,rr,res);
	return res;
}
void change(int v,int ll,int rr,int i,int x)
{
	del(v,root[v],a[i]);
	ins(v,root[v],x,0);
	if (rr-ll==1) return;
	int mid=(ll+rr)&gt;&gt;1;
	if (i&lt;mid) change(lc(v),ll,mid,i,x);
	else change(rc(v),mid,rr,i,x);
}
int pred(int t,int x)
{
	int res=-1;
	for (;t;)
		if (x&gt;key[t]) res=key[t],t=son[t][1];
		else t=son[t][0];
	return res;
}
int findpred(int v,int ll,int rr,int x)
{
	if (aa&lt;=ll&amp;&amp;rr&lt;=bb) return pred(root[v],x);
	int mid=(ll+rr)&gt;&gt;1,res=0,tmp;
	if (aa&lt;mid)
	{
		tmp=findpred(lc(v),ll,mid,x);
		if (tmp!=-1) res=max(res,tmp);
	}
	if (bb&gt;mid)
	{
		tmp=findpred(rc(v),mid,rr,x);
		if (tmp!=-1) res=max(res,tmp);
	}
	return res;
}
int succ(int t,int x)
{
	int res=-1;
	for (;t;)
		if (x&lt;key[t]) res=key[t],t=son[t][0];
		else t=son[t][1];
	return res;
}
int findsucc(int v,int ll,int rr,int x)
{
	if (aa&lt;=ll&amp;&amp;rr&lt;=bb) return succ(root[v],x);
	int mid=(ll+rr)&gt;&gt;1,res=inf,tmp;
	if (aa&lt;mid)
	{
		tmp=findsucc(lc(v),ll,mid,x);
		if (tmp!=-1) res=min(res,tmp);
	}
	if (bb&gt;mid)
	{
		tmp=findsucc(rc(v),mid,rr,x);
		if (tmp!=-1) res=min(res,tmp);
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;scanf(&quot;%d&quot;,&amp;a[i++]));
	build(1,1,n+1);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		//printf(&quot;-------------------------\n&quot;);
		if (x==1)
		{
			scanf(&quot;%d%d%d&quot;,&amp;aa,&amp;bb,&amp;x);
			bb++;
			ans=0;
			printf(&quot;%d\n&quot;,findrank(1,1,n+1,x)+1);
		}
		else if (x==2)
		{
			scanf(&quot;%d%d%d&quot;,&amp;aa,&amp;bb,&amp;x);
			bb++;
			int l=0,r=inf;
			ans=0;
			while (l&lt;=r)
			{
				int mid=(l+r)&gt;&gt;1;
				int tmp=findrank(1,1,n+1,mid);
				//printf(&quot;%d %d\n&quot;,mid,tmp);
				if (tmp&lt;x) ans=mid,l=mid+1;
				else r=mid-1;
			}
			printf(&quot;%d\n&quot;,ans);
		}
		else if (x==3)
		{
			scanf(&quot;%d%d&quot;,&amp;pos,&amp;x);
			change(1,1,n+1,pos,x);
			a[pos]=x;
		}
		else if (x==4)
		{
			scanf(&quot;%d%d%d&quot;,&amp;aa,&amp;bb,&amp;x);
			bb++;
			printf(&quot;%d\n&quot;,findpred(1,1,n+1,x));
		}
		else
		{
			scanf(&quot;%d%d%d&quot;,&amp;aa,&amp;bb,&amp;x);
			bb++;
			printf(&quot;%d\n&quot;,findsucc(1,1,n+1,x));
		}
	}
	return 0;
}<pre><h2>Problem3196</h2><pre>#include &lt;cstdio&gt;
using namespace std;
const int maxn=2000000,inf=999999999;
int a[maxn],f[maxn],sum[maxn],num[maxn],n,m,c[50001],root[200000],left,right,tot,son[maxn][2];
void prin(int x)
{
    if (son[x][0]) prin(son[x][0]);
    printf(&quot;%d &quot;,a[x]);
    if (son[x][1]) prin(son[x][1]);
}
void print(int r)
{
    prin(root[r]);
    printf(&quot;\n&quot;);
}
int mmin(int x,int y)
{
    if (x&lt;y) return x;
    return y;
}
int mmax(int x,int y)
{
    if (x&gt;y) return x;
    return y;
}
void rotate(int x,int w)
{
    int y=f[x];
    if (f[y]) if (y==son[f[y]][0]) son[f[y]][0]=x; else son[f[y]][1]=x;
    f[x]=f[y];
    if (son[x][w]) f[son[x][w]]=y;
    son[y][1-w]=son[x][w];
    f[y]=x;
    son[x][w]=y;
    sum[y]=sum[son[y][0]]+sum[son[y][1]]+num[y];
}
void splay(int r,int x,int w)
{
    int y;
    while (f[x]!=w)
    {
        y=f[x];
        if (f[y]==w) if (x==son[y][0]) rotate(x,1); else rotate(x,0);
        else if (y==son[f[y]][0]) if (x==son[y][0]) {rotate(y,1); rotate(x,1); } else {rotate(x,0); rotate(x,1);}
                else if (x==son[y][0]) {rotate(x,1); rotate(x,0);} else {rotate(y,0); rotate(x,0);}
    }
    sum[x]=sum[son[x][0]]+sum[son[x][1]]+num[x];
    if (w==0) root[r]=x;
}
void insert(int r,int value)
{
    int x=root[r];
    if (x==0)
    {
        a[++tot]=value;
        num[tot]=sum[tot]=1;
        root[r]=tot;
        return;
    }
    while (a[x]!=value)
        if (a[x]&gt;value) {if (son[x][0]) x=son[x][0]; else break;}
        else {if (son[x][1]) x=son[x][1]; else break;}
    if (a[x]==value) {num[x]++; splay(r,x,0); return;}
    a[++tot]=value;
    f[tot]=x;
    num[tot]=sum[tot]=1;
    if (value&lt;a[x]) son[x][0]=tot; else son[x][1]=tot;
    splay(r,tot,0);
}
void del(int r,int value)
{
    int x=root[r];
    while (a[x]!=value)
        if (a[x]&gt;value) {if (son[x][0]) x=son[x][0]; else break;}
        else {if (son[x][1]) x=son[x][1]; else break;}
    splay(r,x,0);
    if (num[x]&gt;1) {num[x]--; return;}
    if (!son[x][0]) {root[r]=son[x][1]; f[son[x][1]]=0; return;}
    if (!son[x][1]) {root[r]=son[x][0]; f[son[x][0]]=0; return;}
    int y=son[x][0];
    while (son[y][1]) y=son[y][1];
    splay(r,y,x);
    son[y][1]=son[x][1];
    f[y]=0;
    f[son[y][1]]=y;
    sum[y]=sum[son[y][0]]+sum[son[y][1]]+num[y];
    root[r]=y;
}
void build(int now,int l,int r)
{
    //printf(&quot;now=%d l=%d r=%d\n&quot;,now,l,r);
    int i;
    for (i=l;i&lt;=r;i++) insert(now,c[i]);
    //print(now);
    if (l==r) return;
    int mid=(l+r)&gt;&gt;1;
    i=now&lt;&lt;1;
    build(i,l,mid);
    build(i+1,mid+1,r);
}
int find(int r,int value)
{
    int x=root[r];
    while (a[x]!=value)
        if (a[x]&gt;value) {if (son[x][0]) x=son[x][0]; else break;}
        else {if (son[x][1]) x=son[x][1]; else break;}
    splay(r,x,0);
    return x;
}
int rank(int r,int k)
{
    int x=find(r,k);
    if (a[x]&gt;=k) return (sum[son[x][0]]);
    return (sum[son[x][0]]+num[x]);
}
int getrank(int now,int l,int r,int k)
{
    if (l&gt;=left&amp;&amp;r&lt;=right) return (rank(now,k));
    int mid=(l+r)&gt;&gt;1,w=now&lt;&lt;1,ret=0;
    if (left&lt;=mid) ret=getrank(w,l,mid,k);
    if (right&gt;mid) ret+=getrank(w+1,mid+1,r,k);
    return ret;
}
void change(int now,int l,int r,int pos,int value)
{
    del(now,c[pos]);
    insert(now,value);
    if (l==r) return;
    int mid=(l+r)&gt;&gt;1,w=now&lt;&lt;1;
    if (pos&lt;=mid) change(w,l,mid,pos,value); else change(w+1,mid+1,r,pos,value);
}
int ppre(int r,int value)
{
    int x=root[r];
    while (a[x]!=value)
        if (a[x]&gt;value) {if (son[x][0]) x=son[x][0]; else break;}
        else {if (son[x][1]) x=son[x][1]; else break;}
    if (a[x]==value)
    {
        splay(r,x,0);
        if (!son[x][0]) return 1;
        x=son[x][0];
        while (son[x][1]) x=son[x][1];
        return x;
    }
    while (f[x]&amp;&amp;a[x]&gt;value) x=f[x];
    if (a[x]&lt;value) return x;
    return 1;
}
int ssucc(int r,int value)
{
    int x=root[r];
    while (a[x]!=value)
        if (a[x]&gt;value) {if (son[x][0]) x=son[x][0]; else break;}
        else {if (son[x][1]) x=son[x][1]; else break;}
    if (a[x]==value)
    {
        splay(r,x,0);
        if (!son[x][1]) return 2;
        x=son[x][1];
        while (son[x][0]) x=son[x][0];
        return x;
    }
    while (f[x]&amp;&amp;a[x]&lt;value) x=f[x];
    if (a[x]&gt;value) return x;
    return 2;
}
int pre(int now,int l,int r,int value)
{
    if (l&gt;=left&amp;&amp;r&lt;=right)
    {
        int x=ppre(now,value);
        //if (now==3) printf(&quot;faq%d\n&quot;,a[x]);
        if (a[x]&lt;value) return a[x];
        x=find(now,4);
        return -1;
    }
    int mid=(l+r)&gt;&gt;1,w=now&lt;&lt;1,ret=-1;
    if (left&lt;=mid) ret=mmax(ret,pre(w,l,mid,value));
    if (right&gt;mid) ret=mmax(ret,pre(w+1,mid+1,r,value));
    return ret;
}
int succ(int now,int l,int r,int value)
{
    if (l&gt;=left&amp;&amp;r&lt;=right)
    {
        int x=ssucc(now,value);
        if (a[x]&gt;value) return (a[x]);
        return inf;
    }
    int mid=(l+r)&gt;&gt;1,w=now&lt;&lt;1,ret=inf;
    if (left&lt;=mid) ret=mmin(ret,succ(w,l,mid,value));
    if (right&gt;mid) ret=mmin(ret,succ(w+1,mid+1,r,value));
    return ret;
}
int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    int i,kind,x,y,z,min,max,ans,mid;
    for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;c[i]);
    tot=2;
    a[1]=-1,a[2]=999999999;
    build(1,1,n);
    for (i=1;i&lt;=m;i++)
    {
        scanf(&quot;%d%d%d&quot;,&amp;kind,&amp;x,&amp;y);
        if (kind!=3) scanf(&quot;%d&quot;,&amp;z);
        if (kind==1)
        {
            left=x,right=y;
            printf(&quot;%d\n&quot;,getrank(1,1,n,z)+1);
            continue;
        }
        if (kind==2)
        {
            left=x,right=y;
            min=0,max=100000000;
            while (min&lt;=max)
            {
                mid=(min+max)&gt;&gt;1;
                if (getrank(1,1,n,mid)&lt;z) {ans=mid; min=mid+1;} else max=mid-1;
            }
            printf(&quot;%d\n&quot;,ans);
            continue;
        }
        if (kind==3)
        {
            change(1,1,n,x,y);
            c[x]=y;
            continue;
        }
        if (kind==4)
        {
            left=x,right=y;
            printf(&quot;%d\n&quot;,pre(1,1,n,z));
            continue;
        }
        left=x,right=y;
        printf(&quot;%d\n&quot;,succ(1,1,n,z));
    }
    //printf(&quot;%d\n&quot;,a[ppre(3,5)]);
    return 0;
}<pre><h2>Problem3196</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define lc(v) (v&lt;&lt;1)
#define rc(v) ((v&lt;&lt;1)+1)
const int inf=99999999,maxn=2100000;
int key[maxn],root[maxn],fa[maxn],son[maxn][2],S[maxn],num[maxn],a[maxn];
int n,m,aa,bb,x,i,size,ans,pos;
int max(int a,int b) {return a&gt;b?a:b;}
int min(int a,int b) {return a&lt;b?a:b;}
void update(int t)
{
	S[t]=S[son[t][0]]+S[son[t][1]]+num[t];
}
void rotate(int t,int p)
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
	update(y);
	update(t);
} 
void splay(int w,int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(t,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(t,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root[w]=t;
}
void ins(int w,int &amp;t,int x,int ff)
{
	if (t==0)
	{
		t=++size;
		fa[t]=ff;
		S[t]=num[t]=1;
		son[t][0]=son[t][1]=0;
		key[t]=x;
		splay(w,t,0);
		return;
	}
	++S[t];
	if (x==key[t]) ++num[t],splay(w,t,0);
	else if (x&lt;key[t]) ins(w,son[t][0],x,t);
	else ins(w,son[t][1],x,t);
}
void del(int w,int t,int x)
{
	for (;t;)
	{
		S[t]--;
		if (key[t]==x) {num[t]--;break;}
		t=son[t][x&gt;=key[t]];
	}
	splay(w,t,0);
	if (num[t]) return;
	if (son[t][0]==0) {root[w]=son[t][1];fa[root[w]]=0;return;}
	if (son[t][1]==0) {root[w]=son[t][0];fa[root[w]]=0;return;}
	int y;
	for (y=son[t][0];son[y][1];y=son[y][1]);
	splay(w,y,root[w]);
	son[y][1]=son[t][1];
	fa[son[t][1]]=y;
	fa[y]=0;
	update(y);
	root[w]=y;
}
void build(int v,int ll,int rr)
{
	for (int i=ll;i&lt;rr;i++) ins(v,root[v],a[i],0);
	if (rr-ll==1) return;
	int mid=(ll+rr)&gt;&gt;1;
	build(lc(v),ll,mid);
	build(rc(v),mid,rr);
}
int rank(int t,int x)
{
	int res=0;
	for (;t;)
	{
		if (x&lt;key[t]) t=son[t][0];
		else if (x==key[t]) return res+S[son[t][0]];
		else res+=S[son[t][0]]+num[t],t=son[t][1];
	}
	return res;
}
int findrank(int v,int ll,int rr,int x)
{
	if (aa&lt;=ll&amp;&amp;rr&lt;=bb) return rank(root[v],x);
	int mid=(ll+rr)&gt;&gt;1,res=0;
	if (aa&lt;mid) res+=findrank(lc(v),ll,mid,x);
	if (bb&gt;mid) res+=findrank(rc(v),mid,rr,x);
	return res;
}
void change(int v,int ll,int rr,int i,int x)
{
	del(v,root[v],a[i]);
	ins(v,root[v],x,0);
	if (rr-ll==1) return;
	int mid=(ll+rr)&gt;&gt;1;
	if (i&lt;mid) change(lc(v),ll,mid,i,x);
	else change(rc(v),mid,rr,i,x);
}
int pred(int t,int x)
{
	int res=-1;
	for (;t;)
		if (x&gt;key[t]) res=key[t],t=son[t][1];
		else t=son[t][0];
	return res;
}
int findpred(int v,int ll,int rr,int x)
{
	if (aa&lt;=ll&amp;&amp;rr&lt;=bb) return pred(root[v],x);
	int mid=(ll+rr)&gt;&gt;1,res=0,tmp;
	if (aa&lt;mid)
	{
		tmp=findpred(lc(v),ll,mid,x);
		if (tmp!=-1) res=max(res,tmp);
	}
	if (bb&gt;mid)
	{
		tmp=findpred(rc(v),mid,rr,x);
		if (tmp!=-1) res=max(res,tmp);
	}
	return res;
}
int succ(int t,int x)
{
	int res=-1;
	for (;t;)
		if (x&lt;key[t]) res=key[t],t=son[t][0];
		else t=son[t][1];
	return res;
}
int findsucc(int v,int ll,int rr,int x)
{
	if (aa&lt;=ll&amp;&amp;rr&lt;=bb) return succ(root[v],x);
	int mid=(ll+rr)&gt;&gt;1,res=inf,tmp;
	if (aa&lt;mid)
	{
		tmp=findsucc(lc(v),ll,mid,x);
		if (tmp!=-1) res=min(res,tmp);
	}
	if (bb&gt;mid)
	{
		tmp=findsucc(rc(v),mid,rr,x);
		if (tmp!=-1) res=min(res,tmp);
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;scanf(&quot;%d&quot;,&amp;a[i++]));
	build(1,1,n+1);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		if (x==1)
		{
			scanf(&quot;%d%d%d&quot;,&amp;aa,&amp;bb,&amp;x);
			bb++;
			ans=0;
			printf(&quot;%d\n&quot;,findrank(1,1,n+1,x)+1);
		}
		else if (x==2)
		{
			scanf(&quot;%d%d%d&quot;,&amp;aa,&amp;bb,&amp;x);
			bb++;
			int l=0,r=inf;
			ans=0;
			while (l&lt;=r)
			{
				int mid=(l+r)&gt;&gt;1;
				int tmp=findrank(1,1,n+1,mid)+1;
				if (tmp&lt;=x) ans=mid,l=mid+1;
				else r=mid-1;
			}
			printf(&quot;%d\n&quot;,ans);
		}
		else if (x==3)
		{
			scanf(&quot;%d%d&quot;,&amp;pos,&amp;x);
			change(1,1,n+1,pos,x);
			a[pos]=x;
		}
		else if (x==4)
		{
			scanf(&quot;%d%d%d&quot;,&amp;aa,&amp;bb,&amp;x);
			bb++;
			printf(&quot;%d\n&quot;,findpred(1,1,n+1,x));
		}
		else
		{
			scanf(&quot;%d%d%d&quot;,&amp;aa,&amp;bb,&amp;x);
			bb++;
			printf(&quot;%d\n&quot;,findsucc(1,1,n+1,x));
		}
	}
	return 0;
}<pre><h2>Problem3196</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define lc(v) (v&lt;&lt;1)
#define rc(v) ((v&lt;&lt;1)+1)
const int inf=99999999,maxn=2100000;
int key[maxn],root[maxn],fa[maxn],son[maxn][2],S[maxn],num[maxn],a[maxn];
int n,m,aa,bb,x,i,size,ans,pos;
int max(int a,int b) {return a&gt;b?a:b;}
int min(int a,int b) {return a&lt;b?a:b;}
void update(int t)
{
	S[t]=S[son[t][0]]+S[son[t][1]]+num[t];
}
void rotate(int t,int p)
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
	update(y);
	update(t);
} 
void splay(int w,int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root[w]=t;
}
void ins(int w,int &amp;t,int x,int ff)
{
	if (t==0)
	{
		t=++size;
		fa[t]=ff;
		S[t]=num[t]=1;
		son[t][0]=son[t][1]=0;
		key[t]=x;
		splay(w,t,0);
		return;
	}
	++S[t];
	if (x==key[t]) ++num[t],splay(w,t,0);
	else if (x&lt;key[t]) ins(w,son[t][0],x,t);
	else ins(w,son[t][1],x,t);
}
void del(int w,int t,int x)
{
	for (;t;)
	{
		S[t]--;
		if (key[t]==x) {num[t]--;break;}
		t=son[t][x&gt;=key[t]];
	}
	splay(w,t,0);
	if (num[t]) return;
	if (son[t][0]==0) {root[w]=son[t][1];fa[root[w]]=0;return;}
	if (son[t][1]==0) {root[w]=son[t][0];fa[root[w]]=0;return;}
	int y;
	for (y=son[t][0];son[y][1];y=son[y][1]);
	splay(w,y,root[w]);
	son[y][1]=son[t][1];
	fa[son[t][1]]=y;
	fa[y]=0;
	update(y);
	root[w]=y;
}
void build(int v,int ll,int rr)
{
	for (int i=ll;i&lt;rr;i++) ins(v,root[v],a[i],0);
	if (rr-ll==1) return;
	int mid=(ll+rr)&gt;&gt;1;
	build(lc(v),ll,mid);
	build(rc(v),mid,rr);
}
int rank(int t,int x)
{
	int res=0;
	for (;t;)
	{
		if (x&lt;key[t]) t=son[t][0];
		else if (x==key[t]) return res+S[son[t][0]];
		else res+=S[son[t][0]]+num[t],t=son[t][1];
	}
	return res;
}
int findrank(int v,int ll,int rr,int x)
{
	if (aa&lt;=ll&amp;&amp;rr&lt;=bb) return rank(root[v],x);
	int mid=(ll+rr)&gt;&gt;1,res=0;
	if (aa&lt;mid) res+=findrank(lc(v),ll,mid,x);
	if (bb&gt;mid) res+=findrank(rc(v),mid,rr,x);
	return res;
}
void change(int v,int ll,int rr,int i,int x)
{
	del(v,root[v],a[i]);
	ins(v,root[v],x,0);
	if (rr-ll==1) return;
	int mid=(ll+rr)&gt;&gt;1;
	if (i&lt;mid) change(lc(v),ll,mid,i,x);
	else change(rc(v),mid,rr,i,x);
}
int pred(int t,int x)
{
	int res=-1;
	for (;t;)
		if (x&gt;key[t]) res=key[t],t=son[t][1];
		else t=son[t][0];
	return res;
}
int findpred(int v,int ll,int rr,int x)
{
	if (aa&lt;=ll&amp;&amp;rr&lt;=bb) return pred(root[v],x);
	int mid=(ll+rr)&gt;&gt;1,res=0,tmp;
	if (aa&lt;mid)
	{
		tmp=findpred(lc(v),ll,mid,x);
		if (tmp!=-1) res=max(res,tmp);
	}
	if (bb&gt;mid)
	{
		tmp=findpred(rc(v),mid,rr,x);
		if (tmp!=-1) res=max(res,tmp);
	}
	return res;
}
int succ(int t,int x)
{
	int res=-1;
	for (;t;)
		if (x&lt;key[t]) res=key[t],t=son[t][0];
		else t=son[t][1];
	return res;
}
int findsucc(int v,int ll,int rr,int x)
{
	if (aa&lt;=ll&amp;&amp;rr&lt;=bb) return succ(root[v],x);
	int mid=(ll+rr)&gt;&gt;1,res=inf,tmp;
	if (aa&lt;mid)
	{
		tmp=findsucc(lc(v),ll,mid,x);
		if (tmp!=-1) res=min(res,tmp);
	}
	if (bb&gt;mid)
	{
		tmp=findsucc(rc(v),mid,rr,x);
		if (tmp!=-1) res=min(res,tmp);
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=n;scanf(&quot;%d&quot;,&amp;a[i++]));
	build(1,1,n+1);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		if (x==1)
		{
			scanf(&quot;%d%d%d&quot;,&amp;aa,&amp;bb,&amp;x);
			bb++;
			ans=0;
			printf(&quot;%d\n&quot;,findrank(1,1,n+1,x)+1);
		}
		else if (x==2)
		{
			scanf(&quot;%d%d%d&quot;,&amp;aa,&amp;bb,&amp;x);
			bb++;
			int l=0,r=inf;
			ans=0;
			while (l&lt;=r)
			{
				int mid=(l+r)&gt;&gt;1;
				int tmp=findrank(1,1,n+1,mid)+1;
				if (tmp&lt;=x) ans=mid,l=mid+1;
				else r=mid-1;
			}
			printf(&quot;%d\n&quot;,ans);
		}
		else if (x==3)
		{
			scanf(&quot;%d%d&quot;,&amp;pos,&amp;x);
			change(1,1,n+1,pos,x);
			a[pos]=x;
		}
		else if (x==4)
		{
			scanf(&quot;%d%d%d&quot;,&amp;aa,&amp;bb,&amp;x);
			bb++;
			printf(&quot;%d\n&quot;,findpred(1,1,n+1,x));
		}
		else
		{
			scanf(&quot;%d%d%d&quot;,&amp;aa,&amp;bb,&amp;x);
			bb++;
			printf(&quot;%d\n&quot;,findsucc(1,1,n+1,x));
		}
	}
	return 0;
}
<pre><h2>Problem3196</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define lc(v) ((v)&lt;&lt;1)
#define rc(v) ((v)&lt;&lt;1|1)
#define inf 999999999
#define ln printf(&quot;\n&quot;)
const int NN=2001111;
int fa[NN],size[NN],key[NN],son[NN][2],num[NN],a[NN];
int n,m,TTT,ww,ee;
struct Splay_Tree
{
	int root;
	inline void update(int t)
	{
		size[t]=size[son[t][0]]+size[son[t][1]]+num[t];
	}
	void rotate(int t,int p)
	{
		int y=fa[t];
		if (fa[y])
		{
			if (y==son[fa[y]][0]) son[fa[y]][0]=t;
			else son[fa[y]][1]=t;
		}
		fa[t]=fa[y];
		son[y][p^1]=son[t][p];
		if (son[t][p]) fa[son[t][p]]=y;
		son[t][p]=y;
		fa[y]=t;
		update(y),update(t);
	}
	void splay(int t,int f)
	{
		while (fa[t]!=f)
		{
			int y=fa[t];
			if (fa[y]==f)
				if (t==son[y][0]) rotate(t,1);
				else rotate(t,0);
			else
				if (y==son[fa[y]][0])
					if (t==son[y][0]) rotate(y,1),rotate(t,1);
					else rotate(t,0),rotate(t,1);
				else
					if (t==son[y][1]) rotate(y,0),rotate(t,0);
					else rotate(t,1),rotate(t,0);
		}
		update(t);
		if (!f) root=t;
	}
	void ins(int &amp;v,int x,int f)
	{
		if (!v)
		{
			v=++TTT;
			key[v]=x;
			fa[v]=f;
			size[v]=num[v]=1;
			splay(v,0);
			return;
		}
		if (key[v]==x) num[v]++,splay(v,0);
		else if (x&lt;key[v]) ins(son[v][0],x,v);
		else ins(son[v][1],x,v);
	}
	void del(int x)
	{
		int t=root;
		while (t)
		{
			if (key[t]==x) break;
			if (x&lt;key[t]) t=son[t][0];
			else t=son[t][1];
		}
		if (num[t]&gt;1) {num[t]--;splay(t,0);return;}
		splay(t,0);
		if (!son[t][0]) {root=son[t][1];fa[root]=0;return;}
		if (!son[t][1]) {root=son[t][0];fa[root]=0;return;}
		int y=son[t][0];
		while (son[y][1]) y=son[y][1];
		splay(y,t);
		son[y][1]=son[t][1],fa[son[t][1]]=y;
		root=y,fa[y]=0;
		update(y);
	}
	int rank(int x)
	{
		int t=root,res=0;
		while (t)
		{
			int tmp=size[son[t][0]];
			if (x==key[t]) return res+tmp;
			if (x&lt;key[t]) t=son[t][0];
			else res+=tmp+num[t],t=son[t][1];
		}
		return res;
	}
	int pred(int x)
	{
		int t=root,res=-inf;
		while (t)
		{
			if (key[t]&lt;x) res=key[t],t=son[t][1];
			else t=son[t][0];
		}
		return res;
	}
	int succ(int x)
	{
		int t=root,res=inf;
		while (t)
		{
			if (key[t]&gt;x) res=key[t],t=son[t][0];
			else t=son[t][1];
		}
		return res;
	}
	void debug(int t)
	{
		if (!t) return;
		debug(son[t][0]);
		printf(&quot;%d*%d &quot;,num[t],key[t]);
		debug(son[t][1]);
	}
} T[NN*4];
void build(int v,int l,int r)
{
	for (int i=l;i&lt;r;i++)
		T[v].ins(T[v].root,a[i],0);
	//printf(&quot;build %d %d %d : &quot;,v,l,r);T[v].debug(T[v].root);ln;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	build(lc(v),l,mid);
	build(rc(v),mid,r);
}
void change(int v,int l,int r,int i,int x,int kind)
{
	if (kind==1) T[v].ins(T[v].root,x,0);
	else T[v].del(x);
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid) change(lc(v),l,mid,i,x,kind);
	else change(rc(v),mid,r,i,x,kind);
}
int find1(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return T[v].rank(x);
	int mid=(l+r)&gt;&gt;1,res=0;
	if (ww&lt;mid) res+=find1(lc(v),l,mid,x);
	if (ee&gt;mid) res+=find1(rc(v),mid,r,x);
	return res;
}
int find4(int v,int l,int r,int x)
{
	//printf(&quot;find4 %d %d %d %d\n&quot;,v,l,r,x);T[v].debug(T[v].root);ln;
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return T[v].pred(x);
	int mid=(l+r)&gt;&gt;1,res=-inf;
	if (ww&lt;mid) res=max(res,find4(lc(v),l,mid,x));
	if (ee&gt;mid) res=max(res,find4(rc(v),mid,r,x));
	return res;
}
int find5(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return T[v].succ(x);
	int mid=(l+r)&gt;&gt;1,res=inf;
	if (ww&lt;mid) res=min(res,find5(lc(v),l,mid,x));
	if (ee&gt;mid) res=min(res,find5(rc(v),mid,r,x));
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	build(1,1,n+1);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		//printf(&quot;\n------------------------------------------------------------------------------\n&quot;);
		if (x==1)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			ww=x,ee=y+1;
			printf(&quot;%d\n&quot;,find1(1,1,n+1,z)+1);
		}
		else if (x==2)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			ww=x,ee=y+1;
			int l=0,r=inf,res=0;
			while (l&lt;=r)
			{
				int mid=(l+r)&gt;&gt;1;
				int t=find1(1,1,n+1,mid);
				if (t+1&lt;=z) res=mid,l=mid+1;
				else r=mid-1;
			}
			printf(&quot;%d\n&quot;,res);
		}
		else if (x==3)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			change(1,1,n+1,x,a[x],-1);
			a[x]=y;
			change(1,1,n+1,x,a[x],1);
		}
		else if (x==4)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			ww=x,ee=y+1;
			printf(&quot;%d\n&quot;,find4(1,1,n+1,z));
		}
		else
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			ww=x,ee=y+1;
			printf(&quot;%d\n&quot;,find5(1,1,n+1,z));
		}
	}
	return 0;
}<pre><h2>Problem3196</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
#define lc (v&lt;&lt;1)
#define rc (v&lt;&lt;1|1)
const int NN=51111,AA=1001111;
int fa[AA],son[AA][2],size[AA],num[AA],key[AA],a[NN];
int n,m,TTT,ww,ee;
struct Splay
{
	int root;
	inline void update(int t)
	{
		size[t]=size[son[t][0]]+size[son[t][1]]+num[t];
	}
	inline void rotate(int t,int p)
	{
		int y=fa[t];
		if (fa[y])
		{
			if (y==son[fa[y]][0]) son[fa[y]][0]=t;
			else son[fa[y]][1]=t;
		}
		fa[t]=fa[y];
		son[y][p^1]=son[t][p];
		if (son[t][p]) fa[son[t][p]]=y;
		son[t][p]=y;
		fa[y]=t;
		update(y),update(t);
	}
	void splay(int t,int ff)
	{
		while (fa[t]!=ff)
		{
			int y=fa[t];
			if (fa[y]==ff)
				if (t==son[y][0]) rotate(t,1);
				else rotate(t,0);
			else
				if (y==son[fa[y]][0])
					if (t==son[y][0]) rotate(y,1),rotate(t,1);
					else rotate(t,0),rotate(t,1);
				else
					if (t==son[y][1]) rotate(y,0),rotate(t,0);
					else rotate(t,1),rotate(t,0);
		}
		update(t);
		if (ff==0) root=t;
	}
	void ins(int &amp;v,int x,int ff)
	{
		if (v==0)
		{
			v=++TTT;
			key[v]=x;
			size[v]=num[v]=1;
			fa[v]=ff;
			splay(v,0);
		}
		else if (x==key[v]) num[v]++,splay(v,0);
		else if (x&lt;key[v]) ins(son[v][0],x,v);
		else ins(son[v][1],x,v);
	}
	void del(int x)
	{
		int t=root;
		while (t)
		{
			if (x==key[t]) break;
			if (x&lt;key[t]) t=son[t][0];
			else t=son[t][1];
		}
		if (num[t]&gt;1) {num[t]--;splay(t,0);return;}
		splay(t,0);
		if (!son[t][0]) {root=son[t][1];fa[root]=0;return;}
		if (!son[t][1]) {root=son[t][0];fa[root]=0;return;}
		int y=son[t][0];
		while (son[y][1]) y=son[y][1];
		splay(y,t);
		son[y][1]=son[t][1];
		fa[son[t][1]]=y;
		root=y,fa[y]=0;
		update(y);
	}
	int rank(int x)
	{
		int t=root,res=0;
		while (t)
		{
			int tmp=size[son[t][0]];
			if (x==key[t]) return res+tmp;
			if (x&lt;key[t]) t=son[t][0];
			else res+=tmp+num[t],t=son[t][1];
		}
		return res;
	}
	int pred(int x)
	{
		int t=root,res=-1;
		while (t)
		{
			if (key[t]&lt;x) res=key[t],t=son[t][1];
			else t=son[t][0];
		}
		if (res==-1) return -inf;
		return res;
	}
	int succ(int x)
	{
		int t=root,res=-1;
		while (t)
		{
			if (key[t]&gt;x) res=key[t],t=son[t][0];
			else t=son[t][1];
		}
		if (res==-1) return inf;
		return res;
	}
} T[NN*4];
void build(int v,int l,int r)
{
	for (int i=l;i&lt;r;i++)
		T[v].ins(T[v].root,a[i],0);
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	build(lc,l,mid);
	build(rc,mid,r);
}
int find1(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return T[v].rank(x);
	int mid=(l+r)&gt;&gt;1,res=0;
	if (ww&lt;mid) res+=find1(lc,l,mid,x);
	if (ee&gt;mid) res+=find1(rc,mid,r,x);
	return res;
}
void change(int v,int l,int r,int i,int x,int y)
{
	T[v].del(x);
	T[v].ins(T[v].root,y,0);
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid) change(lc,l,mid,i,x,y);
	else change(rc,mid,r,i,x,y);
}
int find4(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return T[v].pred(x);
	int mid=(l+r)&gt;&gt;1,res=-inf;
	if (ww&lt;mid) res=max(res,find4(lc,l,mid,x));
	if (ee&gt;mid) res=max(res,find4(rc,mid,r,x));
	return res;
}
int find5(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return T[v].succ(x);
	int mid=(l+r)&gt;&gt;1,res=inf;
	if (ww&lt;mid) res=min(res,find5(lc,l,mid,x));
	if (ee&gt;mid) res=min(res,find5(rc,mid,r,x));
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	build(1,1,n+1);
	for (;m;m--)
	{
		scanf(&quot;%d&quot;,&amp;x);
		if (x==1)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			ww=x,ee=y+1;
			printf(&quot;%d\n&quot;,find1(1,1,n+1,z)+1);
		}
		else if (x==2)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			ww=x,ee=y+1;
			int l=0,r=100000001,res;
			while (l&lt;=r)
			{
				int mid=(l+r)&gt;&gt;1;
				if (find1(1,1,n+1,mid)+1&lt;=z) res=mid,l=mid+1;
				else r=mid-1;
			}
			printf(&quot;%d\n&quot;,res);
		}
		else if (x==3)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			change(1,1,n+1,x,a[x],y);
			a[x]=y;
		}
		else if (x==4)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			ww=x,ee=y+1;
			printf(&quot;%d\n&quot;,find4(1,1,n+1,z));
		}
		else
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			ww=x,ee=y+1;
			printf(&quot;%d\n&quot;,find5(1,1,n+1,z));
		}
	}
	return 0;
}<pre><h2>Problem3196</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
#define ls (v&lt;&lt;1)
#define rs (v&lt;&lt;1|1)
const int NN=50111,AA=1500000;
int n,m,TTT,ww,ee,a[NN];
struct splaynode
{
	int fa,sz,num,key,s[2];
} T[AA];
struct splaytree
{
	int root;
	inline void update(int t)
	{
		T[t].sz=T[T[t].s[0]].sz+T[T[t].s[1]].sz+T[t].num;
	}
	inline void rotate(int t,int p)
	{
		int y=T[t].fa;
		if (T[y].fa)
		{
			if (y==T[T[y].fa].s[0]) T[T[y].fa].s[0]=t;
			else T[T[y].fa].s[1]=t;
		}
		T[t].fa=T[y].fa;
		T[y].s[p^1]=T[t].s[p];
		if (T[t].s[p]) T[T[t].s[p]].fa=y;
		T[t].s[p]=y;
		T[y].fa=t;
		update(y),update(t);
	}
	void splay(int t,int ff)
	{
		while (T[t].fa!=ff)
		{
			int y=T[t].fa;
			if (T[y].fa==ff)
				if (t==T[y].s[0]) rotate(t,1);
				else rotate(t,0);
			else
				if (y==T[T[y].fa].s[0])
					if (t==T[y].s[0]) rotate(y,1),rotate(t,1);
					else rotate(t,0),rotate(t,1);
				else
					if (t==T[y].s[1]) rotate(y,0),rotate(t,0);
					else rotate(t,1),rotate(t,0);
		}
		update(t);
		if (ff==0) root=t;
	}
	void ins(int &amp;v,int x,int ff)
	{
		if (v==0)
		{
			v=++TTT;
			T[v].key=x;
			T[v].sz=T[v].num=1;
			T[v].fa=ff;
			splay(v,0);
			return;
		}
		else if (x==T[v].key) T[v].num++,splay(v,0);
		else if (x&lt;T[v].key) ins(T[v].s[0],x,v);
		else ins(T[v].s[1],x,v);
	}
	inline void ins(int x) {ins(root,x,0);}
	void del(int x)
	{
		int t=root;
		while (t)
		{
			if (x==T[t].key) break;
			if (x&lt;T[t].key) t=T[t].s[0];
			else t=T[t].s[1];
		}
		if (T[t].num&gt;1) {T[t].num--;splay(t,0);return;}
		splay(t,0);
		if (!T[t].s[0]||!T[t].s[1])
			{root=T[t].s[0]+T[t].s[1],T[root].fa=0;return;}
		int y=T[t].s[0];
		while (T[y].s[1]) y=T[y].s[1];
		splay(y,t);
		T[y].s[1]=T[t].s[1];
		if (T[t].s[1]) T[T[t].s[1]].fa=y;
		root=y;
		T[root].fa=0;
		update(y);
	}
	int rank(int x)
	{
		int t=root,res=0;
		while (t)
		{
			int tmp=T[T[t].s[0]].sz;
			if (x&gt;T[t].key)
				res+=tmp+T[t].num,t=T[t].s[1];
			else if (x==T[t].key) return res+tmp;
			else t=T[t].s[0];
		}
		return res;
	}
	int pred(int x)
	{
		int t=root,res=-inf;
		while (t)
		{
			if (x&gt;T[t].key)
				res=max(res,T[t].key),t=T[t].s[1];
			else t=T[t].s[0];
		}
		return res;
	}
	int succ(int x)
	{
		int t=root,res=inf;
		while (t)
		{
			if (x&lt;T[t].key)
				res=min(res,T[t].key),t=T[t].s[0];
			else t=T[t].s[1];
		}
		return res;
	}
} E[NN&lt;&lt;2];
void build(int v,int l,int r)
{
	for (int i=l;i&lt;r;i++) E[v].ins(a[i]);
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	build(ls,l,mid);
	build(rs,mid,r);
}
int findrank(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return E[v].rank(x);
	int mid=(l+r)&gt;&gt;1,res=0;
	if (ww&lt;mid) res+=findrank(ls,l,mid,x);
	if (ee&gt;mid) res+=findrank(rs,mid,r,x);
	return res;
}
void change(int v,int l,int r,int i,int x,int y)
{
	E[v].del(x),E[v].ins(y);
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid) change(ls,l,mid,i,x,y);
	else change(rs,mid,r,i,x,y);
}
int findpred(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return E[v].pred(x);
	int mid=(l+r)&gt;&gt;1,res=-inf;
	if (ww&lt;mid) res=max(res,findpred(ls,l,mid,x));
	if (ee&gt;mid) res=max(res,findpred(rs,mid,r,x));
	return res;
}
int findsucc(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return E[v].succ(x);
	int mid=(l+r)&gt;&gt;1,res=inf;
	if (ww&lt;mid) res=min(res,findsucc(ls,l,mid,x));
	if (ee&gt;mid) res=min(res,findsucc(rs,mid,r,x));
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z,K;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	build(1,1,n+1);
	for (;m;m--)
	{
		scanf(&quot;%d&quot;,&amp;x);
		if (x==1)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			ww=x,ee=y+1;
			printf(&quot;%d\n&quot;,findrank(1,1,n+1,z)+1);
		}
		else if (x==2)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;K);
			ww=x,ee=y+1;
			int l=0,r=100000000,res=-1;
			while (l&lt;=r)
			{
				int mid=(l+r)&gt;&gt;1;
				if (findrank(1,1,n+1,mid)&gt;=K) res=mid,r=mid-1;
				else l=mid+1;
			}
			printf(&quot;%d\n&quot;,res-1);
		}
		else if (x==3)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			change(1,1,n+1,x,a[x],y);
			a[x]=y;
		}
		else if (x==4)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			ww=x,ee=y+1;
			printf(&quot;%d\n&quot;,findpred(1,1,n+1,z));
		}
		else if (x==5)
		{
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			ww=x,ee=y+1;
			printf(&quot;%d\n&quot;,findsucc(1,1,n+1,z));
		}
	}
	return 0;
}<pre><h2>Problem3197</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include&lt;algorithm&gt;
#define maxn 800
#define inf 99999999
using namespace std;
int n,mx,go,bx,by,rot;
int g[maxn][20],a[maxn],b[maxn],s[maxn],c[maxn],f[maxn];
void dfs(int x,int fa,int dep) {
    s[++s[0]]=x;
    if (dep&gt;mx) {
        mx=dep; go=x;
        memcpy(c,s,sizeof s);
    }
    for (int i=1;i&lt;=g[x][0];i++) 
        if (g[x][i]!=fa) dfs(g[x][i],x,dep+1);
    s[0]--;
}
void build(int x,int fa) {
    int t[20]; t[0]=0;
    for (int i=1;i&lt;=g[x][0];i++)
        if (g[x][i]!=fa&amp;&amp;!(x==bx&amp;&amp;g[x][i]==by||x==by&amp;&amp;g[x][i]==bx))
            t[++t[0]]=g[x][i];
    memcpy(g[x],t,sizeof t);
    for (int i=1;i&lt;=g[x][0];i++) build(g[x][i],x);
}
int dp(int x,int y) {
    if (g[x][0]!=g[y][0]) return inf;
    int w[20][20];
    for (int i=1;i&lt;=g[x][0];i++)
        for (int j=1;j&lt;=g[y][0];j++)
            w[i][j]=dp(g[x][i],g[y][j]);
    for (int i=0;i&lt;1&lt;&lt;g[x][0];i++) f[i]=inf;
    f[(1&lt;&lt;g[x][0])-1]=0;
    for (int i=(1&lt;&lt;g[x][0])-1;i;i--) {
        if (f[i]&lt;inf) {
            int cnt=g[x][0];
            for (int j=0;j&lt;g[x][0];j++)
                if (i&amp;(1&lt;&lt;j)) cnt--;
            for (int j=0;j&lt;g[x][0];j++)
                if (i&amp;(1&lt;&lt;j))
                    f[i^(1&lt;&lt;j)]=min(f[i^(1&lt;&lt;j)],f[i]+w[cnt+1][j+1]);
        }
    }
    return f[0]+(a[x]!=b[y]);
}
int main() {
    scanf(&quot;%d&quot;,&amp;n);
    for (int i=1;i&lt;n;i++) {
        int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
        g[x][++g[x][0]]=y;
        g[y][++g[y][0]]=x;
    }
    for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
    for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;b[i]);
    dfs(1,0,0);
    dfs(go,mx=0,0);
    if (c[0]&amp;1) rot=c[1+c[0]&gt;&gt;1]; else {
        rot=n+1;
        bx=g[rot][++g[rot][0]]=c[c[0]&gt;&gt;1];
        by=g[rot][++g[rot][0]]=c[(c[0]&gt;&gt;1)+1];
    }
    build(rot,0);
    printf(&quot;%d\n&quot;,dp(rot,rot));
    return 0;
}
<pre><h2>Problem3197</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;
const int MAXN = 777, MAXM = 11, INF = 1000000000;
int n, mx, go, bx, by, a[MAXN], b[MAXN], s[MAXN], c[MAXN],
    g[MAXN], e[MAXN][MAXM], f[(1 &lt;&lt; MAXM) + 1];
inline void checkmin(int &amp;x, int y) {if (y &lt; x) x = y;}
void dfs(int x, int y, int d) {
    s[++s[0]] = x;
    if (d &gt; mx) {
        mx = d, go = x;
        memcpy(c, s, sizeof s);
    }
    for (int i = 0; i &lt; g[x]; ++i)
        if (e[x][i] != y)
            dfs(e[x][i], x, d + 1);
    --s[0];
}
void build(int x, int y) {
    int cnt = 0, t[MAXM];
    for (int i = 0; i &lt; g[x]; ++i)
        if (e[x][i] != y &amp;&amp; !(x == bx &amp;&amp; e[x][i] == by || x == by &amp;&amp; e[x][i] == bx))
            t[cnt++] = e[x][i];
    g[x] = cnt;
    memcpy(e[x], t, sizeof t);
    for (int i = 0; i &lt; g[x]; ++i)
        build(e[x][i], x);
}
int dp(int x, int y) {
    if (g[x] != g[y])
        return INF;
    int r[MAXM][MAXM];
    for (int i = 0; i &lt; g[x]; ++i)
        for (int j = 0; j &lt; g[y]; ++j)
            r[i][j] = dp(e[x][i], e[y][j]);
    for (int i = 0; i &lt; 1 &lt;&lt; g[x]; ++i)
        f[i] = INF;
    f[(1 &lt;&lt; g[x]) - 1] = 0;
    for (int i = (1 &lt;&lt; g[x]) - 1; i; --i)
        if (f[i] &lt; INF) {
            int cnt = g[x];
            for (int j = 0; j &lt; g[x]; ++j)
                if (i &amp; (1 &lt;&lt; j))
                    --cnt;
            for (int j = 0; j &lt; g[x]; ++j)
                if (i &amp; (1 &lt;&lt; j))
                    checkmin(f[i ^ (1 &lt;&lt; j)], f[i] + r[cnt][j]);
        }
    return f[0] + (a[x] != b[y]);
}
int main() {
    int n, root;
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt; n; ++i) {
        int x, y;
        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
        e[x][g[x]++] = y;
        e[y][g[y]++] = x;
    }
    for (int i = 1; i &lt;= n; ++i)
        scanf(&quot;%d&quot;, &amp;a[i]);
    for (int i = 1; i &lt;= n; ++i)
        scanf(&quot;%d&quot;, &amp;b[i]);
    dfs(1, 0, 0);
    dfs(go, mx = 0, 0);
    if (c[0] &amp; 1)
        root = c[1 + c[0] &gt;&gt; 1];
    else {
        root = n + 1;
        bx = e[root][g[root]++] = c[c[0] &gt;&gt; 1];
        by = e[root][g[root]++] = c[(c[0] &gt;&gt; 1) + 1];
    }
    build(root, 0);
    printf(&quot;%d\n&quot;, dp(root, root));
    return 0;
}
<pre><h2>Problem3197</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;
const int MAXN = 777, MAXM = 11, INF = 99999999;
int n, mx, go, bx, by, a[MAXN], b[MAXN], s[MAXN], c[MAXN],
    g[MAXN], e[MAXN][MAXM], f[(1 &lt;&lt; MAXM) + 1];
inline void checkmin(int &amp;x, int y) {if (y &lt; x) x = y;}
void dfs(int x, int y, int d) {
    s[++s[0]] = x;
    if (d &gt; mx) {
        mx = d, go = x;
        memcpy(c, s, sizeof s);
    }
    for (int i = 0; i &lt; g[x]; ++i)
        if (e[x][i] != y)
            dfs(e[x][i], x, d + 1);
    --s[0];
}
void build(int x, int y) {
    int cnt = 0, t[MAXM];
    for (int i = 0; i &lt; g[x]; ++i)
        if (e[x][i] != y &amp;&amp; !(x == bx &amp;&amp; e[x][i] == by || x == by &amp;&amp; e[x][i] == bx))
            t[cnt++] = e[x][i];
    g[x] = cnt;
    memcpy(e[x], t, sizeof t);
    for (int i = 0; i &lt; g[x]; ++i)
        build(e[x][i], x);
}
int dp(int x, int y) {
    if (g[x] != g[y]) return INF;
    int r[MAXM][MAXM];
    for (int i = 0; i &lt; g[x]; ++i)
        for (int j = 0; j &lt; g[y]; ++j)
            r[i][j] = dp(e[x][i], e[y][j]);
    for (int i = 0; i &lt; 1 &lt;&lt; g[x]; ++i) f[i] = INF;
    f[(1 &lt;&lt; g[x]) - 1] = 0;
    for (int i = (1 &lt;&lt; g[x]) - 1; i; --i)
        if (f[i] &lt; INF) {
            int cnt = g[x];
            for (int j = 0; j &lt; g[x]; ++j)
                if (i &amp; (1 &lt;&lt; j)) --cnt;
            for (int j = 0; j &lt; g[x]; ++j)
                if (i &amp; (1 &lt;&lt; j))
                    checkmin(f[i ^ (1 &lt;&lt; j)], f[i] + r[cnt][j]);
        }
    return f[0] + (a[x] != b[y]);
}
int main() {
    int n, root;
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt; n; ++i) {
        int x, y;
        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
        e[x][g[x]++] = y;
        e[y][g[y]++] = x;
    }
    for (int i = 1; i &lt;= n; ++i)
        scanf(&quot;%d&quot;, &amp;a[i]);
    for (int i = 1; i &lt;= n; ++i)
        scanf(&quot;%d&quot;, &amp;b[i]);
    dfs(1, 0, 0);
    dfs(go, mx = 0, 0);
    if (c[0] &amp; 1)
        root = c[1 + c[0] &gt;&gt; 1];
    else {
        root = n + 1;
        bx = e[root][g[root]++] = c[c[0] &gt;&gt; 1];
        by = e[root][g[root]++] = c[(c[0] &gt;&gt; 1) + 1];
    }
    build(root, 0);
    printf(&quot;%d\n&quot;, dp(root, root));
    return 0;
}
<pre><h2>Problem3197</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf=99999999;
int son[1000000][12],stack[100000],c[100000],a[100000],b[100000],num[100000],f[100000];
int root,n,i,x,y,top,now;
bool vt[100000];
int min(int a,int b) {return a&lt;b?a:b;}
void dfs(int v,int deep)
{
	int i;
	vt[v]=1;
	stack[++top]=v;
	if (deep&gt;=c[0])
	{
		c[0]=top;
		for (i=1;i&lt;=top;i++) c[i]=stack[i];
		now=v;
	}
	for (i=1;i&lt;=num[v];i++)
		if (!vt[son[v][i]]) dfs(son[v][i],deep+1);
	top--;
}
void dfs2(int v)
{
	int t[12];
	t[0]=0;
	vt[v]=1;
	for (int i=1;i&lt;=num[v];i++)
		if (!vt[son[v][i]])
		{
			t[++t[0]]=son[v][i];
			dfs2(son[v][i]);
		}
	son[v][0]=t[0];
	for (int i=1;i&lt;=t[0];i++) son[v][i]=t[i];
}
int dp(int x,int y)
{
	int i,j;
	if (son[x][0]!=son[y][0]) return inf;
	int cost[12][12];
	for (i=1;i&lt;=son[x][0];i++)
		for (j=1;j&lt;=son[y][0];j++) cost[i][j]=dp(son[x][i],son[y][j]);
	for (i=0;i&lt;1&lt;&lt;son[x][0];i++) f[i]=inf;
	f[0]=0;
	for (i=0;i&lt;1&lt;&lt;son[x][0];i++)
		if (f[i]&lt;inf)
		{
			int cnt=0;
			for (j=1;j&lt;=son[x][0];j++)
				if (i&amp;(1&lt;&lt;(j-1))) ++cnt;
			for (j=1;j&lt;=son[x][0];j++)
				if ((i&amp;(1&lt;&lt;(j-1)))==0)
					f[i^(1&lt;&lt;(j-1))]=min(f[i^(1&lt;&lt;(j-1))],f[i]+cost[cnt+1][j]);
		}
	//printf(&quot;%d %d %d\n&quot;,x,y,f[(1&lt;&lt;son[x][0])-1]+(a[x]==b[y]?0:1));
	return (f[(1&lt;&lt;son[x][0])-1]+(a[x]==b[y]?0:1));
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		son[x][++num[x]]=y;
		son[y][++num[y]]=x;
	}
	for (i=1;i&lt;=n;scanf(&quot;%d&quot;,&amp;a[i++]));
	for (i=1;i&lt;=n;scanf(&quot;%d&quot;,&amp;b[i++]));
	dfs(1,0);
	//for (i=1;i&lt;=c[0];i++) printf(&quot;%d &quot;,c[i]);printf(&quot;\n&quot;);
	c[0]=0;
	memset(vt,0,sizeof(vt));
	dfs(now,0);
	//for (i=1;i&lt;=c[0];i++) printf(&quot;%d &quot;,c[i]);printf(&quot;\n&quot;);
	if (c[0]&amp;1) root=c[c[0]/2+1];
	else
	{
		x=c[c[0]/2];
		y=c[c[0]/2+1];
		for (i=1;i&lt;=num[x];i++)
			if (son[x][i]==y) son[x][i]=x;
		for (i=1;i&lt;=num[y];i++)
			if (son[y][i]==x) son[y][i]=y;
		root=++n;
		son[root][num[root]=1]=x;
		son[root][++num[root]]=y;
	}
	memset(vt,0,sizeof(vt));
	dfs2(root);
	//for (i=1;i&lt;=n;i++) printf(&quot;%d %d %d %d\n&quot;,i,son[i][0],son[i][1],son[i][2]);
	printf(&quot;%d\n&quot;,dp(root,root));
	return 0;
}
<pre><h2>Problem3197</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf=99999999;
int son[1000000][12],stack[100000],c[100000],a[100000],b[100000],num[100000],f[100000];
int root,n,i,x,y,top,now;
bool vt[100000];
int min(int a,int b) {return a&lt;b?a:b;}
int count(int x) {int res=0;for (;x;res++,x-=(x&amp;-x));return res;}
void dfs(int v,int deep)
{
	int i;
	vt[v]=1;
	stack[++top]=v;
	if (deep&gt;=c[0])
	{
		c[0]=top;
		for (i=1;i&lt;=top;i++) c[i]=stack[i];
		now=v;
	}
	for (i=1;i&lt;=num[v];i++)
		if (!vt[son[v][i]]) dfs(son[v][i],deep+1);
	top--;
}
void dfs2(int v)
{
	int t[12];
	t[0]=0;
	vt[v]=1;
	for (int i=1;i&lt;=num[v];i++)
		if (!vt[son[v][i]])
		{
			t[++t[0]]=son[v][i];
			dfs2(son[v][i]);
		}
	son[v][0]=t[0];
	for (int i=1;i&lt;=t[0];i++) son[v][i]=t[i];
}
int dp(int x,int y)
{
	int i,j;
	if (son[x][0]!=son[y][0]) return inf;
	int cost[12][12];
	for (i=1;i&lt;=son[x][0];i++)
		for (j=1;j&lt;=son[y][0];j++) cost[i][j]=dp(son[x][i],son[y][j]);
	for (i=0;i&lt;1&lt;&lt;son[x][0];i++) f[i]=inf;
	f[0]=0;
	for (i=1;i&lt;1&lt;&lt;son[x][0];i++)
		/*if (f[i]&lt;inf)
		{
			int cnt=0;
			for (j=1;j&lt;=son[x][0];j++)
				if (i&amp;(1&lt;&lt;(j-1))) ++cnt;
			for (j=1;j&lt;=son[x][0];j++)
				if ((i&amp;(1&lt;&lt;(j-1)))==0)
					f[i^(1&lt;&lt;(j-1))]=min(f[i^(1&lt;&lt;(j-1))],f[i]+cost[cnt+1][j]);
		}*/
		for (j=1;j&lt;=son[x][0];j++)
			if (i&amp;(1&lt;&lt;(j-1)))
			{
				int tmp=count(i);
				f[i]=min(f[i],f[i^(1&lt;&lt;(j-1))]+cost[tmp][j]);
			}
	//printf(&quot;%d %d %d\n&quot;,x,y,f[(1&lt;&lt;son[x][0])-1]+(a[x]==b[y]?0:1));
	return (f[(1&lt;&lt;son[x][0])-1]+(a[x]==b[y]?0:1));
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		son[x][++num[x]]=y;
		son[y][++num[y]]=x;
	}
	for (i=1;i&lt;=n;scanf(&quot;%d&quot;,&amp;a[i++]));
	for (i=1;i&lt;=n;scanf(&quot;%d&quot;,&amp;b[i++]));
	dfs(1,0);
	//for (i=1;i&lt;=c[0];i++) printf(&quot;%d &quot;,c[i]);printf(&quot;\n&quot;);
	c[0]=0;
	memset(vt,0,sizeof(vt));
	dfs(now,0);
	//for (i=1;i&lt;=c[0];i++) printf(&quot;%d &quot;,c[i]);printf(&quot;\n&quot;);
	if (c[0]&amp;1) root=c[c[0]/2+1];
	else
	{
		x=c[c[0]/2];
		y=c[c[0]/2+1];
		for (i=1;i&lt;=num[x];i++)
			if (son[x][i]==y) son[x][i]=x;
		for (i=1;i&lt;=num[y];i++)
			if (son[y][i]==x) son[y][i]=y;
		root=++n;
		son[root][num[root]=1]=x;
		son[root][++num[root]]=y;
	}
	memset(vt,0,sizeof(vt));
	dfs2(root);
	//for (i=1;i&lt;=n;i++) printf(&quot;%d %d %d %d\n&quot;,i,son[i][0],son[i][1],son[i][2]);
	printf(&quot;%d\n&quot;,dp(root,root));
	return 0;
}
<pre><h2>Problem3197</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf=99999999;
int son[1000000][12],stack[100000],c[100000],a[100000],b[100000],num[100000],f[100000];
int root,n,i,x,y,top,now;
bool vt[100000];
int min(int a,int b) {return a&lt;b?a:b;}
void dfs(int v,int deep)
{
    int i;
    vt[v]=1;
    stack[++top]=v;
    if (deep&gt;=c[0])
    {
        c[0]=top;
        for (i=1;i&lt;=top;i++) c[i]=stack[i];
        now=v;
    }
    for (i=1;i&lt;=num[v];i++)
        if (!vt[son[v][i]]) dfs(son[v][i],deep+1);
    top--;
}
void dfs2(int v)
{
    int t[12];
    t[0]=0;
    vt[v]=1;
    for (int i=1;i&lt;=num[v];i++)
        if (!vt[son[v][i]])
        {
            t[++t[0]]=son[v][i];
            dfs2(son[v][i]);
        }
    son[v][0]=t[0];
    for (int i=1;i&lt;=t[0];i++) son[v][i]=t[i];
}
int dp(int x,int y)
{
    int i,j;
    if (son[x][0]!=son[y][0]) return inf;
    int cost[12][12];
    for (i=1;i&lt;=son[x][0];i++)
        for (j=1;j&lt;=son[y][0];j++) cost[i][j]=dp(son[x][i],son[y][j]);
    for (i=0;i&lt;1&lt;&lt;son[x][0];i++) f[i]=inf;
    f[0]=0;
    for (i=0;i&lt;1&lt;&lt;son[x][0];i++)
        if (f[i]&lt;inf)
        {
            int cnt=0;
            for (j=1;j&lt;=son[x][0];j++)
                if (i&amp;(1&lt;&lt;(j-1))) ++cnt;
            for (j=1;j&lt;=son[x][0];j++)
                if ((i&amp;(1&lt;&lt;(j-1)))==0)
                    f[i^(1&lt;&lt;(j-1))]=min(f[i^(1&lt;&lt;(j-1))],f[i]+cost[cnt+1][j]);
        }
    return (f[(1&lt;&lt;son[x][0])-1]+(a[x]==b[y]?0:1));
}
int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    for (i=1;i&lt;n;i++)
    {
        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
        son[x][++num[x]]=y;
        son[y][++num[y]]=x;
    }
    for (i=1;i&lt;=n;scanf(&quot;%d&quot;,&amp;a[i++]));
    for (i=1;i&lt;=n;scanf(&quot;%d&quot;,&amp;b[i++]));
    dfs(1,0);
    //for (i=1;i&lt;=c[0];i++) printf(&quot;%d &quot;,c[i]);printf(&quot;\n&quot;);
    c[0]=0;
    memset(vt,0,sizeof(vt));
    dfs(now,0);
    if (c[0]&amp;1) root=c[c[0]/2+1];
    else
    {
        x=c[c[0]/2];
        y=c[c[0]/2+1];
        for (i=1;i&lt;=num[x];i++)
            if (son[x][i]==y) son[x][i]=x;
        for (i=1;i&lt;=num[y];i++)
            if (son[y][i]==x) son[y][i]=y;
        root=++n;
        son[root][num[root]=1]=x;
        son[root][++num[root]]=y;
    }
    memset(vt,0,sizeof(vt));
    dfs2(root);
    printf(&quot;%d\n&quot;,dp(root,root));
    return 0;
}<pre><h2>Problem3198</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;functional&gt;
#include&lt;cmath&gt;
#include&lt;cctype&gt;
#include&lt;map&gt;
using namespace std;
#define For(i,n) for(int i=1;i&lt;=n;i++)
#define Rep(i,n) for(int i=0;i&lt;n;i++)
#define Fork(i,k,n) for(int i=k;i&lt;=n;i++)
#define ForD(i,n) for(int i=n;i;i--)
#define ForkD(i,k,n) for(int i=n;i&gt;=k;i--)
#define Forp(x) for(int p=pre[x];p;p=next[p])
#define RepD(i,n) for(int i=n;i&gt;=0;i--)
#define MEM(a) memset(a,0,sizeof(a))
#define MEMI(a) memset(a,127,sizeof(a))
#define MEMi(a) memset(a,128,sizeof(a))
#define INF (2139062143)
#define F (300007)
#define MAXN (100000+10)
#define BASE (13131)
#define MAXK (6+1)
int n,k; 
long long a[MAXN][7];
int bin[7]={0,1,2,4,8,16,32};
long long h[F+10],hnum[F+10][7];
int st[MAXN],size=0;
bool equal(long long h1[7],long long h2[7],int p)
{
	For(j,6) if (p&amp;bin[j]) if (h1[j]^h2[j]) return 0;
	return 1; 
}
int hash(int i,int p)
{
	long long ans=0;
	For(j,6) if (p&amp;bin[j]) ans=(ans*BASE+a[i][j])%F;
	while (h[ans]&gt;0&amp;&amp;(!equal(hnum[ans],a[i],p))) ans=(ans+1)%F;
	memcpy(hnum[ans],a[i],sizeof(hnum[ans])); 
	return ans;
}
long long ans[MAXN]={0};
int bitcount(int p)
{
	int i=0;
	For(j,6) if (bin[j]&amp;p) i++;
	return i;
}
long long calc(int p)
{
	long long ans=0;
	size=0;
	For(i,n)
	{
		int t=hash(i,p);
		h[t]++;st[++size]=t;
	}
	For(i,size)
		if (h[st[i]])
		{
			ans+=h[st[i]]*(h[st[i]]-1)/2;						
			h[st[i]]=0;memset(hnum[st[i]],0,sizeof(hnum[st[i]]) );
		} 
	return ans;
}
long long C[MAXK*2][MAXK*2]={0};
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
	For(i,n) For(j,6) scanf(&quot;%lld&quot;,&amp;a[i][j]);
	For(i,64)
	{
		long long delta=calc(i);
		if (delta) ans[bitcount(i)]+=delta;//,cout&lt;&lt;i&lt;&lt;' ';
	}
	C[0][0]=1;
	For(i,12)
	{
		C[i][0]=1;C[i][1]=i;
		Fork(j,2,12) C[i][j]=C[i-1][j]+C[i-1][j-1];
	}
	ForkD(i,k,6) 
	{
		Fork(j,i+1,6) ans[i]-=C[j][j-i]*ans[j];
	}
	cout&lt;&lt;ans[k];
	return 0;
}<pre><h2>Problem3198</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;functional&gt;
#include&lt;cmath&gt;
#include&lt;cctype&gt;
#include&lt;map&gt;
using namespace std;
#define For(i,n) for(int i=1;i&lt;=n;i++)
#define Rep(i,n) for(int i=0;i&lt;n;i++)
#define Fork(i,k,n) for(int i=k;i&lt;=n;i++)
#define ForD(i,n) for(int i=n;i;i--)
#define ForkD(i,k,n) for(int i=n;i&gt;=k;i--)
#define Forp(x) for(int p=pre[x];p;p=next[p])
#define RepD(i,n) for(int i=n;i&gt;=0;i--)
#define MEM(a) memset(a,0,sizeof(a))
#define MEMI(a) memset(a,127,sizeof(a))
#define MEMi(a) memset(a,128,sizeof(a))
#define INF (2139062143)
#define F (300007)
#define MAXN (100000+10)
#define BASE (13131)
#define MAXK (6+1)
int n,k; 
long long a[MAXN][7];
int bin[7]={0,1,2,4,8,16,32};
long long h[F+10],hnum[F+10][7];
int st[MAXN],size=0;
bool equal(long long h1[7],long long h2[7],int p)
{
	For(j,6) if (p&amp;bin[j]) if (h1[j]^h2[j]) return 0;
	return 1; 
}
int hash(int i,int p)
{
	long long ans=0;
	For(j,6) if (p&amp;bin[j]) ans=(ans*BASE+a[i][j])%F;
	while (h[ans]&gt;0&amp;&amp;(!equal(hnum[ans],a[i],p))) ans=(ans+1)%F;
	memcpy(hnum[ans],a[i],sizeof(hnum[ans])); 
	return ans;
}
long long ans[MAXN]={0};
int bitcount(int p)
{
	int i=0;
	For(j,6) if (bin[j]&amp;p) i++;
	return i;
}
long long calc(int p)
{
	long long ans=0;
	size=0;
	For(i,n)
	{
		int t=hash(i,p);
		h[t]++;st[++size]=t;
	}
	For(i,size)
		if (h[st[i]])
		{
			ans+=h[st[i]]*(h[st[i]]-1)/2;						
			h[st[i]]=0;memset(hnum[st[i]],0,sizeof(hnum[st[i]]) );
		} 
	return ans;
}
long long C[MAXK*2][MAXK*2]={0};
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
	For(i,n) For(j,6) scanf(&quot;%lld&quot;,&amp;a[i][j]);
	For(i,64)
	{
		long long delta=calc(i);
		if (delta) ans[bitcount(i)]+=delta;//,cout&lt;&lt;i&lt;&lt;' ';
	}
	C[0][0]=1;
	For(i,12)
	{
		C[i][0]=1;C[i][1]=i;
		Fork(j,2,12) C[i][j]=C[i-1][j]+C[i-1][j-1];
	}
	ForkD(i,k,6) 
	{
		Fork(j,i+1,6) ans[i]-=C[j][i]*ans[j];
	}
	cout&lt;&lt;ans[k];
	return 0;
}<pre><h2>Problem3198</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define LL long long
#define ln printf(&quot;\n&quot;)
const int mo=1000007,p1=723,p2=19980723;
int o[mo+100],a[101111][7],num[1000000],aa[1000000][2],fac[10],hash2[101111],mi2[10];
int n,tot,K;
LL f[10],g[10],mi1[10],hash1[101111];
void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
	num[tot]=1;
}
LL calc(int x)
{
	//printf(&quot;\n--------- calc %d -----------------------------------------\n&quot;,x);
	memset(hash1,0,sizeof(hash1));
	memset(hash2,0,sizeof(hash2));
	memset(o,0,sizeof(o));
	memset(num,0,sizeof(num));
	tot=1;
	int i,j;
	for (i=1;i&lt;=6;i++)
		if (x&amp;(1&lt;&lt;(i-1)))
			for (j=1;j&lt;=n;j++)
			{
				hash1[j]=(hash1[j]+mi1[i]*a[j][i])%mo;
				hash2[j]+=mi2[i]*a[j][i];
			}
	//printf(&quot;hash1 &quot;);for(i=1;i&lt;=n;i++)printf(&quot;%lld &quot;,hash1[i]);ln;
	//printf(&quot;hash2 &quot;);for(i=1;i&lt;=n;i++)printf(&quot;%d &quot;,hash2[i]);ln;
	LL res=0;
	for (i=1;i&lt;=n;i++)
	{
		bool flag=false;
		for (int p=o[hash1[i]];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==hash2[i])
			{
				res+=num[p];
				//printf(&quot;num[p]=%d\n&quot;,num[p]);
				num[p]++;
				flag=true;
			}
		}
		if (!flag) addedge(hash1[i],hash2[i]);
	}
	return res;
}
int count(int x)
{
	int res=0;
	for (;x;x-=(x&amp;-x)) res++;
	return res;
}
int C(int n,int m)
{
	return fac[n]/fac[m]/fac[n-m];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	int i,j;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=6;j++) scanf(&quot;%d&quot;,&amp;a[i][j]);
	for (fac[0]=1,i=1;i&lt;=6;i++) fac[i]=fac[i-1]*i;
	for (mi1[0]=mi2[0]=1,i=1;i&lt;=6;i++)
	{
		mi1[i]=mi1[i-1]*p1%mo;
		mi2[i]=mi2[i-1]*p2;
	}
	for (i=0;i&lt;=((1&lt;&lt;6)-1);i++) f[count(i)]+=calc(i);
	//for (i=0;i&lt;=6;i++) printf(&quot;%lld &quot;,f[i]);ln;
	g[6]=f[6];
	for (i=5;i&gt;=K;i--)
	{
		LL tmp=0;
		for (j=i+1;j&lt;=6;j++) tmp+=C(j,i)*g[j];
		g[i]=f[i]-tmp;
	}
	printf(&quot;%lld\n&quot;,g[K]);
	return 0;
}
<pre><h2>Problem3198</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define LL long long
#define ln printf(&quot;\n&quot;)
const int mo=3000007,p1=723,p2=19980723;
int o[mo+100],a[101111][7],num[1000000],aa[1000000][2],fac[10],hash2[101111],mi2[10];
int n,tot,K;
LL f[10],g[10],mi1[10],hash1[101111];
void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
	num[tot]=1;
}
LL calc(int x)
{
	//printf(&quot;\n--------- calc %d -----------------------------------------\n&quot;,x);
	memset(hash1,0,sizeof(hash1));
	memset(hash2,0,sizeof(hash2));
	memset(o,0,sizeof(o));
	memset(num,0,sizeof(num));
	tot=1;
	int i,j;
	for (i=1;i&lt;=6;i++)
		if (x&amp;(1&lt;&lt;(i-1)))
			for (j=1;j&lt;=n;j++)
			{
				hash1[j]=(hash1[j]+mi1[i]*a[j][i])%mo;
				hash2[j]+=mi2[i]*a[j][i];
			}
	//printf(&quot;hash1 &quot;);for(i=1;i&lt;=n;i++)printf(&quot;%lld &quot;,hash1[i]);ln;
	//printf(&quot;hash2 &quot;);for(i=1;i&lt;=n;i++)printf(&quot;%d &quot;,hash2[i]);ln;
	LL res=0;
	for (i=1;i&lt;=n;i++)
	{
		bool flag=false;
		for (int p=o[hash1[i]];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==hash2[i])
			{
				res+=num[p];
				//printf(&quot;num[p]=%d\n&quot;,num[p]);
				num[p]++;
				flag=true;
			}
		}
		if (!flag) addedge(hash1[i],hash2[i]);
	}
	return res;
}
int count(int x)
{
	int res=0;
	for (;x;x-=(x&amp;-x)) res++;
	return res;
}
int C(int n,int m)
{
	return fac[n]/fac[m]/fac[n-m];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	int i,j;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=6;j++) scanf(&quot;%d&quot;,&amp;a[i][j]);
	for (fac[0]=1,i=1;i&lt;=6;i++) fac[i]=fac[i-1]*i;
	for (mi1[0]=mi2[0]=1,i=1;i&lt;=6;i++)
	{
		mi1[i]=mi1[i-1]*p1%mo;
		mi2[i]=mi2[i-1]*p2;
	}
	for (i=0;i&lt;=((1&lt;&lt;6)-1);i++) f[count(i)]+=calc(i);
	//for (i=0;i&lt;=6;i++) printf(&quot;%lld &quot;,f[i]);ln;
	g[6]=f[6];
	for (i=5;i&gt;=K;i--)
	{
		LL tmp=0;
		for (j=i+1;j&lt;=6;j++) tmp+=C(j,i)*g[j];
		g[i]=f[i]-tmp;
	}
	printf(&quot;%lld\n&quot;,g[K]);
	return 0;
}
<pre><h2>Problem3199</h2><pre>type orz=record
x,y:extended;
end;
orzpz=record
a,b,c:extended;
end;
var test,tttt,i,j,k,m,n,x,y,ans,sum,tot,num,s,t,mm,head,tail:longint;
last,d:array[1..602]of longint;
next,a:array[1..1000000]of longint;
q:array[1..10000]of longint;
aans:array[0..600]of longint;
p:array[0..600]of orz;
zcx:array[1..600,1..600]of orzpz;
list,l:array[1..700]of orz;
dingdian:array[1..5]of orz;
pp:array[1..2]of orz;
bianjie:array[1..4]of orzpz;
ttt:boolean;
tt:array[1..602]of boolean;
mx,my:extended;
function chaji(p1,p2,p3:orz):extended;
begin exit((p1.x-p3.x)*(p2.y-p3.y)-(p2.x-p3.x)*(p1.y-p3.y)); end;
function zzcx(p1,p2:orz):orzpz;
var aa,bb,cc:extended;
begin
  aa:=p2.x-p1.x;
  bb:=p2.y-p1.y;
  cc:=-aa*(p1.x+p2.x)/2-bb*(p1.y+p2.y)/2;
  zzcx.a:=aa;
  zzcx.b:=bb;
  zzcx.c:=cc;
end;
procedure swap(var p1,p2:orz);
var ppp:orz;
begin
  ppp:=p1;
  p1:=p2;
  p2:=ppp;
end;
function oon(z:orzpz;p1:orz):boolean;
begin
  if abs(p1.x*z.a+p1.y*z.b+z.c)&lt;=1e-8 then exit(true) else exit(false);
end;
function lianxian(p1,p2:orz):orzpz;
var aa,bb,cc:extended;
begin
  lianxian.a:=p1.y-p2.y;
  lianxian.b:=p2.x-p1.x;
  lianxian.c:=-lianxian.a*p1.x-lianxian.b*p1.y;
end;
procedure qiujiao(x1,x2:orzpz);
var xx,yy,zz:extended;
ii:longint;
begin
  zz:=x1.a*x2.b-x2.a*x1.b;
  if abs(zz)&lt;=1e-8 then exit;
  xx:=(x1.b*x2.c-x2.b*x1.c)/zz;
  yy:=(x2.a*x1.c-x1.a*x2.c)/zz;
  for ii:=1 to 4 do if (abs(dingdian[ii].x-xx)&lt;1e-8)and(abs(dingdian[ii].y-yy)&lt;1e-8) then exit;
  if (xx&gt;=0)and(xx&lt;=mx)and(yy&gt;=0)and(yy&lt;=my) then begin inc(sum);pp[sum].x:=xx;pp[sum].y:=yy; end;
end;
function qiujiao2(x1,x2:orzpz):orz;
var zz:extended;
begin
  zz:=x1.a*x2.b-x2.a*x1.b;
  qiujiao2.x:=(x1.b*x2.c-x2.b*x1.c)/zz;
  qiujiao2.y:=(x2.a*x1.c-x1.a*x2.c)/zz;
end;
function work(p1,p2,p3,p4:orz):orz;
var x1,x2:orzpz;
begin
  x1:=lianxian(p1,p2);
  x2:=lianxian(p3,p4);
  exit(qiujiao2(x1,x2));
end;
procedure build(xx,yy:longint);
begin
  inc(mm);
  a[mm]:=yy;
  next[mm]:=last[xx];
  last[xx]:=mm;
  inc(mm);
  a[mm]:=xx;
  next[mm]:=last[yy];
  last[yy]:=mm;
end;
begin
//assign(input,'1.in');reset(input);assign(output,'2.out');rewrite(output);
  read(tttt);
  for test:=1 to tttt do begin
    fillchar(last,sizeof(last),0);
    read(n);
    t:=n+1;
    read(mx,my,p[0].x,p[0].y);
    for i:=1 to n do read(p[i].x,p[i].y);
    for i:=2 to n do for j:=1 to i-1 do begin
      zcx[i,j]:=zzcx(p[i],p[j]);
      zcx[j,i]:=zcx[i,j];
    end;
    dingdian[1].x:=0;
    dingdian[1].y:=0;
    dingdian[2].x:=mx;
    dingdian[2].y:=0;
    dingdian[3].x:=mx;
    dingdian[3].y:=my;
    dingdian[4].x:=0;
    dingdian[4].y:=my;
    dingdian[5]:=dingdian[1];
    aans[0]:=0;
    for i:=1 to 4 do bianjie[i]:=lianxian(dingdian[i],dingdian[i+1]);
    for i:=1 to n do begin
      num:=5;
      for j:=1 to 5 do list[j]:=dingdian[j];
      for j:=1 to n do if i&lt;&gt;j then begin
        sum:=0;
        for k:=1 to 4 do if oon(zcx[i,j],dingdian[k]) then begin inc(sum); pp[sum]:=dingdian[k]; end;
        if sum&lt;2 then for k:=1 to 4 do begin qiujiao(bianjie[k],zcx[i,j]); if sum=2 then break; end;
        if sum&lt;2 then continue;
        if chaji(pp[2],p[i],pp[1])&lt;0 then swap(pp[1],pp[2]);
        tot:=0;
        for k:=1 to num-1 do begin
          if chaji(list[k],pp[2],pp[1])&lt;=0 then begin inc(tot); l[tot]:=list[k]; end;
          if chaji(list[k],pp[2],pp[1])*chaji(list[k+1],pp[2],pp[1])&lt;0 then begin inc(tot); l[tot]:=work(pp[1],pp[2],list[k],list[k+1]); end;
        end;
        list:=l;
        num:=tot+1;
        list[num]:=list[1];
      end;
      ttt:=true;
      for j:=1 to num-1 do if chaji(list[j+1],p[0],list[j])&lt;0 then begin ttt:=false; break; end;
      if ttt then begin inc(aans[0]);aans[aans[0]]:=i; end;
      for j:=1 to num-1 do begin
        ttt:=true;
        for k:=1 to 4 do if oon(bianjie[k],list[j]) and oon(bianjie[k],list[j+1]) then begin build(i,t); ttt:=false; break; end;
        if ttt then for k:=1 to n do if (k&lt;&gt;i)and oon(zcx[i,k],list[j]) and oon(zcx[i,k],list[j+1]) then begin build(i,k); break; end;
      end;
    end;
    head:=0;
    tail:=0;
    fillchar(tt,sizeof(tt),false);
    for i:=1 to aans[0] do begin
      d[aans[i]]:=aans[0];
      inc(tail);
      q[tail]:=aans[i];
      tt[aans[i]]:=true;
    end;
    ttt:=false;
    while head&lt;tail do begin
      inc(head);
      x:=q[head];
      j:=last[x];
      while j&lt;&gt;0 do begin
        if not tt[a[j]] then if a[j]=t then begin d[t]:=d[x]; ttt:=true; break; end
                                             else begin tt[a[j]]:=true; inc(tail); q[tail]:=a[j]; d[a[j]]:=d[x]+1; end;
        j:=next[j];
      end;
      if ttt then break;
    end;
    writeln(d[t]);
  end;
end.<pre><h2>Problem3199</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
using namespace std;
#define LD long double
#define DD double
#define inf 999999999
#define ln printf(&quot;\n&quot;)
const LD eps=1e-8,pai=3.14159265358979;
int n,tes,belong[2][10000],now,num[2],o[10000],aa[10000000][2],tot,q[10000],deep[10000],map[1000][1000];
bool vt[10000],yes;
int dcmp(LD x)
{
	if (fabs(x)&lt;eps) return 0;
	return x&lt;0?-1:1;
}
struct point
{
	LD x,y;
	//void out() {printf(&quot;%.3f %.3f\n&quot;,x,y);}
	point(LD a=0,LD b=0) {x=a;y=b;}
	friend LD operator %(point a,point b) {return a.x*b.y-b.x*a.y;}
	friend point operator +(point a,point b) {a.x+=b.x;a.y+=b.y;return a;}
	friend point operator -(point a,point b) {a.x-=b.x;a.y-=b.y;return a;}
	friend point operator *(LD t,point a) {a.x*=t,a.y*=t;return a;}
} b[2][1000],pos[1000],S,T;
point rotate(point v,LD sita)
{
	point tmp;
	tmp.x=v.x*cos(sita)-v.y*sin(sita);
	tmp.y=v.y*cos(sita)+v.x*sin(sita);
	return tmp;
}
bool linesegxj(point P,point v,point A,point B)
{
	int t1=dcmp(v%(A-P)),t2=dcmp(v%(B-P));
	//if (yes) printf(&quot;t1=%d t2=%d\n&quot;,t1,t2);
	return t1*t2==-1;
}
point linejd(point P,point v,point Q,point w)
{
	point u=P-Q;
	LD t=(w%u)/(v%w);
	return P+t*v;
}
void ins(point P,point v,int id)
{
	b[now][++num[now]]=b[now][1];
	now^=1;
	num[now]=0;
	for (int i=1;i&lt;num[now^1];i++)
	{
		point A=b[now^1][i],B=b[now^1][i+1];
		//if (yes)printf(&quot;A: &quot;);A.out();printf(&quot;B: &quot;),B.out();
		if (dcmp(v%(A-P))&gt;=0)
		{
			b[now][++num[now]]=A;
			belong[now][num[now]]=belong[now^1][i];
		}
		if (linesegxj(P,v,A,B))
		{
			b[now][++num[now]]=linejd(P,v,A,B-A);
			//if (yes)printf(&quot;jd: &quot;);b[now][num[now]].out();
			int t=dcmp(v%(A-P));
			if (t==1) belong[now][num[now]]=id;
			else belong[now][num[now]]=belong[now^1][i];
		}
	}
	//if (yes) {printf(&quot;now:\n&quot;);for (int i=1;i&lt;=num[now];i++) printf(&quot;%lf %lf\n&quot;,b[now][i].x,b[now][i].y);
	//for (int i=1;i&lt;=num[now];i++) printf(&quot;%d &quot;,belong[now][i]);ln;ln;}
}
LD lenth(point a) {return sqrt(a.x*a.x+a.y*a.y);}
void addedge(int p,int q)
{
	//printf(&quot;addedge %d %d\n&quot;,p,q);
	map[p][q]=1;
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	//freopen(&quot;3199.in&quot;,&quot;r&quot;,stdin);freopen(&quot;3199.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		//printf(&quot;\n------------------------------------------------------------\n&quot;);
		scanf(&quot;%d&quot;,&amp;n);
		double x1,x2,x3,x4;
		scanf(&quot;%lf%lf%lf%lf&quot;,&amp;x1,&amp;x2,&amp;x3,&amp;x4);
		T.x=x1,T.y=x2,S.x=x3,S.y=x4;
		LD mm=inf;
		int i,j,SS=0,TT=0,head,tail;
		for (i=1;i&lt;=n;i++)
		{
			scanf(&quot;%lf%lf&quot;,&amp;x1,&amp;x2);
			pos[i]=point(x1,x2);
			if (lenth(S-pos[i])&lt;mm) mm=lenth(S-pos[i]),SS=i;
		}
		//printf(&quot;SS=%d TT=%d\n&quot;,SS,TT);
		if (n==1) {printf(&quot;1\n&quot;);continue;}
		memset(map,0,sizeof(map));
		memset(o,0,sizeof(o));
		tot=1;
		for (i=1;i&lt;=n;i++)
		{
			//printf(&quot;======= calc %d =======\n&quot;,i);
			if (i==1) yes=true;
			now=0;
			num[0]=4;
			b[0][1]=point(0,0),belong[0][1]=0;
			b[0][2]=point(T.x,0),belong[0][2]=0;
			b[0][3]=point(T.x,T.y),belong[0][3]=0;
			b[0][4]=point(0,T.y),belong[0][4]=0;
			for (j=1;j&lt;=n;j++)
				if (i!=j)
				{
					point P=point((pos[i].x+pos[j].x)/2,(pos[i].y+pos[j].y)/2);
					point v=rotate(point(pos[j]-pos[i]),pai/2);
					//if (yes) printf(&quot;ins %d: %.3f %.3f  %.3f %.3f\n&quot;,j,P.x,P.y,v.x,v.y);
					ins(P,v,j);
				}
			for (j=1;j&lt;=now[num];j++)
				if (!map[i][belong[now][j]])
				{
					addedge(i,belong[now][j]);
					addedge(belong[now][j],i);
				}
			yes=false;
		}
		memset(vt,0,sizeof(vt));
		vt[SS]=true;
		head=0,q[tail=1]=SS;
		deep[SS]=0;
		while (head&lt;tail)
		{
			int x=q[++head];
			for (int p=o[x];p;p=aa[p][0])
			{
				int y=aa[p][1];
				if (!vt[y])
				{
					vt[y]=true;
					deep[y]=deep[x]+1;
					q[++tail]=y;
				}
			}
		}
		printf(&quot;%d\n&quot;,deep[TT]);
	}
	return 0;
}
<pre><h2>Problem3199</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
using namespace std;
#define LD long double
#define DD double
#define inf 999999999
#define ln printf(&quot;\n&quot;)
const LD eps=1e-8,pai=3.14159265358979;
int n,tes,belong[2][10000],now,num[2],o[10000],aa[10000000][2],tot,q[10000],deep[10000],map[1000][1000];
bool vt[10000],yes;
int dcmp(LD x)
{
	if (fabs(x)&lt;eps) return 0;
	return x&lt;0?-1:1;
}
struct point
{
	LD x,y;
	point(LD a=0,LD b=0) {x=a;y=b;}
	friend LD operator %(point a,point b) {return a.x*b.y-b.x*a.y;}
	friend point operator +(point a,point b) {a.x+=b.x;a.y+=b.y;return a;}
	friend point operator -(point a,point b) {a.x-=b.x;a.y-=b.y;return a;}
	friend point operator *(LD t,point a) {a.x*=t,a.y*=t;return a;}
} b[2][1000],pos[1000],S,T;
point rotate(point v,LD sita)
{
	point tmp;
	tmp.x=v.x*cos(sita)-v.y*sin(sita);
	tmp.y=v.y*cos(sita)+v.x*sin(sita);
	return tmp;
}
bool linesegxj(point P,point v,point A,point B)
{
	int t1=dcmp(v%(A-P)),t2=dcmp(v%(B-P));
	return t1*t2==-1;
}
point linejd(point P,point v,point Q,point w)
{
	point u=P-Q;
	LD t=(w%u)/(v%w);
	return P+t*v;
}
void ins(point P,point v,int id)
{
	b[now][++num[now]]=b[now][1];
	now^=1;
	num[now]=0;
	for (int i=1;i&lt;num[now^1];i++)
	{
		point A=b[now^1][i],B=b[now^1][i+1];
		if (dcmp(v%(A-P))&gt;=0)
		{
			b[now][++num[now]]=A;
			belong[now][num[now]]=belong[now^1][i];
		}
		if (linesegxj(P,v,A,B))
		{
			b[now][++num[now]]=linejd(P,v,A,B-A);
			int t=dcmp(v%(A-P));
			if (t==1) belong[now][num[now]]=id;
			else belong[now][num[now]]=belong[now^1][i];
		}
	}
}
LD lenth(point a) {return sqrt(a.x*a.x+a.y*a.y);}
void addedge(int p,int q)
{
	map[p][q]=1;
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		double x1,x2,x3,x4;
		scanf(&quot;%lf%lf%lf%lf&quot;,&amp;x1,&amp;x2,&amp;x3,&amp;x4);
		T.x=x1,T.y=x2,S.x=x3,S.y=x4;
		LD mm=inf;
		int i,j,SS=0,TT=0,head,tail;
		for (i=1;i&lt;=n;i++)
		{
			scanf(&quot;%lf%lf&quot;,&amp;x1,&amp;x2);
			pos[i]=point(x1,x2);
			if (lenth(S-pos[i])&lt;mm) mm=lenth(S-pos[i]),SS=i;
		}
		if (n==1) {printf(&quot;1\n&quot;);continue;}
		memset(map,0,sizeof(map));
		memset(o,0,sizeof(o));
		tot=1;
		for (i=1;i&lt;=n;i++)
		{
			if (i==1) yes=true;
			now=0;
			num[0]=4;
			b[0][1]=point(0,0),belong[0][1]=0;
			b[0][2]=point(T.x,0),belong[0][2]=0;
			b[0][3]=point(T.x,T.y),belong[0][3]=0;
			b[0][4]=point(0,T.y),belong[0][4]=0;
			for (j=1;j&lt;=n;j++)
				if (i!=j)
				{
					point P=point((pos[i].x+pos[j].x)/2,(pos[i].y+pos[j].y)/2);
					point v=rotate(point(pos[j]-pos[i]),pai/2);
					ins(P,v,j);
				}
			for (j=1;j&lt;=now[num];j++)
				if (!map[i][belong[now][j]])
				{
					addedge(i,belong[now][j]);
					addedge(belong[now][j],i);
				}
			yes=false;
		}
		memset(vt,0,sizeof(vt));
		vt[SS]=true;
		head=0,q[tail=1]=SS;
		deep[SS]=0;
		while (head&lt;tail)
		{
			int x=q[++head];
			for (int p=o[x];p;p=aa[p][0])
			{
				int y=aa[p][1];
				if (!vt[y])
				{
					vt[y]=true;
					deep[y]=deep[x]+1;
					q[++tail]=y;
				}
			}
		}
		printf(&quot;%d\n&quot;,deep[TT]);
	}
	return 0;
}
<pre><h2>Problem3199</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
using namespace std;
#define LD long double
#define DD double
#define inf 999999999
const LD eps=1e-8,pai=3.14159265358979;
int n,tes,belong[2][10000],now,num[2],o[10000],aa[10000000][2],tot,q[10000],deep[10000];
bool vt[10000];
int dcmp(LD x)
{
    if (fabs(x)&lt;eps) return 0;
    return x&lt;0?-1:1;
}
struct point
{
    LD x,y;
    point(LD a=0,LD b=0) {x=a;y=b;}
    friend LD operator %(point a,point b) {return a.x*b.y-b.x*a.y;}
    friend point operator +(point a,point b) {a.x+=b.x;a.y+=b.y;return a;}
    friend point operator -(point a,point b) {a.x-=b.x;a.y-=b.y;return a;}
    friend point operator *(LD t,point a) {a.x*=t,a.y*=t;return a;}
} b[2][1000],pos[1000],S,T;
point rotate(point v,LD sita)
{
    point tmp;
    tmp.x=v.x*cos(sita)-v.y*sin(sita);
    tmp.y=v.y*cos(sita)+v.x*sin(sita);
    return tmp;
}
bool linesegxj(point P,point v,point A,point B)
{
    int t1=dcmp(v%(A-P)),t2=dcmp(v%(B-P));
    return t1*t2==-1;
}
point linejd(point P,point v,point Q,point w)
{
    point u=P-Q;
    LD t=(w%u)/(v%w);
    return P+t*v;
}
void ins(point P,point v,int id)
{
    b[now][++num[now]]=b[now][1];
    now^=1;
    num[now]=0;
    for (int i=1;i&lt;num[now^1];i++)
    {
        point A=b[now^1][i],B=b[now^1][i+1];
        if (dcmp(v%(A-P))&gt;=0)
        {
            b[now][++num[now]]=A;
            belong[now][num[now]]=belong[now^1][i];
        }
        if (linesegxj(P,v,A,B))
        {
            b[now][++num[now]]=linejd(P,v,A,B-A);
            int t=dcmp(v%(A-P));
            if (t==1) belong[now][num[now]]=id;
            else belong[now][num[now]]=belong[now^1][i];
        }
    }
}
LD lenth(point a) {return sqrt(a.x*a.x+a.y*a.y);}
void addedge(int p,int q)
{
    tot++;
    aa[tot][1]=q;
    aa[tot][0]=o[p];
    o[p]=tot;
}
int main()
{
    for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
    {
        scanf(&quot;%d&quot;,&amp;n);
        double x1,x2,x3,x4;
        scanf(&quot;%lf%lf%lf%lf&quot;,&amp;x1,&amp;x2,&amp;x3,&amp;x4);
        T.x=x1,T.y=x2,S.x=x3,S.y=x4;
        LD mm=inf;
        int i,j,SS=0,TT=0,head,tail;
        for (i=1;i&lt;=n;i++)
        {
            scanf(&quot;%lf%lf&quot;,&amp;x1,&amp;x2);
            pos[i]=point(x1,x2);
            if (lenth(S-pos[i])&lt;mm) mm=lenth(S-pos[i]),SS=i;
        }
        if (n==1) {printf(&quot;1\n&quot;);continue;}
        memset(o,0,sizeof(o));
        tot=1;
        for (i=1;i&lt;=n;i++)
        {
            now=0;
            num[0]=4;
            b[0][1]=point(0,0),belong[0][1]=0;
            b[0][2]=point(T.x,0),belong[0][2]=0;
            b[0][3]=point(T.x,T.y),belong[0][3]=0;
            b[0][4]=point(0,T.y),belong[0][4]=0;
            for (j=1;j&lt;=n;j++)
                if (i!=j)
                {
                    point P=point((pos[i].x+pos[j].x)/2,(pos[i].y+pos[j].y)/2);
                    point v=rotate(point(pos[j]-pos[i]),pai/2);
                    ins(P,v,j);
                }
            for (j=1;j&lt;=now[num];j++)
            {
                addedge(i,belong[now][j]);
                addedge(belong[now][j],i);
            }
        }
        memset(vt,0,sizeof(vt));
        vt[SS]=true;
        head=0,q[tail=1]=SS;
        deep[SS]=0;
        while (head&lt;tail)
        {
            int x=q[++head];
            for (int p=o[x];p;p=aa[p][0])
            {
                int y=aa[p][1];
                if (!vt[y])
                {
                    vt[y]=true;
                    deep[y]=deep[x]+1;
                    q[++tail]=y;
                }
            }
        }
        printf(&quot;%d\n&quot;,deep[TT]);
    }
    return 0;
}<pre><h2>Problem3202</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
typedef long long LL;
const LL mo=1000000007,mo2=mo*mo;
int cnt,miu[10000005],pr[1000005],pr2[1000005],tot;
LL n,A,m;
bool is[10000005];
inline LL safe(LL a,LL b)
{
	/*LL res=0,c=mo2;
	a%=c;if (a&lt;0) a+=c;
	for (;b;b&gt;&gt;=1)
	{
		if (b&amp;1) res=res+a;
		if (res&gt;=c) res-=c;
		a&lt;&lt;=1;
		if (a&gt;=c) a-=c;
	}
	return res;*/
	LL tmp=(long double)a*b/mo2;
	tmp=tmp*mo2;
    return (a*b)-tmp;
}
LL ksm(LL a,LL b)
{
	LL res=1;
	for (;b;b&gt;&gt;=1,a=safe(a,a))
		if (b&amp;1) res=safe(res,a);
	return res;
}
void shai()
{
	memset(is,1,sizeof(is));
	is[1]=false;
	miu[1]=1;
	for (int i=2;i&lt;=10000000;i++)
	{
		if (is[i]) pr[++cnt]=i,miu[i]=-1;
		for (int j=1;j&lt;=cnt;j++)
		{
			int x=i*pr[j];
			if (x&gt;10000000) break;
			is[x]=false;
			if (i%pr[j]==0)
				{miu[x]=0;break;}
			else miu[x]=-miu[i];
		}
	}
	for (int i=1;i&lt;=10000000;i++) miu[i]+=miu[i-1];
	//for (int i=1;i&lt;=100;i++) printf(&quot;%d &quot;,pr[i]);ln;
}
LL calcnum()//计算珠子的种类 
{
	LL C3=0,C2=0;
	int l,r,tmp;
	for (l=1;l&lt;=A;l=r+1)
	{
		tmp=A/l;
		r=A/tmp;
		/*C3+=(LL)(miu[r]-miu[l-1])*tmp%mo*tmp%mo*tmp%mo;
		C2+=(LL)(miu[r]-miu[l-1])*tmp%mo*tmp%mo;
		C3%=mo,C2%=mo;*/
		C3+=safe(safe(safe(miu[r]-miu[l-1],tmp),tmp),tmp);
		C3%=mo2;
		C2+=safe(safe(miu[r]-miu[l-1],tmp),tmp);
		C2%=mo2;
	}
	//printf(&quot;C2=%I64d C3=%I64d\n&quot;,C2,C3);
	LL res=safe((C3+3*C2+2),ksm(6,mo2-mo-1));
	if (res&lt;0) res+=mo2;
	return res;
}
struct matrix
{
	LL m[2][2];
	matrix() {memset(m,0,sizeof(m));}
	LL * operator [](int x) {return m[x];}
	friend matrix operator *(matrix a,matrix b)
	{
		matrix c;
		for (int k=0;k&lt;2;k++)
			for (int i=0;i&lt;2;i++)
				for (int j=0;j&lt;2;j++)
					c[i][j]=(c[i][j]+safe(a[i][k],b[k][j]))%mo2;
		return c;
	}
	friend matrix operator ^(matrix a,LL b)
	{
		matrix res;
		res[0][0]=res[1][1]=1;
		for (;b;b&gt;&gt;=1,a=a*a) if (b&amp;1) res=res*a;
		return res;
	}
};
LL f(LL n)
{
	//f[1]=1,g[1]=0;f[i]=(m-1)*g[i-1],g[i]=f[i-1]+(m-2)*g[i-1];
	if (n==1) return 0;
	matrix a,res;
	a[0][1]=1,a[1][0]=(m-1)%mo2,a[1][1]=(m-2)%mo2;
	a=a^(n-1);
	res[0][0]=1;
	res=res*a;
	LL ans=res[0][1];
	//printf(&quot;ans=%I64d\n&quot;,ans);
	ans=safe(ans,safe(m,m-1));
	if (ans&lt;0) ans+=mo2;
	//printf(&quot;f(%I64d)=%I64d\n&quot;,n,ans);
	return ans;
}
LL getphi(LL x)
{
	//printf(&quot;getphi(%I64d)=&quot;,x);
	LL res=1;
	for (int i=1;i&lt;=tot;i++)
	{
		LL tmp=pr2[i];
		if (pr[i]&gt;x) break;
		if (x%tmp) continue;
		x/=tmp;
		res*=(tmp-1);
		for (;x%tmp==0;x/=tmp) res*=tmp;
	}
	if (x&gt;1) res*=(x-1);
	//printf(&quot;%I64d\n&quot;,res);
	return res%mo2;
}
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	shai();
	int tes;
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%lld%lld&quot;,&amp;n,&amp;A);
		m=calcnum();
		//printf(&quot;m=%I64d\n&quot;,m);
		LL x=n;
		tot=0;
		for (int i=1;i&lt;=cnt;i++)
			if (x%pr[i]==0)
			{
				pr2[++tot]=pr[i];
				while (x%pr[i]==0) x/=pr[i];
			}
		if (x&gt;1) pr2[++tot]=x;
		LL ans=0;
		for (LL d=1;d*d&lt;=n;d++) if (n%d==0)
		{
			//printf(&quot;\n----------------------- d=%I64d ----------------------------------------------------\n&quot;,d);
			ans=(ans+safe(f(d),getphi(n/d)))%mo2;
			if (d*d!=n) ans=(ans+safe(f(n/d),getphi(d)))%mo2;
			//printf(&quot;now =%I64d\n&quot;,ans);
		}
		if (n%mo==0) ans/=mo,n/=mo;
		else ans%=mo;
		ans=ans*(ksm(n,mo-2)%mo)%mo;
		if (ans&lt;0) ans+=mo;
		//ln;ln;
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem3202</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
typedef long long LL;
const LL mo=1000000007,mo2=mo*mo;
int cnt,miu[10000005],pr[1000005],pr2[1000005],tot;
LL n,A,m;
bool is[10000005];
LL mul(LL a,LL b)
{
	LL tmp=a*b-mo2*(LL)((long double)a*b/mo2);
	if (tmp&lt;0) tmp+=mo2;
	return tmp;
}
LL ksm(LL a,LL b)
{
	LL res=1;
	for (;b;b&gt;&gt;=1,a=mul(a,a))
		if (b&amp;1) res=mul(res,a);
	return res;
}
void shai()
{
	memset(is,1,sizeof(is));
	is[1]=false;
	miu[1]=1;
	for (int i=2;i&lt;=10000000;i++)
	{
		if (is[i]) pr[++cnt]=i,miu[i]=-1;
		for (int j=1;j&lt;=cnt;j++)
		{
			int x=i*pr[j];
			if (x&gt;10000000) break;
			is[x]=false;
			if (i%pr[j]==0) {miu[x]=0;break;}
			else miu[x]=-miu[i];
		}
	}
	for (int i=1;i&lt;=10000000;i++) miu[i]+=miu[i-1];
}
LL calcnum()//¼ÆËãÖé×ÓµÄÖÖÀà 
{
	LL C3=0,C2=0;
	int l,r;
	for (l=1;l&lt;=A;l=r+1)
	{
		r=A/(A/l);
		LL tmp=A/l;
		LL t=mul(miu[r]-miu[l-1],mul(tmp,tmp));
		C3=(C3+mul(t,tmp))%mo2;
		C2=(C2+t)%mo2;
	}
	LL res=mul((C3+3*C2+2),ksm(6,mo2-mo-1));
	return res;
}
struct matrix
{
	LL m[2][2];
	matrix() {memset(m,0,sizeof(m));}
	LL * operator [](int x) {return m[x];}
	friend matrix operator *(matrix a,matrix b)
	{
		matrix c;
		for (int k=0;k&lt;2;k++)
			for (int i=0;i&lt;2;i++)
				for (int j=0;j&lt;2;j++)
					c[i][j]=(c[i][j]+mul(a[i][k],b[k][j]))%mo2;
		return c;
	}
	friend matrix operator ^(matrix a,LL b)
	{
		matrix res;
		res[0][0]=res[1][1]=1;
		for (;b;b&gt;&gt;=1,a=a*a) if (b&amp;1) res=res*a;
		return res;
	}
};
LL f(LL n)
{
	//if (n==1) return 0;
	matrix a,res;
	a[0][1]=1,a[1][0]=(m-1)%mo2,a[1][1]=(m-2)%mo2;
	a=a^(n-1);
	res[0][0]=1;
	res=res*a;
	LL ans=res[0][1];
	//printf(&quot;ans=%I64d\n&quot;,ans);
	ans=mul(ans,mul(m,m-1));
	if (ans&lt;0) ans+=mo2;
	//printf(&quot;f(%I64d)=%I64d\n&quot;,n,ans);
	return ans;
}
LL getphi(LL x)
{
	LL res=1;
	for (int i=1;i&lt;=tot;i++)
	{
		LL tmp=pr2[i];
		if (pr[i]&gt;x) break;
		if (x%tmp) continue;
		x/=tmp;
		res*=(tmp-1);
		for (;x%tmp==0;x/=tmp) res*=tmp;
	}
	if (x&gt;1) res*=(x-1);
	return res%mo2;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	shai();
	int tes;
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%lld%lld&quot;,&amp;n,&amp;A);
		m=calcnum();
		LL x=n;
		tot=0;
		for (int i=1;i&lt;=cnt;i++)
			if (x%pr[i]==0)
			{
				pr2[++tot]=pr[i];
				while (x%pr[i]==0) x/=pr[i];
			}
		if (x&gt;1) pr2[++tot]=x;
		LL ans=0;
		for (LL d=1;d*d&lt;=n;d++) if (n%d==0)
		{
			ans=(ans+mul(f(d),getphi(n/d)))%mo2;
			if (d*d!=n) ans=(ans+mul(f(n/d),getphi(d)))%mo2;
		}
		if (n%mo==0) ans/=mo,n/=mo;
		else ans%=mo;
		ans=ans*(ksm(n,mo-2)%mo)%mo;
		if (ans&lt;0) ans+=mo;
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem3202</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
typedef long long LL;
const LL mo=1000000007,mo2=mo*mo;
int cnt,miu[10000005],pr[1000005],pr2[1000005],tot;
LL n,A,m;
bool is[10000005];
LL mul(LL a,LL b)
{
	LL tmp=a*b-mo2*(LL)((long double)a*b/mo2);
	if (tmp&lt;0) tmp+=mo2;
	return tmp;
}
LL ksm(LL a,LL b)
{
	LL res=1;
	for (;b;b&gt;&gt;=1,a=mul(a,a))
		if (b&amp;1) res=mul(res,a);
	return res;
}
void shai()
{
	memset(is,1,sizeof(is));
	is[1]=false;
	miu[1]=1;
	for (int i=2;i&lt;=10000000;i++)
	{
		if (is[i]) pr[++cnt]=i,miu[i]=-1;
		for (int j=1;j&lt;=cnt;j++)
		{
			int x=i*pr[j];
			if (x&gt;10000000) break;
			is[x]=false;
			if (i%pr[j]==0) {miu[x]=0;break;}
			else miu[x]=-miu[i];
		}
	}
	for (int i=1;i&lt;=10000000;i++) miu[i]+=miu[i-1];
}
LL calcnum()//¼ÆËãÖé×ÓµÄÖÖÀà 
{
	LL C3=0,C2=0;
	int l,r;
	for (l=1;l&lt;=A;l=r+1)
	{
		r=A/(A/l);
		LL tmp=A/l;
		LL t=mul(miu[r]-miu[l-1],mul(tmp,tmp));
		C3=(C3+mul(t,tmp))%mo2;
		C2=(C2+t)%mo2;
	}
	LL res=mul((C3+3*C2+2),ksm(6,mo2-mo-1));
	return res;
}
struct matrix
{
	LL m[2][2];
	matrix() {memset(m,0,sizeof(m));}
	LL * operator [](int x) {return m[x];}
	friend matrix operator *(matrix a,matrix b)
	{
		matrix c;
		for (int k=0;k&lt;2;k++)
			for (int i=0;i&lt;2;i++)
				for (int j=0;j&lt;2;j++)
					c[i][j]=(c[i][j]+mul(a[i][k],b[k][j]))%mo2;
		return c;
	}
	friend matrix operator ^(matrix a,LL b)
	{
		matrix res;
		res[0][0]=res[1][1]=1;
		for (;b;b&gt;&gt;=1,a=a*a) if (b&amp;1) res=res*a;
		return res;
	}
};
LL f(LL n)
{
	matrix a,res;
	a[0][1]=1,a[1][0]=m-1,a[1][1]=m-2;
	a=a^(n-1);
	res[0][0]=1;
	res=res*a;
	LL ans=res[0][1];
	ans=mul(ans,mul(m,m-1));
	return ans;
}
LL getphi(LL x)
{
	LL res=1;
	for (int i=1;i&lt;=cnt;i++)
	{
		LL tmp=pr[i];
		if (pr[i]&gt;x) break;
		if (x%tmp) continue;
		x/=tmp;
		res*=(tmp-1);
		for (;x%tmp==0;x/=tmp) res*=tmp;
	}
	if (x&gt;1) res*=(x-1);
	return res%mo2;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	shai();
	int tes;
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%lld%lld&quot;,&amp;n,&amp;A);
		m=calcnum();
		LL x=n;
		tot=0;
		for (int i=1;i&lt;=cnt;i++)
			if (x%pr[i]==0)
			{
				pr2[++tot]=pr[i];
				while (x%pr[i]==0) x/=pr[i];
			}
		if (x&gt;1) pr2[++tot]=x;
		LL ans=0;
		for (LL d=1;d*d&lt;=n;d++) if (n%d==0)
		{
			ans=(ans+mul(f(d),getphi(n/d)))%mo2;
			if (d*d!=n) ans=(ans+mul(f(n/d),getphi(d)))%mo2;
		}
		if (n%mo==0) ans/=mo,n/=mo;
		else ans%=mo;
		ans=ans*(ksm(n,mo-2)%mo)%mo;
		if (ans&lt;0) ans+=mo;
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem3202</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
typedef long long LL;
const LL mo=1000000007,mo2=mo*mo;
int tes,cnt,miu[10000005],pr[1000005];
LL n,A,m;
bool is[10000005];
LL mul(LL a,LL b)
{
	LL tmp=a*b-mo2*(LL)((long double)a*b/mo2);
	if (tmp&lt;0) tmp+=mo2;
	return tmp;
}
LL ksm(LL a,LL b)
{
	LL res=1;
	for (;b;b&gt;&gt;=1,a=mul(a,a))
		if (b&amp;1) res=mul(res,a);
	return res;
}
void shai()
{
	memset(is,1,sizeof(is));
	is[1]=false;
	miu[1]=1;
	for (int i=2;i&lt;=10000000;i++)
	{
		if (is[i]) pr[++cnt]=i,miu[i]=-1;
		for (int j=1;j&lt;=cnt;j++)
		{
			int x=i*pr[j];
			if (x&gt;10000000) break;
			is[x]=false;
			if (i%pr[j]==0) {miu[x]=0;break;}
			else miu[x]=-miu[i];
		}
	}
	for (int i=1;i&lt;=10000000;i++) miu[i]+=miu[i-1];
}
LL calcnum()//¼ÆËãÖé×ÓµÄÖÖÀà 
{
	LL C3=0,C2=0;
	int l,r;
	for (l=1;l&lt;=A;l=r+1)
	{
		r=A/(A/l);
		LL tmp=A/l;
		LL t=mul(miu[r]-miu[l-1],mul(tmp,tmp));
		C3=(C3+mul(t,tmp))%mo2;
		C2=(C2+t)%mo2;
	}
	LL res=mul((C3+3*C2+2),ksm(6,mo2-mo-1));
	return res;
}
struct matrix
{
	LL m[2][2];
	matrix() {memset(m,0,sizeof(m));}
	LL * operator [](int x) {return m[x];}
	friend matrix operator *(matrix a,matrix b)
	{
		matrix c;
		for (int k=0;k&lt;2;k++)
			for (int i=0;i&lt;2;i++)
				for (int j=0;j&lt;2;j++)
					c[i][j]=(c[i][j]+mul(a[i][k],b[k][j]))%mo2;
		return c;
	}
	friend matrix operator ^(matrix a,LL b)
	{
		matrix res;
		res[0][0]=res[1][1]=1;
		for (;b;b&gt;&gt;=1,a=a*a) if (b&amp;1) res=res*a;
		return res;
	}
};
LL f(LL n)
{
	matrix a,res;
	a[0][1]=1,a[1][0]=m-1,a[1][1]=m-2;
	a=a^(n-1);
	res[0][0]=1;
	res=res*a;
	LL ans=res[0][1];
	ans=mul(ans,mul(m,m-1));
	return ans;
}
LL getphi(LL x)
{
	LL res=1;
	for (int i=1;i&lt;=cnt;i++)
	{
		LL tmp=pr[i];
		if (pr[i]&gt;x) break;
		if (x%tmp) continue;
		x/=tmp;
		res*=(tmp-1);
		for (;x%tmp==0;x/=tmp) res*=tmp;
	}
	if (x&gt;1) res*=(x-1);
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	shai();
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%lld%lld&quot;,&amp;n,&amp;A);
		m=calcnum();
		LL ans=0;
		for (LL d=1;d*d&lt;=n;d++) if (n%d==0)
		{
			ans=(ans+mul(f(d),getphi(n/d)))%mo2;
			if (d*d!=n) ans=(ans+mul(f(n/d),getphi(d)))%mo2;
		}
		if (n%mo==0) ans/=mo,n/=mo;
		else ans%=mo;
		ans=ans*(ksm(n,mo-2)%mo)%mo;
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem3202</h2><pre>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
typedef long long ll;
int mu[10000005],vis[10000005]={0};
int pr[1000005],tot=0;
ll PP=1000000007;
ll mo=PP*PP;
inline ll mul(ll a,ll b)  
{  
	ll tmp=(long double)a*b/mo;
	tmp=tmp*mo;
      return (a*b)-tmp;  
}  
void sieve(int n){
    mu[0]=0;mu[1]=1;
    for (int i=2;i&lt;=n;i++){
        if(!vis[i])pr[tot++]=i,mu[i]=-1;        
        for (int j=0;j&lt;tot &amp;&amp; pr[j]*i&lt;=n;j++){
            vis[i*pr[j]]=1;
            if(i%pr[j]==0){
                mu[i*pr[j]]=0;
                break;
            }else mu[i*pr[j]]=-mu[i];
        }
    }
    for (int i=1;i&lt;=n;i++)mu[i]+=mu[i-1];
}
ll po(ll a,ll b){
    ll ans=1;
    do{
        if(b&amp;1)ans=mul(ans,a);
        a=mul(a,a);
    }while(b&gt;&gt;=1);
    return ans;
}
ll di;
ll cal(ll n){return mul(mul(mul(n,n+1),n+2),di);}
ll cal2(ll m,ll d){return (m*(1-((d&amp;1)&lt;&lt;1))+po(m,d))%mo;}
ll P[100];int ptot=0;
ll phi(ll a){
    ll ans=a;
    for (int i=0;i&lt;ptot;i++)if(a%P[i]==0)ans=ans/P[i]*(P[i]-1);
    return ans%mo;
}
int main(){
   // freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
    di=po(6,mo-PP-1);
    sieve(10000000);
    int tes;
    scanf(&quot;%d&quot;,&amp;tes);
    while(tes--){
        ll n,a;
        scanf(&quot;%lld%lld&quot;,&amp;n,&amp;a);    
        ll ans=0,nex=1;
        for (ll i=1;i&lt;=a;i=nex+1){
            nex=a/(a/i);
            ans=(ans+mul(cal(a/i),(mu[nex]-mu[i-1])))%mo;
        }
        ll m=(ans-1)%mo;
        if (m&lt;0) m+=mo;
        //printf(&quot;m=%I64d\n&quot;,m);
        ptot=0;
        ll N=n;
        for (int j=0;j&lt;tot &amp;&amp; pr[j]*pr[j]&lt;=N;j++)
            if(N%pr[j]==0){
                P[ptot++]=pr[j];
                while(N%pr[j]==0)N/=pr[j];
            }
        if(N!=1)P[ptot++]=N;
          
        ans=0;
        for (ll i=1;i*i&lt;=n;i++)
            if(n%i==0){
                if(i*i==n)ans+=mul(phi(n/i),cal2(m,i));
                else ans+=mul(phi(n/i),cal2(m,i))+mul(phi(i),cal2(m,n/i));
                ans%=mo;
            }
        if(n%PP==0)ans/=PP,n/=PP;
		else ans%=PP;      
        ans=ans*(po(n,PP-2)%PP)%PP;
        if(ans&lt;0)ans+=PP;
        printf(&quot;%lld\n&quot;,ans);
    }
    //printf(&quot;%I64d\n&quot;,cal2(3,1));
    //printf(&quot;%I64d\n&quot;,mul(x,y));//printf(&quot;%I64d\n&quot;,x*y);
    return 0;
}
<pre><h2>Problem3202</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
typedef long long LL;
const LL mo=1000000007,mo2=mo*mo;
int tes,cnt,miu[10000005],pr[1000005];
LL n,A,m;
bool is[10000005];
LL mul(LL a,LL b)
{
	LL tmp=a*b-mo2*(LL)((long double)a*b/mo2);
	if (tmp&lt;0) tmp+=mo2;
	return tmp;
}
LL ksm(LL a,LL b)
{
	LL res=1;
	for (;b;b&gt;&gt;=1,a=mul(a,a))
		if (b&amp;1) res=mul(res,a);
	return res;
}
void shai()
{
	memset(is,1,sizeof(is));
	is[1]=false;
	miu[1]=1;
	for (int i=2;i&lt;=10000000;i++)
	{
		if (is[i]) pr[++cnt]=i,miu[i]=-1;
		for (int j=1;j&lt;=cnt;j++)
		{
			int x=i*pr[j];
			if (x&gt;10000000) break;
			is[x]=false;
			if (i%pr[j]==0) {miu[x]=0;break;}
			else miu[x]=-miu[i];
		}
	}
	for (int i=1;i&lt;=10000000;i++) miu[i]+=miu[i-1];
}
LL calcnum()//¼ÆËãÖé×ÓµÄÖÖÀà 
{
	LL C3=0,C2=0;
	int l,r;
	for (l=1;l&lt;=A;l=r+1)
	{
		r=A/(A/l);
		LL tmp=A/l;
		LL t=mul(miu[r]-miu[l-1],mul(tmp,tmp));
		C3=(C3+mul(t,tmp))%mo2;
		C2=(C2+t)%mo2;
	}
	LL res=mul((C3+3*C2+2),ksm(6,mo2-mo-1));
	return res;
}
LL f(LL n)
{
	int t=(n&amp;1)?-1:1;
	return ((m-1)*t+ksm(m-1,n))%mo2;
}
LL getphi(LL x)
{
	LL res=1;
	for (int i=1;i&lt;=cnt;i++)
	{
		LL tmp=pr[i];
		if (pr[i]&gt;x) break;
		if (x%tmp) continue;
		x/=tmp;
		res*=(tmp-1);
		for (;x%tmp==0;x/=tmp) res*=tmp;
	}
	if (x&gt;1) res*=(x-1);
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	shai();
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%lld%lld&quot;,&amp;n,&amp;A);
		m=calcnum();
		LL ans=0;
		for (LL d=1;d*d&lt;=n;d++) if (n%d==0)
		{
			ans=(ans+mul(f(d),getphi(n/d)))%mo2;
			if (d*d!=n) ans=(ans+mul(f(n/d),getphi(d)))%mo2;
		}
		if (n%mo==0) ans/=mo,n/=mo;
		else ans%=mo;
		ans=ans*(ksm(n,mo-2)%mo)%mo;
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem3202</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
const LL mo=1000000007,mo2=mo*mo;
int tes,cnt,miu[10000005],pr[1000005];
LL n,A,m;
bool is[10000005];
LL mul(LL a,LL b)
{
	LL tmp=a*b-mo2*(LL)((long double)a*b/mo2);
	if (tmp&lt;0) tmp+=mo2;
	return tmp;
}
LL ksm(LL a,LL b)
{
	LL res=1;
	for (;b;b&gt;&gt;=1,a=mul(a,a))
		if (b&amp;1) res=mul(res,a);
	return res;
}
void shai()
{
	memset(is,1,sizeof(is));
	is[1]=false;
	miu[1]=1;
	for (int i=2;i&lt;=10000000;i++)
	{
		if (is[i]) pr[++cnt]=i,miu[i]=-1;
		for (int j=1;j&lt;=cnt;j++)
		{
			int x=i*pr[j];
			if (x&gt;10000000) break;
			is[x]=false;
			if (i%pr[j]==0) {miu[x]=0;break;}
			else miu[x]=-miu[i];
		}
	}
	for (int i=1;i&lt;=10000000;i++) miu[i]+=miu[i-1];
}
LL calcnum()
{
	LL C2=0,C3=0;
	int l,r;
	for (l=1;l&lt;=A;l=r+1)
	{
		r=A/(A/l);
		LL tmp=A/l;
		LL t=mul(miu[r]-miu[l-1],mul(tmp,tmp));
		C2=(C2+t)%mo2;
		C3=(C3+mul(t,tmp))%mo2;
	}
	return mul((C3+3*C2+2),ksm(6,mo2-mo-1));
}
LL f(LL n)
{
	int t=(n&amp;1)?-1:1;
	return ((m-1)*t+ksm(m-1,n))%mo2;
}
LL getphi(LL x)
{
	LL res=1;
	for (int i=1;i&lt;=cnt&amp;&amp;pr[i]&lt;=x;i++)
		if (x%pr[i]==0)
		{
			LL tmp=pr[i];
			x/=tmp;
			res*=(tmp-1);
			for (;x%tmp==0;x/=tmp) res*=tmp;
		}
	if (x&gt;1) res*=(x-1);
	return res;
}
int main()
{
	shai();
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%lld%lld&quot;,&amp;n,&amp;A);
		m=calcnum();
		LL ans=0;
		for (LL d=1;d*d&lt;=n;d++) if (n%d==0)
		{
			ans+=mul(f(d),getphi(n/d));
			if (d*d!=n) ans+=mul(f(n/d),getphi(d));
			ans%=mo2;
		}
		if (n%mo==0) ans/=mo,n/=mo;
		else ans%=mo;
		ans=ans*(ksm(n,mo-2)%mo)%mo;
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem3202</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const LL mo=1000000007,mo2=mo*mo;
int tes,cnt,miu[10000005],pr[1000005];
LL n,A,m;
bool vt[10000005];
LL mul(LL a,LL b)
{
	LL tmp=a*b-mo2*(LL)((long double)a*b/mo2);
	if (tmp&lt;0) tmp+=mo2;
	return tmp;
}
LL ksm(LL a,LL b)
{
	LL res=1;
	for (;b;b&gt;&gt;=1,a=mul(a,a))
		if (b&amp;1) res=mul(res,a);
	return res;
}
void shai()
{
	vt[1]=true,miu[1]=1;
	for (int i=2;i&lt;=10000000;i++)
	{
		if (!vt[i]) pr[++cnt]=i,miu[i]=-1;
		for (int j=1;j&lt;=cnt;j++)
		{
			int x=i*pr[j];
			if (x&gt;10000000) break;
			vt[x]=true;
			if (i%pr[j]==0) {miu[x]=0;break;}
			else miu[x]=-miu[i];
		}
	}
	for (int i=1;i&lt;=10000000;i++) miu[i]+=miu[i-1];
}
LL calcnum()
{
	LL C2=0,C3=0;
	int l,r;
	for (l=1;l&lt;=A;l=r+1)
	{
		r=A/(A/l);
		LL tmp=A/l;
		LL t=mul(miu[r]-miu[l-1],mul(tmp,tmp));
		C2=(C2+t)%mo2;
		C3=(C3+mul(t,tmp))%mo2;
	}
	return mul((C3+3*C2+2),ksm(6,mo2-mo-1));
}
LL f(LL n)
{
	int t=(n&amp;1)?-1:1;
	return ((m-1)*t+ksm(m-1,n))%mo2;
}
LL phi(LL x)
{
	LL res=1;
	for (int i=1;i&lt;=cnt&amp;&amp;pr[i]&lt;=x;i++)
		if (x%pr[i]==0)
		{
			LL tmp=pr[i];
			x/=tmp;
			res*=(tmp-1);
			for (;x%tmp==0;x/=tmp) res*=tmp;
		}
	if (x&gt;1) res*=(x-1);
	return res;
}
int main()
{
	shai();
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%lld%lld&quot;,&amp;n,&amp;A);
		m=calcnum();
		LL ans=0;
		for (LL d=1;d*d&lt;=n;d++) if (n%d==0)
		{
			ans+=mul(f(d),phi(n/d));
			if (d*d!=n) ans+=mul(f(n/d),phi(d));
			ans%=mo2;
		}
		if (n%mo==0) ans/=mo,n/=mo;else ans%=mo;
		ans=ans*(ksm(n,mo-2)%mo)%mo;
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem3202</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const LL mo=1000000007,mo2=mo*mo;
int tes,cnt,miu[10000005],pr[1000005];
LL n,A,m;
bool vt[10000005];
LL mul(LL a,LL b)
{
	/*LL tmp=a*b-mo2*(LL)((long double)a*b/mo2);
	if (tmp&lt;0) tmp+=mo2;
	return tmp;*/
	LL res=0;
	for (a%=mo2;b;b&gt;&gt;=1,a=(a+a)%mo2)
		if (b&amp;1) res=(res+a)%mo2;
	if (res&lt;0) res+=mo2;
	return res;
}
LL ksm(LL a,LL b)
{
	LL res=1;
	for (;b;b&gt;&gt;=1,a=mul(a,a))
		if (b&amp;1) res=mul(res,a);
	return res;
}
void shai()
{
	vt[1]=true,miu[1]=1;
	for (int i=2;i&lt;=10000000;i++)
	{
		if (!vt[i]) pr[++cnt]=i,miu[i]=-1;
		for (int j=1;j&lt;=cnt;j++)
		{
			int x=i*pr[j];
			if (x&gt;10000000) break;
			vt[x]=true;
			if (i%pr[j]==0) {miu[x]=0;break;}
			else miu[x]=-miu[i];
		}
	}
	for (int i=1;i&lt;=10000000;i++) miu[i]+=miu[i-1];
}
LL calcnum()
{
	LL C2=0,C3=0;
	int l,r;
	for (l=1;l&lt;=A;l=r+1)
	{
		r=A/(A/l);
		LL tmp=A/l;
		LL t=mul(miu[r]-miu[l-1],mul(tmp,tmp));
		C2=(C2+t)%mo2;
		C3=(C3+mul(t,tmp))%mo2;
	}
	return mul((C3+3*C2+2),ksm(6,mo2-mo-1));
}
LL f(LL n)
{
	int t=(n&amp;1)?-1:1;
	return ((m-1)*t+ksm(m-1,n))%mo2;
}
LL phi(LL x)
{
	LL res=1;
	for (int i=1;i&lt;=cnt&amp;&amp;pr[i]&lt;=x;i++)
		if (x%pr[i]==0)
		{
			LL tmp=pr[i];
			x/=tmp;
			res*=(tmp-1);
			for (;x%tmp==0;x/=tmp) res*=tmp;
		}
	if (x&gt;1) res*=(x-1);
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	shai();
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%lld%lld&quot;,&amp;n,&amp;A);
		m=calcnum();
		LL ans=0;
		for (LL d=1;d*d&lt;=n;d++) if (n%d==0)
		{
			ans+=mul(f(d),phi(n/d));
			if (d*d!=n) ans+=mul(f(n/d),phi(d));
			ans%=mo2;
		}
		if (n%mo==0) ans/=mo,n/=mo;else ans%=mo;
		ans=ans*(ksm(n,mo-2)%mo)%mo;
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem3203</h2><pre>/**************************************************************
    Problem: 3203
    User: wangyucheng
    Language: C++
    Result: Accepted
    Time:344 ms
    Memory:4396 kb
****************************************************************/
 
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
#define N 100003
typedef long long ll;
int n;
double d,a[N],x[N],ans=0.0;
struct P{
    double x,y;
    P(double a=0.0,double b=0.0){
     x=a,y=b;   
    }   
    P operator-(P b){return P(x-b.x,y-b.y);}
    double operator*(P b){return x*b.y-y*b.x;}
}s[N];
double sp(P a,P b){
   return (a.y-b.y)/(a.x-b.x);  
}
int main(){
    scanf(&quot;%d&quot;,&amp;n);
    scanf(&quot;%lf&quot;,&amp;d);
    for(int i=1;i&lt;=n;i++)scanf(&quot;%lf%lf&quot;,&amp;a[i],&amp;x[i]);
    double sum =0;
    int top=0;
    for(int i=1;i&lt;=n;i++){
        P p=P(i*d,sum);sum+=a[i];
        while(top&gt;1&amp;&amp;(p-s[top-1])*(s[top]-s[top-1])&gt;=0)top--;
        s[++top]=p;
        p=P(x[i]+i*d,sum);
        int l=1,r=top,m1,m2;
        while(r-l&gt;=3){
           m1=l+(r-l)/3;
           m2=r-(r-l)/3;
           double k1=sp(s[m1],p),k2=sp(s[m2],p);
           if(k1&lt;k2)l=m1;else r=m2;  
        }
        double res=0;
        for(int j=l;j&lt;=r;j++)res=max(res,sp(s[j],p));
        ans+=res;   
      
    }
    printf(&quot;%.0lf\n&quot;,ans);
}<pre><h2>Problem3203</h2><pre>/**************************************************************
    Problem: 3203
    User: wangyucheng
    Language: C++
    Result: Accepted
    Time:344 ms
    Memory:4396 kb
****************************************************************/
 
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
#define N 100003
typedef long long ll;
int n;
double d,a[N],x[N],ans=0.0;
struct P{
    double x,y;
    P(double a=0.0,double b=0.0){
     x=a,y=b;   
    }   
    P operator-(P b){return P(x-b.x,y-b.y);}
    double operator*(P b){return x*b.y-y*b.x;}
}s[N];
double sp(P a,P b){
   return (a.y-b.y)/(a.x-b.x);  
}
int main(){
    scanf(&quot;%d&quot;,&amp;n);
    scanf(&quot;%lf&quot;,&amp;d);
    for(int i=1;i&lt;=n;i++)scanf(&quot;%lf%lf&quot;,&amp;a[i],&amp;x[i]);
    double sum =0;
    int top=0;
    for(int i=1;i&lt;=n;i++){
        P p=P(i*d,sum);sum+=a[i];
        while(top&gt;1&amp;&amp;(p-s[top-1])*(s[top]-s[top-1])&gt;=0)top--;
        s[++top]=p;
        p=P(x[i]+i*d,sum);
        int l=1,r=top,m1,m2;
        while(r-l&gt;=3){
           m1=l+(r-l)/3;
           m2=r-(r-l)/3;
           double k1=sp(s[m1],p),k2=sp(s[m2],p);
           if(k1&lt;k2)l=m1+1;else r=m2-1;  
        }
        double res=0;
        for(int j=l;j&lt;=r;j++)res=max(res,sp(s[j],p));
        ans+=res;   
      
    }
    printf(&quot;%.0lf\n&quot;,ans);
}<pre><h2>Problem3203</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
#define N 100003
typedef long long ll;
int n;
double d,a[N],x[N],ans=0.0;
struct P{
    double x,y;
    P(double a=0.0,double b=0.0){
     x=a,y=b;   
    }   
    P operator-(P b){return P(x-b.x,y-b.y);}
    double operator*(P b){return x*b.y-y*b.x;}
}s[N];
double sp(P a,P b){
   return (a.y-b.y)/(a.x-b.x);  
}
int main(){
    scanf(&quot;%d&quot;,&amp;n);
    scanf(&quot;%lf&quot;,&amp;d);
    for(int i=1;i&lt;=n;i++)scanf(&quot;%lf%lf&quot;,&amp;a[i],&amp;x[i]);
    double sum =0;
    int top=0;
    for(int i=1;i&lt;=n;i++){
        P p=P(i*d,sum);sum+=a[i];
        while(top&gt;1&amp;&amp;(p-s[top-1])*(s[top]-s[top-1])&gt;=0)top--;
        s[++top]=p;
        p=P(x[i]+i*d,sum);
        int l=1,r=top,m1,m2;
        while(r-l&gt;=3){
           m1=l+(r-l)/3;
           m2=r-(r-l)/3;
           double k1=sp(s[m1],p),k2=sp(s[m2],p);
           if(k1&lt;k2)l=m1+1;else r=m2-1;  
        }
        double res=0;
        for(int j=l;j&lt;=r;j++)res=max(res,sp(s[j],p));
        ans+=res;   
       
    }
    printf(&quot;%.0lf\n&quot;,ans);
}
<pre><h2>Problem3203</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define sm 1e-7
#define LL double
int n,i,j,head,tail,l,r,mid1,mid2;
LL d,a[110000],x[110000],S[110000],res,ans;
struct point{LL x,y;} t1,t2,P,tmp,q[110000];
point dec(point a,point b) {a.x-=b.x;a.y-=b.y;return a;}
LL det(point a,point b) {return a.x*b.y-a.y*b.x;}
LL max(LL a,LL b) {return a&gt;b?a:b;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%lf&quot;,&amp;n,&amp;d);
	for (i=1;i&lt;=n;i++) scanf(&quot;%lf%lf&quot;,&amp;a[i],&amp;x[i]),S[i]=S[i-1]+a[i];
	tmp.x=tmp.y=0;
	//q[tail=1]=tmp;
	for (i=1;i&lt;=n;i++)
	{
		P.x=i*d,P.y=S[i-1];
		t1=q[tail],t2=q[tail-1];
		while (tail&gt;1&amp;&amp;det(dec(P,t1),dec(t1,t2))&gt;-sm)
		{
			--tail;
			t1=q[tail],t2=q[tail-1];
		}
			q[++tail]=P;
		P.x=x[i]+i*d,P.y=S[i];
		l=1,r=tail;
		while (r-l&gt;=3)
		{
			mid1=l+(r-l)/3;
			mid2=r-(r-l)/3;
			t1=dec(P,q[mid1]);
			t2=dec(P,q[mid2]);
			if (t1.y*t2.x-t1.x*t2.y&gt;sm) r=mid2-1;
			else l=mid1+1;
		}
		res=0;
		for (j=l;j&lt;=r;j++)
		{
			t1=dec(P,q[j]);
			res=max(res,t1.y/t1.x);
		}
		ans+=res;
		P.x=i*d,P.y=S[i-1];
		//printf(&quot;%.3f\n&quot;,ans);
	}
	printf(&quot;%.0f\n&quot;,ans);
	return 0;
}
<pre><h2>Problem3203</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define sm 1e-7
#define LL double
int n,i,j,head,tail,l,r,mid1,mid2;
LL d,a[110000],x[110000],S[110000],res,ans;
struct point{LL x,y;} t1,t2,P,tmp,q[110000];
point dec(point a,point b) {a.x-=b.x;a.y-=b.y;return a;}
LL det(point a,point b) {return a.x*b.y-a.y*b.x;}
LL max(LL a,LL b) {return a&gt;b?a:b;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%lf&quot;,&amp;n,&amp;d);
	for (i=1;i&lt;=n;i++) scanf(&quot;%lf%lf&quot;,&amp;a[i],&amp;x[i]),S[i]=S[i-1]+a[i];
	tmp.x=tmp.y=0;
	q[tail=1]=tmp;
	for (i=1;i&lt;=n;i++)
	{
		P.x=i*d,P.y=S[i-1];
		t1=q[tail],t2=q[tail-1];
		while (tail&gt;1&amp;&amp;det(dec(P,t1),dec(t1,t2))&gt;-sm)
		{
			--tail;
			t1=q[tail],t2=q[tail-1];
		}
		q[++tail]=P;
		P.x=x[i]+i*d,P.y=S[i];
		l=1,r=tail;
		while (r-l&gt;=3)
		{
			mid1=l+(r-l)/3;
			mid2=r-(r-l)/3;
			t1=dec(P,q[mid1]);
			t2=dec(P,q[mid2]);
			if (t1.y*t2.x-t1.x*t2.y&gt;sm) r=mid2-1;
			else l=mid1+1;
		}
		res=0;
		for (j=l;j&lt;=r;j++)
		{
			t1=dec(P,q[j]);
			res=max(res,t1.y/t1.x);
		}
		ans+=res;
		P.x=i*d,P.y=S[i-1];
		//printf(&quot;%.3f\n&quot;,ans);
	}
	printf(&quot;%.0f\n&quot;,ans);
	return 0;
}
<pre><h2>Problem3209</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define LL long long
#define mo 10000007
LL a[1000000],C[1000][1000],ans,n;
LL i,tmp,sum,j;
LL qmod(LL a,LL b)
{
	LL res=1;
	for (;b&gt;0;b&gt;&gt;=1,a=a*a%mo) if (b&amp;1) res=res*a%mo;
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	//f[i][j]:i位的二进制数，有就j个1的个数
	C[1][0]=C[1][1]=1;
	for (i=2;i&lt;=50;i++)
		for (j=0;j&lt;=i;j++)
			if (j==0) C[i][j]=1;
			else C[i][j]=C[i-1][j]+C[i-1][j-1];
	scanf(&quot;%lld&quot;,&amp;n);
	ans=(LL)1;
	tmp=n+1;
	while (tmp&gt;0)
	{
		a[++a[0]]=(tmp&amp;1);
		tmp&gt;&gt;=1;
	}
	for (i=a[0];i&gt;0;i--)
		if (a[i]==1)
		{
			if (sum&gt;0) ans=ans*sum%mo;
			for (j=1;j&lt;=i-1;j++) ans=ans*qmod(j+sum,C[i-1][j])%mo;
			++sum;
		}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem3209</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define LL long long
#define mo 10000007
LL a[1000000],C[1000][1000],f[1000][1000],ans,n;
LL i,tmp,sum,j;
LL qmod(LL a,LL b)
{
    LL res=1;
    for (;b&gt;0;b&gt;&gt;=1,a=a*a%mo) if (b&amp;1) res=res*a%mo;
    return res;
}
int main()
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    //f[i][j]:i位的二进制数，有就j个1的个数
    C[1][0]=C[1][1]=1;
    for (i=2;i&lt;=50;i++)
        for (j=0;j&lt;=i;j++)
            if (j==0) C[i][j]=1;
            else C[i][j]=C[i-1][j]+C[i-1][j-1];
    f[1][1]=1;
    for (i=2;i&lt;=50;i++)
        for (j=1;j&lt;=i;j++)
            f[i][j]=C[i-1][j-1];
    scanf(&quot;%lld\n&quot;,&amp;n);
    ans=(LL)1;
    tmp=n+1;
    while (tmp&gt;0)
    {
        a[++a[0]]=(tmp&amp;1);
        tmp&gt;&gt;=1;
    }
    //for (i=1;i&lt;=a[0];i++) printf(&quot;%lld &quot;,a[i]);printf(&quot;\n&quot;);
    for (i=a[0];i&gt;0;i--)
        if (a[i]==1)
        {
            if (sum&gt;0) ans=ans*sum%mo;
            for (j=1;j&lt;=i-1;j++) ans=ans*qmod(j+sum,C[i-1][j])%mo;
            ++sum;
        }
    printf(&quot;%lld\n&quot;,ans);
    return 0;
}<pre><h2>Problem3210</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
int n;
struct ppt
{
	int x,y;
	void in()
	{
		int xx,yy;
		scanf(&quot;%d%d&quot;,&amp;xx,&amp;yy);
		x=xx+yy,y=xx-yy;
	}
} q[101111];
inline bool cmp1(ppt a,ppt b) {return a.x&lt;b.x;}
inline bool cmp2(ppt a,ppt b) {return a.y&lt;b.y;}
LL calc(int x0,int y0)
{
	LL res=0;
	for (int i=1;i&lt;=n;i++)
		res+=abs(q[i].x-x0)+abs(q[i].y-y0);
	return res&gt;&gt;1;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	for (int i=1;i&lt;=n;i++) q[i].in();
	sort(q+1,q+n+1,cmp1);
	int xx=q[n&gt;&gt;1].x;
	sort(q+1,q+n+1,cmp2);
	int yy=q[n&gt;&gt;1].y;
	if ((xx&amp;1)==(yy&amp;1)) printf(&quot;%lld\n&quot;,calc(xx,yy));
	else printf(&quot;%lld\n&quot;,min(min(calc(xx-1,yy),calc(xx,yy-1)),min(calc(xx+1,yy),calc(xx,yy+1))));
	return 0;
}<pre><h2>Problem3211</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
using namespace std;
typedef long long LL;
const LL NN=101111;
LL n,m,fa[NN];
LL c[NN];
LL getfa(LL x) {return fa[x]==x?x:fa[x]=getfa(fa[x]);}
void change(LL i,LL x)
{
	for (;i&lt;=n;i+=(i&amp;-i)) c[i]+=x;
}
LL getsum(LL i)
{
	LL res=0;
	for (;i;i-=(i&amp;-i)) res+=c[i];
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld&quot;,&amp;n);
	LL i,x,y,z;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%lld&quot;,&amp;x);
		change(i,x);
		fa[i]=i;
	}
	fa[n+1]=n+1;
	scanf(&quot;%lld&quot;,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%lld%lld%lld&quot;,&amp;x,&amp;y,&amp;z);
		if (y&gt;z) {LL t=y;y=z;z=t;}
		if (x==1) printf(&quot;%lld\n&quot;,getsum(z)-getsum(y-1));
		else
		{
			LL k=getfa(y);
			while (k&lt;=z)
			{
				x=getsum(k)-getsum(k-1);
				y=(LL)sqrt(x);
				change(k,y-x);
				if (x&lt;=1) fa[k]=k+1;
				k=getfa(k+1);
			}
		}
	}
	return 0;
}<pre><h2>Problem3211</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
using namespace std;
typedef long long LL;
const int NN=101111;
int n,m,fa[NN];
LL c[NN];
int getfa(int x) {return fa[x]==x?x:fa[x]=getfa(fa[x]);}
void change(int i,int x)
{
	for (;i&lt;=n;i+=(i&amp;-i)) c[i]+=x;
}
LL getsum(int i)
{
	LL res=0;
	for (;i;i-=(i&amp;-i)) res+=c[i];
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y,z;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		change(i,x);
		fa[i]=i;
	}
	fa[n+1]=n+1;
	scanf(&quot;%d&quot;,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		if (y&gt;z) {int t=y;y=z;z=t;}
		if (x==1) printf(&quot;%lld\n&quot;,getsum(z)-getsum(y-1));
		else
		{
			int k=getfa(y);
			while (k&lt;=z)
			{
				x=getsum(k)-getsum(k-1);
				y=(int)sqrt(x);
				change(k,y-x);
				if (x&lt;=1) fa[k]=k+1;
				k=getfa(k+1);
			}
		}
	}
	return 0;
}<pre><h2>Problem3211</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
using namespace std;
typedef long long LL;
const int NN=101111;
int n,m,fa[NN];
LL c[NN];
int getfa(int x) {return fa[x]==x?x:fa[x]=getfa(fa[x]);}
void change(int i,int x)
{
	for (;i&lt;=n;i+=(i&amp;-i)) c[i]+=x;
}
LL getsum(int i)
{
	LL res=0;
	for (;i;i-=(i&amp;-i)) res+=c[i];
	return res;
}
int read()
{
	int res=0;
	char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar()) res=res*10+ch-'0';
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	n=read();
	int i,x,y,z;
	for (i=1;i&lt;=n;i++)
	{
		x=read();
		change(i,x);
		fa[i]=i;
	}
	fa[n+1]=n+1;
	m=read();
	for (i=1;i&lt;=m;i++)
	{
		x=read(),y=read(),z=read();
		if (y&gt;z) {int t=y;y=z;z=t;}
		if (x==1) printf(&quot;%lld\n&quot;,getsum(z)-getsum(y-1));
		else
		{
			int k=getfa(y);
			while (k&lt;=z)
			{
				x=getsum(k)-getsum(k-1);
				y=(int)sqrt(x);
				change(k,y-x);
				if (x&lt;=1) fa[k]=k+1;
				k=getfa(k+1);
			}
		}
	}
	return 0;
}<pre><h2>Problem3217</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
const int NN=200005,AA=30000000,logn=20;
int b[NN],size[NN],maxsize[NN],lc[NN],rc[NN],key[NN],fa[NN],A[NN],B[NN];
int n,m,TTT1,TTT2,need,cnt,root,n1,n2;
bool flag[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9')
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar();
}
struct Huishouzhan
{
	int top,sta[10000000];
	inline void push(int x){sta[++top]=x;}
	inline int go()
	{
		if (!top) return ++TTT2;
		return sta[top--];
	}
} box;
struct trienode
{
	int size,s[2];
} T[AA];
struct trie
{
	int root;
	void ins(int &amp;v,int x,int k,int kind)
	{
		if (!v) v=box.go();
		T[v].size+=kind;
		if (k==0) return;
		if (x&amp;(1&lt;&lt;(k-1))) ins(T[v].s[1],x,k-1,kind);
		else ins(T[v].s[0],x,k-1,kind);
	}
	void huishou(int v)
	{
		if (!v) return;
		huishou(T[v].s[0]),huishou(T[v].s[1]);
		T[v].size=T[v].s[0]=T[v].s[1]=0;
		box.push(v);
	}
	int find(int v,int K,int k)
	{
		if (!v||!k) return 0;
		int tmp=T[T[v].s[1]].size;
		if (K&lt;=tmp) return (1&lt;&lt;(k-1))+find(T[v].s[1],K,k-1);
		else return find(T[v].s[0],K-tmp,k-1);
	}
	int xormax(int v,int x,int k)
	{
		if (!v||!k) return 0;
		bool t=x&amp;(1&lt;&lt;(k-1));
		if (T[T[v].s[t^1]].size)
			return (1&lt;&lt;(k-1))+xormax(T[v].s[t^1],x,k-1);
		else return xormax(T[v].s[t],x,k-1);
	}
	void ins(int x) {ins(root,x,logn,1);}
	void del(int x) {ins(root,x,logn,-1);}
	void huishou() {huishou(root);root=0;}
	int size() {return T[root].size;}
	int find(int K) {return find(root,K,logn);}
	int xormax(int x) {return xormax(root,x,logn);}
} E[NN&lt;&lt;1];
inline void update(int v)
{
	if (!flag[v]) size[v]=size[lc[v]]+size[rc[v]];
	else
	{
		size[v]=size[lc[v]]+size[rc[v]]+1;
		if (size[v]&gt;maxsize[v]) maxsize[v]=size[v];
	}
}
int build(int l,int r)
{
	int mid=(l+r)&gt;&gt;1;
	int v=b[mid];
	for (int i=l;i&lt;=r;i++) E[v].ins(key[b[i]]);
	lc[v]=rc[v]=0;
	if (l&lt;mid) lc[v]=build(l,mid-1),fa[lc[v]]=v;
	if (r&gt;mid) rc[v]=build(mid+1,r),fa[rc[v]]=v;
	update(v);
	return v;
}
inline bool balance(int v)
{
	double tmp=maxsize[v]*0.88;
	return maxsize[lc[v]]&lt;tmp&amp;&amp;maxsize[rc[v]]&lt;tmp;
}
void ins(int &amp;v,int pos,int x,int ff)
{
	if (v==0)
	{
		v=++TTT1;
		key[v]=x;
		fa[v]=ff;
		size[v]=1;
		flag[v]=true;
		E[v].ins(x);
		return;
	}
	E[v].ins(x);
	int tmp=size[lc[v]],k=flag[v]?1:0;
	if (pos&lt;=tmp) ins(lc[v],pos,x,v);
	else ins(rc[v],pos-tmp-k,x,v);
	update(v);
	if (!balance(v)) need=v;
}
void bianli(int v)
{
	if (lc[v]) bianli(lc[v]);
	E[v].huishou();
	if (flag[v]) b[++cnt]=v;
	if (rc[v]) bianli(rc[v]);
}
void rebuild(int v)
{
	int f=fa[v],p=(v==lc[f]);
	cnt=0;
	bianli(v);
	int t=build(1,cnt);
	fa[t]=f;
	if (p) lc[f]=t;else rc[f]=t;
	if (v==root) root=t;
}
int find(int v,int pos)
{
	int tmp=size[lc[v]],k=flag[v]?1:0;
	if (pos&lt;=tmp) return find(lc[v],pos);
	else if (pos==tmp+k) return key[v];
	else return find(rc[v],pos-tmp-k);
}
void del(int v,int pos,int val)
{
	E[v].del(val);
	int tmp=size[lc[v]],k=flag[v]?1:0;
	if (pos&lt;=tmp) del(lc[v],pos,val);
	else if (pos==tmp+k) flag[v]=false;
	else del(rc[v],pos-tmp-k,val);
	update(v);
}
void modify(int v,int pos,int pre,int now)
{
	E[v].del(pre),E[v].ins(now);
	int tmp=size[lc[v]],k=flag[v]?1:0;
	if (pos&lt;=tmp) modify(lc[v],pos,pre,now);
	else if (pos==tmp+k) key[v]=now;
	else modify(rc[v],pos-tmp-k,pre,now);
	update(v);
}
void get(int v,int l,int r)
{
	if (!v) return;
	int tmp=size[lc[v]],k=flag[v]?1:0;
	if (l==1&amp;&amp;r==size[v]) {B[++n2]=v;return;}
	if (r&lt;=tmp) {get(lc[v],l,r);return;}
	if (l&gt;tmp+k) {get(rc[v],l-tmp-k,r-tmp-k);return;}
	if (flag[v]) A[++n1]=v;
	if (l&lt;=tmp) get(lc[v],l,tmp);
	if (r&gt;tmp+k) get(rc[v],1,r-tmp-k);
}
struct He
{
	int a,b;
	void clear() {a=b=0;}
	void push(int x)
	{
		if (x&gt;a) b=a,a=x;
		else if (x&gt;b) b=x;
	}
	int get() {return b;}
} he;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	int i,x,y;
	for (i=1;i&lt;=n;i++)
		read(key[i]),b[i]=i,flag[i]=true;
	TTT1=n;
	root=build(1,n);
	int lastans=0;
	for (;m;m--)
	{
		char ch=getchar();
		while (ch!='I'&amp;&amp;ch!='D'&amp;&amp;ch!='C'&amp;&amp;ch!='F') ch=getchar();
		if (ch=='I')
		{
			read(x),read(y);
			x=(x+lastans)%n+1,y=(y+lastans)%1048576;
			need=0;
			ins(root,x-1,y,0);
			if (need) rebuild(need);
			n++;
		}
		else if (ch=='D')
		{
			read(x);
			x=(x+lastans)%n+1;
			int val=find(root,x);
			del(root,x,val);
			n--;
		}
		else if (ch=='C')
		{
			read(x),read(y);
			x=(x+lastans)%n+1,y=(y+lastans)%1048576;
			int preval=find(root,x);
			modify(root,x,preval,y);
		}
		else
		{
			read(x),read(y);
			x=(x+lastans)%n+1,y=(y+lastans)%n+1;
			if (x&gt;y) {int t=x;x=y;y=t;}
			n1=n2=0;
			get(root,x,y);
			he.clear();
			for (i=1;i&lt;=n1;i++) he.push(key[A[i]]);
			for (i=1;i&lt;=n2;i++)
			{
				he.push(E[B[i]].find(1));
				if (E[B[i]].size()&gt;1) he.push(E[B[i]].find(2));
			}
			int val=he.get(),ans=0;
			for (i=1;i&lt;=n1;i++)
				ans=max(ans,val^key[A[i]]);
			for (i=1;i&lt;=n2;i++)
				ans=max(ans,E[B[i]].xormax(val));
			printf(&quot;%d\n&quot;,lastans=ans);
		}
	}
	return 0;
}<pre><h2>Problem3217</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
const int NN=200005,AA=40000000,logn=20;
int b[NN],size[NN],maxsize[NN],lc[NN],rc[NN],key[NN],fa[NN],A[NN],B[NN];
int n,m,TTT1,TTT2,need,cnt,root,n1,n2;
bool flag[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9')
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar();
}
struct Huishouzhan
{
	int top,sta[10000000];
	inline void push(int x){sta[++top]=x;}
	inline int go()
	{
		if (!top) return ++TTT2;
		return sta[top--];
	}
} box;
struct trienode
{
	int size,s[2];
} T[AA];
struct trie
{
	int root;
	void ins(int &amp;v,int x,int k,int kind)
	{
		if (!v) v=box.go();
		T[v].size+=kind;
		if (k==0) return;
		if (x&amp;(1&lt;&lt;(k-1))) ins(T[v].s[1],x,k-1,kind);
		else ins(T[v].s[0],x,k-1,kind);
	}
	void huishou(int v)
	{
		if (!v) return;
		huishou(T[v].s[0]),huishou(T[v].s[1]);
		T[v].size=T[v].s[0]=T[v].s[1]=0;
		box.push(v);
	}
	int find(int v,int K,int k)
	{
		if (!v||!k) return 0;
		int tmp=T[T[v].s[1]].size;
		if (K&lt;=tmp) return (1&lt;&lt;(k-1))+find(T[v].s[1],K,k-1);
		else return find(T[v].s[0],K-tmp,k-1);
	}
	int xormax(int v,int x,int k)
	{
		if (!v||!k) return 0;
		bool t=x&amp;(1&lt;&lt;(k-1));
		if (T[T[v].s[t^1]].size)
			return (1&lt;&lt;(k-1))+xormax(T[v].s[t^1],x,k-1);
		else return xormax(T[v].s[t],x,k-1);
	}
	void ins(int x) {ins(root,x,logn,1);}
	void del(int x) {ins(root,x,logn,-1);}
	void huishou() {huishou(root);root=0;}
	int size() {return T[root].size;}
	int find(int K) {return find(root,K,logn);}
	int xormax(int x) {return xormax(root,x,logn);}
} E[NN&lt;&lt;1];
inline void update(int v)
{
	if (!flag[v]) size[v]=size[lc[v]]+size[rc[v]];
	else
	{
		size[v]=size[lc[v]]+size[rc[v]]+1;
		if (size[v]&gt;maxsize[v]) maxsize[v]=size[v];
	}
}
int build(int l,int r)
{
	int mid=(l+r)&gt;&gt;1;
	int v=b[mid];
	for (int i=l;i&lt;=r;i++) E[v].ins(key[b[i]]);
	lc[v]=rc[v]=0;
	if (l&lt;mid) lc[v]=build(l,mid-1),fa[lc[v]]=v;
	if (r&gt;mid) rc[v]=build(mid+1,r),fa[rc[v]]=v;
	update(v);
	return v;
}
inline bool balance(int v)
{
	double tmp=maxsize[v]*0.88;
	return maxsize[lc[v]]&lt;tmp&amp;&amp;maxsize[rc[v]]&lt;tmp;
}
void ins(int &amp;v,int pos,int x,int ff)
{
	if (v==0)
	{
		v=++TTT1;
		key[v]=x;
		fa[v]=ff;
		size[v]=1;
		flag[v]=true;
		E[v].ins(x);
		return;
	}
	E[v].ins(x);
	int tmp=size[lc[v]],k=flag[v]?1:0;
	if (pos&lt;=tmp) ins(lc[v],pos,x,v);
	else ins(rc[v],pos-tmp-k,x,v);
	update(v);
	if (!balance(v)) need=v;
}
void bianli(int v)
{
	if (lc[v]) bianli(lc[v]);
	E[v].huishou();
	if (flag[v]) b[++cnt]=v;
	if (rc[v]) bianli(rc[v]);
}
void rebuild(int v)
{
	int f=fa[v],p=(v==lc[f]);
	cnt=0;
	bianli(v);
	int t=build(1,cnt);
	fa[t]=f;
	if (p) lc[f]=t;else rc[f]=t;
	if (v==root) root=t;
}
int find(int v,int pos)
{
	int tmp=size[lc[v]],k=flag[v]?1:0;
	if (pos&lt;=tmp) return find(lc[v],pos);
	else if (pos==tmp+k) return key[v];
	else return find(rc[v],pos-tmp-k);
}
void del(int v,int pos,int val)
{
	E[v].del(val);
	int tmp=size[lc[v]],k=flag[v]?1:0;
	if (pos&lt;=tmp) del(lc[v],pos,val);
	else if (pos==tmp+k) flag[v]=false;
	else del(rc[v],pos-tmp-k,val);
	update(v);
}
void modify(int v,int pos,int pre,int now)
{
	E[v].del(pre),E[v].ins(now);
	int tmp=size[lc[v]],k=flag[v]?1:0;
	if (pos&lt;=tmp) modify(lc[v],pos,pre,now);
	else if (pos==tmp+k) key[v]=now;
	else modify(rc[v],pos-tmp-k,pre,now);
	update(v);
}
void get(int v,int l,int r)
{
	if (!v) return;
	int tmp=size[lc[v]],k=flag[v]?1:0;
	if (l==1&amp;&amp;r==size[v]) {B[++n2]=v;return;}
	if (r&lt;=tmp) {get(lc[v],l,r);return;}
	if (l&gt;tmp+k) {get(rc[v],l-tmp-k,r-tmp-k);return;}
	if (flag[v]) A[++n1]=v;
	if (l&lt;=tmp) get(lc[v],l,tmp);
	if (r&gt;tmp+k) get(rc[v],1,r-tmp-k);
}
struct He
{
	int a,b;
	void clear() {a=b=0;}
	void push(int x)
	{
		if (x&gt;a) b=a,a=x;
		else if (x&gt;b) b=x;
	}
	int get() {return b;}
} he;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	int i,x,y;
	for (i=1;i&lt;=n;i++)
		read(key[i]),b[i]=i,flag[i]=true;
	TTT1=n;
	root=build(1,n);
	int lastans=0;
	for (;m;m--)
	{
		char ch=getchar();
		while (ch!='I'&amp;&amp;ch!='D'&amp;&amp;ch!='C'&amp;&amp;ch!='F') ch=getchar();
		if (ch=='I')
		{
			read(x),read(y);
			x=(x+lastans)%n+1,y=(y+lastans)%1048576;
			need=0;
			ins(root,x-1,y,0);
			if (need) rebuild(need);
			n++;
		}
		else if (ch=='D')
		{
			read(x);
			x=(x+lastans)%n+1;
			int val=find(root,x);
			del(root,x,val);
			n--;
		}
		else if (ch=='C')
		{
			read(x),read(y);
			x=(x+lastans)%n+1,y=(y+lastans)%1048576;
			int preval=find(root,x);
			modify(root,x,preval,y);
		}
		else
		{
			read(x),read(y);
			x=(x+lastans)%n+1,y=(y+lastans)%n+1;
			if (x&gt;y) {int t=x;x=y;y=t;}
			n1=n2=0;
			get(root,x,y);
			he.clear();
			for (i=1;i&lt;=n1;i++) he.push(key[A[i]]);
			for (i=1;i&lt;=n2;i++)
			{
				he.push(E[B[i]].find(1));
				if (E[B[i]].size()&gt;1) he.push(E[B[i]].find(2));
			}
			int val=he.get(),ans=0;
			for (i=1;i&lt;=n1;i++)
				ans=max(ans,val^key[A[i]]);
			for (i=1;i&lt;=n2;i++)
				ans=max(ans,E[B[i]].xormax(val));
			printf(&quot;%d\n&quot;,lastans=ans);
		}
	}
	return 0;
}<pre><h2>Problem3217</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
const int NN=200005,AA=30000000,logn=20;
int b[NN],size[NN],maxsize[NN],lc[NN],rc[NN],key[NN],fa[NN],A[NN],B[NN];
int n,m,TTT1,TTT2,need,cnt,root,n1,n2;
bool flag[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9')
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar();
}
struct Huishouzhan
{
	int top,sta[10000000];
	inline void push(int x){sta[++top]=x;}
	inline int go()
	{
		if (!top) return ++TTT2;
		return sta[top--];
	}
} box;
struct trienode
{
	int size,s[2];
} T[AA];
struct trie
{
	int root;
	void ins(int &amp;v,int x,int k,int kind)
	{
		if (!v) v=box.go();
		T[v].size+=kind;
		if (k==0) return;
		if (x&amp;(1&lt;&lt;(k-1))) ins(T[v].s[1],x,k-1,kind);
		else ins(T[v].s[0],x,k-1,kind);
	}
	void huishou(int v)
	{
		if (!v) return;
		huishou(T[v].s[0]),huishou(T[v].s[1]);
		T[v].size=T[v].s[0]=T[v].s[1]=0;
		box.push(v);
	}
	int find(int v,int K,int k)
	{
		if (!v||!k) return 0;
		int tmp=T[T[v].s[1]].size;
		if (K&lt;=tmp) return (1&lt;&lt;(k-1))+find(T[v].s[1],K,k-1);
		else return find(T[v].s[0],K-tmp,k-1);
	}
	int xormax(int v,int x,int k)
	{
		if (!v||!k) return 0;
		bool t=x&amp;(1&lt;&lt;(k-1));
		if (T[T[v].s[t^1]].size)
			return (1&lt;&lt;(k-1))+xormax(T[v].s[t^1],x,k-1);
		else return xormax(T[v].s[t],x,k-1);
	}
	void ins(int x) {ins(root,x,logn,1);}
	void del(int x) {ins(root,x,logn,-1);}
	void huishou() {huishou(root);root=0;}
	int size() {return T[root].size;}
	int find(int K) {return find(root,K,logn);}
	int xormax(int x) {return xormax(root,x,logn);}
} E[NN];
inline void update(int v)
{
	if (!flag[v]) size[v]=size[lc[v]]+size[rc[v]];
	else
	{
		size[v]=size[lc[v]]+size[rc[v]]+1;
		if (size[v]&gt;maxsize[v]) maxsize[v]=size[v];
	}
}
int build(int l,int r)
{
	int mid=(l+r)&gt;&gt;1;
	int v=b[mid];
	for (int i=l;i&lt;=r;i++) E[v].ins(key[b[i]]);
	lc[v]=rc[v]=0;
	if (l&lt;mid) lc[v]=build(l,mid-1),fa[lc[v]]=v;
	if (r&gt;mid) rc[v]=build(mid+1,r),fa[rc[v]]=v;
	update(v);
	return v;
}
inline bool balance(int v)
{
	double tmp=maxsize[v]*0.88;
	return maxsize[lc[v]]&lt;tmp&amp;&amp;maxsize[rc[v]]&lt;tmp;
}
void ins(int &amp;v,int pos,int x,int ff)
{
	if (v==0)
	{
		v=++TTT1;
		key[v]=x;
		fa[v]=ff;
		size[v]=1;
		flag[v]=true;
		E[v].ins(x);
		return;
	}
	E[v].ins(x);
	int tmp=size[lc[v]],k=flag[v]?1:0;
	if (pos&lt;=tmp) ins(lc[v],pos,x,v);
	else ins(rc[v],pos-tmp-k,x,v);
	update(v);
	if (!balance(v)) need=v;
}
void bianli(int v)
{
	if (lc[v]) bianli(lc[v]);
	E[v].huishou();
	if (flag[v]) b[++cnt]=v;
	if (rc[v]) bianli(rc[v]);
}
void rebuild(int v)
{
	int f=fa[v],p=(v==lc[f]);
	cnt=0;
	bianli(v);
	int t=build(1,cnt);
	fa[t]=f;
	if (p) lc[f]=t;else rc[f]=t;
	if (v==root) root=t;
}
int find(int v,int pos)
{
	int tmp=size[lc[v]],k=flag[v]?1:0;
	if (pos&lt;=tmp) return find(lc[v],pos);
	else if (pos==tmp+k) return key[v];
	else return find(rc[v],pos-tmp-k);
}
void del(int v,int pos,int val)
{
	E[v].del(val);
	int tmp=size[lc[v]],k=flag[v]?1:0;
	if (pos&lt;=tmp) del(lc[v],pos,val);
	else if (pos==tmp+k) flag[v]=false;
	else del(rc[v],pos-tmp-k,val);
	update(v);
}
void modify(int v,int pos,int pre,int now)
{
	E[v].del(pre),E[v].ins(now);
	int tmp=size[lc[v]],k=flag[v]?1:0;
	if (pos&lt;=tmp) modify(lc[v],pos,pre,now);
	else if (pos==tmp+k) key[v]=now;
	else modify(rc[v],pos-tmp-k,pre,now);
	update(v);
}
void get(int v,int l,int r)
{
	if (!v) return;
	int tmp=size[lc[v]],k=flag[v]?1:0;
	if (l==1&amp;&amp;r==size[v]) {B[++n2]=v;return;}
	if (r&lt;=tmp) {get(lc[v],l,r);return;}
	if (l&gt;tmp+k) {get(rc[v],l-tmp-k,r-tmp-k);return;}
	if (flag[v]) A[++n1]=v;
	if (l&lt;=tmp) get(lc[v],l,tmp);
	if (r&gt;tmp+k) get(rc[v],1,r-tmp-k);
}
struct He
{
	int a,b;
	void clear() {a=b=0;}
	void push(int x)
	{
		if (x&gt;a) b=a,a=x;
		else if (x&gt;b) b=x;
	}
	int get() {return b;}
} he;
int main()
{
	read(n),read(m);
	int i,x,y;
	for (i=1;i&lt;=n;i++)
		read(key[i]),b[i]=i,flag[i]=true;
	TTT1=n;
	root=build(1,n);
	int lastans=0;
	for (;m;m--)
	{
		char ch=getchar();
		while (ch!='I'&amp;&amp;ch!='D'&amp;&amp;ch!='C'&amp;&amp;ch!='F') ch=getchar();
		if (ch=='I')
		{
			read(x),read(y);
			x=(x+lastans)%n+1,y=(y+lastans)%1048576;
			need=0;
			ins(root,x-1,y,0);
			if (need) rebuild(need);
			n++;
		}
		else if (ch=='D')
		{
			read(x);
			x=(x+lastans)%n+1;
			int val=find(root,x);
			del(root,x,val);
			n--;
		}
		else if (ch=='C')
		{
			read(x),read(y);
			x=(x+lastans)%n+1,y=(y+lastans)%1048576;
			int preval=find(root,x);
			modify(root,x,preval,y);
		}
		else
		{
			read(x),read(y);
			x=(x+lastans)%n+1,y=(y+lastans)%n+1;
			n1=n2=0;
			get(root,x,y);
			he.clear();
			for (i=1;i&lt;=n1;i++) he.push(key[A[i]]);
			for (i=1;i&lt;=n2;i++)
			{
				he.push(E[B[i]].find(1));
				if (E[B[i]].size()&gt;1) he.push(E[B[i]].find(2));
			}
			int val=he.get(),ans=0;
			for (i=1;i&lt;=n1;i++)
				ans=max(ans,val^key[A[i]]);
			for (i=1;i&lt;=n2;i++)
				ans=max(ans,E[B[i]].xormax(val));
			printf(&quot;%d\n&quot;,lastans=ans);
		}
	}
	return 0;
}<pre><h2>Problem3218</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define inf 1000000005
#define INF 9999999999999999ll
#define h(x) (((x)&lt;&lt;1)-1)
#define h2(x) ((x)&lt;&lt;1)
const int AA=210000;
int o[AA],aa[AA&lt;&lt;2][3],lc[AA],rc[AA],root[AA],deep[AA],cur[AA];
int n,TTT,S,T,tot=1,ww,ee;
LL ans;
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline void add(int p,int q,int v)
{
	//printf(&quot;add %d %d %d\n&quot;,p,q,v);
	addedge(p,q,v);
	addedge(q,p,0);
}
void find(int v,int l,int r,int x)
{
	if (!v) return;
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		add(x,v,inf);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) find(lc[v],l,mid,x);
	if (ee&gt;mid) find(rc[v],mid,r,x);
}
void ins(int &amp;v,int u,int l,int r,int x,int go)
{
	if (!v)
	{
		v=++TTT;
		if (u) add(v,u,inf);
	}
	//printf(&quot;ins %d %d %d %d %d %d\n&quot;,v,u,l,r,x,go);
	if (r-l==1)
	{
		add(v,go,inf);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid)
		rc[v]=rc[u],ins(lc[v],lc[u],l,mid,x,go);
	else
		lc[v]=lc[u],ins(rc[v],rc[u],mid,r,x,go);
	if (lc[v]) add(v,lc[v],inf);
	if (rc[v]) add(v,rc[v],inf);
}
struct ppt
{
	int a,b,w,l,r,p;
	void in(int i)
	{
		//printf(&quot;\n--------------------------------------------------------\n&quot;);
		scanf(&quot;%d%d%d%d%d%d&quot;,&amp;a,&amp;b,&amp;w,&amp;l,&amp;r,&amp;p);
		ans+=b+w;
		add(h(i),h2(i),p);
		add(S,h(i),b),add(h(i),T,w);
		ww=l,ee=r+1;
		find(root[i-1],0,inf,h2(i));
		//printf(&quot;=================\n&quot;);
		ins(root[i],root[i-1],0,inf,a,h(i));
	}
} q[5011];
bool bfs()
{
	static int que[AA];
	int head=0,tail=1;
	que[1]=S;
	for (int i=1;i&lt;=TTT;i++) deep[i]=0;
	deep[S]=1;
	while (head&lt;tail)
	{
		int x=que[++head];
		cur[x]=o[x];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y])
			{
				deep[y]=deep[x]+1;
				que[++tail]=y;
			}
		}
	}
	return deep[T];
}
LL dfs(int v,LL ff)
{
	if (v==T) return ff;
	LL res=0;
	for (int &amp;p=cur[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		LL tmp=dfs(y,min(ff,(LL)aa[p][2]));
		ff-=tmp,aa[p][2]-=tmp;
		aa[p^1][2]+=tmp,res+=tmp;
		if (ff==0) break;
	}
	if (res==0) deep[v]=inf;
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	S=n*2+1,T=S+1,TTT=S+2;
	for (int i=1;i&lt;=n;i++) q[i].in(i);
	while (bfs()) ans-=dfs(S,INF);
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem3218</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;

#define lson(x) (tr[x].l)
#define rson(x) (tr[x].r)
#define maxn 5010
#define maxp 170010
#define maxm 1000010
#define inf 0x7fffffff

using namespace std;

int n,ans,B[maxn],W[maxn],l[maxn],r[maxn],p[maxn],tot=1,A[maxn],su,sv,b[maxp],R;
int num,cnt,dep[maxp],Rt[maxn],tmp[maxp];

struct edge{
    int x,y,w,last;
}a[maxm&lt;&lt;1];

void add(int x,int y,int w)
{
    a[++tot]=(edge){x,y,w,b[x]};
    b[x]=tot;
}

void Add(int x,int y,int w)
{
    //printf(&quot;%d %d %d\n&quot;,x,y,w);
    add(x,y,w);
    add(y,x,0);
}

bool cmp(int x,int y)
{
    return dep[x]&lt;dep[y];
}

struct Tree{
    struct node{
        int l,r,o,dep;
        bool flag;
    }tr[maxp];
    void modify(int pos,int l,int r,int lx,int &amp;x,int p,int deps){
        x=++num;
        tr[x]=tr[lx];
        tr[x].o=++cnt;
        if(tr[lx].o) Add(tr[lx].o,tr[x].o,inf);
        if(l==r){
            Add(p,tr[x].o,inf);
            return;
        }
        int mid=(l+r)&gt;&gt;1;
        if(pos&lt;=mid) modify(pos,l,mid,lson(lx),lson(x),p,deps+1);
        else modify(pos,mid+1,r,rson(lx),rson(x),p,deps+1);
    }
    void modify(int pos,int lrt,int &amp;rt,int p){
        modify(pos,0,R,lrt,rt,p,1);
    }
    void query(int al,int ar,int l,int r,int x,int p){
        if(!x) return;
        if(al&lt;=l&amp;&amp;r&lt;=ar){
            //printf(&quot;%d %d\n&quot;,l,r);
            tr[x].flag=1;
            Add(tr[x].o,p+n,inf);
            return;
        }
        int mid=(l+r)&gt;&gt;1;
        if(al&lt;=mid) query(al,ar,l,mid,lson(x),p);
        if(ar&gt;mid) query(al,ar,mid+1,r,rson(x),p);
    }
    void query(int al,int ar,int rt,int p){
        query(al,ar,0,R,rt,p);
    }
    void build(){
        for(int i=1;i&lt;=num;i++){
            if(lson(i)) Add(tr[lson(i)].o,tr[i].o,inf);
            if(rson(i)) Add(tr[rson(i)].o,tr[i].o,inf);
        }
    }
}T;

#define v a[i].y
bool bfs()
{
    queue&lt;int&gt; q;
    q.push(su);
    memset(dep,0,sizeof(dep));
    dep[su]=1;
    while(!q.empty()){
        int x=q.front();q.pop();
        for(int i=b[x];i;i=a[i].last){
            if(!dep[v]&amp;&amp;a[i].w){
                dep[v]=dep[x]+1;
                if(v==sv) return 1;
                q.push(v);
            }
        }
    }
    return 0;
}

int Dinic(int x,int flow)
{
    if(x==sv) return flow;
    int remain=flow;
    for(int i=b[x];i;i=a[i].last){
        if(!remain) return flow;
        if(a[i].w&amp;&amp;dep[v]==dep[x]+1){
            int tmp=Dinic(v,min(remain,a[i].w));
            if(!tmp){
                dep[v]=0;
                continue;
            }
            a[i].w-=tmp;
            a[i^1].w+=tmp;
            remain-=tmp;
        }
    }
    return flow-remain;
}

int main()
{
//	freopen(&quot;ts.in&quot;, &quot;r&quot;, stdin);
//	freopen(&quot;lgl.out&quot;, &quot;w&quot;, stdout);
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++){
        scanf(&quot;%d%d%d%d%d%d&quot;,&amp;A[i],&amp;B[i],&amp;W[i],&amp;l[i],&amp;r[i],&amp;p[i]);
        R=max(R,A[i]);
        ans=ans+B[i]+W[i];
    }
    sv=cnt=2*n+1;
    for(int i=1;i&lt;=n;i++){
        if(i!=1) T.query(l[i],r[i],Rt[i-1],i);
        T.modify(A[i],Rt[i-1],Rt[i],i);
    }
    for(int i=1;i&lt;=n;i++){
        Add(su,i,W[i]);
        Add(i,sv,B[i]);
        Add(i+n,i,p[i]);
    }
    T.build();
    int tmp;
  //  printf(&quot;ans = %lld\n&quot;, ans);
    while(bfs()) while(tmp=Dinic(su,inf)) ans-=tmp;
    printf(&quot;%d&quot;,ans);
   // while(1);
    return 0;
}
<pre><h2>Problem3223</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int fa[110000],son[110000][2],key[110000],S[110000],n,m,i,a[110000],b[110000],sss,ll,rr,root;
bool tag[110000];
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
void update(int v)
{
	int x=son[v][0],y=son[v][1];
	S[v]=S[x]+S[y]+1;
}
void make(int v)
{
	tag[v]^=1;
	swap(son[v][0],son[v][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	if (son[v][0]) make(son[v][0]);
	if (son[v][1]) make(son[v][1]);
	tag[v]=0;
}
int splaybuild(int l,int r)
{
	int mid=(l+r)&gt;&gt;1;
	int now=++sss;
	key[now]=a[mid];
	S[now]=1;
	tag[now]=0;
	if (l&lt;mid)
	{
		son[now][0]=splaybuild(l,mid-1);
		fa[son[now][0]]=now;
	}
	if (mid&lt;r)
	{
		son[now][1]=splaybuild(mid+1,r);
		fa[son[now][1]]=now;
	}
	update(now);
	return now;
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y);
	pushdown(t);
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y);
	update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
}
int select(int t,int x)
{
	for (;t;)
	{
		pushdown(t);
		if (x==S[son[t][0]]+1) return t;
		else if (x&lt;=S[son[t][0]]) t=son[t][0];
		else x-=(S[son[t][0]]+1),t=son[t][1];
	}
	return 0;
}
void zhong(int t)
{
	pushdown(t);
	if (son[t][0]) zhong(son[t][0]);
	b[++b[0]]=key[t];
	if (son[t][1]) zhong(son[t][1]);
}
void debug(int t)
{
	pushdown(t);
	if (son[t][0]) debug(son[t][0]);
	printf(&quot;%d &quot;,key[t]);
	if (son[t][1]) debug(son[t][1]);
	if (t==root) printf(&quot;\n&quot;);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	a[1]=0;
	for (i=2;i&lt;=n+1;i++) a[i]=i-1;
	a[n+2]=0;
	root=splaybuild(1,n+2);
	//printf(&quot;At first:  &quot;);debug(root);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;ll,&amp;rr);
		++ll,++rr;
		int x=select(root,ll-1);
		splay(x,0);
		int y=select(root,rr+1);
		splay(y,root);
		x=son[y][0];
		make(x);
		splay(x,0);
		//printf(&quot;When i=1:   &quot;);debug(root);
	}
	zhong(root);
	for (i=2;i&lt;=n+1;i++) printf(&quot;%d &quot;,b[i]);
	return 0;
}
<pre><h2>Problem3224</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int S[110000],son[110000][2],num[110000],fa[110000],key[110000];
int root,x,n,t,size;
void update(int t)
{
	S[t]=S[son[t][0]]+S[son[t][1]]+num[t];
}
void rotate(int t,int p)
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][1-p]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
	update(y);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(t,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(t,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
	update(t);
}
void ins(int t,int x)
{
	if (t==0)
	{
		root=++size;
		key[root]=x;
		num[root]=S[root]=1;
		fa[root]=son[root][0]=son[root][1]=0;
		return;
	}
	for (;t;)
	{
		++S[t];
		if (x==key[t]) {++num[t];return;}
		if (son[t][x&gt;=key[t]]==0)
		{
			int y=++size;
			son[t][x&gt;key[t]]=y;
			key[y]=x;
			fa[y]=t;
			son[y][0]=son[y][1]=0;
			num[y]=S[y]=1;
			t=y;
			break;
		}
		t=son[t][x&gt;=key[t]];
	}
	splay(t,0);
}
void del(int t,int x)
{
	for (;t;)
	{
		--S[t];
		if (key[t]==x) {--num[t];break;}
		t=son[t][x&gt;=key[t]];
	}
	if (num[t]) return;
	splay(t,0);
	if (son[t][0]==0) {root=son[t][1],fa[root]=0;return;}
	if (son[t][1]==0) {root=son[t][0],fa[root]=0;return;}
	int y=son[root][0];
	while (son[y][1]) y=son[y][1];
	splay(y,root);
	son[y][1]=son[root][1];
	fa[son[root][1]]=y;
	S[y]=S[root];
	fa[y]=0;
	root=y;
}
int rank(int t,int x)
{
	int res=0;
	for (;t;)
	{
		if (x&lt;key[t]) t=son[t][0];
		else if (x==key[t]) return res+S[son[t][0]]+1;
		else
		{
			res+=S[son[t][0]]+num[t];
			t=son[t][1];
		}
	}
	return res;
}
int select(int t,int x)
{
	for (;t;)
	{
		if (x&gt;S[son[t][0]]&amp;&amp;x&lt;=S[son[t][0]]+num[t]) return key[t];
		if (x&lt;=S[son[t][0]]) t=son[t][0];
		else
		{
			x-=(S[son[t][0]]+num[t]);
			t=son[t][1];
		}
	}
}
int pred(int t,int x)
{
	int res;
	for (;t;)
		if (x&gt;key[t]) res=key[t],t=son[t][1];
		else t=son[t][0];
	return res;
}
int succ(int t,int x)
{
	int res;
	for (;t;)
		if (x&lt;key[t]) res=key[t],t=son[t][0];
		else t=son[t][1];
	return res;
}
int main()
{
	//freopen(&quot;input1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d&quot;,&amp;n);
	//printf(&quot;%d\n\n&quot;,n);
	for (;n;n--)
	{
		scanf(&quot;%d%d&quot;,&amp;t,&amp;x);
		if (n==10)
		{
			t++;
			t--;
		}
		//printf(&quot;%d %d %d\n&quot;,n,t,x);
		if (t==1) ins(root,x);
		else if (t==2) del(root,x);
		else if (t==3) printf(&quot;%d\n&quot;,rank(root,x));
		else if (t==4) printf(&quot;%d\n&quot;,select(root,x));
		else if (t==5) printf(&quot;%d\n&quot;,pred(root,x));
		else printf(&quot;%d\n&quot;,succ(root,x));
	}
	return 0;
}<pre><h2>Problem3224</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int S[110000],son[110000][2],num[110000],fa[110000],key[110000];
int root,x,n,t,size;
void update(int t)
{
	S[t]=S[son[t][0]]+S[son[t][1]]+num[t];
}
void rotate(int t,int p)
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][1-p]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
	update(y);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(t,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(t,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
	update(t);
}
void ins(int t,int x)
{
	if (t==0)
	{
		root=++size;
		key[root]=x;
		num[root]=S[root]=1;
		fa[root]=son[root][0]=son[root][1]=0;
		return;
	}
	for (;t;)
	{
		++S[t];
		if (x==key[t]) {++num[t];return;}
		if (son[t][x&gt;=key[t]]==0)
		{
			son[t][x&gt;key[t]]=++size;
			key[size]=x;
			fa[size]=t;
			son[size][0]=son[size][1]=0;
			num[size]=S[size]=1;
			splay(size,0);
			break;
		}
		t=son[t][x&gt;=key[t]];
	}
}
void del(int t,int x)
{
	for (;t;)
	{
		--S[t];
		if (key[t]==x) {--num[t];break;}
		t=son[t][x&gt;=key[t]];
	}
	if (num[t]) return;
	splay(t,0);
	if (son[t][0]==0) {root=son[t][1],fa[root]=0;return;}
	if (son[t][1]==0) {root=son[t][0],fa[root]=0;return;}
	int y=son[root][0];
	while (son[y][1]) y=son[y][1];
	splay(y,root);
	son[y][1]=son[root][1];
	fa[son[root][1]]=y;
	S[y]=S[root];
	fa[y]=0;
	root=y;
}
int rank(int t,int x)
{
	int res=0;
	for (;t;)
	{
		if (x&lt;key[t]) t=son[t][0];
		else if (x==key[t]) return res+S[son[t][0]]+1;
		else
		{
			res+=S[son[t][0]]+num[t];
			t=son[t][1];
		}
	}
	return res;
}
int select(int t,int x)
{
	for (;t;)
	{
		if (x&gt;S[son[t][0]]&amp;&amp;x&lt;=S[son[t][0]]+num[t]) return key[t];
		if (x&lt;=S[son[t][0]]) t=son[t][0];
		else
		{
			x-=(S[son[t][0]]+num[t]);
			t=son[t][1];
		}
	}
}
int pred(int t,int x)
{
	int res;
	for (;t;)
		if (x&gt;key[t]) res=key[t],t=son[t][1];
		else t=son[t][0];
	return res;
}
int succ(int t,int x)
{
	int res;
	for (;t;)
		if (x&lt;key[t]) res=key[t],t=son[t][0];
		else t=son[t][1];
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d&quot;,&amp;n);
	for (;n;n--)
	{
		scanf(&quot;%d%d&quot;,&amp;t,&amp;x);
		if (n==10)
		{
			t++;
			t--;
		}
		if (t==1) ins(root,x);
		else if (t==2) del(root,x);
		else if (t==3) printf(&quot;%d\n&quot;,rank(root,x));
		else if (t==4) printf(&quot;%d\n&quot;,select(root,x));
		else if (t==5) printf(&quot;%d\n&quot;,pred(root,x));
		else printf(&quot;%d\n&quot;,succ(root,x));
	}
	return 0;
}<pre><h2>Problem3224</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int S[110000],son[110000][2],num[110000],fa[110000],key[110000];
int root,x,n,t,size;
void update(int t)
{
	S[t]=S[son[t][0]]+S[son[t][1]]+num[t];
}
void rotate(int t,int p)
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][1-p]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
	update(y);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(t,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(t,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
	update(t);
}
void ins(int t,int x)
{
	if (t==0)
	{
		root=++size;
		key[root]=x;
		num[root]=S[root]=1;
		fa[root]=son[root][0]=son[root][1]=0;
		return;
	}
	for (;t;)
	{
		++S[t];
		if (x==key[t])
		{
			++num[t];
			splay(t,0);
			return;
		}
		if (son[t][x&gt;=key[t]]==0)
		{
			son[t][x&gt;key[t]]=++size;
			key[size]=x;
			fa[size]=t;
			son[size][0]=son[size][1]=0;
			num[size]=S[size]=1;
			splay(size,0);
			break;
		}
		t=son[t][x&gt;=key[t]];
	}
}
void del(int t,int x)
{
	for (;t;)
	{
		--S[t];
		if (key[t]==x) {--num[t];break;}
		t=son[t][x&gt;=key[t]];
	}
	if (num[t]) return;
	splay(t,0);
	if (son[t][0]==0) {root=son[t][1],fa[root]=0;return;}
	if (son[t][1]==0) {root=son[t][0],fa[root]=0;return;}
	int y=son[root][0];
	while (son[y][1]) y=son[y][1];
	splay(y,root);
	son[y][1]=son[root][1];
	fa[son[root][1]]=y;
	S[y]=S[root];
	fa[y]=0;
	root=y;
}
int rank(int t,int x)
{
	int res=0;
	for (;t;)
	{
		if (x&lt;key[t]) t=son[t][0];
		else if (x==key[t]) return res+S[son[t][0]]+1;
		else
		{
			res+=S[son[t][0]]+num[t];
			t=son[t][1];
		}
	}
	return res;
}
int select(int t,int x)
{
	for (;t;)
	{
		if (x&gt;S[son[t][0]]&amp;&amp;x&lt;=S[son[t][0]]+num[t]) return key[t];
		if (x&lt;=S[son[t][0]]) t=son[t][0];
		else
		{
			x-=(S[son[t][0]]+num[t]);
			t=son[t][1];
		}
	}
}
int pred(int t,int x)
{
	int res;
	for (;t;)
		if (x&gt;key[t]) res=key[t],t=son[t][1];
		else t=son[t][0];
	return res;
}
int succ(int t,int x)
{
	int res;
	for (;t;)
		if (x&lt;key[t]) res=key[t],t=son[t][0];
		else t=son[t][1];
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d&quot;,&amp;n);
	for (;n;n--)
	{
		scanf(&quot;%d%d&quot;,&amp;t,&amp;x);
		if (n==10)
		{
			t++;
			t--;
		}
		if (t==1) ins(root,x);
		else if (t==2) del(root,x);
		else if (t==3) printf(&quot;%d\n&quot;,rank(root,x));
		else if (t==4) printf(&quot;%d\n&quot;,select(root,x));
		else if (t==5) printf(&quot;%d\n&quot;,pred(root,x));
		else printf(&quot;%d\n&quot;,succ(root,x));
	}
	return 0;
}<pre><h2>Problem3224</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int S[110000],son[110000][2],num[110000],fa[110000],key[110000];
int root,x,n,t,size;
void update(int t)
{
	S[t]=S[son[t][0]]+S[son[t][1]]+num[t];
}
void rotate(int t,int p)
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
	update(y);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(t,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(t,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
	update(t);
}
void ins(int t,int x)
{
	if (t==0)
	{
		root=++size;
		key[root]=x;
		num[root]=S[root]=1;
		fa[root]=son[root][0]=son[root][1]=0;
		return;
	}
	for (;;)
	{
		++S[t];
		if (x==key[t])
		{
			++num[t];
			splay(t,0);
			return;
		}
		if (son[t][x&gt;=key[t]]==0)
		{
			son[t][x&gt;key[t]]=++size;
			key[size]=x;
			fa[size]=t;
			son[size][0]=son[size][1]=0;
			num[size]=S[size]=1;
			splay(size,0);
			break;
		}
		t=son[t][x&gt;=key[t]];
	}
}
void del(int t,int x)
{
	for (;t;)
	{
		--S[t];
		if (key[t]==x) {--num[t];break;}
		t=son[t][x&gt;=key[t]];
	}
	if (t==0||num[t]) return;
	splay(t,0);
	if (son[t][0]==0) {root=son[t][1],fa[root]=0;return;}
	if (son[t][1]==0) {root=son[t][0],fa[root]=0;return;}
	int y;
	for (y=son[t][0];son[y][1];y=son[y][1]);
	splay(y,root);
	son[y][1]=son[root][1];
	fa[son[root][1]]=y;
	fa[y]=0;
	update(y);
	root=y;
}
int rank(int t,int x)
{
	int res=0;
	for (;t;)
	{
		if (x&lt;key[t]) t=son[t][0];
		else if (x==key[t]) return res+S[son[t][0]]+1;
		else
		{
			res+=S[son[t][0]]+num[t];
			t=son[t][1];
		}
	}
	return res;
}
int select(int t,int x)
{
	for (;t;)
	{
		if (x&gt;S[son[t][0]]&amp;&amp;x&lt;=S[son[t][0]]+num[t]) return key[t];
		if (x&lt;=S[son[t][0]]) t=son[t][0];
		else
		{
			x-=(S[son[t][0]]+num[t]);
			t=son[t][1];
		}
	}
}
int pred(int t,int x)
{
	int res;
	for (;t;)
		if (x&gt;key[t]) res=key[t],t=son[t][1];
		else t=son[t][0];
	return res;
}
int succ(int t,int x)
{
	int res;
	for (;t;)
		if (x&lt;key[t]) res=key[t],t=son[t][0];
		else t=son[t][1];
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d&quot;,&amp;n);
	for (;n;n--)
	{
		scanf(&quot;%d%d&quot;,&amp;t,&amp;x);
		if (t==1) ins(root,x);
		else if (t==2) del(root,x);
		else if (t==3) printf(&quot;%d\n&quot;,rank(root,x));
		else if (t==4) printf(&quot;%d\n&quot;,select(root,x));
		else if (t==5) printf(&quot;%d\n&quot;,pred(root,x));
		else printf(&quot;%d\n&quot;,succ(root,x));
	}
	return 0;
}<pre><h2>Problem3224</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int S[110000],son[110000][2],num[110000],fa[110000],key[110000];
int root,x,n,t,size;
void update(int t)
{
	S[t]=S[son[t][0]]+S[son[t][1]]+num[t];
}
void rotate(int t,int p)
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
	update(y);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(t,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(t,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
	update(t);
}
void ins(int t,int x)
{
	if (t==0)
	{
		root=++size;
		key[root]=x;
		num[root]=S[root]=1;
		fa[root]=son[root][0]=son[root][1]=0;
		return;
	}
	for (;;)
	{
		++S[t];
		if (x==key[t])
		{
			++num[t];
			return;
		}
		if (son[t][x&gt;=key[t]]==0)
		{
			son[t][x&gt;key[t]]=++size;
			key[size]=x;
			fa[size]=t;
			son[size][0]=son[size][1]=0;
			num[size]=S[size]=1;
			splay(size,0);
			break;
		}
		t=son[t][x&gt;=key[t]];
	}
}
void del(int t,int x)
{
	for (;t;)
	{
		--S[t];
		if (key[t]==x) {--num[t];break;}
		t=son[t][x&gt;=key[t]];
	}
	if (t==0||num[t]) return;
	splay(t,0);
	if (son[t][0]==0) {root=son[t][1],fa[root]=0;return;}
	if (son[t][1]==0) {root=son[t][0],fa[root]=0;return;}
	int y;
	for (y=son[t][0];son[y][1];y=son[y][1]);
	splay(y,root);
	son[y][1]=son[root][1];
	fa[son[root][1]]=y;
	fa[y]=0;
	update(y);
	root=y;
}
int rank(int t,int x)
{
	int res=0;
	for (;t;)
	{
		if (x&lt;key[t]) t=son[t][0];
		else if (x==key[t]) return res+S[son[t][0]]+1;
		else
		{
			res+=S[son[t][0]]+num[t];
			t=son[t][1];
		}
	}
	return res;
}
int select(int t,int x)
{
	for (;t;)
	{
		if (x&gt;S[son[t][0]]&amp;&amp;x&lt;=S[son[t][0]]+num[t]) return key[t];
		if (x&lt;=S[son[t][0]]) t=son[t][0];
		else
		{
			x-=(S[son[t][0]]+num[t]);
			t=son[t][1];
		}
	}
}
int pred(int t,int x)
{
	int res;
	for (;t;)
		if (x&gt;key[t]) res=key[t],t=son[t][1];
		else t=son[t][0];
	return res;
}
int succ(int t,int x)
{
	int res;
	for (;t;)
		if (x&lt;key[t]) res=key[t],t=son[t][0];
		else t=son[t][1];
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d&quot;,&amp;n);
	for (;n;n--)
	{
		scanf(&quot;%d%d&quot;,&amp;t,&amp;x);
		if (t==1) ins(root,x);
		else if (t==2) del(root,x);
		else if (t==3) printf(&quot;%d\n&quot;,rank(root,x));
		else if (t==4) printf(&quot;%d\n&quot;,select(root,x));
		else if (t==5) printf(&quot;%d\n&quot;,pred(root,x));
		else printf(&quot;%d\n&quot;,succ(root,x));
	}
	return 0;
}<pre><h2>Problem3224</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int S[110000],son[110000][2],num[110000],fa[110000],key[110000];
int root,x,n,t,size;
void update(int t)
{
	S[t]=S[son[t][0]]+S[son[t][1]]+num[t];
}
void rotate(int t,int p)
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
	update(y);
	update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(t,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(t,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
}
void ins(int t,int x)
{
	if (t==0)
	{
		root=++size;
		key[root]=x;
		num[root]=S[root]=1;
		fa[root]=son[root][0]=son[root][1]=0;
		return;
	}
	for (;;)
	{
		++S[t];
		if (x==key[t])
		{
			++num[t];
			return;
		}
		if (son[t][x&gt;=key[t]]==0)
		{
			son[t][x&gt;key[t]]=++size;
			key[size]=x;
			fa[size]=t;
			son[size][0]=son[size][1]=0;
			num[size]=S[size]=1;
			splay(size,0);
			break;
		}
		t=son[t][x&gt;=key[t]];
	}
}
void del(int t,int x)
{
	for (;t;)
	{
		--S[t];
		if (key[t]==x) {--num[t];break;}
		t=son[t][x&gt;=key[t]];
	}
	if (t==0||num[t]) return;
	splay(t,0);
	if (son[t][0]==0) {root=son[t][1],fa[root]=0;return;}
	if (son[t][1]==0) {root=son[t][0],fa[root]=0;return;}
	int y;
	for (y=son[t][0];son[y][1];y=son[y][1]);
	splay(y,root);
	son[y][1]=son[root][1];
	fa[son[root][1]]=y;
	fa[y]=0;
	update(y);
	root=y;
}
int rank(int t,int x)
{
	int res=0;
	for (;t;)
	{
		if (x&lt;key[t]) t=son[t][0];
		else if (x==key[t]) return res+S[son[t][0]]+1;
		else
		{
			res+=S[son[t][0]]+num[t];
			t=son[t][1];
		}
	}
	return res;
}
int select(int t,int x)
{
	for (;t;)
	{
		if (x&gt;S[son[t][0]]&amp;&amp;x&lt;=S[son[t][0]]+num[t]) return key[t];
		if (x&lt;=S[son[t][0]]) t=son[t][0];
		else
		{
			x-=(S[son[t][0]]+num[t]);
			t=son[t][1];
		}
	}
}
int pred(int t,int x)
{
	int res;
	for (;t;)
		if (x&gt;key[t]) res=key[t],t=son[t][1];
		else t=son[t][0];
	return res;
}
int succ(int t,int x)
{
	int res;
	for (;t;)
		if (x&lt;key[t]) res=key[t],t=son[t][0];
		else t=son[t][1];
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d&quot;,&amp;n);
	for (;n;n--)
	{
		scanf(&quot;%d%d&quot;,&amp;t,&amp;x);
		if (t==1) ins(root,x);
		else if (t==2) del(root,x);
		else if (t==3) printf(&quot;%d\n&quot;,rank(root,x));
		else if (t==4) printf(&quot;%d\n&quot;,select(root,x));
		else if (t==5) printf(&quot;%d\n&quot;,pred(root,x));
		else printf(&quot;%d\n&quot;,succ(root,x));
	}
	return 0;
}<pre><h2>Problem3224</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int S[110000],son[110000][2],num[110000],fa[110000],key[110000];
int root,x,n,t,size;
void update(int t)
{
	S[t]=S[son[t][0]]+S[son[t][1]]+num[t];
}
void rotate(int t,int p)
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
	update(y);
	update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(t,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(t,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
}
void ins(int t,int x)
{
	if (t==0)
	{
		root=++size;
		key[root]=x;
		num[root]=S[root]=1;
		fa[root]=son[root][0]=son[root][1]=0;
		return;
	}
	for (;;)
	{
		++S[t];
		if (x==key[t])
		{
			++num[t];
			splay(t,0);
			return;
		}
		if (son[t][x&gt;=key[t]]==0)
		{
			son[t][x&gt;key[t]]=++size;
			key[size]=x;
			fa[size]=t;
			son[size][0]=son[size][1]=0;
			num[size]=S[size]=1;
			splay(size,0);
			break;
		}
		t=son[t][x&gt;=key[t]];
	}
}
void del(int t,int x)
{
	for (;t;)
	{
		--S[t];
		if (key[t]==x) {--num[t];break;}
		t=son[t][x&gt;=key[t]];
	}
	if (t==0||num[t]) return;
	splay(t,0);
	if (son[t][0]==0) {root=son[t][1],fa[root]=0;return;}
	if (son[t][1]==0) {root=son[t][0],fa[root]=0;return;}
	int y;
	for (y=son[t][0];son[y][1];y=son[y][1]);
	splay(y,root);
	son[y][1]=son[root][1];
	fa[son[root][1]]=y;
	fa[y]=0;
	update(y);
	root=y;
}
int rank(int t,int x)
{
	int res=0;
	for (;t;)
	{
		if (x&lt;key[t]) t=son[t][0];
		else if (x==key[t]) return res+S[son[t][0]]+1;
		else
		{
			res+=S[son[t][0]]+num[t];
			t=son[t][1];
		}
	}
	return res;
}
int select(int t,int x)
{
	for (;t;)
	{
		if (x&gt;S[son[t][0]]&amp;&amp;x&lt;=S[son[t][0]]+num[t]) return key[t];
		if (x&lt;=S[son[t][0]]) t=son[t][0];
		else
		{
			x-=(S[son[t][0]]+num[t]);
			t=son[t][1];
		}
	}
}
int pred(int t,int x)
{
	int res;
	for (;t;)
		if (x&gt;key[t]) res=key[t],t=son[t][1];
		else t=son[t][0];
	return res;
}
int succ(int t,int x)
{
	int res;
	for (;t;)
		if (x&lt;key[t]) res=key[t],t=son[t][0];
		else t=son[t][1];
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d&quot;,&amp;n);
	for (;n;n--)
	{
		scanf(&quot;%d%d&quot;,&amp;t,&amp;x);
		if (t==1) ins(root,x);
		else if (t==2) del(root,x);
		else if (t==3) printf(&quot;%d\n&quot;,rank(root,x));
		else if (t==4) printf(&quot;%d\n&quot;,select(root,x));
		else if (t==5) printf(&quot;%d\n&quot;,pred(root,x));
		else printf(&quot;%d\n&quot;,succ(root,x));
	}
	return 0;
}<pre><h2>Problem3224</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int S[110000],son[110000][2],num[110000],fa[110000],key[110000];
int root,x,n,t,size;
void update(int t)
{
	S[t]=S[son[t][0]]+S[son[t][1]]+num[t];
}
void rotate(int t,int p)
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
	update(y);
	update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(t,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(t,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
}
void ins(int &amp;t,int x,int ff)
{
	if (t==0)
	{
		t=++size;
		key[t]=x;
		fa[t]=ff;
		num[t]=S[t]=1;
		son[t][0]=son[t][1]=0;
		splay(t,0);
		return;
	}
	S[t]++;
	if (x==key[t]) num[t]++;
	else if (x&lt;key[t]) ins(son[t][0],x,t);
	else ins(son[t][1],x,t);
}
void del(int t,int x)
{
	for (;t;)
	{
		--S[t];
		if (key[t]==x) {--num[t];break;}
		t=son[t][x&gt;=key[t]];
	}
	if (t==0||num[t]) return;
	splay(t,0);
	if (son[t][0]==0) {root=son[t][1],fa[root]=0;return;}
	if (son[t][1]==0) {root=son[t][0],fa[root]=0;return;}
	int y;
	for (y=son[t][0];son[y][1];y=son[y][1]);
	splay(y,root);
	son[y][1]=son[root][1];
	fa[son[root][1]]=y;
	fa[y]=0;
	update(y);
	root=y;
}
int rank(int t,int x)
{
	int res=0;
	for (;t;)
	{
		if (x&lt;key[t]) t=son[t][0];
		else if (x==key[t]) return res+S[son[t][0]]+1;
		else
		{
			res+=S[son[t][0]]+num[t];
			t=son[t][1];
		}
	}
	return res;
}
int select(int t,int x)
{
	for (;t;)
	{
		if (x&gt;S[son[t][0]]&amp;&amp;x&lt;=S[son[t][0]]+num[t]) return key[t];
		if (x&lt;=S[son[t][0]]) t=son[t][0];
		else
		{
			x-=(S[son[t][0]]+num[t]);
			t=son[t][1];
		}
	}
}
int pred(int t,int x)
{
	int res;
	for (;t;)
		if (x&gt;key[t]) res=key[t],t=son[t][1];
		else t=son[t][0];
	return res;
}
int succ(int t,int x)
{
	int res;
	for (;t;)
		if (x&lt;key[t]) res=key[t],t=son[t][0];
		else t=son[t][1];
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d&quot;,&amp;n);
	for (;n;n--)
	{
		scanf(&quot;%d%d&quot;,&amp;t,&amp;x);
		if (t==1) ins(root,x,0);
		else if (t==2) del(root,x);
		else if (t==3) printf(&quot;%d\n&quot;,rank(root,x));
		else if (t==4) printf(&quot;%d\n&quot;,select(root,x));
		else if (t==5) printf(&quot;%d\n&quot;,pred(root,x));
		else printf(&quot;%d\n&quot;,succ(root,x));
	}
	return 0;
}<pre><h2>Problem3224</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int S[110000],son[110000][2],num[110000],fa[110000],key[110000];
int root,x,n,t,size;
void update(int t)
{
	S[t]=S[son[t][0]]+S[son[t][1]]+num[t];
}
void rotate(int t,int p)
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
	update(y);
	update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
}
void ins(int &amp;t,int x,int ff)
{
	if (t==0)
	{
		t=++size;
		key[t]=x;
		fa[t]=ff;
		num[t]=S[t]=1;
		son[t][0]=son[t][1]=0;
		splay(t,0);
		return;
	}
	S[t]++;
	if (x==key[t]) num[t]++;
	else if (x&lt;key[t]) ins(son[t][0],x,t);
	else ins(son[t][1],x,t);
}
void del(int t,int x)
{
	for (;t;)
	{
		--S[t];
		if (key[t]==x) {--num[t];break;}
		t=son[t][x&gt;=key[t]];
	}
	if (t==0||num[t]) return;
	splay(t,0);
	if (son[t][0]==0) {root=son[t][1],fa[root]=0;return;}
	if (son[t][1]==0) {root=son[t][0],fa[root]=0;return;}
	int y;
	for (y=son[t][0];son[y][1];y=son[y][1]);
	splay(y,root);
	son[y][1]=son[root][1];
	fa[son[root][1]]=y;
	fa[y]=0;
	update(y);
	root=y;
}
int rank(int t,int x)
{
	int res=0;
	for (;t;)
	{
		if (x&lt;key[t]) t=son[t][0];
		else if (x==key[t]) return res+S[son[t][0]]+1;
		else
		{
			res+=S[son[t][0]]+num[t];
			t=son[t][1];
		}
	}
	return res;
}
int select(int t,int x)
{
	for (;t;)
	{
		if (x&gt;S[son[t][0]]&amp;&amp;x&lt;=S[son[t][0]]+num[t]) return key[t];
		if (x&lt;=S[son[t][0]]) t=son[t][0];
		else
		{
			x-=(S[son[t][0]]+num[t]);
			t=son[t][1];
		}
	}
}
int pred(int t,int x)
{
	int res;
	for (;t;)
		if (x&gt;key[t]) res=key[t],t=son[t][1];
		else t=son[t][0];
	return res;
}
int succ(int t,int x)
{
	int res;
	for (;t;)
		if (x&lt;key[t]) res=key[t],t=son[t][0];
		else t=son[t][1];
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d&quot;,&amp;n);
	for (;n;n--)
	{
		scanf(&quot;%d%d&quot;,&amp;t,&amp;x);
		if (t==1) ins(root,x,0);
		else if (t==2) del(root,x);
		else if (t==3) printf(&quot;%d\n&quot;,rank(root,x));
		else if (t==4) printf(&quot;%d\n&quot;,select(root,x));
		else if (t==5) printf(&quot;%d\n&quot;,pred(root,x));
		else printf(&quot;%d\n&quot;,succ(root,x));
	}
	return 0;
}<pre><h2>Problem3224</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int NN=101111;
int fa[NN],son[NN][2],size[NN],num[NN],key[NN];
int n,root,TTT;
void update(int t)
{
	size[t]=size[son[t][0]]+size[son[t][1]]+num[t];
}
void rotate(int t,int p)
{
	int y=fa[t];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t,int f)
{
	while (fa[t]!=f)
	{
		int y=fa[t];
		if (fa[y]==f)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
	if (!f) root=t;
}
void ins(int &amp;t,int x,int f)
{
	if (!t)
	{
		t=++TTT;
		key[t]=x;
		size[t]=num[t]=1;
		fa[t]=f;
		splay(t,0);
		return;
	}
	if (x==key[t]) num[t]++,splay(t,0);
	else if (x&lt;key[t]) ins(son[t][0],x,t);
	else ins(son[t][1],x,t);
}
void del(int x)
{
	int t=root;
	while (t)
	{
		if (x==key[t]) break;
		if (x&lt;key[t]) t=son[t][0];
		else t=son[t][1];
	}
	if (num[t]&gt;1) {num[t]--;splay(t,0);return;}
	splay(t,0);
	if (!son[t][0]) {root=son[t][1];fa[root]=0;return;}
	if (!son[t][1]) {root=son[t][0];fa[root]=0;return;}
	int y=son[t][0];
	while (son[y][1]) y=son[y][1];
	splay(y,t);
	son[y][1]=son[t][1];
	fa[son[t][1]]=y;
	update(y);
	root=y;
	fa[root]=0;
}
int rank(int x)
{
	int res=0,t=root;
	while (t)
	{
		int tmp=size[son[t][0]];
		if (x==key[t]) return res+tmp+1;
		if (x&lt;key[t]) t=son[t][0];
		else res+=tmp+num[t],t=son[t][1];
	}
	return res;
}
int find(int K)
{
	int t=root;
	while (t)
	{
		int tmp=size[son[t][0]];
		if (tmp&lt;K&amp;&amp;K&lt;=tmp+num[t]) return key[t];
		if (K&lt;=tmp) t=son[t][0];
		else K-=(tmp+num[t]),t=son[t][1];
	}
}
int pred(int x)
{
	int res=0,t=root;
	while (t)
	{
		if (key[t]&lt;x) res=key[t],t=son[t][1];
		else t=son[t][0];
	}
	return res;
}
int succ(int x)
{
	int res=0,t=root;
	while (t)
	{
		if (key[t]&gt;x) res=key[t],t=son[t][0];
		else t=son[t][1];
	}
	return res;
}
void debug(int t) {if (!t) return;debug(son[t][0]);printf(&quot;%d &quot;,key[t]);debug(son[t][1]);}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y;
	for (i=1;i&lt;=n;i++)
	{
		//printf(&quot;\n-------------------------------------------------------------------\n&quot;);debug(root);ln;
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		if (x==1) ins(root,y,0);
		else if (x==2) del(y);
		else if (x==3) printf(&quot;%d\n&quot;,rank(y));
		else if (x==4) printf(&quot;%d\n&quot;,find(y));
		else if (x==5) printf(&quot;%d\n&quot;,pred(y));
		else printf(&quot;%d\n&quot;,succ(y));
	}
	return 0;
}<pre><h2>Problem3224</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int NN=101111;
int fa[NN],size[NN],num[NN],son[NN][2],key[NN];
int n,TTT,root;
inline void update(int t)
{
	size[t]=size[son[t][0]]+size[son[t][1]]+num[t];
}
void rotate(int t,int p)
{
	int y=fa[t];
	if (fa[y])
	{
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	}
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t,int f)
{
	while (fa[t]!=f)
	{
		int y=fa[t];
		if (fa[y]==f)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
	if (f==0) root=t;
}
void ins(int &amp;v,int x,int f)
{
	if (v==0)
	{
		v=++TTT;
		key[v]=x;
		size[v]=num[v]=1;
		fa[v]=f;
		splay(v,0);
	}
	else if (x==key[v]) num[v]++,splay(v,0);
	else if (x&lt;key[v]) ins(son[v][0],x,v);
	else ins(son[v][1],x,v);
}
void del(int x)
{
	int t=root;
	for (;;)
	{
		if (key[t]==x) break;
		if (x&lt;key[t]) t=son[t][0];
		else t=son[t][1];
	}
	splay(t,0);
	if (num[t]&gt;1) {num[t]--;return;}
	if (!son[t][0]) {root=son[t][1],fa[root]=0;return;}
	if (!son[t][1]) {root=son[t][0],fa[root]=0;return;}
	int y=son[t][0];
	while (son[y][1]) y=son[y][1];
	splay(y,t);
	son[y][1]=son[t][1];
	fa[son[t][1]]=y;
	root=y,fa[y]=0;
	update(y);
}
int rank(int x)
{
	int t=root,res=0;
	while (t)
	{
		if (x==key[t]) return res+size[son[t][0]];
		else if (x&gt;key[t]) res+=size[son[t][0]]+num[t],t=son[t][1];
		else t=son[t][0];
	}
	return res;
}
int find(int K)
{
	int t=root;
	while (t)
	{
		int tmp=size[son[t][0]];
		if (K&lt;=tmp) t=son[t][0];
		else if (K&lt;=tmp+num[t]) return key[t];
		else K-=(tmp+num[t]),t=son[t][1];
	}
	return 0;
}
int pred(int x)
{
	int t=root,res=0;
	while (t)
	{
		if (key[t]&lt;x) res=key[t],t=son[t][1];
		else t=son[t][0];
	}
	return res;
}
int succ(int x)
{
	int t=root,res=0;
	while (t)
	{
		if (key[t]&gt;x) res=key[t],t=son[t][0];
		else t=son[t][1];
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;n);n;n--)
	{
		int x,y;
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		if (x==1) ins(root,y,0);
		else if (x==2) del(y);
		else if (x==3) printf(&quot;%d\n&quot;,rank(y)+1);
		else if (x==4) printf(&quot;%d\n&quot;,find(y));
		else if (x==5) printf(&quot;%d\n&quot;,pred(y));
		else printf(&quot;%d\n&quot;,succ(y));
	}
	return 0;
}<pre><h2>Problem3224</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=100005;
int fa[NN],son[NN][2],size[NN],num[NN],key[NN];
int n,TTT,root;
inline void update(int t)
{
	size[t]=size[son[t][0]]+size[son[t][1]]+num[t];
}
inline void rotate(int t,int p)
{
	int y=fa[t];
	if (fa[y])
	{
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	}
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
	if (ff==0) root=t;
}
void ins(int &amp;v,int x,int ff)
{
	if (v==0)
	{
		v=++TTT;
		key[v]=x;
		num[v]=size[v]=1;
		fa[v]=ff;
		splay(v,0);
	}
	else if (x==key[v])
	{
		num[v]++;
		splay(v,0);
	}
	else if (x&lt;key[v]) ins(son[v][0],x,v);
	else ins(son[v][1],x,v);
}
void del(int x)
{
	int t=root;
	while (t)
	{
		if (x==key[t]) break;
		if (x&lt;key[t]) t=son[t][0];
		else t=son[t][1];
	}
	if (num[t]&gt;1) {num[t]--;splay(t,0);return;}
	splay(t,0);
	if (!son[t][0]) {root=son[t][1];fa[root]=0;return;}
	if (!son[t][1]) {root=son[t][0];fa[root]=0;return;}
	int y=son[t][0];
	while (son[y][1]) y=son[y][1];
	splay(y,t);
	son[y][1]=son[t][1];
	fa[son[t][1]]=y;
	fa[y]=0;update(y);
	root=y;
}
int rank(int x)
{
	int t=root,res=0;
	while (t)
	{
		int tmp=size[son[t][0]];
		if (x==key[t]) return res+tmp;
		if (x&lt;key[t]) t=son[t][0];
		else res+=tmp+num[t],t=son[t][1];
	}
	return res;
}
int find(int K)
{
	int t=root;
	while (t)
	{
		int tmp=size[son[t][0]];
		if (K&lt;=tmp) t=son[t][0];
		else if (K&lt;=tmp+num[t]) return key[t];
		else K-=tmp+num[t],t=son[t][1];
	}
	return -1;
}
int pred(int x)
{
	int t=root,res;
	while (t)
	{
		if (key[t]&lt;x) res=key[t],t=son[t][1];
		else t=son[t][0];
	}
	return res;
}
int succ(int x)
{
	int t=root,res;
	while (t)
	{
		if (key[t]&gt;x) res=key[t],t=son[t][0];
		else t=son[t][1];
	}
	return res;
}
void debug(int x)
{
	if (x==0) return;
	debug(son[x][0]);
	printf(&quot;%d &quot;,key[x]);
	debug(son[x][1]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y;
	for (i=1;i&lt;=n;i++)
	{
		//debug(root);ln;
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		if (x==1) ins(root,y,0);
		else if (x==2) del(y);
		else if (x==3) printf(&quot;%d\n&quot;,rank(y)+1);
		else if (x==4) printf(&quot;%d\n&quot;,find(y));
		else if (x==5) printf(&quot;%d\n&quot;,pred(y));
		else if (x==6) printf(&quot;%d\n&quot;,succ(y));
	}
	return 0;
}<pre><h2>Problem3224</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int NN=101111;
int fa[NN],son[NN][2],size[NN],num[NN],key[NN];
int n,m,TTT,root;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar()) x=x*10+ch-'0';
	if (f) x=-x;
}
inline void update(int t)
{
	size[t]=size[son[t][0]]+size[son[t][1]]+num[t];
}
inline void rotate(int t,int p)
{
	int y=fa[t];
	if (fa[y])
	{
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	}
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
	if (ff==0) root=t;
}
void ins(int &amp;t,int x,int ff)
{
	if (t==0)
	{
		t=++TTT;
		key[t]=x;
		size[t]=num[t]=1;
		fa[t]=ff;
		splay(t,0);
	}
	else if (x==key[t]) num[t]++,splay(t,0);
	else if (x&lt;key[t]) ins(son[t][0],x,t);
	else ins(son[t][1],x,t);
}
void del(int x)
{
	int t=root;
	while (t)
	{
		if (x==key[t]) break;
		if (x&lt;key[t]) t=son[t][0];
		else t=son[t][1];
	}
	if (num[t]&gt;1) {num[t]--;splay(t,0);return;}
	splay(t,0);
	if (!son[t][0]) {root=son[t][1];fa[root]=0;return;}
	if (!son[t][1]) {root=son[t][0];fa[root]=0;return;}
	int y=son[t][0];
	while (son[y][1]) y=son[y][1];
	splay(y,t);
	son[y][1]=son[t][1];
	fa[son[t][1]]=y;
	root=y;fa[y]=0;
	update(y);
}
int rank(int x)
{
	int res=0,t=root;
	while (t)
	{
		if (x==key[t]) return res+size[son[t][0]];
		if (x&lt;key[t]) t=son[t][0];
		else res+=size[son[t][0]]+num[t],t=son[t][1];
	}
	return res;
}
int find(int K)
{
	int t=root;
	while (t)
	{
		int tmp=size[son[t][0]];
		if (K&lt;=tmp) t=son[t][0];
		else if (K&lt;=tmp+num[t]) return key[t];
		else K-=tmp+num[t],t=son[t][1];
	}
	return -1;
}
int pred(int x)
{
	int t=root,res=0;
	while (t)
	{
		if (x&gt;key[t]) res=key[t],t=son[t][1];
		else t=son[t][0];
	}
	return res;
}
int succ(int x)
{
	int t=root,res=0;
	while (t)
	{
		if (x&lt;key[t]) res=key[t],t=son[t][0];
		else t=son[t][1];
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (read(m);m;m--)
	{
		int x,y;
		read(x),read(y);
		if (x==1) ins(root,y,0);
		else if (x==2) del(y);
		else if (x==3) printf(&quot;%d\n&quot;,rank(y)+1);
		else if (x==4) printf(&quot;%d\n&quot;,find(y));
		else if (x==5) printf(&quot;%d\n&quot;,pred(y));
		else printf(&quot;%d\n&quot;,succ(y));
	}
	return 0;
}<pre><h2>Problem3224</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int NN=101111;
int fa[NN],son[NN][2],size[NN],num[NN],key[NN];
int n,TTT,root;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar()) x=x*10+ch-'0';
	if (f) x=-x;
}
inline void update(int t)
{
	size[t]=size[son[t][0]]+size[son[t][1]]+num[t];
}
inline void rotate(int t,int p)
{
	int y=fa[t];
	if (fa[y])
	{
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	}
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
	if (ff==0) root=t;
}
void ins(int &amp;t,int x,int ff)
{
	if (t==0)
	{
		t=++TTT;
		key[t]=x;
		fa[t]=ff;
		size[t]=num[t]=1;
		splay(t,0);
	}
	else if (x==key[t]) num[t]++,splay(t,0);
	else if (x&lt;key[t]) ins(son[t][0],x,t);
	else ins(son[t][1],x,t);
}
void del(int x)
{
	int t=root;
	while (t)
	{
		if (key[t]==x) break;
		if (x&lt;key[t]) t=son[t][0];
		else t=son[t][1];
	}
	if (num[t]&gt;1) {num[t]--;splay(t,0);return;}
	splay(t,0);
	if (!son[t][0]) {root=son[t][1];fa[root]=0;return;}
	if (!son[t][1]) {root=son[t][0];fa[root]=0;return;}
	int y=son[t][0];
	while (son[y][1]) y=son[y][1];
	splay(y,t);
	son[y][1]=son[t][1];
	fa[son[t][1]]=y;
	root=y,fa[y]=0;
	update(y);
}
int rank(int x)
{
	int res=0,t=root;
	while (t)
	{
		if (x==key[t]) return res+size[son[t][0]];
		if (x&lt;key[t]) t=son[t][0];
		else res+=size[son[t][0]]+num[t],t=son[t][1];
	}
	return res;
}
int find(int K)
{
	int t=root;
	while (t)
	{
		int tmp=size[son[t][0]];
		if (K&lt;=tmp) t=son[t][0];
		else if (K&lt;=tmp+num[t]) return key[t];
		else K-=tmp+num[t],t=son[t][1];
	}
	return 0;
}
int pred(int x)
{
	int t=root,res;
	while (t)
	{
		if (key[t]&lt;x) res=key[t],t=son[t][1];
		else t=son[t][0];
	}
	return res;
}
int succ(int x)
{
	int t=root,res;
	while (t)
	{
		if (key[t]&gt;x) res=key[t],t=son[t][0];
		else t=son[t][1];
	}
	return res;
}
int main()
{
////	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int x,y;
	for (read(n);n;n--)
	{
		read(x),read(y);
		if (x==1) ins(root,y,0);
		else if (x==2) del(y);
		else if (x==3) printf(&quot;%d\n&quot;,rank(y)+1);
		else if (x==4) printf(&quot;%d\n&quot;,find(y));
		else if (x==5) printf(&quot;%d\n&quot;,pred(y));
		else printf(&quot;%d\n&quot;,succ(y));
	}
	return 0;
}<pre><h2>Problem3224</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int NN=100111;
int n,root,TTT;
struct splaynode
{
	int fa,s[2],key,sz,num;
} T[NN];
inline void update(int t)
{
	T[t].sz=T[T[t].s[0]].sz+T[T[t].s[1]].sz+T[t].num;
}
inline void rotate(int t,int p)
{
	int y=T[t].fa;
	if (T[y].fa)
	{
		if (y==T[T[y].fa].s[0]) T[T[y].fa].s[0]=t;
		else T[T[y].fa].s[1]=t;
	}
	T[t].fa=T[y].fa;
	T[y].s[p^1]=T[t].s[p];
	if (T[t].s[p]) T[T[t].s[p]].fa=y;
	T[t].s[p]=y;
	T[y].fa=t;
	update(y),update(t);
}
void splay(int t,int ff)
{
	while (T[t].fa!=ff)
	{
		int y=T[t].fa;
		if (T[y].fa==ff)
			if (t==T[y].s[0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==T[T[y].fa].s[0])
				if (t==T[y].s[0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==T[y].s[1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
	if (ff==0) root=t;
}
void ins(int &amp;v,int x,int ff)
{
	if (v==0)
	{
		v=++TTT;
		T[v].fa=ff;
		T[v].key=x;
		T[v].sz=T[v].num=1;
		splay(v,0);
	}
	else if (x==T[v].key)
		T[v].num++,splay(v,0);
	else if (x&lt;T[v].key) ins(T[v].s[0],x,v);
	else ins(T[v].s[1],x,v);
}
void del(int x)
{
	int t=root;
	while (t)
	{
		if (x==T[t].key) break;
		else if (x&lt;T[t].key) t=T[t].s[0];
		else t=T[t].s[1];
	}
	if (T[t].num&gt;1) {T[t].num--;splay(t,0);return;}
	splay(t,0);
	if (!T[t].s[0]) {root=T[t].s[1];T[root].fa=0;return;}
	if (!T[t].s[1]) {root=T[t].s[0];T[root].fa=0;return;}
	int y=T[t].s[0];
	while (T[y].s[1]) y=T[y].s[1];
	splay(y,t);
	T[y].s[1]=T[t].s[1];
	if (T[t].s[1]) T[T[t].s[1]].fa=y;
	root=y,T[root].fa=0;
	update(y);
}
int rank(int x)
{
	int t=root,res=0;
	while (t)
	{
		if (x&lt;T[t].key) t=T[t].s[0];
		else if (x==T[t].key) return res+T[T[t].s[0]].sz;
		else
		{
			res+=T[T[t].s[0]].sz+T[t].num;
			t=T[t].s[1];
		}
	}
	return res;
}
int find(int K)
{
	int t=root;
	while (t)
	{
		int tmp=T[T[t].s[0]].sz;
		if (K&lt;=tmp) t=T[t].s[0];
		else if (K&lt;=tmp+T[t].num) return T[t].key;
		else K-=tmp+T[t].num,t=T[t].s[1];
	}
	return 0;
}
int pred(int x)
{
	int t=root,res=0;
	while (t)
	{
		if (T[t].key&lt;x) res=T[t].key,t=T[t].s[1];
		else t=T[t].s[0];
	}
	return res;
}
int succ(int x)
{
	int t=root,res=0;
	while (t)
	{
		if (T[t].key&gt;x) res=T[t].key,t=T[t].s[0];
		else t=T[t].s[1];
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d&quot;,&amp;n);
	int i,opt,x;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;opt,&amp;x);
		if (opt==1) ins(root,x,0);
		else if (opt==2) del(x);
		else if (opt==3) printf(&quot;%d\n&quot;,rank(x)+1);
		else if (opt==4) printf(&quot;%d\n&quot;,find(x));
		else if (opt==5) printf(&quot;%d\n&quot;,pred(x));
		else printf(&quot;%d\n&quot;,succ(x));
	}
	return 0;
}<pre><h2>Problem3224</h2><pre>/**************************************************************
    Problem: 3224
    User: xindubawukong
    Language: C++
    Result: Accepted
    Time:540 ms
    Memory:3384 kb
****************************************************************/
 
#include&lt;cstdio&gt;
using namespace std;
int S[110000],son[110000][2],num[110000],fa[110000],key[110000];
int root,x,n,t,size;
void update(int t)
{
    S[t]=S[son[t][0]]+S[son[t][1]]+num[t];
}
void rotate(int t,int p)
{
    int y=fa[t];
    fa[t]=fa[y];
    if (fa[y])
        if (y==son[fa[y]][0]) son[fa[y]][0]=t;
        else son[fa[y]][1]=t;
    son[y][1-p]=son[t][p];
    if (son[t][p]) fa[son[t][p]]=y;
    fa[y]=t;
    son[t][p]=y;
    update(y);
}
void splay(int t,int ff)
{
    while (fa[t]!=ff)
    {
        int y=fa[t];
        if (fa[y]==ff)
            if (t==son[y][0]) rotate(t,1);
            else rotate(t,0);
        else
            if (y==son[fa[y]][0])
                if (t==son[y][0]) rotate(t,1),rotate(t,1);
                else rotate(t,0),rotate(t,1);
            else
                if (t==son[y][1]) rotate(t,0),rotate(t,0);
                else rotate(t,1),rotate(t,0);
    }
    if (ff==0) root=t;
    update(t);
}
void ins(int t,int x)
{
    if (t==0)
    {
        root=++size;
        key[root]=x;
        num[root]=S[root]=1;
        fa[root]=son[root][0]=son[root][1]=0;
        return;
    }
    for (;t;)
    {
        ++S[t];
        if (x==key[t])
        {
            ++num[t];
            splay(t,0);
            return;
        }
        if (son[t][x&gt;=key[t]]==0)
        {
            son[t][x&gt;key[t]]=++size;
            key[size]=x;
            fa[size]=t;
            son[size][0]=son[size][1]=0;
            num[size]=S[size]=1;
            splay(size,0);
            break;
        }
        t=son[t][x&gt;=key[t]];
    }
}
void del(int t,int x)
{
    for (;t;)
    {
        --S[t];
        if (key[t]==x) {--num[t];break;}
        t=son[t][x&gt;=key[t]];
    }
    if (num[t]) return;
    splay(t,0);
    if (son[t][0]==0) {root=son[t][1],fa[root]=0;return;}
    if (son[t][1]==0) {root=son[t][0],fa[root]=0;return;}
    int y=son[root][0];
    while (son[y][1]) y=son[y][1];
    splay(y,root);
    son[y][1]=son[root][1];
    fa[son[root][1]]=y;
    S[y]=S[root];
    fa[y]=0;
    root=y;
}
int rank(int t,int x)
{
    int res=0;
    for (;t;)
    {
        if (x&lt;key[t]) t=son[t][0];
        else if (x==key[t]) return res+S[son[t][0]]+1;
        else
        {
            res+=S[son[t][0]]+num[t];
            t=son[t][1];
        }
    }
    return res;
}
int select(int t,int x)
{
    for (;t;)
    {
        if (x&gt;S[son[t][0]]&amp;&amp;x&lt;=S[son[t][0]]+num[t]) return key[t];
        if (x&lt;=S[son[t][0]]) t=son[t][0];
        else
        {
            x-=(S[son[t][0]]+num[t]);
            t=son[t][1];
        }
    }
}
int pred(int t,int x)
{
    int res;
    for (;t;)
        if (x&gt;key[t]) res=key[t],t=son[t][1];
        else t=son[t][0];
    return res;
}
int succ(int t,int x)
{
    int res;
    for (;t;)
        if (x&lt;key[t]) res=key[t],t=son[t][0];
        else t=son[t][1];
    return res;
}
int main()
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
    scanf(&quot;%d&quot;,&amp;n);
    for (;n;n--)
    {
        scanf(&quot;%d%d&quot;,&amp;t,&amp;x);

        if (t==1) ins(root,x);
        else if (t==2) del(root,x);
        else if (t==3) printf(&quot;%d\n&quot;,rank(root,x));
        else if (t==4) printf(&quot;%d\n&quot;,select(root,x));
        else if (t==5) printf(&quot;%d\n&quot;,pred(root,x));
        else printf(&quot;%d\n&quot;,succ(root,x));
    }
    return 0;
}<pre><h2>Problem3224</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int S[110000],son[110000][2],num[110000],fa[110000],key[110000];
int root,x,n,t,size;
void update(int t)//更新节点t的大小域。
{
	S[t]=S[son[t][0]]+S[son[t][1]]+num[t];
}
void rotate(int t,int p)//旋转，p==0左旋，p==1右旋
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
	update(y);
	update(t); //旋转完后要维护S。注意先y后t。
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
}
void ins(int &amp;t,int x,int ff)
{
	if (t==0)
	{
		t=++size;
		key[t]=x;
		fa[t]=ff;
		num[t]=S[t]=1;
		son[t][0]=son[t][1]=0;
		splay(t,0);
		return;
	}
	S[t]++;
	if (x==key[t]) num[t]++, splay(t,0);//IMIIMIM！
	else if (x&lt;key[t]) ins(son[t][0],x,t);
	else ins(son[t][1],x,t);
}
void del(int t,int x)
{
	for (;t;)
	{
		--S[t];
		if (key[t]==x) {--num[t];break;}
		t=son[t][x&gt;=key[t]];
	}
	if (t==0||num[t]) return;
	//t==0表示没找到x，num[t]&gt;0表示这个数还有，不用删
	splay(t,0);
	if (son[t][0]==0) {root=son[t][1],fa[root]=0;return;}
	if (son[t][1]==0) {root=son[t][0],fa[root]=0;return;}
	int y;
	for (y=son[t][0];son[y][1];y=son[y][1]);
	//找到左子树中的max当做根。
	splay(y,root);//将max旋转到root下面
	son[y][1]=son[root][1];
	fa[son[root][1]]=y;
	fa[y]=0;
	update(y);
	root=y;
}
int rank(int t,int x)//返回x的排名。
{
	int res=0;
	for (;t;)
	{
		if (x&lt;key[t]) t=son[t][0];
		else if (x==key[t]) return res+S[son[t][0]]+1;
		else
		{
			res+=S[son[t][0]]+num[t];
			t=son[t][1];
		}
	}
	return res;
}
int select(int t,int x)//返回排名x的是几
{
	for (;t;)
	{
		if (x&gt;S[son[t][0]]&amp;&amp;x&lt;=S[son[t][0]]+num[t]) return key[t];
		if (x&lt;=S[son[t][0]]) t=son[t][0];
		else
		{
			x-=(S[son[t][0]]+num[t]);
			t=son[t][1];
		}
	}
}
int pred(int t,int x)//前驱
{
	int res;
	for (;t;)
		if (x&gt;key[t]) res=key[t],t=son[t][1];
		//这里用了类似二分查找那样的方法
		else t=son[t][0];
	return res;
}
int succ(int t,int x)//后继
{
	int res;
	for (;t;)
		if (x&lt;key[t]) res=key[t],t=son[t][0];
		else t=son[t][1];
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d&quot;,&amp;n);
	for (;n;n--)
	{
		scanf(&quot;%d%d&quot;,&amp;t,&amp;x);
		if (t==1) ins(root,x,0);
		else if (t==2) del(root,x);
		else if (t==3) printf(&quot;%d\n&quot;,rank(root,x));
		else if (t==4) printf(&quot;%d\n&quot;,select(root,x));
		else if (t==5) printf(&quot;%d\n&quot;,pred(root,x));
		else printf(&quot;%d\n&quot;,succ(root,x));
	}
	return 0;
}<pre><h2>Problem3224</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int S[110000],son[110000][2],num[110000],fa[110000],key[110000];
int root,x,n,t,size;
void update(int t)//更新节点t的大小域。
{
	S[t]=S[son[t][0]]+S[son[t][1]]+num[t];
}
void rotate(int t,int p)//旋转，p==0左旋，p==1右旋
{
	int y=fa[t];
	fa[t]=fa[y];
	if (fa[y])
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	fa[y]=t;
	son[t][p]=y;
	update(y);
	update(t); //旋转完后要维护S。注意先y后t。
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	if (ff==0) root=t;
}
void ins(int &amp;t,int x,int ff)
{
	if (t==0)
	{
		t=++size;
		key[t]=x;
		fa[t]=ff;
		num[t]=S[t]=1;
		son[t][0]=son[t][1]=0;
		splay(t,0);
		return;
	}
	//S[t]++;
	if (x==key[t]) num[t]++, splay(t,0);//IMIIMIM！
	else if (x&lt;key[t]) ins(son[t][0],x,t);
	else ins(son[t][1],x,t);
}
void del(int t,int x)
{
	for (;t;)
	{
		--S[t];
		if (key[t]==x) {--num[t];break;}
		t=son[t][x&gt;=key[t]];
	}
	if (t==0||num[t]) return;
	//t==0表示没找到x，num[t]&gt;0表示这个数还有，不用删
	splay(t,0);
	if (son[t][0]==0) {root=son[t][1],fa[root]=0;return;}
	if (son[t][1]==0) {root=son[t][0],fa[root]=0;return;}
	int y;
	for (y=son[t][0];son[y][1];y=son[y][1]);
	//找到左子树中的max当做根。
	splay(y,root);//将max旋转到root下面
	son[y][1]=son[root][1];
	fa[son[root][1]]=y;
	fa[y]=0;
	update(y);
	root=y;
}
int rank(int t,int x)//返回x的排名。
{
	int res=0;
	for (;t;)
	{
		if (x&lt;key[t]) t=son[t][0];
		else if (x==key[t]) return res+S[son[t][0]]+1;
		else
		{
			res+=S[son[t][0]]+num[t];
			t=son[t][1];
		}
	}
	return res;
}
int select(int t,int x)//返回排名x的是几
{
	for (;t;)
	{
		if (x&gt;S[son[t][0]]&amp;&amp;x&lt;=S[son[t][0]]+num[t]) return key[t];
		if (x&lt;=S[son[t][0]]) t=son[t][0];
		else
		{
			x-=(S[son[t][0]]+num[t]);
			t=son[t][1];
		}
	}
}
int pred(int t,int x)//前驱
{
	int res;
	for (;t;)
		if (x&gt;key[t]) res=key[t],t=son[t][1];
		//这里用了类似二分查找那样的方法
		else t=son[t][0];
	return res;
}
int succ(int t,int x)//后继
{
	int res;
	for (;t;)
		if (x&lt;key[t]) res=key[t],t=son[t][0];
		else t=son[t][1];
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d&quot;,&amp;n);
	for (;n;n--)
	{
		scanf(&quot;%d%d&quot;,&amp;t,&amp;x);
		if (t==1) ins(root,x,0);
		else if (t==2) del(root,x);
		else if (t==3) printf(&quot;%d\n&quot;,rank(root,x));
		else if (t==4) printf(&quot;%d\n&quot;,select(root,x));
		else if (t==5) printf(&quot;%d\n&quot;,pred(root,x));
		else printf(&quot;%d\n&quot;,succ(root,x));
	}
	return 0;
}<pre><h2>Problem3224</h2><pre>#include&lt;cstdio&gt;
#define MAXN 300005
struct node {
    int v, cnt, sz, ch[2], f;
}t[MAXN];
int rt, sz, n;
#define Upd(r) {t[r].sz = t[t[r].ch[0]].sz + t[t[r].ch[1]].sz + t[r].cnt;}
void rot(int x)
{
    int y = t[x].f, z = t[y].f;
    bool f = (t[y].ch[1] == x);
    t[y].ch[f] = t[x].ch[f^1];
    if(t[y].ch[f]) t[t[y].ch[f]].f = y;
    t[x].ch[f^1] = y; t[y].f = x;
    t[x].f = z;
    if(z) t[z].ch[t[z].ch[1]==y] = x;
    Upd(y);
}
void Spaly(int r, int tp) {
    for(int y, z; (y = t[r].f) != tp; rot(r)) {
        z = t[y].f;
        if(z == tp) continue;
        if( (t[z].ch[0] == y) == (t[y].ch[0] == r) ) rot(y);
        else rot(r);
    }
    if(!tp) rt = r; Upd(r);
}
void Ins(int r, int x) {
    int y = 0;
    while(r &amp;&amp; t[r].v != x) { y = r; r = t[r].ch[x &gt; t[r].v]; }
    if(r) ++ t[r].cnt;
    else {
        r = ++ sz; t[r].sz = t[r].cnt = 1;
        t[r].v = x; t[r].f = y; if(y) t[y].ch[x &gt; t[y].v] = r;
    }
    Spaly(r, 0);
}
void Find(int v) {
    int x = rt; if(!x) return;
    while(t[x].ch[v &gt; t[x].v] &amp;&amp; t[x].v != v) x = t[x].ch[v &gt; t[x].v];
    Spaly(x, 0);
}
int Ran(int v) {
    Find(v);
    return t[t[rt].ch[0]].sz;
}
int Kth(int x)
{
    int y=rt,p;
    if(x&gt;t[rt].sz)return 0;
    while(1)
    {
        p=t[y].ch[0];
        if(t[p].sz+t[y].cnt&lt;x) {
            x-=t[p].sz+t[y].cnt;
            y=t[y].ch[1];
        }
        else if(t[p].sz&gt;=x) y=p;
        else return t[y].v;
    }
}
int Nxt(int x, bool f)
{
    Find(x);
    if((t[rt].v&gt;x&amp;&amp;f)||(t[rt].v&lt;x&amp;&amp;!f)) return rt;
    int p = t[rt].ch[f];
    while(t[p].ch[f^1]) p = t[p].ch[!f];
    return p;
}
void Del(int v) {
    int p = Nxt(v, 0), s = Nxt(v, 1);
    Spaly(p, 0); Spaly(s, p);
    p = t[s].ch[0];
    if(t[p].cnt &gt; 1) -- t[p].cnt, Spaly(p, 0);
    else t[s].ch[0] = 0;
}
char c, f;
inline void GET(int &amp;n) {
    n = 0; f = 1;
    do {c = getchar(); if(c == '-') f = -1;} while(c &gt; '9' || c &lt; '0');
    while(c &gt;= '0' &amp;&amp; c &lt;= '9') {n=n*10+c-'0';c=getchar();}
    n *= f;
}
int main() {
    GET(n);
    int opt,x;
    Ins(rt, -0x7fffffff); Ins(rt, +0x7fffffff);
    for(int i=1; i&lt;=n; i++) {
        GET(opt); GET(x);
        switch(opt) {
            case 1: Ins(rt,x); break;
            case 2: Del(x); break;
            case 3: printf(&quot;%d\n&quot;,Ran(x)); break;
            case 4: printf(&quot;%d\n&quot;,Kth(x+1)); break;
            case 5: printf(&quot;%d\n&quot;,t[Nxt(x, 0)].v); break;
            case 6: printf(&quot;%d\n&quot;,t[Nxt(x, 1)].v); break;
        }
    }
    return 0;
}<pre><h2>Problem3226</h2><pre>#include&lt;bits/stdc++.h&gt;
#define lson i&lt;&lt;1,l,mid
#define rson i&lt;&lt;1|1,mid+1,r
#define L i&lt;&lt;1
#define R i&lt;&lt;1|1
using namespace std;
const int maxn=65535*2+10;
int n=65535*2+1;
short a[maxn];
struct seg{
	struct node{
		short col,lazy,rev;
		node():col(0),lazy(-1),rev(0){};
	}t[maxn&lt;&lt;2];
	void pushdown(int i){
		if(t[i].rev){
			t[L].rev^=1;t[L].col^=1;
			if(~t[L].lazy)t[L].lazy^=1;
			
			t[R].rev^=1;t[R].col^=1;
			if(~t[R].lazy)t[R].lazy^=1;
			
			t[i].rev=0;
		}	
		if(t[i].lazy!=-1){
			t[L].lazy=t[R].lazy=t[i].lazy;
			t[L].col=t[R].col=t[i].lazy;
			t[i].lazy=-1;
		}
	}
	void Cov(int i,int l,int r,int l0,int r0,int col){
		if(l0&gt;r0)return;
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			t[i].col=col;
			t[i].lazy=col;
			return;
		}int mid=(l+r)&gt;&gt;1;
		pushdown(i);
		if(l0&lt;=mid)Cov(lson,l0,r0,col);
		if(r0&gt;mid)Cov(rson,l0,r0,col);
	}
	void Rev(int i,int l,int r,int l0,int r0){
		if(l0&gt;r0)return;
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			t[i].col^=1;
			if(~t[i].lazy)t[i].lazy^=1;
			t[i].rev^=1;
			return;
		}int mid=(l+r)&gt;&gt;1;
		pushdown(i);
		if(l0&lt;=mid)Rev(lson,l0,r0);
		if(r0&gt;mid)Rev(rson,l0,r0);
	}
	void print(int i,int l,int r){
		if(l==r){a[l]=t[i].col;return;}
		int mid=(l+r)&gt;&gt;1;
		pushdown(i);
		print(lson);print(rson);
	}
}T;
#undef L
#undef R
struct segment{
	int l,r;
	char L,R;
}anss[maxn];
int size;
int main(){
	char op[2];
	int l,r;char L,R;
	while(~scanf(&quot;%s %c%d,%d%c&quot;,op,&amp;L,&amp;l,&amp;r,&amp;R)){
		l&lt;&lt;=1;r&lt;&lt;=1;
		l++;r++;
		l+=L=='(';r-=R==')';
		if(op[0]=='U')T.Cov(1,1,n,l,r,1);
		else if(op[0]=='I')T.Cov(1,1,n,1,l-1,0),T.Cov(1,1,n,r+1,n,0);
		else if(op[0]=='D')T.Cov(1,1,n,l,r,0);
		else if(op[0]=='C')T.Cov(1,1,n,1,l-1,0),T.Cov(1,1,n,r+1,n,0),T.Rev(1,1,n,l,r);
		else if(op[0]=='S')T.Rev(1,1,n,l,r);		
	}T.print(1,1,n);
	for(int i=1;i&lt;=n;i++){
		int j=i-1;
		if(!a[i-1]&amp;&amp;a[i]){
			size++;
			anss[size].l=j/2;
			anss[size].L=j%2==0?'[':'(';
		}
		if(a[i]&amp;&amp;!a[i+1]){
			anss[size].r=j/2+j%2;
			anss[size].R=j%2==0?']':')';		
		}
	}
	if(!size)printf(&quot;empty set&quot;);
	for(int i=1;i&lt;=size;i++){
		printf(&quot;%c%d,%d%c&quot;,anss[i].L,anss[i].l,anss[i].r,anss[i].R);if(i-size)putchar(' ');
	}
	return 0;
}<pre><h2>Problem3226</h2><pre>#include&lt;cstdio&gt;
#define lc(v) (v&lt;&lt;1)
#define rc(v) (lc(v)+1)
#define maxx 131200
using namespace std;
bool flag,t1[550000],t2[550000],t3[550000],a[200000];
char ch,ch1,ch2;
int i,k,t,ll,rr,l[550000],r[550000];
void update(int v)
{
	//printf(&quot;%s%d %d %d\n&quot;,&quot;update    &quot;,v,t2[lc(v)],t2[lc(v)]);
	t1[v]=t1[lc(v)]&amp;&amp;t1[rc(v)];
	t2[v]=t2[lc(v)]&amp;&amp;t2[rc(v)];
}
void pushdown(int v)
{
	if (t1[v]!=0)
	{
		t1[lc(v)]=1;t2[lc(v)]=0;t3[lc(v)]=0;
		t1[rc(v)]=1;t2[rc(v)]=0;t3[rc(v)]=0;
		t1[v]=0;
	}
	if (t2[v]!=0)
	{
		t1[lc(v)]=0;t2[lc(v)]=1;t3[lc(v)]=0;
		t1[rc(v)]=0;t2[rc(v)]=1;t3[rc(v)]=0;
		t2[v]=0;
	}
	if (t3[v]!=0)
	{
		if (t1[lc(v)]==1) t1[lc(v)]=0,t2[lc(v)]=1;
		else if (t2[lc(v)]==1) t1[lc(v)]=1,t2[lc(v)]=0;
		else if (t3[lc(v)]==1) t3[lc(v)]=0;
		else t3[lc(v)]=1;
		if (t1[rc(v)]==1) t1[rc(v)]=0,t2[rc(v)]=1;
		else if (t2[rc(v)]==1) t1[rc(v)]=1,t2[rc(v)]=0;
		else if (t3[rc(v)]==1) t3[rc(v)]=0;
		else t3[rc(v)]=1;
		t3[v]=0;
	}
}
void build(int v,int ll,int rr)
{
	l[v]=ll,r[v]=rr;
	if (rr-ll==1)
	{
		t1[v]=0;//是否被全部赋为1
		t2[v]=1;//是否被全部赋为0
		t3[v]=0;//是否被取反 
		return;
	}
	int mid=(ll+rr)&gt;&gt;1;
	build(lc(v),ll,mid);
	build(rc(v),mid,rr);
	update(v);
}
void change1(int v,int a,int b)
{
	if (a&gt;b) return;
	//printf(&quot;%s%d %d %d %d %d %d\n&quot;,&quot;change1 1   &quot;,v,l[v],r[v],t1[v],t2[v],t3[v]);
	if (r[v]-l[v]==1||(a&lt;=l[v]&amp;&amp;r[v]&lt;=b))
	{
		t1[v]=1;
		t2[v]=0;
		t3[v]=0;
		//printf(&quot;%s%d %d %d %d %d %d\n&quot;,&quot;change1 2   &quot;,v,l[v],r[v],t1[v],t2[v],t3[v]);
		return;
	}
	pushdown(v);
	int mid=(l[v]+r[v])&gt;&gt;1;
	if (a&lt;mid) change1(lc(v),a,b);
	if (b&gt;=mid) change1(rc(v),a,b);
	update(v);
	//printf(&quot;%s%d %d %d %d %d %d\n&quot;,&quot;change1 2   &quot;,v,l[v],r[v],t1[v],t2[v],t3[v]);
}
void change2(int v,int a,int b)
{
	if (a&gt;b) return;
	//printf(&quot;%s%d %d %d %d %d %d\n&quot;,&quot;change2 1   &quot;,v,l[v],r[v],t1[v],t2[v],t3[v]);
	if (r[v]-l[v]==1||(a&lt;=l[v]&amp;&amp;r[v]&lt;=b))
	{
		t1[v]=0;
		t2[v]=1;
		t3[v]=0;
		//printf(&quot;%s%d %d %d %d %d %d\n&quot;,&quot;change2 2   &quot;,v,l[v],r[v],t1[v],t2[v],t3[v]);
		return;
	}
	pushdown(v);
	int mid=(l[v]+r[v])&gt;&gt;1;
	if (a&lt;mid) change2(lc(v),a,b);
	if (b&gt;=mid) change2(rc(v),a,b);
	update(v);
	//printf(&quot;%s%d %d %d %d %d %d\n&quot;,&quot;change2 2   &quot;,v,l[v],r[v],t1[v],t2[v],t3[v]);
}
void change3(int v,int a,int b)
{
	if (a&gt;b) return;
	//printf(&quot;%s%d %d %d %d %d %d\n&quot;,&quot;change3 1   &quot;,v,l[v],r[v],t1[v],t2[v],t3[v]);
	if (r[v]-l[v]==1||(a&lt;=l[v]&amp;&amp;r[v]&lt;=b))
	{
		if (t1[v]==1) t1[v]=0,t2[v]=1;
		else if (t2[v]==1) t1[v]=1,t2[v]=0;
		else if (t3[v]==1) t3[v]=0;
		else t3[v]=1;
		//printf(&quot;%s%d %d %d %d %d %d\n&quot;,&quot;change3 2   &quot;,v,l[v],r[v],t1[v],t2[v],t3[v]);
		return;
	}
	pushdown(v);
	int mid=(l[v]+r[v])&gt;&gt;1;
	if (a&lt;mid) change3(lc(v),a,b);
	if (b&gt;=mid) change3(rc(v),a,b);
	update(v);
	//printf(&quot;%s%d %d %d %d %d %d\n&quot;,&quot;change3 2   &quot;,v,l[v],r[v],t1[v],t2[v],t3[v]);
}
void outit(int v)
{
	//printf(&quot;%s%d %d %d %d %d %d\n&quot;,&quot;outit    &quot;,v,l[v],r[v],t1[v],t2[v],t3[v]);
	if (r[v]-l[v]==1)
	{
		//printf(&quot;%d %d\n&quot;,l[v],v);
		if (t1[v]==1) a[l[v]]=1;
		return;
	}
	pushdown(v);
	outit(lc(v));
	outit(rc(v));
}
int main()
{
	//freopen(&quot;baoj32261.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;baoj3226.out&quot;,&quot;w&quot;,stdout);
	//freopen(&quot;interval.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;interval.out&quot;,&quot;w&quot;,stdout);
	build(1,1,maxx+1);
	//printf(&quot;\n%s\n\n&quot;,&quot;--------------build end--------------&quot;);
	while (~scanf(&quot;%c &quot;,&amp;ch))
	{
		scanf(&quot;%c%d%c%d%c&quot;,&amp;ch1,&amp;ll,&amp;ch2,&amp;rr,&amp;ch2);
		scanf(&quot;\n&quot;);
		//printf(&quot;%c %d %d %c\n&quot;,ch1,ll,rr,ch2);
		if (ch1=='[') ll=ll*2+1;
		else ll=ll*2+2;
		if (ch2==']') rr=rr*2+1;
		else rr=rr*2;
		//printf(&quot;\n%d %d\n\n&quot;,ll,rr);
		if (ch=='U') change1(1,ll,rr);
		else if (ch=='I')
		{
			change2(1,1,ll-1);
			change2(1,rr+1,maxx);
		}
		else if (ch=='D') change2(1,ll,rr);
		else if (ch=='C')
		{
			change2(1,1,ll-1);
			change2(1,rr+1,maxx);
			change3(1,ll,rr);
		}
		else change3(1,ll,rr);
	}
	outit(1);
	k=0;
	while (k&lt;=maxx)
	{
		while (a[k]==0&amp;&amp;k&lt;=maxx) ++k;
		if (k&gt;maxx) break;
		//if (flag) printf(&quot; &quot;);
		flag=1;
		t=k;
		while (a[t]==1&amp;&amp;t&lt;=maxx) ++t;
		--t;
		//printf(&quot;%d %d\n&quot;,k,t);
		if (k%2==1) printf(&quot;%c%d&quot;,'[',(k-1)/2);
		else printf(&quot;%c%d&quot;,'(',(k-2)/2);
		printf(&quot;%c&quot;,',');
		if (t%2==1) printf(&quot;%d%c&quot;,(t-1)/2,']');
		else printf(&quot;%d%c&quot;,t/2,')');printf(&quot; &quot;);
		//printf(&quot; &quot;);
		k=t+1;
	}
	if (!flag) printf(&quot;%s&quot;,&quot;empty set\n&quot;);
	printf(&quot;\n&quot;);
	return 0;
}<pre><h2>Problem3226</h2><pre>#include&lt;cstdio&gt;
#define lc(v) (v&lt;&lt;1)
#define rc(v) (lc(v)+1)
#define maxx 131200
using namespace std;
bool flag,t1[550000],t2[550000],t3[550000],a[200000];
char ch,ch1,ch2;
int i,k,t,ll,rr,l[550000],r[550000];
void update(int v)
{
	t1[v]=t1[lc(v)]&amp;&amp;t1[rc(v)];
	t2[v]=t2[lc(v)]&amp;&amp;t2[rc(v)];
}
void pushdown(int v)
{
	if (t1[v]!=0)
	{
		t1[lc(v)]=1;t2[lc(v)]=0;t3[lc(v)]=0;
		t1[rc(v)]=1;t2[rc(v)]=0;t3[rc(v)]=0;
		t1[v]=0;
	}
	if (t2[v]!=0)
	{
		t1[lc(v)]=0;t2[lc(v)]=1;t3[lc(v)]=0;
		t1[rc(v)]=0;t2[rc(v)]=1;t3[rc(v)]=0;
		t2[v]=0;
	}
	if (t3[v]!=0)
	{
		if (t1[lc(v)]==1) t1[lc(v)]=0,t2[lc(v)]=1;
		else if (t2[lc(v)]==1) t1[lc(v)]=1,t2[lc(v)]=0;
		else if (t3[lc(v)]==1) t3[lc(v)]=0;
		else t3[lc(v)]=1;
		if (t1[rc(v)]==1) t1[rc(v)]=0,t2[rc(v)]=1;
		else if (t2[rc(v)]==1) t1[rc(v)]=1,t2[rc(v)]=0;
		else if (t3[rc(v)]==1) t3[rc(v)]=0;
		else t3[rc(v)]=1;
		t3[v]=0;
	}
}
void build(int v,int ll,int rr)
{
	l[v]=ll,r[v]=rr;
	if (rr-ll==1)
	{
		t1[v]=0;//是否被全部赋为1
		t2[v]=1;//是否被全部赋为0
		t3[v]=0;//是否被取反 
		return;
	}
	int mid=(ll+rr)&gt;&gt;1;
	build(lc(v),ll,mid);
	build(rc(v),mid,rr);
	update(v);
}
void change1(int v,int a,int b)
{
	if (a&gt;b) return;
	if (r[v]-l[v]==1||(a&lt;=l[v]&amp;&amp;r[v]&lt;=b))
	{
		t1[v]=1;
		t2[v]=0;
		t3[v]=0;
		return;
	}
	pushdown(v);
	int mid=(l[v]+r[v])&gt;&gt;1;
	if (a&lt;mid) change1(lc(v),a,b);
	if (b&gt;=mid) change1(rc(v),a,b);
	update(v);
}
void change2(int v,int a,int b)
{
	if (a&gt;b) return;
	if (r[v]-l[v]==1||(a&lt;=l[v]&amp;&amp;r[v]&lt;=b))
	{
		t1[v]=0;
		t2[v]=1;
		t3[v]=0;
		return;
	}
	pushdown(v);
	int mid=(l[v]+r[v])&gt;&gt;1;
	if (a&lt;mid) change2(lc(v),a,b);
	if (b&gt;=mid) change2(rc(v),a,b);
	update(v);
}
void change3(int v,int a,int b)
{
	if (a&gt;b) return;
	if (r[v]-l[v]==1||(a&lt;=l[v]&amp;&amp;r[v]&lt;=b))
	{
		if (t1[v]==1) t1[v]=0,t2[v]=1;
		else if (t2[v]==1) t1[v]=1,t2[v]=0;
		else if (t3[v]==1) t3[v]=0;
		else t3[v]=1;
		return;
	}
	pushdown(v);
	int mid=(l[v]+r[v])&gt;&gt;1;
	if (a&lt;mid) change3(lc(v),a,b);
	if (b&gt;=mid) change3(rc(v),a,b);
	update(v);
}
void outit(int v)
{
	if (r[v]-l[v]==1)
	{
		if (t1[v]==1) a[l[v]]=1;
		return;
	}
	pushdown(v);
	outit(lc(v));
	outit(rc(v));
}
int main()
{
	build(1,1,maxx+1);
	while (~scanf(&quot;%c &quot;,&amp;ch))
	{
		scanf(&quot;%c%d%c%d%c&quot;,&amp;ch1,&amp;ll,&amp;ch2,&amp;rr,&amp;ch2);
		scanf(&quot;\n&quot;);
		if (ch1=='[') ll=ll*2+1;
		else ll=ll*2+2;
		if (ch2==']') rr=rr*2+1;
		else rr=rr*2;
		if (ch=='U') change1(1,ll,rr);
		else if (ch=='I')
		{
			change2(1,1,ll-1);
			change2(1,rr+1,maxx);
		}
		else if (ch=='D') change2(1,ll,rr);
		else if (ch=='C')
		{
			change2(1,1,ll-1);
			change2(1,rr+1,maxx);
			change3(1,ll,rr);
		}
		else change3(1,ll,rr);
	}
	outit(1);
	k=0;
	while (k&lt;=maxx)
	{
		while (a[k]==0&amp;&amp;k&lt;=maxx) ++k;
		if (k&gt;maxx) break;
		flag=1;
		t=k;
		while (a[t]==1&amp;&amp;t&lt;=maxx) ++t;
		--t;
		if (k%2==1) printf(&quot;%c%d&quot;,'[',(k-1)/2);
		else printf(&quot;%c%d&quot;,'(',(k-2)/2);
		printf(&quot;%c&quot;,',');
		if (t%2==1) printf(&quot;%d%c&quot;,(t-1)/2,']');
		else printf(&quot;%d%c&quot;,t/2,')');printf(&quot; &quot;);
		k=t+1;
	}
	if (!flag) printf(&quot;%s&quot;,&quot;empty set\n&quot;);
	printf(&quot;\n&quot;);
	return 0;
}<pre><h2>Problem3226</h2><pre>#include&lt;cstdio&gt;
#define lc(v) (v&lt;&lt;1)
#define rc(v) (lc(v)+1)
#define maxx 131200
using namespace std;
bool flag,t1[550000],t2[550000],t3[550000],a[200000];
char ch,ch1,ch2;
int i,k,t,ll,rr,l[550000],r[550000];
void update(int v)
{
	//t1[v]=t1[lc(v)]&amp;&amp;t1[rc(v)];
	//t2[v]=t2[lc(v)]&amp;&amp;t2[rc(v)];
}
void pushdown(int v)
{
	if (t1[v]!=0)
	{
		t1[lc(v)]=1;t2[lc(v)]=0;t3[lc(v)]=0;
		t1[rc(v)]=1;t2[rc(v)]=0;t3[rc(v)]=0;
		t1[v]=0;
	}
	if (t2[v]!=0)
	{
		t1[lc(v)]=0;t2[lc(v)]=1;t3[lc(v)]=0;
		t1[rc(v)]=0;t2[rc(v)]=1;t3[rc(v)]=0;
		t2[v]=0;
	}
	if (t3[v]!=0)
	{
		if (t1[lc(v)]==1) t1[lc(v)]=0,t2[lc(v)]=1;
		else if (t2[lc(v)]==1) t1[lc(v)]=1,t2[lc(v)]=0;
		else if (t3[lc(v)]==1) t3[lc(v)]=0;
		else t3[lc(v)]=1;
		if (t1[rc(v)]==1) t1[rc(v)]=0,t2[rc(v)]=1;
		else if (t2[rc(v)]==1) t1[rc(v)]=1,t2[rc(v)]=0;
		else if (t3[rc(v)]==1) t3[rc(v)]=0;
		else t3[rc(v)]=1;
		t3[v]=0;
	}
}
void build(int v,int ll,int rr)
{
	l[v]=ll,r[v]=rr;
	if (rr-ll==1)
	{
		t1[v]=0;//是否被全部赋为1
		t2[v]=1;//是否被全部赋为0
		t3[v]=0;//是否被取反 
		return;
	}
	int mid=(ll+rr)&gt;&gt;1;
	build(lc(v),ll,mid);
	build(rc(v),mid,rr);
	update(v);
}
void change1(int v,int a,int b)
{
	if (a&gt;b) return;
	if (r[v]-l[v]==1||(a&lt;=l[v]&amp;&amp;r[v]&lt;=b))
	{
		t1[v]=1;
		t2[v]=0;
		t3[v]=0;
		return;
	}
	pushdown(v);
	int mid=(l[v]+r[v])&gt;&gt;1;
	if (a&lt;mid) change1(lc(v),a,b);
	if (b&gt;=mid) change1(rc(v),a,b);
	update(v);
}
void change2(int v,int a,int b)
{
	if (a&gt;b) return;
	if (r[v]-l[v]==1||(a&lt;=l[v]&amp;&amp;r[v]&lt;=b))
	{
		t1[v]=0;
		t2[v]=1;
		t3[v]=0;
		return;
	}
	pushdown(v);
	int mid=(l[v]+r[v])&gt;&gt;1;
	if (a&lt;mid) change2(lc(v),a,b);
	if (b&gt;=mid) change2(rc(v),a,b);
	update(v);
}
void change3(int v,int a,int b)
{
	if (a&gt;b) return;
	if (r[v]-l[v]==1||(a&lt;=l[v]&amp;&amp;r[v]&lt;=b))
	{
		if (t1[v]==1) t1[v]=0,t2[v]=1;
		else if (t2[v]==1) t1[v]=1,t2[v]=0;
		else if (t3[v]==1) t3[v]=0;
		else t3[v]=1;
		return;
	}
	pushdown(v);
	int mid=(l[v]+r[v])&gt;&gt;1;
	if (a&lt;mid) change3(lc(v),a,b);
	if (b&gt;=mid) change3(rc(v),a,b);
	update(v);
}
void outit(int v)
{
	if (r[v]-l[v]==1)
	{
		if (t1[v]==1) a[l[v]]=1;
		return;
	}
	pushdown(v);
	outit(lc(v));
	outit(rc(v));
}
int main()
{
	build(1,1,maxx+1);
	while (~scanf(&quot;%c &quot;,&amp;ch))
	{
		scanf(&quot;%c%d%c%d%c&quot;,&amp;ch1,&amp;ll,&amp;ch2,&amp;rr,&amp;ch2);
		scanf(&quot;\n&quot;);
		if (ch1=='[') ll=ll*2+1;
		else ll=ll*2+2;
		if (ch2==']') rr=rr*2+1;
		else rr=rr*2;
		if (ch=='U') change1(1,ll,rr);
		else if (ch=='I')
		{
			change2(1,1,ll-1);
			change2(1,rr+1,maxx);
		}
		else if (ch=='D') change2(1,ll,rr);
		else if (ch=='C')
		{
			change2(1,1,ll-1);
			change2(1,rr+1,maxx);
			change3(1,ll,rr);
		}
		else change3(1,ll,rr);
	}
	outit(1);
	k=0;
	while (k&lt;=maxx)
	{
		while (a[k]==0&amp;&amp;k&lt;=maxx) ++k;
		if (k&gt;maxx) break;
		flag=1;
		t=k;
		while (a[t]==1&amp;&amp;t&lt;=maxx) ++t;
		--t;
		if (k%2==1) printf(&quot;%c%d&quot;,'[',(k-1)/2);
		else printf(&quot;%c%d&quot;,'(',(k-2)/2);
		printf(&quot;%c&quot;,',');
		if (t%2==1) printf(&quot;%d%c&quot;,(t-1)/2,']');
		else printf(&quot;%d%c&quot;,t/2,')');printf(&quot; &quot;);
		k=t+1;
	}
	if (!flag) printf(&quot;%s&quot;,&quot;empty set\n&quot;);
	printf(&quot;\n&quot;);
	return 0;
}<pre><h2>Problem3226</h2><pre>#include&lt;cstdio&gt;
#define lc(v) (v&lt;&lt;1)
#define rc(v) (lc(v)+1)
#define maxx 131200
using namespace std;
bool flag,t1[550000],t2[550000],t3[550000],a[200000];
char ch,ch1,ch2;
int i,k,t,ll,rr,l[550000],r[550000];
void pushdown(int v)
{
	if (t1[v]!=0)
	{
		t1[lc(v)]=1;t2[lc(v)]=0;t3[lc(v)]=0;
		t1[rc(v)]=1;t2[rc(v)]=0;t3[rc(v)]=0;
		t1[v]=0;
	}
	if (t2[v]!=0)
	{
		t1[lc(v)]=0;t2[lc(v)]=1;t3[lc(v)]=0;
		t1[rc(v)]=0;t2[rc(v)]=1;t3[rc(v)]=0;
		t2[v]=0;
	}
	if (t3[v]!=0)
	{
		if (t1[lc(v)]==1) t1[lc(v)]=0,t2[lc(v)]=1;
		else if (t2[lc(v)]==1) t1[lc(v)]=1,t2[lc(v)]=0;
		else if (t3[lc(v)]==1) t3[lc(v)]=0;
		else t3[lc(v)]=1;
		if (t1[rc(v)]==1) t1[rc(v)]=0,t2[rc(v)]=1;
		else if (t2[rc(v)]==1) t1[rc(v)]=1,t2[rc(v)]=0;
		else if (t3[rc(v)]==1) t3[rc(v)]=0;
		else t3[rc(v)]=1;
		t3[v]=0;
	}
}
void build(int v,int ll,int rr)
{
	l[v]=ll,r[v]=rr;
	if (rr-ll==1)
	{
		t1[v]=0;//是否被全部赋为1
		t2[v]=1;//是否被全部赋为0
		t3[v]=0;//是否被取反 
		return;
	}
	int mid=(ll+rr)&gt;&gt;1;
	build(lc(v),ll,mid);
	build(rc(v),mid,rr);
}
void change1(int v,int a,int b)
{
	if (a&gt;b) return;
	if (r[v]-l[v]==1||(a&lt;=l[v]&amp;&amp;r[v]&lt;=b))
	{
		t1[v]=1;
		t2[v]=0;
		t3[v]=0;
		return;
	}
	pushdown(v);
	int mid=(l[v]+r[v])&gt;&gt;1;
	if (a&lt;mid) change1(lc(v),a,b);
	if (b&gt;=mid) change1(rc(v),a,b);
}
void change2(int v,int a,int b)
{
	if (a&gt;b) return;
	if (r[v]-l[v]==1||(a&lt;=l[v]&amp;&amp;r[v]&lt;=b))
	{
		t1[v]=0;
		t2[v]=1;
		t3[v]=0;
		return;
	}
	pushdown(v);
	int mid=(l[v]+r[v])&gt;&gt;1;
	if (a&lt;mid) change2(lc(v),a,b);
	if (b&gt;=mid) change2(rc(v),a,b);
}
void change3(int v,int a,int b)
{
	if (a&gt;b) return;
	if (r[v]-l[v]==1||(a&lt;=l[v]&amp;&amp;r[v]&lt;=b))
	{
		if (t1[v]==1) t1[v]=0,t2[v]=1;
		else if (t2[v]==1) t1[v]=1,t2[v]=0;
		else if (t3[v]==1) t3[v]=0;
		else t3[v]=1;
		return;
	}
	pushdown(v);
	int mid=(l[v]+r[v])&gt;&gt;1;
	if (a&lt;mid) change3(lc(v),a,b);
	if (b&gt;=mid) change3(rc(v),a,b);
}
void outit(int v)
{
	if (r[v]-l[v]==1)
	{
		if (t1[v]==1) a[l[v]]=1;
		return;
	}
	pushdown(v);
	outit(lc(v));
	outit(rc(v));
}
int main()
{
	build(1,1,maxx+1);
	while (~scanf(&quot;%c &quot;,&amp;ch))
	{
		scanf(&quot;%c%d%c%d%c&quot;,&amp;ch1,&amp;ll,&amp;ch2,&amp;rr,&amp;ch2);
		scanf(&quot;\n&quot;);
		if (ch1=='[') ll=ll*2+1;
		else ll=ll*2+2;
		if (ch2==']') rr=rr*2+1;
		else rr=rr*2;
		if (ch=='U') change1(1,ll,rr);
		else if (ch=='I')
		{
			change2(1,1,ll-1);
			change2(1,rr+1,maxx);
		}
		else if (ch=='D') change2(1,ll,rr);
		else if (ch=='C')
		{
			change2(1,1,ll-1);
			change2(1,rr+1,maxx);
			change3(1,ll,rr);
		}
		else change3(1,ll,rr);
	}
	outit(1);
	k=0;
	while (k&lt;=maxx)
	{
		while (a[k]==0&amp;&amp;k&lt;=maxx) ++k;
		if (k&gt;maxx) break;
		flag=1;
		t=k;
		while (a[t]==1&amp;&amp;t&lt;=maxx) ++t;
		--t;
		if (k%2==1) printf(&quot;%c%d&quot;,'[',(k-1)/2);
		else printf(&quot;%c%d&quot;,'(',(k-2)/2);
		printf(&quot;%c&quot;,',');
		if (t%2==1) printf(&quot;%d%c&quot;,(t-1)/2,']');
		else printf(&quot;%d%c&quot;,t/2,')');printf(&quot; &quot;);
		k=t+1;
	}
	if (!flag) printf(&quot;%s&quot;,&quot;empty set\n&quot;);
	printf(&quot;\n&quot;);
	return 0;
}<pre><h2>Problem3226</h2><pre>#include&lt;cstdio&gt;
#define lc(v) (v&lt;&lt;1)
#define rc(v) (lc(v)+1)
#define maxx 131200
using namespace std;
bool flag,t1[550000],t2[550000],t3[550000],a[200000];
char ch,ch1,ch2;
int i,k,t,ll,rr,l[550000],r[550000];
void pushdown(int v)
{
	if (t1[v]!=0)
	{
		t1[lc(v)]=1;t2[lc(v)]=0;t3[lc(v)]=0;
		t1[rc(v)]=1;t2[rc(v)]=0;t3[rc(v)]=0;
		t1[v]=0;
	}
	if (t2[v]!=0)
	{
		t1[lc(v)]=0;t2[lc(v)]=1;t3[lc(v)]=0;
		t1[rc(v)]=0;t2[rc(v)]=1;t3[rc(v)]=0;
		t2[v]=0;
	}
	if (t3[v]!=0)
	{
		if (t1[lc(v)]==1) t1[lc(v)]=0,t2[lc(v)]=1;
		else if (t2[lc(v)]==1) t1[lc(v)]=1,t2[lc(v)]=0;
		else if (t3[lc(v)]==1) t3[lc(v)]=0;
		else t3[lc(v)]=1;
		if (t1[rc(v)]==1) t1[rc(v)]=0,t2[rc(v)]=1;
		else if (t2[rc(v)]==1) t1[rc(v)]=1,t2[rc(v)]=0;
		else if (t3[rc(v)]==1) t3[rc(v)]=0;
		else t3[rc(v)]=1;
		t3[v]=0;
	}
}
void build(int v,int ll,int rr)
{
	l[v]=ll,r[v]=rr;
	if (rr-ll==1)
	{
		t1[v]=0;//是否被全部赋为1
		t2[v]=1;//是否被全部赋为0
		t3[v]=0;//是否被取反 
		return;
	}
	int mid=(ll+rr)&gt;&gt;1;
	build(lc(v),ll,mid);
	build(rc(v),mid,rr);
}
void change1(int v,int a,int b)
{
	if (a&gt;b) return;
	if (r[v]-l[v]==1||(a&lt;=l[v]&amp;&amp;r[v]&lt;=b))
	{
		t1[v]=1;
		t2[v]=0;
		t3[v]=0;
		return;
	}
	pushdown(v);
	int mid=(l[v]+r[v])&gt;&gt;1;
	if (a&lt;mid) change1(lc(v),a,b);
	if (b&gt;=mid) change1(rc(v),a,b);
}
void change2(int v,int a,int b)
{
	if (a&gt;b) return;
	if (r[v]-l[v]==1||(a&lt;=l[v]&amp;&amp;r[v]&lt;=b))
	{
		t1[v]=0;
		t2[v]=1;
		t3[v]=0;
		return;
	}
	pushdown(v);
	int mid=(l[v]+r[v])&gt;&gt;1;
	if (a&lt;mid) change2(lc(v),a,b);
	if (b&gt;=mid) change2(rc(v),a,b);
}
void change3(int v,int a,int b)
{
	if (a&gt;b) return;
	if (r[v]-l[v]==1||(a&lt;=l[v]&amp;&amp;r[v]&lt;=b))
	{
		if (t1[v]==1) t1[v]=0,t2[v]=1;
		else if (t2[v]==1) t1[v]=1,t2[v]=0;
		else if (t3[v]==1) t3[v]=0;
		else t3[v]=1;
		return;
	}
	pushdown(v);
	int mid=(l[v]+r[v])&gt;&gt;1;
	if (a&lt;mid) change3(lc(v),a,b);
	if (b&gt;=mid) change3(rc(v),a,b);
}
void outit(int v)
{
	if (r[v]-l[v]==1)
	{
		if (t1[v]==1) a[l[v]]=1;
		return;
	}
	pushdown(v);
	outit(lc(v));
	outit(rc(v));
}
int main()
{
	build(1,1,maxx+1);
	while (~scanf(&quot;%c &quot;,&amp;ch))
	{
		scanf(&quot;%c%d%c%d%c&quot;,&amp;ch1,&amp;ll,&amp;ch2,&amp;rr,&amp;ch2);
		scanf(&quot;\n&quot;);
		if (ch1=='[') ll=ll*2+1;
		else ll=ll*2+2;
		if (ch2==']') rr=rr*2+1;
		else rr=rr*2;
		if (ch=='U') change1(1,ll,rr);
		else if (ch=='I')
		{
			change2(1,1,ll-1);
			change2(1,rr+1,maxx);
		}
		else if (ch=='D') change2(1,ll,rr);
		else if (ch=='C')
		{
			change2(1,1,ll-1);
			change2(1,rr+1,maxx);
			change3(1,ll,rr);
		}
		else change3(1,ll,rr);
	}
	outit(1);
	k=0;
	while (k&lt;=maxx)
	{
		while (a[k]==0&amp;&amp;k&lt;=maxx) ++k;
		if (k&gt;maxx) break;
		flag=1;
		t=k;
		while (a[t]==1&amp;&amp;t&lt;=maxx) ++t;
		--t;
		if (k&amp;1==1) printf(&quot;%c%d&quot;,'[',(k-1)/2);
		else printf(&quot;%c%d&quot;,'(',(k-2)/2);
		printf(&quot;%c&quot;,',');
		if (t&amp;1==1) printf(&quot;%d%c&quot;,(t-1)/2,']');
		else printf(&quot;%d%c&quot;,t/2,')');printf(&quot; &quot;);
		k=t+1;
	}
	if (!flag) printf(&quot;%s&quot;,&quot;empty set\n&quot;);
	printf(&quot;\n&quot;);
	return 0;
}<pre><h2>Problem3226</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define NN 601001
#define rep(i,s,t) for(int i=s;i&lt;=t;i++)
using namespace std;
int rev[NN],sum[NN],change[NN],a[NN];
int n=140000,m;

inline void update(int p){sum[p]=sum[p&lt;&lt;1]+sum[p&lt;&lt;1|1];}
void makec(int p,int len,int x){change[p]=x;sum[p]=len*x;rev[p]=0;}
void maker(int p,int len){rev[p]^=1,sum[p]=len-sum[p];}

void clear(int p,int len)
{
	if(len==1)return;
	int e=p&lt;&lt;1;
	if(change[p]!=-1)
		makec(e,len-(len&gt;&gt;1),change[p]),makec(e+1,len&gt;&gt;1,change[p]);
	if(rev[p])
		maker(e,len-(len&gt;&gt;1)),maker(e+1,len&gt;&gt;1);
	change[p]=-1,rev[p]=0;
}

void Change(int p,int l,int r,int s,int t,int x)
{
	if(s&gt;t)return;
	if(l==s&amp;&amp;r==t)
		makec(p,r-l+1,x);
	else
	{
		clear(p,r-l+1);
		int mid=(l+r)&gt;&gt;1;
		if(t&lt;=mid) Change(p&lt;&lt;1,l,mid,s,t,x);
		else if(s&gt;mid) Change(p&lt;&lt;1|1,mid+1,r,s,t,x);
		else Change(p&lt;&lt;1,l,mid,s,mid,x),Change(p&lt;&lt;1|1,mid+1,r,mid+1,t,x);
		update(p);
	}
}

void REV(int p,int l,int r,int s,int t)
{
	if(s&gt;t)return;
	if(l==s&amp;&amp;r==t)
		maker(p,r-l+1);
	else
	{
		clear(p,r-l+1);
		int mid=(l+r)&gt;&gt;1;
		if(t&lt;=mid) REV(p&lt;&lt;1,l,mid,s,t);
		else if(s&gt;mid) REV(p&lt;&lt;1|1,mid+1,r,s,t);
		else REV(p&lt;&lt;1,l,mid,s,mid),REV(p&lt;&lt;1|1,mid+1,r,mid+1,t);
		update(p);
	}
}

void getsq(int p,int l,int r)
{
	if(l==r)
		a[l]=sum[p];
	else
	{
		clear(p,r-l+1);
		int mid=(l+r)&gt;&gt;1;
		getsq(p&lt;&lt;1,l,mid);
		getsq(p&lt;&lt;1|1,mid+1,r);
	}
}

int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);//freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	memset(rev,0,sizeof(rev));
	memset(change,-1,sizeof(change));
	memset(sum,0,sizeof(sum));
	char ch,s[10];
	int x,y;
	int cnt=0;
	while(scanf(&quot;%s&quot;,s)!=EOF)
	{
		cnt++;
		ch=getchar();
		while(ch!='('&amp;&amp;ch!='[')ch=getchar();
		scanf(&quot;%d&quot;,&amp;x);x++;
		x=(ch=='[')?x*2-1:x*2;
		getchar();
		scanf(&quot;%d&quot;,&amp;y);y++;
		ch=getchar();
		y=(ch==')')?(y-1)*2:y*2-1;
	//	printf(&quot;%d     %c %d %d\n&quot;,cnt,s[0],x,y);
		if (x&gt;y)continue;
		if(s[0]=='U') Change(1,1,n,x,y,1);
		else if(s[0]=='I')Change(1,1,n,1,x-1,0),Change(1,1,n,y+1,n,0);
		else if(s[0]=='D')Change(1,1,n,x,y,0);
		else if(s[0]=='C')REV(1,1,n,x,y),Change(1,1,n,1,x-1,0),Change(1,1,n,y+1,n,0);
		else if(s[0]=='S')REV(1,1,n,x,y);
//		getsq(1,1,n);
//		for(int i=1;i&lt;=20;i+=2)
//			printf(&quot;%d %d\n&quot;,a[i],a[i+1]);
//		printf(&quot;//================================\n&quot;);
	}
	getsq(1,1,n);
	int tmp=0;
	rep(i,1,n)
		if(a[i]!=a[i-1])
		{
			tmp+=a[i];
			if(a[i]) 
				printf((i%2)?&quot;[%d,&quot;:&quot;(%d,&quot;,((i+1)&gt;&gt;1)-1);
			else 
				printf(((i-1)%2)?&quot;%d] &quot;:&quot;%d) &quot;,((i+1)&gt;&gt;1)-1);
		}	
	if(tmp==0)printf(&quot;empty set&quot;);
	return 0;
}<pre><h2>Problem3227</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 999999999
int f[5001][19],g[5001][19],n;
bool kind;
inline void renew(int &amp;x,int y)
{
	if (kind&amp;&amp;y&lt;x) x=y;
	else if (!kind&amp;&amp;y&gt;x) x=y;
}
int work()
{
	int i,j,k,t;
	if (kind) t=60;else t=-60;
	memset(f,t,sizeof(f)),memset(g,t,sizeof(g));
	f[0][1]=g[0][1]=0;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=18;j++)
		{
			int &amp;B=f[i][j],&amp;R=g[i][j];
			for (k=0;(k&lt;&lt;1)&lt;=i;k++)
			{
				renew(R,f[k][j]+f[i-k-1][j]);
				renew(B,f[k][j-1]+f[i-k-1][j-1]);
				renew(B,g[k][j-1]+g[i-k-1][j-1]);
			}
			for (k=0;k&lt;=i;k++) renew(B,f[k][j-1]+g[i-k-1][j-1]);
			R++;
		}
	if (kind) t=inf;else t=0;
	for (j=1;j&lt;=18;j++)
		renew(t,f[n][j]),renew(t,g[n][j]);
	return t;
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	kind=true;
	printf(&quot;%d\n&quot;,work());
	kind=false;
	printf(&quot;%d\n&quot;,work());
	return 0;
}<pre><h2>Problem3227</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 999999999
int f[5001][19],g[5001][19],n;
bool kind;
inline void renew(int &amp;x,int y)
{
	if (kind&amp;&amp;y&lt;x) x=y;
	else if (!kind&amp;&amp;y&gt;x) x=y;
}
int work()
{
	int i,j,k,t;
	if (kind) t=60;else t=-60;
	memset(f,t,sizeof(f)),memset(g,t,sizeof(g));
	f[0][1]=g[0][1]=0;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=15;j++)
		{
			int &amp;B=f[i][j],&amp;R=g[i][j];
			for (k=0;(k&lt;&lt;1)&lt;=i;k++)
			{
				renew(R,f[k][j]+f[i-k-1][j]);
				renew(B,f[k][j-1]+f[i-k-1][j-1]);
				renew(B,g[k][j-1]+g[i-k-1][j-1]);
			}
			for (k=0;k&lt;=i;k++) renew(B,f[k][j-1]+g[i-k-1][j-1]);
			R++;
		}
	if (kind) t=inf;else t=0;
	for (j=1;j&lt;=15;j++)
		renew(t,f[n][j]),renew(t,g[n][j]);
	return t;
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	kind=true;
	printf(&quot;%d\n&quot;,work());
	kind=false;
	printf(&quot;%d\n&quot;,work());
	return 0;
}<pre><h2>Problem3227</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 999999999
int f[5001][16],g[5001][16],n;
bool kind;
inline void renew(int &amp;x,int y)
{
	if (kind&amp;&amp;y&lt;x) x=y;
	else if (!kind&amp;&amp;y&gt;x) x=y;
}
int work()
{
	int i,j,k,t;
	if (kind) t=60;else t=-60;
	memset(f,t,sizeof(f)),memset(g,t,sizeof(g));
	f[0][1]=g[0][1]=0;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=15;j++)
		{
			int &amp;B=f[i][j],&amp;R=g[i][j];
			for (k=0;(k&lt;&lt;1)&lt;=i;k++)
			{
				renew(R,f[k][j]+f[i-k-1][j]);
				renew(B,f[k][j-1]+f[i-k-1][j-1]);
				renew(B,g[k][j-1]+g[i-k-1][j-1]);
			}
			for (k=0;k&lt;=i;k++) renew(B,f[k][j-1]+g[i-k-1][j-1]);
			R++;
		}
	if (kind) t=inf;else t=0;
	for (j=1;j&lt;=15;j++)
		renew(t,f[n][j]),renew(t,g[n][j]);
	return t;
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	kind=true;
	printf(&quot;%d\n&quot;,work());
	kind=false;
	printf(&quot;%d\n&quot;,work());
	return 0;
}<pre><h2>Problem3227</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 999999999
int f[5001][16],g[5001][16],n;
bool kind;
inline void renew(int &amp;x,int y)
{
	if (kind&amp;&amp;y&lt;x) x=y;
	else if (!kind&amp;&amp;y&gt;x) x=y;
}
int work()
{
	int i,j,k,t;
	if (kind) t=60;else t=-60;
	memset(f,t,sizeof(f)),memset(g,t,sizeof(g));
	f[0][1]=g[0][1]=0;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=15;j++)
		{
			int &amp;B=f[i][j],&amp;R=g[i][j];
			for (k=0;(k&lt;&lt;1)&lt;=i;k++)
			{
				renew(R,f[k][j]+f[i-k-1][j]);
				renew(B,f[k][j-1]+f[i-k-1][j-1]);
				renew(B,g[k][j-1]+g[i-k-1][j-1]);
			}
			for (k=0;k&lt;=i;k++) renew(B,f[k][j-1]+g[i-k-1][j-1]);
			R++;
		}
	if (kind) t=inf;else t=0;
	for (j=1;j&lt;=15;j++)
		renew(t,f[n][j]),renew(t,g[n][j]);
	return t;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	kind=true;
	printf(&quot;%d\n&quot;,work());
	kind=false;
	printf(&quot;%d\n&quot;,work());
	return 0;
}<pre><h2>Problem3227</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 999999999
int f[5001][16],g[5001][16],n;
bool kind;
inline void renew(int &amp;x,int y)
{
	if (kind&amp;&amp;y&lt;x) x=y;
	else if (!kind&amp;&amp;y&gt;x) x=y;
}
int work()
{
	int i,j,k,t;
	if (kind) t=60;else t=-60;
	memset(f,t,sizeof(f)),memset(g,t,sizeof(g));
	f[0][1]=0;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=15;j++)
		{
			int &amp;B=f[i][j],&amp;R=g[i][j];
			for (k=0;(k&lt;&lt;1)&lt;=i;k++)
			{
				renew(R,f[k][j]+f[i-k-1][j]);
				renew(B,f[k][j-1]+f[i-k-1][j-1]);
				renew(B,g[k][j-1]+g[i-k-1][j-1]);
			}
			for (k=0;k&lt;=i;k++) renew(B,f[k][j-1]+g[i-k-1][j-1]);
			R++;
		}
	if (kind) t=inf;else t=0;
	for (j=1;j&lt;=15;j++)
		renew(t,f[n][j]),renew(t,g[n][j]);
	return t;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	kind=true;
	printf(&quot;%d\n&quot;,work());
	kind=false;
	printf(&quot;%d\n&quot;,work());
	return 0;
}<pre><h2>Problem3230</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
typedef pair&lt;int,int&gt; pii;
#define mp make_pair
#define fi first
#define se second
const int NN=250111;
int n,m;
struct SA
{
	int sa[NN&lt;&lt;1],rank[NN&lt;&lt;1],height[NN],f[NN][18],log[NN];
	LL tot,now[NN];
	void build(char *r,int n,int m)
	{
		static int sum[NN&lt;&lt;1],sa2[NN&lt;&lt;1],wv[NN&lt;&lt;1];
		int i,j,p,*x=rank,*y=sa2,*t;
		for (i=0;i&lt;=m;i++) sum[i]=0;
		for (i=1;i&lt;=n;i++) sum[x[i]=r[i]]++;
		for (i=1;i&lt;=m;i++) sum[i]+=sum[i-1];
		for (i=n;i;i--) sa[sum[x[i]]--]=i;
		for (j=p=1;p&lt;n;j&lt;&lt;=1,m=p)
		{
			for (i=n-j+1,p=0;i&lt;=n;i++) y[++p]=i;
			for (i=1;i&lt;=n;i++) if (sa[i]&gt;j) y[++p]=sa[i]-j;
			for (i=0;i&lt;=m;i++) sum[i]=0;
			for (i=1;i&lt;=n;i++) sum[wv[i]=x[y[i]]]++;
			for (i=1;i&lt;=m;i++) sum[i]+=sum[i-1];
			for (i=n;i;i--) sa[sum[wv[i]]--]=y[i];
			for (t=x,x=y,y=t,i=2,x[sa[1]]=p=1;i&lt;=n;i++)
				x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+j]==y[sa[i-1]+j])?p:++p;
		}
		for (i=1;i&lt;=n;i++) rank[i]=x[i];
		for (i=1,p=0;i&lt;=n;i++) if (x[i]&gt;1)
		{
			j=sa[x[i]-1];
			while (r[i+p]==r[j+p]) p++;
			height[x[i]]=p;
			if (p) p--;
		}
		tot=0;
		for (i=1;i&lt;=n;i++)
		{
			tot+=n-sa[i]+1-height[i];
			now[i]=tot;
		}
		for (i=1;i&lt;=n;i++) f[i][0]=height[i];
		for (j=1;j&lt;=17;j++)
			for (i=1;i+(1&lt;&lt;(j-1))&lt;=n;i++)
				f[i][j]=min(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]);
		log[1]=0;
		for (i=2;i&lt;=n;i++) log[i]=(i==(i&amp;-i))?log[i-1]+1:log[i-1];
	}
	pii find(LL K)
	{
		int l=1,r=n,the=0;
		while (l&lt;=r)
		{
			LL mid=(l+r)&gt;&gt;1;
			if (K&lt;=now[mid]) the=mid,r=mid-1;
			else l=mid+1;
		}
		return mp(sa[the],sa[the]+height[the]+(int)(K-now[the-1])-1);
	}
	int getlcp(int l,int r)
	{
		if (l==r) return n;
		l=rank[l],r=rank[r];
		if (l&gt;r) {int t=l;l=r;r=t;}
		l++;
		int t=log[r-l+1];
		return min(f[l][t],f[r-(1&lt;&lt;t)+1][t]);
	}
} sa1,sa2;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	static char s[NN];
	scanf(&quot;%d%d%s&quot;,&amp;n,&amp;m,s+1);
	sa1.build(s,n,256);
	reverse(s+1,s+n+1);
	sa2.build(s,n,256);
	for (;m;m--)
	{
		LL x,y;
		scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y);
		if (x&gt;sa1.tot||y&gt;sa1.tot) {printf(&quot;-1\n&quot;);continue;}
		pii t1=sa1.find(x),t2=sa1.find(y);
		int maxlen=min(t1.se-t1.fi+1,t2.se-t2.fi+1);
		x=min(sa1.getlcp(t1.fi,t2.fi),maxlen);
		y=min(sa2.getlcp(n-t1.se+1,n-t2.se+1),maxlen);
		printf(&quot;%lld\n&quot;,x*x+y*y);
	}
	return 0;
}<pre><h2>Problem3231</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
int size,K;
LL n,m,mo,a[16],b[16],c[16];
struct matrix
{
	LL m[16][16];
	matrix() {memset(m,0,sizeof(m));}
	void clear() {memset(m,0,sizeof(m));}
	LL * operator [](int x) {return m[x];}
	friend matrix operator *(matrix a,matrix b)
	{
		matrix c;
		for (int k=0;k&lt;size;k++)
			for (int i=0;i&lt;size;i++)
				for (int j=0;j&lt;size;j++)
					c[i][j]=(c[i][j]+a[i][k]*b[k][j])%mo;
		return c;
	}
	friend matrix operator ^(matrix a,LL b)
	{
		matrix res;
		for (int i=0;i&lt;size;i++) res[i][i]=1;
		for (;b;b&gt;&gt;=1,a=a*a)
			if (b&amp;1) res=res*a;
		return res;
	}
} aa,ans;
LL calc(LL n)
{
	int i;
	if (n&lt;=K)
	{
		LL res=0;
		for (i=1;i&lt;=n;i++)
		{
			res+=a[i];
			if (res&gt;mo) res-=mo;
		}
		return res;
	}
	aa.clear(),ans.clear();
	for (i=0;i&lt;=K-2;i++) aa[i+1][i]=1;
	for (i=0;i&lt;K;i++) aa[i][K-1]=c[K-i];
	for (i=0;i&lt;K;i++) aa[i][K]=c[K-i];
	aa[K][K]=1;
	aa=aa^(n-K);
	for (i=0;i&lt;K;i++) ans[0][i]=a[i+1];
	for (i=1;i&lt;=K;i++)
	{
		ans[0][K]+=a[i];
		if (ans[0][K]&gt;mo) ans[0][K]-=mo;
	}
	ans=ans*aa;
	return ans[0][K];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;K);
	int i;
	for (i=1;i&lt;=K;i++) scanf(&quot;%lld&quot;,&amp;b[i]);
	for (i=1;i&lt;=K;i++) scanf(&quot;%lld&quot;,&amp;c[i]);
	for (i=1;i&lt;=K;i++) a[i]=b[i];
	scanf(&quot;%lld%lld%lld&quot;,&amp;m,&amp;n,&amp;mo);
	size=K+1;
	LL res=(calc(n)-calc(m-1))%mo;
	if (res&lt;0) res+=mo;
	printf(&quot;%lld\n&quot;,res);
	return 0;
}<pre><h2>Problem3236</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
int b[2101111],num[2101111],a[101111],ans1[1001111],ans2[1001111];
int n,m,cnt,sqrtn;
int cha(int x)
{
	int l=1,r=cnt;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (b[mid]==x) return mid;
		if (b[mid]&gt;x) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
struct query
{
	int l,r,A,B,id;
	void out() {printf(&quot;%d %d %d %d %d\n&quot;,l,r,A,B,id);}
	void in(int i)
	{
		id=i;
		scanf(&quot;%d%d%d%d&quot;,&amp;l,&amp;r,&amp;A,&amp;B);
		b[++cnt]=A,b[++cnt]=B;
	}
	void update()
	{
		A=cha(A),B=cha(B);
	}
	friend bool operator &lt;(query a,query b)
	{
		int t1=a.l/sqrtn,t2=b.l/sqrtn;
		return t1&lt;t2||(t1==t2&amp;&amp;a.r&lt;b.r);
	}
} q[1001111];
struct BIT
{
	int c[2100001];
	void change(int i,int x)
	{
		for (;i&lt;=cnt;i+=i&amp;-i) c[i]+=x;
	}
	int getsum(int i)
	{
		int res=0;
		for (;i;i-=i&amp;-i) res+=c[i];
		return res;
	}
} C1,C2;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),b[i]=a[i];
	cnt=n;
	for (i=1;i&lt;=m;i++) q[i].in(i);
	sort(b+1,b+cnt+1);
	int t=1;
	for (i=2;i&lt;=cnt;i++)
		if (b[i]!=b[t]) b[++t]=b[i];
	cnt=t;
	for (i=1;i&lt;=n;i++) a[i]=cha(a[i]);
	for (i=1;i&lt;=m;i++) q[i].update();
	//for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,a[i]);ln;ln;for (i=1;i&lt;=m;i++) q[i].out();ln;
	sqrtn=(int)sqrt(n)+1;
	sort(q+1,q+m+1);
	int l=1,r=1;
	num[a[1]]=1;
	C1.change(a[1],1);C2.change(a[1],1);
	for (i=1;i&lt;=m;i++)
	{
		//printf(&quot;\n-------------------------------------------------------------------------\n&quot;);
		if (q[i].r&gt;r)
			for (j=r+1;j&lt;=q[i].r;j++)
			{
				num[a[j]]++;
				C1.change(a[j],1);
				if (num[a[j]]==1) C2.change(a[j],1);
			}
		if (q[i].l&lt;l)
			for (j=l-1;j&gt;=q[i].l;j--)
			{
				num[a[j]]++;
				C1.change(a[j],1);
				if (num[a[j]]==1) C2.change(a[j],1);
			}
		if (q[i].r&lt;r)
			for (j=r;j&gt;q[i].r;j--)
			{
				num[a[j]]--;
				C1.change(a[j],-1);
				if (num[a[j]]==0) C2.change(a[j],-1);
			}
		if (q[i].l&gt;l)
			for (j=l;j&lt;q[i].l;j++)
			{
				num[a[j]]--;
				C1.change(a[j],-1);
				if (num[a[j]]==0) C2.change(a[j],-1);
			}
		ans1[q[i].id]=C1.getsum(q[i].B)-C1.getsum(q[i].A-1);
		ans2[q[i].id]=C2.getsum(q[i].B)-C2.getsum(q[i].A-1);
		l=q[i].l,r=q[i].r;
	}
	for (i=1;i&lt;=m;i++) printf(&quot;%d %d\n&quot;,ans1[i],ans2[i]);
	return 0;
}<pre><h2>Problem3237</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
using namespace std;
typedef unsigned long long ULL;
#define ln printf(&quot;\n&quot;)
const int NN=100111,MM=201111;
int o[NN],aa[MM&lt;&lt;1][2],fa[NN],dfn[NN];
int n,m,tes,tot=1,TIME;
ULL val[MM],temp[NN];
bool vt[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar());
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline ULL getrand()
{
	return (ULL)rand()*rand()*rand()+1;
}
void dfs(int v)
{
	dfn[v]=++TIME;
	vt[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		if (!vt[y])
		{
			fa[y]=v;
			dfs(y);
			val[p&gt;&gt;1]=temp[y];
			temp[v]^=temp[y];
		}
		else if (dfn[y]&lt;dfn[v])
		{
			val[p&gt;&gt;1]=getrand();
			temp[v]^=val[p&gt;&gt;1];
			temp[y]^=val[p&gt;&gt;1];
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	int i,x,y,k;
	for (i=1;i&lt;=m;i++)
	{
		read(x),read(y);
		addedge(x,y),addedge(y,x);
	}
	dfs(1);
	for (read(tes);tes;tes--)
	{
		read(k);
		int b[5];
		for (i=1;i&lt;=k;i++) read(b[i]);
		bool flag=true;
		for (int S=1;S&lt;1&lt;&lt;k;S++)
		{
			ULL tmp=0;
			for (i=1;i&lt;=k;i++)
				if (S&amp;(1&lt;&lt;(i-1))) tmp^=val[b[i]];
			if (tmp==0) {flag=false;break;}
		}
		printf(flag?&quot;Connected\n&quot;:&quot;Disconnected\n&quot;);
	}
	return 0;
}<pre><h2>Problem3237</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
using namespace std;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
const int NN=100111,MM=201111;
int o[NN],aa[MM&lt;&lt;1][2],fa[NN],dfn[NN];
int n,m,tes,tot=1,TIME;
LL val[MM],temp[NN];
bool vt[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar());
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline LL getrand()
{
	LL tmp=(LL)rand()*rand()*rand();
	if (tmp&lt;0) tmp+=1ll&lt;&lt;63;
	return ++tmp;
}
void dfs(int v)
{
	dfn[v]=++TIME;
	vt[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		if (!vt[y])
		{
			fa[y]=v;
			dfs(y);
			val[p&gt;&gt;1]=temp[y];
			temp[v]^=temp[y];
		}
		else if (dfn[y]&lt;dfn[v])
		{
			val[p&gt;&gt;1]=getrand();
			temp[v]^=val[p&gt;&gt;1];
			temp[y]^=val[p&gt;&gt;1];
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	int i,j,x,y,k;
	for (i=1;i&lt;=m;i++)
	{
		read(x),read(y);
		addedge(x,y),addedge(y,x);
	}
	dfs(1);
	for (read(tes);tes;tes--)
	{
		read(k);
		LL b[5];
		for (i=1;i&lt;=k;i++)
		{
			read(x);
			b[i]=val[x];
		}
		int t=0;
		for (i=63;i;i--)
		{
			for (j=t+1;j&lt;=k;j++)
				if (b[j]&amp;(1ll&lt;&lt;(i-1))) break;
			if (j==k+1) continue;
			swap(b[++t],b[j]);
			for (j=t+1;j&lt;=k;j++)
				if (b[j]&amp;(1ll&lt;&lt;(i-1))) b[j]^=b[t];
		}
		bool flag=true;
		for (i=1;i&lt;=k;i++)
			if (b[i]==0) flag=false;
		printf(flag?&quot;Connected\n&quot;:&quot;Disconnected\n&quot;);
	}
	return 0;
}<pre><h2>Problem3238</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 999999999
#define ln printf(&quot;\n&quot;)
typedef long long LL;
const int NN=1001111;
int sum[NN],rank[NN],height[NN],wv[NN],sa[NN],sa2[NN],s[NN],sta[NN],right[NN],left[NN];
int n,top;
LL ans;
char ss[NN];
void out(int*a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
void Suffix_Array(int *r,int n,int m)
{
	int i,j,p,*x=rank,*y=sa2,*t;
	for (i=0;i&lt;=m;i++) sum[i]=0;
	for (i=1;i&lt;=n;i++) sum[x[i]=r[i]]++;
	for (i=1;i&lt;=m;i++) sum[i]+=sum[i-1];
	for (i=n;i;i--) sa[sum[x[i]]--]=i;
	for (j=p=1;p&lt;n;j&lt;&lt;=1,m=p)
	{
		for (i=n-j+1,p=0;i&lt;=n;i++) y[++p]=i;
		for (i=1;i&lt;=n;i++) if (sa[i]&gt;j) y[++p]=sa[i]-j;
		for (i=1;i&lt;=n;i++) wv[i]=x[y[i]];
		for (i=0;i&lt;=m;i++) sum[i]=0;
		for (i=1;i&lt;=n;i++) sum[wv[i]]++;
		for (i=1;i&lt;=m;i++) sum[i]+=sum[i-1];
		for (i=n;i;i--) sa[sum[wv[i]]--]=y[i];
		for (t=x,x=y,y=t,i=2,x[sa[1]]=p=1;i&lt;=n;i++)
			x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+j]==y[sa[i-1]+j])?p:++p;
	}
	for (i=1;i&lt;=n;i++) rank[i]=x[i];
	for (p=0,i=1;i&lt;=n;i++) if (x[i]&gt;1)
	{
		j=sa[x[i]-1];
		while (r[i+p]==r[j+p]) p++;
		height[x[i]]=p;
		if (p) p--;
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%s&quot;,ss+1);
	n=strlen(ss+1);
	int i;
	for (i=1;i&lt;=n;i++) s[i]=ss[i];
	Suffix_Array(s,n,256);
	//printf(&quot;height &quot;);out(height,1,n);
	LL ans=0;
	for (i=1;i&lt;=n;i++) ans+=(LL)(n-1)*i;
	//printf(&quot;ans=%I64d\n&quot;,ans);
	height[1]=-inf;
	sta[top=1]=1;
	for (i=2;i&lt;=n;i++)
	{
		while (height[i]&lt;height[sta[top]]) right[sta[top--]]=i-1;
		left[i]=sta[top]+1;
		sta[++top]=i;
	}
	while (top&gt;1) right[sta[top--]]=n;
	for (i=1;i&lt;=n;i++) left[i]--;
	//printf(&quot;right &quot;);out(right,1,n);printf(&quot;left  &quot;);out(left,1,n);
	for (i=2;i&lt;=n;i++)
	{
		int t1=i-left[i],t2=right[i]-i+1;
		LL tmp=(LL)t1*t2;
		//printf(&quot;tmp=%I64d\n&quot;,tmp);
		ans-=tmp*2*height[i];
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem3239</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
typedef long long LL;
LL P,B,N;
struct ppt
{
	LL w;
	int id;
	friend bool operator &lt;(ppt a,ppt b) {return a.w&lt;b.w;}
} f[3000000];
LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	while (scanf(&quot;%I64d%I64d%I64d&quot;,&amp;P,&amp;B,&amp;N)!=EOF)
	{
		//printf(&quot;\n----------------------------------------------------------------------------\n&quot;);
		B%=P,N%=P;
		f[0].w=1;
		f[0].id=0;
		LL size=(LL)sqrt(P)+1;
		//printf(&quot;size=%I64d\n&quot;,size);
		for (int i=1;i&lt;size;i++)
		{
			f[i].id=i;
			f[i].w=f[i-1].w*B%P;
		}
		sort(f,f+size);
		int t=0;
		for (int i=1;i&lt;size;i++)
			if (f[i].w!=f[t].w||(f[i].w==f[t].w&amp;&amp;f[i].id&lt;f[t].id)) f[++t]=f[i];
		int cnt=t;
		//for (int i=0;i&lt;=cnt;i++) printf(&quot;%d %I64d\n&quot;,f[i].id,f[i].w);
		bool flag=false;
		LL ans;
		for (int i=0;i&lt;=size;i++)
		{
			LL tmp=ksm(B,size*i,P);
			if (tmp==0)
			{
				if (N==0) {flag=true;ans=size*i;break;}
				else break;
			}
			tmp=N*ksm(tmp,P-2,P)%P;
			//printf(&quot;======== i=%d tmp=%I64d =======\n&quot;,i,tmp);
			int l=0,r=cnt,res=-1;
			while (l&lt;=r)
			{
				int mid=(l+r)&gt;&gt;1;
				if (f[mid].w==tmp) {res=mid;break;}
				if (f[mid].w&gt;tmp) r=mid-1;
				else l=mid+1;
			}
			if (res&gt;=0)
			{
				flag=true;
				ans=size*i+f[res].id;
				break;
			}
		}
		if (!flag) printf(&quot;no solution\n&quot;);
		else printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem3239</h2><pre>
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#define ll long long
#define MOD 140345

using namespace std;

ll ans, A, B, C;
int t, d[MOD+10];

struct ME {
	int hou, nt;
	ll zhi;
}sg[MOD+10];

inline ll Get_inv(ll x, ll k) {
	ll an = 1;
	while(k) {
		if(k&amp;1) an = (an*x)%C;
		x = (x*x)%C;
		k &gt;&gt;= 1;
	}
	return an;
}

inline void Add(int x, int y, ll z) {
	sg[++ t].hou = y;
	sg[t].zhi = z;
	sg[t].nt = d[x];
	d[x] = t;
	return;
}

inline void BSGS(int A, int B, int C) {
	int m = (int)ceil(sqrt(C));
	ll k = 1;
	Add(1, 0, 1);
	for(int i = 1 ; i &lt; m ; ++ i) {
		k = (k*A)%C;
		bool fg = false;
		for(int j = d[k%MOD] ; j != -1 ; j = sg[j].nt) {
			if(sg[j].zhi==k) {
				fg = true;
				break;
			}
		}
		if(!fg) Add(k%MOD, i, k);
	}
	k = (k*A)%C;
	ll D = 1, inv = Get_inv(D, C-2), tmp = (B*inv)%C;
	ans = -1;
	for(int j = d[tmp%MOD] ; j != -1 ; j = sg[j].nt) {
		if(sg[j].zhi==tmp) {
			ans = sg[j].hou;
			break;
		}
	}
	if(ans!=-1) return;
	for(int i = 1 ; i &lt;= m ; ++ i) {
		D = (D*k)%C;
		inv = Get_inv(D, C-2);
		tmp = (B*inv)%C;
		for(int j = d[tmp%MOD] ; j != -1 ; j = sg[j].nt) {
			if(sg[j].zhi==tmp) {
				ans =sg[j].hou+i*m;
				break;
			}
		}
		if(ans!=-1) return;
	}
	return;
}

int main() {
	while(~scanf(&quot;%lld%lld%lld&quot;, &amp;C, &amp;A, &amp;B)) {
		t = 0, memset(d, -1, sizeof(d));
		BSGS(A, B, C);
		if(ans==-1) puts(&quot;no solution&quot;);
		else printf(&quot;%lld\n&quot;, ans);
	}
//	while(1);
	return 0;
}
<pre><h2>Problem3239</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;map&gt;

using namespace std;

typedef pair&lt;long long,long long&gt; data;
long long A,B,C;
map&lt;long long,long long&gt; M;

data EXGCD(long long x,long long y)
{
	if(!y) return data(1,0);
	data temp=EXGCD(y,x%y);
	return data(temp.second,temp.first-x/y*temp.second);
}

long long EXBSGS()
{
	M.clear();
	int i;
	long long am,D,m=(int)ceil(sqrt(C));
	for(i=0,am=1;i&lt;m;i++,(am*=A)%=C){
		if(!M.count(am)) M[am]=i;
	}
	for(i=0,D=1;i&lt;=m;i++,(D*=am)%=C){
		data temp=EXGCD(D,C);
		long long x=(temp.first*B%C+C)%C;
		if(M.count(x)) return i*m+M[x];
	}
	return -1;
}

int main()
{
	while(scanf(&quot;%lld%lld%lld&quot;,&amp;C,&amp;A,&amp;B)==3){
		long long ans=EXBSGS();
		if(ans==-1) puts(&quot;no solution&quot;);
		else printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}
<pre><h2>Problem3239</h2><pre>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;
#define ll long long
ll m;
int cnt,hash[100007],num[100007],ci[100007];
inline void add(int x,int shu){
    int pos=x%100007;
    while(hash[pos]&amp;&amp;num[hash[pos]]!=x) pos=(pos+1)%100007;
    if(!hash[pos]) hash[pos]=++cnt,num[cnt]=x,ci[cnt]=shu;
}
inline int find(int x){
    int pos=x%100007;
    while(hash[pos]&amp;&amp;num[hash[pos]]!=x) pos=(pos+1)%100007;
    if(hash[pos]) return ci[hash[pos]];
    return -1;
}
inline void exgcd(ll a,ll b,ll &amp;x,ll &amp;y){
    if(!b){x=1,y=0;return;}
    else exgcd(b,a%b,y,x),y-=a/b*x;
}
int main(){
    for(ll B,N,P;~scanf(&quot;%lld%lld%lld&quot;,&amp;P,&amp;B,&amp;N);memset(hash,0,sizeof(hash))){
        m=sqrt(P)+1;ll i,j,k,x,y;cnt=0;
        for(i=0,j=1;i&lt;m;++i)
            if(j==N){printf(&quot;%lld\n&quot;,i);break;}
            else add(j,i),j=j*B%P;
        if(i&lt;m) continue;
        for(i=0,k=1;i&lt;m;++i,k=k*j%P){
            exgcd(k,P,x,y);
            x=x*N%P;
            if(x&lt;0) x+=P;
            if((x=find(x))&gt;-1){printf(&quot;%lld\n&quot;,i*m+x);break;}
        }
        if(i==m) puts(&quot;no solution&quot;);
    }
    //while(1);
}<pre><h2>Problem3240</h2><pre>//#include&lt;CSpreadSheet.h&gt;

#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;sstream&gt;
#include&lt;cstdlib&gt;
#include&lt;string&gt;
#include&lt;string.h&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;stack&gt;
#include&lt;list&gt;
#include&lt;queue&gt;
#include&lt;ctime&gt;
#include&lt;bitset&gt;
#include&lt;cmath&gt;
#define eps 1e-6
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
//#define ll __int64
#define ll long long
#define lson l,m,(rt&lt;&lt;1)
#define rson m+1,r,(rt&lt;&lt;1)|1
#define MM 1000000007
//#pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;)
using namespace std;

#define Maxn 1100000

char s1[Maxn],s2[Maxn];
ll a,b,c,d;

void sub(char * cur)
{
    int len=strlen(cur);

    len--;
    if(cur[len]!='0')
    {
        cur[len]=cur[len]-1;
        return ;
    }
    cur[len]='9';
    len--;

    while(len&gt;=0&amp;&amp;cur[len]=='0')
    {
        cur[len]='9';
        len--;
    }
    cur[len]=cur[len]-1;
}
struct Mar
{
    ll v1,v2;

    void init(ll a,ll b)
    {
        v1=a;
        v2=b;
    }
    friend struct Mar operator * (const struct Mar &amp;a,const struct Mar &amp;b)
    {

        Mar c;

        c.v1=(a.v1*b.v1)%MM;
        c.v2=(a.v1*b.v2+a.v2)%MM;

        return c;


    }

};


Mar Pow(Mar aa,ll bb)
{
    Mar c;
    c.init(1,0);
    //c.s[1][1]=1,c.s[2][2]=1;

    while(bb)
    {
        if(bb&amp;1)
            c=aa*c;
        bb&gt;&gt;=1;
        aa=aa*aa;
    }
    return c;
}
Mar T_Pow(Mar aa,char * cur)
{
    Mar res;
    res.init(1,0);

    int i=strlen(cur)-1;
    int j=0;
    while(cur[j]=='0')
        j++;
    while(i&gt;=j)
    {
        res=Pow(aa,cur[i]-'0')*res;
        aa=Pow(aa,10);
        i--;
    }
    return res;
}

int main()
{
   //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);
   //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);

   while(~scanf(&quot;%s%s&quot;,s1,s2))
   {
       scanf(&quot;%lld%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c,&amp;d);
       sub(s1);
       //printf(&quot;%s\n&quot;,s1);
       sub(s2);
       //printf(&quot;%s\n&quot;,s2);
      // ll n=cal(s1),m=cal(s2);

       Mar A;
       A.init(a,b);
       //A.s[1][1]=a,A.s[1][2]=b,A.s[2][2]=1;
       Mar B;
       B.init(c,d);
       //B.s[1][1]=c,B.s[1][2]=d,B.s[2][2]=1;

       Mar C=T_Pow(A,s2);
       Mar D=B*C;
       D=T_Pow(D,s1);
       D=C*D;

       printf(&quot;%lld\n&quot;,(D.v1+D.v2)%MM);

   }
   return 0;
}



<pre><h2>Problem3240</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mo 1000000007
#define LL long long
int i;
LL n,m,phi,a,b,c,d,x,y,res;
char s1[1001111],s2[1001111];
LL ksm(LL a,LL b)
{
	LL res=1;
	for (a%=mo;b;b&gt;&gt;=1,a=a*a%mo)
		if (b&amp;1) res=res*a%mo;
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%s%s%lld%lld%lld%lld&quot;,s1+1,s2+1,&amp;a,&amp;b,&amp;c,&amp;d);
	if (a==1&amp;&amp;c==1) phi=mo;else phi=mo-1;
	int len=strlen(s1+1);
	for (i=1;i&lt;=len;i++) n=(n*10+s1[i]-'0')%phi;
	if (a==1) phi=mo;else phi=mo-1;
	len=strlen(s2+1);
	for (i=1;i&lt;=len;i++) m=(m*10+s2[i]-'0')%phi;
	//printf(&quot;%lld %lld\n&quot;,n,m);
	if (a==1)
	{
		x=c;
		y=(b*c%mo*(m-1)%mo+d)%mo;
	}
	else
	{
		x=c*ksm(a,m-1)%mo;
		y=b*c%mo*ksm(a-1,mo-2)%mo;
		y=(y*(ksm(a,m-1)-1)+d)%mo;
	}
	if (x==1) res=(1+n*y)%mo;
	else
	{
		res=(y*ksm(x-1,mo-2)+1)%mo;
		res=res*ksm(x,n)%mo;
		res=(res-y*ksm(x-1,mo-2)%mo)%mo;
	}
	res=(res-d)%mo;
	res=res*ksm(c,mo-2)%mo;
	if (res&lt;0) res+=mo;
	printf(&quot;%lld\n&quot;,res);
	return 0;
}
<pre><h2>Problem3240</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mo 1000000007
#define LL long long
int i;
LL n,m,phi,a,b,c,d,x,y,res;
char s1[1001111],s2[1001111];
LL ksm(LL a,LL b)
{
	LL res=1;
	for (a%=mo;b;b&gt;&gt;=1,a=a*a%mo)
		if (b&amp;1) res=res*a%mo;
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%s%s%lld%lld%lld%lld&quot;,s1+1,s2+1,&amp;a,&amp;b,&amp;c,&amp;d);
	if (a==1&amp;&amp;c==1) phi=mo;else phi=mo-1;
	int len=strlen(s1+1);
	for (i=1;i&lt;=len;i++) n=(n*10+s1[i]-'0')%phi;
	if (a==1) phi=mo;else phi=mo-1;
	len=strlen(s2+1);
	for (i=1;i&lt;=len;i++) m=(m*10+s2[i]-'0')%phi;
	if (a==1)
	{
		x=c;
		y=(b*c%mo*(m-1)%mo+d)%mo;
	}
	else
	{
		x=c*ksm(a,m-1)%mo;
		y=b*c%mo*ksm(a-1,mo-2)%mo;
		y=(y*(ksm(a,m-1)-1)+d)%mo;
	}
	if (x==1) res=(1+n*y)%mo;
	else
	{
		res=(y*ksm(x-1,mo-2)+1)%mo;
		res=res*ksm(x,n)%mo;
		res=(res-y*ksm(x-1,mo-2)%mo)%mo;
	}
	res=(res-d)%mo;
	res=res*ksm(c,mo-2)%mo;
	if (res&lt;0) res+=mo;
	printf(&quot;%lld\n&quot;,res);
	return 0;
}
<pre><h2>Problem3242</h2><pre>#include&lt;cstdio&gt;
#include&lt;set&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
#define INF 99999999999999999ll
typedef long long LL;
const int NN=101111;
int fa[NN],b[NN],o[NN],aa[NN*2][3];
int n,tot=1,cnt;
LL f[NN],f2[NN],dd[NN],deep[NN],res;
bool flag[NN],vt[NN];
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
void out(LL *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%I64d &quot;,a[i]);ln;}
struct ppt
{
	LL w; int id;
	void out() {printf(&quot;w=%I64d  id=%d\n&quot;,w,id);}
	ppt(LL a=0,int b=0) {w=a,id=b;}
	friend bool operator &lt;(ppt a,ppt b) {return a.w&lt;b.w||(a.w==b.w&amp;&amp;a.id&lt;b.id);}
};
multiset&lt;ppt&gt; S1,S2;
bool dfs(int v)
{
	vt[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		if (vt[y])
		{
			for (int x=v;x!=fa[y];x=fa[x])
				cnt++,b[cnt]=x,dd[cnt]=deep[v]-deep[x];
			dd[cnt+1]=dd[cnt]+aa[p][2];
			return true;
		}
		fa[y]=v;
		deep[y]=deep[v]+aa[p][2];
		if (dfs(y)) return true;
	}
	return false;
}
void dp(int v)
{
	LL m1=0,m2=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (flag[y]||y==fa[v]) continue;
		fa[y]=v;
		dp(y);
		LL tmp=f[y]+aa[p][2];
		if (tmp&gt;m1) m2=m1,m1=tmp;
		else if (tmp&gt;m2) m2=tmp;
	}
	if (m1+m2&gt;res) res=m1+m2;
	f[v]=m1;
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y,z;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
	}
	dfs(1);
	//printf(&quot;fa &quot;);out(fa,1,n);
	for (i=1;i&lt;=cnt;i++) flag[b[i]]=true;
	for (i=1;i&lt;=cnt;i++) fa[b[i]]=0,dp(b[i]);
	for (i=1;i&lt;=n;i++) f2[i]=f[i];
	for (i=1;i&lt;=cnt;i++) f[i]=f2[b[i]];
	//printf(&quot;b &quot;);out(b,1,cnt);printf(&quot;dd &quot;);out(dd,1,cnt+1);printf(&quot;f &quot;);out(f,1,cnt);ln;
	for (i=1;i&lt;=cnt;i++)
	{
		S1.insert(ppt(f[i]+dd[i],i));//,printf(&quot;ins1 %d %I64d\n&quot;,i,f[i]+dd[i]);
		S2.insert(ppt(f[i]-dd[i],i));//,printf(&quot;ins2 %d %I64d\n&quot;,i,f[i]-dd[i]);
	}
	LL ans=INF;
	for (i=1;i&lt;=cnt;i++)
	{
		//printf(&quot;\n------------ %d ---------------------------------------------------------\n&quot;,i);
		multiset&lt;ppt&gt;::iterator it1,it2;
		it1=S1.end(),it1--;
		it2=S2.end(),it2--;
		ppt t1=*it1,t2=*it2;
		//printf(&quot;t1:  &quot;);t1.out();printf(&quot;t2:  &quot;);t2.out();
		if (t1.id!=t2.id) ans=min(ans,max(res,t1.w+t2.w));
		else
		{
			it1--,it2--;
			ppt t3=*it1,t4=*it2;
			//printf(&quot;t3:  &quot;);t3.out();printf(&quot;t4:  &quot;);t4.out();
			ans=min(ans,max(res,max(t1.w+t4.w,t2.w+t3.w)));
		}
		//printf(&quot;ans=%I64d\n&quot;,ans);
		S1.erase(S1.find(ppt(f[i]+dd[i],i)));//,printf(&quot;del1 %d %I64d\n&quot;,i,f[i]+dd[i]);
		S1.insert(ppt(f[i]+dd[cnt+1]+dd[i],i));//,printf(&quot;ins1 %d %I64d\n&quot;,i,f[i]+dd[cnt]+dd[i]);
		S2.erase(S2.find(ppt(f[i]-dd[i],i)));//,printf(&quot;del2 %d %I64d\n&quot;,i,f[i]-dd[i]);
		S2.insert(ppt(f[i]-(dd[cnt+1]+dd[i]),i));//,printf(&quot;ins2 %d %I64d\n&quot;,i,f[i]-(dd[cnt]+dd[i]));
	}
	//ln;ln;printf(&quot;Answer: &quot;);
	printf(&quot;%.1f\n&quot;,ans*0.5);
	return 0;
}<pre><h2>Problem3242</h2><pre>#include&lt;cstdio&gt;
#include&lt;set&gt;
using namespace std;
#define INF 99999999999999999ll
typedef long long LL;
const int NN=101111;
int fa[NN],b[NN],o[NN],aa[NN*2][3];
int n,tot=1,cnt;
LL f[NN],f2[NN],dd[NN],deep[NN],res;
bool flag[NN],vt[NN];
struct ppt
{
	LL w; int id;
	ppt(LL a=0,int b=0) {w=a,id=b;}
	friend bool operator &lt;(ppt a,ppt b) {return a.w&lt;b.w||(a.w==b.w&amp;&amp;a.id&lt;b.id);}
};
multiset&lt;ppt&gt; S1,S2;
bool dfs(int v)
{
	vt[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		if (vt[y])
		{
			for (int x=v;x!=fa[y];x=fa[x])
				cnt++,b[cnt]=x,dd[cnt]=deep[v]-deep[x];
			dd[cnt+1]=dd[cnt]+aa[p][2];
			return true;
		}
		fa[y]=v;
		deep[y]=deep[v]+aa[p][2];
		if (dfs(y)) return true;
	}
	return false;
}
void dp(int v)
{
	LL m1=0,m2=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (flag[y]||y==fa[v]) continue;
		fa[y]=v;
		dp(y);
		LL tmp=f[y]+aa[p][2];
		if (tmp&gt;m1) m2=m1,m1=tmp;
		else if (tmp&gt;m2) m2=tmp;
	}
	if (m1+m2&gt;res) res=m1+m2;
	f[v]=m1;
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y,z;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
	}
	dfs(1);
	for (i=1;i&lt;=cnt;i++) flag[b[i]]=true;
	for (i=1;i&lt;=cnt;i++) fa[b[i]]=0,dp(b[i]);
	for (i=1;i&lt;=n;i++) f2[i]=f[i];
	for (i=1;i&lt;=cnt;i++) f[i]=f2[b[i]];
	for (i=1;i&lt;=cnt;i++)
	{
		S1.insert(ppt(f[i]+dd[i],i));
		S2.insert(ppt(f[i]-dd[i],i));
	}
	LL ans=INF;
	for (i=1;i&lt;=cnt;i++)
	{
		multiset&lt;ppt&gt;::iterator it1,it2;
		it1=S1.end(),it1--;
		it2=S2.end(),it2--;
		ppt t1=*it1,t2=*it2;
		if (t1.id!=t2.id) ans=min(ans,max(res,t1.w+t2.w));
		else
		{
			it1--,it2--;
			ppt t3=*it1,t4=*it2;
			ans=min(ans,max(res,max(t1.w+t4.w,t2.w+t3.w)));
		}
		S1.erase(S1.find(ppt(f[i]+dd[i],i)));
		S1.insert(ppt(f[i]+dd[cnt+1]+dd[i],i));
		S2.erase(S2.find(ppt(f[i]-dd[i],i)));
		S2.insert(ppt(f[i]-(dd[cnt+1]+dd[i]),i));
	}
	printf(&quot;%.1f\n&quot;,ans*0.5);
	return 0;
}<pre><h2>Problem3251</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
using namespace std;
const int NN=101111;
int o[NN],aa[NN&lt;&lt;1][2],deep[NN],fa[NN],w[NN];
int n,m,tot;
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs()
{
	static int sta[NN],cur[NN],top;
	sta[top=1]=1;
	cur[1]=o[1];
	deep[1]=1;
	while (top)
	{
		int v=sta[top];
		int p=cur[v];
		if (p==0) {top--;continue;}
		cur[v]=aa[p][0];
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		cur[y]=o[y];
		sta[++top]=y;
	}
}
bool work(int x,int y)
{
	if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
	int cnt=0;
	static int b[NN];
	while (deep[x]&gt;deep[y])
	{
		b[++cnt]=w[x];
		if (cnt&gt;50) return true;
		x=fa[x];
	}
	while (x!=y)
	{
		b[++cnt]=w[x],b[++cnt]=w[y];
		if (cnt&gt;50) return true;
		x=fa[x],y=fa[y];
	}
	b[++cnt]=w[x];
	sort(b+1,b+cnt+1);
	static multiset&lt;int&gt; S;
	S.clear();
	S.insert(b[1]),S.insert(b[2]);
	for (int i=3;i&lt;=cnt;i++)
	{
		multiset&lt;int&gt;::iterator it=S.end();
		int t1=*(--it);
		int t2=*(--it);
		if (t1&gt;b[i]-t2) return true;
		S.insert(b[i]);
	}
	return false;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;w[i]);
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	dfs();
	for (;m;m--)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		if (x==1) w[y]=z;
		else printf(work(y,z)?&quot;Y\n&quot;:&quot;N\n&quot;);
	}
	return 0;
}<pre><h2>Problem3258</h2><pre>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#define ll long long
ll inf=0x7fffffffffffffffLL;
inline ll MIN(ll A,ll B){return A&lt;B?A:B;}
int n,m,u,v,val;
ll w[11000];
int sh,firs[11000];
struct edge{int v,nx;ll w;}e[110000],o[110000];
inline void ad(int u,int v,int w){
	e[++sh].v=v,e[sh].w=w,e[sh].nx=firs[u],firs[u]=sh;
}
int shu,first[11000];
inline void add(int u,int v,ll w){
	o[++shu].v=v,o[shu].w=w,o[shu].nx=first[u],first[u]=shu;
}
bool flag[11000];
int l,r,q[11000];
ll d[11000];
inline void spfa(){
	memset(d,0x3f,sizeof(d)),d[1]=0;
	q[l=r=0]=1;
	while(l&lt;=r){
		u=q[l++],flag[u]=0;
		for(int i=firs[u];i;i=e[i].nx)
		    if(d[e[i].v]&gt;d[u]+e[i].w){
				d[e[i].v]=d[u]+e[i].w;
				if(!flag[e[i].v])
					flag[e[i].v]=1,q[++r]=e[i].v;
		    }
	}
}
int tmp;
inline void topu(){
	tmp=n,q[l=r=0]=n,flag[n]=1;
	while(l&lt;=r){
		u=q[l++];
		for(int i=firs[u];i;i=e[i].nx)
		    if(d[u]==d[e[i].v]+e[i].w){
				add(++tmp,u,w[u]),add(u,tmp,0);
				add(e[i].v,tmp,w[e[i].v]),add(tmp,e[i].v,0);
				if(!flag[e[i].v]) q[++r]=e[i].v,flag[e[i].v]=1;
		    }
	}memset(flag,0,sizeof(flag));
}
inline void build(){
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	memset(firs,0,sizeof(firs)),sh=0;
	memset(first,0,sizeof(first)),shu=1;
	for(int i=1;i&lt;n;++i) scanf(&quot;%lld&quot;,&amp;w[i]);
	w[n]=0x3ffffffffffLL;
	for(;m--;ad(u,v,val),ad(v,u,val))
	    scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;val);
	spfa(),topu();
}
inline bool BFS(int s,int t){
	memset(d,0,sizeof(d));
	q[l=r=0]=s,d[s]=1;
	while(l&lt;=r){
		s=q[l++];
		for(int i=first[s];i;i=o[i].nx)
		    if(o[i].w&amp;&amp;!d[o[i].v]){
				d[o[i].v]=d[s]+1;
				if(o[i].v==t) return 1;
				q[++r]=o[i].v;
		    }
	}
	return 0;
}
inline ll DFS(int x,int t,ll flow){
	if(x==t) return flow;
	ll tmp=flow,k;
	for(int i=first[x];i&amp;&amp;tmp;i=o[i].nx)
	    if(o[i].w&amp;&amp;d[o[i].v]==d[x]+1){
			k=DFS(o[i].v,t,MIN(tmp,o[i].w));
			if(!k) d[o[i].v]=0;
			tmp-=k,o[i].w-=k,o[i^1].w+=k;
	    }
	return flow-tmp;
}
int y,cnt,num,dfn[11000],low[11000],st[11000],fa[11000];
inline void dfs(int x){
	low[x]=dfn[x]=++cnt,st[++st[0]]=x;
	for(int i=first[x];i;i=o[i].nx)
	    if(o[i].w){
		    if(!dfn[o[i].v]) dfs(o[i].v),low[x]=MIN(low[x],low[o[i].v]);
		    else if(!fa[o[i].v]) low[x]=MIN(low[x],dfn[o[i].v]);
		}
	if(dfn[x]==low[x]){
		++num;
		do fa[y=st[st[0]--]]=num;
		while(x!=y);
	}
}
inline bool judge(){
	num=0,cnt=0;
	memset(dfn,0,sizeof(dfn));
	memset(fa,0,sizeof(fa));
	memset(low,0,sizeof(low));
	for(int i=1;i&lt;=tmp;++i) if(!dfn[i]) dfs(i);
	for(int i=2;i&lt;=shu;i+=2)
	    if(!o[i].w&amp;&amp;(fa[o[i].v]!=fa[o[i^1].v])){
			if(fa[1]!=fa[o[i^1].v]||fa[n]!=fa[o[i].v])
			    return 1;
	    }
	return 0;
}
inline void sol(){
    ll maxflow=0,flow;
	while(BFS(1,n)) while(flow=DFS(1,n,inf)) maxflow+=flow;
	if(judge()) printf(&quot;No %lld\n&quot;,maxflow);
	else printf(&quot;Yes %lld\n&quot;,maxflow);
}
int main(){
	int T;for(scanf(&quot;%d&quot;,&amp;T);T--;sol())build();
	//while(1);
}
/*
1
7 15
6 5 7 6 9 6
7 2 12
7 3 11
4 3 7
3 5 19
4 1 1
4 5 3
2 6 8
5 1 20
5 3 6
5 2 16
5 7 9
5 6 24
1 3 6
4 5 3
4 3 7
*/
<pre><h2>Problem3261</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
using namespace std;
int son[38000001][2],size[38000001],a[3611111],root[3611111];
int n,m,TTT,ans;
void ins(int &amp;v,int u,int x,int deep)
{
	if (!v) v=++TTT;
	size[v]=size[u]+1;
	if (deep==0) return;
	int tmp=(x&gt;&gt;(deep-1))&amp;1;
	son[v][tmp^1]=son[u][tmp^1];
	ins(son[v][tmp],son[u][tmp],x,deep-1);
}
void find(int v,int u,int x,int deep)
{
	//printf(&quot;---------------find(%d,%d,%d,%d)--------------\n&quot;,v,u,x,deep);
	if (deep==0) return;
	int tt=(x&gt;&gt;(deep-1))&amp;1;
	//printf(&quot;tt=%d\n&quot;,tt);
	if (tt==0)
	{
		int tmp=size[son[v][1]]-size[son[u][1]];
		//printf(&quot;tmp=%d\n&quot;,tmp);
		if (tmp&gt;0)
		{
			ans+=(1&lt;&lt;(deep-1));
			//printf(&quot;ans=%d\n&quot;,ans);
			find(son[v][1],son[u][1],x,deep-1);
		}
		else find(son[v][0],son[u][0],x,deep-1);
	}
	else
	{
		int tmp=size[son[v][0]]-size[son[u][0]];
		if (tmp&gt;0)
		{
			ans+=(1&lt;&lt;(deep-1));
			find(son[v][0],son[u][0],x,deep-1);
		}
		else find(son[v][1],son[u][1],x,deep-1);
	}
}
int main()
{
	//freopen(&quot;3261.in&quot;,&quot;r&quot;,stdin);freopen(&quot;3261.out&quot;,&quot;w&quot;,stdout);
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,l,r;
	//ins(root[0],root[0],0,24);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		a[i]^=a[i-1];
		ins(root[i],root[i-1],a[i],24);
	}
	for (i=1;i&lt;=m;i++)
	{
		//printf(&quot;\n-------------------------------------\n&quot;);
		char ch=getchar();
		while (ch!='A'&amp;&amp;ch!='Q') ch=getchar();
		//printf(&quot;%c\n&quot;,ch);
		if (ch=='A')
		{
			scanf(&quot;%d&quot;,&amp;x);
			n++;
			a[n]=x^a[n-1];
			ins(root[n],root[n-1],a[n],24);
		}
		else
		{
			scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;x);
			x^=a[n];
			if (r==1) {printf(&quot;%d\n&quot;,x);continue;}
			ans=0;
			//printf(&quot;x=%d\n&quot;,x);
			find(root[r-1],root[max(l-2,0)],x,24);
			printf(&quot;%d\n&quot;,ans);
		}
		//for (int j=1;j&lt;=n;j++) printf(&quot;%d &quot;,a[j]);printf(&quot;\n&quot;);
	}
	return 0;
}
<pre><h2>Problem3261</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
using namespace std;
int son[18000001][2],size[18000001],a[611111],root[611111];
int n,m,TTT,ans;
void ins(int &amp;v,int u,int x,int deep)
{
	if (!v) v=++TTT;
	size[v]=size[u]+1;
	if (deep==0) return;
	int tmp=(x&gt;&gt;(deep-1))&amp;1;
	son[v][tmp^1]=son[u][tmp^1];
	ins(son[v][tmp],son[u][tmp],x,deep-1);
}
void find(int v,int u,int x,int deep)
{
	//printf(&quot;---------------find(%d,%d,%d,%d)--------------\n&quot;,v,u,x,deep);
	if (deep==0) return;
	int tt=(x&gt;&gt;(deep-1))&amp;1;
	//printf(&quot;tt=%d\n&quot;,tt);
	if (tt==0)
	{
		int tmp=size[son[v][1]]-size[son[u][1]];
		//printf(&quot;tmp=%d\n&quot;,tmp);
		if (tmp&gt;0)
		{
			ans+=(1&lt;&lt;(deep-1));
			//printf(&quot;ans=%d\n&quot;,ans);
			find(son[v][1],son[u][1],x,deep-1);
		}
		else find(son[v][0],son[u][0],x,deep-1);
	}
	else
	{
		int tmp=size[son[v][0]]-size[son[u][0]];
		if (tmp&gt;0)
		{
			ans+=(1&lt;&lt;(deep-1));
			find(son[v][0],son[u][0],x,deep-1);
		}
		else find(son[v][1],son[u][1],x,deep-1);
	}
}
int main()
{
	//freopen(&quot;3261.in&quot;,&quot;r&quot;,stdin);freopen(&quot;3261.out&quot;,&quot;w&quot;,stdout);
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,l,r;
	//ins(root[0],root[0],0,24);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		a[i]^=a[i-1];
		ins(root[i],root[i-1],a[i],24);
	}
	for (i=1;i&lt;=m;i++)
	{
		//printf(&quot;\n-------------------------------------\n&quot;);
		char ch=getchar();
		while (ch!='A'&amp;&amp;ch!='Q') ch=getchar();
		//printf(&quot;%c\n&quot;,ch);
		if (ch=='A')
		{
			scanf(&quot;%d&quot;,&amp;x);
			n++;
			a[n]=x^a[n-1];
			ins(root[n],root[n-1],a[n],24);
		}
		else
		{
			scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;x);
			x^=a[n];
			if (r==1) {printf(&quot;%d\n&quot;,x);continue;}
			ans=0;
			//printf(&quot;x=%d\n&quot;,x);
			find(root[r-1],root[max(l-2,0)],x,24);
			printf(&quot;%d\n&quot;,ans);
		}
		//for (int j=1;j&lt;=n;j++) printf(&quot;%d &quot;,a[j]);printf(&quot;\n&quot;);
	}
	return 0;
}
<pre><h2>Problem3261</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#define ll long long 
#define N 600005
#define inf 2000000000
using namespace std;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int bin[30];
int n,m;
int a[N],b[N],root[N];
struct trie{
	int cnt;
	int ch[N*24][2],sum[N*24];
	int insert(int x,int val){
		int tmp,y;tmp=y=++cnt;
		for(int i=23;i&gt;=0;i--)
		{
			ch[y][0]=ch[x][0];ch[y][1]=ch[x][1];
			sum[y]=sum[x]+1;
			int t=val&amp;bin[i];t&gt;&gt;=i;
			x=ch[x][t];
			ch[y][t]=++cnt;
			y=ch[y][t];
		}
		sum[y]=sum[x]+1;
		return tmp;
	}
	int query(int l,int r,int val){
		int tmp=0;
		for(int i=23;i&gt;=0;i--)
		{
			int t=val&amp;bin[i];t&gt;&gt;=i;
			if(sum[ch[r][t^1]]-sum[ch[l][t^1]])
				tmp+=bin[i],r=ch[r][t^1],l=ch[l][t^1];
			else r=ch[r][t],l=ch[l][t];
		}
		return tmp;
	}
}trie;
int main()
{
	bin[0]=1;for(int i=1;i&lt;30;i++)bin[i]=bin[i-1]&lt;&lt;1;
	n=read();m=read();
	n++;
	for(int i=2;i&lt;=n;i++)a[i]=read();
	for(int i=1;i&lt;=n;i++)b[i]=b[i-1]^a[i];
	for(int i=1;i&lt;=n;i++)
		root[i]=trie.insert(root[i-1],b[i]);
	char ch[5];
	int l,r,x;
	while(m--)
	{
		scanf(&quot;%s&quot;,ch);
		if(ch[0]=='A')
		{
			n++;
			a[n]=read();b[n]=b[n-1]^a[n];
			root[n]=trie.insert(root[n-1],b[n]);
		}
		else 
		{
			l=read();r=read();x=read();
			printf(&quot;%d\n&quot;,trie.query(root[l-1],root[r],b[n]^x));
		}
	}
	return 0;
}<pre><h2>Problem3261</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define NN 600100
using namespace std;
int n,m,root[NN],bin[30],a[NN];

struct trie
{
	int cnt;
	#define pp 23
	int son[NN*pp][2],S[NN*pp];
	int ins(int y,int val)
	{
		int x,rt=x=++cnt;
		for (int i=pp;i+1;i--)
		{
			son[x][1]=son[y][1],son[x][0]=son[y][0];
			S[x]=S[y]+1;
			int t=(val&amp;bin[i])&gt;&gt;i;
			son[x][t]=++cnt;
			x=son[x][t],y=son[y][t];
		}
		S[x]=S[y]+1;
		return rt;
	}
	int find(int l,int r,int x)
	{
		int res=0;
		for (int i=pp;i+1;i--)
		{
//			printf(&quot;i=%d ; l=%d ; r=%d\n&quot;,i,l,r);
			int t=(bin[i]&amp;x)&gt;&gt;i;
			if (S[son[r][t^1]]-S[son[l][t^1]])
				res+=bin[i],r=son[r][t^1],l=son[l][t^1];
			else r=son[r][t],l=son[l][t];
		}
		return res;
	}	
}tr;
inline void read(int &amp;t)
{
	t=0;char ch=getchar();
	while(ch&lt;'0'||ch&gt;'9')ch=getchar();
	while(ch&gt;='0'&amp;&amp;ch&lt;='9')t=t*10+ch-'0',ch=getchar();
}

int main()
{
	
	read(n);read(m);
	bin[0]=1;
	for (int i=1;i&lt;=29;i++)
		bin[i]=bin[i-1]&lt;&lt;1;
	root[1]=tr.ins(0,0);
	n++;
	for (int i=2;i&lt;=n;i++)
		read(a[i]),a[i]^=a[i-1],root[i]=tr.ins(root[i-1],a[i]);	
	for (int i=1;i&lt;=m;i++)
	{
		int x,y,t;
		char ch[10];
		scanf(&quot;%s&quot;,ch);
		if (ch[0]=='A')
			read(a[++n]),a[n]^=a[n-1],root[n]=tr.ins(root[n-1],a[n]);
		else
		{
			read(x),read(y),read(t);
			int ans=tr.find(root[x-1],root[y],a[n]^t);
			printf(&quot;%d\n&quot;,ans);
		}
	}
	return 0;
}
<pre><h2>Problem3261</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define NN 600100
using namespace std;
int n,m,root[NN],bin[30],a[NN];

struct trie
{
	int cnt;
	static const int pp=23;
	int son[NN*20][2],S[NN*20];
	int ins(int y,int val)
	{
		int x,rt=x=++cnt;
		for (int i=pp;i+1;i--)
		{
			son[x][1]=son[y][1],son[x][0]=son[y][0];
			S[x]=S[y]+1;
			int t=(val&amp;bin[i])&gt;&gt;i;
			son[x][t]=++cnt;
			x=son[x][t],y=son[y][t];
		}
		S[x]=S[y]+1;
		return rt;
	}
	int find(int l,int r,int x)
	{
		int res=0;
		for (int i=pp;i+1;i--)
		{
//			printf(&quot;i=%d ; l=%d ; r=%d\n&quot;,i,l,r);
			int t=(bin[i]&amp;x)&gt;&gt;i;
			if (S[son[r][t^1]]-S[son[l][t^1]])
				res+=bin[i],r=son[r][t^1],l=son[l][t^1];
			else r=son[r][t],l=son[l][t];
		}
		return res;
	}	
}tr;
inline void read(int &amp;t)
{
	t=0;char ch=getchar();
	while(ch&lt;'0'||ch&gt;'9')ch=getchar();
	while(ch&gt;='0'&amp;&amp;ch&lt;='9')t=t*10+ch-'0',ch=getchar();
}

int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	read(n);read(m);
	bin[0]=1;
	for (int i=1;i&lt;=29;i++)
		bin[i]=bin[i-1]&lt;&lt;1;
	root[1]=tr.ins(0,0);
	n++;
	for (int i=2;i&lt;=n;i++)
		read(a[i]),a[i]^=a[i-1],root[i]=tr.ins(root[i-1],a[i]);	
	for (int i=1;i&lt;=m;i++)
	{
		int x,y,t;
		char ch[10];
		scanf(&quot;%s&quot;,ch);
		if (ch[0]=='A')
			read(a[++n]),a[n]^=a[n-1],root[n]=tr.ins(root[n-1],a[n]);
		else
		{
			read(x),read(y),read(t);
			int ans=tr.find(root[x-1],root[y],a[n]^t);
			printf(&quot;%d\n&quot;,ans);
		}
	}
	return 0;
}
<pre><h2>Problem3262</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=1000111;
int id[NN],id2[NN],f[NN],num[NN],c[NN&lt;&lt;1],ans[NN];
int n,K,n2;
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);ln;}
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar());
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
}
struct hua
{
	int x,y,z;
	inline void in() {read(x),read(y),read(z);}
	friend bool operator &lt;(const hua &amp;a,const hua &amp;b)
	{
		if (a.x!=b.x) return a.x&lt;b.x;
		if (a.y!=b.y) return a.y&lt;b.y;
		return a.z&lt;b.z;
	}
} q[NN];
inline void change(int i,int x)
{
	//printf(&quot;change %d %d\n&quot;,i,x);
	for (;i&lt;=K;i+=i&amp;-i) c[i]+=x;
}
inline int getsum(int i)
{
	int res=0;
	for (;i;i-=i&amp;-i) res+=c[i];
	return res;
}
inline void clear(int i)
{
	for (;i&lt;=K;i+=i&amp;-i) c[i]=0;
}
void cdq(int l,int r)
{
	if (l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	cdq(l,mid),cdq(mid+1,r);
	//printf(&quot;\n------------------- l=%d r=%d mid=%d -----------------\n&quot;,l,r,mid);printf(&quot;id &quot;);out(id,l,r);
	for (i=mid+1,j=l;i&lt;=r;i++)
	{
		int t=id[i];
		for (int w=id[j];j&lt;=mid&amp;&amp;q[w].y&lt;=q[t].y;w=id[++j])
			change(q[w].z,num[w]);
		f[t]+=getsum(q[t].z);
	}
	for (j=l;j&lt;=mid;j++) clear(q[id[j]].z);
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if ((i&lt;=mid&amp;&amp;q[id[i]].y&lt;=q[id[j]].y)||j&gt;r) id2[k]=id[i++];
		else id2[k]=id[j++];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
	//printf(&quot;f &quot;);out(f,1,n);ln;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(K);
	int i;
	for (i=1;i&lt;=n;i++) q[i].in();
	sort(q+1,q+n+1);
	int t=1;
	num[1]=1;
	for (i=2;i&lt;=n;i++)
		if (q[i].x==q[t].x&amp;&amp;q[i].y==q[t].y&amp;&amp;q[i].z==q[t].z) num[t]++;
		else q[++t]=q[i],num[t]=1;
	n2=t;
	//printf(&quot;q:\n&quot;);for(i=1;i&lt;=n2;i++) printf(&quot;%d %d %d\n&quot;,q[i].x,q[i].y,q[i].z);ln;
	for (i=1;i&lt;=n2;i++) id[i]=i;
	cdq(1,n2);
	for (i=1;i&lt;=n2;i++)
	{
		int tmp=f[i]+num[i]-1;
		ans[tmp]+=num[i];
	}
	for (i=0;i&lt;=n-1;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem3262</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int NN=1000005;
int id[NN],id2[NN],f[NN],num[NN],c[NN&lt;&lt;1],ans[NN];
int n,K,n2;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar());
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
}
struct hua
{
	int x,y,z;
	inline void in() {read(x),read(y),read(z);}
	friend bool operator &lt;(const hua &amp;a,const hua &amp;b)
	{
		if (a.x!=b.x) return a.x&lt;b.x;
		if (a.y!=b.y) return a.y&lt;b.y;
		return a.z&lt;b.z;
	}
} q[NN];
inline void change(int i,int x)
{
	for (;i&lt;=K;i+=i&amp;-i) c[i]+=x;
}
inline int getsum(int i)
{
	int res=0;
	for (;i;i-=i&amp;-i) res+=c[i];
	return res;
}
inline void clear(int i)
{
	for (;i&lt;=K;i+=i&amp;-i) c[i]=0;
}
void cdq(int l,int r)
{
	if (l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	cdq(l,mid),cdq(mid+1,r);
	for (i=mid+1,j=l;i&lt;=r;i++)
	{
		int t=id[i];
		for (int w=id[j];j&lt;=mid&amp;&amp;q[w].y&lt;=q[t].y;w=id[++j])
			change(q[w].z,num[w]);
		f[t]+=getsum(q[t].z);
	}
	for (j=l;j&lt;=mid;j++) clear(q[id[j]].z);
	for (i=l,j=mid+1,k=l;k&lt;=r;k++)
		if ((i&lt;=mid&amp;&amp;q[id[i]].y&lt;=q[id[j]].y)||j&gt;r) id2[k]=id[i++];
		else id2[k]=id[j++];
	for (k=l;k&lt;=r;k++) id[k]=id2[k];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(K);
	int i;
	for (i=1;i&lt;=n;i++) q[i].in();
	sort(q+1,q+n+1);
	int t=1;
	num[1]=1;
	for (i=2;i&lt;=n;i++)
		if (q[i].x==q[t].x&amp;&amp;q[i].y==q[t].y&amp;&amp;q[i].z==q[t].z) num[t]++;
		else q[++t]=q[i],num[t]=1;
	n2=t;
	for (i=1;i&lt;=n2;i++) id[i]=i;
	cdq(1,n2);
	for (i=1;i&lt;=n2;i++)
	{
		int tmp=f[i]+num[i]-1;
		ans[tmp]+=num[i];
	}
	for (i=0;i&lt;=n-1;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem3265</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;

#define eps 1e-8
#define INF 1e18
#define maxm 10010
#define maxn 1010

using namespace std;

int n,m;

namespace Lp{
	double A[maxm][maxn],c[maxn],b[maxm],v;
	void pivot(int l,int e){
		b[l]/=A[l][e];
		for(int i=1;i&lt;=n;i++) if(i!=e) A[l][i]/=A[l][e];
		A[l][e]=1/A[l][e];
		for(int i=1;i&lt;=m;i++){
			if(i!=l&amp;&amp;fabs(A[i][e])&gt;eps){
				b[i]-=A[i][e]*b[l];
				for(int j=1;j&lt;=n;j++)
					if(j!=e) A[i][j]-=A[i][e]*A[l][j];
				A[i][e]=-A[i][e]*A[l][e];
			}
		}
		v+=c[e]*b[l];
		for(int i=1;i&lt;=n;i++) if(i!=e) c[i]-=A[l][i]*c[e];
		c[e]=-A[l][e]*c[e];
	}
	double Simplex(){
		int i,l,e;
		while(1){
			for(i=1;i&lt;=n;i++) if(c[i]&gt;eps) break;
			if((e=i)==n+1) return v;
			double tmp=INF;
			for(i=1;i&lt;=m;i++){
				if(A[i][e]&gt;eps&amp;&amp;b[i]/A[i][e]&lt;tmp)
					tmp=b[i]/A[i][e],l=i;
			}
			if(tmp==INF) return INF;
			pivot(l,e);
		}
	}
}

int main()
{
	using namespace Lp;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++) scanf(&quot;%lf&quot;,&amp;c[i]);
	for(int i=1;i&lt;=m;i++){
		int k,x,y;
		scanf(&quot;%d&quot;,&amp;k);
		for(int j=1;j&lt;=k;j++){
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			for(int t=x;t&lt;=y;t++) A[i][t]=1;
		}
		scanf(&quot;%lf&quot;,&amp;b[i]);
	}
	double ans=Simplex();
	printf(&quot;%d&quot;,(int)(ans+0.5));
}
<pre><h2>Problem3265</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;

#define eps 1e-8
#define INF 1e18
#define maxm 10010
#define maxn 1010

using namespace std;

int n,m;

namespace Lp{
	double A[maxm][maxn],c[maxn],b[maxm],v;
	void pivot(int l,int e){
		b[l]/=A[l][e];
		for(int i=1;i&lt;=n;i++) if(i!=e) A[l][i]/=A[l][e];
		A[l][e]=1/A[l][e];
		for(int i=1;i&lt;=m;i++){
			if(i!=l){
				b[i]-=A[i][e]*b[l];
				for(int j=1;j&lt;=n;j++)
					if(j!=e) A[i][j]-=A[i][e]*A[l][j];
				A[i][e]=-A[i][e]*A[l][e];
			}
		}
		v+=c[e]*b[l];
		for(int i=1;i&lt;=n;i++) if(i!=e) c[i]-=A[l][i]*c[e];
		c[e]=-A[l][e]*c[e];
	}
	double Simplex(){
		int i,l,e;
		while(1){
			for(i=1;i&lt;=n;i++) if(c[i]&gt;eps) break;
			if((e=i)==n+1) return v;
			double tmp=INF;
			for(i=1;i&lt;=m;i++){
				if(A[i][e]&gt;eps&amp;&amp;b[i]/A[i][e]&lt;tmp)
					tmp=b[i]/A[i][e],l=i;
			}
			if(tmp==INF) return INF;
			pivot(l,e);
		}
	}
}

int main()
{
	using namespace Lp;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++) scanf(&quot;%lf&quot;,&amp;c[i]);
	for(int i=1;i&lt;=m;i++){
		int k,x,y;
		scanf(&quot;%d&quot;,&amp;k);
		for(int j=1;j&lt;=k;j++){
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			for(int t=x;t&lt;=y;t++) A[i][t]=1;
		}
		scanf(&quot;%lf&quot;,&amp;b[i]);
	}
	double ans=Simplex();
	printf(&quot;%d&quot;,(int)(ans+0.5));
}
<pre><h2>Problem3265</h2><pre>
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#define eps 1e-7
#define INF 1e9

using namespace std;

int n, m;
double v, A[10010][1010], b[10010], c[1010];

inline void Pivot(int l, int e) {
	b[l] /= A[l][e];
	for(int i = 1 ; i &lt;= n ; ++ i) if(i!=e) A[l][i] /= A[l][e];
	A[l][e] = 1./A[l][e];
	for(int i = 1 ; i &lt;= m ; ++ i) if(i!=l&amp;&amp;fabs(A[i][e])&gt;eps) {
		b[i] -= A[i][e]*b[l];
		for(int j = 1 ; j &lt;= n ; ++ j) {
			if(j!=e) A[i][j] -= A[i][e]*A[l][j];
		}
		A[i][e] = -A[l][e]*A[i][e];
	}
	v += b[l]*c[e];
	for(int i = 1 ; i &lt;= n ; ++ i) if(i!=e) c[i] -= c[e]*A[l][i];
	c[e] = -c[e]*A[l][e];
	return;
}

inline double Solve() {
	int i, j, k, e, l;
	while(true) {
		for(i = 1 ; i &lt;= n ; ++ i) if(c[i]&gt;eps) break;
		e = i;
		if(e==n+1) return v;
		double tmp = INF;
		for(i = 1 ; i &lt;= m ; ++ i) {
			if(A[i][e]&gt;eps&amp;&amp;(b[i]/A[i][e])&lt;tmp) {
				l = i, tmp = b[i]/A[i][e];
			}
		}
		if(tmp==INF) return INF;
		Pivot(l, e);
	}
}

int main() {
	int l, r, x;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1 ; i &lt;= n ; ++ i) scanf(&quot;%lf&quot;, &amp;c[i]); // 对偶转换
	for(int i = 1 ; i &lt;= m ; ++ i) {
		scanf(&quot;%d&quot;, &amp;x);
		for(int k = 1 ; k &lt;= x ; ++ k) {
			scanf(&quot;%d%d&quot;, &amp;l, &amp;r);
			for(int j = l ; j &lt;= r ; ++ j) A[i][j] = 1;
		}
		scanf(&quot;%lf&quot;, &amp;b[i]);
	}
	printf(&quot;%d&quot;, (int)ceil(Solve()));
	//while(1);
	return 0;
}
<pre><h2>Problem3270</h2><pre>#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;cmath&gt;
#include&lt;ctime&gt;
#include&lt;queue&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define rad 100000000
#define inf 1000000000
#define ll long long 
#define eps 1e-10
#define pa pair&lt;ll,int&gt;
#define p(x,y) (x-1)*n+y
using namespace std;
int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int n,m,A,B,cnt,tot;
int last[25],d[25];
double a[405][405],p[25];
vector&lt;int&gt; e[25];
void build(int x,int y)
{
	a[p(x,y)][p(x,y)]--;
    for(unsigned int i=0;i&lt;e[x].size();i++)
        for(unsigned int j=0;j&lt;e[y].size();j++)
        {
            int tx=e[x][i],ty=e[y][j];
			int t1=p(x,y),t2=p(tx,ty);
            if(tx!=ty)
            {
                if(tx==x&amp;&amp;ty==y)a[t1][t2]+=p[tx]*p[ty];
                else if(tx==x)a[t1][t2]+=p[tx]*(1-p[ty])/d[ty];
                else if(ty==y)a[t1][t2]+=p[ty]*(1-p[tx])/d[tx];
                else a[t1][t2]+=(1-p[tx])*(1-p[ty])/d[tx]/d[ty];
            }
        }
}
void gauss()
{
    int now=1;
    for(int i=1;i&lt;=tot;i++)
    {
        int j;
        for(j=now;!a[j][now]&amp;&amp;j&lt;=tot;j++);
        for(int k=1;k&lt;=tot+1;k++)swap(a[now][k],a[j][k]);
        for(int j=1;j&lt;=tot;j++)
            if(j!=now)
            {
                double t=a[j][now]/a[now][now];
                for(int k=1;k&lt;=tot+1;k++)
                    a[j][k]-=t*a[now][k];
            }
        now++;
    }
}
int main()
{
    n=read();m=read();A=read();B=read();
    tot=n*n;
    for(int i=1;i&lt;=n;i++)e[i].push_back(i);
    for(int i=1;i&lt;=m;i++)
    {
        int u=read(),v=read();
        d[u]++;d[v]++;
        e[u].push_back(v);
        e[v].push_back(u);
    }
    for(int i=1;i&lt;=n;i++)scanf(&quot;%lf&quot;,&amp;p[i]);
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=n;j++)
            build(i,j);
    a[p(A,B)][tot+1]=-1;
    gauss();    
    for(int i=1;i&lt;=n;i++)
    {
		int t=p(i,i);
        printf(&quot;%.6lf&quot;,a[t][tot+1]/a[t][t]);
        if(i!=n)printf(&quot; &quot;);
    }
    return 0;
}<pre><h2>Problem3272</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
int n,m,op,l,r,k,a[100005];
vector&lt;pair&lt;int,int&gt; &gt;Q;
struct data{
	int lx,rx,mx,sum,lp,rp,p1,p2;
	void init(int l,int val){lp=rp=p1=p2=l,lx=rx=mx=sum=val;}
	friend data operator + (data a,data b){
		data c;
		c.sum=a.sum+b.sum;
		c.lx=a.lx,c.lp=a.lp;
		if(a.sum+b.lx&gt;c.lx)c.lx=a.sum+b.lx,c.lp=b.lp;
		c.rx=b.rx,c.rp=b.rp;
		if(b.sum+a.rx&gt;c.rx)c.rx=b.sum+a.rx,c.rp=a.rp;
		c.mx=a.rx+b.lx,c.p1=a.rp,c.p2=b.lp;
		if(c.mx&lt;a.mx)c.mx=a.mx,c.p1=a.p1,c.p2=a.p2;
		if(c.mx&lt;b.mx)c.mx=b.mx,c.p1=b.p1,c.p2=b.p2;
		return c;
	}
};
struct Seg{
	int l,r,a,b;
	bool flag;
	data mn,mx;
	void init(int val){
		mn.init(l,-val);
		mx.init(l,val);
	}
}t[400005];
void pushdown(int k){
	if(t[k].l==t[k].r)return;
	if(t[k].flag){
		swap(t[k&lt;&lt;1].mn,t[k&lt;&lt;1].mx);
		swap(t[k&lt;&lt;1|1].mn,t[k&lt;&lt;1|1].mx);
		t[k&lt;&lt;1].flag^=1,t[k&lt;&lt;1|1].flag^=1,t[k].flag^=1;
	}
}
void update(int k){
	t[k].mn=t[k&lt;&lt;1].mn+t[k&lt;&lt;1|1].mn;
	t[k].mx=t[k&lt;&lt;1].mx+t[k&lt;&lt;1|1].mx;
}
void build(int l,int r,int k){
	t[k].l=l,t[k].r=r;
	if(l==r){
		t[k].init(a[l]);
		return;
	}
	int mid=l+r&gt;&gt;1;
	build(l,mid,k&lt;&lt;1);
	build(mid+1,r,k&lt;&lt;1|1);
	update(k);
}
void rever(int x,int y,int k){
	pushdown(k);
	int l=t[k].l,r=t[k].r,mid=l+r&gt;&gt;1;
	if(l==x&amp;&amp;y==r){
		swap(t[k].mn,t[k].mx);
		t[k].flag^=1;
		return;
	}
	if(y&lt;=mid)rever(x,y,k&lt;&lt;1);
	else if(x&gt;mid)rever(x,y,k&lt;&lt;1|1);
	else rever(x,mid,k&lt;&lt;1),rever(mid+1,y,k&lt;&lt;1|1);
	update(k);
}
data Query(int x,int y,int k){
	pushdown(k);
	int l=t[k].l,r=t[k].r,mid=l+r&gt;&gt;1;
	if(l==x&amp;&amp;y==r)return t[k].mx;
	if(y&lt;=mid)return Query(x,y,k&lt;&lt;1);
	if(x&gt;mid)return Query(x,y,k&lt;&lt;1|1);
	return Query(x,mid,k&lt;&lt;1)+Query(mid+1,y,k&lt;&lt;1|1);
}
void Solve(int l,int r,int k){
	int ans=0;
	Q.clear();
	while(k--){
		data t=Query(l,r,1);
		if(t.mx&gt;0)ans+=t.mx;
		else break;
		rever(t.p1,t.p2,1);
		Q.push_back(make_pair(t.p1,t.p2));
	}
	for(int i=Q.size()-1;~i;i--){
		rever(Q[i].first,Q[i].second,1);
	}
	printf(&quot;%d\n&quot;,ans);
}
void change(int pos,int val,int k){
	pushdown(k);
	int l=t[k].l,r=t[k].r,mid=l+r&gt;&gt;1;
	if(l==r){
		t[k].init(val);
		return;
	}
	if(pos&lt;=mid)change(pos,val,k&lt;&lt;1);
	else change(pos,val,k&lt;&lt;1|1);
	update(k);
}
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]);
	build(1,n,1);
	scanf(&quot;%d&quot;,&amp;m);
	while(m--){
		scanf(&quot;%d%d%d&quot;,&amp;op,&amp;l,&amp;r);
		if(op-1)change(l,r,1);
		else scanf(&quot;%d&quot;,&amp;k),Solve(l,r,k);
	}
}
<pre><h2>Problem3282</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=301111;
int son[NN][2],fa[NN],size[NN],key[NN],sum[NN];
int n,m;
bool rrr[NN],tag[NN];
void debug(int t){if(!t)return;debug(son[t][0]);printf(&quot;%d &quot;,t);debug(son[t][1]);}
void rev(int x)
{
	tag[x]=!tag[x];
	swap(son[x][0],son[x][1]);
}
void pushdown(int t)
{
	if (!tag[t]) return;
	rev(son[t][0]),rev(son[t][1]);
	tag[t]=false;
}
void update(int t)
{
	int x=son[t][0],y=son[t][1];
	size[t]=size[x]+size[y]+1;
	sum[t]=sum[x]^key[t]^sum[y];
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[t]=true,rrr[y]=false;
	else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
	else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
}
void access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
}
void makeroot(int x)
{
	access(x);
	splay(x);
	rev(x);
}
void link(int x,int y)
{
	makeroot(x);
	splay(x);
	fa[x]=y;
}
int getroot(int x)
{
	access(x);
	splay(x);
	while (son[x][0]) x=son[x][0];
	return x;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;key[i]);
		sum[i]=key[i];
		rrr[i]=true;
		size[i]=1;
	}
	for (i=1;i&lt;=m;i++)
	{
		//printf(&quot;\n-----------------------------------------------------------------------\n&quot;);
		scanf(&quot;%d&quot;,&amp;x);
		if (x==0)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			makeroot(x);
			access(y);
			splay(y);
			printf(&quot;%d\n&quot;,sum[y]);
		}
		else if (x==1)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			if (getroot(x)!=getroot(y)) link(x,y);
		}
		else if (x==2)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			makeroot(x);
			access(y);
			splay(y);
			if (size[y]!=2||son[y][0]!=x||fa[x]!=y) continue;
			rrr[x]=true;
			fa[x]=son[y][0]=0;
		}
		else
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			key[x]=y;
			splay(x);
		}
	}
	return 0;
}<pre><h2>Problem3283</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
typedef pair&lt;LL,int&gt; pli;
#define fi first
#define se second
#define ln printf(&quot;\n&quot;)
LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (a%=c;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
LL gcd(LL a,LL b) {return !b?a:gcd(b,a%b);}
LL getphi(LL n)
{
	LL tmp=n;
	for (int i=2;i*i&lt;=n;i++)
		if (n%i==0)
		{
			tmp=tmp/i*(i-1);
			while (n%i==0) n/=i;
		}
	if (n&gt;1) tmp*=n-1;
	return tmp;
}
struct HT
{
	int mod,TIME,tot,o[1000007],vt[1000007],aa0[1000000];
	LL aa1[1000000],aa2[1000000];
	HT() {mod=1000007;}
	void clear() {TIME++;tot=0;}
	void insert(LL x,LL y)
	{
		int t=x%mod;
		if (vt[t]!=TIME)
			vt[t]=TIME,o[t]=0;
		for (int p=o[t];p;p=aa0[p])
			if (x==aa1[p])
			{
				aa2[p]=min(aa2[p],y);
				return;
			}
		tot++;aa1[tot]=x;aa2[tot]=y;
		aa0[tot]=o[t];o[t]=tot;
	}
	int find(LL x)
	{
		int t=x%mod;
		if (vt[t]!=TIME)
			vt[t]=TIME,o[t]=0;
		for (int p=o[t];p;p=aa0[p])
			if (x==aa1[p]) return aa2[p];
		return -1;
	}
} ht;
LL bsgs(LL A,LL B,LL P,LL phi)
{
	//printf(&quot;bsgs %lld %lld %lld\n&quot;,A,B,P);
	ht.clear();
	LL tmp=1,blo=(LL)sqrt(P)+1;
	int i;
	for (i=0;i&lt;blo;i++)
	{
		ht.insert(tmp,i);
		tmp=tmp*A%P;
	}
	for (i=0;i&lt;blo;i++)
	{
		tmp=ksm(A,i*blo,P);
		tmp=B*ksm(tmp,phi-1,P)%P;
		//printf(&quot;tmp=%lld\n&quot;,tmp);
		if (tmp==0) return B==0?i*blo:-1;
		int t=ht.find(tmp);
		if (t!=-1) return i*blo+t;
	}
	return -1;
}
int work2(int A,int B,int P)
{
	LL tmp=1;
	for (int i=0;i&lt;=30;i++)
	{
		if (tmp==B) return i;
		tmp=tmp*A%P;
	}
	tmp=1;
	for (int i=1;i&lt;=30;i++) tmp=tmp*A%P;
	LL K=gcd(tmp,P);
	if (B%K) return -1;
	LL phi=getphi(P/K);
	//printf(&quot;tmp=%lld K=%lld\n&quot;,tmp,K);
	LL ans=bsgs(A,B/K*ksm(tmp/K,phi-1,P)%(P/K),P/K,phi);
	if (ans!=-1) return ans+30;
	return -1;
}
pli calc(int n,LL *f,int pr,int pp)
{
	LL t1=1;int t2=0;
	for (;n;n/=pr)
	{
		t2+=n/pr;
		t1=t1*ksm(f[pp],n/pp,pp)%pp;
		t1=t1*f[n%pp]%pp;
	}
	return make_pair(t1,t2);
}
int C(int n,int m,int P)
{
	static LL pr[100],pp[100],phi[100],e[100],f[101111];
	LL P2=P;
	int tot=0,i,j;
	for (i=2;i*i&lt;=P;i++) if (P2%i==0)
	{
		pr[++tot]=i;
		pp[tot]=1;
		for (;P2%i==0;P2/=i) pp[tot]*=i;
		phi[tot]=pp[tot]/i*(i-1);
		e[tot]=P/pp[tot]*ksm(P/pp[tot],phi[tot]-1,pp[tot])%P;
	}
	if (P2&gt;1)
	{
		i=P2;
		pr[++tot]=i;
		pp[tot]=1;
		for (;P2%i==0;P2/=i) pp[tot]*=i;
		phi[tot]=pp[tot]/i*(i-1);
		e[tot]=P/pp[tot]*ksm(P/pp[tot],phi[tot]-1,pp[tot])%P;
	}
	//printf(&quot;tot=%d pr[1]=%lld pp[1]=%lld phi[1]=%lld e[1]=%lld\n&quot;,tot,pr[1],pp[1],phi[1],e[1]);
	LL ans=0;
	for (i=1;i&lt;=tot;i++)
	{
		f[0]=1;
		for (j=1;j&lt;=pp[i];j++)
			if (j%pr[i]==0) f[j]=f[j-1];
			else f[j]=f[j-1]*j%pp[i];
		//printf(&quot;f &quot;);for(j=1;j&lt;=pp[i];j++)printf(&quot;%lld &quot;,f[j]);ln;
		pli nn=calc(n,f,pr[i],pp[i]);
		//printf(&quot;nn: %lld %d\n&quot;,nn.fi,nn.se);
		pli mm=calc(m,f,pr[i],pp[i]);
		//printf(&quot;mm: %lld %d\n&quot;,mm.fi,mm.se);
		pli nm=calc(n-m,f,pr[i],pp[i]);
		LL res=nn.fi*ksm(mm.fi*nm.fi,phi[i]-1,pp[i])%pp[i];
		res=res*ksm(pr[i],nn.se-mm.se-nm.se,pp[i])%pp[i];
		(ans+=res*e[i]%P)%=P;
	}
	ans%=P;
	if (ans&lt;0) ans+=P;
	return ans;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int tes,kind,y,z,P;
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;kind,&amp;y,&amp;z,&amp;P);
		if (kind==1) printf(&quot;%lld\n&quot;,ksm(y,z,P));
		else if (kind==2)
		{
			int tmp=work2(y,z,P);
			if (tmp==-1) printf(&quot;Math Error\n&quot;);
			else printf(&quot;%d\n&quot;,tmp);
		}
		else printf(&quot;%d\n&quot;,C(z,y,P));
	}
	return 0;
}<pre><h2>Problem3283</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
typedef pair&lt;LL,int&gt; pli;
#define fi first
#define se second
LL ksm(LL a,LL b,LL c)
{
    LL res=1;
    for (a%=c;b;b&gt;&gt;=1,a=a*a%c)
        if (b&amp;1) res=res*a%c;
    return res;
}
LL gcd(LL a,LL b) {return !b?a:gcd(b,a%b);}
LL getphi(LL n)
{
    LL tmp=n;
    for (int i=2;i*i&lt;=n;i++)
        if (n%i==0)
        {
            tmp=tmp/i*(i-1);
            while (n%i==0) n/=i;
        }
    if (n&gt;1) tmp*=n-1;
    return tmp;
}
struct HT
{
    int mod,TIME,tot,o[1000007],vt[1000007],aa0[1000000];
    LL aa1[1000000],aa2[1000000];
    HT() {mod=1000007;}
    void clear() {TIME++;tot=0;}
    void insert(LL x,LL y)
    {
        int t=x%mod;
        if (vt[t]!=TIME)
            vt[t]=TIME,o[t]=0;
        for (int p=o[t];p;p=aa0[p])
            if (x==aa1[p])
            {
                aa2[p]=min(aa2[p],y);
                return;
            }
        tot++;aa1[tot]=x;aa2[tot]=y;
        aa0[tot]=o[t];o[t]=tot;
    }
    int find(LL x)
    {
        int t=x%mod;
        if (vt[t]!=TIME)
            vt[t]=TIME,o[t]=0;
        for (int p=o[t];p;p=aa0[p])
            if (x==aa1[p]) return aa2[p];
        return -1;
    }
} ht;
LL bsgs(LL A,LL B,LL P,LL phi)
{
    ht.clear();
    LL tmp=1,blo=(LL)sqrt(P)+1;
    int i;
    for (i=0;i&lt;blo;i++)
    {
        ht.insert(tmp,i);
        tmp=tmp*A%P;
    }
    for (i=0;i&lt;blo;i++)
    {
        tmp=ksm(A,i*blo,P);
        tmp=B*ksm(tmp,phi-1,P)%P;
        if (tmp==0) return B==0?i*blo:-1;
        int t=ht.find(tmp);
        if (t!=-1) return i*blo+t;
    }
    return -1;
}
int work2(int A,int B,int P)
{
    LL tmp=1;
    for (int i=0;i&lt;=30;i++)
    {
        if (tmp==B) return i;
        tmp=tmp*A%P;
    }
    tmp=1;
    for (int i=1;i&lt;=30;i++) tmp=tmp*A%P;
    LL K=gcd(tmp,P);
    if (B%K) return -1;
    LL phi=getphi(P/K);
    LL ans=bsgs(A,B/K*ksm(tmp/K,phi-1,P)%(P/K),P/K,phi);
    if (ans!=-1) return ans+30;
    return -1;
}
pli calc(int n,LL *f,int pr,int pp)
{
    LL t1=1;int t2=0;
    for (;n;n/=pr)
    {
        t2+=n/pr;
        t1=t1*ksm(f[pp],n/pp,pp)%pp;
        t1=t1*f[n%pp]%pp;
    }
    return make_pair(t1,t2);
}
int C(int n,int m,int P)
{
    static LL pr[100],pp[100],phi[100],e[100],f[101111];
    LL P2=P;
    int tot=0,i,j;
    for (i=2;i*i&lt;=P;i++) if (P2%i==0)
    {
        pr[++tot]=i;
        pp[tot]=1;
        for (;P2%i==0;P2/=i) pp[tot]*=i;
        phi[tot]=pp[tot]/i*(i-1);
        e[tot]=P/pp[tot]*ksm(P/pp[tot],phi[tot]-1,pp[tot])%P;
    }
    if (P2&gt;1)
    {
        i=P2;
        pr[++tot]=i;
        pp[tot]=1;
        for (;P2%i==0;P2/=i) pp[tot]*=i;
        phi[tot]=pp[tot]/i*(i-1);
        e[tot]=P/pp[tot]*ksm(P/pp[tot],phi[tot]-1,pp[tot])%P;
    }
    LL ans=0;
    for (i=1;i&lt;=tot;i++)
    {
        f[0]=1;
        for (j=1;j&lt;=pp[i];j++)
            if (j%pr[i]==0) f[j]=f[j-1];
            else f[j]=f[j-1]*j%pp[i];
        pli nn=calc(n,f,pr[i],pp[i]);
        pli mm=calc(m,f,pr[i],pp[i]);
        pli nm=calc(n-m,f,pr[i],pp[i]);
        LL res=nn.fi*ksm(mm.fi*nm.fi,phi[i]-1,pp[i])%pp[i];
        res=res*ksm(pr[i],nn.se-mm.se-nm.se,pp[i])%pp[i];
        (ans+=res*e[i]%P)%=P;
    }
    ans%=P;
    if (ans&lt;0) ans+=P;
    return ans;
}
int main()
{
   // freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    int tes,kind,y,z,P;
    for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
    {
        scanf(&quot;%d%d%d%d&quot;,&amp;kind,&amp;y,&amp;z,&amp;P);
        if (kind==1) printf(&quot;%lld\n&quot;,ksm(y,z,P));
        else if (kind==2)
        {
            int tmp=work2(y,z,P);
            if (tmp==-1) printf(&quot;Math Error\n&quot;);
            else printf(&quot;%d\n&quot;,tmp);
        }
        else printf(&quot;%d\n&quot;,C(z,y,P));
    }
    return 0;
}<pre><h2>Problem3283</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
typedef pair&lt;LL,LL&gt; pll;
#define mp make_pair
#define fi first
#define se second
LL pr[100],pp[100],phi[100],e[100],f[101111];
inline LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (a%=c;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
LL gcd(LL a,LL b) {return !b?a:gcd(b,a%b);}
LL getphi(LL n)
{
	LL res=1;
	for (LL i=2;i*i&lt;=n;i++) if (n%i==0)
	{
		res*=i-1;
		for (n/=i;n%i==0;n/=i) res*=i;
	}
	if (n&gt;1) res*=n-1;
	return res;
}
struct HT
{
	#define mod 1000007
	int tot,TIME,o[mod],vt[mod],aa0[1000000];
	LL aa1[1000000],f[1000000];
	void clear() {tot=0;TIME++;}
	void insert(LL x,LL y)
	{
		int t=x%mod;
		if (vt[t]!=TIME) vt[t]=TIME,o[t]=0;
		for (int p=o[t];p;p=aa0[p])
			if (aa1[p]==x)
			{
				if (y&lt;f[p]) f[p]=y;
				return;
			}
		tot++;aa1[tot]=x;f[tot]=y;
		aa0[tot]=o[t];o[t]=tot;
	}
	LL find(LL x)
	{
		int t=x%mod;
		if (vt[t]!=TIME) vt[t]=TIME,o[t]=0;
		for (int p=o[t];p;p=aa0[p])
			if (aa1[p]==x) return f[p];
		return -1;
	}
} ht;
LL bsgs(LL A,LL B,LL P,LL phi)
{
	A%=P,B%=P;
	LL blo=(LL)sqrt(P)+1,tmp=1,i;
	ht.clear();
	for (i=0;i&lt;blo;i++)
	{
		ht.insert(tmp,i);
		tmp=tmp*A%P;
	}
	LL t=1;
	for (i=0;i&lt;P;i+=blo)
	{
		if (t==0)
		{
			if (B==0) return i;
			return -1;
		}
		LL res=ht.find(B*ksm(t,phi-1,P)%P);
		if (res!=-1) return res+i;
		t=t*tmp%P;
	}
	return -1;
}
LL extbsgs(LL A,LL B,LL P)
{
	A%=P,B%=P;
	LL tmp=1;
	for (int i=0;i&lt;30;i++)
	{
		if (tmp==B) return i;
		tmp=tmp*A%P;
	}
	LL t=gcd(tmp,P);
	if (B%t) return -1;
	B/=t,P/=t,tmp/=t;
	LL phi=getphi(P);
	B=B*ksm(tmp,phi-1,P)%P;
	LL res=bsgs(A,B,P,phi);
	if (res==-1) return -1;
	return res+30;
}
pll calc(LL n,int i)
{
	//printf(&quot;calc %lld %d\n&quot;,n,i);
	LL t1=1,t2=0;
	while (n)
	{
		t2=t2+n/pr[i];
		t1=t1*ksm(f[pp[i]],n/pp[i],pp[i])%pp[i];
		t1=t1*f[n%pp[i]]%pp[i];
		n/=pr[i];
	}
	return mp(t1,t2);
}
LL C(LL n,LL m,LL P)
{
	LL P2=P;
	int tot=0;
	for (int i=2;i*i&lt;=P2;i++) if (P2%i==0)
	{
		pr[++tot]=i;
		pp[tot]=1;
		for (;P2%i==0;P2/=i) pp[tot]*=i;
		phi[tot]=pp[tot]/i*(i-1);
		e[tot]=P/pp[tot]*ksm(P/pp[tot],phi[tot]-1,pp[tot])%P;
	}
	if (P2&gt;1)
	{
		LL i=P2;
		pr[++tot]=i;
		pp[tot]=1;
		for (;P2%i==0;P2/=i) pp[tot]*=i;
		phi[tot]=pp[tot]/i*(i-1);
		e[tot]=P/pp[tot]*ksm(P/pp[tot],phi[tot]-1,pp[tot])%P;
	}
	//printf(&quot;pr=%lld pp=%lld phi=%lld\n&quot;,pr[1],pp[1],phi[1]);
	LL ans=0;
	for (int i=1;i&lt;=tot;i++)
	{
		f[0]=1;
		for (int j=1;j&lt;=pp[i];j++)
			if (j%pr[i]==0) f[j]=f[j-1];
			else f[j]=f[j-1]*j%pp[i];
		//printf(&quot;f &quot;);for(int j=1;j&lt;=pp[i];j++)printf(&quot;%lld &quot;,f[j]);printf(&quot;\n&quot;);
		pll tmp=calc(n,i);
		//printf(&quot;tmp  %lld %lld\n&quot;,tmp.fi,tmp.se);
		pll t1=calc(m,i),t2=calc(n-m,i);
		//printf(&quot;t1 %lld %lld  t2 %lld %lld\n&quot;,t1.fi,t1.se,t2.fi,t2.se);
		LL res=tmp.fi*ksm(t1.fi*t2.fi,phi[i]-1,pp[i])%pp[i];
		res=res*ksm(pr[i],tmp.se-t1.se-t2.se,pp[i])%pp[i];
		ans=(ans+e[i]*res)%P;
	}
	return ans;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int tes,kind,y,z,p;
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		//printf(&quot;\n---------------------------------------------------------------------------\n&quot;);
		scanf(&quot;%d%d%d%d&quot;,&amp;kind,&amp;y,&amp;z,&amp;p);
		if (kind==1) printf(&quot;%lld\n&quot;,ksm(y,z,p));
		else if (kind==2)
		{
			LL tmp=extbsgs(y,z,p);
			if (tmp==-1) printf(&quot;Math Error\n&quot;);
			else printf(&quot;%lld\n&quot;,tmp);
		}
		else printf(&quot;%lld\n&quot;,C(z,y,p));
	}
	return 0;
}<pre><h2>Problem3289</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int NN=50111;
int a[NN],b[NN],c[NN];
int n,m;
LL ans[NN];
struct query
{
	int l,r,id;
	friend bool operator &lt;(query a,query b)
	{
		int t1=a.l/224,t2=b.l/224;
		if (t1!=t2) return t1&lt;t2;
		return a.r&lt;b.r;
	}
} q[NN];
int cha(int x)
{
	int l=1,r=n;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;if (b[mid]==x) return mid;
		if (b[mid]&gt;x) r=mid-1;else l=mid+1;
	}
	return -1;
}
void change(int i,int x)
{
	for (;i&lt;=n;i+=i&amp;-i) c[i]+=x;
}
int getsum(int i)
{
	int res=0;
	for (;i;i-=i&amp;-i) res+=c[i];
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),b[i]=a[i];
	sort(b+1,b+n+1);
	for (i=1;i&lt;=n;i++) a[i]=cha(a[i]);
	scanf(&quot;%d&quot;,&amp;m);
	for (i=1;i&lt;=m;i++) scanf(&quot;%d%d&quot;,&amp;q[i].l,&amp;q[i].r),q[i].id=i;
	sort(q+1,q+m+1);
	int l=1,r=1;
	LL now=0;
	change(a[1],1);
	for (i=1;i&lt;=m;i++)
	{
		//printf(&quot;\n------------------------------------------------------------------------\n&quot;);
		query t=q[i];
		if (t.l&lt;l)
			for (j=l-1;j&gt;=t.l;j--)
			{
				now+=getsum(a[j]-1);
				change(a[j],1);
			}
		if (t.r&gt;r)
			for (j=r+1;j&lt;=t.r;j++)
			{
				now+=getsum(n)-getsum(a[j]);
				change(a[j],1);
			}
		if (t.l&gt;l)
			for (j=l;j&lt;t.l;j++)
			{
				now-=getsum(a[j]-1);
				change(a[j],-1);
			}
		if (t.r&lt;r)
			for (j=r;j&gt;t.r;j--)
			{
				now-=getsum(n)-getsum(a[j]);
				change(a[j],-1);
			}
		ans[t.id]=now;
		l=t.l,r=t.r;
	}
	for (i=1;i&lt;=m;i++) printf(&quot;%lld\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem3295</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const int NN=201111;
int root[NN],cur[NN],vt[NN],lc[10101111],rc[10101111],size[10101111],pos[NN],a[NN];
int n,m,TIME,TTT;
struct bit
{
	int c[NN];
	void change(int i,int x)
	{
		for (;i&lt;=n;i+=i&amp;-i) c[i]+=x;
	}
	int getsum(int i)
	{
		int res=0;
		for (;i;i-=i&amp;-i) res+=c[i];
		return res;
	}
} C0;
void ins(int &amp;v,int l,int r,int x,int kind)
{
	if (!v) v=++TTT;
	size[v]+=kind;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid) ins(lc[v],l,mid,x,kind);
	else ins(rc[v],mid,r,x,kind);
}
void change(int i,int x,int kind)
{
	for (;i&lt;=n;i+=i&amp;-i) ins(root[i],1,n+1,x,kind);
}
void clear(int i)
{
	for (;i;i-=i&amp;-i) cur[i]=root[i];
}
int getsumr(int i)
{
	int res=0;
	for (;i;i-=i&amp;-i) res+=size[rc[cur[i]]];
	return res;
}
int getsuml(int i)
{
	int res=0;
	for (;i;i-=i&amp;-i) res+=size[lc[cur[i]]];
	return res;
}
void turn(int i,int k)
{
	for (;i;i-=i&amp;-i)
		if (vt[i]!=TIME)
		{
			vt[i]=TIME;
			if (k==0) cur[i]=lc[cur[i]];
			else cur[i]=rc[cur[i]];
		}
}
int da(int L,int R,int x)
{
	clear(R),clear(L-1);
	int l=1,r=n+1,res=0;
	while (r-l&gt;1)
	{
		//printf(&quot;%d %d %d\n&quot;,l,r,res);
		int mid=(l+r)&gt;&gt;1;
		TIME++;
		if (x&lt;mid)
		{
			int tmp=getsumr(R)-getsumr(L-1);
			res+=tmp;
			turn(R,0),turn(L-1,0);
			r=mid;
		}
		else
		{
			turn(R,1),turn(L-1,1);
			l=mid;
		}
	}
	return res;
}
int xiao(int L,int R,int x)
{
	clear(R),clear(L-1);
	int l=1,r=n+1,res=0;
	while (r-l&gt;1)
	{
		//printf(&quot;l=%d r=%d  &quot;,l,r);
		int mid=(l+r)&gt;&gt;1;
		TIME++;
		if (x&gt;=mid)
		{
			int tmp=getsuml(R)-getsuml(L-1);
			res+=tmp;
			turn(R,1),turn(L-1,1);
			l=mid;
		}
		else
		{
			turn(R,0),turn(L-1,0);
			r=mid;
		}
		//printf(&quot;res=%d\n&quot;,res);
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x;
	LL now=0;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]),pos[a[i]]=i;
		change(i,a[i],1);
		now+=C0.getsum(n)-C0.getsum(a[i]);
		C0.change(a[i],1);
	}
	//clear(n);printf(&quot;%d\n&quot;,getsuml(n));clear(4);printf(&quot;%d\n&quot;,getsuml(4));
	for (i=1;i&lt;=m;i++)
	{
		//printf(&quot;\n------------------------------------------------------------------------------\n&quot;);
		printf(&quot;%lld\n&quot;,now);
		scanf(&quot;%d&quot;,&amp;x);
		if (pos[x]&gt;1) now-=da(1,pos[x]-1,x);
		if (pos[x]&lt;n) now-=xiao(pos[x]+1,n,x);
		change(pos[x],x,-1);
	}
	return 0;
}<pre><h2>Problem3307</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
#define pb push_back
#define inf 1000000005
#define ln printf(&quot;\n&quot;)
const int NN=101111,AA=2000000;
int deep[NN],up[NN],size[NN],o[NN],aa[NN&lt;&lt;1][2],fa[NN],hea[NN];
int tmax[AA],from[AA],lc[AA],rc[AA],vt[AA],pos[NN],ans[NN];
int n,m,tot,TTT,TIME,root;
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);ln;}
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
struct Lian
{
	vector&lt;int&gt; b;
	vector&lt;vector&lt;int&gt; &gt; c;
	int num,id;
	void out()
	{
		printf(&quot;\nnum=%d\n&quot;,num);
		printf(&quot;b: &quot;);for (int i=1;i&lt;=num;i++) printf(&quot;%d &quot;,b[i]);ln;
	}
	Lian() {num=0;b.clear();c.clear();b.pb(0);}
	void push(int v)
	{
		b.pb(v);
		pos[v]=b.size()-1;
	}
	void init(int i)
	{
		id=i;
		num=b.size()-1;
		b.pb(0);
		c.resize(num+5);
	}
	void change(int l,int r,int val)
	{
		//printf(&quot;lian[%d]. change %d %d %d\n&quot;,id,l,r,val);
		l=pos[l],r=pos[r];
		c[l].pb(val),c[r+1].pb(-val);
	}
	void change(int &amp;v,int l,int r,int x,int kind)
	{
		if (v==0) v=++TTT;
		if (vt[v]!=TIME)
		{
			vt[v]=TIME,tmax[v]=from[v]=0;
			lc[v]=rc[v]=0;
		}
		if (r-l==1)
		{
			from[v]=l;
			if (kind==1) tmax[v]++;
			else tmax[v]--;
			//printf(&quot;change %d %d %d %d    tmax=%d from=%d\n&quot;,v,l,r,x,tmax[v],from[v]);
			return;
		}
		int mid=(l+r)&gt;&gt;1;
		if (x&lt;mid) change(lc[v],l,mid,x,kind);
		else change(rc[v],mid,r,x,kind);
		if (tmax[lc[v]]&gt;=tmax[rc[v]])
			tmax[v]=tmax[lc[v]],from[v]=from[lc[v]];
		else
			tmax[v]=tmax[rc[v]],from[v]=from[rc[v]];
		//printf(&quot;change %d %d %d %d    tmax=%d from=%d\n&quot;,v,l,r,x,tmax[v],from[v]);
	}
	void work()
	{
		//printf(&quot;\n--------------------- lian[%d].work() -----------------------------------\n&quot;,id);
		TIME++;TTT=0;root=0;
		for (int i=1;i&lt;=num;i++)
		{
			//printf(&quot;================= i=%d =================\n&quot;,i);
			for (int j=0;j&lt;(int)c[i].size();j++)
			{
				//printf(&quot;%d\n&quot;,c[i][j]);
				if (c[i][j]&gt;0) change(root,0,inf,c[i][j],1);
				else change(root,0,inf,-c[i][j],-1);
			}
			ans[b[i]]=tmax[root]?from[root]:0;
		}
	}
} lian[NN];
void dfs1(int v)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		dfs1(y);
		size[v]+=size[y];
		if (size[y]&gt;size[hea[v]]) hea[v]=y;
	}
}
void dfs2(int v)
{
	lian[up[v]].push(v);
	if (hea[v])
	{
		up[hea[v]]=up[v];
		dfs2(hea[v]);
	}
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||y==hea[v]) continue;
		up[y]=y;
		dfs2(y);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y);
		addedge(x,y),addedge(y,x);
	}
	deep[1]=1,dfs1(1);
	up[1]=1,dfs2(1);
	//printf(&quot;hea &quot;);out(hea,1,n);printf(&quot;up &quot;);out(up,1,n);printf(&quot;pos &quot;);out(pos,1,n);
	for (i=1;i&lt;=n;i++)
		if (up[i]==i) lian[i].init(i);
	//for(i=1;i&lt;=n;i++)if(up[i]==i)lian[i].out();ln;
	for (;m;m--)
	{
		read(x),read(y),read(z);
		while (up[x]!=up[y])
		{
			if (deep[up[x]]&lt;deep[up[y]]) swap(x,y);
			lian[up[x]].change(up[x],x,z);
			x=fa[up[x]];
		}
		if (deep[x]&lt;deep[y]) swap(x,y);
		lian[up[x]].change(y,x,z);
	}
	for (i=1;i&lt;=n;i++)
		if (up[i]==i) lian[i].work();
	//ln;ln;
	for (i=1;i&lt;=n;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem3307</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
#define pb push_back
#define inf 1000000005
const int NN=101111,AA=2000000;
int deep[NN],up[NN],size[NN],o[NN],aa[NN&lt;&lt;1][2],fa[NN],hea[NN];
int tmax[AA],from[AA],lc[AA],rc[AA],vt[AA],pos[NN],ans[NN];
int n,m,tot,TTT,TIME,root;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
struct Lian
{
	vector&lt;int&gt; b;
	vector&lt;vector&lt;int&gt; &gt; c;
	int num,id;
	Lian() {num=0;b.clear();c.clear();b.pb(0);}
	void push(int v)
	{
		b.pb(v);
		pos[v]=b.size()-1;
	}
	void init(int i)
	{
		id=i;
		num=b.size()-1;
		b.pb(0);
		c.resize(num+5);
	}
	void change(int l,int r,int val)
	{
		l=pos[l],r=pos[r];
		c[l].pb(val),c[r+1].pb(-val);
	}
	void change(int &amp;v,int l,int r,int x,int kind)
	{
		if (v==0) v=++TTT;
		if (vt[v]!=TIME)
		{
			vt[v]=TIME,tmax[v]=from[v]=0;
			lc[v]=rc[v]=0;
		}
		if (r-l==1)
		{
			from[v]=l;
			if (kind==1) tmax[v]++;
			else tmax[v]--;
			return;
		}
		int mid=(l+r)&gt;&gt;1;
		if (x&lt;mid) change(lc[v],l,mid,x,kind);
		else change(rc[v],mid,r,x,kind);
		if (tmax[lc[v]]&gt;=tmax[rc[v]])
			tmax[v]=tmax[lc[v]],from[v]=from[lc[v]];
		else
			tmax[v]=tmax[rc[v]],from[v]=from[rc[v]];
	}
	void work()
	{
		TIME++;TTT=0;root=0;
		for (int i=1;i&lt;=num;i++)
		{
			for (int j=0;j&lt;(int)c[i].size();j++)
			{
				if (c[i][j]&gt;0) change(root,0,inf,c[i][j],1);
				else change(root,0,inf,-c[i][j],-1);
			}
			ans[b[i]]=tmax[root]?from[root]:0;
		}
	}
} lian[NN];
void dfs1(int v)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		dfs1(y);
		size[v]+=size[y];
		if (size[y]&gt;size[hea[v]]) hea[v]=y;
	}
}
void dfs2(int v)
{
	lian[up[v]].push(v);
	if (hea[v])
	{
		up[hea[v]]=up[v];
		dfs2(hea[v]);
	}
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||y==hea[v]) continue;
		up[y]=y;
		dfs2(y);
	}
}
int main()
{
	read(n),read(m);
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y);
		addedge(x,y),addedge(y,x);
	}
	deep[1]=1,dfs1(1);
	up[1]=1,dfs2(1);
	for (i=1;i&lt;=n;i++)
		if (up[i]==i) lian[i].init(i);
	for (;m;m--)
	{
		read(x),read(y),read(z);
		while (up[x]!=up[y])
		{
			if (deep[up[x]]&lt;deep[up[y]]) swap(x,y);
			lian[up[x]].change(up[x],x,z);
			x=fa[up[x]];
		}
		if (deep[x]&lt;deep[y]) swap(x,y);
		lian[up[x]].change(y,x,z);
	}
	for (i=1;i&lt;=n;i++)
		if (up[i]==i) lian[i].work();
	//ln;ln;
	for (i=1;i&lt;=n;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem3308</h2><pre>
#define MAXN 200010UL
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#define ll long long
#define INF 1e9

using namespace std;

int n, t, S, T, pr[MAXN], fv[MAXN], d[MAXN], w[MAXN], hd, tl, lie[5000010];
ll Cost, dis[MAXN], pre[MAXN];;
bool ins[MAXN], vis[MAXN], rel[MAXN];

struct ME {
    int qn, hou, nt, zhi, ct;
}sg[5000010];

inline void Add(int x, int y, int z, int ct) {
    sg[t].qn = x;
    sg[t].hou = y;
    sg[t].nt = d[x];
    sg[t].zhi = z;
    sg[t].ct = ct;
    d[x] = t ++;
  //  if(t==(MAXN&lt;&lt;6)) puts(&quot;Yes&quot;);
  //  printf(&quot;t = %d\n&quot;, t);
    return;
}

inline void Insert(int x, int y, int z, int ct) {
//	printf(&quot;x = %d y = %d z = %d ct = %d\n&quot;, x, y, z, ct);
    Add(x, y, z, ct), Add(y, x, 0, -ct);
    return;
}

inline void Pre(int r) {
    for(int i = 2 ; i &lt;= n ; ++ i) {
        if(!vis[i]) pre[++ pre[0]] = i;
        for(int j = 1 ; j &lt;= pre[0] &amp;&amp; i*pre[j] &lt;= n ; ++ j) {
            vis[i*pre[j]] = true;
            if(!(i%pre[j])) break;
        }
    }
    return;
}

inline int MIN(int A, int B) { return A&lt;B?A:B; }

inline bool Find() {
    memset(dis, -0x3f, sizeof(dis));
    ll inf = dis[0];
    hd = tl = 0;
    lie[++ tl] = S;
    dis[S] = 0, fv[S] = INF;
    while(hd&lt;tl) {
	//	printf(&quot;tl = %d\n&quot;, tl);
        int op = lie[++ hd];
        ins[op] = false;
        for(int i = d[op] ; i != -1 ; i = sg[i].nt) {
            if(sg[i].zhi&amp;&amp;dis[sg[i].hou]&lt;dis[op]+sg[i].ct) {
                dis[sg[i].hou] = dis[op]+sg[i].ct;
                pr[sg[i].hou] = i;
                fv[sg[i].hou] = MIN(fv[op], sg[i].zhi);
                if(!ins[sg[i].hou]) {
                    ins[sg[i].hou] = true;
                    lie[++ tl] = sg[i].hou;
                }
            }
        }
    }
    if(dis[T]&lt;=0) return false;
    Cost += dis[T]*(ll)fv[T];
    int u = T;
    while(u!=S) {
        sg[pr[u]].zhi -= fv[T];
        sg[pr[u]^1].zhi += fv[T];
        u = sg[pr[u]].qn;
    }
    return true;
}

int main() {
    memset(d, -1, sizeof(d));
    scanf(&quot;%d&quot;, &amp;n);
    Pre(n);
    S = 0, T = pre[0]+1;
    for(int i = 1 ; i &lt;= pre[0] ; ++ i) {
		ll k;
	    for(k = pre[i] ; k*pre[i] &lt;= n ; k *= pre[i]);
		w[i] = k, Cost += k;
	}
//	printf(&quot;pre[0] = %lld\n&quot;, pre[0]);
	int ti = 0;
	for(int i = 1 ; i &lt;= pre[0] ; ++ i) {
		if(pre[i]*pre[i]&lt;=n) {
			for(int j = i+1 ; j &lt;= pre[0] ; ++ j) {
				if(pre[j]*pre[j]&gt;n&amp;&amp;pre[i]*pre[j]&lt;=n) {
					//printf(&quot;ti = %d i = %d\n&quot;, ++ ti, i);
					ll k = pre[j]*pre[i];
					rel[i] = rel[j] = true;
					while(k*pre[i]&lt;=n) k *= pre[i];
					Insert(i, j, 1, k-w[i]-w[j]);
				}
			}
		}
    }
    for(int i = 1 ; i &lt;= pre[0] ; ++ i) {
		if(rel[i]) {
			if(pre[i]*pre[i]&lt;=n) Insert(S, i, 1, 0);
			else Insert(i, T, 1, 0);
		}
	}
  //  puts(&quot;Yes&quot;);
 //   printf(&quot;Cost = %lld\n&quot;, Cost);
    while(Find());
   // printf(&quot;Cost = %lld\n&quot;, Cost);
    printf(&quot;%lld&quot;, Cost+1);
//	while(1);
	return 0;
}
<pre><h2>Problem3309</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
int pr[2000000],a[10000005],the[10000005],f[10000005],sumf[10000005];;
int tes,n,m,prcnt;
void shai()
{
	static bool vt[10000005];
	vt[1]=true;
	f[1]=0;
	int i,j;
	for (i=2;i&lt;=10000000;i++)
	{
		if (!vt[i])
		{
			pr[++prcnt]=i;
			f[i]=1;
			a[i]=1;
			the[i]=i;
		}
		for (j=1;j&lt;=prcnt;j++)
		{
			int x=i*pr[j];
			if (x&gt;10000000) break;
			vt[x]=true;
			if (i%pr[j]==0)
			{
				a[x]=a[i]+1;
				the[x]=the[i]*pr[j];
				if (x==the[x]) f[x]=1;
				else
				{
					int t=x/the[x];
					f[x]=(a[x]==a[t])?-f[t]:0;
				}
				break;
			}
			a[x]=1;
			the[x]=pr[j];
			f[x]=(a[x]==a[i])?-f[i]:0;
		}
	}
	//for (i=1;i&lt;=100;i++) printf(&quot;f[%d]=%d\n&quot;,i,f[i]);
	for (i=1;i&lt;=10000000;i++) sumf[i]=sumf[i-1]+f[i];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	shai();
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		if (n&gt;m) {int t=n;n=m;m=t;}
		int l,r;LL ans=0;
		for (l=1;l&lt;=n;l=r+1)
		{
			r=min(n/(n/l),m/(m/l));
			ans+=(LL)(sumf[r]-sumf[l-1])*(n/l)*(m/l);
		}
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem3316</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long double DD;
typedef long long LL;
typedef pair&lt;int,DD&gt; pid;
#define mp make_pair
#define fi first
#define se second
const int NN=201111;
const DD eps=1e-8;
int n,L,R,a[NN];
LL sum[NN],fz,fm;
bool check(DD mid)
{
	static pid que[2][NN];
	static int head[2],tail[2];
	static DD b[NN];
	int i;
	for (i=1;i&lt;=n;i++) b[i]=b[i-1]+a[i]-mid;
	head[0]=head[1]=0,tail[0]=tail[1]=0;
	for (i=1;i&lt;=n;i++)
	{
		pid *q=que[i&amp;1];
		int &amp;h=head[i&amp;1],&amp;t=tail[i&amp;1];
		while (h&lt;t&amp;&amp;q[h+1].fi&lt;i-R) h++;
		if (h&lt;t&amp;&amp;b[i]&gt;=q[h+1].se)
		{
			fz=sum[i]-sum[q[h+1].fi];
			fm=i-q[h+1].fi;
			return true;
		}
		pid *qq=que[(i&amp;1)^1];
		int &amp;hh=head[(i&amp;1)^1],&amp;tt=tail[(i&amp;1)^1];
		int k=i-L+1;
		if (k&gt;=0)
		{
			while (hh&lt;tt&amp;&amp;qq[tt].se&gt;b[k]) tt--;
			qq[++tt]=mp(k,b[k]);
		}
	}
	return false;
}
LL gcd(LL a,LL b) {return !b?a:gcd(b,a%b);}
int main()
{
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;L,&amp;R);
	if (L&amp;1) L++;
	if (R&amp;1) R--;
	DD l=0,r=0;
	int i;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]),a[i+n]=a[i];
		if (a[i]&gt;r) r=a[i];
	}
	n=(n&lt;&lt;1)-1;
	for (i=1;i&lt;=n;i++) sum[i]=sum[i-1]+a[i];
	while (r-l&gt;eps)
	{
		DD mid=(l+r)*0.5;
		if (check(mid)) l=mid;
		else r=mid;
	}
	check(l);
	LL t=gcd(fz,fm);
	fz/=t,fm/=t;
	if (fm==1) printf(&quot;%lld\n&quot;,fz);
	else printf(&quot;%lld/%lld\n&quot;,fz,fm);
	return 0;
}<pre><h2>Problem3316</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
typedef long long LL;
typedef pair&lt;int,DD&gt; pid;
#define mp make_pair
#define fi first
#define se second
const int NN=201111;
const DD eps=1e-8;
int n,L,R,a[NN];
LL sum[NN],fz,fm;
bool check(DD mid)
{
	static pid que[2][NN];
	static int head[2],tail[2];
	static DD b[NN];
	int i;
	for (i=1;i&lt;=n;i++) b[i]=b[i-1]+a[i]-mid;
	head[0]=head[1]=0,tail[0]=tail[1]=0;
	for (i=1;i&lt;=n;i++)
	{
		pid *q=que[i&amp;1];
		int &amp;h=head[i&amp;1],&amp;t=tail[i&amp;1];
		while (h&lt;t&amp;&amp;q[h+1].fi&lt;i-R) h++;
		if (h&lt;t&amp;&amp;b[i]&gt;=q[h+1].se)
		{
			fz=sum[i]-sum[q[h+1].fi];
			fm=i-q[h+1].fi;
			return true;
		}
		pid *qq=que[(i&amp;1)^1];
		int &amp;hh=head[(i&amp;1)^1],&amp;tt=tail[(i&amp;1)^1];
		int k=i-L+1;
		if (k&gt;=0)
		{
			while (hh&lt;tt&amp;&amp;qq[tt].se&gt;b[k]) tt--;
			qq[++tt]=mp(k,b[k]);
		}
	}
	return false;
}
LL gcd(LL a,LL b) {return !b?a:gcd(b,a%b);}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;L,&amp;R);
	if (L&amp;1) L++;
	if (R&amp;1) R--;
	DD l=0,r=0;
	int i;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]),a[i+n]=a[i];
		if (a[i]&gt;r) r=a[i];
	}
	n=(n&lt;&lt;1)-1;
	for (i=1;i&lt;=n;i++) sum[i]=sum[i-1]+a[i];
	for (int tt=0;tt&lt;=100;tt++)
	{
		DD mid=(l+r)*0.5;
		if (check(mid)) l=mid;
		else r=mid;
	}
	check(l);
	LL t=gcd(fz,fm);
	fz/=t,fm/=t;
	if (fm==1) printf(&quot;%lld\n&quot;,fz);
	else printf(&quot;%lld/%lld\n&quot;,fz,fm);
	return 0;
}<pre><h2>Problem3316</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
typedef long long LL;
typedef pair&lt;int,DD&gt; pid;
#define mp make_pair
#define fi first
#define se second
const int NN=201111;
const DD eps=1e-7;
int n,L,R,a[NN];
LL sum[NN],fz,fm;
bool check(DD mid)
{
	static pid que[2][NN];
	static int head[2],tail[2];
	static DD b[NN];
	int i;
	for (i=1;i&lt;=n;i++) b[i]=b[i-1]+a[i]-mid;
	head[0]=head[1]=0,tail[0]=tail[1]=0;
	for (i=1;i&lt;=n;i++)
	{
		pid *q=que[i&amp;1];
		int &amp;h=head[i&amp;1],&amp;t=tail[i&amp;1];
		while (h&lt;t&amp;&amp;q[h+1].fi&lt;i-R) h++;
		if (h&lt;t&amp;&amp;b[i]&gt;=q[h+1].se)
		{
			fz=sum[i]-sum[q[h+1].fi];
			fm=i-q[h+1].fi;
			return true;
		}
		pid *qq=que[(i&amp;1)^1];
		int &amp;hh=head[(i&amp;1)^1],&amp;tt=tail[(i&amp;1)^1];
		int k=i-L+1;
		if (k&gt;=0)
		{
			while (hh&lt;tt&amp;&amp;qq[tt].se&gt;b[k]) tt--;
			qq[++tt]=mp(k,b[k]);
		}
	}
	return false;
}
LL gcd(LL a,LL b) {return !b?a:gcd(b,a%b);}
int main()
{
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;L,&amp;R);
	if (L&amp;1) L++;
	if (R&amp;1) R--;
	DD l=0,r=0;
	int i;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]),a[i+n]=a[i];
		if (a[i]&gt;r) r=a[i];
	}
	n=(n&lt;&lt;1)-1;
	for (i=1;i&lt;=n;i++) sum[i]=sum[i-1]+a[i];
	for (int tt=0;tt&lt;=50;tt++)
	{
		DD mid=(l+r)*0.5;
		if (check(mid)) l=mid;
		else r=mid;
	}
	check(l);
	LL t=gcd(fz,fm);
	fz/=t,fm/=t;
	if (fm==1) printf(&quot;%lld\n&quot;,fz);
	else printf(&quot;%lld/%lld\n&quot;,fz,fm);
	return 0;
}<pre><h2>Problem3316</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
typedef long long LL;
typedef pair&lt;int,DD&gt; pid;
#define mp make_pair
#define fi first
#define se second
const int NN=201111;
const DD eps=1e-7;
int n,L,R,a[NN];
LL sum[NN],fz,fm;
bool check(DD mid)
{
	static pid que[2][NN];
	static int head[2],tail[2];
	static DD b[NN];
	int i;
	for (i=1;i&lt;=n;i++) b[i]=b[i-1]+a[i]-mid;
	head[0]=head[1]=0,tail[0]=tail[1]=0;
	for (i=1;i&lt;=n;i++)
	{
		pid *q=que[i&amp;1];
		int &amp;h=head[i&amp;1],&amp;t=tail[i&amp;1];
		while (h&lt;t&amp;&amp;q[h+1].fi&lt;i-R) h++;
		if (h&lt;t&amp;&amp;b[i]&gt;=q[h+1].se)
		{
			fz=sum[i]-sum[q[h+1].fi];
			fm=i-q[h+1].fi;
			return true;
		}
		pid *qq=que[(i&amp;1)^1];
		int &amp;hh=head[(i&amp;1)^1],&amp;tt=tail[(i&amp;1)^1];
		int k=i-L+1;
		if (k&gt;=0)
		{
			while (hh&lt;tt&amp;&amp;qq[tt].se&gt;b[k]) tt--;
			qq[++tt]=mp(k,b[k]);
		}
	}
	return false;
}
LL gcd(LL a,LL b) {return !b?a:gcd(b,a%b);}
int main()
{
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;L,&amp;R);
	if (L&amp;1) L++;
	if (R&amp;1) R--;
	DD l=0,r=0;
	int i;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]),a[i+n]=a[i];
		if (a[i]&gt;r) r=a[i];
	}
	n=(n&lt;&lt;1)-1;
	for (i=1;i&lt;=n;i++) sum[i]=sum[i-1]+a[i];
	for (int tt=0;tt&lt;=30;tt++)
	{
		DD mid=(l+r)*0.5;
		if (check(mid)) l=mid;
		else r=mid;
	}
	check(l);
	LL t=gcd(fz,fm);
	fz/=t,fm/=t;
	if (fm==1) printf(&quot;%lld\n&quot;,fz);
	else printf(&quot;%lld/%lld\n&quot;,fz,fm);
	return 0;
}<pre><h2>Problem3333</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
const int maxn=500010;
int b[maxn],c[maxn],sum[maxn],n,m,a[maxn],tot;
bool v[maxn];
long long ans;
int find(int x)
{
    int mid,l=1,r=tot;
    while (l&lt;=r)
    {
        mid=(l+r)&gt;&gt;1;
        if (c[mid]==x) return mid;
        if (c[mid]&gt;x) r=mid-1; else l=mid+1;
    }
}
int getsum(int x)
{
    int get=0;
    for (;x;x-=x&amp;-x) get+=sum[x];
    return get;
}
void change(int x)
{
    for (;x&lt;=tot;x+=x&amp;-x) sum[x]++;
}
int main()
{
    int i,x,pos;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for (i=1;i&lt;=n;i++) {scanf(&quot;%d&quot;,&amp;a[i]); c[i]=a[i];}
    sort(c+1,c+n+1);
    tot=n;
    for (i=n;i;i--)
    {
        x=find(a[i]);
        b[i]=getsum(x-1);
        change(x);
        ans+=(long long )b[i];
    }
    printf(&quot;%lld\n&quot;,ans);
    for (;m;m--)
    {
        scanf(&quot;%d&quot;,&amp;pos);
        if (v[pos]) {printf(&quot;%lld\n&quot;,ans); continue;}
        for (i=pos;i&lt;=n;i++) if (!v[i]&amp;&amp;a[i]&lt;=a[pos])
        {
            v[i]=true;
            ans-=(long long )b[i];
        }
        printf(&quot;%lld\n&quot;,ans);
    }
    return 0;
}<pre><h2>Problem3336</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;map&gt;
using namespace std;
typedef long long LL;
#define mp make_pair
#define fi first
#define se second
#define ln printf(&quot;\n&quot;)
char M[11][11];
int tes,n,m,now;
map&lt; pair&lt; pair&lt;LL,int&gt;,pair&lt;int,int&gt; &gt;, int &gt; C[2];
map&lt; pair&lt; pair&lt;LL,int&gt;,pair&lt;int,int&gt; &gt;, int &gt;::iterator it;
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);ln;}
pair&lt;LL,int&gt; pack(int *a,int *b)
{
	int res2=0,i;
	for (i=1;i&lt;=m;i++) res2=res2&lt;&lt;1|b[i];
	static int dy[11];
	memset(dy,-1,sizeof(dy));
	int cnt=0;LL res1=0;
	for (i=1;i&lt;=m;i++)
	{
		if (dy[a[i]]==-1) dy[a[i]]=cnt++;
		a[i]=dy[a[i]];
		res1=res1&lt;&lt;3|a[i];
	}
	return mp(res1,res2);
}
void repack(int *a,LL X,int *b,int Y)
{
	for (int i=m;i;i--)
	{
		a[i]=X&amp;7;X&gt;&gt;=3;
		b[i]=Y&amp;1;Y&gt;&gt;=1;
	}
}
void debug(int *a,int *b,int P,int must)
{
	int i;
	for (i=1;i&lt;=m;i++) printf(&quot;%d &quot;,a[i]);
	printf(&quot;  &quot;);
	for (i=1;i&lt;=m;i++) printf(&quot;%d &quot;,b[i]);
	printf(&quot;  P=%d must=%d &quot;,P,must);
}
void work(int i,int j,int cc)
{
	//printf(&quot;****************** work %d *****************************\n&quot;,cc);
	static int a[11],b[11],aa[11],bb[11];
	static bool vt[11];
	for (it=C[now].begin();it!=C[now].end();it++)
	{
		//printf(&quot;===============================\n&quot;);
		LL X=(*it).fi.fi.fi;
		int Y=(*it).fi.fi.se,PP=(*it).fi.se.fi,must=(*it).fi.se.se;
		int ff=(*it).se,k;
		repack(aa,X,bb,Y);
		//debug(aa,bb,PP,must);printf(&quot;ff=%d\n&quot;,ff); 
		memset(vt,0,sizeof(vt));
		int n0=0,n1=0;
		if (i&gt;1) for (k=1;k&lt;=m;k++)
		{
			if (vt[aa[k]]) continue;
			vt[aa[k]]=true;
			if (bb[k]==0) n0++;else n1++;
		}
		//if (n0&gt;1&amp;&amp;n1&gt;1) continue;
		if (i&gt;1&amp;&amp;j&gt;1&amp;&amp;PP==cc&amp;&amp;bb[j]==cc&amp;&amp;bb[j-1]==cc) continue;
		if (must!=-1&amp;&amp;cc!=must) continue;
		for (k=1;k&lt;=m;k++) a[k]=aa[k],b[k]=bb[k];
		if (i&gt;1&amp;&amp;bb[j]==cc) a[j]=aa[j];
		else a[j]=9;
		if (j&gt;1&amp;&amp;bb[j-1]==cc)
		{
			int t=a[j-1];
			for (k=1;k&lt;=m;k++) if (a[k]==t) a[k]=a[j];
		}
		b[j]=cc;
		int P=bb[j];
		if (i&gt;1&amp;&amp;bb[j]!=cc)
		{
			bool flag=false;
			for (k=1;k&lt;=m;k++) if (a[k]==aa[j]) flag=true;
			if (!flag)
			{
				flag=false;
				for (k=1;k&lt;=m;k++) if (b[k]==(cc^1)) flag=true;
				if (flag) continue;
				if (must!=-1&amp;&amp;cc!=must) continue;
				C[now^1][mp(pack(a,b),mp(P,cc))]+=ff;
				//printf(&quot;  insert:   &quot;);debug(a,b,P,cc);ln;
				continue;
			}
		}
		C[now^1][mp(pack(a,b),mp(P,must))]+=ff;
		//printf(&quot;  insert:   &quot;);debug(a,b,P,must);ln;
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		int i,j;
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=m;j++)
			{
				char ch=getchar();
				while (ch!='.'&amp;&amp;ch!='#'&amp;&amp;ch!='o') ch=getchar();
				M[i][j]=ch;
			}
		now=0;
		C[0].clear();
		C[0][mp(mp(0ll,0),mp(0,-1))]=1;
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=m;j++)
			{
				//printf(&quot;\n------------------- i=%d j=%d -----------------------------------\n&quot;,i,j);
				C[now^1].clear();
				if (M[i][j]=='.') work(i,j,0),work(i,j,1);
				else if (M[i][j]=='o') work(i,j,0);
				else work(i,j,1);
				now^=1;
			}
		int ans=0;
		for (it=C[now].begin();it!=C[now].end();it++)
		{
			static int aa[11],bb[11];
			LL X=(*it).fi.fi.fi;
			int Y=(*it).fi.fi.se;
			int ff=(*it).se;
			repack(aa,X,bb,Y);
			int n1=0,n2=0;static bool vt[11];
			memset(vt,0,sizeof(vt));
			for (int k=1;k&lt;=m;k++)
			{
				if (vt[aa[k]]) continue;
				vt[aa[k]]=true;
				if (bb[k]==0) n1++;else n2++;
			}
			if (n1&gt;1||n2&gt;1) continue;
			ans+=ff;
		}
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem3336</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;map&gt;
using namespace std;
typedef long long LL;
#define mp make_pair
#define fi first
#define se second
#define ln printf(&quot;\n&quot;)
char M[11][11];
int tes,n,m,now;
map&lt; pair&lt; pair&lt;LL,int&gt;,pair&lt;int,int&gt; &gt;, int &gt; C[2];
map&lt; pair&lt; pair&lt;LL,int&gt;,pair&lt;int,int&gt; &gt;, int &gt;::iterator it;
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);ln;}
pair&lt;LL,int&gt; pack(int *a,int *b)
{
	int res2=0,i;
	for (i=1;i&lt;=m;i++) res2=res2&lt;&lt;1|b[i];
	static int dy[11];
	memset(dy,-1,sizeof(dy));
	int cnt=0;LL res1=0;
	for (i=1;i&lt;=m;i++)
	{
		if (dy[a[i]]==-1) dy[a[i]]=cnt++;
		a[i]=dy[a[i]];
		res1=res1&lt;&lt;3|a[i];
	}
	return mp(res1,res2);
}
void repack(int *a,LL X,int *b,int Y)
{
	for (int i=m;i;i--)
	{
		a[i]=X&amp;7;X&gt;&gt;=3;
		b[i]=Y&amp;1;Y&gt;&gt;=1;
	}
}
void debug(int *a,int *b,int P,int must)
{
	int i;
	for (i=1;i&lt;=m;i++) printf(&quot;%d &quot;,a[i]);
	printf(&quot;  &quot;);
	for (i=1;i&lt;=m;i++) printf(&quot;%d &quot;,b[i]);
	printf(&quot;  P=%d must=%d &quot;,P,must);
}
void work(int i,int j,int cc)
{
	//printf(&quot;****************** work %d *****************************\n&quot;,cc);
	static int a[11],b[11],aa[11],bb[11];
	static bool vt[11];
	for (it=C[now].begin();it!=C[now].end();it++)
	{
		//printf(&quot;===============================\n&quot;);
		LL X=(*it).fi.fi.fi;
		int Y=(*it).fi.fi.se,PP=(*it).fi.se.fi,must=(*it).fi.se.se;
		int ff=(*it).se,k;
		repack(aa,X,bb,Y);
		//debug(aa,bb,PP,must);printf(&quot;ff=%d\n&quot;,ff); 
		memset(vt,0,sizeof(vt));
		int n0=0,n1=0;
		if (i&gt;1) for (k=1;k&lt;=m;k++)
		{
			if (vt[aa[k]]) continue;
			vt[aa[k]]=true;
			if (bb[k]==0) n0++;else n1++;
		}
		if (n0&gt;1&amp;&amp;n1&gt;1)
		{
			//printf(&quot;now!!!  i=%d j=%d\n&quot;,i,j);
			//debug(aa,bb,PP,must);printf(&quot;ff=%d\n&quot;,ff); 
			//continue;
		}
		if (i&gt;1&amp;&amp;j&gt;1&amp;&amp;PP==cc&amp;&amp;bb[j]==cc&amp;&amp;bb[j-1]==cc) continue;
		if (must!=-1&amp;&amp;cc!=must) continue;
		for (k=1;k&lt;=m;k++) a[k]=aa[k],b[k]=bb[k];
		if (i&gt;1&amp;&amp;bb[j]==cc) a[j]=aa[j];
		else a[j]=9;
		if (j&gt;1&amp;&amp;bb[j-1]==cc)
		{
			int t=a[j-1];
			for (k=1;k&lt;=m;k++) if (a[k]==t) a[k]=a[j];
		}
		b[j]=cc;
		int P=bb[j];
		if (i&gt;1&amp;&amp;bb[j]!=cc)
		{
			bool flag=false;
			for (k=1;k&lt;=m;k++) if (a[k]==aa[j]) flag=true;
			if (!flag)
			{
				flag=false;
				for (k=1;k&lt;=m;k++) if (b[k]==(cc^1)) flag=true;
				if (flag) continue;
				if (must!=-1&amp;&amp;cc!=must) continue;
				C[now^1][mp(pack(a,b),mp(P,cc))]+=ff;
				//printf(&quot;  insert:   &quot;);debug(a,b,P,cc);ln;
				continue;
			}
		}
		C[now^1][mp(pack(a,b),mp(P,must))]+=ff;
		//printf(&quot;  insert:   &quot;);debug(a,b,P,must);ln;
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		int i,j;
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=m;j++)
			{
				char ch=getchar();
				while (ch!='.'&amp;&amp;ch!='#'&amp;&amp;ch!='o') ch=getchar();
				M[i][j]=ch;
			}
		now=0;
		C[0].clear();
		C[0][mp(mp(0ll,0),mp(0,-1))]=1;
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=m;j++)
			{
				//printf(&quot;\n------------------- i=%d j=%d -----------------------------------\n&quot;,i,j);
				C[now^1].clear();
				if (M[i][j]=='.') work(i,j,0),work(i,j,1);
				else if (M[i][j]=='o') work(i,j,0);
				else work(i,j,1);
				now^=1;
			}
		int ans=0;
		for (it=C[now].begin();it!=C[now].end();it++)
		{
			static int aa[11],bb[11];
			LL X=(*it).fi.fi.fi;
			int Y=(*it).fi.fi.se;
			int ff=(*it).se;
			repack(aa,X,bb,Y);
			int n1=0,n2=0;static bool vt[11];
			memset(vt,0,sizeof(vt));
			for (int k=1;k&lt;=m;k++)
			{
				if (vt[aa[k]]) continue;
				vt[aa[k]]=true;
				if (bb[k]==0) n1++;else n2++;
			}
			if (n1&gt;1||n2&gt;1) continue;
			ans+=ff;
		}
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem3336</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;map&gt;
using namespace std;
typedef long long LL;
#define mp make_pair
#define fi first
#define se second
#define ln printf(&quot;\n&quot;)
char M[11][11];
int tes,n,m,now;
map&lt; pair&lt; pair&lt;LL,int&gt;,pair&lt;int,int&gt; &gt;, int &gt; C[2];
map&lt; pair&lt; pair&lt;LL,int&gt;,pair&lt;int,int&gt; &gt;, int &gt;::iterator it;
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);ln;}
pair&lt;LL,int&gt; pack(int *a,int *b)
{
	int res2=0,i;
	for (i=1;i&lt;=m;i++) res2=res2&lt;&lt;1|b[i];
	static int dy[11];
	memset(dy,-1,sizeof(dy));
	int cnt=0;LL res1=0;
	for (i=1;i&lt;=m;i++)
	{
		if (dy[a[i]]==-1) dy[a[i]]=cnt++;
		a[i]=dy[a[i]];
		res1=res1&lt;&lt;3|a[i];
	}
	return mp(res1,res2);
}
void repack(int *a,LL X,int *b,int Y)
{
	for (int i=m;i;i--)
	{
		a[i]=X&amp;7;X&gt;&gt;=3;
		b[i]=Y&amp;1;Y&gt;&gt;=1;
	}
}
void debug(int *a,int *b,int P,int must)
{
	int i;
	for (i=1;i&lt;=m;i++) printf(&quot;%d &quot;,a[i]);
	printf(&quot;  &quot;);
	for (i=1;i&lt;=m;i++) printf(&quot;%d &quot;,b[i]);
	printf(&quot;  P=%d must=%d &quot;,P,must);
}
void work(int i,int j,int cc)
{
	static int a[11],b[11],aa[11],bb[11];
	for (it=C[now].begin();it!=C[now].end();it++)
	{
		int X=(*it).fi.fi.fi,Y=(*it).fi.fi.se;
		int PP=(*it).fi.se.fi,must=(*it).fi.se.se,ff=(*it).se,k;
		repack(aa,X,bb,Y);
		if (i&gt;1&amp;&amp;j&gt;1&amp;&amp;PP==cc&amp;&amp;bb[j]==cc&amp;&amp;bb[j-1]==cc) continue;
		if (must!=-1&amp;&amp;cc!=must) continue;
		for (k=1;k&lt;=m;k++) a[k]=aa[k],b[k]=bb[k];
		if (i&gt;1&amp;&amp;bb[j]==cc) a[j]=aa[j];
		else a[j]=9;
		if (j&gt;1&amp;&amp;bb[j-1]==cc)
		{
			int t=a[j-1];
			for (k=1;k&lt;=m;k++) if (a[k]==t) a[k]=a[j];
		}
		b[j]=cc;
		int P=bb[j];
		if (i&gt;1&amp;&amp;bb[j]!=cc)
		{
			bool flag=false;
			for (k=1;k&lt;=m;k++) if (a[k]==aa[j]) flag=true;
			if (!flag)
			{
				flag=false;
				for (k=1;k&lt;=m;k++) if (b[k]==(cc^1)) flag=true;
				if (flag) continue;
				if (must!=-1&amp;&amp;cc!=must) continue;
				C[now^1][mp(pack(a,b),mp(P,cc))]+=ff;
				//printf(&quot;  insert:   &quot;);debug(a,b,P,cc);ln;
				continue;
			}
		}
		C[now^1][mp(pack(a,b),mp(P,must))]+=ff;
		//printf(&quot;  insert:   &quot;);debug(a,b,P,must);ln;
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		int i,j;
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=m;j++)
			{
				char ch=getchar();
				while (ch!='.'&amp;&amp;ch!='#'&amp;&amp;ch!='o') ch=getchar();
				M[i][j]=ch;
			}
		now=0;
		C[0].clear();
		C[0][mp(mp(0ll,0),mp(0,-1))]=1;
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=m;j++)
			{
				//printf(&quot;\n------------------- i=%d j=%d -----------------------------------\n&quot;,i,j);
				C[now^1].clear();
				if (M[i][j]=='.') work(i,j,0),work(i,j,1);
				else if (M[i][j]=='o') work(i,j,0);
				else work(i,j,1);
				now^=1;
			}
		int ans=0;
		for (it=C[now].begin();it!=C[now].end();it++)
		{
			static int aa[11],bb[11];
			LL X=(*it).fi.fi.fi;
			int Y=(*it).fi.fi.se;
			int ff=(*it).se;
			repack(aa,X,bb,Y);
			int n1=0,n2=0;static bool vt[11];
			memset(vt,0,sizeof(vt));
			for (int k=1;k&lt;=m;k++)
			{
				if (vt[aa[k]]) continue;
				vt[aa[k]]=true;
				if (bb[k]==0) n1++;else n2++;
			}
			if (n1&gt;1||n2&gt;1) continue;
			ans+=ff;
		}
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem3336</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;map&gt;
using namespace std;
#define mp make_pair
#define fi first
#define se second
#define ln printf(&quot;\n&quot;)
char M[11][11];
int tes,n,m,now;
map&lt; pair&lt; pair&lt;int,int&gt;,pair&lt;int,int&gt; &gt;, int &gt; C[2];
map&lt; pair&lt; pair&lt;int,int&gt;,pair&lt;int,int&gt; &gt;, int &gt;::iterator it;
pair&lt;int,int&gt; pack(int *a,int *b)
{
	int res2=0,i;
	for (i=1;i&lt;=m;i++) res2=res2&lt;&lt;1|b[i];
	static int dy[11];
	memset(dy,-1,sizeof(dy));
	int cnt=0,res1=0;
	for (i=1;i&lt;=m;i++)
	{
		if (dy[a[i]]==-1) dy[a[i]]=cnt++;
		a[i]=dy[a[i]];
		res1=res1&lt;&lt;3|a[i];
	}
	return mp(res1,res2);
}
void repack(int *a,int X,int *b,int Y)
{
	for (int i=m;i;i--)
	{
		a[i]=X&amp;7;X&gt;&gt;=3;
		b[i]=Y&amp;1;Y&gt;&gt;=1;
	}
}
void work(int i,int j,int cc)
{
	static int a[11],b[11],aa[11],bb[11];
	for (it=C[now].begin();it!=C[now].end();it++)
	{
		int X=(*it).fi.fi.fi,Y=(*it).fi.fi.se;
		int PP=(*it).fi.se.fi,must=(*it).fi.se.se,ff=(*it).se,k;
		repack(aa,X,bb,Y);
		if (i&gt;1&amp;&amp;j&gt;1&amp;&amp;PP==cc&amp;&amp;bb[j]==cc&amp;&amp;bb[j-1]==cc) continue;
		if (must!=-1&amp;&amp;cc!=must) continue;
		for (k=1;k&lt;=m;k++) a[k]=aa[k],b[k]=bb[k];
		if (i&gt;1&amp;&amp;bb[j]==cc) a[j]=aa[j];
		else a[j]=9;
		if (j&gt;1&amp;&amp;bb[j-1]==cc)
		{
			int t=a[j-1];
			for (k=1;k&lt;=m;k++) if (a[k]==t) a[k]=a[j];
		}
		b[j]=cc;
		int P=bb[j];
		if (i&gt;1&amp;&amp;bb[j]!=cc)
		{
			bool flag=false;
			for (k=1;k&lt;=m;k++) if (a[k]==aa[j]) flag=true;
			if (!flag)
			{
				flag=false;
				for (k=1;k&lt;=m;k++) if (b[k]==(cc^1)) flag=true;
				if (flag) continue;
				if (must!=-1&amp;&amp;cc!=must) continue;
				C[now^1][mp(pack(a,b),mp(P,cc))]+=ff;
				continue;
			}
		}
		C[now^1][mp(pack(a,b),mp(P,must))]+=ff;
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		int i,j;
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=m;j++)
			{
				char ch=getchar();
				while (ch!='.'&amp;&amp;ch!='#'&amp;&amp;ch!='o') ch=getchar();
				M[i][j]=ch;
			}
		now=0;
		C[0].clear();
		C[0][mp(mp(0ll,0),mp(0,-1))]=1;
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=m;j++)
			{
				//printf(&quot;\n------------------- i=%d j=%d -----------------------------------\n&quot;,i,j);
				C[now^1].clear();
				if (M[i][j]=='.') work(i,j,0),work(i,j,1);
				else if (M[i][j]=='o') work(i,j,0);
				else work(i,j,1);
				now^=1;
			}
		int ans=0;
		for (it=C[now].begin();it!=C[now].end();it++)
		{
			static int aa[11],bb[11];
			int X=(*it).fi.fi.fi;
			int Y=(*it).fi.fi.se;
			int ff=(*it).se;
			repack(aa,X,bb,Y);
			int n1=0,n2=0;static bool vt[11];
			memset(vt,0,sizeof(vt));
			for (int k=1;k&lt;=m;k++)
			{
				if (vt[aa[k]]) continue;
				vt[aa[k]]=true;
				if (bb[k]==0) n1++;else n2++;
			}
			if (n1&gt;1||n2&gt;1) continue;
			ans+=ff;
		}
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem3336</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;map&gt;
using namespace std;
typedef pair&lt;int,int&gt; pii;
#define mp make_pair
#define fi first
#define se second
#define ln printf(&quot;\n&quot;)
char M[11][11];
int tes,n,m,now;
map&lt;pair&lt;pii,pii&gt;,int&gt; C[2];
map&lt;pair&lt;pii,pii&gt;,int&gt;::iterator it;
pii pack(int *a,int *b)
{
	int res2=0,i;
	for (i=1;i&lt;=m;i++) res2=res2&lt;&lt;1|b[i];
	static int dy[11];
	memset(dy,-1,sizeof(dy));
	int cnt=0,res1=0;
	for (i=1;i&lt;=m;i++)
	{
		if (dy[a[i]]==-1) dy[a[i]]=cnt++;
		a[i]=dy[a[i]];
		res1=res1&lt;&lt;3|a[i];
	}
	return mp(res1,res2);
}
void repack(int *a,int X,int *b,int Y)
{
	for (int i=m;i;i--)
	{
		a[i]=X&amp;7;X&gt;&gt;=3;
		b[i]=Y&amp;1;Y&gt;&gt;=1;
	}
}
void work(int i,int j,int cc)
{
	static int a[11],b[11],aa[11],bb[11];
	for (it=C[now].begin();it!=C[now].end();it++)
	{
		int X=(*it).fi.fi.fi,Y=(*it).fi.fi.se;
		int PP=(*it).fi.se.fi,must=(*it).fi.se.se,ff=(*it).se,k;
		repack(aa,X,bb,Y);
		if (i&gt;1&amp;&amp;j&gt;1&amp;&amp;PP==cc&amp;&amp;bb[j]==cc&amp;&amp;bb[j-1]==cc) continue;
		if (must!=-1&amp;&amp;cc!=must) continue;
		for (k=1;k&lt;=m;k++) a[k]=aa[k],b[k]=bb[k];
		if (i&gt;1&amp;&amp;bb[j]==cc) a[j]=aa[j];
		else a[j]=9;
		if (j&gt;1&amp;&amp;bb[j-1]==cc)
		{
			int t=a[j-1];
			for (k=1;k&lt;=m;k++) if (a[k]==t) a[k]=a[j];
		}
		b[j]=cc;
		int P=bb[j];
		if (i&gt;1&amp;&amp;bb[j]!=cc)
		{
			bool flag=false;
			for (k=1;k&lt;=m;k++) if (a[k]==aa[j]) flag=true;
			if (!flag)
			{
				flag=false;
				for (k=1;k&lt;=m;k++) if (b[k]==(cc^1)) flag=true;
				if (flag) continue;
				if (must!=-1&amp;&amp;cc!=must) continue;
				C[now^1][mp(pack(a,b),mp(P,cc))]+=ff;
				continue;
			}
		}
		C[now^1][mp(pack(a,b),mp(P,must))]+=ff;
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		int i,j;
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=m;j++)
			{
				char ch=getchar();
				while (ch!='.'&amp;&amp;ch!='#'&amp;&amp;ch!='o') ch=getchar();
				M[i][j]=ch;
			}
		now=0;
		C[0].clear();
		C[0][mp(mp(0ll,0),mp(0,-1))]=1;
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=m;j++)
			{
				C[now^1].clear();
				if (M[i][j]=='.') work(i,j,0),work(i,j,1);
				else if (M[i][j]=='o') work(i,j,0);
				else work(i,j,1);
				now^=1;
			}
		int ans=0;
		for (it=C[now].begin();it!=C[now].end();it++)
		{
			static int aa[11],bb[11];
			int X=(*it).fi.fi.fi;
			int Y=(*it).fi.fi.se;
			int ff=(*it).se;
			repack(aa,X,bb,Y);
			int n1=0,n2=0;static bool vt[11];
			memset(vt,0,sizeof(vt));
			for (int k=1;k&lt;=m;k++)
			{
				if (vt[aa[k]]) continue;
				vt[aa[k]]=true;
				if (bb[k]==0) n1++;else n2++;
			}
			if (n1&gt;1||n2&gt;1) continue;
			ans+=ff;
		}
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem3336</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;map&gt;
using namespace std;
typedef pair&lt;int,int&gt; pii;
#define mp make_pair
#define fi first
#define se second
char M[11][11];
int tes,n,m,now;
map&lt;pair&lt;pii,pii&gt;,int&gt; C[2];
map&lt;pair&lt;pii,pii&gt;,int&gt;::iterator it;
pii pack(int *a,int *b)
{
	int res2=0,i;
	for (i=1;i&lt;=m;i++) res2=res2&lt;&lt;1|b[i];
	static int dy[11];
	memset(dy,-1,sizeof(dy));
	int cnt=0,res1=0;
	for (i=1;i&lt;=m;i++)
	{
		if (dy[a[i]]==-1) dy[a[i]]=cnt++;
		a[i]=dy[a[i]];
		res1=res1&lt;&lt;3|a[i];
	}
	return mp(res1,res2);
}
void repack(int *a,int X,int *b,int Y)
{
	for (int i=m;i;i--)
	{
		a[i]=X&amp;7;X&gt;&gt;=3;
		b[i]=Y&amp;1;Y&gt;&gt;=1;
	}
}
void work(int i,int j,int cc)
{
	static int a[11],b[11],aa[11],bb[11];
	for (it=C[now].begin();it!=C[now].end();it++)
	{
		int X=(*it).fi.fi.fi,Y=(*it).fi.fi.se;
		int PP=(*it).fi.se.fi,must=(*it).fi.se.se,ff=(*it).se,k;
		repack(aa,X,bb,Y);
		if (i&gt;1&amp;&amp;j&gt;1&amp;&amp;PP==cc&amp;&amp;bb[j]==cc&amp;&amp;bb[j-1]==cc) continue;
		if (must!=-1&amp;&amp;cc!=must) continue;
		for (k=1;k&lt;=m;k++) a[k]=aa[k],b[k]=bb[k];
		if (i&gt;1&amp;&amp;bb[j]==cc) a[j]=aa[j];
		else a[j]=9;
		if (j&gt;1&amp;&amp;bb[j-1]==cc)
		{
			int t=a[j-1];
			for (k=1;k&lt;=m;k++) if (a[k]==t) a[k]=a[j];
		}
		b[j]=cc;
		int P=bb[j];
		if (i&gt;1&amp;&amp;bb[j]!=cc)
		{
			bool flag=false;
			for (k=1;k&lt;=m;k++) if (a[k]==aa[j]) flag=true;
			if (!flag)
			{
				flag=false;
				for (k=1;k&lt;=m;k++) if (b[k]==(cc^1)) flag=true;
				if (flag) continue;
				if (must!=-1&amp;&amp;cc!=must) continue;
				C[now^1][mp(pack(a,b),mp(P,cc))]+=ff;
				continue;
			}
		}
		C[now^1][mp(pack(a,b),mp(P,must))]+=ff;
	}
}
int main()
{
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		int i,j;
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=m;j++)
			{
				char ch=getchar();
				while (ch!='.'&amp;&amp;ch!='#'&amp;&amp;ch!='o') ch=getchar();
				M[i][j]=ch;
			}
		now=0;
		C[0].clear();
		C[0][mp(mp(0ll,0),mp(0,-1))]=1;
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=m;j++)
			{
				C[now^1].clear();
				if (M[i][j]=='.') work(i,j,0),work(i,j,1);
				else if (M[i][j]=='o') work(i,j,0);
				else work(i,j,1);
				now^=1;
			}
		int ans=0;
		for (it=C[now].begin();it!=C[now].end();it++)
		{
			static int aa[11],bb[11];
			int X=(*it).fi.fi.fi,Y=(*it).fi.fi.se,ff=(*it).se;
			repack(aa,X,bb,Y);
			int n0=0,n1=0;
			static bool vt[11];
			memset(vt,0,sizeof(vt));
			for (int k=1;k&lt;=m;k++)
			{
				if (vt[aa[k]]) continue;
				vt[aa[k]]=true;
				if (bb[k]==0) n0++;else n1++;
			}
			if (n0&lt;=1&amp;&amp;n1&lt;=1) ans+=ff;
		}
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem3336</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;map&gt;
using namespace std;
typedef pair&lt;int,int&gt; pii;
#define mp make_pair
#define fi first
#define se second
char M[11][11];
int tes,n,m,now;
map&lt;pair&lt;pii,pii&gt;,int&gt; C[2];
map&lt;pair&lt;pii,pii&gt;,int&gt;::iterator it;
pii pack(int *a,int *b)
{
	int res2=0,i;
	for (i=1;i&lt;=m;i++) res2=res2&lt;&lt;1|b[i];
	static int dy[11];
	memset(dy,-1,sizeof(dy));
	int cnt=0,res1=0;
	for (i=1;i&lt;=m;i++)
	{
		if (dy[a[i]]==-1) dy[a[i]]=cnt++;
		a[i]=dy[a[i]];
		res1=res1&lt;&lt;3|a[i];
	}
	return mp(res1,res2);
}
void repack(int *a,int X,int *b,int Y)
{
	for (int i=m;i;i--)
	{
		a[i]=X&amp;7;X&gt;&gt;=3;
		b[i]=Y&amp;1;Y&gt;&gt;=1;
	}
}
void work(int i,int j,int cc)
{
	static int a[11],b[11],aa[11],bb[11];
	for (it=C[now].begin();it!=C[now].end();it++)
	{
		int X=(*it).fi.fi.fi,Y=(*it).fi.fi.se;
		int PP=(*it).fi.se.fi,must=(*it).fi.se.se,ff=(*it).se,k;
		repack(aa,X,bb,Y);
		if (i&gt;1&amp;&amp;j&gt;1&amp;&amp;PP==cc&amp;&amp;bb[j]==cc&amp;&amp;bb[j-1]==cc) continue;
		if (must!=-1&amp;&amp;cc!=must) continue;
		for (k=1;k&lt;=m;k++) a[k]=aa[k],b[k]=bb[k];
		if (i&gt;1&amp;&amp;bb[j]==cc) a[j]=aa[j];
		else a[j]=9;
		if (j&gt;1&amp;&amp;bb[j-1]==cc)
		{
			int t=a[j-1];
			for (k=1;k&lt;=m;k++) if (a[k]==t) a[k]=a[j];
		}
		b[j]=cc;
		int P=bb[j];
		if (i&gt;1&amp;&amp;bb[j]!=cc)
		{
			bool flag=false;
			for (k=1;k&lt;=m;k++) if (a[k]==aa[j]) flag=true;
			if (!flag)
			{
				flag=false;
				for (k=1;k&lt;=m;k++) if (b[k]==(cc^1)) flag=true;
				if (flag) continue;
				if (must!=-1&amp;&amp;cc!=must) continue;
				C[now^1][mp(pack(a,b),mp(P,cc))]+=ff;
				continue;
			}
		}
		C[now^1][mp(pack(a,b),mp(P,must))]+=ff;
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		int i,j;
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=m;j++)
			{
				char ch=getchar();
				while (ch!='.'&amp;&amp;ch!='#'&amp;&amp;ch!='o') ch=getchar();
				M[i][j]=ch;
			}
		now=0;
		C[0].clear();
		C[0][mp(mp(0ll,0),mp(0,-1))]=1;
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=m;j++)
			{
				C[now^1].clear();
				if (M[i][j]=='.') work(i,j,0),work(i,j,1);
				else if (M[i][j]=='o') work(i,j,0);
				else work(i,j,1);
				now^=1;
			}
		int ans=0;
		for (it=C[now].begin();it!=C[now].end();it++)
		{
			static int aa[11],bb[11];
			int X=(*it).fi.fi.fi,Y=(*it).fi.fi.se,ff=(*it).se;
			repack(aa,X,bb,Y);
			int n0=0,n1=0;
			static bool vt[11];
			memset(vt,0,sizeof(vt));
			for (int k=1;k&lt;=m;k++)
			{
				if (vt[aa[k]]) continue;
				vt[aa[k]]=true;
				if (bb[k]==0) n0++;else n1++;
			}
			if (n0&lt;=1&amp;&amp;n1&lt;=1) ans+=ff;
		}
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem3343</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
int a0[1000111],belong[1000111];
int n,m,blo,num;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
	if (f) x=-x;
}
struct Kuai
{
	int tag,id,st,ed,cnt,a[1011],b[1011];
	void out()
	{
		printf(&quot;id=%d tag=%d st=%d ed=%d cnt=%d\n&quot;,id,tag,st,ed,cnt);
		printf(&quot;  a &quot;);for(int i=1;i&lt;=cnt;i++)printf(&quot;%d &quot;,a[i]);printf(&quot;  b &quot;);for(int i=1;i&lt;=cnt;i++)printf(&quot;%d &quot;,b[i]);ln;
	}
	void in(int _id,int from)
	{
		id=_id;
		st=from,ed=min(from+blo-1,n);
		for (int i=st;i&lt;=ed;i++)
		{
			belong[i]=id;
			a[i-st+1]=b[i-st+1]=a0[i];
		}
		cnt=ed-st+1;
		sort(b+1,b+cnt+1);
	}
	void change(int l,int r,int x)
	{
		int i;
		for (i=l;i&lt;=r;i++) a[i-st+1]+=x;
		for (i=1;i&lt;=cnt;i++) b[i]=a[i];
		sort(b+1,b+cnt+1);
	}
	int find0(int x)
	{
		//printf(&quot;kuai[%d].find(%d)\n&quot;,id,x);
		x-=tag;
		int l=1,r=cnt,res=cnt+1;
		while (l&lt;=r)
		{
			int mid=(l+r)&gt;&gt;1;
			if (b[mid]&gt;=x) res=mid,r=mid-1;
			else l=mid+1;
		}
		return cnt-res+1;
	}
	int find(int l,int r,int x)
	{
		x-=tag;
		int res=0;
		for (int i=l;i&lt;=r;i++)
			if (a[i-st+1]&gt;=x) res++;
		return res;
	}
} kuai[1011];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	int i,l,r,x;
	for (i=1;i&lt;=n;i++) read(a0[i]);
	blo=(int)sqrt(n)+1;
	//printf(&quot;blo=%d\n&quot;,blo);
	for (i=1;i&lt;=n;i+=blo)
	{
		num++;
		kuai[num].in(num,i);
	}
	//printf(&quot;belong &quot;);for(i=1;i&lt;=n;i++)printf(&quot;%d &quot;,belong[i]);ln;
	for (;m;m--)
	{
		//printf(&quot;\n-------------------------------------------------------------------------\n&quot;);for(i=1;i&lt;=num;i++)kuai[i].out();ln;
		char ch=getchar();
		while (ch!='A'&amp;&amp;ch!='M') ch=getchar();
		read(l),read(r),read(x);
		if (ch=='M')
		{
			int L=belong[l],R=belong[r];
			if (L==R)
			{
				kuai[belong[l]].change(l,r,x);
				continue;
			}
			for (i=L+1;i&lt;R;i++) kuai[i].tag+=x;
			kuai[L].change(l,kuai[L].ed,x);
			kuai[R].change(kuai[R].st,r,x);
		}
		else
		{
			int L=belong[l],R=belong[r];
			if (L==R)
			{
				printf(&quot;%d\n&quot;,kuai[L].find(l,r,x));
				continue;
			}
			int res=0;
			for (i=L+1;i&lt;R;i++)
				res+=kuai[i].find0(x);
			//printf(&quot;res=%d\n&quot;,res);
			res+=kuai[L].find(l,kuai[L].ed,x);
			res+=kuai[R].find(kuai[R].st,r,x);
			printf(&quot;%d\n&quot;,res);
		}
	}
	return 0;
}<pre><h2>Problem3343</h2><pre>#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
using namespace std;
int a[1000100],b[1000100],pos[1000100],w[10010];
int n,m,q,t,block;

inline int min(int a,int b){return(a&lt;b)?a:b;}
inline int read(){
	int t=0,f=1;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
	while (ch&gt;='0'&amp;&amp;ch&lt;='9')t=t*10+ch-'0',ch=getchar();
	return t*f;
}

void reset(int p){
	int l=(p-1)*block+1,r=min(l+block-1,n);
	for (int i=l;i&lt;=r;i++)
		b[i]=a[i];
	sort(b+l,b+r+1);
}

void update(int l,int r,int t){
	int x=pos[l],y=pos[r];
	if (x==y){
		for (int i=l;i&lt;=r;i++)
			a[i]+=t;
		reset(x);
	}
	else{
		for (int i=l;pos[i]==x;i++)
			a[i]+=t;
		for (int i=r;pos[i]==y;i--)
			a[i]+=t;
		reset(x);reset(y);
	}
	for (int i=x+1;i&lt;=y-1;i++)
		w[i]+=t;
}

int query(int l,int r,int c){
	int x=pos[l],y=pos[r];
	int res=0;
	if (x==y){
		for (int i=l;i&lt;=r;i++)
			if (a[i]+w[x]&gt;=c)res++;
	}
	else{
		for (int i=l;pos[i]==x;i++)
			if (a[i]+w[x]&gt;=c)res++;
		for (int i=r;pos[i]==y;i--)
			if (a[i]+w[y]&gt;=c)res++;
	}
	for (int i=x+1;i&lt;=y-1;i++){
		int L=(i-1)*block+1,R=min(L+block-1,n);//手写二分要熟练！ 
		int last=R;
		while (L&lt;=R){
			int mid=(L+R)&gt;&gt;1;
			if (b[mid]+w[i]&lt;c)L=mid+1;
			else R=mid-1;
		}
		res+=last-L+1;
	}
	return res;
}

int main(){
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	n=read();
	q=read();
	block=sqrt(n);
	for (int i=1;i&lt;=n;i++)
		b[i]=a[i]=read(),pos[i]=(i-1)/block+1;//每一块是k*block+1到 （k+1）*bolck； 
	m=n/block;
	if (n%block)
		m++;
	for (int i=1;i&lt;=m;i++)
		reset(i);
	for (int i=1;i&lt;=q;i++){
		char s[10];int x,y,t;
		scanf(&quot;%s%d%d%d\n&quot;,s,&amp;x,&amp;y,&amp;t);
		if (s[0]=='A')printf(&quot;%d\n&quot;,query(x,y,t));
		else update(x,y,t);
	}		
	return 0;
}<pre><h2>Problem3354</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;cstring&gt;
#include&lt;cctype&gt;
#define fi first
#define se second
#define INF 100000000
#define N 500005
typedef long long LL;
using namespace std;
typedef pair&lt;double,int&gt; pii;
priority_queue&lt;int&gt; q;
double w,c=0,qs=1;
int n;
pii p[N];
int main()
{
    int i,ans=0,ma=0;
    double s;
   // freopen(&quot;hiring.in&quot;,&quot;r&quot;,stdin);
    //freopen(&quot;hiring.out&quot;,&quot;w&quot;,stdout);
    cin&gt;&gt;n&gt;&gt;w;
    for(i=1;i&lt;=n;i++)
    {
        scanf(&quot;%lf%d&quot;,&amp;p[i].fi,&amp;p[i].se);
        p[i].fi/=p[i].se;
    }
    sort(p+1,p+1+n);
    q.push(0);
    for(i=1;i&lt;=n;i++)
    {
        s=p[i].fi*p[i].se;
        c=c/qs*p[i].fi;
        qs=p[i].fi;
        while(w&lt;c)
        {
            c-=q.top()*p[i].fi;
            q.pop();
            ans--;
        }
        while(q.top()&gt;p[i].se&amp;&amp;w-c&lt;s)
        {
            c-=q.top()*p[i].fi;
            q.pop();
            ans--;
        }
        if(w-c&gt;=s)
        {
            ans++;
            c+=s;
            q.push(p[i].se);
        }
        ma=max(ma,ans);
    }
    cout&lt;&lt;ma&lt;&lt;endl;
    return 0;
}<pre><h2>Problem3365</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define M 40400
using namespace std;
struct abcd{
	int to,f,next;
	bool ban;
}table[M&lt;&lt;1];
int head[M],tot=1;
int n,m,k,ans;
int siz[M],fa[M],dist[M];
int stack[M],top;
void Add(int x,int y,int z)
{
	table[++tot].to=y;
	table[tot].f=z;
	table[tot].next=head[x];
	head[x]=tot;
	table[tot].ban=0;
}
void Get_Centre_Of_Gravity(int x,int size,int &amp;cg)
{
	int i;
	bool flag=1;
	siz[x]=1;
	for(i=head[x];i;i=table[i].next)
		if(!table[i].ban)
			if(table[i].to!=fa[x])
			{
				fa[table[i].to]=x;
				Get_Centre_Of_Gravity(table[i].to,size,cg);
				if(siz[table[i].to]&gt;size&gt;&gt;1)
					flag=0;
				siz[x]+=siz[table[i].to];
			}
	if(size-siz[x]&gt;size&gt;&gt;1)
		flag=0;
	if(flag)
		cg=x;
}
void DFS1(int x,int dis)
{
	int i;
	dist[x]=dis;
	for(i=head[x];i;i=table[i].next)
	{
		if(table[i].ban)
			continue;
		if(table[i].to==fa[x])
			continue;
		fa[table[i].to]=x;
		DFS1(table[i].to,dis+table[i].f);
	}
}
void DFS2(int x)
{
	int i;
	stack[++top]=dist[x];
	for(i=head[x];i;i=table[i].next)
	{
		if(table[i].ban)
			continue;
		if(table[i].to==fa[x])
			continue;
		DFS2(table[i].to);
	}
}
int Calculate(int root)
{
	int i,j,re=0;
	top=0;
	DFS2(root);
	sort(stack+1,stack+top+1);
	for(i=1,j=top;i&lt;=top;i++)
	{
		for(;j&amp;&amp;stack[j]+stack[i]&gt;k;j--);
		re+=j;
	}
	return re;
}
void Tree_Divide_And_Conquer(int root,int size)
{
	int i,cg;
	fa[root]=0;
	Get_Centre_Of_Gravity(root,size,cg);
	siz[fa[cg]]=size-siz[cg];
	fa[cg]=0;
	DFS1(cg,0);
	ans+=Calculate(cg);
	for(i=head[cg];i;i=table[i].next)
		if(!table[i].ban)
		{
			table[i].ban=table[i^1].ban=1;
			ans-=Calculate(table[i].to);
			Tree_Divide_And_Conquer(table[i].to,siz[table[i].to]);
		}			
}
int main()
{
	int i,x,y,z;
	char p[10];
	cin&gt;&gt;n&gt;&gt;m;
	for(i=1;i&lt;n;i++)
		scanf(&quot;%d%d%d%s&quot;,&amp;x,&amp;y,&amp;z,p),Add(x,y,z),Add(y,x,z);
	cin&gt;&gt;k;
	Tree_Divide_And_Conquer(1,n);
	cout&lt;&lt;(ans-n&gt;&gt;1)&lt;&lt;endl;
}
<pre><h2>Problem3398</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int NN=100005,mo=5000011;
int f[NN],g[NN],n,K;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	f[0]=1;
	for (int i=1;i&lt;=n;i++)
	{
		f[i]=f[i-1]+g[i-1];
		if (i-K-1&gt;0) g[i]=f[i-K-1]+g[i-K-1];
		else g[i]=1;
		f[i]%=mo,g[i]%=mo;
	}
	printf(&quot;%d\n&quot;,(f[n]+g[n])%mo);
	return 0;
}<pre><h2>Problem3398</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int NN=100005,mo=5000011;
int f[NN],g[NN],n,K;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	f[0]=1;
	for (int i=1;i&lt;=n;i++)
	{
		f[i]=f[i-1]+g[i-1];
		if (i-K-1&gt;0) g[i]=f[i-K-1]+g[i-K-1];
		else g[i]=1;
		if (f[i]&gt;mo) f[i]-=mo;
		if (g[i]&gt;mo) g[i]-=mo;
	}
	printf(&quot;%d\n&quot;,(f[n]+g[n])%mo);
	return 0;
}<pre><h2>Problem3398</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int NN=100005,mo=5000011;
int f[NN],g[NN],n,K;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	f[0]=1;
	int *x,*y,i;
	for (i=1,x=&amp;f[1],y=&amp;g[1];i&lt;=n;i++,x++,y++)
	{
		*x=*(x-1)+*(y-1);
		if (i-K-1&gt;0) *y=*(x-K-1)+*(y-K-1);
		else *y=1;
		if (*x&gt;mo) *x-=mo;
		if (*y&gt;mo) *y-=mo;
	}
	printf(&quot;%d\n&quot;,(f[n]+g[n])%mo);
	return 0;
}<pre><h2>Problem3398</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int NN=100001,mo=5000011;
int f[NN],g[NN],n,K;
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	f[0]=1;
	int *x,*y,i;
	for (i=1,x=&amp;f[1],y=&amp;g[1];i&lt;=n;i++,x++,y++)
	{
		*x=*(x-1)+*(y-1);
		if (i-K-1&gt;0) *y=*(x-K-1)+*(y-K-1);
		else *y=1;
		if (*x&gt;mo) *x-=mo;
		if (*y&gt;mo) *y-=mo;
	}
	printf(&quot;%d\n&quot;,(f[n]+g[n])%mo);
	return 0;
}<pre><h2>Problem3434</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
typedef long long LL;
#define mo 10007
#define inf 999999999
#define pb push_back
int f[21][100111],g[12][19][100111],C[100111][21];
int tes,n,c,maxmi;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar());
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
}
struct info
{
	int n,c;
	vector&lt;int&gt; m;
	void in()
	{
		m.pb(0);
		read(n),read(c);
		for (int i=1;i&lt;=n;i++)
		{
			int x;
			read(x);
			m.pb(x);
			if (x&gt;maxmi) maxmi=x;
		}
	}
} q[1001];
inline int ksm(int a,int b,int c)
{
    int res=1;
    for (a%=c;b;b&gt;&gt;=1,a=a*a%c)
        if (b&amp;1) res=res*a%c;
    return res;
}
void shai()
{
    static bool vt[100111];
    static int miu[100111],pr[10111];
    int i,j,k,prcnt=0;
    vt[1]=true;
    miu[1]=1;
    for (i=2;i&lt;=maxmi;i++)
    {
        if (!vt[i])
        {
            pr[++prcnt]=i;
            miu[i]=-1;
        }
        for (j=1;j&lt;=prcnt;j++)
        {
            int x=i*pr[j];
            if (x&gt;maxmi) break;
            vt[x]=true;
            if (i%pr[j]==0)
            {
                miu[x]=0;
                break;
            }
            miu[x]=-miu[i];
        }
    }
    C[0][0]=1;
    for (i=1;i&lt;=maxmi;i++)
    {
        C[i][0]=1;
        for (j=1;j&lt;=20;j++)
        {
            C[i][j]=C[i-1][j-1]+C[i-1][j];
            if (C[i][j]&gt;=mo) C[i][j]-=mo;
        }
    }
    for (i=1;i&lt;=maxmi;i++)
    {
        for (j=i;j&lt;=maxmi;j+=i)
            for (k=0;k&lt;=18;k++)
            {
                f[k][j]+=C[i-1][k]*miu[j/i];
                if (f[k][j]&gt;=mo) f[k][j]-=mo;
                if (f[k][j]&lt;0) f[k][j]+=mo;
            }
    }
    for (i=1;i&lt;=maxmi;i++)
    {
        int tmp=1,t=i%mo;
        for (j=0;j&lt;=11;j++)
        {
            for (k=0;k&lt;=18;k++)
            {
                g[j][k][i]=g[j][k][i-1]+tmp*f[k][i];
                if (g[j][k][i]&gt;1000000000) g[j][k][i]%=mo;
            }
            tmp=tmp*t%mo;
        }
    }
}
int main()
{
	scanf(&quot;%d&quot;,&amp;tes);
	for (int i=1;i&lt;=tes;i++) q[i].in();
    shai();
    for (int tt=1;tt&lt;=tes;tt++)
    {
        n=q[tt].n,c=q[tt].c;
        c-=2;
        int mm=inf,i,j;
        static int m[12];
        for (i=1;i&lt;=n;i++)
        {
            m[i]=q[tt].m[i];
            if (m[i]&lt;mm) mm=m[i];
        }
        int ans=0,l,r;
        static int a[13],b[13];
        for (l=1;l&lt;=mm;l=r+1)
        {
            r=inf;
            for (i=1;i&lt;=n;i++)
                r=min(r,m[i]/(m[i]/l));
            a[0]=1;
            for (i=1;i&lt;=n;i++) a[i]=0;
            for (i=1;i&lt;=n;i++)
            {
                for (j=0;j&lt;=n;j++) b[j]=0;
                int tmp=(LL)m[i]*(m[i]/l)%mo;
                for (j=0;j&lt;=n;j++) b[j]+=a[j]*tmp%mo;
                tmp=(LL)(m[i]/l)*(m[i]/l+1)/2%mo;
                for (j=0;j&lt;=n;j++)
                    (b[j+1]-=a[j]*tmp)%=mo;
                for (j=0;j&lt;=n;j++) a[j]=b[j];
            }
            for (j=0;j&lt;=n;j++)
                (ans+=a[j]*(g[j][c][r]%mo-g[j][c][l-1]%mo))%=mo;
        }
        if (ans&lt;0) ans+=mo;
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}<pre><h2>Problem3435</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef double DD;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
#define inf 999999999
const DD alfa=0.8;
const int NN=100111,AA=4000000;
int o[NN],aa[NN&lt;&lt;1][2],R[NN];
int n,tot=1,TTT;
LL lastans;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9')
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar();
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
struct Tree
{
	int fa[NN],deep[NN],dist[NN],f[18][NN];
	void insert(int x,int ff,int dd)
	{
		fa[x]=ff;
		if (ff) addedge(x,ff),addedge(ff,x);
		deep[x]=deep[ff]+1;
		dist[x]=dist[ff]+dd;
		f[0][x]=ff;
		for (int j=1;j&lt;=17;j++)
			f[j][x]=f[j-1][f[j-1][x]];
	}
	inline int getlca(int x,int y)
	{
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		for (int i=17;i&gt;=0;i--)
			if (deep[f[i][x]]&gt;=deep[y]) x=f[i][x];
		if (x==y) return x;
		for (int i=17;i&gt;=0;i--)
			if (f[i][x]!=f[i][y]) x=f[i][x],y=f[i][y];
		return f[0][x];
	}
	inline int getdist(int x,int y)
	{
		int lca=getlca(x,y);
		return dist[x]+dist[y]-dist[lca]-dist[lca];
	}
} tree;
struct splaynode
{
	int fa,sz,s[2],num,key;
	inline void clear() {fa=sz=s[0]=s[1]=num=key=0;}
} T[AA];
struct huishouzhan
{
	int sta[AA],top;
	inline void push(int v)
	{
		T[v].clear();
		sta[++top]=v;
	}
	inline int go()
	{
		if (top) return sta[top--];
		return ++TTT;
	}
} box;
struct splaytree
{
	int root,id;
	inline void update(int t)
	{
		T[t].sz=T[T[t].s[0]].sz+T[T[t].s[1]].sz+T[t].num;
	}
	inline void rotate(int t,int p)
	{
		int y=T[t].fa;
		if (T[y].fa)
		{
			if (y==T[T[y].fa].s[0]) T[T[y].fa].s[0]=t;
			else T[T[y].fa].s[1]=t;
		}
		T[t].fa=T[y].fa;
		T[y].s[p^1]=T[t].s[p];
		if (T[t].s[p]) T[T[t].s[p]].fa=y;
		T[t].s[p]=y;
		T[y].fa=t;
		update(y),update(t);
	}
	void splay(int t,int ff)
	{
		while (T[t].fa!=ff)
		{
			int y=T[t].fa;
			if (T[y].fa==ff)
				if (t==T[y].s[0]) rotate(t,1);
				else rotate(t,0);
			else
				if (y==T[T[y].fa].s[0])
					if (t==T[y].s[0]) rotate(y,1),rotate(t,1);
					else rotate(t,0),rotate(t,1);
				else
					if (t==T[y].s[1]) rotate(y,0),rotate(t,0);
					else rotate(t,1),rotate(t,0);
		}
		update(t);
		if (ff==0) root=t;
	}
	void ins(int &amp;v,int x,int ff)
	{
		if (v==0)
		{
			v=box.go();
			T[v].fa=ff;
			T[v].key=x;
			T[v].sz=T[v].num=1;
			splay(v,0);
		}
		else if (x==T[v].key)
			T[v].num++,splay(v,0);
		else if (x&lt;T[v].key) ins(T[v].s[0],x,v);
		else ins(T[v].s[1],x,v);
	}
	inline void insert(int x)
	{
		//if(id&gt;0)printf(&quot;E1[%d].ins(%d)\n&quot;,id,x);else printf(&quot;E2[%d].ins(%d)\n&quot;,-id,x);
		ins(root,x,0);
	}
	inline int size() {return T[root].sz;}
	inline int find(int x)
	{
		int t=root,res=0;
		while (t)
		{
			int tmp=t;
			if (x&lt;T[t].key) t=T[t].s[0];
			else res+=T[T[t].s[0]].sz+T[t].num,t=T[t].s[1];
			if (t==0) splay(tmp,0);
		}
		//if(id&gt;0)printf(&quot;E1[%d].find(%d) &quot;,id,x);else printf(&quot;E2[%d].find(%d) &quot;,-id,x);printf(&quot;res=%d\n&quot;,res);
		return res;
	}
	void huishou(int v)
	{
		if (!v) return;
		huishou(T[v].s[0]),huishou(T[v].s[1]);
		box.push(v);
	}
	inline void huishou()
	{
		//if(id&gt;0)printf(&quot;  E1[%d].huishou\n&quot;,id);else printf(&quot;  E2[%d].huishou\n&quot;,-id);
		huishou(root);root=0;
	}
} E1[NN],E2[NN];
struct TDC
{
	int deep[NN],b[NN],size[NN],fa[NN],boss[NN],cnt;
	void dfs0(int v,int limit)
	{
		deep[v]=inf;
		b[++cnt]=v;
		E1[v].huishou(),E2[v].huishou();
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[v]||deep[y]&lt;=limit) continue;
			fa[y]=v;
			dfs0(y,limit);
		}
	}
	void calcsize(int v)
	{
		size[v]=1;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[v]||deep[y]&lt;deep[v]) continue;
			fa[y]=v;
			calcsize(y);
			size[v]+=size[y];
		}
	}
	int getcore(int v)
	{
		fa[v]=0,calcsize(v);
		for (;;)
		{
			bool flag=false;
			for (int p=o[v];p;p=aa[p][0])
			{
				int y=aa[p][1];
				if (deep[y]&lt;deep[v]) continue;
				if (size[y]&lt;&lt;1&gt;size[v])
				{
					size[v]-=size[y];
					size[y]+=size[v];
					v=y;flag=true;break;
				}
			}
			if (!flag) break;
		}
		return v;
	}
	void work(int v)
	{
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (deep[y]&lt;deep[v]) continue;
			y=getcore(y);
			deep[y]=deep[v]+1;
			boss[y]=v;
			work(y);
		}
	}
	void rebuild(int x)
	{
		int ff=boss[x];
		cnt=0;
		fa[x]=0,dfs0(x,deep[ff]);
		x=getcore(x);
		deep[x]=deep[ff]+1;
		work(x);
		boss[x]=ff;
		for (int i=1;i&lt;=cnt;i++)
		{
			int x=b[i];
			E1[x].insert(-R[x]);
			for (int y=x;y!=ff;y=boss[y])
			{
				int t=boss[y];
				int dd=tree.getdist(x,t);
				if (t!=ff) E1[t].insert(dd-R[x]);
				E2[y].insert(dd-R[x]);
			}
		}
	}
	void insert(int x,int ff)
	{
		boss[x]=ff;
		deep[x]=deep[ff]+1;
		E1[x].insert(-R[x]);
		int need=0;
		for (int y=x;boss[y];y=boss[y])
		{
			ff=boss[y];
			int dd=tree.getdist(x,ff);
			lastans+=E1[ff].find(R[x]-dd);
			lastans-=E2[y].find(R[x]-dd);
			E1[ff].insert(dd-R[x]);
			E2[y].insert(dd-R[x]);
			if (E1[y].size()&gt;E1[ff].size()*alfa) need=ff;
		}
		if (need) rebuild(need);
	}
} tdc;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,x,y;
	read(x),read(n);
	for (i=1;i&lt;=n;i++) E1[i].id=i,E2[i].id=-i;
	for (i=1;i&lt;=n;i++)
	{
		read(x),read(y),read(R[i]);
		x^=(lastans%1000000000);
		tree.insert(i,x,y);
		tdc.insert(i,x);
		printf(&quot;%lld\n&quot;,lastans);
	}
	return 0;
}<pre><h2>Problem3435</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef double DD;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
#define inf 999999999
const DD alfa=0.8;
const int NN=100111,AA=3500000;
int o[NN],aa[NN&lt;&lt;1][2],R[NN];
int n,tot=1,TTT;
LL lastans;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9')
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar();
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
struct Tree
{
	int fa[NN],deep[NN],dist[NN],f[18][NN];
	void insert(int x,int ff,int dd)
	{
		fa[x]=ff;
		if (ff) addedge(x,ff),addedge(ff,x);
		deep[x]=deep[ff]+1;
		dist[x]=dist[ff]+dd;
		f[0][x]=ff;
		for (int j=1;j&lt;=17;j++)
			f[j][x]=f[j-1][f[j-1][x]];
	}
	inline int getlca(int x,int y)
	{
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		for (int i=17;i&gt;=0;i--)
			if (deep[f[i][x]]&gt;=deep[y]) x=f[i][x];
		if (x==y) return x;
		for (int i=17;i&gt;=0;i--)
			if (f[i][x]!=f[i][y]) x=f[i][x],y=f[i][y];
		return f[0][x];
	}
	inline int getdist(int x,int y)
	{
		int lca=getlca(x,y);
		return dist[x]+dist[y]-dist[lca]-dist[lca];
	}
} tree;
struct splaynode
{
	int fa,sz,s[2],num,key;
	inline void clear() {fa=sz=s[0]=s[1]=num=key=0;}
} T[AA];
struct huishouzhan
{
	int sta[AA],top;
	inline void push(int v)
	{
		T[v].clear();
		sta[++top]=v;
	}
	inline int go()
	{
		if (top) return sta[top--];
		return ++TTT;
	}
} box;
struct splaytree
{
	int root;
	inline void update(int t)
	{
		T[t].sz=T[T[t].s[0]].sz+T[T[t].s[1]].sz+T[t].num;
	}
	inline void rotate(int t,int p)
	{
		int y=T[t].fa;
		if (T[y].fa)
		{
			if (y==T[T[y].fa].s[0]) T[T[y].fa].s[0]=t;
			else T[T[y].fa].s[1]=t;
		}
		T[t].fa=T[y].fa;
		T[y].s[p^1]=T[t].s[p];
		if (T[t].s[p]) T[T[t].s[p]].fa=y;
		T[t].s[p]=y;
		T[y].fa=t;
		update(y),update(t);
	}
	void splay(int t,int ff)
	{
		while (T[t].fa!=ff)
		{
			int y=T[t].fa;
			if (T[y].fa==ff)
				if (t==T[y].s[0]) rotate(t,1);
				else rotate(t,0);
			else
				if (y==T[T[y].fa].s[0])
					if (t==T[y].s[0]) rotate(y,1),rotate(t,1);
					else rotate(t,0),rotate(t,1);
				else
					if (t==T[y].s[1]) rotate(y,0),rotate(t,0);
					else rotate(t,1),rotate(t,0);
		}
		update(t);
		if (ff==0) root=t;
	}
	void ins(int &amp;v,int x,int ff)
	{
		if (v==0)
		{
			v=box.go();
			T[v].fa=ff;
			T[v].key=x;
			T[v].sz=T[v].num=1;
			splay(v,0);
		}
		else if (x==T[v].key)
			T[v].num++,splay(v,0);
		else if (x&lt;T[v].key) ins(T[v].s[0],x,v);
		else ins(T[v].s[1],x,v);
	}
	inline void insert(int x){ins(root,x,0);}
	inline int size() {return T[root].sz;}
	inline int find(int x)
	{
		int t=root,res=0;
		while (t)
		{
			int tmp=t;
			if (x&lt;T[t].key) t=T[t].s[0];
			else res+=T[T[t].s[0]].sz+T[t].num,t=T[t].s[1];
			if (t==0) splay(tmp,0);
		}
		return res;
	}
	void huishou(int v)
	{
		if (!v) return;
		huishou(T[v].s[0]),huishou(T[v].s[1]);
		box.push(v);
	}
	inline void huishou(){huishou(root);root=0;}
} E1[NN],E2[NN];
struct TDC
{
	int deep[NN],b[NN],size[NN],fa[NN],boss[NN],cnt;
	void dfs0(int v,int limit)
	{
		deep[v]=inf;
		b[++cnt]=v;
		E1[v].huishou(),E2[v].huishou();
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[v]||deep[y]&lt;=limit) continue;
			fa[y]=v;
			dfs0(y,limit);
		}
	}
	void calcsize(int v)
	{
		size[v]=1;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[v]||deep[y]&lt;deep[v]) continue;
			fa[y]=v;
			calcsize(y);
			size[v]+=size[y];
		}
	}
	int getcore(int v)
	{
		fa[v]=0,calcsize(v);
		for (;;)
		{
			bool flag=false;
			for (int p=o[v];p;p=aa[p][0])
			{
				int y=aa[p][1];
				if (deep[y]&lt;deep[v]) continue;
				if (size[y]&lt;&lt;1&gt;size[v])
				{
					size[v]-=size[y];
					size[y]+=size[v];
					v=y;flag=true;break;
				}
			}
			if (!flag) break;
		}
		return v;
	}
	void work(int v)
	{
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (deep[y]&lt;deep[v]) continue;
			y=getcore(y);
			deep[y]=deep[v]+1;
			boss[y]=v;
			work(y);
		}
	}
	void rebuild(int x)
	{
		int ff=boss[x];
		cnt=0;
		fa[x]=0,dfs0(x,deep[ff]);
		x=getcore(x);
		deep[x]=deep[ff]+1;
		work(x);
		boss[x]=ff;
		for (int i=1;i&lt;=cnt;i++)
		{
			int x=b[i];
			E1[x].insert(-R[x]);
			for (int y=x;y!=ff;y=boss[y])
			{
				int t=boss[y];
				int dd=tree.getdist(x,t);
				if (t!=ff) E1[t].insert(dd-R[x]);
				E2[y].insert(dd-R[x]);
			}
		}
	}
	void insert(int x,int ff)
	{
		boss[x]=ff;
		deep[x]=deep[ff]+1;
		E1[x].insert(-R[x]);
		int need=0;
		for (int y=x;boss[y];y=boss[y])
		{
			ff=boss[y];
			int dd=tree.getdist(x,ff);
			lastans+=E1[ff].find(R[x]-dd);
			lastans-=E2[y].find(R[x]-dd);
			E1[ff].insert(dd-R[x]);
			E2[y].insert(dd-R[x]);
			if (E1[y].size()&gt;E1[ff].size()*alfa) need=ff;
		}
		if (need) rebuild(need);
	}
} tdc;
int main()
{
	int i,x,y;
	read(x),read(n);
	for (i=1;i&lt;=n;i++)
	{
		read(x),read(y),read(R[i]);
		x^=(lastans%1000000000);
		tree.insert(i,x,y);
		tdc.insert(i,x);
		printf(&quot;%lld\n&quot;,lastans);
	}
	return 0;
}<pre><h2>Problem3435</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef double DD;
typedef long long LL;
#define inf 999999999
const DD alfa=0.8;
const int NN=100111,AA=3500000;
int o[NN],aa[NN&lt;&lt;1][2],R[NN];
int n,tot=1,TTT;
LL lastans;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9')
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar();
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
struct Tree
{
	int fa[NN],deep[NN],dist[NN],f[18][NN];
	void insert(int x,int ff,int dd)
	{
		fa[x]=ff;
		if (ff) addedge(x,ff),addedge(ff,x);
		deep[x]=deep[ff]+1;
		dist[x]=dist[ff]+dd;
		f[0][x]=ff;
		for (int j=1;j&lt;=17;j++)
			f[j][x]=f[j-1][f[j-1][x]];
	}
	inline int getlca(int x,int y)
	{
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		for (int i=17;i&gt;=0;i--)
			if (deep[f[i][x]]&gt;=deep[y]) x=f[i][x];
		if (x==y) return x;
		for (int i=17;i&gt;=0;i--)
			if (f[i][x]!=f[i][y]) x=f[i][x],y=f[i][y];
		return f[0][x];
	}
	inline int getdist(int x,int y)
	{
		int lca=getlca(x,y);
		return dist[x]+dist[y]-dist[lca]-dist[lca];
	}
} tree;
struct splaynode
{
	int fa,sz,s[2],num,key;
	inline void clear() {fa=sz=s[0]=s[1]=num=key=0;}
} T[AA];
struct huishouzhan
{
	int sta[AA],top;
	inline void push(int v)
	{
		T[v].clear();
		sta[++top]=v;
	}
	inline int go()
	{
		if (top) return sta[top--];
		return ++TTT;
	}
} box;
struct splaytree
{
	int root;
	inline void update(int t)
	{
		T[t].sz=T[T[t].s[0]].sz+T[T[t].s[1]].sz+T[t].num;
	}
	inline void rotate(int t,int p)
	{
		int y=T[t].fa;
		if (T[y].fa)
		{
			if (y==T[T[y].fa].s[0]) T[T[y].fa].s[0]=t;
			else T[T[y].fa].s[1]=t;
		}
		T[t].fa=T[y].fa;
		T[y].s[p^1]=T[t].s[p];
		if (T[t].s[p]) T[T[t].s[p]].fa=y;
		T[t].s[p]=y;
		T[y].fa=t;
		update(y),update(t);
	}
	void splay(int t,int ff)
	{
		while (T[t].fa!=ff)
		{
			int y=T[t].fa;
			if (T[y].fa==ff)
				if (t==T[y].s[0]) rotate(t,1);
				else rotate(t,0);
			else
				if (y==T[T[y].fa].s[0])
					if (t==T[y].s[0]) rotate(y,1),rotate(t,1);
					else rotate(t,0),rotate(t,1);
				else
					if (t==T[y].s[1]) rotate(y,0),rotate(t,0);
					else rotate(t,1),rotate(t,0);
		}
		update(t);
		if (ff==0) root=t;
	}
	void ins(int &amp;v,int x,int ff)
	{
		if (v==0)
		{
			v=box.go();
			T[v].fa=ff;
			T[v].key=x;
			T[v].sz=T[v].num=1;
			splay(v,0);
		}
		else if (x==T[v].key)
			T[v].num++,splay(v,0);
		else if (x&lt;T[v].key) ins(T[v].s[0],x,v);
		else ins(T[v].s[1],x,v);
	}
	inline void insert(int x){ins(root,x,0);}
	inline int size() {return T[root].sz;}
	inline int find(int x)
	{
		int t=root,res=0,tmp;
		while (t)
		{
			tmp=t;
			if (x&lt;T[t].key) t=T[t].s[0];
			else res+=T[T[t].s[0]].sz+T[t].num,t=T[t].s[1];
		}
		splay(tmp,0);
		return res;
	}
	void huishou(int v)
	{
		if (!v) return;
		huishou(T[v].s[0]),huishou(T[v].s[1]);
		box.push(v);
	}
	inline void huishou(){huishou(root);root=0;}
} E1[NN],E2[NN];
struct TDC
{
	int deep[NN],b[NN],size[NN],fa[NN],boss[NN],cnt;
	void dfs0(int v,int limit)
	{
		deep[v]=inf;
		b[++cnt]=v;
		E1[v].huishou(),E2[v].huishou();
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[v]||deep[y]&lt;=limit) continue;
			fa[y]=v;
			dfs0(y,limit);
		}
	}
	void calcsize(int v)
	{
		size[v]=1;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[v]||deep[y]&lt;deep[v]) continue;
			fa[y]=v;
			calcsize(y);
			size[v]+=size[y];
		}
	}
	int getcore(int v)
	{
		fa[v]=0,calcsize(v);
		for (;;)
		{
			bool flag=false;
			for (int p=o[v];p;p=aa[p][0])
			{
				int y=aa[p][1];
				if (deep[y]&lt;deep[v]) continue;
				if (size[y]&lt;&lt;1&gt;size[v])
				{
					size[v]-=size[y];
					size[y]+=size[v];
					v=y;flag=true;break;
				}
			}
			if (!flag) break;
		}
		return v;
	}
	void work(int v)
	{
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (deep[y]&lt;deep[v]) continue;
			y=getcore(y);
			deep[y]=deep[v]+1;
			boss[y]=v;
			work(y);
		}
	}
	void rebuild(int x)
	{
		int ff=boss[x];
		cnt=0;
		fa[x]=0,dfs0(x,deep[ff]);
		x=getcore(x);
		deep[x]=deep[ff]+1;
		work(x);
		boss[x]=ff;
		for (int i=1;i&lt;=cnt;i++)
		{
			int x=b[i];
			E1[x].insert(-R[x]);
			for (int y=x;y!=ff;y=boss[y])
			{
				int t=boss[y];
				int dd=tree.getdist(x,t);
				if (t!=ff) E1[t].insert(dd-R[x]);
				E2[y].insert(dd-R[x]);
			}
		}
	}
	void insert(int x,int ff)
	{
		boss[x]=ff;
		deep[x]=deep[ff]+1;
		E1[x].insert(-R[x]);
		int need=0;
		for (int y=x;boss[y];y=boss[y])
		{
			ff=boss[y];
			int dd=tree.getdist(x,ff);
			lastans+=E1[ff].find(R[x]-dd);
			lastans-=E2[y].find(R[x]-dd);
			E1[ff].insert(dd-R[x]);
			E2[y].insert(dd-R[x]);
			if (E1[y].size()&gt;E1[ff].size()*alfa) need=ff;
		}
		if (need) rebuild(need);
	}
} tdc;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,x,y;
	read(x),read(n);
	for (i=1;i&lt;=n;i++)
	{
		read(x),read(y),read(R[i]);
		x^=(lastans%1000000000);
		tree.insert(i,x,y);
		tdc.insert(i,x);
		printf(&quot;%lld\n&quot;,lastans);
	}
	return 0;
}<pre><h2>Problem3436</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int dist[11111],o[11111],aa[11111&lt;&lt;1][3];
int n,m,tot=1;
bool vt[11111];
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
bool dfs(int v)
{
	vt[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (dist[y]&gt;dist[v]+aa[p][2])
			if (vt[y]) return true;
			else
			{
				dist[y]=dist[v]+aa[p][2];
				if (dfs(y)) return true;
			}
	}
	vt[v]=false;
	return false;
}
bool check()
{
	memset(vt,0,sizeof(vt));
	memset(dist,0,sizeof(dist));
	for (int i=1;i&lt;=n;i++)
		if (dfs(i)) return true;
	return false;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;z,&amp;x,&amp;y);
		if (z==1)
		{
			scanf(&quot;%d&quot;,&amp;z);
			addedge(x,y,-z);
		}
		else if (z==2)
		{
			scanf(&quot;%d&quot;,&amp;z);
			addedge(y,x,z);
		}
		else
			addedge(x,y,0),addedge(y,x,0);
	}
	printf(check()?&quot;No\n&quot;:&quot;Yes\n&quot;);
	return 0;
}<pre><h2>Problem3437</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const int NN=1001111;
int a[NN],b[NN],q[NN],n;
LL f[NN],g[NN],sum[NN],sumb[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);
	int i;
	for (i=1;i&lt;=n;i++) read(a[i]);
	for (i=1;i&lt;=n;i++)
	{
		read(b[i]);
		sum[i]=sum[i-1]+(LL)b[i]*(n-i);
		sumb[i]=sumb[i-1]+b[i];
	}
	int head=0,tail=1;
	q[1]=0;
	for (i=1;i&lt;=n;i++)
	{
		int j=q[head+1],k=q[head+2];
		while (head+1&lt;tail&amp;&amp;g[k]-g[j]&lt;=(sumb[k]-sumb[j])*i)
		{
			head++;
			j=k,k=q[head+2];
		}
		f[i]=f[j]+sum[i]-sum[j]-(sumb[i]-sumb[j])*(n-i)+a[i];
		//printf(&quot;%d -&gt; %d\n&quot;,j,i);
		g[i]=f[i]-sum[i]+sumb[i]*n;
		j=q[tail-1],k=q[tail];
		while (head+1&lt;tail&amp;&amp;(g[i]-g[k])*(sumb[k]-sumb[j])&lt;=(g[k]-g[j])*(sumb[i]-sumb[k]))
		{
			tail--;
			k=j,j=q[tail-1];
		}
		q[++tail]=i;
	}
	printf(&quot;%lld\n&quot;,f[n]);
	return 0;
}<pre><h2>Problem3437</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const int NN=1001111;
int a[NN],b[NN],q[NN],n;
LL f[NN],g[NN],sum[NN],sumb[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
int main()
{
	read(n);
	int i;
	for (i=1;i&lt;=n;i++) read(a[i]);
	for (i=1;i&lt;=n;i++)
	{
		read(b[i]);
		sum[i]=sum[i-1]+(LL)b[i]*(n-i);
		sumb[i]=sumb[i-1]+b[i];
	}
	int head=0,tail=1;
	q[1]=0;
	for (i=1;i&lt;=n;i++)
	{
		int j=q[head+1],k=q[head+2];
		while (head+1&lt;tail&amp;&amp;g[k]-g[j]&lt;=(sumb[k]-sumb[j])*i)
		{
			head++;
			j=k,k=q[head+2];
		}
		f[i]=f[j]+sum[i]-sum[j]-(sumb[i]-sumb[j])*(n-i)+a[i];
		g[i]=f[i]-sum[i]+sumb[i]*n;
		j=q[tail-1],k=q[tail];
		while (head+1&lt;tail&amp;&amp;(g[i]-g[k])*(sumb[k]-sumb[j])&lt;=(g[k]-g[j])*(sumb[i]-sumb[k]))
		{
			tail--;
			k=j,j=q[tail-1];
		}
		q[++tail]=i;
	}
	printf(&quot;%lld\n&quot;,f[n]);
	return 0;
}<pre><h2>Problem3450</h2><pre>#include&lt;cstdio&gt;
using namespace std;
double f[301111],g[301111];
char s[301111];
int n;
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d\n%s&quot;,&amp;n,s+1);
	int i;
	for (i=1;i&lt;=n;i++)
		if (s[i]=='o')
		{
			f[i]=f[i-1]+2*g[i-1]+1;
			g[i]=g[i-1]+1;
		}
		else if (s[i]=='x')
		{
			f[i]=f[i-1];
			g[i]=0;
		}
		else
		{
			f[i]=(f[i-1]+2*g[i-1]+1+f[i-1])/2;
			g[i]=(g[i-1]+1)/2;
		}
	printf(&quot;%.4f\n&quot;,f[n]);
	return 0;
}<pre><h2>Problem3450</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define NN 300909
#define LLD long double
#define sqr(x)(x*x)
using namespace std;
int n;
LLD d[NN],f[NN];
char c[NN];
int main(){
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d\n&quot;,&amp;n);
	for (int i=1;i&lt;=n;i++)
		c[i]=getchar();
	for (int i=1;i&lt;=n;i++){
		if (c[i]=='o'){
			d[i]=d[i-1]+1;
			f[i]=f[i-1]+2*d[i-1]+1;
		}
		else if (c[i]=='x'){
			f[i]=f[i-1];
			d[i]=0;
		}
		else if (c[i]=='?'){
			d[i]=(d[i-1]+1)/2;
			f[i]=f[i-1]+d[i-1]+0.5;
		}
	}
	printf(&quot;%.4lf\n&quot;,(double)f[n]);	
    return 0;
}<pre><h2>Problem3451</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
typedef double DD;
#define mo 998244353
#define ln printf(&quot;\n&quot;)
const int NN=60111;
int o[NN],aa[NN&lt;&lt;1][2],size[NN],fa[NN],num[NN],vt[NN],rev[NN&lt;&lt;1],deep[NN];
int n,tot=1,TIME,dep,N,L;
LL ans[NN&lt;&lt;1];
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);ln;}
void out(LL *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%I64d &quot;,a[i]);ln;}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (a%=c;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
void calcsize(int v)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||deep[y]&lt;deep[v]) continue;
		fa[y]=v;
		calcsize(y);
		size[v]+=size[y];
	}
}
int getcore(int v)
{
	fa[v]=0,calcsize(v);
	for (;;)
	{
		bool flag=false;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (deep[y]&lt;deep[v]) continue;
			if (size[y]&lt;&lt;1&gt;size[v])
			{
				size[v]-=size[y];
				size[y]+=size[v];
				v=y;flag=true;break;
			}
		}
		if (!flag) break;
	}
	return v;
}
void dfs(int v,int d)
{
	if (vt[d]==TIME) num[d]++;
	else vt[d]=TIME,num[d]=1;
	if (d&gt;dep) dep=d;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||deep[y]&lt;deep[v]) continue;
		fa[y]=v;
		dfs(y,d+1);
	}
}
void ntt(LL *a,int ff)
{
	int i,j,k,p;
	for (i=0;i&lt;N;i++)
		if (i&lt;rev[i]) swap(a[i],a[rev[i]]);
	for (i=1;i&lt;N;i&lt;&lt;=1)
	{
		LL wn=ksm(3,(mo-1)/(i*2),mo);
		if (ff==-1) wn=ksm(wn,mo-2,mo);
		for (p=i&lt;&lt;1,j=0;j&lt;N;j+=p)
		{
			LL w=1;
			for (k=0;k&lt;i;k++,w=w*wn%mo)
			{
				LL x=a[j+k],y=w*a[j+k+i]%mo;
				a[j+k]=x+y,a[j+k+i]=x-y;
				if (a[j+k]&gt;=mo) a[j+k]-=mo;
				if (a[j+k+i]&lt;0) a[j+k+i]+=mo;
			}
		}
	}
	if (ff==-1)
		for (i=0;i&lt;N;i++) a[i]=a[i]*ksm(N,mo-2,mo)%mo;
}
void calc(int n,int ff)
{
	L=0,N=1;
	for (;N&lt;n;N&lt;&lt;=1) L++;
	int i;
	for (i=0;i&lt;N;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(L-1));
	static LL a[NN&lt;&lt;1];
	for (i=0;i&lt;N;i++) a[i]=0;
	for (i=0;i&lt;n;i++) a[i]=num[i];
	//printf(&quot;a &quot;);out(a,0,N);
	ntt(a,1);
	for (i=0;i&lt;N;i++) a[i]=a[i]*a[i]%mo;
	ntt(a,-1);
	for (i=0;i&lt;N;i++) ans[i]+=ff*a[i];
	//printf(&quot;The result of NTT is: &quot;),out(a,0,N);printf(&quot;Now, ans is:  &quot;),out(ans,0,10);
}
void work(int v)
{
	//printf(&quot;\n----------------------------- work %d -----------------------------\n&quot;,v);
	dep=0;TIME++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]) continue;
		fa[y]=0,dfs(y,1);
	}
	int i;
	for (i=0;i&lt;=(dep+1)&lt;&lt;1;i++)
		if (vt[i]!=TIME) num[i]=0;
	num[0]=1;
	//printf(&quot;dep=%d  num:&quot;,dep),out(num,0,dep);
	calc((dep+1)&lt;&lt;1,1);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]) continue;
		dep=0;TIME++;
		dfs(y,1);
		for (i=0;i&lt;=(dep+1)&lt;&lt;1;i++)
			if (vt[i]!=TIME) num[i]=0;
		//printf(&quot;dep=%d  num:&quot;,dep),out(num,0,dep);
		calc((dep+1)&lt;&lt;1,-1);
	}
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]) continue;
		y=getcore(y);
		deep[y]=deep[v]+1;
		work(y);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		x++,y++;
		addedge(x,y),addedge(y,x);
	}
	memset(deep,60,sizeof(deep));
	int t=getcore(1);
	deep[t]=1;
	work(t);
	DD res=0;
	for (i=0;i&lt;=n;i++) if (ans[i])
		res+=(DD)ans[i]/(i+1);
	//ln;ln;printf(&quot;ans &quot;);for(i=0;i&lt;=n;i++) printf(&quot;%I64d &quot;,ans[i]);ln;ln;
	printf(&quot;%.4f\n&quot;,res);
	return 0;
}<pre><h2>Problem3453</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define mo 1234567891
#define ln printf(&quot;\n&quot;)
int size;
LL a[133][133],X[133];
inline LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
void gause(int n)
{
	int i,j,k;
	//printf(&quot;a:\n&quot;);for (i=0;i&lt;=n;i++){for(j=0;j&lt;=n+1;j++) printf(&quot;%lld &quot;,a[i][j]);ln;}ln;
	for (i=0;i&lt;n;i++)
	{
		for (j=i;j&lt;=n;j++)
			if (a[j][i]) break;
		if (i!=j)
			for (k=0;k&lt;=n+1;k++) swap(a[i][k],a[j][k]);
		LL inv=ksm(a[i][i],mo-2,mo);
		for (j=i+1;j&lt;=n;j++)
		{
			LL tmp=a[j][i]*inv%mo;
			for (k=i;k&lt;=n+1;k++)
				(a[j][k]-=a[i][k]*tmp)%=mo;
		}
	}
	for (i=n;i&gt;=0;i--)
	{
		LL tmp=0;
		for (j=i+1;j&lt;=n;j++) (tmp+=a[i][j]*X[j])%=mo;
		X[i]=(a[i][n+1]-tmp)*ksm(a[i][i],mo-2,mo)%mo;
	}
}
void jiefangcheng(int K)
{
	int i,j;
	for (i=1;i&lt;=K+3;i++)
	{
		LL gi=0;
		for (j=1;j&lt;=i;j++)
			(gi+=ksm(j,K,mo)*(i-j+1))%=mo;
		a[i-1][K+3]=gi;
		for (j=0;j&lt;=K+2;j++)
			a[i-1][j]=ksm(i,j,mo);
	}
	gause(K+2);
	//printf(&quot;X &quot;);for (i=0;i&lt;=K+2;i++) printf(&quot;%lld &quot;,X[i]);ln;ln;
}
struct matrix
{
	LL qq[255][255];
	matrix() {memset(qq,0,sizeof(qq));}
	inline void clear() {memset(qq,0,sizeof(qq));}
	LL * operator [](int x) {return qq[x];}
	friend matrix operator *(matrix a,matrix b)
	{
		matrix c;
		for (int k=0;k&lt;=size;k++)
			for (int i=0;i&lt;=size;i++) if (a[i][k])
				for (int j=0;j&lt;=size;j++) if (b[k][j])
					(c[i][j]+=a[i][k]*b[k][j])%=mo;
		return c;
	}
	friend matrix operator ^(matrix a,LL b)
	{
		matrix res;
		for (int i=0;i&lt;=size;i++) res[i][i]=1;
		for (;b;b&gt;&gt;=1,a=a*a)
			if (b&amp;1) res=res*a;
		return res;
	}
};
LL work(int K,LL m,LL n,LL D)
{
	jiefangcheng(K);
	size=2*K+5;
	static matrix a,ans;
	a.clear();ans.clear();
	int i,j;
	for (i=0;i&lt;=K+2;i++) ans[0][i]=ksm(m,i,mo);
	static LL C[133][133];
	C[0][0]=1;
	for (i=1;i&lt;=K+3;i++)
	{
		C[i][0]=1;
		for (j=1;j&lt;=K+3;j++)
		{
			C[i][j]=C[i-1][j-1]+C[i-1][j];
			if (C[i][j]&gt;=mo) C[i][j]-=mo;
		}
	}
	for (i=0;i&lt;=K+2;i++)
	{
		a[i][i+K+3]=1;
		a[i+K+3][i+K+3]=1;
		for (j=0;j&lt;=i;j++)
			a[j][i]=C[i][j]*ksm(D,i-j,mo)%mo;
	}
	//printf(&quot;trans:\n&quot;);for(i=0;i&lt;=size;i++){for(j=0;j&lt;=size;j++)printf(&quot;%lld &quot;,a[i][j]);ln;}ln;
	ans=ans*(a^(n+1));
	LL res=0;
	for (i=0;i&lt;=K+2;i++)
		(res+=X[i]*ans[0][i+K+3])%=mo;
	if (res&lt;0) res+=mo;
	return res;
}
int main()
{
	//freopen(&quot;sum.in&quot;,&quot;r&quot;,stdin);freopen(&quot;sum.out&quot;,&quot;w&quot;,stdout);
	int tes,K;LL a,n,d;
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d%lld%lld%lld&quot;,&amp;K,&amp;a,&amp;n,&amp;d);
		printf(&quot;%lld\n&quot;,work(K,a,n,d));
	}
	return 0;
}<pre><h2>Problem3456</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define Mod 1004535809
namespace Polynomial{
    inline int Revbit(int x,int bit){
	    int r=0;
	    for(int i=0;i&lt;bit;++i)if((x&gt;&gt;i)&amp;1)r+=1&lt;&lt;(bit-1-i);
	    return r;
	}
	long long Qpow(long long x,long long y){long long re=1;for(;y;y&gt;&gt;=1,x=x*x%Mod)if(y&amp;1)re=re*x%Mod;return re;}
	void NTT(int *a,int n,int flag){
		int i,j,k,W,Wn,t,bit=0;
	    for(int tmp=n;tmp^1;tmp&gt;&gt;=1)++bit;
	    static int b[262300];
	    for(i=0;i&lt;n;i++)b[Revbit(i,bit)]=a[i];
	    memcpy(a,b,sizeof(a[0])*n);
		for(k=2;k&lt;=n;k&lt;&lt;=1){
			for(Wn=Qpow(3,(long long)(Mod-1)/k*flag%(Mod-1)),i=0;i&lt;n;i+=k){
				for(W=1,j=0;j&lt;k/2;j++,W=(long long)W*Wn%Mod){
					t=(long long)W*a[i+j+k/2]%Mod,a[i+j+k/2]=(a[i+j]+Mod-t)%Mod,a[i+j]=(a[i+j]+t)%Mod;
				}
			}
		}
	}
	void poly_inv(int *a,int *b,int n){
		static int tmp[262300];
		if(n==1){b[0]=Qpow(a[0],Mod-2);return;}
		poly_inv(a,b,n&gt;&gt;1);
		memcpy(tmp,a,sizeof(a[0])*n);
		memset(tmp+n,0,sizeof(a[0])*n);
		NTT(tmp,n&lt;&lt;1,1),NTT(b,n&lt;&lt;1,1);
		for(int i=0;i&lt;(n&lt;&lt;1);i++)tmp[i]=(long long)b[i]*(2-(long long)tmp[i]*b[i]%Mod+Mod)%Mod;
		NTT(tmp,n&lt;&lt;1,Mod-2);
		long long inv=Qpow(n&lt;&lt;1,Mod-2);
		for(int i=0;i&lt;n;i++)b[i]=(long long)tmp[i]*inv%Mod;
		memset(b+n,0,sizeof(b[0])*n);
	}
};
int n,m;
int main(){
	using namespace Polynomial;
	static int A[263000],B[263000],C[263000],invB[263000];
	static long long fac[263000];
	scanf(&quot;%d&quot;,&amp;n);
	int i;
	for(m=1;m&lt;=n;m&lt;&lt;=1);
	for(fac[0]=1,i=1;i&lt;=n;i++)fac[i]=fac[i-1]*i%Mod;
	for(i=0;i&lt;=n;i++)B[i]=Qpow(2,((long long)i*(i-1)&gt;&gt;1)%(Mod-1))*Qpow(fac[i],Mod-2)%Mod;
	for(i=1;i&lt;=n;i++)C[i]=Qpow(2,((long long)i*(i-1)&gt;&gt;1)%(Mod-1))*Qpow(fac[i-1],Mod-2)%Mod;
	poly_inv(B,invB,m);NTT(invB,m&lt;&lt;1,1);NTT(C,m&lt;&lt;1,1);
	for(i=0;i&lt;m&lt;&lt;1;i++)A[i]=(long long)invB[i]*C[i]%Mod;
	NTT(A,m&lt;&lt;1,Mod-2);
	long long inv=Qpow(m&lt;&lt;1,Mod-2);
	for(i=1;i&lt;=n;i++)A[i]=A[i]*inv%Mod;
	printf(&quot;%d\n&quot;,A[n]*fac[n-1]%Mod);
}
<pre><h2>Problem3456</h2><pre>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#define ll long long
#define P 1004535809
ll z,fac[131000];
inline ll POW(ll x,ll y){
	for(z=1;y;x=x*x%P,y&gt;&gt;=1)
	    if(y&amp;1) z=z*x%P;
	return z;
}
inline void NTT(int o[],int n,int tp){
	for(int i=0,j=0;i&lt;n;++i){
		if(i&gt;j) o[i]^=o[j],o[j]^=o[i],o[i]^=o[j];
		for(int k=n&gt;&gt;1;(j^=k)&lt;k;k&gt;&gt;=1);
	}
	for(int i=2,y;i&lt;=n;i&lt;&lt;=1)
		for(ll wn=POW(3,tp?(P-1)/i:P-1-(P-1)/i),j=0;j&lt;n;j+=i)
		    for(ll w=1,k=0,p=i&gt;&gt;1;k&lt;p;++k,w=w*wn%P)
		        y=w*o[j+k+p]%P,o[j+k+p]=(o[j+k]-y+P)%P,o[j+k]=(o[j+k]+y)%P;
	if(!tp) for(ll inv=POW(n,P-2),i=0;i&lt;n;++i) o[i]=inv*o[i]%P;
}
int n,len,G[610000],G_[610000],G_INV[610000];
inline void get_inv(int a[],int b[],int n){
	if(n==1){b[0]=POW(a[0],P-2);return;}
	static int tmp[610000];
	get_inv(a,b,n&gt;&gt;1);
	memcpy(tmp,a,sizeof(a[0])*n);
	memset(tmp+n,0,sizeof(a[0])*n);
	NTT(tmp,n&lt;&lt;1,1),NTT(b,n&lt;&lt;1,1);
	for(int i=0;i&lt;n&lt;&lt;1;++i) b[i]=(ll)b[i]*(2-(ll)tmp[i]*b[i]%P+P)%P;
	NTT(b,n&lt;&lt;1,0),memset(b+n,0,sizeof(a[0])*n);
}
int main(){
	scanf(&quot;%d&quot;,&amp;n),fac[0]=G[0]=1;
	for(int i=1;i&lt;=n;++i)
		fac[i]=fac[i-1]*i%P,
		G[i]=POW(2,((ll)i*(i-1)&gt;&gt;1)%(P-1))*POW(fac[i],P-2)%P;
	for(int i=0;i&lt;n;++i) G_[i]=(ll)G[i+1]*(i+1)%P;
	for(len=1;len&lt;=n;len&lt;&lt;=1);
	get_inv(G,G_INV,len);
	NTT(G_INV,len,1),NTT(G_,len,1);
	for(int i=0;i&lt;len;++i) G[i]=(ll)G_[i]*G_INV[i]%P;
	NTT(G,len,0);
	ll ans=POW(n,P-2)*G[n-1]%P;
	ans=ans*fac[n]%P;
	printf(&quot;%lld&quot;,ans);
}
<pre><h2>Problem3456</h2><pre>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#define ll long long
#define P 1004535809
ll z,fac[131000];
inline ll POW(ll x,ll y){
	for(z=1;y;x=x*x%P,y&gt;&gt;=1)
	    if(y&amp;1) z=z*x%P;
	return z;
}
inline void NTT(int o[],int n,int tp){
	for(int i=0,j=0;i&lt;n;++i){
		if(i&gt;j) o[i]^=o[j],o[j]^=o[i],o[i]^=o[j];
		for(int k=n&gt;&gt;1;(j^=k)&lt;k;k&gt;&gt;=1);
	}
	for(int i=2,y;i&lt;=n;i&lt;&lt;=1)
		for(ll wn=POW(3,tp?(P-1)/i:P-1-(P-1)/i),j=0;j&lt;n;j+=i)
		    for(ll w=1,k=0,p=i&gt;&gt;1;k&lt;p;++k,w=w*wn%P)
		        y=w*o[j+k+p]%P,o[j+k+p]=(o[j+k]-y+P)%P,o[j+k]=(o[j+k]+y)%P;
	if(!tp) for(ll inv=POW(n,P-2),i=0;i&lt;n;++i) o[i]=inv*o[i]%P;
}
int n,len,G[610000],G_[610000],G_INV[610000];
inline void get_inv(int a[],int b[],int n){
	if(n==1){b[0]=POW(a[0],P-2);return;}
	static int tmp[610000];
	get_inv(a,b,n&gt;&gt;1);
	memcpy(tmp,a,sizeof(a[0])*n);
	NTT(tmp,n&lt;&lt;1,1),NTT(b,n&lt;&lt;1,1);
	for(int i=0;i&lt;n&lt;&lt;1;++i) b[i]=(ll)b[i]*(2-(ll)tmp[i]*b[i]%P+P)%P;
	NTT(b,n&lt;&lt;1,0),memset(b+n,0,sizeof(a[0])*n);
}
int main(){
	scanf(&quot;%d&quot;,&amp;n),fac[0]=G[0]=1;
	for(int i=1;i&lt;=n;++i)
		fac[i]=fac[i-1]*i%P,
		G[i]=POW(2,((ll)i*(i-1)&gt;&gt;1)%(P-1))*POW(fac[i],P-2)%P;
	for(int i=0;i&lt;n;++i) G_[i]=(ll)G[i+1]*(i+1)%P;
	for(len=1;len&lt;=n;len&lt;&lt;=1);
	get_inv(G,G_INV,len);
	NTT(G_INV,len,1),NTT(G_,len,1);
	for(int i=0;i&lt;len;++i) G[i]=(ll)G_[i]*G_INV[i]%P;
	NTT(G,len,0);
	ll ans=POW(n,P-2)*G[n-1]%P;
	ans=ans*fac[n]%P;
	printf(&quot;%lld&quot;,ans);
}
<pre><h2>Problem3456</h2><pre>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#define ll long long
#define P 1004535809
ll z,fac[131000];
inline ll POW(ll x,ll y){
	for(z=1;y;x=x*x%P,y&gt;&gt;=1)
	    if(y&amp;1) z=z*x%P;
	return z;
}
inline void NTT(int o[],int n,int tp){
	for(int i=0,j=0;i&lt;n;++i){
		if(i&gt;j) o[i]^=o[j],o[j]^=o[i],o[i]^=o[j];
		for(int k=n&gt;&gt;1;(j^=k)&lt;k;k&gt;&gt;=1);
	}
	for(int i=2,y;i&lt;=n;i&lt;&lt;=1)
		for(ll wn=POW(3,tp?(P-1)/i:P-1-(P-1)/i),j=0;j&lt;n;j+=i)
		    for(ll w=1,k=0,p=i&gt;&gt;1;k&lt;p;++k,w=w*wn%P)
		        y=w*o[j+k+p]%P,o[j+k+p]=(o[j+k]-y+P)%P,o[j+k]=(o[j+k]+y)%P;
	if(!tp) for(ll inv=POW(n,P-2),i=0;i&lt;n;++i) o[i]=inv*o[i]%P;
}
int n,len,G[610000],G_ln[610000];
inline void get_inv(int a[],int b[],int n){
	if(n==1){b[0]=POW(a[0],P-2);return;}
	static int tmp[610000];
	get_inv(a,b,n&gt;&gt;1);
	memcpy(tmp,a,sizeof(a[0])*n);
	NTT(tmp,n&lt;&lt;1,1),NTT(b,n&lt;&lt;1,1);
	for(int i=0;i&lt;n&lt;&lt;1;++i) b[i]=(ll)b[i]*(2-(ll)tmp[i]*b[i]%P+P)%P;
	NTT(b,n&lt;&lt;1,0),memset(b+n,0,sizeof(a[0])*n);
}
void get_ln(int a[],int b[],int n){
	static int a_[610000],a_inv[610000];
	for(int i=0;i&lt;n;++i) a_[i]=(ll)a[i+1]*(i+1)%P;
	get_inv(a,a_inv,len);
	NTT(a_inv,n,1),NTT(a_,n,1);
	for(int i=0;i&lt;n;++i) b[i]=(ll)a_[i]*a_inv[i]%P;
	NTT(b,n,0);
}
int main(){
	scanf(&quot;%d&quot;,&amp;n),fac[0]=G[0]=1;
	for(int i=1;i&lt;=n;++i)
		fac[i]=fac[i-1]*i%P,
		G[i]=POW(2,((ll)i*(i-1)&gt;&gt;1)%(P-1))*POW(fac[i],P-2)%P;
	for(len=1;len&lt;=n;len&lt;&lt;=1);
	get_ln(G,G_ln,len);
	ll ans=POW(n,P-2)*G_ln[n-1]%P;
	ans=ans*fac[n]%P;
	printf(&quot;%lld&quot;,ans);
}
<pre><h2>Problem3463</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
using namespace std;
#define NN 111111
#define blocksize 320
#define inf 999999999999999ll
#define LL long long
LL k[NN],b[NN],belong[NN],begin[400],end[400],n,m;
bool flag[NN];
struct line
{
	LL k,b,id;
	line(LL x=0,LL y=0,LL z=0) {k=x,b=y,id=z;}
	friend bool operator &lt;(line x,line y)
	{
		return (x.k==y.k?x.b&lt;y.b:x.k&lt;y.k);
	}
};
struct budget
{
	private:
		LL num,now,tot,i;
		line a[blocksize],ans[blocksize];
		void lswap(line &amp;a,line &amp;b) {line t=a;a=b;b=t;}
		bool check(const line &amp;a,const line &amp;b,const line &amp;c)
		{
			return ((a.k-b.k)*(a.b-c.b)-(a.k-c.k)*(a.b-b.b)&gt;=0);
		}
		LL calc(line x,LL t) {return x.k*t+x.b;}
	public:
		budget() {tot=num=0,now=1;}
		void ins(LL k,LL b,LL id)
		{
			//printf(&quot;%lld %lld\n&quot;,k,b);
			for (i=1;i&lt;tot;i++)
				if (a[i].id==id) swap(a[i],a[i+1]);
			if (a[tot].id==id) tot--;
			tot++;
			a[tot].k=k,a[tot].b=b,a[tot].id=id;
			for (i=tot;i&gt;1&amp;&amp;a[i]&lt;a[i-1];i--) swap(a[i],a[i-1]);
			//printf(&quot;tot=%lld\n&quot;,tot);
			for (num=0,i=1;i&lt;=tot;i++)
			{
				while (num&gt;1&amp;&amp;check(ans[num-1],ans[num],a[i])) num--;
				ans[++num]=a[i];
				//printf(&quot;i=%lld num=%lld\n&quot;,i,num);
			}
			now=1;
			//for (int i=1;i&lt;=tot;i++) printf(&quot;%lld &quot;,calc(a[i],100));printf(&quot;\n&quot;);printf(&quot;m=%lld\n&quot;,num);
			//for (int i=1;i&lt;=tot;i++) printf(&quot;%lld &quot;,calc(a[i],400));printf(&quot;\n&quot;);printf(&quot;m=%lld\n&quot;,num);
		}
		LL getmax(LL t)
		{
			//for (int i=1;i&lt;=num;i++) printf(&quot;%lld &quot;,calc(ans[i],t));printf(&quot;\n&quot;);
			//printf(&quot;%lld\n&quot;,num);
			if (tot==0) return -inf;
			while (now&lt;num&amp;&amp;calc(ans[now],t)&lt;=calc(ans[now+1],t)) now++;
			return calc(ans[now],t);
		}
} a[blocksize];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);
	int i,now,cnt;
	for (now=1,cnt=0;now&lt;=n;now+=blocksize)
	{
		cnt++;
		begin[cnt]=now;
		end[cnt]=now+blocksize-1;
		for (i=begin[cnt];i&lt;=end[cnt];i++)
			if (i&lt;=n) belong[i]=cnt;
		//printf(&quot;%lld %lld\n&quot;,begin[cnt],end[cnt]);
	}
	//printf(&quot;%d\n&quot;,cnt);
	for (;m;m--)
	{
		//printf(&quot;\n-------------------------------------\n&quot;);
		//printf(&quot;%lld\n&quot;,m);
		//for (LL i=1;i&lt;=500000000;i++);
		LL T,K,Z,S,A,B,i,res,kind;
		scanf(&quot;%lld&quot;,&amp;kind);
		//printf(&quot;%lld\n&quot;,kind);
		//for (LL i=1;i&lt;=500000000;i++);
		if (kind==1)
		{
			scanf(&quot;%lld%lld%lld%lld&quot;,&amp;T,&amp;K,&amp;Z,&amp;S);
			flag[K]=true;
			//printf(&quot;%lld %lld %lld %lld\n&quot;,T,K,Z,S);
			//for (LL i=1;i&lt;=500000000;i++);
			k[K]=Z,b[K]=S-T*Z;
			a[belong[K]].ins(Z,S-T*Z,K);
		}
		else
		{
			scanf(&quot;%lld%lld%lld&quot;,&amp;T,&amp;A,&amp;B);
			res=-inf;
			if (A&gt;B) swap(A,B);
			if (belong[B]-belong[A]&lt;=1)
			{
				for (i=A;i&lt;=B;i++)
					if (flag[i]) res=max(res,k[i]*T+b[i]);
				if (res==-inf) printf(&quot;nema\n&quot;);
				else printf(&quot;%lld\n&quot;,res);
				continue;
			}
			LL L=belong[A]+1,R=belong[B]-1;
			for (i=A;i&lt;begin[L];i++)
				if (flag[i]) res=max(res,k[i]*T+b[i]);
			//printf(&quot;res=%lld\n&quot;,res);
			for (i=B;i&gt;end[R];i--)
				if (flag[i]) res=max(res,k[i]*T+b[i]);
			//printf(&quot;res=%lld\n&quot;,res);
			for (i=L;i&lt;=R;i++) res=max(res,a[i].getmax(T));
			//printf(&quot;res=%lld\n&quot;,res);
			if (res==-inf) printf(&quot;nema\n&quot;);
			else printf(&quot;%lld\n&quot;,res);
		}
	}
	return 0;
}
<pre><h2>Problem3489</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
#define maa(a,b) (a&gt;b?a:b)
const int NN=100005,AA=1800005,BB=32000005;
int b[NN],root[NN];
int n,m,TTT,TTT2;
struct info
{
	int w,last,next,id;
	void out() {printf(&quot;w=%d last=%d next=%d id=%d\n&quot;,w,last,next,id);}
	friend bool operator &lt;(info a,info b) {return a.last&lt;b.last;}
} a[NN];
struct tree
{
	int lc,rc,T;
} t[AA];
struct tree2
{
	int lc,rc,m;
} t2[BB];
void update(int v)
{
	t2[v].m=max(t2[t2[v].lc].m,t2[t2[v].rc].m);
}
void ins2(int &amp;v,int u,int l,int r,int i,int w)
{
	if (!v) v=++TTT2;
	//printf(&quot;  ins2 %d %d %d %d %d %d\n&quot;,v,u,l,r,i,w);
	if (r-l==1)
	{
		t2[v].m=maa(t2[u].m,w);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid)
		t2[v].rc=t2[u].rc,ins2(t2[v].lc,t2[u].lc,l,mid,i,w);
	else
		t2[v].lc=t2[u].lc,ins2(t2[v].rc,t2[u].rc,mid,r,i,w);
	update(v);
	//printf(&quot;  tmax[%d]=%d\n&quot;,v,tmax[v]);
}
void ins(int &amp;v,int u,int l,int r,int next,int i,int w)
{
	if (!v) v=++TTT;
	//printf(&quot;ins %d %d %d %d %d %d %d\n&quot;,v,u,l,r,next,i,w);
	ins2(t[v].T,t[u].T,1,n+1,i,w);
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (next&lt;mid)
		t[v].rc=t[u].rc,ins(t[v].lc,t[u].lc,l,mid,next,i,w);
	else
		t[v].lc=t[u].lc,ins(t[v].rc,t[u].rc,mid,r,next,i,w);
}
int find2(int v,int l,int r,int ww,int ee)
{
	//printf(&quot;  find2 %d %d %d %d %d\n&quot;,v,l,r,ww,ee);
	if (!v) return 0;
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return t2[v].m;
	int mid=(l+r)&gt;&gt;1,res=0;
	if (ww&lt;mid) res=find2(t2[v].lc,l,mid,ww,ee);
	if (ee&gt;mid) res=max(res,find2(t2[v].rc,mid,r,ww,ee));
	return res;
}
int find(int v,int l,int r,int ww,int ee)
{
	//printf(&quot;find %d %d %d %d %d\n&quot;,v,l,r,ww,ee);
	if (!v) return 0;
	if (ee&lt;=l) return find2(t[v].T,1,n+1,ww,ee);
	int mid=(l+r)&gt;&gt;1,res=0;
	if (ee&lt;mid) res=find(t[v].lc,l,mid,ww,ee);
	res=max(res,find(t[v].rc,mid,r,ww,ee));;
	return res;
}
int cha(int x)
{
	int l=1,r=n,res=1;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (a[mid].last&lt;x) res=mid,l=mid+1;
		else r=mid-1;
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	//freopen(&quot;3489.in&quot;,&quot;r&quot;,stdin);freopen(&quot;3489.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i].w),a[i].id=i;
	for (i=1;i&lt;=n;i++)
		{a[i].last=b[a[i].w];b[a[i].w]=i;}
	for (i=1;i&lt;=n;i++) b[i]=n+1;
	for (i=n;i;i--)
		{a[i].next=b[a[i].w];b[a[i].w]=i;}
	sort(a+1,a+n+1);
	//for(i=1;i&lt;=n;i++)a[i].out();ln;
	for (i=1;i&lt;=n;i++)
		ins(root[i],root[i-1],1,n+2,a[i].next,a[i].id,a[i].w);
	int lastans=0;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		x=(x+lastans)%n+1,y=(y+lastans)%n+1;
		if (x&gt;y) {int t=x;x=y;y=t;}
		//printf(&quot;x=%d y=%d\n&quot;,x,y);
		int t=cha(x);
		//printf(&quot;t=%d\n&quot;,t);
		lastans=find(root[t],1,n+2,x,y+1);
		printf(&quot;%d\n&quot;,lastans);
	}
	return 0;
}<pre><h2>Problem3489</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
#define maa(a,b) (a&gt;b?a:b)
const int NN=100005,AA=1800005,BB=32000005;
int b[NN],root[NN];
int n,m,TTT,TTT2;
struct info
{
	int w,last,next,id;
	void out() {printf(&quot;w=%d last=%d next=%d id=%d\n&quot;,w,last,next,id);}
	friend bool operator &lt;(info a,info b) {return a.last&lt;b.last;}
} a[NN];
struct tree
{
	int lc,rc,T;
} t[AA];
struct tree2
{
	int lc,rc,m;
} t2[BB];
void update(int v)
{
	t2[v].m=max(t2[t2[v].lc].m,t2[t2[v].rc].m);
}
void ins2(int &amp;v,int u,int l,int r,int i,int w)
{
	if (!v) v=++TTT2;
	//printf(&quot;  ins2 %d %d %d %d %d %d\n&quot;,v,u,l,r,i,w);
	if (r-l==1)
	{
		t2[v].m=maa(t2[u].m,w);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid)
		t2[v].rc=t2[u].rc,ins2(t2[v].lc,t2[u].lc,l,mid,i,w);
	else
		t2[v].lc=t2[u].lc,ins2(t2[v].rc,t2[u].rc,mid,r,i,w);
	update(v);
	//printf(&quot;  tmax[%d]=%d\n&quot;,v,tmax[v]);
}
void ins(int &amp;v,int u,int l,int r,int next,int i,int w)
{
	if (!v) v=++TTT;
	//printf(&quot;ins %d %d %d %d %d %d %d\n&quot;,v,u,l,r,next,i,w);
	ins2(t[v].T,t[u].T,1,n+1,i,w);
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (next&lt;mid)
		t[v].rc=t[u].rc,ins(t[v].lc,t[u].lc,l,mid,next,i,w);
	else
		t[v].lc=t[u].lc,ins(t[v].rc,t[u].rc,mid,r,next,i,w);
}
int find2(int v,int l,int r,int ww,int ee)
{
	//printf(&quot;  find2 %d %d %d %d %d\n&quot;,v,l,r,ww,ee);
	if (!v) return 0;
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return t2[v].m;
	int mid=(l+r)&gt;&gt;1,res=0;
	if (ww&lt;mid) res=find2(t2[v].lc,l,mid,ww,ee);
	if (ee&gt;mid) res=max(res,find2(t2[v].rc,mid,r,ww,ee));
	return res;
}
int find(int v,int l,int r,int ww,int ee)
{
	//printf(&quot;find %d %d %d %d %d\n&quot;,v,l,r,ww,ee);
	if (!v) return 0;
	if (ee&lt;=l) return find2(t[v].T,1,n+1,ww,ee);
	int mid=(l+r)&gt;&gt;1,res=0;
	if (ee&lt;mid) res=find(t[v].lc,l,mid,ww,ee);
	res=max(res,find(t[v].rc,mid,r,ww,ee));;
	return res;
}
int cha(int x)
{
	int l=1,r=n,res=1;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (a[mid].last&lt;x) res=mid,l=mid+1;
		else r=mid-1;
	}
	return res;
}
int read()
{
	int tmp=0;
	char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9')
		tmp=tmp*10+ch-'0',ch=getchar();
	return tmp;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	//freopen(&quot;3489.in&quot;,&quot;r&quot;,stdin);freopen(&quot;3489.out&quot;,&quot;w&quot;,stdout);
	n=read(),m=read();
	int i,x,y;
	for (i=1;i&lt;=n;i++) a[i].w=read(),a[i].id=i;
	for (i=1;i&lt;=n;i++)
		{a[i].last=b[a[i].w];b[a[i].w]=i;}
	for (i=1;i&lt;=n;i++) b[i]=n+1;
	for (i=n;i;i--)
		{a[i].next=b[a[i].w];b[a[i].w]=i;}
	sort(a+1,a+n+1);
	//for(i=1;i&lt;=n;i++)a[i].out();ln;
	for (i=1;i&lt;=n;i++)
		ins(root[i],root[i-1],1,n+2,a[i].next,a[i].id,a[i].w);
	int lastans=0;
	for (i=1;i&lt;=m;i++)
	{
		x=read(),y=read();
		x=(x+lastans)%n+1,y=(y+lastans)%n+1;
		if (x&gt;y) {int t=x;x=y;y=t;}
		//printf(&quot;x=%d y=%d\n&quot;,x,y);
		int t=cha(x);
		//printf(&quot;t=%d\n&quot;,t);
		lastans=find(root[t],1,n+2,x,y+1);
		printf(&quot;%d\n&quot;,lastans);
	}
	return 0;
}<pre><h2>Problem3489</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
#define maa(a,b) (a&gt;b?a:b)
const int NN=100005,AA=1800005,BB=32000005;
int b[NN],root[NN],sta[10];
int n,m,TTT,TTT2;
struct info
{
	int w,last,next,id;
	void out() {printf(&quot;w=%d last=%d next=%d id=%d\n&quot;,w,last,next,id);}
	friend bool operator &lt;(info a,info b) {return a.last&lt;b.last;}
} a[NN];
struct tree
{
	int lc,rc,T;
} t[AA];
struct tree2
{
	int lc,rc,m;
} t2[BB];
void update(int v)
{
	t2[v].m=max(t2[t2[v].lc].m,t2[t2[v].rc].m);
}
void ins2(int &amp;v,int u,int l,int r,int i,int w)
{
	if (!v) v=++TTT2;
	//printf(&quot;  ins2 %d %d %d %d %d %d\n&quot;,v,u,l,r,i,w);
	if (r-l==1)
	{
		t2[v].m=maa(t2[u].m,w);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid)
		t2[v].rc=t2[u].rc,ins2(t2[v].lc,t2[u].lc,l,mid,i,w);
	else
		t2[v].lc=t2[u].lc,ins2(t2[v].rc,t2[u].rc,mid,r,i,w);
	update(v);
	//printf(&quot;  tmax[%d]=%d\n&quot;,v,tmax[v]);
}
void ins(int &amp;v,int u,int l,int r,int next,int i,int w)
{
	if (!v) v=++TTT;
	//printf(&quot;ins %d %d %d %d %d %d %d\n&quot;,v,u,l,r,next,i,w);
	ins2(t[v].T,t[u].T,1,n+1,i,w);
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (next&lt;mid)
		t[v].rc=t[u].rc,ins(t[v].lc,t[u].lc,l,mid,next,i,w);
	else
		t[v].lc=t[u].lc,ins(t[v].rc,t[u].rc,mid,r,next,i,w);
}
int find2(int v,int l,int r,int ww,int ee)
{
	//printf(&quot;  find2 %d %d %d %d %d\n&quot;,v,l,r,ww,ee);
	if (!v) return 0;
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return t2[v].m;
	int mid=(l+r)&gt;&gt;1,res=0;
	if (ww&lt;mid) res=find2(t2[v].lc,l,mid,ww,ee);
	if (ee&gt;mid) res=max(res,find2(t2[v].rc,mid,r,ww,ee));
	return res;
}
int find(int v,int l,int r,int ww,int ee)
{
	//printf(&quot;find %d %d %d %d %d\n&quot;,v,l,r,ww,ee);
	if (!v) return 0;
	if (ee&lt;=l) return find2(t[v].T,1,n+1,ww,ee);
	int mid=(l+r)&gt;&gt;1,res=0;
	if (ee&lt;mid) res=find(t[v].lc,l,mid,ww,ee);
	res=max(res,find(t[v].rc,mid,r,ww,ee));;
	return res;
}
int cha(int x)
{
	int l=1,r=n,res=1;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (a[mid].last&lt;x) res=mid,l=mid+1;
		else r=mid-1;
	}
	return res;
}
int read()
{
	int tmp=0;
	char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9')
		tmp=tmp*10+ch-'0',ch=getchar();
	return tmp;
}
void writeln(int x)
{
	int t=0;
	for (;x;x/=10) sta[++t]=x%10;
	for (;t;t--) putchar('0'+sta[t]);
	putchar('\n');
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	//freopen(&quot;3489.in&quot;,&quot;r&quot;,stdin);freopen(&quot;3489.out&quot;,&quot;w&quot;,stdout);
	n=read(),m=read();
	int i,x,y;
	for (i=1;i&lt;=n;i++) a[i].w=read(),a[i].id=i;
	for (i=1;i&lt;=n;i++)
		{a[i].last=b[a[i].w];b[a[i].w]=i;}
	for (i=1;i&lt;=n;i++) b[i]=n+1;
	for (i=n;i;i--)
		{a[i].next=b[a[i].w];b[a[i].w]=i;}
	sort(a+1,a+n+1);
	//for(i=1;i&lt;=n;i++)a[i].out();ln;
	for (i=1;i&lt;=n;i++)
		ins(root[i],root[i-1],1,n+2,a[i].next,a[i].id,a[i].w);
	int lastans=0;
	for (i=1;i&lt;=m;i++)
	{
		x=read(),y=read();
		x=(x+lastans)%n+1,y=(y+lastans)%n+1;
		if (x&gt;y) {int t=x;x=y;y=t;}
		//printf(&quot;x=%d y=%d\n&quot;,x,y);
		int t=cha(x);
		//printf(&quot;t=%d\n&quot;,t);
		lastans=find(root[t],1,n+2,x,y+1);
		printf(&quot;%d\n&quot;,lastans);
	}
	return 0;
}<pre><h2>Problem3509</h2><pre>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;
#define ll long long
#define pi 3.14159265358979323846
inline int MAX(int A,int B){return A&gt;B?A:B;}
inline int MIN(int A,int B){return A&lt;B?A:B;}
struct cpx{
	double r,i;
	inline friend cpx operator + (cpx a,cpx b){return (cpx){a.r+b.r,a.i+b.i};}
	inline friend cpx operator - (cpx a,cpx b){return (cpx){a.r-b.r,a.i-b.i};}
	inline friend cpx operator * (cpx a,cpx b){return (cpx){a.r*b.r-a.i*b.i,a.r*b.i+a.i*b.r};}
}A[110000],B[110000],t;
void FFT(cpx *o,int n,int tp){
	for(int i=0,j=0;i&lt;n;++i){
		if(i&gt;j) t=o[i],o[i]=o[j],o[j]=t;
		for(int k=n&gt;&gt;1;(j^=k)&lt;k;k&gt;&gt;=1);
	}cpx wn,w;
	for(int i=2;i&lt;=n;i&lt;&lt;=1){
		wn=(cpx){cos(pi*2/i),tp*sin(pi*2/i)},w=(cpx){1,0};
		for(int j=0;j&lt;n;j+=i,w=(cpx){1,0})
		    for(int k=0,p=i&gt;&gt;1;k&lt;p;++k,w=w*wn)
				t=w*o[j+k+p],o[j+k+p]=o[j+k]-t,o[j+k]=o[j+k]+t;
	}
	if(tp==-1) for(int i=0;i&lt;n;++i) o[i].r/=n;
}
inline void in(int &amp;TEMP){int EPX;for(TEMP=getchar();TEMP&lt;48||TEMP&gt;57;TEMP=getchar());for(TEMP^=48,EPX=getchar();EPX&lt;58&amp;&amp;EPX&gt;47;EPX=getchar())TEMP=(TEMP&lt;&lt;3)+(TEMP&lt;&lt;1)+(EPX^48);}
int n,tp,l,len,o[110000],lnum[110000],rnum[110000];
ll ans;
int main(){
	in(n),tp=5000;for(int i=0;i&lt;n;++i) in(o[i]),l=MAX(l,o[i]),++B[o[i]].r,++rnum[o[i]];
	for(len=1;len&lt;=l;len&lt;&lt;=1);len&lt;&lt;=1;
	for(int i=0,R=n/tp;i&lt;=R;++i){
		for(int j=i*tp,r=MIN((i+1)*tp,n);j&lt;r;++j) --rnum[o[j]];
		for(int j=0;j&lt;len;++j) A[j]=(cpx){lnum[j],0},B[j]=(cpx){rnum[j],0};
		FFT(A,len,1),FFT(B,len,1);
		for(int j=0;j&lt;len;++j) A[j]=A[j]*B[j];
		FFT(A,len,-1);
//*
		for(int j=i*tp,r=MIN((i+1)*tp,n);j&lt;r;++j){
			ans+=(ll)(A[o[j]&lt;&lt;1].r+0.5);
			for(int k=j+1;k&lt;r;++k) if(o[j]&lt;&lt;1&gt;=o[k]) ans+=lnum[(o[j]&lt;&lt;1)-o[k]];
			for(int k=i*tp;k&lt;j;++k) if(o[j]&lt;&lt;1&gt;=o[k]) ans+=rnum[(o[j]&lt;&lt;1)-o[k]];
			++lnum[o[j]];
		}
//*/
	}
	printf(&quot;%lld&quot;,ans);
	//while(1);
}
<pre><h2>Problem3514</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define ln printf(&quot;\n&quot;)
#define inf 999999999
const int NN=2001111,nlogn=4001111;
int fa[NN],son[NN][2],key[NN],tmin[NN],lc[nlogn],rc[nlogn],size[nlogn],pre[NN],root[NN];
int n,m,K,kind,TTT;
bool rrr[NN],tag[NN];
void out(int*a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
struct edge {int a,b;} e[NN];
void rev(int t)
{
	tag[t]=!tag[t];
	swap(son[t][0],son[t][1]);
}
void pushdown(int t)
{
	if (!tag[t]) return;
	rev(son[t][0]),rev(son[t][1]);
	tag[t]=false;
}
void update(int t)
{
	tmin[t]=min(key[t],mii(tmin[son[t][0]],tmin[son[t][1]]));
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[t]=true,rrr[y]=false;
	else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
	else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
}
void access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
}
void makeroot(int x)
{
	access(x);
	splay(x);
	rev(x);
}
void link(int x,int y)
{
	//printf(&quot;link %d %d\n&quot;,x,y);
	makeroot(x);
	splay(x);
	fa[x]=y;
}
void cut(int x,int y)
{
	//printf(&quot;cut %d %d\n&quot;,x,y);
	makeroot(x);
	access(y);
	splay(y);
	rrr[x]=true;
	fa[x]=son[y][0]=0;
}
int getroot(int x)
{
	//printf(&quot;  getroot %d\n&quot;,x);
	access(x);
	splay(x);
	while (son[x][0]) x=son[x][0];
	//printf(&quot;  root is %d\n&quot;,x);
	return x;
}
void ins(int &amp;v,int u,int l,int r,int x)
{
	if (!v) v=++TTT;
	size[v]=size[u]+1;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid) rc[v]=rc[u],ins(lc[v],lc[u],l,mid,x);
	else lc[v]=lc[u],ins(rc[v],rc[u],mid,r,x);
}
int find(int v,int u,int l,int r,int x)
{
	//printf(&quot;find %d %d %d\n&quot;,l,r,x);printf(&quot;size[v]-size[u]=%d\n&quot;,size[v]-size[u]);
	if (!v) return 0;
	if (r-l==1) return size[v]-size[u];
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid) return find(lc[v],lc[u],l,mid,x);
	else return size[lc[v]]-size[lc[u]]+find(rc[v],rc[u],mid,r,x);
}
void debug(int t){if(!t)return;pushdown(t);debug(son[t][0]);printf(&quot;%d &quot;,t);debug(son[t][1]);}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;K,&amp;kind);
	int i;
	for (i=1;i&lt;=n;i++) rrr[i]=true,key[i]=inf;
	for (i=1;i&lt;=m;i++) rrr[i+n]=true,key[i+n]=i;
	tmin[0]=inf;
	for (i=1;i&lt;=m;i++)
	{
		//printf(&quot;\n------------------ %d --------------------------------------------------\n&quot;,i);
		//printf(&quot;fa &quot;);out(fa,1,n);printf(&quot;rrr &quot;);for(int j=1;j&lt;=n;j++)printf(&quot;%d &quot;,rrr[j]);ln;
		scanf(&quot;%d%d&quot;,&amp;e[i].a,&amp;e[i].b);
		if (e[i].a==e[i].b) pre[i]=i;
		else if (getroot(e[i].a)==getroot(e[i].b))
		{
			int x=e[i].a,y=e[i].b;
			makeroot(x);
			access(y);
			splay(y);
			int t=tmin[y];
			pre[i]=t;
			//printf(&quot;t=%d\n&quot;,t);
			cut(e[t].a,t+n);cut(t+n,e[t].b);
			link(x,i+n),link(i+n,y);
		}
		else pre[i]=0,link(e[i].a,i+n),link(i+n,e[i].b);
	}
	//printf(&quot;pre &quot;);out(pre,1,m);
	for (i=1;i&lt;=m;i++) ins(root[i],root[i-1],0,m+1,pre[i]);
	int lastans=0;
	for (i=1;i&lt;=K;i++)
	{
		//printf(&quot;\n---------------------------------------------------------------------------------\n&quot;);
		int l,r;
		scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
		if (kind==1) l^=lastans,r^=lastans;
		lastans=n-find(root[r],root[l-1],0,m+1,l-1);
		printf(&quot;%d\n&quot;,lastans);
	}
	return 0;
}<pre><h2>Problem3514</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define mii(a,b) ((a)&lt;(b)?(a):(b))
#define ln printf(&quot;\n&quot;)
#define inf 999999999
const int NN=401111,nlogn=4001111;
int fa[NN],son[NN][2],key[NN],tmin[NN],lc[nlogn],rc[nlogn],size[nlogn],pre[NN],root[NN];
int n,m,K,kind,TTT;
bool rrr[NN],tag[NN];
void out(int*a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
struct edge {int a,b;} e[NN];
void rev(int t)
{
	tag[t]=!tag[t];
	swap(son[t][0],son[t][1]);
}
void pushdown(int t)
{
	if (!tag[t]) return;
	rev(son[t][0]),rev(son[t][1]);
	tag[t]=false;
}
void update(int t)
{
	tmin[t]=min(key[t],mii(tmin[son[t][0]],tmin[son[t][1]]));
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[t]=true,rrr[y]=false;
	else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
	else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
}
void access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
}
void makeroot(int x)
{
	access(x);
	splay(x);
	rev(x);
}
void link(int x,int y)
{
	//printf(&quot;link %d %d\n&quot;,x,y);
	makeroot(x);
	splay(x);
	fa[x]=y;
}
void cut(int x,int y)
{
	//printf(&quot;cut %d %d\n&quot;,x,y);
	makeroot(x);
	access(y);
	splay(y);
	rrr[x]=true;
	fa[x]=son[y][0]=0;
}
int getroot(int x)
{
	//printf(&quot;  getroot %d\n&quot;,x);
	access(x);
	splay(x);
	while (son[x][0]) x=son[x][0];
	//printf(&quot;  root is %d\n&quot;,x);
	return x;
}
void ins(int &amp;v,int u,int l,int r,int x)
{
	if (!v) v=++TTT;
	size[v]=size[u]+1;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid) rc[v]=rc[u],ins(lc[v],lc[u],l,mid,x);
	else lc[v]=lc[u],ins(rc[v],rc[u],mid,r,x);
}
int find(int v,int u,int l,int r,int x)
{
	//printf(&quot;find %d %d %d\n&quot;,l,r,x);printf(&quot;size[v]-size[u]=%d\n&quot;,size[v]-size[u]);
	if (!v) return 0;
	if (r-l==1) return size[v]-size[u];
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid) return find(lc[v],lc[u],l,mid,x);
	else return size[lc[v]]-size[lc[u]]+find(rc[v],rc[u],mid,r,x);
}
void debug(int t){if(!t)return;pushdown(t);debug(son[t][0]);printf(&quot;%d &quot;,t);debug(son[t][1]);}
int main()
{
	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;K,&amp;kind);
	int i;
	for (i=1;i&lt;=n;i++) rrr[i]=true,key[i]=inf;
	for (i=1;i&lt;=m;i++) rrr[i+n]=true,key[i+n]=i;
	tmin[0]=inf;
	for (i=1;i&lt;=m;i++)
	{
		//printf(&quot;\n------------------ %d --------------------------------------------------\n&quot;,i);
		//printf(&quot;fa &quot;);out(fa,1,n);printf(&quot;rrr &quot;);for(int j=1;j&lt;=n;j++)printf(&quot;%d &quot;,rrr[j]);ln;
		scanf(&quot;%d%d&quot;,&amp;e[i].a,&amp;e[i].b);
		if (e[i].a==e[i].b) pre[i]=i;
		else if (getroot(e[i].a)==getroot(e[i].b))
		{
			int x=e[i].a,y=e[i].b;
			makeroot(x);
			access(y);
			splay(y);
			int t=tmin[y];
			pre[i]=t;
			//printf(&quot;t=%d\n&quot;,t);
			cut(e[t].a,t+n);cut(t+n,e[t].b);
			link(x,i+n),link(i+n,y);
		}
		else pre[i]=0,link(e[i].a,i+n),link(i+n,e[i].b);
	}
	//printf(&quot;pre &quot;);out(pre,1,m);
	for (i=1;i&lt;=m;i++) ins(root[i],root[i-1],0,m+1,pre[i]);
	int lastans=0;
	for (i=1;i&lt;=K;i++)
	{
		//printf(&quot;\n---------------------------------------------------------------------------------\n&quot;);
		int l,r;
		scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
		if (kind==1) l^=lastans,r^=lastans;
		lastans=n-find(root[r],root[l-1],0,m+1,l-1);
		printf(&quot;%d\n&quot;,lastans);
	}
	return 0;
}<pre><h2>Problem3514</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;

#define maxn 400010
#define L(x) (ch[x][0])
#define R(x) (ch[x][1])

using namespace std;

inline int read()
{
	int ret=0;char ch=getchar();
	while(ch&lt;'!') ch=getchar();
	while(ch&gt;'!') ret=ret*10+ch-'0',ch=getchar();
	return ret;
}

int n,m,q,fa[maxn],rt[maxn],ch[maxn][2],f[maxn],w[maxn],num,father[maxn],sta[maxn],top;
bool mark[maxn];

namespace LCT{
	inline bool isroot(int x)
	{
		return (!fa[x])||(L(fa[x])!=x&amp;&amp;R(fa[x])!=x);
	}
	
	void update(int x)
	{
		f[x]=min(min(w[x],f[L(x)]),f[R(x)]);
	}
	
	void pushdown(int x)
	{
		if(mark[x]){
			swap(L(x),R(x));
			mark[x]=0;
			mark[L(x)]^=1;
			mark[R(x)]^=1;
		}
	}
	
	void Rotate(int f1,int k)
	{
		int x=ch[f1][!k];
		ch[f1][!k]=ch[x][k];
		fa[ch[x][k]]=f1;
		ch[x][k]=f1;
		fa[x]=fa[f1];
		if(!isroot(f1)) ch[fa[f1]][R(fa[f1])==f1]=x;
		fa[f1]=x;
		update(f1);
		update(x);
	}
	
	void splay(int x)
	{
		sta[top=1]=x;
		for(int i=x;!isroot(i);i=fa[i]) sta[++top]=fa[i];
		while(top) pushdown(sta[top--]);
		while(!isroot(x)){
			int f1=fa[x],f2=fa[f1];
			pushdown(x);
			pushdown(f1);
			pushdown(f2);
			if(isroot(f1)) Rotate(f1,L(f1)==x);
			else{
				if((L(f2)==f1)==(L(f1)==x)) Rotate(f2,L(f2)==f1),Rotate(f1,L(f1)==x);
				else Rotate(f1,L(f1)==x),Rotate(f2,L(f2)==x);
			}
		}
	}
	
	void access(int x)
	{
		int tmp=0;
		while(x){
			splay(x);
			R(x)=tmp;
			update(x);
			tmp=x,x=fa[x];
		}
	}
	
	void makeroot(int x)
	{
		access(x);
		splay(x);
		mark[x]^=1;
	}
	
	void cut(int x,int y)
	{
		makeroot(x);access(y);
		splay(x);R(x)=fa[y]=0;
	}
	
	void link(int x,int y)
	{
		makeroot(x);fa[x]=y;
	}
	
	int work(int x,int y)
	{
		makeroot(x);
		access(y);
		splay(x);
		return f[x];
	}
}

namespace SegTre{
	struct node{
		int l,r,val;
	}tr[maxn*30];
	
	void Update(int x)
	{
		tr[x].val=tr[tr[x].l].val+tr[tr[x].r].val;
	}
	
	void modify(int pos,int val,int l,int r,int &amp;x,int lx)
	{
		if(!x||x==lx){
			x=++num;
			tr[x]=tr[lx];
		}
		if(l==r){
			tr[x].val=val;
			return ;
		}
		int mid=l+r&gt;&gt;1;
		if(pos&lt;=mid)modify(pos,val,l,mid,tr[x].l,tr[lx].l);
		else modify(pos,val,mid+1,r,tr[x].r,tr[lx].r);
		Update(x);
	}
	
	int query(int al,int ar,int l,int r,int x)
	{
		if(al&lt;=l&amp;&amp;r&lt;=ar){
			return tr[x].val;
		}
		int mid=l+r&gt;&gt;1,ans=0;
		if(al&lt;=mid) ans+=query(al,ar,l,mid,tr[x].l);
		if(ar&gt;mid) ans+=query(al,ar,mid+1,r,tr[x].r);
		return ans;
	}
}

struct edge{
	int x,y;
}a[maxn];

int getfather(int x)
{
	return father[x]==x?x:father[x]=getfather(father[x]);
}

int main()
{
//	freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;test.out&quot;,&quot;w&quot;,stdout);
	using namespace SegTre;
	using namespace LCT;
	int type=0;
	n=read(),m=read(),q=read(),type=read();
	memset(w,0x3f,sizeof(w));
	memset(f,0x3f,sizeof(f));
	for(int i=1;i&lt;=n;i++) father[i]=i;
	for(int i=1;i&lt;=m;i++){
		int x=read(),y=read();
		if(x==y){
			rt[i]=rt[i-1];
			continue;
		}
		a[i].x=x,a[i].y=y;
		modify(i,-1,1,m,rt[i],rt[i-1]);
		w[i+n]=i;
		int fx=getfather(x),fy=getfather(y);
		if(fx!=fy){
			father[fx]=fy;
			link(x,i+n);link(y,i+n);
		}else{
			int pos=work(x,y);
			cut(a[pos].x,pos+n);
			cut(a[pos].y,pos+n);
			link(x,i+n);link(y,i+n);
			modify(pos,0,1,m,rt[i],rt[i-1]);
		}
	}
	int lastans=0;
	for(int i=1;i&lt;=q;i++){
		int l=read(),r=read();
		if(type)l^=lastans,r^=lastans;
		int val=query(l,r,1,m,rt[r]);
		printf(&quot;%d\n&quot;,lastans=(val+n));
	}
	return 0;
}
<pre><h2>Problem3521</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef pair&lt;int,int&gt; pii;
#define inf 999999999
#define fi first
#define se second
#define mp make_pair
#define ln printf(&quot;\n&quot;)
const int NN=1001111;
int sum[NN],sta[NN];
int n,top;
char s[NN];
pii a[NN];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d\n%s&quot;,&amp;n,s+1);
	int i;
	for (i=1;i&lt;=n;i++)
		sum[i]=sum[i-1]+(s[i]=='p'?1:-1);
	//for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,sum[i]);ln;
	sta[0]=inf;
	int ans=0;
	for (i=0;i&lt;=n;i++)
	{
		pii tmp=mp(sum[i],i);
		while (sum[i]&gt;=sta[top])
			tmp=min(tmp,a[top--]);
		sta[++top]=sum[i];
		a[top]=tmp;
		if (i-tmp.se+1&gt;ans) ans=i-tmp.se;
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3521</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef pair&lt;int,int&gt; pii;
#define inf 999999999
#define fi first
#define se second
#define mp make_pair
const int NN=1001111;
int sum[NN],sta[NN];
int n,top;
char s[NN];
pii a[NN];
int main()
{
	scanf(&quot;%d\n%s&quot;,&amp;n,s+1);
	int i;
	for (i=1;i&lt;=n;i++)
		sum[i]=sum[i-1]+(s[i]=='p'?1:-1);
	sta[0]=inf;
	int ans=0;
	for (i=0;i&lt;=n;i++)
	{
		pii tmp=mp(sum[i],i);
		while (sum[i]&gt;=sta[top])
			tmp=min(tmp,a[top--]);
		sta[++top]=sum[i];
		a[top]=tmp;
		if (i-tmp.se+1&gt;ans) ans=i-tmp.se;
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3521</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
using namespace std;
const int N = 1000500;
const int T = 1048576;
const int M = 2100000;
int n;
bool dr[N];
int lv[N],rv[N];
int tree[M];
bool getbool()
{
	char ch=getchar();
	while(ch!='p' &amp;&amp; ch!='j')
		ch=getchar();
	return(ch=='p');
}
void GetData()
{
	cin&gt;&gt;n;
	int i;
	for(i=1;i&lt;=n;i++)
		dr[i]=getbool();
}
void Make(int x,int y)
{
	x+=T;
	tree[x]=y;
	x&gt;&gt;=1;
	while(x)
	{
		tree[x]=max(tree[x&lt;&lt;1],tree[(x&lt;&lt;1)|1]);
		x&gt;&gt;=1;
	}
}
void Clear()
{
	memset(tree,0xc0,sizeof tree);
	Make(0,987654321);
	Make(n+1,987654321);
}
int FindLast(int x,int y)
{
	x+=T;
	while(x)
	{
		if(x&amp;1)
		{
			if(tree[x^1]&gt;y)
				break;
		}
		x&gt;&gt;=1;
	}
	x^=1;
	while(x&lt;T)
	{
		x&lt;&lt;=1;
		if(tree[x^1]&gt;y)
			x++;
	}
	return(x-T);
}
int FindNext(int x,int y)
{
	x+=T;
	while(x)
	{
		if((x&amp;1)^1)
		{
			if(tree[x^1]&gt;y)
				break;
		}
		x&gt;&gt;=1;
	}
	x^=1;
	while(x&lt;T)
	{
		x&lt;&lt;=1;
		if(tree[x]&lt;=y)
			x++;
	}
	return(x-T);
}
void DoIt()
{
	int i,now;
	Clear();
	now=0;
	for(i=1;i&lt;=n;i++)
	{
		if(dr[i])
			now++;
		else
			now--;
		Make(i,now);
		lv[i]=FindLast(i,now);
	}
	Clear();
	now=0;
	for(i=n;i&gt;=1;i--)
	{
		if(dr[i])
			now++;
		else
			now--;
		Make(i,now);
		rv[i]=FindNext(i,now);
	}
	int ans=0;
	Clear();
	for(i=1;i&lt;=n;i++)
	{
		Make(i,rv[i]);
		now=FindNext(lv[i],i);
		ans=max(ans,i-now+1);
	}
	cout&lt;&lt;ans&lt;&lt;endl;
}
int main()
{
	GetData();
	DoIt();
	return 0;
}<pre><h2>Problem3522</h2><pre>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
inline void in(int &amp;TEMP){int EPX;for(TEMP=getchar();TEMP&lt;48||TEMP&gt;57;TEMP=getchar());for(TEMP^=48,EPX=getchar();EPX&lt;58&amp;&amp;EPX&gt;47;EPX=getchar())TEMP=(TEMP&lt;&lt;3)+(TEMP&lt;&lt;1)+(EPX^48);}
long long ans,num[51000],d[51000],now[51000];
int n,shu,first[51000];
struct edge{int v,nx;}o[110000];
inline void add(int u,int v){o[++shu].v=v,o[shu].nx=first[u],first[u]=shu;}
inline void dfs(int x,int last,int w){
	++now[w];
	for(int i=first[x];i;i=o[i].nx)
	    if(o[i].v!=last)
			dfs(o[i].v,x,w+1);
}
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1,u,v;i&lt;n;++i) in(u),in(v),add(u,v),add(v,u);
	for(int i=1;i&lt;=n;++i){
	    for(int j=1;j&lt;=n;++j)d[j]=num[j]=0;
	    for(int j=first[i];j;j=o[j].nx){
	        dfs(o[j].v,i,1);
			for(int k=1;k&lt;=n;++k)
				ans+=now[k]*d[k],d[k]+=now[k]*num[k],num[k]+=now[k],now[k]=0;
		}
	}
	printf(&quot;%lld\n&quot;,ans);
}
<pre><h2>Problem3522</h2><pre>#include&lt;cstdio&gt;

#define maxn 50010

using namespace std;

inline int read()
{
	int ret=0;char ch=getchar();
	while(ch&lt;'!') ch=getchar();
	while(ch&gt;'!') ret=ret*10+ch-'0',ch=getchar();
	return ret;
}

typedef long long ll;
int n,tot,b[maxn],mx;
ll ans,S[maxn],t[maxn],sum[maxn];
bool vis[maxn];

struct edge{
	int x,y,last;
}a[maxn];

void add(int x,int y)
{
	a[++tot]=(edge){x,y,b[x]};
	b[x]=tot;
}

void dfs(int x,int dep)
{
	vis[x]=1;
	t[dep]++;
	if(dep&gt;mx) mx=dep;
	for(int i=b[x];i;i=a[i].last){
		int v=a[i].y;
		if(!vis[v]) dfs(v,dep+1);
	}
}

void work(int x)
{
	vis[x]=1;
	for(int i=b[x];i;i=a[i].last){
		int v=a[i].y;
		mx=0;
		dfs(v,1);
		for(int i=1;i&lt;=mx;i++){
			ans+=t[i]*S[i];
			S[i]+=sum[i]*t[i];
			sum[i]+=t[i];
			t[i]=0;
		}
	}
}

int main()
{
	n=read();
	ans=0,tot=0;
	for(int i=1;i&lt;=n;i++) b[i]=0;
	for(int i=1;i&lt;n;i++){
		int x=read(),y=read();
		add(x,y);add(y,x);
	}
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=n;j++) vis[j]=0,S[j]=0,sum[j]=0;
		work(i);
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem3522</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstdlib&gt; 
#include &lt;cstring&gt; 
#include &lt;iostream&gt; 
#include &lt;algorithm&gt; 

using namespace std;

typedef int arr32[200010];

arr32 x,y;
int n;

struct task_thr {
	arr32 c,next,g,md,d;
	long long * f[200010],*h[200010],arr[2000010],*arrp;
	int ap;
	long long ans;
	void link(int x, int y) {
		c[++ap] = y,next[ap] = g[x],g[x] = ap;
		c[++ap] = x,next[ap] = g[y],g[y] = ap;
	}

	void init() {
		memset(g, 0, sizeof(g)),
		ap = 1;
		memset(arr, 0, sizeof(arr)),
		arrp = arr;
		ans = 0;
	}

	void dfs(int z, int ft) {
		d[z] = d[ft] + 1,
		md[z] = z;
		for (int x = g[z]; x; x = next[x]) if (c[x] != ft) {
			dfs(c[x], z);
			if (d[md[c[x]]] &gt; d[md[z]]) md[z] = md[c[x]];
		}
		for (int x = g[z]; x; x = next[x]) if (c[x] != ft) {
			if (md[c[x]] != md[z] || z == 1) {
				int p = md[c[x]];
				arrp += d[p] - d[z] + 5,
				f[p] = arrp,
				arrp += d[p] - d[z] + 5;
				h[p] = arrp + 5,
				arrp += (d[p] - d[z]) * 2 + 10;
			}
		}
	}

	void dp(int z, int ft) {
		for (int x = g[z]; x; x = next[x]) if (c[x] != ft) {
			dp(c[x], z);
			if (md[c[x]] == md[z]) {
				f[z] = f[c[x]] - 1;
				h[z] = h[c[x]] + 1;
			}
		}
		long long * fz = f[z],
		*hz = h[z];
		fz[0] = 1,
		ans += hz[0];
		for (int x = g[z]; x; x = next[x]) if (c[x] != ft) {
			if (md[c[x]] == md[z]) continue;
			int s = d[md[c[x]]] - d[z];
			long long * ft = f[c[x]],
			*ht = h[c[x]];
			for (int i = 0; i &lt;= s; ++i) {
				ans += fz[i - 1] * ht[i];
				ans += hz[i + 1] * ft[i];
			}
			for (int i = 0; i &lt;= s; ++i) {
				hz[i - 1] += ht[i];
				hz[i + 1] += fz[i + 1] * ft[i];
				fz[i + 1] += ft[i];
			}
		}
	}

	long long count(int n, int * x, int * y) {
		if (n == 1) return (0);
		init();
		for (int i = 1; i &lt; n; ++i) link(x[i], y[i]);
		dfs(1, 0);
		dp(1, 0);
		return (ans);
	}
};
int main() {
//	freopen(&quot;thr.in&quot;, &quot;r&quot;, stdin);
//	freopen(&quot;thr.out&quot;, &quot;w&quot;, stdout);
	task_thr * thr = new task_thr();
	int testnum = 0;
	//while (true) {
		scanf(&quot;%d&quot;, &amp;n);
		//if (n == 0) break;
		for (int i = 1; i &lt; n; ++i) scanf(&quot;%d %d&quot;, x + i, y + i);
		cout &lt;&lt; thr-&gt;count(n, x, y) &lt;&lt; endl;
	//}
}
<pre><h2>Problem3529</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=1001111,QQ=201111;
int miu[NN],f[NN],pr[NN],c[NN],ans[NN];
int tes,cnt;
bool is[NN];
struct fff
{
	int f,id;
	friend bool operator &lt;(fff a,fff b) {return a.f&lt;b.f;}
} b[NN];
struct query
{
	int n,m,a,id;
	friend bool operator &lt;(query a,query b) {return a.a&lt;b.a;}
} q[QQ];
void prepare()
{
	memset(is,1,sizeof(is));
	is[1]=false;
	miu[1]=1;
	int i,j;
	for (i=2;i&lt;=100000;i++)
	{
		if (is[i]) pr[++cnt]=i,miu[i]=-1;
		for (j=1;j&lt;=cnt;j++)
		{
			int x=i*pr[j];
			if (x&gt;100000) break;
			is[x]=false;
			if (i%pr[j]==0) {miu[x]=0;break;}
			else miu[x]=-miu[i];
		}
	}
	for (i=1;i&lt;=100000;i++)
		for (j=i;j&lt;=100000;j+=i) f[j]+=i;
	for (i=1;i&lt;=100000;i++) b[i].f=f[i],b[i].id=i;
	sort(b+1,b+100000+1);
}
void change(int i,int x)
{
	for (;i&lt;=100000;i+=i&amp;-i) c[i]+=x;
}
void add(int f,int i)
{
	for (int t=1;t*i&lt;=100000;t++) change(i*t,f*miu[t]);
}
int getsum(int i)
{
	int res=0;
	for (;i;i-=i&amp;-i) res+=c[i];
	return res;
}
int find(int n,int m)
{
	if (n&gt;m) {int t=n;n=m;m=t;}
	int l,r,res=0;
	for (l=1;l&lt;=n;l=r+1)
	{
		r=min(n/(n/l),m/(m/l));
		res+=(getsum(r)-getsum(l-1))*(n/l)*(m/l);
	}
	return res&amp;0x7fffffff;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	prepare();
	//for (int i=1;i&lt;=10;i++) printf(&quot;%d &quot;,miu[i]);ln;
	scanf(&quot;%d&quot;,&amp;tes);
	int i,now;
	for (i=1;i&lt;=tes;i++) scanf(&quot;%d%d%d&quot;,&amp;q[i].n,&amp;q[i].m,&amp;q[i].a),q[i].id=i;
	sort(q+1,q+tes+1);
	now=1;
	for (i=1;i&lt;=tes;i++)
	{
		for (;now&lt;=100000&amp;&amp;b[now].f&lt;=q[i].a;now++) add(b[now].f,b[now].id);
		ans[q[i].id]=find(q[i].n,q[i].m);
	}
	for (i=1;i&lt;=tes;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem3529</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=1001111,QQ=201111;
int miu[NN],f[NN],pr[NN],c[NN],ans[NN];
int tes,cnt;
bool is[NN];
struct fff
{
	int f,id;
	friend bool operator &lt;(fff a,fff b) {return a.f&lt;b.f;}
} b[NN];
struct query
{
	int n,m,a,id;
	friend bool operator &lt;(query a,query b) {return a.a&lt;b.a;}
} q[QQ];
void prepare()
{
	memset(is,1,sizeof(is));
	is[1]=false;
	miu[1]=1;
	int i,j;
	for (i=2;i&lt;=100000;i++)
	{
		if (is[i]) pr[++cnt]=i,miu[i]=-1;
		for (j=1;j&lt;=cnt;j++)
		{
			int x=i*pr[j];
			if (x&gt;100000) break;
			is[x]=false;
			if (i%pr[j]==0) {miu[x]=0;break;}
			else miu[x]=-miu[i];
		}
	}
	for (i=1;i&lt;=100000;i++)
		for (j=i;j&lt;=100000;j+=i) f[j]+=i;
	for (i=1;i&lt;=100000;i++) b[i].f=f[i],b[i].id=i;
	sort(b+1,b+100000+1);
}
void change(int i,int x)
{
	for (;i&lt;=100000;i+=i&amp;-i) c[i]+=x;
}
void add(int f,int i)
{
	for (int t=1;t*i&lt;=100000;t++) change(i*t,f*miu[t]);
}
int getsum(int i)
{
	int res=0;
	for (;i;i-=i&amp;-i) res+=c[i];
	return res;
}
int find(int n,int m)
{
	if (n&gt;m) {int t=n;n=m;m=t;}
	int l,r,res=0;
	for (l=1;l&lt;=n;l=r+1)
	{
		r=min(n/(n/l),m/(m/l));
		res+=(getsum(r)-getsum(l-1))*(n/l)*(m/l);
	}
	if (res&lt;0) res+=1&lt;&lt;31;
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	prepare();
	//for (int i=1;i&lt;=10;i++) printf(&quot;%d &quot;,miu[i]);ln;
	scanf(&quot;%d&quot;,&amp;tes);
	int i,now;
	for (i=1;i&lt;=tes;i++) scanf(&quot;%d%d%d&quot;,&amp;q[i].n,&amp;q[i].m,&amp;q[i].a),q[i].id=i;
	sort(q+1,q+tes+1);
	now=1;
	for (i=1;i&lt;=tes;i++)
	{
		for (;now&lt;=100000&amp;&amp;b[now].f&lt;=q[i].a;now++) add(b[now].f,b[now].id);
		ans[q[i].id]=find(q[i].n,q[i].m);
	}
	for (i=1;i&lt;=tes;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem3530</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mo 1000000007
int son[1550][10],N[1550],fail[1550],f[1550][1550],q[1550];
int n,TTT,m,ans;
bool danger[1550];
char s[1550];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,j,k,x,len,now,head,tail;
	for (i=0;i&lt;10;i++) son[0][i]=1;
	TTT=1;
	scanf(&quot;%s&quot;,s+1);
	n=strlen(s+1);
	//printf(&quot;%d\n&quot;,n);
	for (i=1;i&lt;=n;i++) N[i]=s[i]-'0';
	scanf(&quot;%d\n&quot;,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%s&quot;,s+1);
		for (len=strlen(s+1),now=1,j=1;j&lt;=len;j++)
		{
			if (danger[now]) break;
			int tmp=s[j]-'0';
			//printf(&quot;%d\n&quot;,tmp);
			if (son[now][tmp]) now=son[now][tmp];
			else son[now][tmp]=++TTT,now=TTT;
		}
		danger[now]=true;
	}
	head=0,q[tail=1]=1;
	while (head&lt;tail)
	{
		x=q[++head];
		if (danger[x]|=danger[fail[x]]) continue;
		for (i=0;i&lt;10;i++)
			if (son[x][i]==0) son[x][i]=son[fail[x]][i];
			else fail[son[x][i]]=son[fail[x]][i],q[++tail]=son[x][i];
	}
	//for (i=1;i&lt;=TTT;i++) printf(&quot;%d\n&quot;,fail[i]);
	for (i=1;i&lt;=TTT;i++) if (!danger[i]) f[1][i]=1;
	for (i=2;i&lt;=n;i++)
		for (j=1;j&lt;=TTT;j++)
		{
			if (danger[j]) continue;
			for (k=0;k&lt;10;k++) f[i][j]=(f[i][j]+f[i-1][son[j][k]])%mo;
			//printf(&quot;%d %d %d\n&quot;,i,j,f[i][j]);
		}
	ans=1;
	for (i=1;i&lt;n;i++)
		for (j=1;j&lt;10;j++) ans=(ans+f[i][son[1][j]])%mo;
	//printf(&quot;%d\n&quot;,ans);
	for (i=1;i&lt;N[1];i++) ans=(ans+f[n][son[1][i]])%mo;
	//printf(&quot;%d\n&quot;,ans);
	for (now=son[1][N[1]],i=2;i&lt;=n;i++)
	{
		if (danger[now]) break;
		for (j=0;j&lt;N[i];j++) ans=(ans+f[n-i+1][son[now][j]])%mo;
		now=son[now][N[i]];
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem3530</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mo 1000000007
int son[1550][10],N[1550],fail[1550],f[1550][1550],q[1550];
int n,TTT,m,ans;
bool danger[1550];
char s[1550];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,j,k,x,len,now,head,tail;
	for (i=0;i&lt;10;i++) son[0][i]=1;
	TTT=1;
	scanf(&quot;%s&quot;,s+1);
	n=strlen(s+1);
	for (i=1;i&lt;=n;i++) N[i]=s[i]-'0';
	scanf(&quot;%d\n&quot;,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%s&quot;,s+1);
		for (len=strlen(s+1),now=1,j=1;j&lt;=len;j++)
		{
			if (danger[now]) break;
			int tmp=s[j]-'0';
			if (son[now][tmp]) now=son[now][tmp];
			else son[now][tmp]=++TTT,now=TTT;
		}
		danger[now]=true;
	}
	head=0,q[tail=1]=1;
	while (head&lt;tail)
	{
		x=q[++head];
		if (danger[x]|=danger[fail[x]]) continue;
		for (i=0;i&lt;10;i++)
			if (son[x][i]==0) son[x][i]=son[fail[x]][i];
			else fail[son[x][i]]=son[fail[x]][i],q[++tail]=son[x][i];
	}
	for (i=1;i&lt;=TTT;i++) if (!danger[i]) f[1][i]=1;
	for (i=2;i&lt;=n;i++)
		for (j=1;j&lt;=TTT;j++)
		{
			if (danger[j]) continue;
			for (k=0;k&lt;10;k++) f[i][j]=(f[i][j]+f[i-1][son[j][k]])%mo;
		}
	ans=1;
	for (i=1;i&lt;n;i++)
		for (j=1;j&lt;10;j++) ans=(ans+f[i][son[1][j]])%mo;
	for (i=1;i&lt;N[1];i++) ans=(ans+f[n][son[1][i]])%mo;
	for (now=son[1][N[1]],i=2;i&lt;=n;i++)
	{
		if (danger[now]) break;
		for (j=0;j&lt;N[i];j++) ans=(ans+f[n-i+1][son[now][j]])%mo;
		now=son[now][N[i]];
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem3531</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define maa(a,b) ((a)&gt;(b)?(a):(b))
#define ln printf(&quot;\n&quot;)
const int NN=101111,MM=4001111;
int tsum[MM],tmax[MM],lc[MM],rc[MM],pos[NN],size[NN],up[NN],heavy[NN],fa[NN];
int deep[NN],o[NN],aa[NN*2][2],W[NN],C[NN];
int n,m,TTT,cnt,tot=1;
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
struct Segment_Tree
{
	int root;
	void update(int v)
	{
		int x=lc[v],y=rc[v];
		tsum[v]=tsum[x]+tsum[y];
		tmax[v]=maa(tmax[x],tmax[y]);
	}
	void ins(int &amp;v,int l,int r,int i,int x)
	{
		//printf(&quot;%d %d %d\n&quot;,root,i,x);
		if (!v) v=++TTT;
		if (r-l==1)
		{
			tsum[v]=tmax[v]=x;
			return;
		}
		int mid=(l+r)&gt;&gt;1;
		if (i&lt;mid) ins(lc[v],l,mid,i,x);
		else ins(rc[v],mid,r,i,x);
		update(v);
	}
	void del(int v,int l,int r,int i)
	{
		if (r-l==1)
		{
			tsum[v]=tmax[v]=0;
			return;
		}
		int mid=(l+r)&gt;&gt;1;
		if (i&lt;mid) del(lc[v],l,mid,i);
		else del(rc[v],mid,r,i);
		update(v);
	}
	int findsum(int v,int l,int r,int ww,int ee)
	{
		if (!v) return 0;
		if (ww&lt;=l&amp;&amp;r&lt;=ee) return tsum[v];
		int mid=(l+r)&gt;&gt;1,res=0;
		if (ww&lt;mid) res+=findsum(lc[v],l,mid,ww,ee);
		if (ee&gt;mid) res+=findsum(rc[v],mid,r,ww,ee);
		return res;
	}
	int findmax(int v,int l,int r,int ww,int ee)
	{
		if (!v) return 0;
		if (ww&lt;=l&amp;&amp;r&lt;=ee) return tmax[v];
		int mid=(l+r)&gt;&gt;1,res=0;
		if (ww&lt;mid) res=max(res,findmax(lc[v],l,mid,ww,ee));
		if (ee&gt;mid) res=max(res,findmax(rc[v],mid,r,ww,ee));
		return res;
	}
	int getsum(int x,int y)
	{
		int res=0;
		while (up[x]!=up[y])
		{
			if (deep[up[x]]&lt;deep[up[y]]) {int t=x;x=y;y=t;}
			res+=findsum(root,1,n+1,pos[up[x]],pos[x]+1);
			x=fa[up[x]];
		}
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		res+=findsum(root,1,n+1,pos[y],pos[x]+1);
		return res;
	}
	int getmax(int x,int y)
	{
		int res=0;
		while (up[x]!=up[y])
		{
			if (deep[up[x]]&lt;deep[up[y]]) {int t=x;x=y;y=t;}
			res=max(res,findmax(root,1,n+1,pos[up[x]],pos[x]+1));
			x=fa[up[x]];
		}
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		res=max(res,findmax(root,1,n+1,pos[y],pos[x]+1));
		return res;
	}
} T[NN];
void dfs(int v)
{
	//size,heavy,deep,fa,up,pos,which
	int tmp=0,mm=0;
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		dfs(y);
		size[v]+=size[y];
		if (size[y]&gt;mm) mm=size[y],tmp=y;
	}
	heavy[v]=tmp;
}
void dfs2(int v)
{
	//printf(&quot;dfs2 %d\n&quot;,v);
	pos[v]=++cnt;
	if (!heavy[v]) return;
	up[heavy[v]]=up[v];
	dfs2(heavy[v]);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||y==heavy[v]) continue;
		up[y]=y;
		dfs2(y);
	}
}
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;W[i],&amp;C[i]);
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	deep[1]=1;
	dfs(1);
	//printf(&quot;size &quot;);out(size,1,n);
	up[1]=1;
	dfs2(1);
	//printf(&quot;fa &quot;),out(fa,1,n);printf(&quot;heavy &quot;),out(heavy,1,n);printf(&quot;pos &quot;),out(pos,1,n);printf(&quot;up &quot;),out(up,1,n);
	for (i=1;i&lt;=n;i++)
		T[C[i]].ins(T[C[i]].root,1,n+1,pos[i],W[i]);
	for (i=1;i&lt;=m;i++)
	{
		//printf(&quot;\n-----------------------------------------------------------------------\n&quot;);
		char ch=getchar();
		while (ch!='C'&amp;&amp;ch!='Q') ch=getchar();
		if (ch=='C')
		{
			ch=getchar();
			if (ch=='C')
			{
				scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
				T[C[x]].del(T[C[x]].root,1,n+1,pos[x]);
				T[y].ins(T[y].root,1,n+1,pos[x],W[x]);
				C[x]=y;
			}
			else
			{
				scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
				T[C[x]].ins(T[C[x]].root,1,n+1,pos[x],y);
				W[x]=y;
			}
		}
		else
		{
			ch=getchar();
			if (ch=='S')
			{
				scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
				printf(&quot;%d\n&quot;,T[C[x]].getsum(x,y));
			}
			else
			{
				scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
				printf(&quot;%d\n&quot;,T[C[x]].getmax(x,y));
			}
		}
	}
	return 0;
}
<pre><h2>Problem3531</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define maa(a,b) ((a)&gt;(b)?(a):(b))
const int NN=101111,MM=4001111;
int tsum[MM],tmax[MM],lc[MM],rc[MM],pos[NN],size[NN],up[NN],heavy[NN],fa[NN];
int deep[NN],o[NN],aa[NN*2][2],W[NN],C[NN];
int n,m,TTT,cnt,tot=1;
struct Segment_Tree
{
	int root;
	void update(int v)
	{
		int x=lc[v],y=rc[v];
		tsum[v]=tsum[x]+tsum[y];
		tmax[v]=maa(tmax[x],tmax[y]);
	}
	void ins(int &amp;v,int l,int r,int i,int x)
	{
		if (!v) v=++TTT;
		if (r-l==1)
		{
			tsum[v]=tmax[v]=x;
			return;
		}
		int mid=(l+r)&gt;&gt;1;
		if (i&lt;mid) ins(lc[v],l,mid,i,x);
		else ins(rc[v],mid,r,i,x);
		update(v);
	}
	int findsum(int v,int l,int r,int ww,int ee)
	{
		if (!v) return 0;
		if (ww&lt;=l&amp;&amp;r&lt;=ee) return tsum[v];
		int mid=(l+r)&gt;&gt;1,res=0;
		if (ww&lt;mid) res+=findsum(lc[v],l,mid,ww,ee);
		if (ee&gt;mid) res+=findsum(rc[v],mid,r,ww,ee);
		return res;
	}
	int findmax(int v,int l,int r,int ww,int ee)
	{
		if (!v) return 0;
		if (ww&lt;=l&amp;&amp;r&lt;=ee) return tmax[v];
		int mid=(l+r)&gt;&gt;1,res=0;
		if (ww&lt;mid) res=max(res,findmax(lc[v],l,mid,ww,ee));
		if (ee&gt;mid) res=max(res,findmax(rc[v],mid,r,ww,ee));
		return res;
	}
	int getsum(int x,int y)
	{
		int res=0;
		while (up[x]!=up[y])
		{
			if (deep[up[x]]&lt;deep[up[y]]) {int t=x;x=y;y=t;}
			res+=findsum(root,1,n+1,pos[up[x]],pos[x]+1);
			x=fa[up[x]];
		}
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		res+=findsum(root,1,n+1,pos[y],pos[x]+1);
		return res;
	}
	int getmax(int x,int y)
	{
		int res=0;
		while (up[x]!=up[y])
		{
			if (deep[up[x]]&lt;deep[up[y]]) {int t=x;x=y;y=t;}
			res=max(res,findmax(root,1,n+1,pos[up[x]],pos[x]+1));
			x=fa[up[x]];
		}
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		res=max(res,findmax(root,1,n+1,pos[y],pos[x]+1));
		return res;
	}
} T[NN];
void dfs(int v)
{
	int tmp=0,mm=0;
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		dfs(y);
		size[v]+=size[y];
		if (size[y]&gt;mm) mm=size[y],tmp=y;
	}
	heavy[v]=tmp;
}
void dfs2(int v)
{
	pos[v]=++cnt;
	if (!heavy[v]) return;
	up[heavy[v]]=up[v];
	dfs2(heavy[v]);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||y==heavy[v]) continue;
		up[y]=y;
		dfs2(y);
	}
}
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;W[i],&amp;C[i]);
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	deep[1]=1;
	dfs(1);
	up[1]=1;
	dfs2(1);
	for (i=1;i&lt;=n;i++)
		T[C[i]].ins(T[C[i]].root,1,n+1,pos[i],W[i]);
	for (i=1;i&lt;=m;i++)
	{
		char ch=getchar();
		while (ch!='C'&amp;&amp;ch!='Q') ch=getchar();
		if (ch=='C')
		{
			ch=getchar();
			if (ch=='C')
			{
				scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
				T[C[x]].ins(T[C[x]].root,1,n+1,pos[x],0);
				T[y].ins(T[y].root,1,n+1,pos[x],W[x]);
				C[x]=y;
			}
			else
			{
				scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
				T[C[x]].ins(T[C[x]].root,1,n+1,pos[x],y);
				W[x]=y;
			}
		}
		else
		{
			ch=getchar();
			if (ch=='S')
			{
				scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
				printf(&quot;%d\n&quot;,T[C[x]].getsum(x,y));
			}
			else
			{
				scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
				printf(&quot;%d\n&quot;,T[C[x]].getmax(x,y));
			}
		}
	}
	return 0;
}
<pre><h2>Problem3531</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define maa(a,b) ((a)&gt;(b)?(a):(b))
const int NN=101111,MM=4001111;
int tsum[MM],tmax[MM],lc[MM],rc[MM],pos[NN],size[NN],up[NN],heavy[NN],fa[NN];
int deep[NN],o[NN],aa[NN*2][2],W[NN],C[NN],cur[NN],sta[NN],vt[NN];
int n,m,TTT,cnt,tot=1;
struct Segment_Tree
{
	int root;
	void update(int v)
	{
		int x=lc[v],y=rc[v];
		tsum[v]=tsum[x]+tsum[y];
		tmax[v]=maa(tmax[x],tmax[y]);
	}
	void ins(int &amp;v,int l,int r,int i,int x)
	{
		if (!v) v=++TTT;
		if (r-l==1)
		{
			tsum[v]=tmax[v]=x;
			return;
		}
		int mid=(l+r)&gt;&gt;1;
		if (i&lt;mid) ins(lc[v],l,mid,i,x);
		else ins(rc[v],mid,r,i,x);
		update(v);
	}
	int findsum(int v,int l,int r,int ww,int ee)
	{
		if (!v) return 0;
		if (ww&lt;=l&amp;&amp;r&lt;=ee) return tsum[v];
		int mid=(l+r)&gt;&gt;1,res=0;
		if (ww&lt;mid) res+=findsum(lc[v],l,mid,ww,ee);
		if (ee&gt;mid) res+=findsum(rc[v],mid,r,ww,ee);
		return res;
	}
	int findmax(int v,int l,int r,int ww,int ee)
	{
		if (!v) return 0;
		if (ww&lt;=l&amp;&amp;r&lt;=ee) return tmax[v];
		int mid=(l+r)&gt;&gt;1,res=0;
		if (ww&lt;mid) res=max(res,findmax(lc[v],l,mid,ww,ee));
		if (ee&gt;mid) res=max(res,findmax(rc[v],mid,r,ww,ee));
		return res;
	}
	int getsum(int x,int y)
	{
		int res=0;
		while (up[x]!=up[y])
		{
			if (deep[up[x]]&lt;deep[up[y]]) {int t=x;x=y;y=t;}
			res+=findsum(root,1,n+1,pos[up[x]],pos[x]+1);
			x=fa[up[x]];
		}
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		res+=findsum(root,1,n+1,pos[y],pos[x]+1);
		return res;
	}
	int getmax(int x,int y)
	{
		int res=0;
		while (up[x]!=up[y])
		{
			if (deep[up[x]]&lt;deep[up[y]]) {int t=x;x=y;y=t;}
			res=max(res,findmax(root,1,n+1,pos[up[x]],pos[x]+1));
			x=fa[up[x]];
		}
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		res=max(res,findmax(root,1,n+1,pos[y],pos[x]+1));
		return res;
	}
} T[NN];
void dfs(int v)
{
	/*int tmp=0,mm=0;
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		dfs(y);
		size[v]+=size[y];
		if (size[y]&gt;mm) mm=size[y],tmp=y;
	}
	heavy[v]=tmp;*/
	int top=0;
	sta[top=1]=1;
	cur[1]=o[1];
	size[1]=1;
	vt[1]=1;
	while (top)
	{
		int v=sta[top];
		int p=cur[v];
		if (p==0) {top--;continue;}
		int y=aa[p][1];
		if (y==fa[v]) {cur[v]=aa[p][0];continue;}
		if (!vt[y])
		{
			vt[y]=1;
			fa[y]=v;
			deep[y]=deep[v]+1;
			sta[++top]=y,cur[y]=o[y];
			size[y]=1;
		}
		else
		{
			size[v]+=size[y];
			if (size[y]&gt;size[heavy[v]]) heavy[v]=y;
			cur[v]=aa[p][0];
		}
	}
}
void dfs2(int v)
{
	pos[v]=++cnt;
	if (!heavy[v]) return;
	up[heavy[v]]=up[v];
	dfs2(heavy[v]);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||y==heavy[v]) continue;
		up[y]=y;
		dfs2(y);
	}
}
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;W[i],&amp;C[i]);
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	deep[1]=1;
	dfs(1);
	up[1]=1;
	dfs2(1);
	for (i=1;i&lt;=n;i++)
		T[C[i]].ins(T[C[i]].root,1,n+1,pos[i],W[i]);
	for (i=1;i&lt;=m;i++)
	{
		char ch=getchar();
		while (ch!='C'&amp;&amp;ch!='Q') ch=getchar();
		if (ch=='C')
		{
			ch=getchar();
			if (ch=='C')
			{
				scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
				T[C[x]].ins(T[C[x]].root,1,n+1,pos[x],0);
				T[y].ins(T[y].root,1,n+1,pos[x],W[x]);
				C[x]=y;
			}
			else
			{
				scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
				T[C[x]].ins(T[C[x]].root,1,n+1,pos[x],y);
				W[x]=y;
			}
		}
		else
		{
			ch=getchar();
			if (ch=='S')
			{
				scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
				printf(&quot;%d\n&quot;,T[C[x]].getsum(x,y));
			}
			else
			{
				scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
				printf(&quot;%d\n&quot;,T[C[x]].getmax(x,y));
			}
		}
	}
	return 0;
}
<pre><h2>Problem3532</h2><pre>/**************************************************************
    Problem: 3532
    User: zhuohan123
    Language: C++
    Result: Accepted
    Time:9472 ms
    Memory:18660 kb
****************************************************************/
 
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int maxpoint=11000,maxedge=1100000;
const LL inf=~0ULL&gt;&gt;3;
int head[maxpoint],nowhead[maxpoint],pointsize;
struct edge{int to,next;LL c;}g[maxedge];int gnum=1;
void addedge(int from,int to,LL c)
{
    g[++gnum].to=to;g[gnum].c=c;g[gnum].next=head[from];head[from]=gnum;
    g[++gnum].to=from;g[gnum].c=0;g[gnum].next=head[to];head[to]=gnum;
}
int dfsstart,dfsend,dis[maxpoint];
int q[maxpoint],ql,qr;
bool BFS()
{
    for(int i=1;i&lt;=pointsize;i++)nowhead[i]=head[i],dis[i]=0;
    ql=1;qr=0;q[++qr]=dfsend;
    while(ql&lt;=qr)
        for(int now=q[ql++],i=head[now];i;i=g[i].next)
        if(g[i^1].c&amp;&amp;!dis[g[i].to]&amp;&amp;g[i].to!=dfsend)
            dis[q[++qr]=g[i].to]=dis[now]+1;
    return dis[dfsstart];
}
LL DFS(int po,LL delta)
{
    if(po==dfsend)return delta;
    LL nowans=0,tans;
    for(int&amp;i=nowhead[po];i&amp;&amp;delta;i=g[i].next)
        if(g[i].c&amp;&amp;dis[g[i].to]+1==dis[po]&amp;&amp;(tans=DFS(g[i].to,min(delta,g[i].c))))
            g[i].c-=tans,g[i^1].c+=tans,nowans+=tans,delta-=tans;
    return nowans;
}
LL dinic(int start,int end)
{
    dfsstart=start,dfsend=end;
    LL ans=0;
    while(BFS())ans+=DFS(start,inf);
    return ans;
}
int n;
int a[1100],b[1100],f[1100];
struct T
{
    int num,pos;
    friend bool operator&lt;(T A,T B){return A.num&lt;B.num;}
}c[1100];
int oans[1100],ansnum;
int main(int argc, char *argv[])
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
    //freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    int Ti;scanf(&quot;%d&quot;,&amp;Ti);
    while(Ti--)
    {
        memset(head,0,sizeof head);gnum=1;
        scanf(&quot;%d&quot;,&amp;n);
        for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]);
        for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;b[i]);
        for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;c[i].num),c[i].pos=i;
        int maxf=0;
        for(int i=1;i&lt;=n;i++)f[i]=1;
        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;i;j++)
                if(a[j]&lt;a[i])maxf=max(maxf,f[i]=max(f[i],f[j]+1));
        for(int i=1;i&lt;=n;i++)
        {
            addedge(2*i+1,2*i+2,b[i]);
            if(f[i]==1)addedge(1,2*i+1,inf);
            if(f[i]==maxf)addedge(2*i+2,2,inf);
            for(int j=1;j&lt;i;j++)
                if(a[j]&lt;a[i]&amp;&amp;(f[j]+1==f[i]))
                addedge(2*j+2,2*i+1,inf);
        }
        pointsize=2*n+2;
        LL ans=dinic(1,2);
        sort(c+1,c+n+1);
        ansnum=0;
        for(int i=1;i&lt;=n;i++)
        {
            int ne=0,po=c[i].pos;
            for(int j=head[2*po+1];j;j=g[j].next)
                if(g[j].to==2*po+2){ne=j;break ;}
            if(g[ne].c==0)
            {
                dfsstart=2*po+1,dfsend=2*po+2;
                if(!BFS())
                {
                    dinic(2,2*po+2);
                    dinic(2*po+1,1);
                    g[ne^1].c=0;
                    oans[++ansnum]=po;
                }
            }
        }
        sort(oans+1,oans+ansnum+1);
        printf(&quot;%lld %d\n&quot;,ans,ansnum);
        for(int i=1;i&lt;ansnum;i++)printf(&quot;%d &quot;,oans[i]);printf(&quot;%d\n&quot;,oans[ansnum]);
         
    }
    return 0;
}<pre><h2>Problem3532</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf=99999999;
int q[100000],o[100000],aa[1000000][3],a[1000],b[1000],e[1000],deep[100000],ans[1000],f[1000];
int S,T,head,tail,n,tot,start,end;
bool vt[100000];
int max(int a,int b) {return a&gt;b?a:b;}
struct arr
{
	int pos,val;
} c[1000];
bool cmp(arr x,arr y)
{
	return x.val&lt;y.val;
}
void init()
{
	int i;
	scanf(&quot;%d&quot;,&amp;n);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;b[i]);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;c[i].val),c[i].pos=i;
	sort(c+1,c+n+1,cmp);
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v)
{
	//printf(&quot;%d %d %d\n&quot;,p,q,v);
	addedge(p,q,v);
	addedge(q,p,0);
}
void prepare()
{
	int lis,i,j;
	lis=0;
	for (i=1;i&lt;=n;i++)
	{
		f[i]=1;
		for (j=1;j&lt;i;j++)
			if (a[i]&gt;a[j]) f[i]=max(f[i],f[j]+1);
		lis=max(lis,f[i]);
	}
	tot=1;
	S=n*2+1,T=S+1;
	memset(o,0,sizeof(o[0])*(T+10));
	for (i=1;i&lt;=n;i++)
	{
		e[i]=tot+1;
		//printf(&quot;----------------- %d\n&quot;,e[3]);
		add(i*2-1,i*2,b[i]);
		if (f[i]==1) add(S,i*2-1,inf);
		if (f[i]==lis) add(i*2,T,inf);
		for (j=1;j&lt;i;j++)
			if (a[j]&lt;a[i]&amp;&amp;f[j]+1==f[i]) add(j*2,i*2-1,inf);
	}
}
void bfs()
{
	int head=0,tail=0;
	memset(deep,0,sizeof(deep[0])*(T+10));
	deep[start]=1;
	q[++tail]=start;
	while (head&lt;tail)
	{
		int x=q[++head];
		int p=o[x];
		while (p)
		{
			int y=aa[p][1];
			if (!deep[y]&amp;&amp;aa[p][2])
			{
				deep[y]=deep[x]+1;
				q[++tail]=y;
			}
			p=aa[p][0];
		}
	}
}
int dfs(int v,int flow)
{
	if (v==end) return flow;
	int res=0,p=o[v];
	while (p)
	{
		int y=aa[p][1];
		if (aa[p][2]&amp;&amp;deep[y]==deep[v]+1)
		{
			int tmp=dfs(y,min(flow,aa[p][2]));
			if (!tmp) deep[y]=inf;
			flow-=tmp;
			aa[p][2]-=tmp;
			aa[p^1][2]+=tmp;
			res+=tmp;
			if (!flow) break;
		}
		p=aa[p][0];
	}
	return res;
}
int dinic(int SS,int TT)
{
	int res=0;
	start=SS,end=TT;
	bfs();
	while (deep[end])
	{
		res+=dfs(start,inf);
		bfs();
	}
	return res;
}
bool find(int v,int goal)
{
	if (v==goal) return 1;
	vt[v]=1;
	int p=o[v];
	while (p)
	{
		int y=aa[p][1];
		if (aa[p][2]&amp;&amp;!vt[y])
			if (find(y,goal)) return 1;
		p=aa[p][0];
	}
	return 0;
}
void doit()
{
	int ans1,i;
	ans1=dinic(S,T);
	ans[0]=0;
	//printf(&quot;%d\n&quot;,aa[12][2]);
	for (i=1;i&lt;=n;i++)
	{
		int t=c[i].pos;
		int p=e[t];
		if (aa[p][2]) continue;
		//printf(&quot;%d\n&quot;,c[i].pos);
		memset(vt,0,sizeof(vt[0])*(T+10));
		if (find(t*2-1,t*2)) continue;
		dinic(T,t*2);
		dinic(t*2-1,S);
		aa[p][2]=0,aa[p^1][2]=0;
		ans[++ans[0]]=c[i].pos;
	}
	sort(ans+1,ans+ans[0]+1);
	printf(&quot;%d %d\n&quot;,ans1,ans[0]);
	for (i=1;i&lt;ans[0];i++) printf(&quot;%d &quot;,ans[i]);
	printf(&quot;%d\n&quot;,ans[ans[0]]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	int tt;
	scanf(&quot;%d&quot;,&amp;tt);
	for (;tt;tt--)
	{
		init();
		prepare();
		doit();
		//printf(&quot;\n&quot;);
	}
	return 0;
}<pre><h2>Problem3532</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf=99999999;
int q[100000],o[100000],aa[1000000][3],a[1000],b[1000],e[1000],deep[100000],ans[1000],f[1000];
int S,T,head,tail,n,tot,start,end;
bool vt[100000];
struct arr
{
	int pos,val;
} c[1000];
bool cmp(arr x,arr y)
{
	return x.val&lt;y.val;
}
void init()
{
	int i;
	scanf(&quot;%d&quot;,&amp;n);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;b[i]);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;c[i].val),c[i].pos=i;
	sort(c+1,c+n+1,cmp);
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v)
{
	addedge(p,q,v);
	addedge(q,p,0);
}
void prepare()
{
	int lis,i,j;
	lis=0;
	for (i=1;i&lt;=n;i++)
	{
		f[i]=1;
		for (j=1;j&lt;i;j++)
			if (a[i]&gt;a[j]&amp;&amp;f[j]+1&gt;f[i]) f[i]=f[j]+1;
		if (f[i]&gt;lis) lis=f[i];
	}
	tot=1;
	S=n*2+1,T=S+1;
	memset(o,0,sizeof(o[0])*(T+10));
	for (i=1;i&lt;=n;i++)
	{
		e[i]=tot+1;
		add(i*2-1,i*2,b[i]);
		if (f[i]==1) add(S,i*2-1,inf);
		if (f[i]==lis) add(i*2,T,inf);
		for (j=1;j&lt;i;j++)
			if (a[j]&lt;a[i]&amp;&amp;f[j]+1==f[i]) add(j*2,i*2-1,inf);
	}
}
void bfs()
{
	int head=0,tail=0;
	memset(deep,0,sizeof(deep[0])*(T+10));
	deep[start]=1;
	q[++tail]=start;
	while (head&lt;tail)
	{
		int x=q[++head];
		int p=o[x];
		while (p)
		{
			int y=aa[p][1];
			if (!deep[y]&amp;&amp;aa[p][2])
			{
				deep[y]=deep[x]+1;
				q[++tail]=y;
			}
			p=aa[p][0];
		}
	}
}
int dfs(int v,int flow)
{
	if (v==end) return flow;
	int res=0,p=o[v];
	while (p)
	{
		int y=aa[p][1];
		if (aa[p][2]&amp;&amp;deep[y]==deep[v]+1)
		{
			int tmp=dfs(y,min(flow,aa[p][2]));
			if (!tmp) deep[y]=inf;
			flow-=tmp;
			aa[p][2]-=tmp;
			aa[p^1][2]+=tmp;
			res+=tmp;
			if (!flow) break;
		}
		p=aa[p][0];
	}
	return res;
}
int dinic(int SS,int TT)
{
	int res=0;
	start=SS,end=TT;
	bfs();
	while (deep[end])
	{
		res+=dfs(start,inf);
		bfs();
	}
	return res;
}
bool find(int v,int goal)
{
	if (v==goal) return 1;
	vt[v]=1;
	int p=o[v];
	while (p)
	{
		int y=aa[p][1];
		if (aa[p][2]&amp;&amp;!vt[y])
			if (find(y,goal)) return 1;
		p=aa[p][0];
	}
	return 0;
}
void doit()
{
	int ans1,i;
	ans1=dinic(S,T);
	ans[0]=0;
	for (i=1;i&lt;=n;i++)
	{
		int t=c[i].pos;
		int p=e[t];
		if (aa[p][2]) continue;
		memset(vt,0,sizeof(vt[0])*(T+10));
		if (find(t*2-1,t*2)) continue;
		dinic(T,t*2);
		dinic(t*2-1,S);
		aa[p][2]=0,aa[p^1][2]=0;
		ans[++ans[0]]=c[i].pos;
	}
	sort(ans+1,ans+ans[0]+1);
	printf(&quot;%d %d\n&quot;,ans1,ans[0]);
	for (i=1;i&lt;=ans[0];i++)
	{
		printf(&quot;%d&quot;,ans[i]);
		if (i&lt;ans[0]) printf(&quot; &quot;);
	}
	printf(&quot;\n&quot;);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	int tt;
	scanf(&quot;%d&quot;,&amp;tt);
	for (;tt;tt--)
	{
		init();
		prepare();
		doit();
	}
	return 0;
}<pre><h2>Problem3532</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf=99999999;
int q[100000],o[100000],aa[1000000][3],a[1000],b[1000],e[1000],deep[100000],ans[1000],f[1000];
int S,T,head,tail,n,tot,start,end;
bool vt[100000];
struct arr
{
	int pos,val;
} c[1000];
bool cmp(arr x,arr y)
{
	return x.val&lt;y.val;
}
void init()
{
	int i;
	scanf(&quot;%d&quot;,&amp;n);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;b[i]);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;c[i].val),c[i].pos=i;
	sort(c+1,c+n+1,cmp);
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v)
{
	addedge(p,q,v);
	addedge(q,p,0);
}
void prepare()
{
	int lis,i,j;
	lis=0;
	for (i=1;i&lt;=n;i++)
	{
		f[i]=1;
		for (j=1;j&lt;i;j++)
			if (a[i]&gt;a[j]&amp;&amp;f[j]+1&gt;f[i]) f[i]=f[j]+1;
		if (f[i]&gt;lis) lis=f[i];
	}
	tot=1;
	S=n*2+1,T=S+1;
	memset(o,0,sizeof(o[0])*(T+10));
	for (i=1;i&lt;=n;i++)
	{
		e[i]=tot+1;
		add(i*2-1,i*2,b[i]);
		if (f[i]==1) add(S,i*2-1,inf);
		if (f[i]==lis) add(i*2,T,inf);
		for (j=1;j&lt;i;j++)
			if (a[j]&lt;a[i]&amp;&amp;f[j]+1==f[i]) add(j*2,i*2-1,inf);
	}
}
void bfs()
{
	int head=0,tail=0;
	memset(deep,0,sizeof(deep[0])*(T+10));
	deep[start]=1;
	q[++tail]=start;
	while (head&lt;tail)
	{
		int x=q[++head];
		int p=o[x];
		while (p)
		{
			int y=aa[p][1];
			if (!deep[y]&amp;&amp;aa[p][2])
			{
				deep[y]=deep[x]+1;
				q[++tail]=y;
			}
			p=aa[p][0];
		}
	}
}
int dfs(int v,int flow)
{
	if (v==end) return flow;
	int res=0,p=o[v];
	while (p)
	{
		int y=aa[p][1];
		if (aa[p][2]&amp;&amp;deep[y]==deep[v]+1)
		{
			int tmp=dfs(y,min(flow,aa[p][2]));
			if (!tmp) deep[y]=inf;
			flow-=tmp;
			aa[p][2]-=tmp;
			aa[p^1][2]+=tmp;
			res+=tmp;
			if (!flow) break;
		}
		p=aa[p][0];
	}
	return res;
}
int dinic(int SS,int TT)
{
	int res=0;
	start=SS,end=TT;
	bfs();
	while (deep[end])
	{
		res+=dfs(start,inf);
		bfs();
	}
	return res;
}
bool find(int v,int goal)
{
	if (v==goal) return 1;
	vt[v]=1;
	int p=o[v];
	while (p)
	{
		int y=aa[p][1];
		if (aa[p][2]&amp;&amp;!vt[y])
			if (find(y,goal)) return 1;
		p=aa[p][0];
	}
	return 0;
}
void doit()
{
	int ans1,i;
	ans1=dinic(S,T);
	ans[0]=0;
	for (i=1;i&lt;=n;i++)
	{
		int t=c[i].pos;
		int p=e[t];
		//if (aa[p][2]) continue;
		memset(vt,0,sizeof(vt[0])*(T+10));
		if (find(t*2-1,t*2)) continue;
		dinic(T,t*2);
		dinic(t*2-1,S);
		aa[p][2]=0,aa[p^1][2]=0;
		ans[++ans[0]]=c[i].pos;
	}
	sort(ans+1,ans+ans[0]+1);
	printf(&quot;%d %d\n&quot;,ans1,ans[0]);
	for (i=1;i&lt;=ans[0];i++)
	{
		printf(&quot;%d&quot;,ans[i]);
		if (i&lt;ans[0]) printf(&quot; &quot;);
	}
	printf(&quot;\n&quot;);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	int tt;
	scanf(&quot;%d&quot;,&amp;tt);
	for (;tt;tt--)
	{
		init();
		prepare();
		doit();
	}
	return 0;
}<pre><h2>Problem3532</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf=99999999;
int q[100000],o[100000],aa[1000000][3],a[1000],b[1000],e[1000],deep[100000],ans[1000],f[1000],cur[100000];
int S,T,head,tail,n,tot,start,end;
bool vt[100000];
struct arr
{
    int pos,val;
} c[1000];
bool cmp(arr x,arr y)
{
    return x.val&lt;y.val;
}
void init()
{
    int i;
    scanf(&quot;%d&quot;,&amp;n);
    for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
    for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;b[i]);
    for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;c[i].val),c[i].pos=i;
    sort(c+1,c+n+1,cmp);
}
void addedge(int p,int q,int v)
{
    tot++;
    aa[tot][1]=q;
    aa[tot][2]=v;
    aa[tot][0]=o[p];
    o[p]=tot;
}
void add(int p,int q,int v)
{
    addedge(p,q,v);
    addedge(q,p,0);
}
void prepare()
{
    int lis,i,j;
    lis=0;
    for (i=1;i&lt;=n;i++)
    {
        f[i]=1;
        for (j=1;j&lt;i;j++)
            if (a[i]&gt;a[j]&amp;&amp;f[j]+1&gt;f[i]) f[i]=f[j]+1;
        if (f[i]&gt;lis) lis=f[i];
    }
    tot=1;
    S=n*2+1,T=S+1;
    memset(o,0,sizeof(o[0])*(T+10));
    for (i=1;i&lt;=n;i++)
    {
        e[i]=tot+1;
        add(i*2-1,i*2,b[i]);
        if (f[i]==1) add(S,i*2-1,inf);
        if (f[i]==lis) add(i*2,T,inf);
        for (j=1;j&lt;i;j++)
            if (a[j]&lt;a[i]&amp;&amp;f[j]+1==f[i]) add(j*2,i*2-1,inf);
    }
}
void bfs()
{
    int head=0,tail=0;
    memset(deep,0,sizeof(deep[0])*(T+10));
    deep[start]=1;
    q[++tail]=start;
    while (head&lt;tail)
    {
        int x=q[++head];
        int p=o[x];
        while (p)
        {
            int y=aa[p][1];
            if (!deep[y]&amp;&amp;aa[p][2])
            {
                deep[y]=deep[x]+1;
                q[++tail]=y;
            }
            p=aa[p][0];
        }
    }
    for (int i=1;i&lt;=T;i++) cur[i]=o[i];
}
int dfs(int v,int flow)
{
    if (v==end) return flow;
    int res=0,p=cur[v];
    while (p&amp;&amp;flow)
    {
        int y=aa[p][1];
        if (aa[p][2]&amp;&amp;deep[y]==deep[v]+1)
        {
            int tmp=dfs(y,min(flow,aa[p][2]));
            if (!tmp) deep[y]=inf;
            flow-=tmp;
            aa[p][2]-=tmp;
            aa[p^1][2]+=tmp;
            res+=tmp;
        }
        p=aa[p][0];
        cur[v]=p;
    }
    return res;
}
int dinic(int SS,int TT)
{
    int res=0;
    start=SS,end=TT;
    bfs();
    while (deep[end])
    {
        res+=dfs(start,inf);
        bfs();
    }
    return res;
}
bool find(int v,int goal)
{
    if (v==goal) return 1;
    vt[v]=1;
    int p=o[v];
    while (p)
    {
        int y=aa[p][1];
        if (aa[p][2]&amp;&amp;!vt[y])
            if (find(y,goal)) return 1;
        p=aa[p][0];
    }
    return 0;
}
void doit()
{
    int ans1,i;
    ans1=dinic(S,T);
    ans[0]=0;
    for (i=1;i&lt;=n;i++)
    {
        int t=c[i].pos;
        int p=e[t];
        if (aa[p][2]) continue;
        memset(vt,0,sizeof(vt[0])*(T+10));
        if (find(t*2-1,t*2)) continue;
        dinic(T,t*2);
        dinic(t*2-1,S);
        aa[p][2]=0,aa[p^1][2]=0;
        ans[++ans[0]]=c[i].pos;
    }
    sort(ans+1,ans+ans[0]+1);
    printf(&quot;%d %d\n&quot;,ans1,ans[0]);
    for (i=1;i&lt;=ans[0];i++)
    {
        printf(&quot;%d&quot;,ans[i]);
        if (i&lt;ans[0]) printf(&quot; &quot;);
    }
    printf(&quot;\n&quot;);
}
int main()
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
    int tt;
    scanf(&quot;%d&quot;,&amp;tt);
    for (;tt;tt--)
    {
        init();
        prepare();
        doit();
    }
    return 0;
}<pre><h2>Problem3532</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf=99999999;
int q[100000],o[100000],aa[1000000][3],a[1000],b[1000],e[1000],deep[100000],ans[1000],f[1000],cur[100000];
int S,T,head,tail,n,tot,start,end;
bool vt[100000];
struct arr
{
    int pos,val;
} c[1000];
bool cmp(arr x,arr y)
{
    return x.val&lt;y.val;
}
void init()
{
    int i;
    scanf(&quot;%d&quot;,&amp;n);
    for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
    for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;b[i]);
    for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;c[i].val),c[i].pos=i;
    sort(c+1,c+n+1,cmp);
}
void addedge(int p,int q,int v)
{
    tot++;
    aa[tot][1]=q;
    aa[tot][2]=v;
    aa[tot][0]=o[p];
    o[p]=tot;
}
void add(int p,int q,int v)
{
    addedge(p,q,v);
    addedge(q,p,0);
}
void prepare()
{
    int lis,i,j;
    lis=0;
    for (i=1;i&lt;=n;i++)
    {
        f[i]=1;
        for (j=1;j&lt;i;j++)
            if (a[i]&gt;a[j]&amp;&amp;f[j]+1&gt;f[i]) f[i]=f[j]+1;
        if (f[i]&gt;lis) lis=f[i];
    }
    tot=1;
    S=n*2+1,T=S+1;
    memset(o,0,sizeof(o[0])*(T+10));
    for (i=1;i&lt;=n;i++)
    {
        e[i]=tot+1;
        add(i*2-1,i*2,b[i]);
        if (f[i]==1) add(S,i*2-1,inf);
        if (f[i]==lis) add(i*2,T,inf);
        for (j=1;j&lt;i;j++)
            if (a[j]&lt;a[i]&amp;&amp;f[j]+1==f[i]) add(j*2,i*2-1,inf);
    }
}
void bfs()
{
    int head=0,tail=0;
    memset(deep,0,sizeof(deep[0])*(T+10));
    deep[start]=1;
    q[++tail]=start;
    while (head&lt;tail)
    {
        int x=q[++head];
        cur[x]=o[x];
        int p=o[x];
        while (p)
        {
            int y=aa[p][1];
            if (!deep[y]&amp;&amp;aa[p][2])
            {
                deep[y]=deep[x]+1;
                q[++tail]=y;
            }
            p=aa[p][0];
        }
    }
}
int dfs(int v,int flow)
{
    if (v==end) return flow;
    int res=0,p=cur[v];
    while (p&amp;&amp;flow)
    {
        int y=aa[p][1];
        if (aa[p][2]&amp;&amp;deep[y]==deep[v]+1)
        {
            int tmp=dfs(y,min(flow,aa[p][2]));
            if (!tmp) deep[y]=inf;
            flow-=tmp;
            aa[p][2]-=tmp;
            aa[p^1][2]+=tmp;
            res+=tmp;
        }
        p=aa[p][0];
        cur[v]=p;
    }
    return res;
}
int dinic(int SS,int TT)
{
    int res=0;
    start=SS,end=TT;
    bfs();
    while (deep[end])
    {
        res+=dfs(start,inf);
        bfs();
    }
    return res;
}
bool find(int v,int goal)
{
    if (v==goal) return 1;
    vt[v]=1;
    int p=o[v];
    while (p)
    {
        int y=aa[p][1];
        if (aa[p][2]&amp;&amp;!vt[y])
            if (find(y,goal)) return 1;
        p=aa[p][0];
    }
    return 0;
}
void doit()
{
    int ans1,i;
    ans1=dinic(S,T);
    ans[0]=0;
    for (i=1;i&lt;=n;i++)
    {
        int t=c[i].pos;
        int p=e[t];
        if (aa[p][2]) continue;
        memset(vt,0,sizeof(vt[0])*(T+10));
        if (find(t*2-1,t*2)) continue;
        dinic(T,t*2);
        dinic(t*2-1,S);
        aa[p][2]=0,aa[p^1][2]=0;
        ans[++ans[0]]=c[i].pos;
    }
    sort(ans+1,ans+ans[0]+1);
    printf(&quot;%d %d\n&quot;,ans1,ans[0]);
    for (i=1;i&lt;=ans[0];i++)
    {
        printf(&quot;%d&quot;,ans[i]);
        if (i&lt;ans[0]) printf(&quot; &quot;);
    }
    printf(&quot;\n&quot;);
}
int main()
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
    int tt;
    scanf(&quot;%d&quot;,&amp;tt);
    for (;tt;tt--)
    {
        init();
        prepare();
        doit();
    }
    return 0;
}<pre><h2>Problem3533</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
#define INF 9999999999999999ll
#define lc(v) ((v)&lt;&lt;1)
#define rc(v) ((v)&lt;&lt;1|1)
const int NN=401111;
int n,cnt;
LL lastans;
struct point
{
	LL x,y;
	void out() {printf(&quot;%I64d %I64d\n&quot;,x,y);}
	point(LL a=0,LL b=0) {x=a,y=b;}
	friend bool operator &lt;(point a,point b) {return a.x&lt;b.x||(a.x==b.x&amp;&amp;a.y&lt;b.y);}
	friend LL operator %(point a,point b) {return a.x*b.y-b.x*a.y;}
	friend LL operator *(point a,point b) {return a.x*b.x+a.y*b.y;}
	friend point operator -(point a,point b) {a.x-=b.x;a.y-=b.y;return a;}
} p[NN],q[NN],P;
struct segnode
{
	point *a,*b;
	int n1,n2;
	bool flag;
	void build(int l,int r)
	{
		//printf(&quot;build %d~%d\n&quot;,l,r);
		int n=r-l,i;
		for (i=l;i&lt;r;i++) p[i-l+1]=q[i];
		sort(p+1,p+n+1);
		//printf(&quot;p:\n&quot;);for (i=1;i&lt;=n;i++) p[i].out();ln;
		n1=n2=0;
		a=new point[n+3],b=new point[n+3];
		for (i=1;i&lt;=n;i++)
		{
			while (n1&gt;1&amp;&amp;(a[n1]-a[n1-1])%(p[i]-a[n1-1])&gt;=0) n1--;
			a[++n1]=p[i];
		}
		//ln;printf(&quot;a:\n&quot;);for (i=1;i&lt;=n1;i++) a[i].out();ln;
		for (i=1;i&lt;=n;i++)
		{
			while (n2&gt;1&amp;&amp;(b[n2]-b[n2-1])%(p[i]-b[n2-1])&lt;=0) n2--;
			b[++n2]=p[i];
		}
		flag=true;
		//printf(&quot;b:\n&quot;);for (i=1;i&lt;=n1;i++) b[i].out();ln;
	}
	LL find(int ll,int rr,point P)
	{
		//printf(&quot;\n===========find %d %d=============\n&quot;,ll,rr);
		if (!flag) build(ll,rr);
		int l,r,m1,m2,t,i;
		LL res=-INF;
		if (P.y&gt;=0)
		{
			l=1,r=n1;
			while (r-l&gt;5)
			{
				t=(r-l)/3;
				m1=l+t,m2=r-t;
				if (a[m1]*P&lt;a[m2]*P) l=m1+1;
				else r=m2-1;
			}
			//P.out();a[l].out();
			for (i=l;i&lt;=r;i++) res=max(res,a[i]*P);
		}
		else
		{
			l=1,r=n2;
			while (r-l&gt;5)
			{
				t=(r-l)/3;
				m1=l+t,m2=r-t;
				if (b[m1]*P&lt;b[m2]*P) l=m1+1;
				else r=m2-1;
			}
			for (i=l;i&lt;=r;i++) res=max(res,b[i]*P);
		}
		//printf(&quot;res=%I64d\n&quot;,res);
		return res;
	}
} t[NN*4];
LL find(int v,int l,int r,int ww,int ee)
{
	//if (v&gt;0) printf(&quot;find %d %d %d %d %d\n&quot;,v,l,r,ww,ee);
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return t[v].find(l,r,P);
	int mid=(l+r)&gt;&gt;1;
	LL res=-INF;
	if (ww&lt;mid) res=max(res,find(lc(v),l,mid,ww,ee));
	if (ee&gt;mid) res=max(res,find(rc(v),mid,r,ww,ee));
	return res;
}
inline LL decode(LL x) {return x^(lastans&amp;0x7fffffff);}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d &quot;,&amp;n);
	bool kind=(getchar()!='E');
	//printf(&quot;kind is %s\n&quot;,kind?&quot;true&quot;:&quot;false&quot;); 
	lastans=0;cnt=0;
	int i,x,y,l,r;
	for (i=1;i&lt;=n;i++)
	{
		char ch=getchar();
		while (ch!='A'&amp;&amp;ch!='Q') ch=getchar();
		//printf(&quot;\n------------------------------------------------------------------------\nch=%c\n&quot;,ch);
		if (ch=='A')
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			if (kind) x=decode(x),y=decode(y);
			q[++cnt]=point(x,y);
		}
		else
		{
			scanf(&quot;%d%d%d%d&quot;,&amp;x,&amp;y,&amp;l,&amp;r);
			if (kind) x=decode(x),y=decode(y),l=decode(l),r=decode(r);
			P=point(x,y);
			lastans=find(1,1,n+1,l,r+1);
			printf(&quot;%lld\n&quot;,lastans);
		}
	}
	return 0;
}<pre><h2>Problem3533</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define INF 9999999999999999ll
#define lc(v) ((v)&lt;&lt;1)
#define rc(v) ((v)&lt;&lt;1|1)
const int NN=401111;
int n,cnt;
LL lastans;
struct point
{
	LL x,y;
	point(LL a=0,LL b=0) {x=a,y=b;}
	friend bool operator &lt;(point a,point b) {return a.x&lt;b.x||(a.x==b.x&amp;&amp;a.y&lt;b.y);}
	friend LL operator %(point a,point b) {return a.x*b.y-b.x*a.y;}
	friend LL operator *(point a,point b) {return a.x*b.x+a.y*b.y;}
	friend point operator -(point a,point b) {a.x-=b.x;a.y-=b.y;return a;}
} p[NN],q[NN],P;
struct segnode
{
	point *a,*b;
	int n1,n2;
	bool flag;
	void build(int l,int r)
	{
		int n=r-l,i;
		for (i=l;i&lt;r;i++) p[i-l+1]=q[i];
		sort(p+1,p+n+1);
		n1=n2=0;
		a=new point[n+3],b=new point[n+3];
		for (i=1;i&lt;=n;i++)
		{
			while (n1&gt;1&amp;&amp;(a[n1]-a[n1-1])%(p[i]-a[n1-1])&gt;=0) n1--;
			a[++n1]=p[i];
		}
		for (i=1;i&lt;=n;i++)
		{
			while (n2&gt;1&amp;&amp;(b[n2]-b[n2-1])%(p[i]-b[n2-1])&lt;=0) n2--;
			b[++n2]=p[i];
		}
		flag=true;
	}
	LL find(int ll,int rr,point P)
	{
		if (!flag) build(ll,rr);
		int l,r,m1,m2,t,i;
		LL res=-INF;
		if (P.y&gt;=0)
		{
			l=1,r=n1;
			while (r-l&gt;5)
			{
				t=(r-l)/3;
				m1=l+t,m2=r-t;
				if (a[m1]*P&lt;a[m2]*P) l=m1+1;
				else r=m2-1;
			}
			for (i=l;i&lt;=r;i++) res=max(res,a[i]*P);
		}
		else
		{
			l=1,r=n2;
			while (r-l&gt;5)
			{
				t=(r-l)/3;
				m1=l+t,m2=r-t;
				if (b[m1]*P&lt;b[m2]*P) l=m1+1;
				else r=m2-1;
			}
			for (i=l;i&lt;=r;i++) res=max(res,b[i]*P);
		}
		return res;
	}
} t[NN*4];
LL find(int v,int l,int r,int ww,int ee)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return t[v].find(l,r,P);
	int mid=(l+r)&gt;&gt;1;
	LL res=-INF;
	if (ww&lt;mid) res=max(res,find(lc(v),l,mid,ww,ee));
	if (ee&gt;mid) res=max(res,find(rc(v),mid,r,ww,ee));
	return res;
}
inline LL decode(LL x) {return x^(lastans&amp;0x7fffffff);}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d &quot;,&amp;n);
	bool kind=(getchar()!='E');
	lastans=0;cnt=0;
	int i,x,y,l,r;
	for (i=1;i&lt;=n;i++)
	{
		char ch=getchar();
		while (ch!='A'&amp;&amp;ch!='Q') ch=getchar();
		if (ch=='A')
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			if (kind) x=decode(x),y=decode(y);
			q[++cnt]=point(x,y);
		}
		else
		{
			scanf(&quot;%d%d%d%d&quot;,&amp;x,&amp;y,&amp;l,&amp;r);
			if (kind) x=decode(x),y=decode(y),l=decode(l),r=decode(r);
			P=point(x,y);
			lastans=find(1,1,n+1,l,r+1);
			printf(&quot;%lld\n&quot;,lastans);
		}
	}
	return 0;
}<pre><h2>Problem3534</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
typedef double DD;
const int NN=55;
const DD eps=1e-10;
DD ans,a[NN][NN];
int n;
void gause(int n)
{
	int i,j,k;
	for (i=1;i&lt;=n;i++)
	{
		DD tmp=a[i][i];k=i;
		for (j=i+1;j&lt;=n;j++)
			if (fabs(a[j][i])&gt;tmp) tmp=fabs(a[j][i]),k=j;
		for (j=i;j&lt;=n;j++) swap(a[i][j],a[k][j]);
		ans=-ans;
		if (fabs(a[i][i])&lt;eps) {ans=0;return;}
		ans*=a[i][i];
		for (j=i+1;j&lt;=n;j++)
		{
			tmp=a[j][i]/a[i][i];
			for (k=i;k&lt;=n;k++) a[j][k]-=tmp*a[i][k];
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	DD tmp=1;
	int i,j;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++)
		{
			scanf(&quot;%lf&quot;,&amp;a[i][j]);
			if (i==j) continue;
			if (fabs(a[i][j]-1)&lt;eps) a[i][j]-=eps;
			if (i&lt;j) tmp*=(1-a[i][j]);
			a[i][j]/=(1-a[i][j]);
		}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++)
			if (i!=j) a[i][i]-=a[i][j];
	//for(i=1;i&lt;=n;i++){for(j=1;j&lt;=n;j++)printf(&quot;%.2f &quot;,a[i][j]);ln;}ln;
	ans=1;
	gause(n-1);
	printf(&quot;%.10f\n&quot;,fabs(ans*tmp));
	return 0;
}<pre><h2>Problem3535</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef pair&lt;int,int&gt; pii;
#define p1 19980723
#define p2 10000007
#define mp make_pair
#define fi first
#define se second
const int NN=100111;
int sum[9],b[NN];
int n,K,num;
struct info
{
	int x,kind;
	friend bool operator &lt;(const info &amp;a,const info &amp;b)
	{
		if (a.x!=b.x) return a.x&lt;b.x;
		return a.kind&lt;b.kind;
	}
} q[NN];
int cha(int x,int l,int r)
{
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (b[mid]==x) return mid;
		if (x&lt;b[mid]) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
inline int calcbit(int x)
{
	int res=0;
	for (;x;x-=x&amp;-x) res++;
	return res;
}
pii gethash(int S)
{
	int cnt=0;static int b[10];
	for (int i=1;i&lt;=num;i++)
		if (S&amp;(1&lt;&lt;(i-1))) b[++cnt]=sum[i];
	int t1=0,t2=0;
	for (int i=2;i&lt;=cnt;i++)
	{
		int x=b[i]-b[i-1];
		t1=t1*p1+x;
		t2=t2*p2+x;
	}
	return mp(t1,t2);
}
struct HT
{
	#define mod 1000007
	int TIME,tot,aa0[NN],aa2[NN],vt[mod],o[mod];
	pii aa1[NN];
	inline void clear() {TIME++,tot=0;}
	void insert(pii tmp,int i)
	{
		int t=tmp.fi%mod;
		if (t&lt;0) t+=mod;
		if (vt[t]!=TIME)
			vt[t]=TIME,o[t]=0;
		tot++;aa1[tot]=tmp;aa2[tot]=i;
		aa0[tot]=o[t];o[t]=tot;
	}
	int find(pii tmp)
	{
		int t=tmp.fi%mod;
		if (t&lt;0) t+=mod;
		if (vt[t]!=TIME)
			vt[t]=TIME,o[t]=0;
		for (int p=o[t];p;p=aa0[p])
			if (aa1[p]==tmp) return aa2[p];
		return -1;
	}
} ht;
int work(int S)
{
	int res=-1,i,j;
	ht.clear();
	for (j=1;j&lt;=num;j++) sum[j]=0;
	ht.insert(gethash(S),0);
	for (int l=1,r;l&lt;=n;l=r+1)
	{
		for (r=l;r&lt;=n&amp;&amp;q[r].x==q[l].x;r++);
		r--;
		bool ok=true;
		for (i=l;i&lt;=r;i++)
			if (S&amp;(1&lt;&lt;(q[i].kind-1))) sum[q[i].kind]++;
			else ok=false;
		if (!ok)
		{
			ht.clear();
			ht.insert(mp(0,0),r);
			for (j=1;j&lt;=num;j++) sum[j]=0;
			continue;
		}
		pii hash=gethash(S);
		int t=ht.find(hash);
		if (t!=-1) res=max(res,q[r].x-q[t+1].x);
		else ht.insert(hash,r);
	}
	return res;
}
int main()
{
	//freopen(&quot;long.in&quot;,&quot;r&quot;,stdin);freopen(&quot;long.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	for (int i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;q[i].x,&amp;q[i].kind);
		b[i]=q[i].kind;
	}
	sort(q+1,q+n+1);
	sort(b+1,b+n+1);
	int t=1;
	for (int i=2;i&lt;=n;i++)
		if (b[i]!=b[t]) b[++t]=b[i];
	num=t;
	for (int i=1;i&lt;=n;i++) q[i].kind=cha(q[i].kind,1,t);
	int ans=-1;
	for (int S=0;S&lt;1&lt;&lt;num;S++)
	{
		if (calcbit(S)&lt;K) continue;
		ans=max(ans,work(S));
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3544</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
using namespace std;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
int n;
LL sum[201111],M;
multiset&lt;LL&gt; S;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%lld&quot;,&amp;n,&amp;M);
	int i;LL x;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%lld&quot;,&amp;x);
		sum[i]=(sum[i-1]+x)%M;
		if (sum[i]&lt;0) sum[i]+=M;
	}
	LL ans=0;
	S.insert(0);
	for (i=1;i&lt;=n;i++)
	{
		multiset&lt;LL&gt;::iterator it=S.upper_bound(sum[i]);
		if (it==S.end()) it=S.begin();
		ans=max(ans,(sum[i]-*it+M)%M);
		S.insert(sum[i]);
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem3545</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=100111,MM=500111;
int fa[NN],son[NN][2],size[NN],key[NN],b[NN],ans[MM];
int n,m,Q,TTT,cnt;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9')
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar();
}
struct Bcj
{
	int fa[NN],size[NN];
	void init()
	{
		for (int i=1;i&lt;=n;i++)
			fa[i]=i,size[i]=1;
	}
	inline int getfa(int x)
	{
		if (fa[x]==x) return x;
		return fa[x]=getfa(fa[x]);
	}
	inline void merge(int x,int y)
	{
		x=getfa(x),y=getfa(y);
		if (size[x]&gt;size[y])
			fa[y]=x,size[x]+=size[y];
		else
			fa[x]=y,size[y]+=size[x];
	}
} bcj;
inline void update(int t)
{
	size[t]=size[son[t][0]]+size[son[t][1]]+1;
}
inline void rotate(int t,int p)
{
	int y=fa[t];
	if (fa[y])
	{
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	}
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
}
void bianli(int t)
{
	if (!t) return;
	bianli(son[t][0]),bianli(son[t][1]);
	b[++cnt]=t;
}
void ins(int &amp;v,int t,int ff)
{
	if (!v)
	{
		v=t;
		size[v]=1;
		fa[v]=ff;
		son[v][0]=son[v][1]=0;
		splay(v,0);
	}
	else if (key[t]&lt;key[v]) ins(son[v][0],t,v);
	else ins(son[v][1],t,v);
}
int find(int t,int K)
{
	if (size[t]&lt;K) return -1;
	while (t)
	{
		int tmp=size[son[t][1]];
		if (K&lt;=tmp) t=son[t][1];
		else if (K&lt;=tmp+1) return key[t];
		else K-=tmp+1,t=son[t][0];
	}
	return -1;
}
void debug(int t)
{
	if (!t) return;
	debug(son[t][0]);
	printf(&quot;%d &quot;,key[t]);
	debug(son[t][1]);
}
struct edge
{
	int u,v,w;
	inline void in() {read(u),read(v),read(w);}
	friend bool operator &lt;(const edge &amp;a,const edge &amp;b) {return a.w&lt;b.w;}
	void merge()
	{
		if (bcj.getfa(u)==bcj.getfa(v)) return;
		bcj.merge(u,v);
		//printf(&quot;\n------------------------- merge %d %d ---------------------------\n&quot;,u,v);
		splay(u,0),splay(v,0);
		//debug(u);ln;debug(v);ln;
		if (size[u]&gt;size[v]) {int t=u;u=v;v=t;}
		cnt=0;bianli(u);
		b[0]=v;
		for (int i=1;i&lt;=cnt;i++) ins(b[i-1],b[i],0);
	}
} e[MM];
struct query
{
	int v,x,K,id;
	inline void in(int i) {id=i;read(v),read(x),read(K);}
	friend bool operator &lt;(const query &amp;a,const query &amp;b) {return a.x&lt;b.x;}
} q[MM];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m),read(Q);
	int i;
	for (i=1;i&lt;=n;i++)
		read(key[i]),size[i]=1;
	bcj.init();
	for (i=1;i&lt;=m;i++) e[i].in();
	sort(e+1,e+m+1);
	for (i=1;i&lt;=Q;i++) q[i].in(i);
	sort(q+1,q+Q+1);
	int now=1;
	for (i=1;i&lt;=Q;i++)
	{
		int x=q[i].x;
		for (;now&lt;=m&amp;&amp;e[now].w&lt;=x;now++) e[now].merge();
		int v=q[i].v;
		splay(v,0);
		//debug(v);ln;
		ans[q[i].id]=find(v,q[i].K);
	}
	for (i=1;i&lt;=Q;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem3545</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int NN=100111,MM=500111;
int fa[NN],son[NN][2],size[NN],key[NN],b[NN],ans[MM];
int n,m,Q,TTT,cnt;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9')
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar();
}
struct Bcj
{
	int fa[NN],size[NN];
	void init()
	{
		for (int i=1;i&lt;=n;i++)
			fa[i]=i,size[i]=1;
	}
	inline int getfa(int x)
	{
		if (fa[x]==x) return x;
		return fa[x]=getfa(fa[x]);
	}
	inline void merge(int x,int y)
	{
		x=getfa(x),y=getfa(y);
		if (size[x]&gt;size[y])
			fa[y]=x,size[x]+=size[y];
		else
			fa[x]=y,size[y]+=size[x];
	}
} bcj;
inline void update(int t)
{
	size[t]=size[son[t][0]]+size[son[t][1]]+1;
}
inline void rotate(int t,int p)
{
	int y=fa[t];
	if (fa[y])
	{
		if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
	}
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t,int ff)
{
	while (fa[t]!=ff)
	{
		int y=fa[t];
		if (fa[y]==ff)
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
}
void bianli(int t)
{
	if (!t) return;
	bianli(son[t][0]),bianli(son[t][1]);
	b[++cnt]=t;
}
void ins(int &amp;v,int t,int ff)
{
	if (!v)
	{
		v=t;
		size[v]=1;
		fa[v]=ff;
		son[v][0]=son[v][1]=0;
		splay(v,0);
	}
	else if (key[t]&lt;key[v]) ins(son[v][0],t,v);
	else ins(son[v][1],t,v);
}
int find(int t,int K)
{
	if (size[t]&lt;K) return -1;
	while (t)
	{
		int tmp=size[son[t][1]];
		if (K&lt;=tmp) t=son[t][1];
		else if (K&lt;=tmp+1) return key[t];
		else K-=tmp+1,t=son[t][0];
	}
	return -1;
}
struct edge
{
	int u,v,w;
	inline void in() {read(u),read(v),read(w);}
	friend bool operator &lt;(const edge &amp;a,const edge &amp;b) {return a.w&lt;b.w;}
	void merge()
	{
		if (bcj.getfa(u)==bcj.getfa(v)) return;
		bcj.merge(u,v);
		splay(u,0),splay(v,0);
		if (size[u]&gt;size[v]) {int t=u;u=v;v=t;}
		cnt=0;bianli(u);
		b[0]=v;
		for (int i=1;i&lt;=cnt;i++) ins(b[i-1],b[i],0);
	}
} e[MM];
struct query
{
	int v,x,K,id;
	inline void in(int i) {id=i;read(v),read(x),read(K);}
	friend bool operator &lt;(const query &amp;a,const query &amp;b) {return a.x&lt;b.x;}
} q[MM];
int main()
{
	read(n),read(m),read(Q);
	int i;
	for (i=1;i&lt;=n;i++)
		read(key[i]),size[i]=1;
	bcj.init();
	for (i=1;i&lt;=m;i++) e[i].in();
	sort(e+1,e+m+1);
	for (i=1;i&lt;=Q;i++) q[i].in(i);
	sort(q+1,q+Q+1);
	int now=1;
	for (i=1;i&lt;=Q;i++)
	{
		int x=q[i].x;
		for (;now&lt;=m&amp;&amp;e[now].w&lt;=x;now++) e[now].merge();
		int v=q[i].v;
		splay(v,0);
		ans[q[i].id]=find(v,q[i].K);
	}
	for (i=1;i&lt;=Q;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem3551</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 1000000005
const int NN=200111,AA=3100000,MM=500111;
int fa[NN],o[NN],aa[NN][2],root[NN],w[NN],val[NN],f[19][NN];
int st[NN],ed[NN],b[NN],lc[AA],rc[AA],size[AA];
int n,m,Q,TTT,segnum,tot=1,cnt;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9')
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar();
}
struct edge
{
	int u,v,w;
	inline void in() {read(u),read(v),read(w);}
	friend bool operator &lt;(const edge &amp;a,const edge &amp;b) {return a.w&lt;b.w;}
} e[MM];
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int getfa(int x) {return fa[x]==x?x:fa[x]=getfa(fa[x]);}
void dfs(int v)
{
	st[v]=++cnt;
	b[cnt]=v;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dfs(y);
	}
	ed[v]=cnt;
}
void maketree()
{
	sort(e+1,e+m+1);
	int i,j;
	for (i=1;i&lt;=n;i++) fa[i]=i;
	TTT=n;
	for (i=1;i&lt;=m;i++)
	{
		int u=getfa(e[i].u),v=getfa(e[i].v);
		if (u==v) continue;
		int t=++TTT;
		val[t]=e[i].w;
		addedge(t,u),addedge(t,v);
		fa[t]=t;
		fa[u]=fa[v]=t;
	}
	for (i=1;i&lt;=TTT;i++)
		if (fa[i]==i) fa[i]=0,dfs(i);
	for (i=1;i&lt;=TTT;i++) f[0][i]=fa[i];
	for (j=1;j&lt;=18;j++)
		for (i=1;i&lt;=TTT;i++) f[j][i]=f[j-1][f[j-1][i]];
}
void ins(int &amp;v,int u,int l,int r,int x)
{
	if (!v) v=++segnum;
	size[v]=size[u]+1;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid) rc[v]=rc[u],ins(lc[v],lc[u],l,mid,x);
	else lc[v]=lc[u],ins(rc[v],rc[u],mid,r,x);
}
int find(int v,int u,int l,int r,int K)
{
	if (size[v]-size[u]&lt;K) return 0;
	if (r-l==1) return l;
	int mid=(l+r)&gt;&gt;1,tmp=size[rc[v]]-size[rc[u]];
	if (K&lt;=tmp) return find(rc[v],rc[u],mid,r,K);
	else return find(lc[v],lc[u],l,mid,K-tmp);
}
int main()
{
	read(n),read(m),read(Q);
	int i;
	for (i=1;i&lt;=n;i++) read(w[i]);
	for (i=1;i&lt;=m;i++) e[i].in();
	maketree();
	for (i=1;i&lt;=TTT;i++)
		if (b[i]&lt;=n) ins(root[i],root[i-1],0,inf,w[b[i]]);
		else root[i]=root[i-1];
	val[0]=inf;
	for (int lastans=0;Q;Q--)
	{
		int v,x,K;
		read(v),read(x),read(K);
		v^=lastans,x^=lastans,K^=lastans;
		for (i=18;i&gt;=0;i--)
			if (val[f[i][v]]&lt;=x) v=f[i][v];
		lastans=find(root[ed[v]],root[st[v]-1],0,inf,K);
		if (lastans) printf(&quot;%d\n&quot;,lastans);
		else printf(&quot;-1\n&quot;);
	}
	return 0;
}<pre><h2>Problem3555</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define M 30300
#define BASE 149
using namespace std;
typedef unsigned long long ll;
int n,k,ans;
ll sum[M][210],power[210];
char s[210];
ll a[M];
void Calculate(int pos)
{
    int i;
    for(i=1;i&lt;=n;i++)
        a[i]=sum[i][k]-sum[i][pos]*power[k-pos]+sum[i][pos-1]*power[k-pos+1];
    sort(a+1,a+n+1);
    int cnt;
    for(i=1;i&lt;=n;i++)
    {
        if(i==1||a[i]!=a[i-1])
            cnt=-1;
        cnt++;
        ans+=cnt;
    }
}
int main()
{
    int i,j;
    cin&gt;&gt;n&gt;&gt;k;
    scanf(&quot;%*d&quot;);
    power[0]=1;
    for(i=1;i&lt;210;i++)
        power[i]=power[i-1]*BASE;
    for(i=1;i&lt;=n;i++)
    {
        scanf(&quot;%s&quot;,s+1);
        for(j=1;j&lt;=k;j++)
            sum[i][j]=sum[i][j-1]*BASE+s[j];
    }
    for(i=1;i&lt;=k;i++)
        Calculate(i);
    cout&lt;&lt;ans&lt;&lt;endl;
}
<pre><h2>Problem3555</h2><pre>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
 
using namespace std;
 
const int MaxL = 200 + 5, MaxN = 30000 + 5;
const int C1 = 233, P1 = 3000007, C2 = 277;
const long long P2 = (1 &lt;&lt; 31);
 
int l, n, p, Used_Index, Ans, Num1, Num2;
int Pow[2][MaxL], Hash[MaxN][2];
 
char S[MaxN][MaxL];
 
struct HashNode
{
    int Hash2, Used, Num;
    HashNode *Next;
} HA[MaxN * MaxL], *P = HA, *Hash1[P1 + 5];  
 
void PreHash(int x) {
    int Num1 = 0, Num2 = 0;
    for (int i = 0; i &lt; l; i++) {
        Num1 += Pow[0][i] * S[x][i];
        Num1 %= P1;
        Num2 += Pow[1][i] * S[x][i];    
    }
    Hash[x][0] = Num1;
    Hash[x][1] = Num2;
}
 
void Insert(int x, int y) {
    for (HashNode *j = Hash1[x]; j; j = j -&gt; Next) {
        if (j -&gt; Hash2 != y) continue;
        if (j -&gt; Used == Used_Index) {
            Ans += j -&gt; Num;
            ++(j -&gt; Num);
            return;
        }
        else {
            j -&gt; Used = Used_Index;
            j -&gt; Num = 1;
            return;
        }
    }
    ++P;
	P -&gt; Hash2 = y;
	P -&gt; Used = Used_Index;
	P -&gt; Num = 1;
    P -&gt; Next = Hash1[x]; 
	Hash1[x] = P;
}

int main() 
{
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;l, &amp;p);
    Pow[0][0] = Pow[1][0] = 1;
    for (int i = 1; i &lt; l; i++) {
        Pow[0][i] = (Pow[0][i - 1] * C1) % P1;
        Pow[1][i] = Pow[1][i - 1] * C2;
    }
    for (int i = 1; i &lt;= n; i++) {
        scanf(&quot;%s&quot;, S[i]);
        PreHash(i);
    }
    Used_Index = 0; 
    Ans = 0;
    for (int j = 0; j &lt; l; j++) {
        ++Used_Index;
        for (int i = 1; i &lt;= n; i++) {
            Num1 = (Hash[i][0] - Pow[0][j] * S[i][j]) % P1;
            if (Num1 &lt; 0) Num1 += P1;
            Num2 = Hash[i][1] - Pow[1][j] * S[i][j];
            if (Num2 &lt; 0) Num2 += P2;
            Insert(Num1, Num2);
        }
    }
    printf(&quot;%d\n&quot;, Ans);
    return 0;
}<pre><h2>Problem3555</h2><pre>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
 
using namespace std;
 
const int MaxL = 200 + 5, MaxN = 30000 + 5;
const int C1 = 233, P1 = 3000007, C2 = 277;
const long long P2 = (1 &lt;&lt; 31);
 
int l, n, p, Used_Index, Ans, Num1, Num2;
int Pow[2][MaxL], Hash[MaxN][2];
 
char S[MaxN][MaxL];
 
struct HashNode
{
    int Hash2, Used, Num;
    HashNode *Next;
} HA[MaxN * MaxL], *P = HA, *Hash1[P1 + 5];  
 
void PreHash(int x) {
    int Num1 = 0, Num2 = 0;
    for (int i = 0; i &lt; l; i++) {
        Num1 += Pow[0][i] * S[x][i];
        Num1 %= P1;
        Num2 += Pow[1][i] * S[x][i];    
    }
    Hash[x][0] = Num1;
    Hash[x][1] = Num2;
}
 
void Insert(int x, int y) {
    for (HashNode *j = Hash1[x]; j; j = j -&gt; Next) {
        if (j -&gt; Hash2 != y) continue;
        if (j -&gt; Used == Used_Index) {
            Ans += j -&gt; Num;
            ++(j -&gt; Num);
            return;
        }
        else {
            j -&gt; Used = Used_Index;
            j -&gt; Num = 1;
            return;
        }
    }
    ++P;
	P -&gt; Hash2 = y;
	P -&gt; Used = Used_Index;
	P -&gt; Num = 1;
    P -&gt; Next = Hash1[x]; 
	Hash1[x] = P;
}

int main() 
{
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;l, &amp;p);
    Pow[0][0] = Pow[1][0] = 1;
    for (int i = 1; i &lt; l; i++) {
        Pow[0][i] = (Pow[0][i - 1] * C1) % P1;
        Pow[1][i] = Pow[1][i - 1] * C2;
    }
    for (int i = 1; i &lt;= n; i++) {
        scanf(&quot;%s&quot;, S[i]);
        PreHash(i);
    }
    Used_Index = 0; 
    Ans = 0;
    for (int j = 0; j &lt; l; j++) {
        ++Used_Index;
        for (int i = 1; i &lt;= n; i++) {
            Num1 = (Hash[i][0] - Pow[0][j] * S[i][j]) % P1;
            if (Num1 &lt; 0) Num1 += P1;
            Num2 = Hash[i][1] - Pow[1][j] * S[i][j];
            //if (Num2 &lt; 0) Num2 += P2;
            Insert(Num1, Num2);
        }
    }
    printf(&quot;%d\n&quot;, Ans);
    return 0;
}<pre><h2>Problem3555</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define MM 211
#define NN 31111
const int p1=31,mo=3999999,p2=19980723;
int hash1[NN],hash2[NN],mi1[NN],mi2[NN],o[mo],aa[6001111][2],num[6001111],vt[6001111];
int n,m,TIME,tot,ans;
char s[NN][MM];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	//freopen(&quot;3555.in&quot;,&quot;r&quot;,stdin);freopen(&quot;3555.out&quot;,&quot;w&quot;,stdout);
	int i,j;
	mi1[0]=mi2[0]=1;
	for (i=1;i&lt;=200;i++)
	{
		mi1[i]=mi1[i-1]*p1%mo;
		mi2[i]=mi2[i-1]*p2;
	}
	scanf(&quot;%d%d%d\n&quot;,&amp;n,&amp;m,&amp;i);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s\n&quot;,s[i]+1);
		//printf(&quot;%s\n&quot;,s[i]+1);
		for (hash1[i]=hash2[i]=0,j=1;j&lt;=m;j++)
		{
			hash1[i]=(hash1[i]+(s[i][j]-'a'+1)*mi1[j])%mo;
			hash2[i]=hash2[i]+s[i][j]*mi2[j];
		}
		//printf(&quot;%d %d\n&quot;,hash1[i],hash2[i]);
	}
	for (j=1;j&lt;=m;j++)
	{
		//printf(&quot;\n----------------------------------------------------\n&quot;);
		++TIME;
		for (i=1;i&lt;=n;i++)
		{
			//printf(&quot;\n=======\n&quot;);
			int t1=(hash1[i]-s[i][j]*mi1[j])%mo;
			if (t1&lt;0) t1+=mo;
			int t2=hash2[i]-s[i][j]*mi2[j];
			//printf(&quot;%d %d\n&quot;,t1,t2);
			bool flag=false;
			for (int p=o[t1];p;p=aa[p][0])
			{
				int y=aa[p][1];
				if (y!=t2) continue;
				flag=true;
				if (vt[p]==TIME) ans+=num[p],num[p]++;
				else vt[p]=TIME,num[p]=1;
				continue;
				//printf(&quot;%d\n&quot;,p);
			}
			if (!flag)
			{
				tot++;
				aa[tot][1]=t2;
				aa[tot][0]=o[t1];
				o[t1]=tot;
				num[tot]=1;
				vt[tot]=TIME;
			}
		}
		//printf(&quot;%d\n&quot;,ans);
	}
	//printf(&quot;\n\n&quot;);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem3555</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define MM 211
#define NN 31111
const int p1=31,mo=3999999,p2=19980723;
int hash1[NN],hash2[NN],mi1[NN],mi2[NN],o[mo],aa[6001111][2],num[6001111],vt[6001111];
int n,m,TIME,tot,ans;
char s[NN][MM];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,j;
	mi1[0]=mi2[0]=1;
	for (i=1;i&lt;=200;i++)
	{
		mi1[i]=mi1[i-1]*p1%mo;
		mi2[i]=mi2[i-1]*p2;
	}
	scanf(&quot;%d%d%d\n&quot;,&amp;n,&amp;m,&amp;i);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s\n&quot;,s[i]+1);
		for (hash1[i]=hash2[i]=0,j=1;j&lt;=m;j++)
		{
			hash1[i]=(hash1[i]+(s[i][j]-'a'+1)*mi1[j])%mo;
			hash2[i]=hash2[i]+s[i][j]*mi2[j];
		}
	}
	for (j=1;j&lt;=m;j++)
	{
		++TIME;
		for (i=1;i&lt;=n;i++)
		{
			int t1=(hash1[i]-s[i][j]*mi1[j])%mo;
			if (t1&lt;0) t1+=mo;
			int t2=hash2[i]-s[i][j]*mi2[j];
			bool flag=false;
			for (int p=o[t1];p;p=aa[p][0])
			{
				int y=aa[p][1];
				if (y!=t2) continue;
				flag=true;
				if (vt[p]==TIME) ans+=num[p],num[p]++;
				else vt[p]=TIME,num[p]=1;
			}
			if (flag) continue;
			tot++;
			aa[tot][1]=t2;
			aa[tot][0]=o[t1];
			o[t1]=tot;
			num[tot]=1;
			vt[tot]=TIME;
		}
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem3555</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define MM 211
#define NN 31111
const int p1=31,mo=3000007,p2=19980723;
int hash1[NN],hash2[NN],mi1[NN],mi2[NN],o[mo],aa[6001111][2],num[6001111],vt[6001111];
int n,m,TIME,tot,ans;
char s[NN][MM];
int main()
{
	int i,j;
	mi1[0]=mi2[0]=1;
	for (i=1;i&lt;=200;i++)
	{
		mi1[i]=mi1[i-1]*p1%mo;
		mi2[i]=mi2[i-1]*p2;
	}
	scanf(&quot;%d%d%d\n&quot;,&amp;n,&amp;m,&amp;i);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s\n&quot;,s[i]+1);
		for (hash1[i]=hash2[i]=0,j=1;j&lt;=m;j++)
		{
			hash1[i]=(hash1[i]+(s[i][j]-'a'+1)*mi1[j])%mo;
			hash2[i]=hash2[i]+s[i][j]*mi2[j];
		}
	}
	for (j=1;j&lt;=m;j++)
	{
		++TIME;
		for (i=1;i&lt;=n;i++)
		{
			int t1=(hash1[i]-s[i][j]*mi1[j])%mo;
			if (t1&lt;0) t1+=mo;
			int t2=hash2[i]-s[i][j]*mi2[j];
			bool flag=false;
			for (int p=o[t1];p;p=aa[p][0])
			{
				int y=aa[p][1];
				if (y!=t2) continue;
				flag=true;
				if (vt[p]==TIME) ans+=num[p],num[p]++;
				else vt[p]=TIME,num[p]=1;
			}
			if (flag) continue;
			tot++;
			aa[tot][1]=t2;
			aa[tot][0]=o[t1];
			o[t1]=tot;
			num[tot]=1;
			vt[tot]=TIME;
		}
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem3555</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define MM 211
#define NN 31111
const int p1=31,mo=3000007,p2=19980723;
int hash1[NN],hash2[NN],mi1[NN],mi2[NN],o[mo],aa[6001111][2],num[6001111],vt[6001111];
int n,m,TIME,tot,ans;
char s[NN][MM];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,j;
	mi1[1]=mi2[1]=1;
	for (i=2;i&lt;=200;i++)
	{
		mi1[i]=mi1[i-1]*p1%mo;
		mi2[i]=mi2[i-1]*p2;
	}
	scanf(&quot;%d%d%d\n&quot;,&amp;n,&amp;m,&amp;i);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s\n&quot;,s[i]+1);
		for (hash1[i]=hash2[i]=0,j=1;j&lt;=m;j++)
		{
			hash1[i]=(hash1[i]+(s[i][j]-'a'+1)*mi1[j])%mo;
			hash2[i]=hash2[i]+s[i][j]*mi2[j];
		}
	}
	for (j=1;j&lt;=m;j++)
	{
		++TIME;
		for (i=1;i&lt;=n;i++)
		{
			int t1=(hash1[i]-s[i][j]*mi1[j])%mo;
			if (t1&lt;0) t1+=mo;
			int t2=hash2[i]-s[i][j]*mi2[j];
			bool flag=false;
			for (int p=o[t1];p;p=aa[p][0])
			{
				int y=aa[p][1];
				if (y!=t2) continue;
				flag=true;
				if (vt[p]==TIME) ans+=num[p],num[p]++;
				else vt[p]=TIME,num[p]=1;
			}
			if (flag) continue;
			tot++;
			aa[tot][1]=t2;
			aa[tot][0]=o[t1];
			o[t1]=tot;
			num[tot]=1;
			vt[tot]=TIME;
		}
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem3555</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define MM 211
#define NN 31111
const int p1=31,mo=3000007,p2=19980723;
int hash1[NN],hash2[NN],mi1[NN],mi2[NN],o[mo],aa[6001111][2],num[6001111],vt[6001111];
int n,m,TIME,tot,ans;
char s[NN][MM];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,j;
	mi1[0]=mi2[0]=1;
	for (i=1;i&lt;=200;i++)
	{
		mi1[i]=mi1[i-1]*p1%mo;
		mi2[i]=mi2[i-1]*p2;
	}
	scanf(&quot;%d%d%d\n&quot;,&amp;n,&amp;m,&amp;i);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s\n&quot;,s[i]+1);
		for (hash1[i]=hash2[i]=0,j=1;j&lt;=m;j++)
		{
			hash1[i]=(hash1[i]+(s[i][j]-'a'+1)*mi1[j])%mo;
			hash2[i]=hash2[i]+s[i][j]*mi2[j];
		}
	}
	for (j=1;j&lt;=m;j++)
	{
		++TIME;
		for (i=1;i&lt;=n;i++)
		{
			int t1=(hash1[i]-s[i][j]*mi1[j])%mo;
			if (t1&lt;0) t1+=mo;
			int t2=hash2[i]-s[i][j]*mi2[j];
			bool flag=false;
			for (int p=o[t1];p;p=aa[p][0])
			{
				int y=aa[p][1];
				if (y!=t2) continue;
				flag=true;
				if (vt[p]==TIME) ans+=num[p],num[p]++;
				else vt[p]=TIME,num[p]=1;
			}
			if (flag) continue;
			tot++;
			aa[tot][1]=t2;
			aa[tot][0]=o[t1];
			o[t1]=tot;
			num[tot]=1;
			vt[tot]=TIME;
		}
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem3555</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int p1=31,p2=19980723,mo=999997;
const int AA=6000005,LL=205,NN=300005;
int aa[AA][2],vt[AA],num[AA],mi1[LL],mi2[LL],o[1000000],h1[NN],h2[NN];
int n,L,tot,TIME;
char s[NN][LL];
int get1(int t,int i)
{
	int tmp=(h1[t]-s[t][i]*mi1[L-i])%mo;
	if (tmp&lt;0) tmp+=mo;
	return tmp;
}
int get2(int t,int i)
{
	return h2[t]-s[t][i]*mi2[L-i];
}
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,j,x;
	scanf(&quot;%d%d%d\n&quot;,&amp;n,&amp;L,&amp;x);
	mi1[0]=mi2[0]=1;
	for (i=1;i&lt;=L;i++)
	{
		mi1[i]=mi1[i-1]*p1%mo;
		mi2[i]=mi2[i-1]*p2;
	}
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s\n&quot;,s[i]+1);
		for (j=1;j&lt;=L;j++)
		{
			h1[i]=(h1[i]*p1+s[i][j])%mo;
			h2[i]=h2[i]*p2+s[i][j];
		}
	}
	int ans=0;
	for (i=1;i&lt;=L;i++)
	{
		TIME++;
		for (j=1;j&lt;=n;j++)
		{
			int t1=get1(j,i),t2=get2(j,i);
			bool flag=false;
			for (int p=o[t1];p;p=aa[p][0])
			{
				int y=aa[p][1];
				if (y!=t2) continue;
				flag=true;
				if (vt[p]==TIME) ans+=num[p],num[p]++;
				else vt[p]=TIME,num[p]=1;
				break;
			}
			if (flag) continue;
			tot++;
			aa[tot][1]=t2;
			aa[tot][0]=o[t1];
			o[t1]=tot;
			vt[tot]=TIME;
			num[tot]=1;
		}
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3555</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int p1=31,p2=19980723,mo=2999997;
const int AA=6000005,LL=205,NN=300005;
int aa[AA][2],vt[AA],num[AA],mi1[LL],mi2[LL],o[3000000],h1[NN],h2[NN];
int n,L,tot,TIME;
char s[NN][LL];
int get1(int t,int i)
{
	int tmp=(h1[t]-s[t][i]*mi1[L-i])%mo;
	if (tmp&lt;0) tmp+=mo;
	return tmp;
}
int get2(int t,int i)
{
	return h2[t]-s[t][i]*mi2[L-i];
}
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,j,x;
	scanf(&quot;%d%d%d\n&quot;,&amp;n,&amp;L,&amp;x);
	mi1[0]=mi2[0]=1;
	for (i=1;i&lt;=L;i++)
	{
		mi1[i]=mi1[i-1]*p1%mo;
		mi2[i]=mi2[i-1]*p2;
	}
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s\n&quot;,s[i]+1);
		for (j=1;j&lt;=L;j++)
		{
			h1[i]=(h1[i]*p1+s[i][j])%mo;
			h2[i]=h2[i]*p2+s[i][j];
		}
	}
	int ans=0;
	for (i=1;i&lt;=L;i++)
	{
		TIME++;
		for (j=1;j&lt;=n;j++)
		{
			int t1=get1(j,i),t2=get2(j,i);
			bool flag=false;
			for (int p=o[t1];p;p=aa[p][0])
			{
				int y=aa[p][1];
				if (y!=t2) continue;
				flag=true;
				if (vt[p]==TIME) ans+=num[p],num[p]++;
				else vt[p]=TIME,num[p]=1;
				break;
			}
			if (flag) continue;
			tot++;
			aa[tot][1]=t2;
			aa[tot][0]=o[t1];
			o[t1]=tot;
			vt[tot]=TIME;
			num[tot]=1;
		}
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3560</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define mo 1000000007
#define ln printf(&quot;\n&quot;)
typedef long long LL;
int pr[1001111],sum[1001111],a[101111];
int n,cnt,tot;
bool vt[10001111];
void shai()
{
	vt[1]=true;
	for (int i=2;i&lt;=10000000;i++)
	{
		if (!vt[i]) pr[++cnt]=i;
		for (int j=1;j&lt;=cnt;j++)
		{
			int x=pr[j]*i;
			if (x&gt;10000000) break;
			vt[x]=true;
			if (i%pr[j]==0) break;
		}
	}
}
struct ppt
{
	int p,num;
	void out() {printf(&quot;%d %d\n&quot;,p,num);}
	ppt(int a=0,int b=0) {p=a;num=b;}
	friend bool operator &lt;(ppt a,ppt b) {return a.p&lt;b.p;}
} q[1001111];
void fenjie(int x)
{
	for (int i=1;i&lt;=cnt&amp;&amp;pr[i]*pr[i]&lt;=x;i++)
		if (x%pr[i]==0)
		{
			int num=1;
			x/=pr[i];
			for (;x%pr[i]==0;x/=pr[i]) num++;
			q[++tot]=ppt(pr[i],num);
		}
	if (x&gt;1) q[++tot]=ppt(x,1);
}
LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
LL calc(int l,int r)
{
	LL P=q[l].p;
	int mm=0,i;
	for (i=l;i&lt;=r;i++)
		if (q[i].num&gt;mm) mm=q[i].num;
	LL t=1;
	sum[0]=1;
	for (i=1;i&lt;=mm;i++)
	{
		t=t*P%mo;
		sum[i]=sum[i-1]+t;
		if (sum[i]&gt;mo) sum[i]-=mo;
	}
	LL res=1;
	for (i=l;i&lt;=r;i++)
		res=res*sum[q[i].num]%mo;
	res--;
	res=res*ksm(P,mo-2,mo)%mo*(P-1)%mo;
	res++;
	return res;
}
int main()
{
	//freopen(&quot;best.in&quot;,&quot;r&quot;,stdin);freopen(&quot;best.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,l,r;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	shai();
	for (i=1;i&lt;=n;i++) fenjie(a[i]);
	sort(q+1,q+tot+1);
	//for (i=1;i&lt;=tot;i++) q[i].out();
	LL ans=1;
	for (l=r=1;l&lt;=tot;l=r+1,r=l)
	{
		while (r&lt;=tot&amp;&amp;q[r].p==q[l].p) r++;
		r--;
		//printf(&quot;l=%d r=%d\n&quot;,l,r);
		ans=ans*calc(l,r)%mo;
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem3560</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define mo 1000000007
#define ln printf(&quot;\n&quot;)
typedef long long LL;
int pr[40000],sum[40000],a[400000];
int n,cnt,tot;
bool vt[40000];
void shai()
{
	vt[1]=true;
	for (int i=2;i&lt;=39955;i++)
	{
		if (!vt[i]) pr[++cnt]=i;
		for (int j=1;j&lt;=cnt;j++)
		{
			int x=pr[j]*i;
			if (x&gt;39955) break;
			vt[x]=true;
			if (i%pr[j]==0) break;
		}
	}
}
struct ppt
{
	int p,num;
	void out() {printf(&quot;%d %d\n&quot;,p,num);}
	ppt(int a=0,int b=0) {p=a;num=b;}
	friend bool operator &lt;(ppt a,ppt b) {return a.p&lt;b.p;}
} q[1001111];
void fenjie(int x)
{
	for (int i=1;i&lt;=cnt&amp;&amp;pr[i]*pr[i]&lt;=x;i++)
		if (x%pr[i]==0)
		{
			int num=1;
			x/=pr[i];
			for (;x%pr[i]==0;x/=pr[i]) num++;
			q[++tot]=ppt(pr[i],num);
		}
	if (x&gt;1) q[++tot]=ppt(x,1);
}
LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
LL calc(int l,int r)
{
	LL P=q[l].p;
	int mm=0,i;
	for (i=l;i&lt;=r;i++)
		if (q[i].num&gt;mm) mm=q[i].num;
	LL t=1;
	sum[0]=1;
	for (i=1;i&lt;=mm;i++)
	{
		t=t*P%mo;
		sum[i]=sum[i-1]+t;
		if (sum[i]&gt;mo) sum[i]-=mo;
	}
	LL res=1;
	for (i=l;i&lt;=r;i++)
		res=res*sum[q[i].num]%mo;
	res--;
	res=res*ksm(P,mo-2,mo)%mo*(P-1)%mo;
	res++;
	return res;
}
int main()
{
	//freopen(&quot;best.in&quot;,&quot;r&quot;,stdin);freopen(&quot;best.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,l,r;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	shai();
	for (i=1;i&lt;=n;i++) fenjie(a[i]);
	sort(q+1,q+tot+1);
	//for (i=1;i&lt;=tot;i++) q[i].out();
	LL ans=1;
	for (l=r=1;l&lt;=tot;l=r+1,r=l)
	{
		while (r&lt;=tot&amp;&amp;q[r].p==q[l].p) r++;
		r--;
		//printf(&quot;l=%d r=%d\n&quot;,l,r);
		ans=ans*calc(l,r)%mo;
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem3563</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
using namespace std;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
const int NN=100111,MM=501111;
int o[NN],aa[MM&lt;&lt;1][2],fa[NN],dfn[NN];
int n,m,tes,tot=1,TIME;
LL val[MM],temp[NN];
bool vt[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar());
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline LL getrand()
{
	LL tmp=(LL)rand()*rand()*rand();
	if (tmp&lt;0) tmp+=1ll&lt;&lt;63;
	return ++tmp;
}
void dfs(int v)
{
	dfn[v]=++TIME;
	vt[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		if (!vt[y])
		{
			fa[y]=v;
			dfs(y);
			val[p&gt;&gt;1]=temp[y];
			temp[v]^=temp[y];
		}
		else if (dfn[y]&lt;dfn[v])
		{
			val[p&gt;&gt;1]=getrand();
			temp[v]^=val[p&gt;&gt;1];
			temp[y]^=val[p&gt;&gt;1];
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	int i,j,x,y,k;
	for (i=1;i&lt;=m;i++)
	{
		read(x),read(y);
		addedge(x,y),addedge(y,x);
	}
	dfs(1);
	int lastans=0;
	for (read(tes);tes;tes--)
	{
		read(k);k^=lastans;
		LL b[17];
		for (i=1;i&lt;=k;i++)
		{
			read(x);
			b[i]=val[x^lastans];
		}
		int t=0;
		for (i=63;i;i--)
		{
			for (j=t+1;j&lt;=k;j++)
				if (b[j]&amp;(1ll&lt;&lt;(i-1))) break;
			if (j==k+1) continue;
			swap(b[++t],b[j]);
			for (j=t+1;j&lt;=k;j++)
				if (b[j]&amp;(1ll&lt;&lt;(i-1))) b[j]^=b[t];
		}
		bool flag=true;
		for (i=1;i&lt;=k;i++)
			if (b[i]==0) flag=false;
		if (flag) lastans++;
		printf(flag?&quot;Connected\n&quot;:&quot;Disconnected\n&quot;);
	}
	return 0;
}<pre><h2>Problem3564</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
#define sqr(x) ((x)*(x))
const DD eps=1e-7,pai=3.14159265358979;
const int NN=50111;
int n;
struct point
{
	DD x,y;
	point(DD _x=0,DD _y=0) {x=_x,y=_y;}
	inline void in() {scanf(&quot;%lf%lf&quot;,&amp;x,&amp;y);}
	inline void out() {printf(&quot;%.3f %.3f\n&quot;,x,y);}
	point rotate(DD sita)
	{
		DD xx=x*cos(sita)-y*sin(sita);
		DD yy=y*cos(sita)+x*sin(sita);
		x=xx,y=yy;
		return *this;
	}
	friend point operator +(const point &amp;a,const point &amp;b) {return point(a.x+b.x,a.y+b.y);}
	friend point operator -(const point &amp;a,const point &amp;b) {return point(a.x-b.x,a.y-b.y);}
	friend point operator *(const point &amp;a,DD t) {return point(a.x*t,a.y*t);}
	friend point operator *(DD t,const point &amp;a) {return point(a.x*t,a.y*t);}
	friend DD operator %(const point &amp;a,const point &amp;b) {return a.x*b.y-b.x*a.y;}
	friend point linejd(point P,point v,point Q,point w)
	{
		point u=P-Q;
		DD t=(w%u)/(v%w);
		return P+t*v;
	}
	friend DD getdist(const point &amp;a,const point &amp;b) {return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));}
} q[NN];
struct yuan
{
	point O;DD r;
	yuan(point _O=point(0,0),DD _r=0) {O=_O,r=_r;}
	inline bool inside(point P) {return getdist(O,P)-r&lt;eps;}
};
point calcwx(point A,point B,point C)
{
	point P=(A+B)*0.5,v=(A-B).rotate(pai/2);
	point Q=(B+C)*0.5,w=(B-C).rotate(pai/2);
	return linejd(P,v,Q,w);
}
DD work()
{
	random_shuffle(q+1,q+n+1);
	yuan C;
	int i,j,k;
	for (i=1;i&lt;=n;i++) if (!C.inside(q[i]))
	{
		C.O=q[i],C.r=0;
		for (j=1;j&lt;i;j++) if (!C.inside(q[j]))
		{
			C.O=(q[i]+q[j])*0.5;
			C.r=getdist(C.O,q[i]);
			for (k=1;k&lt;j;k++) if (!C.inside(q[k]))
			{
				C.O=calcwx(q[i],q[j],q[k]);
				C.r=getdist(C.O,q[i]);
			}
		}
	}
	return C.r;
}
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,P;
	for (i=1;i&lt;=n;i++) q[i].in();
	scanf(&quot;%d&quot;,&amp;x);
	DD alfa=(DD)x/180*pai;
	scanf(&quot;%d&quot;,&amp;P);
	for (i=1;i&lt;=n;i++)
	{
		q[i].rotate(-alfa);
		q[i].x/=P;
	}
	//printf(&quot;q:\n&quot;);for (i=1;i&lt;=n;i++) q[i].out();
	printf(&quot;%.3f\n&quot;,work());
	return 0;
}<pre><h2>Problem3566</h2><pre>#include&lt;cstdio&gt;
#include&lt;cctype&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
  
typedef double f2;
  
#define N 500010
  
int head[N],next[N&lt;&lt;1],end[N&lt;&lt;1],pa[N];f2 p[N&lt;&lt;1],pp[N];
inline void addedge(int a,int b,f2 _p){static int q=1;end[q]=b,next[q]=head[a],head[a]=q,p[q++]=_p;}
inline void make(int a,int b,f2 _p){addedge(a,b,_p),addedge(b,a,_p);}
  
f2 f[N][2];
void dfs1(int x,int fa){
    for(int j=head[x];j;j=next[j]){
        if(end[j]!=fa){
            pp[end[j]]=p[j],pa[end[j]]=x,dfs1(end[j],x);
            f[x][0]*=f[end[j]][0]+(1-f[end[j]][0])*(1-pp[end[j]]);
        }
    }
}
void dfs2(int x,int fa){
    f2 t,_p;
    for(int j=head[x];j;j=next[j]){
        if(end[j]!=fa){
            t=f[end[j]][0]+(1-f[end[j]][0])*(1-pp[end[j]]);
            _p=t&lt;1e-6?0:f[x][1]*f[x][0]/t;
            f[end[j]][1]=_p+(1-_p)*(1-pp[end[j]]);
            dfs2(end[j],x);
        }
    }
}
int main(){
  // freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
    int n;cin&gt;&gt;n;
    register int i;int a,b,x;for(i=1;i&lt;n;++i)scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;x),make(a,b,x/100.0);
  
    for(i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,&amp;x),f[i][0]=1-x/100.0;
    dfs1(1,-1),f[1][1]=1,dfs2(1,-1);
    f2 res=0;for(i=1;i&lt;=n;++i)res+=1-f[i][0]*f[i][1];
    printf(&quot;%.6f&quot;,res);
    return 0;
}<pre><h2>Problem3566</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef double DD;
#define ln printf(&quot;\n&quot;)
const int NN=501111;
int o[NN],aa[NN&lt;&lt;1][3],que[NN],fa[NN];
int n,tot;
DD f[NN],g[NN],q[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar());
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
}
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void bfs()
{
	int head=0,tail=1;
	que[1]=1;
	while (head&lt;tail)
	{
		int x=que[++head];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[x]) continue;
			fa[y]=x;
			que[++tail]=y;
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y),read(z);
		z=100-z;
		addedge(x,y,z),addedge(y,x,z);
	}
	for (i=1;i&lt;=n;i++)
	{
		read(x);
		q[i]=(DD)(100-x)/100;
	}
	bfs();
	for (i=n;i;i--)
	{
		x=que[i];
		f[x]=1;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[x]) continue;
			f[x]*=q[y]*f[y]+(1-q[y]*f[y])*aa[p][2]/100;
		}
	}
	//printf(&quot;f &quot;);for(i=1;i&lt;=n;i++)printf(&quot;%.3f &quot;,f[i]);ln;
	g[1]=1;
	for (i=1;i&lt;=n;i++)
	{
		x=que[i];
		DD tmp=f[x]*g[x];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[x]) continue;
			DD t=tmp/(q[y]*f[y]+(1-q[y]*f[y])*aa[p][2]/100);
			g[y]=q[x]*t+(1-q[x]*t)*aa[p][2]/100;
		}
	}
	DD ans=0;
	for (i=1;i&lt;=n;i++)
		ans+=1-f[i]*g[i]*q[i];
	printf(&quot;%.6f\n&quot;,ans);
	return 0;
}<pre><h2>Problem3569</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
using namespace std;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
const int NN=100111,MM=501111;
int o[NN],aa[MM&lt;&lt;1][2],fa[NN],dfn[NN];
int n,m,tes,tot=1,TIME;
LL val[MM],temp[NN];
bool vt[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar());
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline LL getrand()
{
	LL tmp=(LL)rand()*rand()*rand();
	if (tmp&lt;0) tmp+=1ll&lt;&lt;63;
	return ++tmp;
}
void dfs(int v)
{
	dfn[v]=++TIME;
	vt[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		if (!vt[y])
		{
			fa[y]=v;
			dfs(y);
			val[p&gt;&gt;1]=temp[y];
			temp[v]^=temp[y];
		}
		else if (dfn[y]&lt;dfn[v])
		{
			val[p&gt;&gt;1]=getrand();
			temp[v]^=val[p&gt;&gt;1];
			temp[y]^=val[p&gt;&gt;1];
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	int i,j,x,y,k;
	for (i=1;i&lt;=m;i++)
	{
		read(x),read(y);
		addedge(x,y),addedge(y,x);
	}
	dfs(1);
	int lastans=0;
	for (read(tes);tes;tes--)
	{
		read(k);
		LL b[17];
		for (i=1;i&lt;=k;i++)
		{
			read(x);
			b[i]=val[x^lastans];
		}
		int t=0;
		for (i=63;i;i--)
		{
			for (j=t+1;j&lt;=k;j++)
				if (b[j]&amp;(1ll&lt;&lt;(i-1))) break;
			if (j==k+1) continue;
			swap(b[++t],b[j]);
			for (j=t+1;j&lt;=k;j++)
				if (b[j]&amp;(1ll&lt;&lt;(i-1))) b[j]^=b[t];
		}
		bool flag=true;
		for (i=1;i&lt;=k;i++)
			if (b[i]==0) flag=false;
		if (flag) lastans++;
		printf(flag?&quot;Connected\n&quot;:&quot;Disconnected\n&quot;);
	}
	return 0;
}<pre><h2>Problem3571</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
#define inf 999999999
#define mii(a,b) ((a)&lt;(b)?(a):(b))
int A[77][77],B[77][77],o[77*2],aa[11111][4],pre[77*2],dist[77*2],q[1000000];
int tes,n,S,T,ans,tot;
bool dl[77*2];
bool qwe=false;
struct point
{
	int x,y;
	void out() {printf(&quot;x=%d y=%d\n&quot;,x,y);}
	point(int a=0,int b=0) {x=a,y=b;}
	friend int operator %(point a,point b) {return a.x*b.y-b.x*a.y;}
	friend point operator -(point a,point b) {a.x-=b.x;a.y-=b.y;return a;}
};
bool spfa()
{
	int head=0,tail=1,x,p,y;
	q[1]=S;
	memset(dist,60,sizeof(dist));
	dist[S]=0;
	memset(dl,0,sizeof(dl));
	dl[S]=true;
	while (head&lt;tail)
	{
		x=q[++head];
		dl[x]=false;
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;dist[x]+aa[p][3]&lt;dist[y])
			{
				pre[y]=p;
				dist[y]=dist[x]+aa[p][3];
				if (!dl[y]) dl[y]=true,q[++tail]=y;
			}
		}
	}
	return dist[T]&lt;dist[0];
}
void doit()
{
	int p,ff=inf;
	for (p=pre[T];p;p=pre[aa[p^1][1]]) ff=mii(ff,aa[p][2]);
	for (p=pre[T];p;p=pre[aa[p^1][1]])
	{
		aa[p][2]-=ff;
		aa[p^1][2]+=ff;
	}
}
void addedge(int p,int q,int v,int c)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][3]=c;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v,int c)
{
	//if (qwe) printf(&quot;add  %d %d %d %d\n&quot;,p,q,v,c);
	addedge(p,q,v,c);
	addedge(q,p,0,-c);
}
point calc(int t1,int t2)
{
	int i,j,p;
	memset(o,0,sizeof(o));
	tot=1;
	S=n+n+1,T=S+1;
	for (i=1;i&lt;=n;i++)
	{
		add(S,i,1,0);
		add(i+n,T,1,0);
		for (j=1;j&lt;=n;j++)
			add(i,j+n,1,t1*A[i][j]+t2*B[i][j]);
	}
	while (spfa()) doit();
	int sumA=0,sumB=0;
	for (i=1;i&lt;=n;i++)
	{
		for (p=o[i];p;p=aa[p][0])
			if (aa[p][2]==0) break;
		j=aa[p][1]-n;
		//if (qwe) printf(&quot;%d &quot;,j);
		sumA+=A[i][j],sumB+=B[i][j];
	}
	//if (qwe) ln;
	i=sumA*sumB;
	if (i&lt;ans) ans=i;
	return point(sumA,sumB);
}
void work(point M,point N)
{
	int t1=M.y-N.y,t2=N.x-M.x;
	point P=calc(t1,t2);
	if ((P-M)%(N-M)&lt;=0) return;
	work(M,P);
	work(P,N);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes--;)
	{
		scanf(&quot;%d&quot;,&amp;n);
		int i,j;
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=n;j++) scanf(&quot;%d&quot;,&amp;A[i][j]);
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=n;j++) scanf(&quot;%d&quot;,&amp;B[i][j]);
		ans=inf;
		//qwe=true;
		point M=calc(1,0);
		//M.out();qwe=false;
		point N=calc(0,1);
		work(M,N);
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
<pre><h2>Problem3571</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 999999999
#define mii(a,b) ((a)&lt;(b)?(a):(b))
int A[77][77],B[77][77],o[77*2],aa[11111][4],pre[77*2],dist[77*2],q[11111];
int tes,n,S,T,ans,tot;
bool dl[77*2];
struct point
{
	int x,y;
	point(int a=0,int b=0) {x=a,y=b;}
	friend int operator %(point a,point b) {return a.x*b.y-b.x*a.y;}
	friend point operator -(point a,point b) {a.x-=b.x;a.y-=b.y;return a;}
};
bool spfa()
{
	int head=0,tail=1,x,p,y;
	q[1]=S;
	memset(dist,60,sizeof(dist));
	dist[S]=0;
	memset(dl,0,sizeof(dl));
	dl[S]=true;
	while (head&lt;tail)
	{
		x=q[++head];
		dl[x]=false;
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;dist[x]+aa[p][3]&lt;dist[y])
			{
				pre[y]=p;
				dist[y]=dist[x]+aa[p][3];
				if (!dl[y]) dl[y]=true,q[++tail]=y;
			}
		}
	}
	return dist[T]&lt;dist[0];
}
void doit()
{
	int p,ff=inf;
	for (p=pre[T];p;p=pre[aa[p^1][1]]) ff=mii(ff,aa[p][2]);
	for (p=pre[T];p;p=pre[aa[p^1][1]])
	{
		aa[p][2]-=ff;
		aa[p^1][2]+=ff;
	}
}
void addedge(int p,int q,int v,int c)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][3]=c;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void add(int p,int q,int v,int c)
{
	addedge(p,q,v,c);
	addedge(q,p,0,-c);
}
point calc(int t1,int t2)
{
	int i,j,p;
	memset(o,0,sizeof(o));
	tot=1;
	S=n+n+1,T=S+1;
	for (i=1;i&lt;=n;i++)
	{
		add(S,i,1,0);
		add(i+n,T,1,0);
		for (j=1;j&lt;=n;j++)
			add(i,j+n,1,t1*A[i][j]+t2*B[i][j]);
	}
	while (spfa()) doit();
	int sumA=0,sumB=0;
	for (i=1;i&lt;=n;i++)
	{
		for (p=o[i];p;p=aa[p][0])
			if (aa[p][2]==0) break;
		j=aa[p][1]-n;
		sumA+=A[i][j],sumB+=B[i][j];
	}
	i=sumA*sumB;
	if (i&lt;ans) ans=i;
	return point(sumA,sumB);
}
void work(point M,point N)
{
	int t1=M.y-N.y,t2=N.x-M.x;
	point P=calc(t1,t2);
	if ((P-M)%(N-M)&lt;=0) return;
	work(M,P);
	work(P,N);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes--;)
	{
		scanf(&quot;%d&quot;,&amp;n);
		int i,j;
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=n;j++) scanf(&quot;%d&quot;,&amp;A[i][j]);
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=n;j++) scanf(&quot;%d&quot;,&amp;B[i][j]);
		ans=inf;
		point M=calc(1,0);
		point N=calc(0,1);
		work(M,N);
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
<pre><h2>Problem3572</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef pair&lt;int,int&gt; pii;
#define mp make_pair
#define fi first
#define se second
#define inf 999999999
#define ln printf(&quot;\n&quot;)
const int NN=301111;
int size[NN],deep[NN],dfn[NN];
int n,m,tes;
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);ln;}
struct Shu
{
	int o[NN],aa[NN*2][2],fa[20][NN];
	int tot,dfx;
	inline void addedge(int p,int q)
	{
		tot++;
		aa[tot][1]=q;
		aa[tot][0]=o[p];
		o[p]=tot;
	}
	void dfs(int v)
	{
		size[v]=1;
		dfn[v]=++dfx;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[0][v]) continue;
			fa[0][y]=v;
			deep[y]=deep[v]+1;
			dfs(y);
			size[v]+=size[y];
		}
	}
	void in()
	{
		scanf(&quot;%d&quot;,&amp;n);
		int i,j,x,y;
		for (i=1;i&lt;n;i++)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			addedge(x,y),addedge(y,x);
		}
		deep[1]=1;
		dfs(1);
		for (j=1;j&lt;=19;j++)
			for (i=1;i&lt;=n;i++) fa[j][i]=fa[j-1][fa[j-1][i]];
	}
	int getlca(int x,int y)
	{
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		for (int i=19;i&gt;=0;i--)
			if (deep[fa[i][x]]&gt;=deep[y]) x=fa[i][x];
		if (x==y) return x;
		for (int i=19;i&gt;=0;i--)
			if (fa[i][x]!=fa[i][y]) x=fa[i][x],y=fa[i][y];
		return fa[0][x];
	}
	int find(int x,int d)
	{
		for (int i=19;i&gt;=0;i--)
			if (d&amp;(1&lt;&lt;i)) x=fa[i][x];
		return x;
	}
	int dist(int x,int y)
	{
		if (deep[x]&gt;deep[y]) return deep[x]-deep[y];
		else return deep[y]-deep[x];
	}
} shu;
bool cmp(int a,int b) {return dfn[a]&lt;dfn[b];}
void work()
{
	static int ask[NN],record[NN],ans[NN],tree[NN],sta[NN],fa[NN],all[NN];
	static pii near[NN];
	int i;
	scanf(&quot;%d&quot;,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;ask[i]);
		record[i]=ask[i];
		near[ask[i]]=mp(0,ask[i]);
		ans[ask[i]]=0;
	}
	sort(ask+1,ask+m+1,cmp);
	int top=0,tot=0;
	for (i=1;i&lt;=m;i++)
	{
		int x=ask[i];
		fa[x]=0;
		tree[++tot]=x;
		if (top==0)
		{
			sta[++top]=x;
			continue;
		}
		int lca=shu.getlca(x,sta[top]);
		fa[lca]=0;
		for (;deep[lca]&lt;deep[sta[top]];top--)
		{
			if (deep[lca]&gt;=deep[sta[top-1]])
			{
				fa[sta[top--]]=lca;
				if (lca!=sta[top])
				{
					sta[++top]=lca,tree[++tot]=lca;
					near[lca]=mp(inf,0);
				}
				break;
			}
			fa[sta[top]]=sta[top-1];
		}
		if (x!=sta[top]) sta[++top]=x;
	}
	for (;top&gt;1;top--) fa[sta[top]]=sta[top-1];
	sort(tree+1,tree+tot+1,cmp);
	//printf(&quot;tree &quot;);out(tree,1,tot);printf(&quot;fa   &quot;);out(fa,1,n);ln;
	for (i=tot;i&gt;1;i--)
	{
		int x=tree[i],y=fa[x];
		near[y]=min(near[y],mp(near[x].fi+shu.dist(x,y),near[x].se));
	}
	for (i=2;i&lt;=tot;i++)
	{
		int x=tree[i],y=fa[x];
		near[x]=min(near[x],mp(near[y].fi+shu.dist(x,y),near[y].se));
	}
	//for (i=1;i&lt;=n;i++) printf(&quot;%d %d\n&quot;,near[i].fi,near[i].second);ln;
	for (i=1;i&lt;=tot;i++) all[tree[i]]=size[tree[i]];
	ans[near[tree[1]].se]+=n-size[tree[1]];
	for (i=2;i&lt;=tot;i++)
	{
		if (i==6)
		{
			i++;
			i--;
		}
		//printf(&quot;\n--------------------------------------------------------------------\n&quot;);
		int x=tree[i],f=fa[x];
		int l=deep[x]-deep[f];
		//printf(&quot;l=%d\n&quot;,l);printf(&quot;%d\n&quot;,shu.find(x,l-1));
		int sum=size[shu.find(x,l-1)]-size[x];
		//printf(&quot;sum=%d\n&quot;,sum);
		all[f]-=sum+size[x];
		if (near[x].se==near[f].se)
		{
			ans[near[x].se]+=sum;
			//ln;printf(&quot;ans &quot;);out(ans,1,n);printf(&quot;all &quot;);out(all,1,n);
			continue;
		}
		int a=near[f].fi,b=near[x].fi;
		//printf(&quot;a=%d b=%d l=%d\n&quot;,a,b,l);
		int t=(a+l-b)/2;
		if (a+l-b==t+t&amp;&amp;near[f].se&lt;near[x].se) t--;
		//printf(&quot;t=%d\n&quot;,t);
		int y=shu.find(x,t);
		//printf(&quot;x=%d f=%d y=%d\n&quot;,x,f,y);
		ans[near[x].se]+=size[y]-size[x];
		ans[near[f].se]+=sum-(size[y]-size[x]);
		//ln;printf(&quot;ans &quot;);out(ans,1,n);printf(&quot;all &quot;);out(all,1,n);
	}
	for (i=1;i&lt;=tot;i++)
		ans[near[tree[i]].se]+=all[tree[i]];
	//ln;printf(&quot;ans &quot;);out(ans,1,n);ln;
	for (i=1;i&lt;=m;i++) printf(&quot;%d &quot;,ans[record[i]]);
	printf(&quot;\n&quot;);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	shu.in();
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--) work();
	return 0;
}<pre><h2>Problem3572</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef pair&lt;int,int&gt; pii;
#define mp make_pair
#define fi first
#define se second
#define inf 999999999
const int NN=301111;
int size[NN],deep[NN],dfn[NN];
int n,m,tes;
struct Shu
{
	int o[NN],aa[NN*2][2],fa[20][NN];
	int tot,dfx;
	inline void addedge(int p,int q)
	{
		tot++;
		aa[tot][1]=q;
		aa[tot][0]=o[p];
		o[p]=tot;
	}
	void dfs(int v)
	{
		size[v]=1;
		dfn[v]=++dfx;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[0][v]) continue;
			fa[0][y]=v;
			deep[y]=deep[v]+1;
			dfs(y);
			size[v]+=size[y];
		}
	}
	void in()
	{
		scanf(&quot;%d&quot;,&amp;n);
		int i,j,x,y;
		for (i=1;i&lt;n;i++)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			addedge(x,y),addedge(y,x);
		}
		deep[1]=1;
		dfs(1);
		for (j=1;j&lt;=19;j++)
			for (i=1;i&lt;=n;i++) fa[j][i]=fa[j-1][fa[j-1][i]];
	}
	int getlca(int x,int y)
	{
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		for (int i=19;i&gt;=0;i--)
			if (deep[fa[i][x]]&gt;=deep[y]) x=fa[i][x];
		if (x==y) return x;
		for (int i=19;i&gt;=0;i--)
			if (fa[i][x]!=fa[i][y]) x=fa[i][x],y=fa[i][y];
		return fa[0][x];
	}
	int find(int x,int d)
	{
		for (int i=19;i&gt;=0;i--)
			if (d&amp;(1&lt;&lt;i)) x=fa[i][x];
		return x;
	}
	int dist(int x,int y)
	{
		if (deep[x]&gt;deep[y]) return deep[x]-deep[y];
		else return deep[y]-deep[x];
	}
} shu;
bool cmp(int a,int b) {return dfn[a]&lt;dfn[b];}
void work()
{
	static int ask[NN],record[NN],ans[NN],tree[NN],sta[NN],fa[NN],all[NN];
	static pii near[NN];
	int i;
	scanf(&quot;%d&quot;,&amp;m);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;ask[i]);
		record[i]=ask[i];
		near[ask[i]]=mp(0,ask[i]);
		ans[ask[i]]=0;
	}
	sort(ask+1,ask+m+1,cmp);
	int top=0,tot=0;
	for (i=1;i&lt;=m;i++)
	{
		int x=ask[i];
		fa[x]=0;
		tree[++tot]=x;
		if (top==0)
		{
			sta[++top]=x;
			continue;
		}
		int lca=shu.getlca(x,sta[top]);
		fa[lca]=0;
		for (;deep[lca]&lt;deep[sta[top]];top--)
		{
			if (deep[lca]&gt;=deep[sta[top-1]])
			{
				fa[sta[top--]]=lca;
				if (lca!=sta[top])
				{
					sta[++top]=lca,tree[++tot]=lca;
					near[lca]=mp(inf,0);
				}
				break;
			}
			fa[sta[top]]=sta[top-1];
		}
		if (x!=sta[top]) sta[++top]=x;
	}
	for (;top&gt;1;top--) fa[sta[top]]=sta[top-1];
	sort(tree+1,tree+tot+1,cmp);
	for (i=tot;i&gt;1;i--)
	{
		int x=tree[i],y=fa[x];
		near[y]=min(near[y],mp(near[x].fi+shu.dist(x,y),near[x].se));
	}
	for (i=2;i&lt;=tot;i++)
	{
		int x=tree[i],y=fa[x];
		near[x]=min(near[x],mp(near[y].fi+shu.dist(x,y),near[y].se));
	}
	for (i=1;i&lt;=tot;i++) all[tree[i]]=size[tree[i]];
	ans[near[tree[1]].se]+=n-size[tree[1]];
	for (i=2;i&lt;=tot;i++)
	{
		if (i==6)
		{
			i++;
			i--;
		}
		int x=tree[i],f=fa[x];
		int l=deep[x]-deep[f];
		int sum=size[shu.find(x,l-1)]-size[x];
		all[f]-=sum+size[x];
		if (near[x].se==near[f].se)
		{
			ans[near[x].se]+=sum;
			continue;
		}
		int a=near[f].fi,b=near[x].fi;
		int t=(a+l-b)/2;
		if (a+l-b==t+t&amp;&amp;near[f].se&lt;near[x].se) t--;
		int y=shu.find(x,t);
		ans[near[x].se]+=size[y]-size[x];
		ans[near[f].se]+=sum-(size[y]-size[x]);
	}
	for (i=1;i&lt;=tot;i++)
		ans[near[tree[i]].se]+=all[tree[i]];
	for (i=1;i&lt;=m;i++) printf(&quot;%d &quot;,ans[record[i]]);
	printf(&quot;\n&quot;);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	shu.in();
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--) work();
	return 0;
}<pre><h2>Problem3572</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef pair&lt;int,int&gt; pii;
#define mp make_pair
#define fi first
#define se second
#define inf 999999999
const int NN=301111;
int size[NN],deep[NN],dfn[NN];
int n,m,tes;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
struct Shu
{
	int o[NN],aa[NN*2][2],fa[20][NN];
	int tot,dfx;
	inline void addedge(int p,int q)
	{
		tot++;
		aa[tot][1]=q;
		aa[tot][0]=o[p];
		o[p]=tot;
	}
	void dfs(int v)
	{
		size[v]=1;
		dfn[v]=++dfx;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[0][v]) continue;
			fa[0][y]=v;
			deep[y]=deep[v]+1;
			dfs(y);
			size[v]+=size[y];
		}
	}
	void in()
	{
		read(n);
		int i,j,x,y;
		for (i=1;i&lt;n;i++)
		{
			read(x),read(y);
			addedge(x,y),addedge(y,x);
		}
		deep[1]=1;
		dfs(1);
		for (j=1;j&lt;=19;j++)
			for (i=1;i&lt;=n;i++) fa[j][i]=fa[j-1][fa[j-1][i]];
	}
	int getlca(int x,int y)
	{
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		for (int i=19;i&gt;=0;i--)
			if (deep[fa[i][x]]&gt;=deep[y]) x=fa[i][x];
		if (x==y) return x;
		for (int i=19;i&gt;=0;i--)
			if (fa[i][x]!=fa[i][y]) x=fa[i][x],y=fa[i][y];
		return fa[0][x];
	}
	int find(int x,int d)
	{
		for (int i=19;i&gt;=0;i--)
			if (d&amp;(1&lt;&lt;i)) x=fa[i][x];
		return x;
	}
	int dist(int x,int y)
	{
		if (deep[x]&gt;deep[y]) return deep[x]-deep[y];
		else return deep[y]-deep[x];
	}
} shu;
bool cmp(int a,int b) {return dfn[a]&lt;dfn[b];}
void work()
{
	static int ask[NN],record[NN],ans[NN],tree[NN],sta[NN],fa[NN],all[NN];
	static pii near[NN];
	int i;
	read(m);
	for (i=1;i&lt;=m;i++)
	{
		read(ask[i]);
		record[i]=ask[i];
		near[ask[i]]=mp(0,ask[i]);
		ans[ask[i]]=0;
	}
	sort(ask+1,ask+m+1,cmp);
	int top=0,tot=0;
	for (i=1;i&lt;=m;i++)
	{
		int x=ask[i];
		fa[x]=0;
		tree[++tot]=x;
		if (top==0)
		{
			sta[++top]=x;
			continue;
		}
		int lca=shu.getlca(x,sta[top]);
		fa[lca]=0;
		for (;deep[lca]&lt;deep[sta[top]];top--)
		{
			if (deep[lca]&gt;=deep[sta[top-1]])
			{
				fa[sta[top--]]=lca;
				if (lca!=sta[top])
				{
					sta[++top]=lca,tree[++tot]=lca;
					near[lca]=mp(inf,0);
				}
				break;
			}
			fa[sta[top]]=sta[top-1];
		}
		if (x!=sta[top]) sta[++top]=x;
	}
	for (;top&gt;1;top--) fa[sta[top]]=sta[top-1];
	sort(tree+1,tree+tot+1,cmp);
	for (i=tot;i&gt;1;i--)
	{
		int x=tree[i],y=fa[x];
		near[y]=min(near[y],mp(near[x].fi+shu.dist(x,y),near[x].se));
	}
	for (i=2;i&lt;=tot;i++)
	{
		int x=tree[i],y=fa[x];
		near[x]=min(near[x],mp(near[y].fi+shu.dist(x,y),near[y].se));
	}
	for (i=1;i&lt;=tot;i++) all[tree[i]]=size[tree[i]];
	ans[near[tree[1]].se]+=n-size[tree[1]];
	for (i=2;i&lt;=tot;i++)
	{
		if (i==6)
		{
			i++;
			i--;
		}
		int x=tree[i],f=fa[x];
		int l=deep[x]-deep[f];
		int sum=size[shu.find(x,l-1)]-size[x];
		all[f]-=sum+size[x];
		if (near[x].se==near[f].se)
		{
			ans[near[x].se]+=sum;
			continue;
		}
		int a=near[f].fi,b=near[x].fi;
		int t=(a+l-b)/2;
		if (a+l-b==t+t&amp;&amp;near[f].se&lt;near[x].se) t--;
		int y=shu.find(x,t);
		ans[near[x].se]+=size[y]-size[x];
		ans[near[f].se]+=sum-(size[y]-size[x]);
	}
	for (i=1;i&lt;=tot;i++)
		ans[near[tree[i]].se]+=all[tree[i]];
	for (i=1;i&lt;=m;i++) printf(&quot;%d &quot;,ans[record[i]]);
	printf(&quot;\n&quot;);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	shu.in();
	for (read(tes);tes;tes--) work();
	return 0;
}<pre><h2>Problem3572</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef pair&lt;int,int&gt; pii;
#define mp make_pair
#define fi first
#define se second
#define inf 999999999
const int NN=301111;
int size[NN],deep[NN],dfn[NN];
int n,m,tes;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
struct Shu
{
	int o[NN],aa[NN*2][2],fa[20][NN];
	int tot,dfx;
	inline void addedge(int p,int q)
	{
		tot++;
		aa[tot][1]=q;
		aa[tot][0]=o[p];
		o[p]=tot;
	}
	void dfs(int v)
	{
		size[v]=1;
		dfn[v]=++dfx;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[0][v]) continue;
			fa[0][y]=v;
			deep[y]=deep[v]+1;
			dfs(y);
			size[v]+=size[y];
		}
	}
	void in()
	{
		read(n);
		int i,j,x,y;
		for (i=1;i&lt;n;i++)
		{
			read(x),read(y);
			addedge(x,y),addedge(y,x);
		}
		deep[1]=1;
		dfs(1);
		for (j=1;j&lt;=19;j++)
			for (i=1;i&lt;=n;i++) fa[j][i]=fa[j-1][fa[j-1][i]];
	}
	int getlca(int x,int y)
	{
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		for (int i=19;i&gt;=0;i--)
			if (deep[fa[i][x]]&gt;=deep[y]) x=fa[i][x];
		if (x==y) return x;
		for (int i=19;i&gt;=0;i--)
			if (fa[i][x]!=fa[i][y]) x=fa[i][x],y=fa[i][y];
		return fa[0][x];
	}
	int find(int x,int d)
	{
		for (int i=19;i&gt;=0;i--)
			if (d&amp;(1&lt;&lt;i)) x=fa[i][x];
		return x;
	}
	int dist(int x,int y)
	{
		if (deep[x]&gt;deep[y]) return deep[x]-deep[y];
		else return deep[y]-deep[x];
	}
} shu;
bool cmp(int a,int b) {return dfn[a]&lt;dfn[b];}
void work()
{
	static int ask[NN],record[NN],ans[NN],tree[NN],sta[NN],fa[NN],all[NN];
	static pii near[NN];
	int i;
	read(m);
	for (i=1;i&lt;=m;i++)
	{
		read(ask[i]);
		record[i]=ask[i];
		near[ask[i]]=mp(0,ask[i]);
		ans[ask[i]]=0;
	}
	sort(ask+1,ask+m+1,cmp);
	int top=0,tot=0;
	for (i=1;i&lt;=m;i++)
	{
		int x=ask[i];
		fa[x]=0;
		tree[++tot]=x;
		if (top==0)
		{
			sta[++top]=x;
			continue;
		}
		int lca=shu.getlca(x,sta[top]);
		fa[lca]=0;
		for (;deep[lca]&lt;deep[sta[top]];top--)
		{
			if (deep[lca]&gt;=deep[sta[top-1]])
			{
				fa[sta[top--]]=lca;
				if (lca!=sta[top])
				{
					sta[++top]=lca,tree[++tot]=lca;
					near[lca]=mp(inf,0);
				}
				break;
			}
			fa[sta[top]]=sta[top-1];
		}
		if (x!=sta[top]) sta[++top]=x;
	}
	for (;top&gt;1;top--) fa[sta[top]]=sta[top-1];
	sort(tree+1,tree+tot+1,cmp);
	for (i=tot;i&gt;1;i--)
	{
		int x=tree[i],y=fa[x];
		near[y]=min(near[y],mp(near[x].fi+shu.dist(x,y),near[x].se));
	}
	for (i=2;i&lt;=tot;i++)
	{
		int x=tree[i],y=fa[x];
		near[x]=min(near[x],mp(near[y].fi+shu.dist(x,y),near[y].se));
	}
	for (i=1;i&lt;=tot;i++) all[tree[i]]=size[tree[i]];
	ans[near[tree[1]].se]=n-size[tree[1]];
	for (i=2;i&lt;=tot;i++)
	{
		int x=tree[i],f=fa[x];
		int l=deep[x]-deep[f];
		int sum=size[shu.find(x,l-1)]-size[x];
		all[f]-=sum+size[x];
		if (near[x].se==near[f].se)
		{
			all[f]+=sum;
			continue;
		}
		int a=near[f].fi,b=near[x].fi;
		int t=(a+l-b)/2;
		if (a+l-b==t+t&amp;&amp;near[f].se&lt;near[x].se) t--;
		int y=shu.find(x,t);
		all[x]+=size[y]-size[x];
		all[f]+=sum-(size[y]-size[x]);
	}
	for (i=1;i&lt;=tot;i++)
		ans[near[tree[i]].se]+=all[tree[i]];
	for (i=1;i&lt;=m;i++) printf(&quot;%d &quot;,ans[record[i]]);
	printf(&quot;\n&quot;);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	shu.in();
	for (read(tes);tes;tes--) work();
	return 0;
}<pre><h2>Problem3572</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef pair&lt;int,int&gt; pii;
#define mp make_pair
#define fi first
#define se second
#define inf 999999999
const int NN=300005;
int size[NN],deep[NN],dfn[NN];
int n,m,tes;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
struct Shu
{
	int o[NN],aa[NN*2][2],fa[20][NN];
	int tot,dfx;
	inline void addedge(int p,int q)
	{
		tot++;
		aa[tot][1]=q;
		aa[tot][0]=o[p];
		o[p]=tot;
	}
	void dfs(int v)
	{
		size[v]=1;
		dfn[v]=++dfx;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[0][v]) continue;
			fa[0][y]=v;
			deep[y]=deep[v]+1;
			dfs(y);
			size[v]+=size[y];
		}
	}
	void in()
	{
		read(n);
		int i,j,x,y;
		for (i=1;i&lt;n;i++)
		{
			read(x),read(y);
			addedge(x,y),addedge(y,x);
		}
		deep[1]=1;
		dfs(1);
		for (j=1;j&lt;=19;j++)
			for (i=1;i&lt;=n;i++) fa[j][i]=fa[j-1][fa[j-1][i]];
	}
	int getlca(int x,int y)
	{
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		for (int i=19;i&gt;=0;i--)
			if (deep[fa[i][x]]&gt;=deep[y]) x=fa[i][x];
		if (x==y) return x;
		for (int i=19;i&gt;=0;i--)
			if (fa[i][x]!=fa[i][y]) x=fa[i][x],y=fa[i][y];
		return fa[0][x];
	}
	int find(int x,int d)
	{
		for (int i=19;i&gt;=0;i--)
			if (d&amp;(1&lt;&lt;i)) x=fa[i][x];
		return x;
	}
	int dist(int x,int y)
	{
		if (deep[x]&gt;deep[y]) return deep[x]-deep[y];
		else return deep[y]-deep[x];
	}
} shu;
bool cmp(int a,int b) {return dfn[a]&lt;dfn[b];}
void work()
{
	static int ask[NN],record[NN],ans[NN],tree[NN],sta[NN],fa[NN],all[NN];
	static pii near[NN];
	int i;
	read(m);
	for (i=1;i&lt;=m;i++)
	{
		read(ask[i]);
		record[i]=ask[i];
		near[ask[i]]=mp(0,ask[i]);
		ans[ask[i]]=0;
	}
	sort(ask+1,ask+m+1,cmp);
	int top=0,tot=0;
	for (i=1;i&lt;=m;i++)
	{
		int x=ask[i];
		fa[x]=0;
		tree[++tot]=x;
		if (top==0)
		{
			sta[++top]=x;
			continue;
		}
		int lca=shu.getlca(x,sta[top]);
		fa[lca]=0;
		for (;deep[lca]&lt;deep[sta[top]];top--)
		{
			if (deep[lca]&gt;=deep[sta[top-1]])
			{
				fa[sta[top--]]=lca;
				if (lca!=sta[top])
				{
					sta[++top]=lca,tree[++tot]=lca;
					near[lca]=mp(inf,0);
				}
				break;
			}
			fa[sta[top]]=sta[top-1];
		}
		if (x!=sta[top]) sta[++top]=x;
	}
	for (;top&gt;1;top--) fa[sta[top]]=sta[top-1];
	sort(tree+1,tree+tot+1,cmp);
	for (i=tot;i&gt;1;i--)
	{
		int x=tree[i],y=fa[x];
		near[y]=min(near[y],mp(near[x].fi+shu.dist(x,y),near[x].se));
	}
	for (i=2;i&lt;=tot;i++)
	{
		int x=tree[i],y=fa[x];
		near[x]=min(near[x],mp(near[y].fi+shu.dist(x,y),near[y].se));
	}
	for (i=1;i&lt;=tot;i++) all[tree[i]]=size[tree[i]];
	ans[near[tree[1]].se]=n-size[tree[1]];
	for (i=2;i&lt;=tot;i++)
	{
		int x=tree[i],f=fa[x];
		int l=deep[x]-deep[f];
		int sum=size[shu.find(x,l-1)]-size[x];
		all[f]-=sum+size[x];
		if (near[x].se==near[f].se)
		{
			all[f]+=sum;
			continue;
		}
		int a=near[f].fi,b=near[x].fi;
		int t=(a+l-b)/2;
		if (a+l-b==t+t&amp;&amp;near[f].se&lt;near[x].se) t--;
		int y=shu.find(x,t);
		all[x]+=size[y]-size[x];
		all[f]+=sum-(size[y]-size[x]);
	}
	for (i=1;i&lt;=tot;i++)
		ans[near[tree[i]].se]+=all[tree[i]];
	for (i=1;i&lt;=m;i++) printf(&quot;%d &quot;,ans[record[i]]);
	printf(&quot;\n&quot;);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	shu.in();
	for (read(tes);tes;tes--) work();
	return 0;
}<pre><h2>Problem3573</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#define maxn 500010
#define eps 1e-11
using namespace std;
typedef long double ld;
void Read(int &amp;digit)
{
	digit=0;
	char c;
	for(c=getchar();c&lt;'0'||c&gt;'9';c=getchar());
	for(;c&gt;='0'&amp;&amp;c&lt;='9';digit=digit*10+c-'0',c=getchar());
}
int n;
ld val[maxn],dis[maxn];
int nEdge=1,to[maxn*2],next[maxn*2],start[maxn];
void make(int a,int b)
{
	++nEdge,to[nEdge]=b,next[nEdge]=start[a],start[a]=nEdge;
}
void BFS(int p)
{
	static bool use[maxn];
	static int queue[maxn],deg[maxn],father[maxn];
	int front=0,rear=1;
	queue[rear]=p,use[p]=true;
	while(front&lt;rear)
	{
		int p=queue[++front];
		for(int i=start[p];i;i=next[i])
			if(use[to[i]]==false)
			{
				use[to[i]]=true;
				queue[++rear]=to[i];
				father[to[i]]=p;
			}
	}
	memset(start,0,sizeof(start));
	nEdge=1;
	for(int i=n;i&gt;1;--i)
	{
		int p=queue[i];
		++deg[father[p]];
	}
	for(int i=2;i&lt;=n;++i)
	{
		int p=queue[i],fa=father[p];
		dis[p]=dis[fa]+log(deg[fa]);
	}
}
void read()
{
	Read(n);
	for(int i=1,v;i&lt;=n;++i)
	{
		Read(v);
		val[i]=log(v);
	}
	for(int i=2,a,b;i&lt;=n;++i)
	{
		Read(a),Read(b);
		make(a,b),make(b,a);
	}
	BFS(1);
}
int work()
{
	static ld sorted[maxn];
	for(int i=1;i&lt;=n;++i)
		sorted[i]=dis[i]+val[i];
	sort(sorted+1,sorted+n+1);
	int ans=1;
	for(int i=2,cnt=1;i&lt;=n;++i)
	{
		if(abs(sorted[i]-sorted[i-1])&lt;eps)
			ans=max(ans,++cnt);
		else
			cnt=1;
	}
	return ans;
}
int main()
{
	//freopen(&quot;meat.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;meat.out&quot;,&quot;w&quot;,stdout);
	read();
	printf(&quot;%d\n&quot;,n-work());
	//fclose(stdin);
	//fclose(stdout);
	return 0;
}
<pre><h2>Problem3575</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 101111
#define MM 201111
#define lc(v) ((v)&lt;&lt;1)
#define rc(v) ((v)&lt;&lt;1|1)
#define inf 999999999
int pred[NN],succ[NN],id[MM],aa[MM][3],tmin[NN*4],q[NN+111],dist[NN],dl[NN],o[NN],pos[NN],stack[NN],b[NN];
int n,m,L,tot=0,TIME,top;
bool flag[MM];
struct edge
{
	int a,b,w;
} e[MM];
void build(int v,int l,int r)
{
	tmin[v]=inf;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	build(lc(v),l,mid);
	build(rc(v),mid,r);
}
void change(int v,int l,int r,int i,int x)
{
	if (r-l==1)
	{
		if (x&lt;tmin[v]) tmin[v]=x;
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid) change(lc(v),l,mid,i,x);
	else change(rc(v),mid,r,i,x);
	tmin[v]=min(tmin[lc(v)],tmin[rc(v)]);
}
int find(int v,int l,int r,int ww,int ee)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tmin[v];
	int mid=(l+r)&gt;&gt;1,res=inf;
	if (ww&lt;mid) res=find(lc(v),l,mid,ww,ee);
	if (ee&gt;mid) res=min(res,find(rc(v),mid,r,ww,ee));
	return res;
}
void spfa(int S)
{
	int head=0,tail=1,x,p,y;
	q[1]=S;
	TIME++;
	dl[S]=TIME;
	while (head!=tail)
	{
		head++;if (head&gt;NN) head=1;
		x=q[head];
		dl[x]=0;
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (flag[p]) continue;
			if (pos[y]&gt;0)
			{
				if (dl[y]!=TIME)
				{
					dl[y]=TIME;
					stack[++top]=y;
					b[y]=dist[x]+aa[p][2]+succ[y];
				}
				else b[y]=min(b[y],dist[x]+aa[p][2]+succ[y]);
				continue;
			}
			if (dist[y]&gt;dist[x]+aa[p][2])
			{
				dist[y]=dist[x]+aa[p][2];
				if (dl[y]!=TIME)
				{
					dl[y]=TIME;
					tail++;if (tail&gt;NN) tail=1;
					q[++tail]=y;
				}
			}
		}
	}
}
void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;L);
	int i;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);
		addedge(e[i].a,e[i].b,e[i].w);
	}
	for (i=1;i&lt;=L;i++) scanf(&quot;%d&quot;,&amp;id[i]);
	int now=0;
	for (i=1;i&lt;=L;i++)
	{
		now+=e[id[i]].w;
		pred[e[id[i]].b]=now;
		pos[e[id[i]].b]=i;
	}
	now=0;
	for (i=L;i;i--)
	{
		succ[e[id[i]].b]=now;
		now+=e[id[i]].w;
	}
	memset(dist,60,sizeof(dist));
	build(1,1,L+1);
	for (i=1;i&lt;=L;i++)
	{
		int t=id[i];
		flag[t]=true;
		dist[e[t].a]=pred[e[t].a];
		spfa(e[t].a);
		for (;top;top--)
		{
			int y=stack[top];
			if (pos[y]&gt;=i) change(1,1,L+1,pos[y],b[y]);
		}
		int tmp=find(1,1,L+1,pos[e[t].b],L+1);
		if (tmp&lt;inf) printf(&quot;%d\n&quot;,tmp);
		else printf(&quot;-1\n&quot;);
		flag[t]=false;
	}
	return 0;
}
<pre><h2>Problem3576</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N(1e5+200);
int T,F,n,x,sg[N];
inline int get_sg(int x){
	if(sg[x]!=-1)return sg[x];
	if(x&lt;F)return sg[x]=0;
	bool vis[N];
	memset(vis,0,sizeof(vis));
	for(int i(2);i&lt;=x;i=x/(x/i)+1)
		for(int j(i);j&lt;=i+1&amp;&amp;j&lt;=x;j++){
			int t(0);
			if((x%j)&amp;1)t^=get_sg(x/j+1);
			if((j-x%j)&amp;1)t^=get_sg(x/j);
			vis[t]=1;
		}
	for(int i(0);;i++)
		if(!vis[i])
			return sg[x]=i;
}
int main(){
	scanf(&quot;%d%d&quot;,&amp;T,&amp;F);
	memset(sg,0xff,sizeof(sg));
	while(T--){
		scanf(&quot;%d&quot;,&amp;n);
		int ans(0);
		for(int i(1),x;i&lt;=n;i++){
			scanf(&quot;%d&quot;,&amp;x);
			ans^=get_sg(x);
		}
		printf(&quot;%d&quot;,(bool)ans);
		if(T)printf(&quot; &quot;);
	}
	puts(&quot;&quot;);
	return 0;
}
<pre><h2>Problem3576</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#define maxn 100010
using namespace std;
int SG[maxn],F;
bool use[maxn];
int sign(int n,int p)
{
	return n%2==0?0:p;
}
int sg(int n)
{
//	printf(&quot;sg %d\n&quot;,n);
	static int mex[maxn*10],id;
	if(n&lt;F)
		return 0;
	if(use[n])
		return SG[n];
	use[n]=true;
	for(int i=2;i&lt;=n;i=n/(n/i)+1)
		for(int j=i;j&lt;=i+1&amp;&amp;j&lt;=n;++j)
			sg(n/j+1),sg(n/j);
	++id;
	for(int i=2;i&lt;=n;i=n/(n/i)+1)
		for(int j=i;j&lt;=i+1&amp;&amp;j&lt;=n;++j)
			mex[sign(n%j,SG[n/j+1])^sign(j-n%j,SG[n/j])]=id;
	for(SG[n]=0;mex[SG[n]]==id;++SG[n]);
	return SG[n];
}
void work(int T)
{
	static int stone[maxn],n;
	int sumnim=0;
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n;++i)
	{
		scanf(&quot;%d&quot;,stone+i);
		sumnim^=sg(stone[i]);
	}
	printf(&quot;%d%c&quot;,sumnim==0?0:1,T!=1?' ':'\n');
}
int main()
{
//	freopen(&quot;game.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;game.out&quot;,&quot;w&quot;,stdout);
	int T;
	scanf(&quot;%d %d&quot;,&amp;T,&amp;F);
	for(;T;--T)
		work(T);getchar,getchar();getchar();
//	fclose(stdin);
//	fclose(stdout);
	return 0;
}
<pre><h2>Problem3585</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=201111;
int belong[NN],flag[555],st[555],ed[555],a[NN],num[NN],ans[NN];
int n,m,blocnt,blo;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
}
struct ppt
{
	int l,r,id;
	inline void in(int i) {id=i;read(l),read(r);}
	void out() {printf(&quot;id=%d l=%d r=%d\n&quot;,id,l,r);}
	friend bool operator &lt;(const ppt &amp;a,const ppt &amp;b)
	{
		if (belong[a.l]!=belong[b.l]) return belong[a.l]&lt;belong[b.l];
		return a.r&lt;b.r;
	}
} qry[NN];
inline void add(int x)
{
	if (x&gt;n) return;
	//printf(&quot;add %d\n&quot;,x);
	if (num[x]++==0)
		flag[belong[x]]++;
}
inline void del(int x)
{
	if (x&gt;n) return;
	//printf(&quot;del %d\n&quot;,x);
	if (--num[x]==0)
		flag[belong[x]]--;
}
int work()
{
	int i;
	for (i=1;i&lt;=blocnt;i++)
		if (flag[i]!=ed[i]-st[i]+1) break;
	int t=i;
	//printf(&quot;i=%d st=%d ed=%d\n&quot;,i,st[i],ed[i]);
	for (i=st[t];i&lt;=ed[t];i++)
		if (!num[i]) return i;
	return -1;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	blo=(int)sqrt(n)+1;
	blocnt=0;
	int i,j;
	for (i=0;i&lt;=n;i+=blo)
	{
		blocnt++;
		int t=min(i+blo-1,n);
		st[blocnt]=i,ed[blocnt]=t;
		for (j=i;j&lt;=t;j++) belong[j]=blocnt;
	}
	//printf(&quot;blo=%d\n&quot;,blo);printf(&quot;belong &quot;);for(i=0;i&lt;=n;i++)printf(&quot;%d &quot;,belong[i]);ln;
	for (i=1;i&lt;=n;i++) read(a[i]);
	for (i=1;i&lt;=m;i++) qry[i].in(i);
	sort(qry+1,qry+m+1);
	//printf(&quot;qry:\n&quot;);for(i=1;i&lt;=m;i++)qry[i].out();ln;
	int L=1,R=1;
	add(a[1]);
	for (i=1;i&lt;=m;i++)
	{
		int l=qry[i].l,r=qry[i].r;
		//printf(&quot;\n---------------------------- l=%d r=%d ------------------------------\n&quot;,l,r);
		if (l&lt;L)
			for (j=l;j&lt;L;j++) add(a[j]);
		if (r&gt;R)
			for (j=r;j&gt;R;j--) add(a[j]);
		if (l&gt;L)
			for (j=L;j&lt;l;j++) del(a[j]);
		if (r&lt;R)
			for (j=R;j&gt;r;j--) del(a[j]);
		ans[qry[i].id]=work();
		L=l,R=r;
	}
	for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem3585</h2><pre>
#define MAXN 200010UL
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;

using namespace std;

int n, m, ans, Ans[MAXN], ti[MAXN], w[MAXN], c[MAXN], bg[MAXN];
bool vis[MAXN];

struct ME {
	int lt, rt, id;
}st[MAXN];

inline bool Comp(ME x, ME y) {
	return bg[x.lt]==bg[y.lt]?x.rt&lt;y.rt:bg[x.lt]&lt;bg[y.lt];
}

inline void Add(int x, int k) {
	++ x;
	while(x&lt;=n+1) {
		c[x] += k;
		x += x&amp;(-x);
	}
	return;
}

inline int Find(int x) {
	int an = 0;
	++ x;
	while(x) {
		an += c[x];
		x -= x&amp;(-x);
	}
	return an;
}

inline void Update(int x) {
	int l = x+1, r = n;
	while(l&lt;=r) {
		int mid = (l+r)&gt;&gt;1;
		if(mid&gt;=Find(mid)) r = mid-1, ans = mid;
		else l = mid+1;
	}
	return;
}

inline void Reverse(int x) {
	if(w[x]&gt;n) return;
	if(!vis[x]) {
		vis[x] = true;
		++ ti[w[x]];
		if(ti[w[x]]==1) {
			Add(w[x], 1);
			if(ans==w[x]) Update(ans);
		}
	} else {
		vis[x] = false;
		-- ti[w[x]];
		if(ti[w[x]]==0) {
			Add(w[x], -1);
			if(ans&gt;w[x]) ans = w[x];
		}
	}
	return;
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	int blo = sqrt(n);
	for(int i = 1 ; i &lt;= n ; ++ i) scanf(&quot;%d&quot;, &amp;w[i]), bg[i] = (i-1)/blo+1;
	for(int i = 1 ; i &lt;= m ; ++ i) {
		scanf(&quot;%d%d&quot;, &amp;st[i].lt, &amp;st[i].rt);
		st[i].id = i;
	}
	sort(st+1, st+m+1, Comp);
	for(int i = st[1].lt ; i &lt;= st[1].rt ; ++ i) Reverse(i);
	Ans[st[1].id] = ans;
	int l = st[1].lt, r = st[1].rt;
	for(int i = 2 ; i &lt;= m ; ++ i) {
		while(l&lt;st[i].lt) Reverse(l ++);
		while(l&gt;st[i].lt) Reverse(-- l);
		while(r&lt;st[i].rt) Reverse(++ r);
		while(r&gt;st[i].rt) Reverse(r --);
		Ans[st[i].id] = ans;
	}
	for(int i = 1 ; i &lt;= m ; ++ i) printf(&quot;%d\n&quot;, Ans[i]);
	//while(1);
	return 0;
}
<pre><h2>Problem3585</h2><pre>
#define MAXN 200010UL
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;

using namespace std;

int n, m, ans, num, Ans[MAXN], ti[MAXN], w[MAXN], sum[MAXN][3], c[MAXN], bg[MAXN];
bool vis[MAXN];

struct ME {
	int lt, rt, id;
}st[MAXN];

inline bool Comp(ME x, ME y) {
	return bg[x.lt]==bg[y.lt]?x.rt&lt;y.rt:bg[x.lt]&lt;bg[y.lt];
}

inline void Add(int x, int k) {
	++ x;
	while(x&lt;=n+1) {
		c[x] += k;
		x += x&amp;(-x);
	}
	return;
}

inline int Find(int x) {
	int an = 0;
	++ x;
	while(x) {
		an += c[x];
		x -= x&amp;(-x);
	}
	return an;
}

inline void Update(int x) {
	/*int l = x+1, r = n;
	while(l&lt;=r) {
		int mid = (l+r)&gt;&gt;1;
		if(mid&gt;=Find(mid)) r = mid-1, ans = mid;
		else l = mid+1;
	}*/
	for(int i = 1 ; i &lt;= num ; ++ i) {
		if(sum[i][2]&lt;sum[i][1]-sum[i][0]+1) {
			for(int j = sum[i][0] ; j &lt;= sum[i][1] ; ++ j) {
				if(ti[j]==0) {
					ans = j;
					break;
				}
			}
			break;
		}
	}
	return;
}

inline void Reverse(int x) {
	if(w[x]&gt;n) return;
	if(!vis[x]) {
		vis[x] = true;
		++ ti[w[x]];
		if(ti[w[x]]==1) {
			++ sum[bg[w[x]]][2];
			if(ans==w[x]) Update(ans);
		}
	} else {
		vis[x] = false;
		-- ti[w[x]];
		if(ti[w[x]]==0) {
			-- sum[bg[w[x]]][2];
			if(ans&gt;w[x]) ans = w[x];
		}
	}
	return;
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	int blo = sqrt(n);
	for(int i = 1 ; i &lt;= n ; ++ i) {
		scanf(&quot;%d&quot;, &amp;w[i]), bg[i] = (i-1)/blo+1;
		if(bg[i]!=bg[i-1]) ++ num, sum[num-1][1] = i-1, sum[num][0] = i;
	}
	sum[num][1] = n;
	for(int i = 1 ; i &lt;= m ; ++ i) {
		scanf(&quot;%d%d&quot;, &amp;st[i].lt, &amp;st[i].rt);
		st[i].id = i;
	}
	sort(st+1, st+m+1, Comp);
	for(int i = st[1].lt ; i &lt;= st[1].rt ; ++ i) Reverse(i);
	Ans[st[1].id] = ans;
	int l = st[1].lt, r = st[1].rt;
	for(int i = 2 ; i &lt;= m ; ++ i) {
		while(l&lt;st[i].lt) Reverse(l ++);
		while(l&gt;st[i].lt) Reverse(-- l);
		while(r&lt;st[i].rt) Reverse(++ r);
		while(r&gt;st[i].rt) Reverse(r --);
		Ans[st[i].id] = ans;
	}
	for(int i = 1 ; i &lt;= m ; ++ i) printf(&quot;%d\n&quot;, Ans[i]);
	//while(1);
	return 0;
}
<pre><h2>Problem3589</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef pair&lt;int,int&gt; pii;
#define lc (v&lt;&lt;1)
#define rc (v&lt;&lt;1|1)
#define fi first
#define se second
const int NN=201111;
int o[NN],aa[NN*2][2],fa[NN],deep[NN],size[NN],up[NN];
int st[NN],ed[NN],f[19][NN],hea[NN],tsum[NN*4],tag[NN*4];
int n,m,tot=1,K,cnt,ww,ee;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar()) x=x*10+ch-'0';
	if (f) x=-x;
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs1(int v)
{
	size[v]=1;
	int mm=0,tmp=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=f[0][y]=v;
		deep[y]=deep[v]+1;
		dfs1(y);
		size[v]+=size[y];
		if (size[y]&gt;mm) mm=size[y],tmp=y;
	}
	hea[v]=tmp;
}
void dfs2(int v)
{
	st[v]=++cnt;
	if (hea[v])
	{
		up[hea[v]]=up[v];
		dfs2(hea[v]);
	}
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||y==hea[v]) continue;
		up[y]=y;
		dfs2(y);
	}
	ed[v]=cnt;
}
inline void add(int v,int l,int r,int x)
{
	tag[v]+=x;
	tsum[v]+=(r-l)*x;
}
inline void pushdown(int v,int l,int r,int mid)
{
	if (!tag[v]) return;
	add(lc,l,mid,tag[v]);
	add(rc,mid,r,tag[v]);
	tag[v]=0;
}
inline void update(int v)
{
	tsum[v]=tsum[lc]+tsum[rc];
}
void change(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		add(v,l,r,x);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	pushdown(v,l,r,mid);
	if (ww&lt;mid) change(lc,l,mid,x);
	if (ee&gt;mid) change(rc,mid,r,x);
	update(v);
}
int find(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tsum[v];
	int mid=(l+r)&gt;&gt;1,res=0;
	pushdown(v,l,r,mid);
	if (ww&lt;mid) res+=find(lc,l,mid);
	if (ee&gt;mid) res+=find(rc,mid,r);
	return res;
}
struct zhi
{
	int u,v;
	void in()
	{
		scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
		if (deep[u]&lt;deep[v]) {int t=u;u=v;v=t;}
	}
} q[6];
int getlca(int x,int y)
{
	if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
	for (int i=18;i&gt;=0;i--)
		if (deep[f[i][x]]&gt;=deep[y]) x=f[i][x];
	if (x==y) return x;
	for (int i=18;i&gt;=0;i--)
		if (f[i][x]!=f[i][y]) x=f[i][x],y=f[i][y];
	return f[0][x];
}
pii bing(int S)
{
	int cnt=0,x,y;
	for (int i=1;i&lt;=K;i++) if (S&amp;(1&lt;&lt;(i-1)))
	{
		int u=q[i].u,v=q[i].v;
		cnt++;
		if (cnt==1)
		{
			x=u,y=v;
			continue;
		}
		int lca=getlca(x,u);
		if (deep[lca]&lt;deep[y]||deep[lca]&lt;deep[v]) 
			return make_pair(0,0);
		x=lca;
		if (deep[v]&gt;deep[y]) y=v;
	}
	return make_pair(x,y);
}
inline int calc(int x)
{
	int res=0;
	for (;x;x-=x&amp;-x) res++;
	return res;
}
int work()
{
	read(K);
	for (int i=1;i&lt;=K;i++) q[i].in();
	int ans=0;
	for (int S=1;S&lt;1&lt;&lt;K;S++)
	{
		pii tmp=bing(S);
		int x=tmp.fi,y=tmp.se,res=0;
		if (x==0&amp;&amp;y==0) continue;
		while (up[x]!=up[y])
		{
			if (deep[up[x]]&lt;deep[up[y]]) {int t=x;x=y;y=t;}
			ww=st[up[x]],ee=st[x]+1;
			res+=find(1,1,n+1);
			x=fa[up[x]];
		}
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		ww=st[y],ee=st[x]+1;
		res+=find(1,1,n+1);
		if (calc(S)&amp;1) ans+=res;
		else ans-=res;
	}
	return ans;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);
	int i,j,x,y;
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y);
		addedge(x,y),addedge(y,x);
	}
	deep[1]=1;
	dfs1(1);
	up[1]=1;
	dfs2(1);
	for (j=1;j&lt;=18;j++)
		for (i=1;i&lt;=n;i++) f[j][i]=f[j-1][f[j-1][i]];
	for (read(m);m;m--)
	{
		read(x);
		if (x==0)
		{
			read(x),read(y);
			ww=st[x],ee=ed[x]+1;
			change(1,1,n+1,y);
		}
		else printf(&quot;%d\n&quot;,work()&amp;2147483647);
	}
	return 0;
}<pre><h2>Problem3601</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
#define mo 1000000007
int d,w;
LL a[105][105],X[105],h[105];
inline LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (a%=c;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
void gause(int n)
{
	int i,j,k;
	//printf(&quot;a:\n&quot;);for(i=0;i&lt;=n;i++){for(j=0;j&lt;=n+1;j++)printf(&quot;%lld &quot;,a[i][j]);ln;}ln;
	for (i=0;i&lt;n;i++)
	{
		for (j=i;j&lt;=n;j++)
			if (a[j][i]) break;
		if (i!=j)
			for (k=i;k&lt;=n+1;k++) swap(a[i][k],a[j][k]);
		LL inv=ksm(a[i][i],mo-2,mo);
		for (j=i+1;j&lt;=n;j++)
		{
			LL tmp=a[j][i]*inv%mo;
			for (k=i;k&lt;=n+1;k++)
			{
				a[j][k]-=tmp*a[i][k]%mo;
				if (a[j][k]&lt;0) a[j][k]+=mo;
			}
		}
		//printf(&quot;a:\n&quot;);for(int i=0;i&lt;=n;i++){for(int j=0;j&lt;=n+1;j++)printf(&quot;%lld &quot;,a[i][j]);ln;}ln;
	}
	for (i=n;i&gt;=0;i--)
	{
		LL tmp=0;
		for (j=i+1;j&lt;=n;j++)
			(tmp+=a[i][j]*X[j])%=mo;
		X[i]=(a[i][n+1]-tmp)*ksm(a[i][i],mo-2,mo)%mo;
		if (X[i]&lt;0) X[i]+=mo;
	}
	//printf(&quot;X &quot;);for(i=0;i&lt;=n;i++)printf(&quot;%lld &quot;,X[i]);ln;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;d,&amp;w);
	LL sum=0;int i,j;
	for (i=0;i&lt;=d+1;i++)
	{
		sum+=ksm(i+1,d,mo);
		if (sum&gt;=mo) sum-=mo;
		a[i][d+2]=sum;
		LL tmp=1;
		for (j=0;j&lt;=d+1;j++)
		{
			a[i][j]=tmp;
			tmp=tmp*(i+1)%mo;
		}
	}
	gause(d+1);
	for (i=0;i&lt;=d+1;i++) h[i]=1;
	for (;w;w--)
	{
		LL p,a;
		scanf(&quot;%lld%lld&quot;,&amp;p,&amp;a);
		for (i=0;i&lt;=d+1;i++)
		{
			LL tmp=ksm(p,a*i,mo)-ksm(p,d+(a-1)*i,mo);
			if (tmp&lt;0) tmp+=mo;
			h[i]=h[i]*tmp%mo;
		}
	}
	LL ans=0;
	for (i=0;i&lt;=d+1;i++)
		ans=(ans+X[i]*h[i])%mo;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem3611</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define inf 999999999
#define ln printf(&quot;\n&quot;)
const int NN=1001111;
int o[NN],aa[NN][3],dfn[NN],deep[NN];
int n,m,tot,top;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
struct Shu
{
	int f[21][NN],o[NN],aa[NN*2][2];
	int tot,dfx;
	inline void addedge(int p,int q)
	{
		tot++;
		aa[tot][1]=q;
		aa[tot][0]=o[p];
		o[p]=tot;
	}
	void dfs(int v)
	{
		dfn[v]=++dfx;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==f[0][v]) continue;
			f[0][y]=v;
			deep[y]=deep[v]+1;
			dfs(y);
		}
	}
	void in()
	{
		int i,j,x,y;
		read(n);
		for (i=1;i&lt;n;i++)
		{
			read(x),read(y);
			addedge(x,y),addedge(y,x);
		}
		deep[1]=1;
		dfs(1);
		for (j=1;j&lt;=20;j++)
			for (i=1;i&lt;=n;i++) f[j][i]=f[j-1][f[j-1][i]];
	}
	int getlca(int x,int y)
	{
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		for (int i=20;i&gt;=0;i--)
			if (deep[f[i][x]]&gt;=deep[y]) x=f[i][x];
		if (x==y) return x;
		for (int i=20;i&gt;=0;i--)
			if (f[i][x]!=f[i][y]) x=f[i][x],y=f[i][y];
		return f[0][x];
	}
	int dist(int x,int y)
	{
		if (deep[x]&gt;deep[y]) return deep[x]-deep[y];
		else return deep[y]-deep[x];
	}
} shu;
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=shu.dist(p,q);
	aa[tot][0]=o[p];
	o[p]=tot;
	//printf(&quot;add2 %d %d %d\n&quot;,p,q,aa[tot][2]);
}
bool cmp(int x,int y) {return dfn[x]&lt;dfn[y];}
void work()
{
	//printf(&quot;\n--------------------------------------------------------------------------------------------\n&quot;);
	static int a[NN],sta[NN],b[NN],fa[NN],dp_num[NN],dp_max[NN],dp_min[NN];
	static LL dp_sum[NN];
	static bool flag[NN];
	int m,i;
	read(m);
	for (i=1;i&lt;=m;i++) read(a[i]);
	sort(a+1,a+m+1,cmp);
	tot=0;
	int num=0;
	top=0;
	for (i=1;i&lt;=m;i++)
	{
		int x=a[i];
		b[++num]=x;
		flag[x]=true;
		if (top==0)
		{
			sta[++top]=x;
			continue;
		}
		int lca=shu.getlca(x,sta[top]);
		for (;deep[lca]&lt;deep[sta[top]];top--)
		{
			if (deep[lca]&gt;=deep[sta[top-1]])
			{
				fa[sta[top--]]=lca;
				if (lca!=sta[top])
				{
					sta[++top]=lca;
					b[++num]=lca;
					flag[lca]=false;
				}
				break;
			}
			fa[sta[top]]=sta[top-1];
		}
		if (sta[top]!=x) sta[++top]=x;
	}
	for (;top&gt;1;top--) fa[sta[top]]=sta[top-1];
	for (i=1;i&lt;=num;i++) o[b[i]]=0;
	for (i=1;i&lt;=num;i++)
		if (fa[b[i]]) addedge(fa[b[i]],b[i]);
	sort(b+1,b+num+1,cmp);
	//for (i=1;i&lt;=num;i++) printf(&quot;%d &quot;,b[i]);ln;
	LL ans_sum=0;
	int ans_min=inf,ans_max=0;
	for (i=num;i;i--)
	{
		int x=b[i];
		dp_sum[x]=0;
		dp_num[x]=flag[x]?1:0;
		dp_max[x]=flag[x]?0:-inf;
		dp_min[x]=flag[x]?0:inf;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			//printf(&quot;%d %d\n&quot;,x,y);
			ans_sum+=(LL)aa[p][2]*dp_num[x]*dp_num[y];
			ans_sum+=dp_sum[y]*dp_num[x]+dp_sum[x]*dp_num[y];
			ans_min=min(ans_min,dp_min[y]+dp_min[x]+aa[p][2]);
			ans_max=max(ans_max,dp_max[y]+dp_max[x]+aa[p][2]);
			dp_sum[x]+=dp_sum[y]+(LL)aa[p][2]*dp_num[y];
			dp_num[x]+=dp_num[y];
			dp_max[x]=max(dp_max[x],dp_max[y]+aa[p][2]);
			dp_min[x]=min(dp_min[x],dp_min[y]+aa[p][2]);
		}
		//printf(&quot;ans_sum=%I64d\n&quot;,ans_sum);
	}
	printf(&quot;%lld %d %d\n&quot;,ans_sum,ans_min,ans_max);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	shu.in();
	for (read(m);m;m--) work();
	return 0;
}<pre><h2>Problem3612</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int MM=100005;
int f[MM][13],n,K,mo;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int tes,i,j;
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d%d%d&quot;,&amp;n,&amp;K,&amp;mo);
		int mm=K*(n+n-K+1)/2;
		memset(f,0,sizeof(f));
		f[0][0]=1;
		for (i=1;i&lt;=mm;i++)
			for (j=1;j&lt;=K;j++)
			{
				int &amp;res=f[i][j];
				if (i&gt;=j) res=f[i-j][j-1]+f[i-j][j];
				if (i&gt;=n+1) res-=f[i-n-1][j-1];
				if (res&gt;mo) res-=mo;
				if (res&lt;0) res+=mo;
			}
		int ans=0;
		for (i=0;i&lt;=mm;i++)
			for (j=0;j&lt;=K;j++)
			{
				ans=(ans+f[i][j]*f[i][K-j])%mo;
				if (j&lt;K) ans=(ans+f[i][j]*f[i][K-1-j])%mo;
			}
		if (ans&lt;0) ans+=mo;
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem3626</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
#define mo 201314
#define NN 51000
#define lc(v) (v&lt;&lt;1)
#define rc(v) ((v&lt;&lt;1)+1)
#define inf 99999999
int size[NN],fa[NN],heavy[NN],deep[NN],pos[NN],which[NN],up[NN],ans[NN],o[NN],aa[NN*2][2],tag[NN*4],tsum[NN*4];
int n,m,tot,cnt,ww,ee;
struct ppt {int l,r,z;} ask[NN];
vector&lt;int&gt; a[NN];
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
void chaindfs1(int v)
{
	int tmp=0,mm=-inf;
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		deep[y]=deep[v]+1;
		fa[y]=v;
		chaindfs1(y);
		size[v]+=size[y];
		if (size[y]&gt;mm) mm=size[y],tmp=y;
	}
	heavy[v]=tmp;
}
void chaindfs2(int v)
{
	pos[v]=++cnt;
	which[cnt]=v;
	if (!heavy[v]) return;
	up[heavy[v]]=up[v];
	chaindfs2(heavy[v]);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||y==heavy[v]) continue;
		up[y]=y;
		chaindfs2(y);
	}
}
void pushdown(int v,int l,int r)
{
	if (!tag[v]) return;
	int x=lc(v),y=rc(v),mid=(l+r)&gt;&gt;1;;
	tsum[x]+=tag[v]*(mid-l);
	tag[x]+=tag[v];
	tsum[y]+=tag[v]*(r-mid);
	tag[y]+=tag[v];
	tag[v]=0;
}
void update(int v)
{
	tsum[v]=tsum[lc(v)]+tsum[rc(v)];
}
void build(int v,int l,int r)
{
	if (r-l==1)
	{
		tag[v]=0;
		tsum[v]=0;
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(lc(v),l,mid);
	build(rc(v),mid,r);
	update(v);
}
void change(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		tsum[v]+=r-l;
		tag[v]++;
		return;
	}
	pushdown(v,l,r);
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) change(lc(v),l,mid);
	if (ee&gt;mid) change(rc(v),mid,r);
	update(v);
}
void change0(int t)
{
	int x=t,y=1;
	while (up[x]!=up[y])
	{
		if (deep[up[x]]&lt;deep[up[y]]) swap(x,y);
		ww=pos[up[x]];
		ee=pos[x]+1;
		change(1,1,n+1);
		x=fa[up[x]];
	}
	if (deep[x]&lt;deep[y]) swap(x,y);
	ww=pos[y];
	ee=pos[x]+1;
	change(1,1,n+1);
}
int find(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tsum[v];
	pushdown(v,l,r);
	int mid=(l+r)&gt;&gt;1,res=0;
	if (ww&lt;mid) res=(res+find(lc(v),l,mid))%mo;
	if (ee&gt;mid) res=(res+find(rc(v),mid,r))%mo;
	return res;
}
int find0(int t)
{
	int x=t,y=1,res=0;
	while (up[x]!=up[y])
	{
		if (deep[up[x]]&lt;deep[up[y]]) swap(x,y);
		ww=pos[up[x]];
		ee=pos[x]+1;
		res=(res+find(1,1,n+1))%mo;
		x=fa[up[x]];
	}
	if (deep[x]&lt;deep[y]) swap(x,y);
	ww=pos[y];
	ee=pos[x]+1;
	res=(res+find(1,1,n+1))%mo;
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j,x;
	for (i=2;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);x++;
		addedge(i,x);
		addedge(x,i);
	}
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;ask[i].l,&amp;ask[i].r,&amp;ask[i].z);
		ask[i].l++;
		ask[i].r++;
		ask[i].z++;
		a[ask[i].l-1].push_back(i);
		a[ask[i].r].push_back(i);
	}
	chaindfs1(1);
	up[1]=1;
	chaindfs2(1);
	//printf(&quot;which: &quot;);for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,which[i]);printf(&quot;\n&quot;);
	build(1,1,n+1);
	for (i=1;i&lt;=n;i++)
	{
		change0(i);
		for (j=0;j&lt;a[i].size();j++)
		{
			int t=a[i][j];
			int tmp=find0(ask[t].z);
			if (i==ask[t].l-1) ans[t]-=tmp;
			else ans[t]+=tmp;
			//printf(&quot;%d\n&quot;,ans[t]);
		}
	}
	for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,(ans[i]%mo+mo)%mo);
	return 0;
}
<pre><h2>Problem3631</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=301111;
int o[NN],aa[NN*2][2],a[NN];
int n,m,tot=1;
inline void read(int &amp;x)
{
	x=0;bool f=false;char ch=getchar();
	while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar();
	if (ch=='-') f=true,ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
	if (f) x=-x;
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
struct splaynode
{
	int fa,s[2],key,tag;
	bool r,tag0;
	void rev()
	{
		tag0=!tag0;
		swap(s[0],s[1]);
	}
	void add(int x)
	{
		key+=x;
		tag+=x;
	}
} q[NN];
void bfs()
{
	static int que[NN];
	int head=0,tail=1;
	que[1]=1;
	while (head&lt;tail)
	{
		int x=que[++head];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==q[x].fa) continue;
			q[y].fa=x;
			que[++tail]=y;
		}
	}
}
inline void pushdown(int t)
{
	int x=q[t].s[0],y=q[t].s[1];
	if (q[t].tag0)
	{
		q[x].rev(),q[y].rev();
		q[t].tag0=false;
	}
	if (q[t].tag)
	{
		q[x].add(q[t].tag);
		q[y].add(q[t].tag);
		q[t].tag=0;
	}
}
void rotate(int t,int p)
{
	int y=q[t].fa;
	pushdown(y),pushdown(t);
	if (q[y].r) q[y].r=false,q[t].r=true;
	else if (y==q[q[y].fa].s[0]) q[q[y].fa].s[0]=t;
	else q[q[y].fa].s[1]=t;
	q[t].fa=q[y].fa;
	q[y].s[p^1]=q[t].s[p];
	if (q[t].s[p]) q[q[t].s[p]].fa=y;
	q[t].s[p]=y;
	q[y].fa=t;
}
void splay(int t)
{
	while (!q[t].r)
	{
		int y=q[t].fa;
		if (q[y].r)
			if (t==q[y].s[0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==q[q[y].fa].s[0])
				if (t==q[y].s[0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==q[y].s[1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
}
void access(int x)
{
	int y=0;
	for (;x;y=x,x=q[x].fa)
	{
		splay(x);
		pushdown(x);
		q[q[x].s[1]].r=true;
		q[x].s[1]=y;
		q[y].r=false;
	}
}
void makeroot(int x)
{
	access(x);
	splay(x);
	q[x].rev();
}
void debug(int t)
{
	if (t==0) return;
	debug(q[t].s[0]);
	printf(&quot;%d &quot;,t);
	debug(q[t].s[1]);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,x,y;
	read(n);
	for (i=1;i&lt;=n;i++) read(a[i]);
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y);
		addedge(x,y),addedge(y,x);
	}
	bfs();
	for (i=1;i&lt;=n;i++) q[i].r=true;
	for (i=1;i&lt;n;i++)
	{
		x=a[i],y=a[i+1];
		makeroot(x);
		access(y),splay(y);
		while (q[y].s[1]) y=q[y].s[1];
		splay(y);
		q[q[y].s[0]].add(1);
		splay(q[y].s[0]);
	}
	for (i=1;i&lt;=n;i++)
	{
		splay(i);
		printf(&quot;%d\n&quot;,q[i].key);
	}
	return 0;
}<pre><h2>Problem3632</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int deep[100],b[100][100],f[100],a[110][100],stack[100];
int n,i,j,ans,top,num;
void dfs(int deep,int num)
{
	int i,tmp,j;
	if (num==0)
	{
		if (deep&gt;ans) ans=deep;
		return;
	}
	for (i=1;i&lt;=num;i++)
	{
		if (num-i+1+deep&lt;=ans) return;
		if (deep+f[b[deep][i]]&lt;=ans) return;
		tmp=0;
		++top;
		stack[top]=i;
		for (j=i+1;j&lt;=num;j++)
			if (a[b[deep][i]][b[deep][j]]) b[deep+1][++tmp]=b[deep][j];
		dfs(deep+1,tmp);
		--top;
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int x,y;
	while (~scanf(&quot;%d%d&quot;,&amp;x,&amp;y)) a[x][y]=a[y][x]=1;
	f[n]=1;
	ans=0;
	for (i=n-1;i;i--)
	{
		num=0;
		top=1;
		stack[top]=i;
		for (j=i+1;j&lt;=n;j++) if (a[i][j]) b[1][++num]=j;
		dfs(1,num);
		f[i]=ans;
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem3632</h2><pre>//bzoj3632
//f[i]代表[i..n]组成的最大团的大小。当搜到deep层时，其实已经搜出来了一个大小为deep的团，此时q[deep]存的是与这deep个点都有边相连的节点，我们要从这些点里面选一个当做这个团的第deep+1个节点并更新q[deep+1]，根据数学归纳法，假如说选择是q[deep][j]，我们只需要判断q[deep][k](k&gt;j)与q[deep][j]是否有边相连即可，因为q[deep][k]一定与前deep个点有边相连。共两个剪枝：如果当前deep个节点加上剩下的所有没有枚举的节点仍然无法更新答案，就剪枝；如果当前deep个节点加上f[q[deep][j]]无法更新答案，则剪枝；
//f[i]并不是代表一定选第i个点，再选[i+1..n]时组成的最大团，而是代表[i..n]组成的最大团，i可以不选
//常用结论：1、最大团点的数量=补图中最大独立集点的数量   2、图的染色问题中，最少需要的颜色的数量=最大团点的数量

#include &lt;cstdio&gt;
using namespace std;
const int maxn=53;
bool a[maxn][maxn];
int f[maxn],q[maxn][maxn],n,ans;
void dfs(int deep,int num)
{
	if (num==0)
	{
		if (deep&gt;ans) ans=deep;
		return;
	}
	int tot,i,j,x;
	for (i=1;i&lt;=num;i++)
	{
		if (num-i+1+deep&lt;=ans) return;//第一个剪枝
		x=q[deep][i];
		if (deep+f[x]&lt;=ans) return;//第二个剪枝
		tot=0;
		for (j=i+1;j&lt;=num;j++) if (a[x][q[deep][j]]) q[deep+1][++tot]=q[deep][j];
		dfs(deep+1,tot);
	}
	return;
}
int main()
{
	//freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;lx.out&quot;,&quot;w&quot;,stdout);
	int i,j,x,y,num;
	scanf(&quot;%d&quot;,&amp;n);
	while (~scanf(&quot;%d%d&quot;,&amp;x,&amp;y)) a[x][y]=a[y][x]=true;
	for (i=n;i;i--)//主程序选择第一个节点时，为了更新f[i]，需从后往前枚举
	{
		num=0;
		for (j=i+1;j&lt;=n;j++) if (a[i][j]) q[1][++num]=j;
		dfs(1,num);
		f[i]=ans;
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3632</h2><pre>//bzoj3632
//f[i]代表[i..n]组成的最大团的大小。当搜到deep层时，其实已经搜出来了一个大小为deep的团，此时q[deep]存的是与这deep个点都有边相连的节点，我们要从这些点里面选一个当做这个团的第deep+1个节点并更新q[deep+1]，根据数学归纳法，假如说选择是q[deep][j]，我们只需要判断q[deep][k](k&gt;j)与q[deep][j]是否有边相连即可，因为q[deep][k]一定与前deep个点有边相连。共两个剪枝：如果当前deep个节点加上剩下的所有没有枚举的节点仍然无法更新答案，就剪枝；如果当前deep个节点加上f[q[deep][j]]无法更新答案，则剪枝；
//f[i]并不是代表一定选第i个点，再选[i+1..n]时组成的最大团，而是代表[i..n]组成的最大团，i可以不选
//常用结论：1、最大团点的数量=补图中最大独立集点的数量   2、图的染色问题中，最少需要的颜色的数量=最大团点的数量

#include &lt;cstdio&gt;
using namespace std;
const int maxn=53;
bool a[maxn][maxn];
int f[maxn],q[maxn][maxn],n,ans;
void dfs(int deep,int num)
{
	if (num==0)
	{
		if (deep&gt;ans) ans=deep;
		return;
	}
	int tot,i,j,x;
	for (i=1;i&lt;=num;i++)
	{
		//if (num-i+1+deep&lt;=ans) return;//第一个剪枝
		x=q[deep][i];
		if (deep+f[x]&lt;=ans) return;//第二个剪枝
		tot=0;
		for (j=i+1;j&lt;=num;j++) if (a[x][q[deep][j]]) q[deep+1][++tot]=q[deep][j];
		dfs(deep+1,tot);
	}
	return;
}
int main()
{
	//freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;lx.out&quot;,&quot;w&quot;,stdout);
	int i,j,x,y,num;
	scanf(&quot;%d&quot;,&amp;n);
	while (~scanf(&quot;%d%d&quot;,&amp;x,&amp;y)) a[x][y]=a[y][x]=true;
	for (i=n;i;i--)//主程序选择第一个节点时，为了更新f[i]，需从后往前枚举
	{
		num=0;
		for (j=i+1;j&lt;=n;j++) if (a[i][j]) q[1][++num]=j;
		dfs(1,num);
		f[i]=ans;
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3632</h2><pre>//bzoj3632
//f[i]代表[i..n]组成的最大团的大小。当搜到deep层时，其实已经搜出来了一个大小为deep的团，此时q[deep]存的是与这deep个点都有边相连的节点，我们要从这些点里面选一个当做这个团的第deep+1个节点并更新q[deep+1]，根据数学归纳法，假如说选择是q[deep][j]，我们只需要判断q[deep][k](k&gt;j)与q[deep][j]是否有边相连即可，因为q[deep][k]一定与前deep个点有边相连。共两个剪枝：如果当前deep个节点加上剩下的所有没有枚举的节点仍然无法更新答案，就剪枝；如果当前deep个节点加上f[q[deep][j]]无法更新答案，则剪枝；
//f[i]并不是代表一定选第i个点，再选[i+1..n]时组成的最大团，而是代表[i..n]组成的最大团，i可以不选
//常用结论：1、最大团点的数量=补图中最大独立集点的数量   2、图的染色问题中，最少需要的颜色的数量=最大团点的数量

#include &lt;cstdio&gt;
using namespace std;
const int maxn=53;
bool a[maxn][maxn];
int f[maxn],q[maxn][maxn],n,ans;
void dfs(int deep,int num)
{
	if (num==0)
	{
		if (deep&gt;ans) ans=deep;
		return;
	}
	int tot,i,j,x;
	for (i=1;i&lt;=num;i++)
	{
		if (num-i+1+deep&lt;=ans) return;//第一个剪枝
		x=q[deep][i];
		//if (deep+f[x]&lt;=ans) return;//第二个剪枝
		tot=0;
		for (j=i+1;j&lt;=num;j++) if (a[x][q[deep][j]]) q[deep+1][++tot]=q[deep][j];
		dfs(deep+1,tot);
	}
	return;
}
int main()
{
	//freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;lx.out&quot;,&quot;w&quot;,stdout);
	int i,j,x,y,num;
	scanf(&quot;%d&quot;,&amp;n);
	while (~scanf(&quot;%d%d&quot;,&amp;x,&amp;y)) a[x][y]=a[y][x]=true;
	for (i=n;i;i--)//主程序选择第一个节点时，为了更新f[i]，需从后往前枚举
	{
		num=0;
		for (j=i+1;j&lt;=n;j++) if (a[i][j]) q[1][++num]=j;
		dfs(1,num);
		f[i]=ans;
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3632</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int f[1000],a[1000][1000],b[1000][1000];
int n,ans,i,j,tmp,x,y;
void dfs(int deep,int num)
{
	if (num==0)
	{
		if (deep&gt;ans) ans=deep;
		return;
	}
	int i,j,x,tot;
	for (i=1;i&lt;=num;i++)
	{
		if (deep+num-i+1&lt;=ans) return;
		x=b[deep][i];
		if (deep+f[x]&lt;=ans) return;
		for (tot=0,j=i+1;j&lt;=num;j++)
			if (a[x][b[deep][j]]) b[deep+1][++tot]=b[deep][j];
		dfs(deep+1,tot);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	while (~scanf(&quot;%d%d&quot;,&amp;x,&amp;y)) a[x][y]=a[y][x]=1;
	for (ans=0,i=n;i;i--)
	{
		for (tmp=0,j=i+1;j&lt;=n;j++)
			if (a[i][j]) b[1][++tmp]=j;
		dfs(1,tmp);
		f[i]=ans;
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3632</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int a[100][100],b[100][100],f[100],n,ans;
void dfs(int t,int num)
{
	if (!num)
	{
		if (t&gt;ans) ans=t;
		return;
	}
	int i,x,k,j;
	for (i=1;i&lt;=num;i++)
	{
		if (t+num-i+1&lt;=ans) break;
		x=b[t][i];
		if (t+f[x]&lt;=ans) break;
		k=0;
		for (j=i+1;j&lt;=num;j++)
			if (a[x][b[t][j]]) b[t+1][++k]=b[t][j];
		dfs(t+1,k);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y,t;
	while (scanf(&quot;%d%d&quot;,&amp;x,&amp;y)!=EOF) a[x][y]=a[y][x]=1;
	for (i=n;i;i--)
	{
		t=0;
		for (int j=i+1;j&lt;=n;j++)
			if (a[i][j]) b[1][++t]=j;
		dfs(1,t);
		f[i]=ans;
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3632</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int NN=55;
int q[NN][NN],a[NN][NN],f[NN];
int n,ans;
void dfs(int t,int num)
{
	if (num==0)
	{
		if (t&gt;ans)ans=t;
		return;
	}
	for (int i=1;i&lt;=num;i++)
	{
		if (t+num-i+1&lt;=ans) break;
		int x=q[t][i];
		if (t+f[x]&lt;=ans) break;
		int k=0;
		for (int j=i+1;j&lt;=num;j++)
			if (a[x][q[t][j]]) q[t+1][++k]=q[t][j];
		dfs(t+1,k);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y,j;
	while (scanf(&quot;%d%d&quot;,&amp;x,&amp;y)!=EOF)
		a[x][y]=a[y][x]=1;
	ans=0;
	for (i=n;i;i--)
	{
		int t=0;
		for (j=i+1;j&lt;=n;j++)
			if (a[i][j]) q[1][++t]=j;
		dfs(1,t);
		f[i]=ans;
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3632</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int NN=55;
int a[NN][NN],q[NN][NN],f[NN];
int n,ans;
void dfs(int deep,int cnt)
{
	if (cnt==0)
	{
		if (deep&gt;ans) ans=deep;
		return;
	}
	for (int i=1;i&lt;=cnt;i++)
	{
		if (deep+cnt-i+1&lt;=ans) return;
		int x=q[deep][i],tot=0;
		if (deep+f[x]&lt;=ans) return;
		for (int j=i+1;j&lt;=cnt;j++)
			if (a[x][q[deep][j]]) q[deep+1][++tot]=q[deep][j];
		dfs(deep+1,tot);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j,x,y;
	while (scanf(&quot;%d%d&quot;,&amp;x,&amp;y)!=EOF)
		a[x][y]=a[y][x]=1;
	ans=0;
	for (i=n;i;i--)
	{
		int cnt=0;
		for (j=i+1;j&lt;=n;j++)
			if (a[i][j]) q[1][++cnt]=j;
		dfs(1,cnt);
		f[i]=ans;
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3632</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
LL a[55];
int n,id[55];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y;
	while (scanf(&quot;%d%d&quot;,&amp;x,&amp;y)!=EOF)
	{
		a[x]|=1ll&lt;&lt;(y-1);
		a[y]|=1ll&lt;&lt;(x-1);
	}
	int ans=0;
	for (i=1;i&lt;=n;i++) id[i]=i;
	for (int tt=1;tt&lt;=1000;tt++)
	{
		random_shuffle(id+1,id+n+1);
		LL now=(1ll&lt;&lt;n)-1;int res=0;
		for (i=1;i&lt;=n;i++)
		{
			int x=id[i];
			if (!(now&gt;&gt;(x-1)&amp;1)) continue;
			res++;
			now&amp;=a[x];
		}
		if (res&gt;ans) ans=res;
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3632</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
LL a[55];
int n,id[55];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y;
	while (scanf(&quot;%d%d&quot;,&amp;x,&amp;y)!=EOF)
	{
		a[x]|=1ll&lt;&lt;(y-1);
		a[y]|=1ll&lt;&lt;(x-1);
	}
	int ans=0;
	for (i=1;i&lt;=n;i++) id[i]=i;
	for (int tt=1;tt&lt;=100;tt++)
	{
		random_shuffle(id+1,id+n+1);
		LL now=(1ll&lt;&lt;n)-1;int res=0;
		for (i=1;i&lt;=n;i++)
		{
			int x=id[i];
			if (!(now&gt;&gt;(x-1)&amp;1)) continue;
			res++;
			now&amp;=a[x];
		}
		if (res&gt;ans) ans=res;
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3638</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef pair&lt;int,int&gt; pii;
#define inf 999999999
#define mp make_pair
#define fi first
#define se second
#define lc (v&lt;&lt;1)
#define rc (v&lt;&lt;1|1)
#define ln printf(&quot;\n&quot;)
#define _ if(qwe)
const int NN=100005;
int n,m,ww,ee,a[NN];
bool qwe=false;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar()) x=x*10+ch-'0';
	if (f) x=-x;
}
struct segnode
{
	int l,r,lmax,_lmax,lmin,_lmin,rmax,_rmax,rmin,_rmin,tmax,tmin,sum;
	pii _tmax,_tmin;
	int tag;
	void out()
	{
		printf(&quot;tag=%d\n&quot;,tag);
		printf(&quot;  tag=%s\n&quot;,tag==1?&quot;true&quot;:&quot;false&quot;);
		printf(&quot;  tmax=%d   [%d,%d]\n&quot;,tmax,_tmax.fi,_tmax.se);
		printf(&quot;  tmin=%d   [%d,%d]\n&quot;,tmin,_tmin.fi,_tmin.se);
	}
	void clear()
	{
		lmax=rmax=tmax=-inf;
		lmin=rmin=tmin=inf;
		sum=0;
	}
	void set(int x)
	{
		sum=x*(r-l);
		if (x&gt;=0)
		{
			lmax=rmax=tmax=x*(r-l);
			_lmax=r-1,_rmax=l,_tmax=mp(l,r-1);
			lmin=rmin=tmin=0;
			_lmin=l-1,_rmin=r,_tmin=mp(l,l-1);
		}
		else
		{
			lmax=rmax=tmax=0;
			_lmax=l-1,_rmax=r,_tmax=mp(l,l-1);
			lmin=rmin=tmin=x*(r-l);
			_lmin=r-1,_rmin=l,_tmin=mp(l,r-1);
		}
	}
	void qufu()
	{
		tag^=1;
		sum=-sum;
		int t;
		t=lmax,lmax=-lmin,lmin=-t;
		t=_lmax,_lmax=_lmin,_lmin=t;
		t=rmax,rmax=-rmin,rmin=-t;
		t=_rmax,_rmax=_rmin,_rmin=t;
		t=tmax,tmax=-tmin,tmin=-t;
		swap(_tmax,_tmin);
	}
	friend segnode operator +(segnode a,segnode b)
	{
		segnode res;
		res.tag=0;
		res.l=a.l,res.r=b.r;
		res.sum=a.sum+b.sum;
		if (a.lmax&gt;a.sum+b.lmax)
			res.lmax=a.lmax,res._lmax=a._lmax;
		else
			res.lmax=a.sum+b.lmax,res._lmax=b._lmax;
		if (a.lmin&lt;a.sum+b.lmin)
			res.lmin=a.lmin,res._lmin=a._lmin;
		else
			res.lmin=a.sum+b.lmin,res._lmin=b._lmin;
		if (b.rmax&gt;b.sum+a.rmax)
			res.rmax=b.rmax,res._rmax=b._rmax;
		else
			res.rmax=b.sum+a.rmax,res._rmax=a._rmax;
		if (b.rmin&lt;b.sum+a.rmin)
			res.rmin=b.rmin,res._rmin=b._rmin;
		else
			res.rmin=b.sum+a.rmin,res._rmin=a._rmin;
		if (a.tmax&gt;b.tmax)
			res.tmax=a.tmax,res._tmax=a._tmax;
		else
			res.tmax=b.tmax,res._tmax=b._tmax;
		if (a.rmax+b.lmax&gt;res.tmax)
			res.tmax=a.rmax+b.lmax,res._tmax=mp(a._rmax,b._lmax);
		if (a.tmin&lt;b.tmin)
			res.tmin=a.tmin,res._tmin=a._tmin;
		else
			res.tmin=b.tmin,res._tmin=b._tmin;
		if (a.rmin+b.lmin&lt;res.tmin)
			res.tmin=a.rmin+b.lmin,res._tmin=mp(a._rmin,b._lmin);
		return res;
	}
} t[NN*4],res;
inline void gogogo()
{
	//_ printf(&quot; special debug t[1]:\n&quot;);//printf(&quot;  &quot;);
	//_ t[1].out();
	//_ printf(&quot; end...\n&quot;);
}
void build(int v,int l,int r)
{
	t[v].l=l,t[v].r=r,t[v].tag=0;
	if (r-l==1)
	{
		t[v].set(a[l]);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(lc,l,mid);
	build(rc,mid,r);
	t[v]=t[lc]+t[rc];
}
inline void pushdown(int v)
{
	//printf(&quot;pushdown %d\n&quot;,v);
	if (t[v].tag==0) return;
	t[v].tag=0;
	t[lc].qufu(),t[rc].qufu();
}
void change0(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		//t[v].out();
		t[v].qufu();
		//_ printf(&quot;change0 %d %d %d %d %d\n&quot;,v,l,r,ww,ee);t[v].out();gogogo();
		return;
	}
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) change0(lc,l,mid);
	if (ee&gt;mid) change0(rc,mid,r);
	t[v]=t[lc]+t[rc];
	//_ printf(&quot;change0 %d %d %d %d %d\n&quot;,v,l,r,ww,ee);t[v].out();
	gogogo();
}
void change(int v,int l,int r,int i,int x)
{
	if (r-l==1)
	{
		t[v].set(x);
		return;
	}
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid) change(lc,l,mid,i,x);
	else change(rc,mid,r,i,x);
	t[v]=t[lc]+t[rc];
}
void find(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		res=res+t[v];
		return;
	}
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) find(lc,l,mid);
	if (ee&gt;mid) find(rc,mid,r);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);
	int i,x,y,L,R,K;
	for (i=1;i&lt;=n;i++) read(a[i]);
	build(1,1,n+1);
	//t[1].out();
	for (read(m);m;m--)
	{
		read(x);
		if (x==1)
		{
			read(L),read(R),read(K);
			int ans=0,top=0;
			static pii sta[NN];
			//qwe=true;
			for (i=1;i&lt;=K;i++)
			{
				//printf(&quot;\n------------------------------------------------------------------\n&quot;);t[1].out();
				ww=L,ee=R+1;
				res.clear();
				res.l=L,res.r=R;
				find(1,1,n+1);
				//printf(&quot;res:\n&quot;);res.out();
				if (res._tmax.fi&gt;res._tmax.se) break;
				ans+=res.tmax;
				sta[++top]=res._tmax;
				ww=res._tmax.fi,ee=res._tmax.se+1;
				//printf(&quot;ww=%d ee=%d\n&quot;,ww,ee);
				change0(1,1,n+1);
			}
			//qwe=false;ln;ln;
			printf(&quot;%d\n&quot;,ans);
			while (top)
			{
				ww=sta[top].fi,ee=sta[top].se+1;
				change0(1,1,n+1);
				top--;
			}
		}
		else
		{
			read(x),read(y);
			change(1,1,n+1,x,y);
		}
	}
	return 0;
}<pre><h2>Problem3638</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef pair&lt;int,int&gt; pii;
#define inf 999999999
#define mp make_pair
#define fi first
#define se second
#define lc (v&lt;&lt;1)
#define rc (v&lt;&lt;1|1)
const int NN=100005;
int n,m,ww,ee,a[NN];
bool qwe=false;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar()) x=x*10+ch-'0';
	if (f) x=-x;
}
struct segnode
{
	int l,r,lmax,_lmax,lmin,_lmin,rmax,_rmax,rmin,_rmin,tmax,tmin,sum;
	pii _tmax,_tmin;
	bool tag;
	void clear()
	{
		lmax=rmax=tmax=-inf;
		lmin=rmin=tmin=inf;
		sum=0;
	}
	void set(int x)
	{
		sum=x*(r-l);
		if (x&gt;=0)
		{
			lmax=rmax=tmax=x*(r-l);
			_lmax=r-1,_rmax=l,_tmax=mp(l,r-1);
			lmin=rmin=tmin=0;
			_lmin=l-1,_rmin=r,_tmin=mp(l,l-1);
		}
		else
		{
			lmax=rmax=tmax=0;
			_lmax=l-1,_rmax=r,_tmax=mp(l,l-1);
			lmin=rmin=tmin=x*(r-l);
			_lmin=r-1,_rmin=l,_tmin=mp(l,r-1);
		}
	}
	void qufu()
	{
		tag=!tag;
		sum=-sum;
		int t;
		t=lmax,lmax=-lmin,lmin=-t;
		t=_lmax,_lmax=_lmin,_lmin=t;
		t=rmax,rmax=-rmin,rmin=-t;
		t=_rmax,_rmax=_rmin,_rmin=t;
		t=tmax,tmax=-tmin,tmin=-t;
		swap(_tmax,_tmin);
	}
	friend segnode operator +(segnode a,segnode b)
	{
		segnode res;
		res.tag=0;
		res.l=a.l,res.r=b.r;
		res.sum=a.sum+b.sum;
		if (a.lmax&gt;a.sum+b.lmax)
			res.lmax=a.lmax,res._lmax=a._lmax;
		else
			res.lmax=a.sum+b.lmax,res._lmax=b._lmax;
		if (a.lmin&lt;a.sum+b.lmin)
			res.lmin=a.lmin,res._lmin=a._lmin;
		else
			res.lmin=a.sum+b.lmin,res._lmin=b._lmin;
		if (b.rmax&gt;b.sum+a.rmax)
			res.rmax=b.rmax,res._rmax=b._rmax;
		else
			res.rmax=b.sum+a.rmax,res._rmax=a._rmax;
		if (b.rmin&lt;b.sum+a.rmin)
			res.rmin=b.rmin,res._rmin=b._rmin;
		else
			res.rmin=b.sum+a.rmin,res._rmin=a._rmin;
		if (a.tmax&gt;b.tmax)
			res.tmax=a.tmax,res._tmax=a._tmax;
		else
			res.tmax=b.tmax,res._tmax=b._tmax;
		if (a.rmax+b.lmax&gt;res.tmax)
			res.tmax=a.rmax+b.lmax,res._tmax=mp(a._rmax,b._lmax);
		if (a.tmin&lt;b.tmin)
			res.tmin=a.tmin,res._tmin=a._tmin;
		else
			res.tmin=b.tmin,res._tmin=b._tmin;
		if (a.rmin+b.lmin&lt;res.tmin)
			res.tmin=a.rmin+b.lmin,res._tmin=mp(a._rmin,b._lmin);
		return res;
	}
} t[NN*4],res;
void build(int v,int l,int r)
{
	t[v].l=l,t[v].r=r,t[v].tag=0;
	if (r-l==1)
	{
		t[v].set(a[l]);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(lc,l,mid);
	build(rc,mid,r);
	t[v]=t[lc]+t[rc];
}
inline void pushdown(int v)
{
	if (!t[v].tag) return;
	t[v].tag=false;
	t[lc].qufu(),t[rc].qufu();
}
void change0(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		t[v].qufu();
		return;
	}
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) change0(lc,l,mid);
	if (ee&gt;mid) change0(rc,mid,r);
	t[v]=t[lc]+t[rc];
}
void change(int v,int l,int r,int i,int x)
{
	if (r-l==1)
	{
		t[v].set(x);
		return;
	}
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid) change(lc,l,mid,i,x);
	else change(rc,mid,r,i,x);
	t[v]=t[lc]+t[rc];
}
void find(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		res=res+t[v];
		return;
	}
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) find(lc,l,mid);
	if (ee&gt;mid) find(rc,mid,r);
}
int main()
{
	read(n);
	int i,x,y,L,R,K;
	for (i=1;i&lt;=n;i++) read(a[i]);
	build(1,1,n+1);
	for (read(m);m;m--)
	{
		read(x);
		if (x==1)
		{
			read(L),read(R),read(K);
			int ans=0,top=0;
			static pii sta[NN];
			for (i=1;i&lt;=K;i++)
			{
				ww=L,ee=R+1;
				res.clear();
				res.l=L,res.r=R;
				find(1,1,n+1);
				if (res._tmax.fi&gt;res._tmax.se) break;
				ans+=res.tmax;
				sta[++top]=res._tmax;
				ww=res._tmax.fi,ee=res._tmax.se+1;
				change0(1,1,n+1);
			}
			printf(&quot;%d\n&quot;,ans);
			while (top)
			{
				ww=sta[top].fi,ee=sta[top].se+1;
				change0(1,1,n+1);
				top--;
			}
		}
		else
		{
			read(x),read(y);
			change(1,1,n+1,x,y);
		}
	}
	return 0;
}<pre><h2>Problem3638</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
int n,m,op,l,r,k,a[100005];
vector&lt;pair&lt;int,int&gt; &gt;Q;
struct data{
	int lx,rx,mx,sum,lp,rp,p1,p2;
	void init(int l,int val){lp=rp=p1=p2=l,lx=rx=mx=sum=val;}
	friend data operator + (data a,data b){
		data c;
		c.sum=a.sum+b.sum;
		c.lx=a.lx,c.lp=a.lp;
		if(a.sum+b.lx&gt;c.lx)c.lx=a.sum+b.lx,c.lp=b.lp;
		c.rx=b.rx,c.rp=b.rp;
		if(b.sum+a.rx&gt;c.rx)c.rx=b.sum+a.rx,c.rp=a.rp;
		c.mx=a.rx+b.lx,c.p1=a.rp,c.p2=b.lp;
		if(c.mx&lt;a.mx)c.mx=a.mx,c.p1=a.p1,c.p2=a.p2;
		if(c.mx&lt;b.mx)c.mx=b.mx,c.p1=b.p1,c.p2=b.p2;
		return c;
	}
};
struct Seg{
	int l,r,a,b;
	bool flag;
	data mn,mx;
	void init(int val){
		mn.init(l,-val);
		mx.init(l,val);
	}
}t[400005];
void pushdown(int k){
	if(t[k].l==t[k].r)return;
	if(t[k].flag){
		swap(t[k&lt;&lt;1].mn,t[k&lt;&lt;1].mx);
		swap(t[k&lt;&lt;1|1].mn,t[k&lt;&lt;1|1].mx);
		t[k&lt;&lt;1].flag^=1,t[k&lt;&lt;1|1].flag^=1,t[k].flag^=1;
	}
}
void update(int k){
	t[k].mn=t[k&lt;&lt;1].mn+t[k&lt;&lt;1|1].mn;
	t[k].mx=t[k&lt;&lt;1].mx+t[k&lt;&lt;1|1].mx;
}
void build(int l,int r,int k){
	t[k].l=l,t[k].r=r;
	if(l==r){
		t[k].init(a[l]);
		return;
	}
	int mid=l+r&gt;&gt;1;
	build(l,mid,k&lt;&lt;1);
	build(mid+1,r,k&lt;&lt;1|1);
	update(k);
}
void rever(int x,int y,int k){
	pushdown(k);
	int l=t[k].l,r=t[k].r,mid=l+r&gt;&gt;1;
	if(l==x&amp;&amp;y==r){
		swap(t[k].mn,t[k].mx);
		t[k].flag^=1;
		return;
	}
	if(y&lt;=mid)rever(x,y,k&lt;&lt;1);
	else if(x&gt;mid)rever(x,y,k&lt;&lt;1|1);
	else rever(x,mid,k&lt;&lt;1),rever(mid+1,y,k&lt;&lt;1|1);
	update(k);
}
data Query(int x,int y,int k){
	pushdown(k);
	int l=t[k].l,r=t[k].r,mid=l+r&gt;&gt;1;
	if(l==x&amp;&amp;y==r)return t[k].mx;
	if(y&lt;=mid)return Query(x,y,k&lt;&lt;1);
	if(x&gt;mid)return Query(x,y,k&lt;&lt;1|1);
	return Query(x,mid,k&lt;&lt;1)+Query(mid+1,y,k&lt;&lt;1|1);
}
void Solve(int l,int r,int k){
	int ans=0;
	Q.clear();
	while(k--){
		data t=Query(l,r,1);
		if(t.mx&gt;0)ans+=t.mx;
		else break;
		rever(t.p1,t.p2,1);
		Q.push_back(make_pair(t.p1,t.p2));
	}
	for(int i=Q.size()-1;~i;i--){
		rever(Q[i].first,Q[i].second,1);
	}
	printf(&quot;%d\n&quot;,ans);
}
void change(int pos,int val,int k){
	pushdown(k);
	int l=t[k].l,r=t[k].r,mid=l+r&gt;&gt;1;
	if(l==r){
		t[k].init(val);
		return;
	}
	if(pos&lt;=mid)change(pos,val,k&lt;&lt;1);
	else change(pos,val,k&lt;&lt;1|1);
	update(k);
}
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]);
	build(1,n,1);
	scanf(&quot;%d&quot;,&amp;m);
	while(m--){
		scanf(&quot;%d%d%d&quot;,&amp;op,&amp;l,&amp;r);
		if(op-1)change(l,r,1);
		else scanf(&quot;%d&quot;,&amp;k),Solve(l,r,k);
	}
}
<pre><h2>Problem3640</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 199
#define MM 5555
#define HP 11111
#define LD double
#define DD double
const DD eps=1e-9;
int aa[MM*2][2],o[NN],lose[NN],du[NN];
int n,m,tot,hp,mj,i,j,k,deep;
LD a[NN][NN],tmp,f[HP][NN];
struct record
{
	int mj;
	LD tmp[NN];
} b[NN];
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;hp);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;lose[i]);
	for (tot=1,i=1;i&lt;=m;i++)
	{
		int x,y;
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		if (x==y)
		{
			addedge(x,y);
			du[x]++;
		}
		else
		{
			addedge(x,y);
			addedge(y,x);
			du[x]++,du[y]++;
		}
	}
	//printf(&quot;\n-----------------------------\n&quot;);
	//printf(&quot;初始方程组：\n&quot;);
	for (i=1;i&lt;=n;i++)
	{
		a[i][i]=1;
		if (i==n) continue;
		for (int p=o[i];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (lose[y]!=0) continue;
			a[i][y]-=1.0/du[i];
		}
		//for (j=1;j&lt;=n;j++) printf(&quot;%.3f &quot;,a[i][j]);printf(&quot;\n&quot;);
	}
	for (i=1;i&lt;n;i++)
	{
		int mj=i;
		tmp=fabs(a[i][i]);
		for (j=i+1;j&lt;=n;j++)
			if (fabs(a[j][i])-tmp&gt;eps) tmp=fabs(a[j][i]),mj=j;
		b[i].mj=mj;
		for (j=i;j&lt;=n;j++) swap(a[i][j],a[mj][j]);
		b[i].tmp[0]=tmp;
		if (tmp&lt;eps) continue;
		for (j=i+1;j&lt;=n;j++)
		{
			tmp=a[j][i]/a[i][i];
			b[i].tmp[j]=tmp;
			for (k=i;k&lt;=n;k++) a[j][k]=a[i][k]*tmp-a[j][k];
		}
		//printf(&quot;\n&quot;);for(int ii=1;ii&lt;=n;ii++){for(int jj=1;jj&lt;=n;jj++)printf(&quot;%.3f &quot;,a[ii][jj]);printf(&quot;\n&quot;);}
	}
	//printf(&quot;\n消完元后：\n&quot;);for(int ii=1;ii&lt;=n;ii++){for(int jj=1;jj&lt;=n;jj++)printf(&quot;%.3f &quot;,a[ii][jj]);printf(&quot;\n&quot;);}
	//printf(&quot;\nrecord: \n&quot;);for (i=1,printf(&quot;%d: &quot;,i);i&lt;n;printf(&quot;\n%d: &quot;,++i)){printf(&quot;mj=%d  &quot;,b[i].mj);printf(&quot;zy=%.3f  &quot;,b[i].tmp[0]);
		//for (j=1;j&lt;=n;j++) printf(&quot;%.3f &quot;,b[i].tmp[j]);}
	for (deep=1;deep&lt;=hp;deep++)
	{
		//printf(&quot;\n\n------- when deep==%d ---------------------------\n&quot;,deep);
		for (i=1;i&lt;=n;i++)
		{
			if (i==n)
			{
				a[i][n+1]=1;
				continue;
			}
			a[i][n+1]=0;
			for (int p=o[i];p;p=aa[p][0])
			{
				int y=aa[p][1];
				if (lose[y]==0) continue;
				if (deep-lose[y]&gt;0&amp;&amp;lose[y]) a[i][n+1]+=f[deep-lose[y]][y]/du[i];
			}
		}
		//for(int ii=1;ii&lt;=n;ii++){for(int jj=1;jj&lt;=n+1;jj++)printf(&quot;%.3f &quot;,a[ii][jj]);printf(&quot;\n&quot;);}
		for (i=1;i&lt;=n-1;i++)
		{
			record tt=b[i];
			mj=tt.mj;
			swap(a[i][n+1],a[mj][n+1]);
			if (b[i].tmp[0]&lt;eps) continue;
			for (j=i+1;j&lt;=n;j++)
			{
				tmp=b[i].tmp[j];
				a[j][n+1]=a[i][n+1]*tmp-a[j][n+1];
			}
		}
		//printf(&quot;\n&quot;);for(int ii=1;ii&lt;=n;ii++){for(int jj=1;jj&lt;=n+1;jj++)printf(&quot;%.3f &quot;,a[ii][jj]);printf(&quot;\n&quot;);}
		f[deep][n]=a[n][n+1]/a[n][n];
		for (i=n-1;i;i--)
		{
			tmp=0;
			for (j=i+1;j&lt;=n;j++) tmp+=a[i][j]*f[deep][j];
			//printf(&quot;%.3f\n&quot;,a[i][i]);
			if (fabs(a[i][i])&lt;eps) continue;
			f[deep][i]=(a[i][n+1]-tmp)/a[i][i];
		}
		//printf(&quot;\nf[deep][i]: &quot;);for (i=1;i&lt;=n;i++) printf(&quot;%.3f &quot;,f[deep][i]);printf(&quot;\n&quot;);
	}
	//printf(&quot;\n\n\n&quot;);
	printf(&quot;%.8f\n&quot;,(DD)f[hp][1]);
	//freopen(&quot;CON&quot;,&quot;r&quot;,stdin);getchar();
	return 0;
}
<pre><h2>Problem3640</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 199
#define MM 5555
#define HP 11111
#define LD double
#define DD double
const DD eps=1e-10;
int aa[MM*2][2],o[NN],lose[NN],du[NN];
int n,m,tot,hp,mj,i,j,k,deep;
LD a[NN][NN],tmp,f[HP][NN];
struct record
{
	int mj;
	LD tmp[NN];
} b[NN];
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;hp);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;lose[i]);
	for (tot=1,i=1;i&lt;=m;i++)
	{
		int x,y;
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		if (x==y)
		{
			addedge(x,y);
			du[x]++;
		}
		else
		{
			addedge(x,y);
			addedge(y,x);
			du[x]++,du[y]++;
		}
	}
	//printf(&quot;\n-----------------------------\n&quot;);
	//printf(&quot;初始方程组：\n&quot;);
	for (i=1;i&lt;=n;i++)
	{
		a[i][i]=1;
		if (i==n) continue;
		for (int p=o[i];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (lose[y]!=0) continue;
			a[i][y]-=1.0/du[i];
		}
		//for (j=1;j&lt;=n;j++) printf(&quot;%.3f &quot;,a[i][j]);printf(&quot;\n&quot;);
	}
	for (i=1;i&lt;n;i++)
	{
		int mj=i;
		tmp=fabs(a[i][i]);
		for (j=i+1;j&lt;=n;j++)
			if (fabs(a[j][i])-tmp&gt;eps) tmp=fabs(a[j][i]),mj=j;
		b[i].mj=mj;
		for (j=i;j&lt;=n;j++) swap(a[i][j],a[mj][j]);
		b[i].tmp[0]=tmp;
		if (tmp&lt;eps) continue;
		for (j=i+1;j&lt;=n;j++)
		{
			tmp=a[j][i]/a[i][i];
			b[i].tmp[j]=tmp;
			for (k=i;k&lt;=n;k++) a[j][k]=a[i][k]*tmp-a[j][k];
		}
		//printf(&quot;\n&quot;);for(int ii=1;ii&lt;=n;ii++){for(int jj=1;jj&lt;=n;jj++)printf(&quot;%.3f &quot;,a[ii][jj]);printf(&quot;\n&quot;);}
	}
	//printf(&quot;\n消完元后：\n&quot;);for(int ii=1;ii&lt;=n;ii++){for(int jj=1;jj&lt;=n;jj++)printf(&quot;%.3f &quot;,a[ii][jj]);printf(&quot;\n&quot;);}
	//printf(&quot;\nrecord: \n&quot;);for (i=1,printf(&quot;%d: &quot;,i);i&lt;n;printf(&quot;\n%d: &quot;,++i)){printf(&quot;mj=%d  &quot;,b[i].mj);printf(&quot;zy=%.3f  &quot;,b[i].tmp[0]);
		//for (j=1;j&lt;=n;j++) printf(&quot;%.3f &quot;,b[i].tmp[j]);}
	for (deep=1;deep&lt;=hp;deep++)
	{
		//printf(&quot;\n\n------- when deep==%d ---------------------------\n&quot;,deep);
		for (i=1;i&lt;=n;i++)
		{
			if (i==n)
			{
				a[i][n+1]=1;
				continue;
			}
			a[i][n+1]=0;
			for (int p=o[i];p;p=aa[p][0])
			{
				int y=aa[p][1];
				if (lose[y]==0) continue;
				if (deep-lose[y]&gt;0&amp;&amp;lose[y]) a[i][n+1]+=f[deep-lose[y]][y]/du[i];
			}
		}
		//for(int ii=1;ii&lt;=n;ii++){for(int jj=1;jj&lt;=n+1;jj++)printf(&quot;%.3f &quot;,a[ii][jj]);printf(&quot;\n&quot;);}
		for (i=1;i&lt;=n-1;i++)
		{
			record tt=b[i];
			mj=tt.mj;
			swap(a[i][n+1],a[mj][n+1]);
			if (b[i].tmp[0]&lt;eps) continue;
			for (j=i+1;j&lt;=n;j++)
			{
				tmp=b[i].tmp[j];
				a[j][n+1]=a[i][n+1]*tmp-a[j][n+1];
			}
		}
		//printf(&quot;\n&quot;);for(int ii=1;ii&lt;=n;ii++){for(int jj=1;jj&lt;=n+1;jj++)printf(&quot;%.3f &quot;,a[ii][jj]);printf(&quot;\n&quot;);}
		f[deep][n]=a[n][n+1]/a[n][n];
		for (i=n-1;i;i--)
		{
			tmp=0;
			for (j=i+1;j&lt;=n;j++) tmp+=a[i][j]*f[deep][j];
			//printf(&quot;%.3f\n&quot;,a[i][i]);
			if (fabs(a[i][i])&lt;eps) continue;
			f[deep][i]=(a[i][n+1]-tmp)/a[i][i];
		}
		//printf(&quot;\nf[deep][i]: &quot;);for (i=1;i&lt;=n;i++) printf(&quot;%.3f &quot;,f[deep][i]);printf(&quot;\n&quot;);
	}
	//printf(&quot;\n\n\n&quot;);
	printf(&quot;%.8f\n&quot;,(DD)f[hp][1]);
	//freopen(&quot;CON&quot;,&quot;r&quot;,stdin);getchar();
	return 0;
}
<pre><h2>Problem3665</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define LL long long
#define limit 99999999999999999ll
int tes;
LL mo,phi;
LL getphi(LL n)
{
	LL res=1,N=n;
	for (LL i=2;i*i&lt;=N;i++)
		if (n%i==0)
		{
			res=res*(i-1);
			n/=i;
			for (;n%i==0;n/=i) res=res*i;
		}
	if (n&gt;1) res=res*(n-1);
	return res;
}
LL safe(LL a,LL b,LL c)
{
	LL res=0;
	for (a%=c;b;b&gt;&gt;=1)
	{
		if (b&amp;1) res=res+a;
		if (res&gt;limit) res%=c;
		a=a+a;
		if (a&gt;limit) a%=c;
	}
	return res%c;
}
LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (a%=c;b;b&gt;&gt;=1,a=safe(a,a,c)) if (b&amp;1) res=safe(res,a,c);
	return res;
}
struct matrix
{
	LL m[4][4];
	void clear() {memset(m,0,sizeof(m));}
	matrix() {memset(m,0,sizeof(m));}
	friend matrix operator *(matrix a,matrix b)
	{
		matrix c;
		int i,j,k;
		for (k=1;k&lt;=3;k++)
			for (i=1;i&lt;=3;i++)
				for (j=1;j&lt;=3;j++)
					c.m[i][j]=(c.m[i][j]+safe(a.m[i][k],b.m[k][j],phi))%phi;
		return c;
	}
} a,ans,res;
int main()
{
	//freopen(&quot;0.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	//freopen(&quot;3665.in&quot;,&quot;r&quot;,stdin);freopen(&quot;3665.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%lld&quot;,&amp;tes,&amp;mo);
	phi=getphi(mo);
	for (;tes;tes--)
	{
		LL M,A0,K,N;
		scanf(&quot;%lld%lld%lld%lld&quot;,&amp;M,&amp;A0,&amp;K,&amp;N);
		LL x=ksm(M,N,phi);
		x=ksm(A0,x,mo);
		a.clear();
		a.m[1][1]=M,a.m[2][1]=a.m[2][2]=a.m[3][2]=a.m[3][3]=1;
		res.clear();
		res.m[1][1]=res.m[2][2]=res.m[3][3]=1;
		for (;N;N&gt;&gt;=1,a=a*a) if (N&amp;1) res=res*a;
		ans.clear();
		ans.m[1][1]=0,ans.m[1][2]=ans.m[1][3]=1;
		ans=ans*res;
		x=safe(x,ksm(K,ans.m[1][1],mo),mo);
		printf(&quot;%lld\n&quot;,x);
	}
	return 0;
}
<pre><h2>Problem3665</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define LL long long
#define limit 999999999999999999ll
int tes;
LL mo,phi;
LL getphi(LL n)
{
	LL res=1,N=n;
	for (LL i=2;i*i&lt;=N;i++)
		if (n%i==0)
		{
			res=res*(i-1);
			n/=i;
			for (;n%i==0;n/=i) res=res*i;
		}
	if (n&gt;1) res=res*(n-1);
	return res;
}
LL safe(LL a,LL b,LL c)
{
	LL res=0;
	for (a%=c;b;b&gt;&gt;=1)
	{
		if (b&amp;1)
		{
			res=res+a;
			if (res&gt;limit) res%=c;
		}
		a=a+a;
		if (a&gt;limit) a%=c;
	}
	return res&lt;c?res:res%c;
}
LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (a%=c;b;b&gt;&gt;=1,a=safe(a,a,c)) if (b&amp;1) res=safe(res,a,c);
	return res;
}
struct matrix
{
	LL m[3][3];
	void clear() {memset(m,0,sizeof(m));}
	friend matrix operator *(matrix a,matrix b)
	{
		matrix c;
		c.clear();
		int i,j,k;
		for (i=0;i&lt;3;i++)
			for (j=0;j&lt;3;j++)
			{
				for (k=0;k&lt;3;k++)
					c.m[i][j]+=safe(a.m[i][k],b.m[k][j],phi);
				c.m[i][j]%=phi;
			}
		return c;
	}
} a,ans,res;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	//freopen(&quot;3665.in&quot;,&quot;r&quot;,stdin);freopen(&quot;3665.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%lld&quot;,&amp;tes,&amp;mo);
	phi=getphi(mo);
	for (;tes;tes--)
	{
		LL M,A0,K,N;
		scanf(&quot;%lld%lld%lld%lld&quot;,&amp;M,&amp;A0,&amp;K,&amp;N);
		LL x=ksm(M,N,phi);
		x=ksm(A0,x,mo);
		a.clear();
		a.m[0][0]=M,a.m[1][0]=a.m[1][1]=a.m[2][1]=a.m[2][2]=1;
		res.clear();
		res.m[0][0]=res.m[1][1]=res.m[2][2]=1;
		for (;N;N&gt;&gt;=1,a=a*a) if (N&amp;1) res=res*a;
		ans.clear();
		ans.m[0][1]=ans.m[0][2]=1;
		ans=ans*res;
		x=safe(x,ksm(K,ans.m[0][0],mo),mo);
		printf(&quot;%lld\n&quot;,x);
	}
	return 0;
}
<pre><h2>Problem3665</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define LL long long
#define limit 999999999999999999ll
int tes;
LL mo,phi;
void getphi(LL n)
{
	phi=1;
	for (LL i=2;i*i&lt;=n;i++)
		if (n%i==0)
		{
			phi=phi*(i-1);
			n/=i;
			for (;n%i==0;n/=i) phi=phi*i;
		}
	if (n&gt;1) phi=phi*(n-1);
}
LL safe(LL a,LL b,LL c)
{
	LL res=0;
	for (;b;b&gt;&gt;=1)
	{
		if (b&amp;1)
		{
			res=res+a;
			if (res&gt;limit) res%=c;
		}
		a=a+a;
		if (a&gt;limit) a%=c;
	}
	return res&lt;c?res:res%c;
}
LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (;b;b&gt;&gt;=1,a=safe(a,a,c)) if (b&amp;1) res=safe(res,a,c);
	return res;
}
struct matrix
{
	LL m[3][3];
	void clear() {memset(m,0,sizeof(m));}
	friend matrix operator *(matrix a,matrix b)
	{
		matrix c;
		c.clear();
		int i,j,k;
		for (i=0;i&lt;3;i++)
			for (j=0;j&lt;3;j++)
			{
				for (k=0;k&lt;3;k++)
					c.m[i][j]+=safe(a.m[i][k],b.m[k][j],phi);
				if (c.m[i][j]&gt;=phi) c.m[i][j]%=phi;
			}
		return c;
	}
};
int main()
{
	scanf(&quot;%d%lld&quot;,&amp;tes,&amp;mo);
	getphi(mo);
	for (;tes;tes--)
	{
		LL M,A0,K,N;
		scanf(&quot;%lld%lld%lld%lld&quot;,&amp;M,&amp;A0,&amp;K,&amp;N);
		LL x=ksm(A0,ksm(M,N,phi),mo);
		matrix a,ans;
		a.clear();
		a.m[0][0]=M,a.m[1][0]=a.m[1][1]=a.m[2][1]=a.m[2][2]=1;
		ans.clear();
		ans.m[0][1]=ans.m[0][2]=1;
		for (;N;N&gt;&gt;=1,a=a*a) if (N&amp;1) ans=ans*a;
		x=safe(x,ksm(K,ans.m[0][0],mo),mo);
		printf(&quot;%lld\n&quot;,x);
	}
	return 0;
}<pre><h2>Problem3665</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define LL long long
#define limit 999999999999999999ll
int tes;
LL mo,phi;
void getphi(LL n)
{
	phi=1;
	for (LL i=2;i*i&lt;=n;i++)
		if (n%i==0)
		{
			phi=phi*(i-1);
			n/=i;
			for (;n%i==0;n/=i) phi=phi*i;
		}
	if (n&gt;1) phi=phi*(n-1);
}
LL safe(LL a,LL b,LL c)
{
	LL res=0;
	for (;b;b&gt;&gt;=1)
	{
		if (b&amp;1)
		{
			res=res+a;
			if (res&gt;limit) res%=c;
		}
		a=a+a;
		if (a&gt;limit) a%=c;
	}
	return res&lt;c?res:res%c;
}
LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (;b;b&gt;&gt;=1,a=safe(a,a,c)) if (b&amp;1) res=safe(res,a,c);
	return res;
}
struct matrix
{
	LL m[3][3];
	void clear() {memset(m,0,sizeof(m));}
	friend matrix operator *(matrix a,matrix b)
	{
		matrix c;
		c.clear();
		int i,j,k;
		LL *x=&amp;c.m[0][0],*y=&amp;a.m[0][0],*z=&amp;b.m[0][0];
		for (i=0;i&lt;3;i++,y+=3,z-=3)
			for (j=0;j&lt;3;j++,x++,y-=3,z-=8)
			{
				for (k=0;k&lt;3;k++,y++,z+=3)
					*x+=safe(*y,*z,phi);
				if (*x&gt;=phi) *x%=phi;
			}
		return c;
	}
};
int main()
{
	scanf(&quot;%d%lld&quot;,&amp;tes,&amp;mo);
	getphi(mo);
	for (;tes;tes--)
	{
		LL M,A0,K,N;
		scanf(&quot;%lld%lld%lld%lld&quot;,&amp;M,&amp;A0,&amp;K,&amp;N);
		LL x=ksm(A0,ksm(M,N,phi),mo);
		matrix a,ans;
		a.clear();
		a.m[0][0]=M,a.m[1][0]=a.m[1][1]=a.m[2][1]=a.m[2][2]=1;
		ans.clear();
		ans.m[0][1]=ans.m[0][2]=1;
		for (;N;N&gt;&gt;=1,a=a*a) if (N&amp;1) ans=ans*a;
		x=safe(x,ksm(K,ans.m[0][0],mo),mo);
		printf(&quot;%lld\n&quot;,x);
	}
	return 0;
}
<pre><h2>Problem3668</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int n,m;
char s[5];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d\n&quot;,&amp;n,&amp;m);
	int k1=(1&lt;&lt;30)-1,k2=0,i,x;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s %d\n&quot;,s+1,&amp;x);
		//printf(&quot;%s\n&quot;,s+1);
		if (s[1]=='A') k1&amp;=x,k2&amp;=x;
		else if (s[1]=='O') k1|=x,k2|=x;
		else k1^=x,k2^=x;
	}
	//printf(&quot;k1=%d k2=%d\n&quot;,k1,k2);
	bool flag=false;
	int ans=0;
	for (i=30;i;i--)
	{
		int x1=(k1&gt;&gt;(i-1))&amp;1,x2=(k2&gt;&gt;(i-1))&amp;1;
		int t=(m&gt;&gt;(i-1))&amp;1;
		if (x1==0&amp;&amp;x2==0)
		{
			if (t==1) flag=true;
		}
		else if (x1==1&amp;&amp;x2==0)
		{
			if (t==0)
			{
				if (flag) ans+=(1&lt;&lt;(i-1));
				else continue;
			}
			else ans+=(1&lt;&lt;(i-1));
		}
		else if (x1==0&amp;&amp;x2==1)
		{
			if (t==0) ans+=(1&lt;&lt;(i-1));
			else flag=true,ans+=(1&lt;&lt;(i-1));
		}
		else
		{
			ans+=(1&lt;&lt;(i-1));
			if (t==1) flag=true;
		}
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3669</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 199999999
#define NN 500111
#define MM 1001111
int fa[NN*2],o[NN],aa[NN*2][2],tag[NN*2],son[NN*2][2],key[NN*2],maxid[NN*2],which[NN*2];
int n,m,tot,TTT;
bool vt[NN],rrr[NN*2];
struct edge {int u,v,A,B,id;} e[MM];
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
void dfs(int v)
{
	vt[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!vt[y]) dfs(y);
	}
}
void checknoans()
{
	for (int i=1;i&lt;=m;i++) addedge(e[i].u,e[i].v),addedge(e[i].v,e[i].u);
	dfs(1);
	if (vt[n]) return;
	printf(&quot;-1\n&quot;);
	exit(0);
}
void rev(int v)
{
	tag[v]=!tag[v];
	swap(son[v][0],son[v][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	rev(son[v][0]);
	rev(son[v][1]);
	tag[v]=false;
}
void update(int v)
{
	int x=son[v][0],y=son[v][1];
	maxid[v]=v;
	if (x&amp;&amp;key[maxid[x]]&gt;key[maxid[v]]) maxid[v]=maxid[x];
	if (y&amp;&amp;key[maxid[y]]&gt;key[maxid[v]]) maxid[v]=maxid[y];
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
	else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
}
int access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
	return y;
}
void makeroot(int x)
{
	access(x);
	splay(x);
	rev(x);
}
void link(int x,int y)
{
	makeroot(x);
	splay(x);
	fa[x]=y;
}
void cut(int x,int y)
{
	//printf(&quot;cut %d %d\n&quot;,x,y);
	makeroot(x);
	access(y);
	splay(y);
	rrr[x]=true;
	son[y][0]=fa[x]=0;
}
int getroot(int x)
{
	//printf(&quot;getroot %d\n&quot;,x);
	access(x);
	splay(x);
	for (;son[x][0];x=son[x][0]) pushdown(x);
	//printf(&quot;root=%d\n\n&quot;,x);
	return x;
}
int find(int x,int y)
{
	if (getroot(x)!=getroot(y)) return 0;
	makeroot(x);
	access(y);
	splay(y);
	return maxid[y];
}
void LCTins(edge now)
{
	if (getroot(now.u)!=getroot(now.v))
	{
		TTT++;
		rrr[TTT]=true;
		fa[TTT]=0;
		maxid[TTT]=TTT;
		which[TTT]=now.id;
		key[TTT]=e[now.id].A;
		link(now.u,TTT);
		link(TTT,now.v);
	}
	else
	{
		//printf(&quot;!=\n&quot;);
		int tmp=find(now.u,now.v);
		//printf(&quot;%d\n&quot;,tmp);
		//printf(&quot;%d\n&quot;,which[tmp]);
		if (e[which[tmp]].A&lt;=now.A) return;
		cut(e[which[tmp]].u,tmp);
		//printf(&quot;cut\n&quot;);
		cut(tmp,e[which[tmp]].v);
		rrr[tmp]=true;
		maxid[tmp]=tmp;
		fa[tmp]=0;
		which[tmp]=now.id;
		key[tmp]=e[now.id].A;
		link(now.u,tmp);
		link(tmp,now.v);
	}
}
bool cmp(edge a,edge b) {return a.B&lt;b.B;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,ans;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=m;i++) scanf(&quot;%d%d%d%d&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].A,&amp;e[i].B);
	checknoans();
	sort(e+1,e+m+1,cmp);
	for (i=1;i&lt;=m;i++) e[i].id=i;
	for (i=1;i&lt;=n;i++)
	{
		fa[i]=0;
		rrr[i]=true;
		key[i]=0;
		maxid[i]=i;
	}
	key[0]=inf;
	//for (int i=1;i&lt;=m;i++) printf(&quot;%d %d %d\n&quot;,e[i].id,e[i].A,e[i].B);
	for (ans=inf,TTT=n,i=1;i&lt;=m;i++)
	{
		//printf(&quot;\n------------------------------------------------------\n&quot;);
		edge now=e[i];
		if (ans&lt;=now.B) break;
		LCTins(now);
		//printf(&quot;%d\n&quot;,find(1,n));
		ans=min(ans,now.B+key[find(1,n)]);
		//printf(&quot;fa &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,fa[i]);printf(&quot;\n&quot;);
		//printf(&quot;rrr &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,rrr[i]?1:0);printf(&quot;\n&quot;);
		//printf(&quot;son &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d %d   &quot;,son[i][0],son[i][1]);printf(&quot;\n&quot;);
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem3669</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 199999999
#define NN 500111
#define MM 101111
int fa[NN*2],o[NN],aa[NN*2][2],tag[NN*2],son[NN*2][2],key[NN*2],maxid[NN*2],which[NN*2];
int n,m,tot,TTT;
bool vt[NN],rrr[NN*2];
struct edge {int u,v,A,B,id;} e[MM];
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
void dfs(int v)
{
	vt[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!vt[y]) dfs(y);
	}
}
void checknoans()
{
	for (int i=1;i&lt;=m;i++) addedge(e[i].u,e[i].v),addedge(e[i].v,e[i].u);
	dfs(1);
	if (vt[n]) return;
	printf(&quot;-1\n&quot;);
	exit(0);
}
void rev(int v)
{
	tag[v]=!tag[v];
	swap(son[v][0],son[v][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	rev(son[v][0]);
	rev(son[v][1]);
	tag[v]=false;
}
void update(int v)
{
	int x=son[v][0],y=son[v][1];
	maxid[v]=v;
	if (x&amp;&amp;key[maxid[x]]&gt;key[maxid[v]]) maxid[v]=maxid[x];
	if (y&amp;&amp;key[maxid[y]]&gt;key[maxid[v]]) maxid[v]=maxid[y];
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
	else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
}
int access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
	return y;
}
void makeroot(int x)
{
	access(x);
	splay(x);
	rev(x);
}
void link(int x,int y)
{
	makeroot(x);
	splay(x);
	fa[x]=y;
}
void cut(int x,int y)
{
	//printf(&quot;cut %d %d\n&quot;,x,y);
	makeroot(x);
	access(y);
	splay(y);
	rrr[x]=true;
	son[y][0]=fa[x]=0;
}
int getroot(int x)
{
	//printf(&quot;getroot %d\n&quot;,x);
	access(x);
	splay(x);
	for (;son[x][0];x=son[x][0]) pushdown(x);
	//printf(&quot;root=%d\n\n&quot;,x);
	return x;
}
int find(int x,int y)
{
	if (getroot(x)!=getroot(y)) return 0;
	makeroot(x);
	access(y);
	splay(y);
	return maxid[y];
}
void LCTins(edge now)
{
	if (getroot(now.u)!=getroot(now.v))
	{
		TTT++;
		rrr[TTT]=true;
		fa[TTT]=0;
		maxid[TTT]=TTT;
		which[TTT]=now.id;
		key[TTT]=e[now.id].A;
		link(now.u,TTT);
		link(TTT,now.v);
	}
	else
	{
		//printf(&quot;!=\n&quot;);
		int tmp=find(now.u,now.v);
		//printf(&quot;%d\n&quot;,tmp);
		//printf(&quot;%d\n&quot;,which[tmp]);
		if (e[which[tmp]].A&lt;=now.A) return;
		cut(e[which[tmp]].u,tmp);
		//printf(&quot;cut\n&quot;);
		cut(tmp,e[which[tmp]].v);
		rrr[tmp]=true;
		maxid[tmp]=tmp;
		fa[tmp]=0;
		which[tmp]=now.id;
		key[tmp]=e[now.id].A;
		link(now.u,tmp);
		link(tmp,now.v);
	}
}
bool cmp(edge a,edge b) {return a.B&lt;b.B;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,ans;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=m;i++) scanf(&quot;%d%d%d%d&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].A,&amp;e[i].B);
	checknoans();
	sort(e+1,e+m+1,cmp);
	for (i=1;i&lt;=m;i++) e[i].id=i;
	for (i=1;i&lt;=n;i++)
	{
		fa[i]=0;
		rrr[i]=true;
		key[i]=0;
		maxid[i]=i;
	}
	key[0]=inf;
	//for (int i=1;i&lt;=m;i++) printf(&quot;%d %d %d\n&quot;,e[i].id,e[i].A,e[i].B);
	for (ans=inf,TTT=n,i=1;i&lt;=m;i++)
	{
		//printf(&quot;\n------------------------------------------------------\n&quot;);
		edge now=e[i];
		if (ans&lt;=now.B) break;
		LCTins(now);
		//printf(&quot;%d\n&quot;,find(1,n));
		ans=min(ans,now.B+key[find(1,n)]);
		//printf(&quot;fa &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,fa[i]);printf(&quot;\n&quot;);
		//printf(&quot;rrr &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,rrr[i]?1:0);printf(&quot;\n&quot;);
		//printf(&quot;son &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d %d   &quot;,son[i][0],son[i][1]);printf(&quot;\n&quot;);
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem3669</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 199999999
#define NN 100111
#define MM 101111
int fa[NN*2],o[NN],aa[NN*2][2],tag[NN*2],son[NN*2][2],key[NN*2],maxid[NN*2],which[NN*2];
int n,m,tot,TTT;
bool vt[NN],rrr[NN*2];
struct edge {int u,v,A,B,id;} e[MM];
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
void dfs(int v)
{
	vt[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!vt[y]) dfs(y);
	}
}
void checknoans()
{
	for (int i=1;i&lt;=m;i++) addedge(e[i].u,e[i].v),addedge(e[i].v,e[i].u);
	dfs(1);
	if (vt[n]) return;
	printf(&quot;-1\n&quot;);
	exit(0);
}
void rev(int v)
{
	tag[v]=!tag[v];
	swap(son[v][0],son[v][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	rev(son[v][0]);
	rev(son[v][1]);
	tag[v]=false;
}
void update(int v)
{
	int x=son[v][0],y=son[v][1];
	maxid[v]=v;
	if (x&amp;&amp;key[maxid[x]]&gt;key[maxid[v]]) maxid[v]=maxid[x];
	if (y&amp;&amp;key[maxid[y]]&gt;key[maxid[v]]) maxid[v]=maxid[y];
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
	else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
}
int access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
	return y;
}
void makeroot(int x)
{
	access(x);
	splay(x);
	rev(x);
}
void link(int x,int y)
{
	makeroot(x);
	splay(x);
	fa[x]=y;
}
void cut(int x,int y)
{
	//printf(&quot;cut %d %d\n&quot;,x,y);
	makeroot(x);
	access(y);
	splay(y);
	rrr[x]=true;
	son[y][0]=fa[x]=0;
}
int getroot(int x)
{
	//printf(&quot;getroot %d\n&quot;,x);
	access(x);
	splay(x);
	for (;son[x][0];x=son[x][0]) pushdown(x);
	//printf(&quot;root=%d\n\n&quot;,x);
	return x;
}
int find(int x,int y)
{
	if (getroot(x)!=getroot(y)) return 0;
	makeroot(x);
	access(y);
	splay(y);
	return maxid[y];
}
void LCTins(edge now)
{
	if (getroot(now.u)!=getroot(now.v))
	{
		TTT++;
		rrr[TTT]=true;
		fa[TTT]=0;
		maxid[TTT]=TTT;
		which[TTT]=now.id;
		key[TTT]=e[now.id].A;
		link(now.u,TTT);
		link(TTT,now.v);
	}
	else
	{
		//printf(&quot;!=\n&quot;);
		int tmp=find(now.u,now.v);
		//printf(&quot;%d\n&quot;,tmp);
		//printf(&quot;%d\n&quot;,which[tmp]);
		if (e[which[tmp]].A&lt;=now.A) return;
		cut(e[which[tmp]].u,tmp);
		//printf(&quot;cut\n&quot;);
		cut(tmp,e[which[tmp]].v);
		rrr[tmp]=true;
		maxid[tmp]=tmp;
		fa[tmp]=0;
		which[tmp]=now.id;
		key[tmp]=e[now.id].A;
		link(now.u,tmp);
		link(tmp,now.v);
	}
}
bool cmp(edge a,edge b) {return a.B&lt;b.B;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,ans;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;=m;i++) scanf(&quot;%d%d%d%d&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].A,&amp;e[i].B);
	checknoans();
	sort(e+1,e+m+1,cmp);
	for (i=1;i&lt;=m;i++) e[i].id=i;
	for (i=1;i&lt;=n;i++)
	{
		fa[i]=0;
		rrr[i]=true;
		key[i]=0;
		maxid[i]=i;
	}
	key[0]=inf;
	//for (int i=1;i&lt;=m;i++) printf(&quot;%d %d %d\n&quot;,e[i].id,e[i].A,e[i].B);
	for (ans=inf,TTT=n,i=1;i&lt;=m;i++)
	{
		//printf(&quot;\n------------------------------------------------------\n&quot;);
		edge now=e[i];
		if (ans&lt;=now.B) break;
		LCTins(now);
		//printf(&quot;%d\n&quot;,find(1,n));
		ans=min(ans,now.B+key[find(1,n)]);
		//printf(&quot;fa &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,fa[i]);printf(&quot;\n&quot;);
		//printf(&quot;rrr &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,rrr[i]?1:0);printf(&quot;\n&quot;);
		//printf(&quot;son &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d %d   &quot;,son[i][0],son[i][1]);printf(&quot;\n&quot;);
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem3669</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
#define ln printf(&quot;\n&quot;)
const int AA=1051111,NN=501111,MM=1001111;
int fa[AA],son[AA][2],tmax[AA],key[AA],o[NN],aa[NN*2][2],from[AA];
int n,m,TTT,tot=1;
bool tag[AA],rrr[AA],vt[AA];
void out(int*a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
struct edge
{
	int u,v,A,B;
	void out() {printf(&quot;%d %d %d %d\n&quot;,u,v,A,B);}
	friend bool operator &lt;(edge a,edge b) {return a.A&lt;b.A;}
} e[MM];
void dfs(int v)
{
	vt[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (vt[y]) continue;
		dfs(y);
	}
}
void rev(int t)
{
	tag[t]=!tag[t];
	swap(son[t][0],son[t][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	rev(son[v][0]),rev(son[v][1]);
	tag[v]=false;
}
void update(int v)
{
	tmax[v]=v;
	int x=son[v][0],y=son[v][1];
	if (key[tmax[x]]&gt;key[tmax[v]]) tmax[v]=tmax[x];
	if (key[tmax[y]]&gt;key[tmax[v]]) tmax[v]=tmax[y];
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
	else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
}
void access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
}
void makeroot(int x)
{
	access(x);
	splay(x);
	rev(x);
}
void link(int x,int y)
{
	//printf(&quot;link %d %d\n&quot;,x,y);
	makeroot(x);
	splay(x);
	fa[x]=y;
}
void cut(int x,int y)
{
	//printf(&quot;cut %d %d\n&quot;,x,y);
	makeroot(x);
	access(y);
	splay(y);
	rrr[x]=true;
	fa[x]=son[y][0]=0;
	update(y);
}
int getfa(int x)
{
	access(x);
	splay(x);
	while (son[x][0]) pushdown(x),x=son[x][0];
	return x;
}
int find(int x,int y)
{
	if (getfa(x)!=getfa(y)) return 0;
	makeroot(x);
	access(y);
	splay(y);
	return tmax[y];
}
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].A,&amp;e[i].B);
		addedge(e[i].u,e[i].v),addedge(e[i].v,e[i].u);
	}
	dfs(1);
	if (!vt[n]) {printf(&quot;-1\n&quot;);return 0;}
	sort(e+1,e+m+1);
	//for (i=1;i&lt;=m;i++) e[i].out();ln;
	key[0]=-inf;
	for (i=1;i&lt;=n;i++)
	{
		rrr[i]=true;
		key[i]=-inf,tmax[i]=i;
	}
	TTT=n;
	int ans=inf;
	for (i=1;i&lt;=m;i++)
	{
		int x=e[i].u,y=e[i].v;
		//printf(&quot;\n------------- i=%d --------------------------------------------\n%d %d\n&quot;,i,x,y);
		if (getfa(x)!=getfa(y))
		{
			int v=++TTT;
			rrr[v]=true;
			from[v]=i;
			key[v]=e[i].B,tmax[v]=v;
			link(x,v),link(v,y);
		}
		else
		{
			int t=find(x,y);
			if (key[t]&lt;=e[i].B) continue;
			int f=from[t];
			cut(e[f].u,t),cut(t,e[f].v);
			int v=++TTT;
			rrr[v]=true;
			from[v]=i;
			key[v]=e[i].B,tmax[v]=v;
			link(x,v),link(v,y);
		}
		int t=find(1,n);
		if (t==0) continue;
		ans=min(ans,e[i].A+key[t]);
		//printf(&quot;ans=%d\n&quot;,ans);
	}
	//ln;ln;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3669</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
#define ln printf(&quot;\n&quot;)
const int AA=201111,NN=51111,MM=101111;
int fa[AA],son[AA][2],tmax[AA],key[AA],o[NN],aa[NN*2][2],from[AA];
int n,m,TTT,tot=1;
bool tag[AA],rrr[AA],vt[AA];
void out(int*a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
struct edge
{
	int u,v,A,B;
	void out() {printf(&quot;%d %d %d %d\n&quot;,u,v,A,B);}
	friend bool operator &lt;(edge a,edge b) {return a.A&lt;b.A;}
} e[MM];
void dfs(int v)
{
	vt[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (vt[y]) continue;
		dfs(y);
	}
}
void rev(int t)
{
	tag[t]=!tag[t];
	swap(son[t][0],son[t][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	rev(son[v][0]),rev(son[v][1]);
	tag[v]=false;
}
void update(int v)
{
	tmax[v]=v;
	int x=son[v][0],y=son[v][1];
	if (key[tmax[x]]&gt;key[tmax[v]]) tmax[v]=tmax[x];
	if (key[tmax[y]]&gt;key[tmax[v]]) tmax[v]=tmax[y];
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
	else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
}
void access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
}
void makeroot(int x)
{
	access(x);
	splay(x);
	rev(x);
}
void link(int x,int y)
{
	//printf(&quot;link %d %d\n&quot;,x,y);
	makeroot(x);
	splay(x);
	fa[x]=y;
}
void cut(int x,int y)
{
	//printf(&quot;cut %d %d\n&quot;,x,y);
	makeroot(x);
	access(y);
	splay(y);
	rrr[x]=true;
	fa[x]=son[y][0]=0;
	update(y);
}
int getfa(int x)
{
	access(x);
	splay(x);
	while (son[x][0]) pushdown(x),x=son[x][0];
	return x;
}
int find(int x,int y)
{
	if (getfa(x)!=getfa(y)) return 0;
	makeroot(x);
	access(y);
	splay(y);
	return tmax[y];
}
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].A,&amp;e[i].B);
		addedge(e[i].u,e[i].v),addedge(e[i].v,e[i].u);
	}
	dfs(1);
	if (!vt[n]) {printf(&quot;-1\n&quot;);return 0;}
	sort(e+1,e+m+1);
	//for (i=1;i&lt;=m;i++) e[i].out();ln;
	key[0]=-inf;
	for (i=1;i&lt;=n;i++)
	{
		rrr[i]=true;
		key[i]=-inf,tmax[i]=i;
	}
	TTT=n;
	int ans=inf;
	for (i=1;i&lt;=m;i++)
	{
		int x=e[i].u,y=e[i].v;
		//printf(&quot;\n------------- i=%d --------------------------------------------\n%d %d\n&quot;,i,x,y);
		if (getfa(x)!=getfa(y))
		{
			int v=++TTT;
			rrr[v]=true;
			from[v]=i;
			key[v]=e[i].B,tmax[v]=v;
			link(x,v),link(v,y);
		}
		else
		{
			int t=find(x,y);
			if (key[t]&lt;=e[i].B) continue;
			int f=from[t];
			cut(e[f].u,t),cut(t,e[f].v);
			int v=++TTT;
			rrr[v]=true;
			from[v]=i;
			key[v]=e[i].B,tmax[v]=v;
			link(x,v),link(v,y);
		}
		int t=find(1,n);
		if (t==0) continue;
		ans=min(ans,e[i].A+key[t]);
		//printf(&quot;ans=%d\n&quot;,ans);
	}
	//ln;ln;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3669</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
#define ln printf(&quot;\n&quot;)
const int AA=201111,NN=51111,MM=101111;
int fa[AA],son[AA][2],tmax[AA],key[AA],o[NN],aa[NN*2][2],from[AA];
int n,m,TTT,tot=1;
bool tag[AA],rrr[AA],vt[AA];
void out(int*a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
struct edge
{
	int u,v,A,B;
	void out() {printf(&quot;%d %d %d %d\n&quot;,u,v,A,B);}
	friend bool operator &lt;(edge a,edge b) {return a.A&lt;b.A;}
} e[MM];
void dfs(int v)
{
	vt[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (vt[y]) continue;
		dfs(y);
	}
}
void rev(int t)
{
	tag[t]=!tag[t];
	swap(son[t][0],son[t][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	rev(son[v][0]),rev(son[v][1]);
	tag[v]=false;
}
void update(int v)
{
	tmax[v]=v;
	int x=son[v][0],y=son[v][1];
	if (key[tmax[x]]&gt;key[tmax[v]]) tmax[v]=tmax[x];
	if (key[tmax[y]]&gt;key[tmax[v]]) tmax[v]=tmax[y];
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
	else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
}
void access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
}
void makeroot(int x)
{
	access(x);
	splay(x);
	rev(x);
}
void link(int x,int y)
{
	//printf(&quot;link %d %d\n&quot;,x,y);
	makeroot(x);
	splay(x);
	fa[x]=y;
}
void cut(int x,int y)
{
	//printf(&quot;cut %d %d\n&quot;,x,y);
	makeroot(x);
	access(y);
	splay(y);
	rrr[x]=true;
	fa[x]=son[y][0]=0;
	update(y);
}
int getfa(int x)
{
	access(x);
	splay(x);
	while (son[x][0]) pushdown(x),x=son[x][0];
	return x;
}
int find(int x,int y)
{
	if (getfa(x)!=getfa(y)) return 0;
	makeroot(x);
	access(y);
	splay(y);
	return tmax[y];
}
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].A,&amp;e[i].B);
		addedge(e[i].u,e[i].v),addedge(e[i].v,e[i].u);
	}
	dfs(1);
	if (!vt[n]) {printf(&quot;-1\n&quot;);return 0;}
	sort(e+1,e+m+1);
	//for (i=1;i&lt;=m;i++) e[i].out();ln;
	key[0]=-inf;
	for (i=1;i&lt;=n;i++)
	{
		rrr[i]=true;
		key[i]=-inf,tmax[i]=i;
	}
	TTT=n;
	int ans=inf;
	for (i=1;i&lt;=m;i++)
	{
		int x=e[i].u,y=e[i].v;
		//printf(&quot;\n------------- i=%d --------------------------------------------\n%d %d\n&quot;,i,x,y);
		if (getfa(x)!=getfa(y))
		{
			int v=++TTT;
			rrr[v]=true;
			from[v]=i;
			key[v]=e[i].B,tmax[v]=v;
			link(x,v),link(v,y);
		}
		else
		{
			int t=find(x,y);
			if (key[t]&lt;=e[i].B) continue;
			int f=from[t];
			cut(e[f].u,t),cut(t,e[f].v);
			int v=t;
			fa[v]=son[v][0]=son[v][1]=0;
			rrr[v]=true;
			from[v]=i;
			key[v]=e[i].B,tmax[v]=v;
			link(x,v),link(v,y);
		}
		int t=find(1,n);
		if (t==0) continue;
		ans=min(ans,e[i].A+key[t]);
		//printf(&quot;ans=%d\n&quot;,ans);
	}
	//ln;ln;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3669</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 199999999
#define NN 100111
#define MM 101111
int fa[NN*2],o[NN],aa[NN*2][2],tag[NN*2],son[NN*2][2],key[NN*2],maxid[NN*2],which[NN*2];
int n,m,tot,TTT;
bool vt[NN],rrr[NN*2];
struct edge {int u,v,A,B,id;} e[MM];
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
void dfs(int v)
{
    vt[v]=true;
    for (int p=o[v];p;p=aa[p][0])
    {
        int y=aa[p][1];
        if (!vt[y]) dfs(y);
    }
}
void checknoans()
{
    for (int i=1;i&lt;=m;i++) addedge(e[i].u,e[i].v),addedge(e[i].v,e[i].u);
    dfs(1);
    if (vt[n]) return;
    printf(&quot;-1\n&quot;);
    exit(0);
}
void rev(int v)
{
    tag[v]=!tag[v];
    swap(son[v][0],son[v][1]);
}
void pushdown(int v)
{
    if (!tag[v]) return;
    rev(son[v][0]);
    rev(son[v][1]);
    tag[v]=false;
}
void update(int v)
{
    int x=son[v][0],y=son[v][1];
    maxid[v]=v;
    if (x&amp;&amp;key[maxid[x]]&gt;key[maxid[v]]) maxid[v]=maxid[x];
    if (y&amp;&amp;key[maxid[y]]&gt;key[maxid[v]]) maxid[v]=maxid[y];
}
void rotate(int t,int p)
{
    int y=fa[t];
    pushdown(y),pushdown(t);
    if (rrr[y]) rrr[y]=false,rrr[t]=true;
    else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
    else son[fa[y]][1]=t;
    fa[t]=fa[y];
    son[y][p^1]=son[t][p];
    if (son[t][p]) fa[son[t][p]]=y;
    son[t][p]=y;
    fa[y]=t;
    update(y),update(t);
}
void splay(int t)
{
    while (!rrr[t])
    {
        int y=fa[t];
        if (rrr[y])
            if (t==son[y][0]) rotate(t,1);
            else rotate(t,0);
        else
            if (y==son[fa[y]][0])
                if (t==son[y][0]) rotate(y,1),rotate(t,1);
                else rotate(t,0),rotate(t,1);
            else
                if (t==son[y][1]) rotate(y,0),rotate(t,0);
                else rotate(t,1),rotate(t,0);
    }
}
int access(int x)
{
    int y=0;
    for (;x;y=x,x=fa[x])
    {
        splay(x);
        pushdown(x);
        rrr[son[x][1]]=true;
        son[x][1]=y;
        rrr[y]=false;
        update(x);
    }
    return y;
}
void makeroot(int x)
{
    access(x);
    splay(x);
    rev(x);
}
void link(int x,int y)
{
    makeroot(x);
    splay(x);
    fa[x]=y;
}
void cut(int x,int y)
{
    //printf(&quot;cut %d %d\n&quot;,x,y);
    makeroot(x);
    access(y);
    splay(y);
    rrr[x]=true;
    son[y][0]=fa[x]=0;
}
int getroot(int x)
{
    //printf(&quot;getroot %d\n&quot;,x);
    access(x);
    splay(x);
    for (;son[x][0];x=son[x][0]) pushdown(x);
    //printf(&quot;root=%d\n\n&quot;,x);
    return x;
}
int find(int x,int y)
{
    if (getroot(x)!=getroot(y)) return 0;
    makeroot(x);
    access(y);
    splay(y);
    return maxid[y];
}
void LCTins(edge now)
{
    if (getroot(now.u)!=getroot(now.v))
    {
        TTT++;
        rrr[TTT]=true;
        fa[TTT]=0;
        maxid[TTT]=TTT;
        which[TTT]=now.id;
        key[TTT]=e[now.id].A;
        link(now.u,TTT);
        link(TTT,now.v);
    }
    else
    {
        //printf(&quot;!=\n&quot;);
        int tmp=find(now.u,now.v);
        //printf(&quot;%d\n&quot;,tmp);
        //printf(&quot;%d\n&quot;,which[tmp]);
        if (e[which[tmp]].A&lt;=now.A) return;
        cut(e[which[tmp]].u,tmp);
        //printf(&quot;cut\n&quot;);
        cut(tmp,e[which[tmp]].v);
        rrr[tmp]=true;
        maxid[tmp]=tmp;
        fa[tmp]=0;
        which[tmp]=now.id;
        key[tmp]=e[now.id].A;
        link(now.u,tmp);
        link(tmp,now.v);
    }
}
bool cmp(edge a,edge b) {return a.B&lt;b.B;}
int main()
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    int i,ans;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for (i=1;i&lt;=m;i++) scanf(&quot;%d%d%d%d&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].A,&amp;e[i].B);
    checknoans();
    sort(e+1,e+m+1,cmp);
    for (i=1;i&lt;=m;i++) e[i].id=i;
    for (i=1;i&lt;=n;i++)
    {
        fa[i]=0;
        rrr[i]=true;
        key[i]=0;
        maxid[i]=i;
    }
    key[0]=inf;
    //for (int i=1;i&lt;=m;i++) printf(&quot;%d %d %d\n&quot;,e[i].id,e[i].A,e[i].B);
    for (ans=inf,TTT=n,i=1;i&lt;=m;i++)
    {
        //printf(&quot;\n------------------------------------------------------\n&quot;);
        edge now=e[i];
        if (ans&lt;=now.B) break;
        LCTins(now);
        //printf(&quot;%d\n&quot;,find(1,n));
        ans=min(ans,now.B+key[find(1,n)]);
        //printf(&quot;fa &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,fa[i]);printf(&quot;\n&quot;);
        //printf(&quot;rrr &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d &quot;,rrr[i]?1:0);printf(&quot;\n&quot;);
        //printf(&quot;son &quot;);for (int i=1;i&lt;=TTT;i++) printf(&quot;%d %d   &quot;,son[i][0],son[i][1]);printf(&quot;\n&quot;);
    }
    printf(&quot;%d\n&quot;,ans);
    return 0;
}<pre><h2>Problem3669</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
#define ln printf(&quot;\n&quot;)
const int AA=201111,NN=51111,MM=101111;
int fa[AA],son[AA][2],tmax[AA],key[AA],o[NN],aa[NN*2][2],from[AA];
int n,m,TTT,tot=1;
bool tag[AA],rrr[AA],vt[AA];
void out(int*a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
struct edge
{
	int u,v,A,B;
	void out() {printf(&quot;%d %d %d %d\n&quot;,u,v,A,B);}
	friend bool operator &lt;(edge a,edge b) {return a.A&lt;b.A;}
} e[MM];
void dfs(int v)
{
	vt[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (vt[y]) continue;
		dfs(y);
	}
}
void rev(int t)
{
	tag[t]=!tag[t];
	swap(son[t][0],son[t][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	rev(son[v][0]),rev(son[v][1]);
	tag[v]=false;
}
void update(int v)
{
	tmax[v]=v;
	int x=son[v][0],y=son[v][1];
	if (key[tmax[x]]&gt;key[tmax[v]]) tmax[v]=tmax[x];
	if (key[tmax[y]]&gt;key[tmax[v]]) tmax[v]=tmax[y];
}
void rotate(int t,int p)
{
    int y=fa[t];
    pushdown(y),pushdown(t);
    if (rrr[y]) rrr[y]=false,rrr[t]=true;
    else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
    else son[fa[y]][1]=t;
    fa[t]=fa[y];
    son[y][p^1]=son[t][p];
    if (son[t][p]) fa[son[t][p]]=y;
    son[t][p]=y;
    fa[y]=t;
    update(y),update(t);
}
void splay(int t)
{
    while (!rrr[t])
    {
        int y=fa[t];
        if (rrr[y])
            if (t==son[y][0]) rotate(t,1);
            else rotate(t,0);
        else
            if (y==son[fa[y]][0])
                if (t==son[y][0]) rotate(y,1),rotate(t,1);
                else rotate(t,0),rotate(t,1);
            else
                if (t==son[y][1]) rotate(y,0),rotate(t,0);
                else rotate(t,1),rotate(t,0);
    }
}
int access(int x)
{
    int y=0;
    for (;x;y=x,x=fa[x])
    {
        splay(x);
        pushdown(x);
        rrr[son[x][1]]=true;
        son[x][1]=y;
        rrr[y]=false;
        update(x);
    }
    return y;
}
void makeroot(int x)
{
    access(x);
    splay(x);
    rev(x);
}
void link(int x,int y)
{
    makeroot(x);
    splay(x);
    fa[x]=y;
}
void cut(int x,int y)
{
    //printf(&quot;cut %d %d\n&quot;,x,y);
    makeroot(x);
    access(y);
    splay(y);
    rrr[x]=true;
    son[y][0]=fa[x]=0;
}
int getfa(int x)
{
	access(x);
	splay(x);
	while (son[x][0]) pushdown(x),x=son[x][0];
	return x;
}
int find(int x,int y)
{
	if (getfa(x)!=getfa(y)) return 0;
	makeroot(x);
	access(y);
	splay(y);
	return tmax[y];
}
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].A,&amp;e[i].B);
		addedge(e[i].u,e[i].v),addedge(e[i].v,e[i].u);
	}
	dfs(1);
	if (!vt[n]) {printf(&quot;-1\n&quot;);return 0;}
	sort(e+1,e+m+1);
	//for (i=1;i&lt;=m;i++) e[i].out();ln;
	key[0]=-inf;
	for (i=1;i&lt;=n;i++)
	{
		rrr[i]=true;
		key[i]=-inf,tmax[i]=i;
	}
	TTT=n;
	int ans=inf;
	for (i=1;i&lt;=m;i++)
	{
		int x=e[i].u,y=e[i].v;
		//printf(&quot;\n------------- i=%d --------------------------------------------\n%d %d\n&quot;,i,x,y);
		if (getfa(x)!=getfa(y))
		{
			int v=++TTT;
			rrr[v]=true;
			from[v]=i;
			key[v]=e[i].B,tmax[v]=v;
			link(x,v),link(v,y);
		}
		else
		{
			int t=find(x,y);
			if (key[t]&lt;=e[i].B) continue;
			int f=from[t];
			cut(e[f].u,t),cut(t,e[f].v);
			int v=t;
			fa[v]=son[v][0]=son[v][1]=0;
			rrr[v]=true;
			from[v]=i;
			key[v]=e[i].B,tmax[v]=v;
			link(x,v),link(v,y);
		}
		int t=find(1,n);
		if (t==0) continue;
		ans=min(ans,e[i].A+key[t]);
		//printf(&quot;ans=%d\n&quot;,ans);
	}
	//ln;ln;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3669</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
#define ln printf(&quot;\n&quot;)
const int AA=201111,NN=51111,MM=101111;
int fa[AA],son[AA][2],tmax[AA],key[AA],o[NN],aa[NN*2][2],from[AA];
int n,m,TTT,tot=1;
bool tag[AA],rrr[AA],vt[AA];
void out(int*a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
struct edge
{
	int u,v,A,B;
	void out() {printf(&quot;%d %d %d %d\n&quot;,u,v,A,B);}
	friend bool operator &lt;(edge a,edge b) {return a.A&lt;b.A;}
} e[MM];
void dfs(int v)
{
	vt[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (vt[y]) continue;
		dfs(y);
	}
}
void rev(int t)
{
	tag[t]=!tag[t];
	swap(son[t][0],son[t][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	rev(son[v][0]),rev(son[v][1]);
	tag[v]=false;
}
void update(int v)
{
	tmax[v]=v;
	int x=son[v][0],y=son[v][1];
	if (key[tmax[x]]&gt;key[tmax[v]]) tmax[v]=tmax[x];
	if (key[tmax[y]]&gt;key[tmax[v]]) tmax[v]=tmax[y];
}
void rotate(int t,int p)
{
    int y=fa[t];
    pushdown(y),pushdown(t);
    if (rrr[y]) rrr[y]=false,rrr[t]=true;
    else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
    else son[fa[y]][1]=t;
    fa[t]=fa[y];
    son[y][p^1]=son[t][p];
    if (son[t][p]) fa[son[t][p]]=y;
    son[t][p]=y;
    fa[y]=t;
    update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
}
void access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
}
void makeroot(int x)
{
	access(x);
	splay(x);
	rev(x);
}
void link(int x,int y)
{
	//printf(&quot;link %d %d\n&quot;,x,y);
	makeroot(x);
	splay(x);
	fa[x]=y;
}
void cut(int x,int y)
{
	//printf(&quot;cut %d %d\n&quot;,x,y);
	makeroot(x);
	access(y);
	splay(y);
	rrr[x]=true;
	fa[x]=son[y][0]=0;
	update(y);
}
int getfa(int x)
{
    //printf(&quot;getroot %d\n&quot;,x);
    access(x);
    splay(x);
    for (;son[x][0];x=son[x][0]) pushdown(x);
    //printf(&quot;root=%d\n\n&quot;,x);
    return x;
}
int find(int x,int y)
{
    if (getfa(x)!=getfa(y)) return 0;
    makeroot(x);
    access(y);
    splay(y);
    return tmax[y];
}
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].A,&amp;e[i].B);
		addedge(e[i].u,e[i].v),addedge(e[i].v,e[i].u);
	}
	dfs(1);
	if (!vt[n]) {printf(&quot;-1\n&quot;);return 0;}
	sort(e+1,e+m+1);
	//for (i=1;i&lt;=m;i++) e[i].out();ln;
	key[0]=-inf;
	for (i=1;i&lt;=n;i++)
	{
		rrr[i]=true;
		key[i]=-inf,tmax[i]=i;
	}
	TTT=n;
	int ans=inf;
	for (i=1;i&lt;=m;i++)
	{
		int x=e[i].u,y=e[i].v;
		//printf(&quot;\n------------- i=%d --------------------------------------------\n%d %d\n&quot;,i,x,y);
		if (getfa(x)!=getfa(y))
		{
			int v=++TTT;
			rrr[v]=true;
			from[v]=i;
			key[v]=e[i].B,tmax[v]=v;
			link(x,v),link(v,y);
		}
		else
		{
			int t=find(x,y);
			if (key[t]&lt;=e[i].B) continue;
			int f=from[t];
			cut(e[f].u,t),cut(t,e[f].v);
			int v=t;
			fa[v]=son[v][0]=son[v][1]=0;
			rrr[v]=true;
			from[v]=i;
			key[v]=e[i].B,tmax[v]=v;
			link(x,v),link(v,y);
		}
		int t=find(1,n);
		if (t==0) continue;
		ans=min(ans,e[i].A+key[t]);
		//printf(&quot;ans=%d\n&quot;,ans);
	}
	//ln;ln;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3669</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 199999999
#define NN 100111
#define MM 101111
int fa[NN*2],o[NN],aa[NN*2][2],tag[NN*2],son[NN*2][2],key[NN*2],tmax[NN*2],which[NN*2];
int n,m,tot,TTT;
bool vt[NN],rrr[NN*2];
struct edge {int u,v,A,B,id;} e[MM];
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
void dfs(int v)
{
    vt[v]=true;
    for (int p=o[v];p;p=aa[p][0])
    {
        int y=aa[p][1];
        if (!vt[y]) dfs(y);
    }
}
void checknoans()
{
    for (int i=1;i&lt;=m;i++) addedge(e[i].u,e[i].v),addedge(e[i].v,e[i].u);
    dfs(1);
    if (vt[n]) return;
    printf(&quot;-1\n&quot;);
    exit(0);
}
void rev(int v)
{
    tag[v]=!tag[v];
    swap(son[v][0],son[v][1]);
}
void pushdown(int v)
{
    if (!tag[v]) return;
    rev(son[v][0]);
    rev(son[v][1]);
    tag[v]=false;
}
void update(int v)
{
    int x=son[v][0],y=son[v][1];
    tmax[v]=v;
    if (x&amp;&amp;key[tmax[x]]&gt;key[tmax[v]]) tmax[v]=tmax[x];
    if (y&amp;&amp;key[tmax[y]]&gt;key[tmax[v]]) tmax[v]=tmax[y];
}
void rotate(int t,int p)
{
    int y=fa[t];
    pushdown(y),pushdown(t);
    if (rrr[y]) rrr[y]=false,rrr[t]=true;
    else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
    else son[fa[y]][1]=t;
    fa[t]=fa[y];
    son[y][p^1]=son[t][p];
    if (son[t][p]) fa[son[t][p]]=y;
    son[t][p]=y;
    fa[y]=t;
    update(y),update(t);
}
void splay(int t)
{
    while (!rrr[t])
    {
        int y=fa[t];
        if (rrr[y])
            if (t==son[y][0]) rotate(t,1);
            else rotate(t,0);
        else
            if (y==son[fa[y]][0])
                if (t==son[y][0]) rotate(y,1),rotate(t,1);
                else rotate(t,0),rotate(t,1);
            else
                if (t==son[y][1]) rotate(y,0),rotate(t,0);
                else rotate(t,1),rotate(t,0);
    }
}
int access(int x)
{
    int y=0;
    for (;x;y=x,x=fa[x])
    {
        splay(x);
        pushdown(x);
        rrr[son[x][1]]=true;
        son[x][1]=y;
        rrr[y]=false;
        update(x);
    }
    return y;
}
void makeroot(int x)
{
    access(x);
    splay(x);
    rev(x);
}
void link(int x,int y)
{
    makeroot(x);
    splay(x);
    fa[x]=y;
}
void cut(int x,int y)
{
    //printf(&quot;cut %d %d\n&quot;,x,y);
    makeroot(x);
    access(y);
    splay(y);
    rrr[x]=true;
    son[y][0]=fa[x]=0;
}
int getroot(int x)
{
    //printf(&quot;getroot %d\n&quot;,x);
    access(x);
    splay(x);
    for (;son[x][0];x=son[x][0]) pushdown(x);
    //printf(&quot;root=%d\n\n&quot;,x);
    return x;
}
int find(int x,int y)
{
    if (getroot(x)!=getroot(y)) return 0;
    makeroot(x);
    access(y);
    splay(y);
    return tmax[y];
}
void LCTins(edge now)
{
    if (getroot(now.u)!=getroot(now.v))
    {
        TTT++;
        rrr[TTT]=true;
        fa[TTT]=0;
        tmax[TTT]=TTT;
        which[TTT]=now.id;
        key[TTT]=e[now.id].A;
        link(now.u,TTT);
        link(TTT,now.v);
    }
    else
    {
        //printf(&quot;!=\n&quot;);
        int tmp=find(now.u,now.v);
        //printf(&quot;%d\n&quot;,tmp);
        //printf(&quot;%d\n&quot;,which[tmp]);
        if (e[which[tmp]].A&lt;=now.A) return;
        cut(e[which[tmp]].u,tmp);
        //printf(&quot;cut\n&quot;);
        cut(tmp,e[which[tmp]].v);
        rrr[tmp]=true;
        tmax[tmp]=tmp;
        fa[tmp]=0;
        which[tmp]=now.id;
        key[tmp]=e[now.id].A;
        link(now.u,tmp);
        link(tmp,now.v);
    }
}
bool cmp(edge a,edge b) {return a.B&lt;b.B;}
int main()
{
   // freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    int i,ans;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for (i=1;i&lt;=m;i++) scanf(&quot;%d%d%d%d&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].A,&amp;e[i].B);
    checknoans();
    sort(e+1,e+m+1,cmp);
    for (i=1;i&lt;=m;i++) e[i].id=i;
    for (i=1;i&lt;=n;i++)
    {
        fa[i]=0;
        rrr[i]=true;
        key[i]=0;
        tmax[i]=i;
    }
    key[0]=inf;
    for (ans=inf,TTT=n,i=1;i&lt;=m;i++)
    {
        edge now=e[i];
        if (ans&lt;=now.B) break;
        LCTins(now);
        ans=min(ans,now.B+key[find(1,n)]);
    }
    printf(&quot;%d\n&quot;,ans);
    return 0;
}<pre><h2>Problem3669</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
#define ln printf(&quot;\n&quot;)
const int AA=201111,NN=51111,MM=101111;
int fa[AA],son[AA][2],tmax[AA],key[AA],o[NN],aa[NN*2][2],from[AA];
int n,m,TTT,tot=1;
bool tag[AA],rrr[AA],vt[AA];
void out(int*a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
struct edge
{
	int u,v,A,B;
	void out() {printf(&quot;%d %d %d %d\n&quot;,u,v,A,B);}
	friend bool operator &lt;(edge a,edge b) {return a.A&lt;b.A;}
} e[MM];
void dfs(int v)
{
	vt[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (vt[y]) continue;
		dfs(y);
	}
}
void rev(int t)
{
	tag[t]=!tag[t];
	swap(son[t][0],son[t][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	rev(son[v][0]),rev(son[v][1]);
	tag[v]=false;
}
void update(int v)
{
	tmax[v]=v;
	int x=son[v][0],y=son[v][1];
	if (key[tmax[x]]&gt;key[tmax[v]]) tmax[v]=tmax[x];
	if (key[tmax[y]]&gt;key[tmax[v]]) tmax[v]=tmax[y];
}
void rotate(int t,int p)
{
    int y=fa[t];
    pushdown(y),pushdown(t);
    if (rrr[y]) rrr[y]=false,rrr[t]=true;
    else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
    else son[fa[y]][1]=t;
    fa[t]=fa[y];
    son[y][p^1]=son[t][p];
    if (son[t][p]) fa[son[t][p]]=y;
    son[t][p]=y;
    fa[y]=t;
    update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
}
void access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
}
void makeroot(int x)
{
	access(x);
	splay(x);
	rev(x);
}
void link(int x,int y)
{
	//printf(&quot;link %d %d\n&quot;,x,y);
	makeroot(x);
	splay(x);
	fa[x]=y;
}
void cut(int x,int y)
{
	//printf(&quot;cut %d %d\n&quot;,x,y);
	makeroot(x);
	access(y);
	splay(y);
	rrr[x]=true;
	fa[x]=son[y][0]=0;
	update(y);
}
int getfa(int x)
{
    //printf(&quot;getroot %d\n&quot;,x);
    access(x);
    splay(x);
    for (;son[x][0];x=son[x][0]) pushdown(x);
    //printf(&quot;root=%d\n\n&quot;,x);
    return x;
}
int find(int x,int y)
{
    if (getfa(x)!=getfa(y)) return 0;
    makeroot(x);
    access(y);
    splay(y);
    return tmax[y];
}
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].A,&amp;e[i].B);
		addedge(e[i].u,e[i].v),addedge(e[i].v,e[i].u);
	}
	dfs(1);
	if (!vt[n]) {printf(&quot;-1\n&quot;);return 0;}
	sort(e+1,e+m+1);
	//for (i=1;i&lt;=m;i++) e[i].out();ln;
	key[0]=0;
	for (i=1;i&lt;=n;i++)
	{
		rrr[i]=true;
		key[i]=-inf,tmax[i]=i;
	}
	TTT=n;
	int ans=inf;
	for (i=1;i&lt;=m;i++)
	{
		int x=e[i].u,y=e[i].v;
		//printf(&quot;\n------------- i=%d --------------------------------------------\n%d %d\n&quot;,i,x,y);
		if (getfa(x)!=getfa(y))
		{
			int v=++TTT;
			rrr[v]=true;
			from[v]=i;
			key[v]=e[i].B,tmax[v]=v;
			link(x,v),link(v,y);
		}
		else
		{
			int t=find(x,y);
			if (key[t]&lt;=e[i].B) continue;
			int f=from[t];
			cut(e[f].u,t),cut(t,e[f].v);
			int v=t;
			fa[v]=son[v][0]=son[v][1]=0;
			rrr[v]=true;
			from[v]=i;
			key[v]=e[i].B,tmax[v]=v;
			link(x,v),link(v,y);
		}
		int t=find(1,n);
		if (t==0) continue;
		ans=min(ans,e[i].A+key[t]);
		//printf(&quot;ans=%d\n&quot;,ans);
	}
	//ln;ln;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3669</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
#define ln printf(&quot;\n&quot;)
const int AA=201111,NN=51111,MM=101111;
int fa[AA],son[AA][2],tmax[AA],key[AA],o[NN],aa[NN*2][2],from[AA];
int n,m,TTT,tot=1;
bool tag[AA],rrr[AA],vt[AA];
void out(int*a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
struct edge
{
	int u,v,A,B;
	void out() {printf(&quot;%d %d %d %d\n&quot;,u,v,A,B);}
	friend bool operator &lt;(edge a,edge b) {return a.A&lt;b.A;}
} e[MM];
void dfs(int v)
{
	vt[v]=true;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (vt[y]) continue;
		dfs(y);
	}
}
void rev(int t)
{
	tag[t]=!tag[t];
	swap(son[t][0],son[t][1]);
}
void pushdown(int v)
{
	if (!tag[v]) return;
	rev(son[v][0]),rev(son[v][1]);
	tag[v]=false;
}
void update(int v)
{
	tmax[v]=v;
	int x=son[v][0],y=son[v][1];
	if (key[tmax[x]]&gt;key[tmax[v]]) tmax[v]=tmax[x];
	if (key[tmax[y]]&gt;key[tmax[v]]) tmax[v]=tmax[y];
}
void rotate(int t,int p)
{
    int y=fa[t];
    pushdown(y),pushdown(t);
    if (rrr[y]) rrr[y]=false,rrr[t]=true;
    else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
    else son[fa[y]][1]=t;
    fa[t]=fa[y];
    son[y][p^1]=son[t][p];
    if (son[t][p]) fa[son[t][p]]=y;
    son[t][p]=y;
    fa[y]=t;
    update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
}
void access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
}
void makeroot(int x)
{
	access(x);
	splay(x);
	rev(x);
}
void link(int x,int y)
{
	//printf(&quot;link %d %d\n&quot;,x,y);
	makeroot(x);
	splay(x);
	fa[x]=y;
}
void cut(int x,int y)
{
	//printf(&quot;cut %d %d\n&quot;,x,y);
	makeroot(x);
	access(y);
	splay(y);
	rrr[x]=true;
	fa[x]=son[y][0]=0;
	update(y);
}
int getfa(int x)
{
    //printf(&quot;getroot %d\n&quot;,x);
    access(x);
    splay(x);
    for (;son[x][0];x=son[x][0]) pushdown(x);
    //printf(&quot;root=%d\n\n&quot;,x);
    return x;
}
int find(int x,int y)
{
    if (getfa(x)!=getfa(y)) return 0;
    makeroot(x);
    access(y);
    splay(y);
    return tmax[y];
}
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].B,&amp;e[i].A);
		addedge(e[i].u,e[i].v),addedge(e[i].v,e[i].u);
	}
	dfs(1);
	if (!vt[n]) {printf(&quot;-1\n&quot;);return 0;}
	sort(e+1,e+m+1);
	//for (i=1;i&lt;=m;i++) e[i].out();ln;
	key[0]=-inf;
	for (i=1;i&lt;=n;i++)
	{
		rrr[i]=true;
		key[i]=-inf,tmax[i]=i;
	}
	TTT=n;
	int ans=inf;
	for (i=1;i&lt;=m;i++)
	{
		int x=e[i].u,y=e[i].v;
		//printf(&quot;\n------------- i=%d --------------------------------------------\n%d %d\n&quot;,i,x,y);
		if (getfa(x)!=getfa(y))
		{
			int v=++TTT;
			rrr[v]=true;
			from[v]=i;
			key[v]=e[i].B,tmax[v]=v;
			link(x,v),link(v,y);
		}
		else
		{
			int t=find(x,y);
			if (key[t]&lt;=e[i].B) continue;
			int f=from[t];
			cut(e[f].u,t),cut(t,e[f].v);
			int v=t;
			fa[v]=son[v][0]=son[v][1]=0;
			rrr[v]=true;
			from[v]=i;
			key[v]=e[i].B,tmax[v]=v;
			link(x,v),link(v,y);
		}
		int t=find(1,n);
		if (t==0) continue;
		ans=min(ans,e[i].A+key[t]);
		//printf(&quot;ans=%d\n&quot;,ans);
	}
	//ln;ln;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3669</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 199999999
#define NN 100111
#define MM 101111
int fa[NN*2],o[NN],aa[NN*2][2],tag[NN*2],son[NN*2][2],key[NN*2],tmax[NN*2],from[NN*2];
int n,m,tot,TTT;
bool vt[NN],rrr[NN*2];
struct edge {int u,v,A,B,id;} e[MM];
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
void dfs(int v)
{
    vt[v]=true;
    for (int p=o[v];p;p=aa[p][0])
    {
        int y=aa[p][1];
        if (!vt[y]) dfs(y);
    }
}
void rev(int v)
{
    tag[v]=!tag[v];
    swap(son[v][0],son[v][1]);
}
void pushdown(int v)
{
    if (!tag[v]) return;
    rev(son[v][0]);
    rev(son[v][1]);
    tag[v]=false;
}
void update(int v)
{
    int x=son[v][0],y=son[v][1];
    tmax[v]=v;
    if (x&amp;&amp;key[tmax[x]]&gt;key[tmax[v]]) tmax[v]=tmax[x];
    if (y&amp;&amp;key[tmax[y]]&gt;key[tmax[v]]) tmax[v]=tmax[y];
}
void rotate(int t,int p)
{
    int y=fa[t];
    pushdown(y),pushdown(t);
    if (rrr[y]) rrr[y]=false,rrr[t]=true;
    else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
    else son[fa[y]][1]=t;
    fa[t]=fa[y];
    son[y][p^1]=son[t][p];
    if (son[t][p]) fa[son[t][p]]=y;
    son[t][p]=y;
    fa[y]=t;
    update(y),update(t);
}
void splay(int t)
{
    while (!rrr[t])
    {
        int y=fa[t];
        if (rrr[y])
            if (t==son[y][0]) rotate(t,1);
            else rotate(t,0);
        else
            if (y==son[fa[y]][0])
                if (t==son[y][0]) rotate(y,1),rotate(t,1);
                else rotate(t,0),rotate(t,1);
            else
                if (t==son[y][1]) rotate(y,0),rotate(t,0);
                else rotate(t,1),rotate(t,0);
    }
}
int access(int x)
{
    int y=0;
    for (;x;y=x,x=fa[x])
    {
        splay(x);
        pushdown(x);
        rrr[son[x][1]]=true;
        son[x][1]=y;
        rrr[y]=false;
        update(x);
    }
    return y;
}
void makeroot(int x)
{
    access(x);
    splay(x);
    rev(x);
}
void link(int x,int y)
{
    makeroot(x);
    splay(x);
    fa[x]=y;
}
void cut(int x,int y)
{
    //printf(&quot;cut %d %d\n&quot;,x,y);
    makeroot(x);
    access(y);
    splay(y);
    rrr[x]=true;
    son[y][0]=fa[x]=0;
}
int getroot(int x)
{
    //printf(&quot;getroot %d\n&quot;,x);
    access(x);
    splay(x);
    for (;son[x][0];x=son[x][0]) pushdown(x);
    //printf(&quot;root=%d\n\n&quot;,x);
    return x;
}
int find(int x,int y)
{
    if (getroot(x)!=getroot(y)) return 0;
    makeroot(x);
    access(y);
    splay(y);
    return tmax[y];
}
void LCTins(edge now)
{
    if (getroot(now.u)!=getroot(now.v))
    {
        TTT++;
        rrr[TTT]=true;
        fa[TTT]=0;
        tmax[TTT]=TTT;
        from[TTT]=now.id;
        key[TTT]=e[now.id].A;
        link(now.u,TTT);
        link(TTT,now.v);
    }
    else
    {
        //printf(&quot;!=\n&quot;);
        int tmp=find(now.u,now.v);
        //printf(&quot;%d\n&quot;,tmp);
        //printf(&quot;%d\n&quot;,from[tmp]);
        if (e[from[tmp]].A&lt;=now.A) return;
        cut(e[from[tmp]].u,tmp);
        //printf(&quot;cut\n&quot;);
        cut(tmp,e[from[tmp]].v);
        rrr[tmp]=true;
        tmax[tmp]=tmp;
        fa[tmp]=0;
        from[tmp]=now.id;
        key[tmp]=e[now.id].A;
        link(now.u,tmp);
        link(tmp,now.v);
    }
}
bool cmp(edge a,edge b) {return a.B&lt;b.B;}
int main()
{
   // freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    int i,ans;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for (i=1;i&lt;=m;i++) scanf(&quot;%d%d%d%d&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].A,&amp;e[i].B);
    for (int i=1;i&lt;=m;i++) addedge(e[i].u,e[i].v),addedge(e[i].v,e[i].u);
    dfs(1);
    if (!vt[n]) {printf(&quot;-1\n&quot;);return 0;}
    sort(e+1,e+m+1,cmp);
    for (i=1;i&lt;=m;i++) e[i].id=i;
    for (i=1;i&lt;=n;i++)
    {
        fa[i]=0;
        rrr[i]=true;
        key[i]=0;
        tmax[i]=i;
    }
    key[0]=inf;
    for (ans=inf,TTT=n,i=1;i&lt;=m;i++)
    {
        edge now=e[i];
        if (ans&lt;=now.B) break;
        LCTins(now);
        ans=min(ans,now.B+key[find(1,n)]);
    }
    printf(&quot;%d\n&quot;,ans);
    return 0;
}<pre><h2>Problem3669</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
const int NN=201111;
int fa[NN],son[NN][2],id[NN],key[NN],from[NN];
int n,m,TTT;
bool tag[NN],rrr[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
struct edge
{
	int u,v,A,B;
	void in() {read(u),read(v),read(A),read(B);}
	friend bool operator &lt;(edge a,edge b) {return a.A&lt;b.A;}
} e[NN];
inline void rev(int t)
{
	tag[t]=!tag[t];
	swap(son[t][0],son[t][1]);
}
inline void pushdown(int t)
{
	if (!tag[t]) return;
	rev(son[t][0]),rev(son[t][1]);
	tag[t]=false;
}
inline void update(int t)
{
	id[t]=t;
	int x=son[t][0],y=son[t][1];
	if (key[id[x]]&gt;key[id[t]]) id[t]=id[x];
	if (key[id[y]]&gt;key[id[t]]) id[t]=id[y];
}
inline void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
	else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
}
void access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
}
void makeroot(int x)
{
	access(x);
	splay(x);
	rev(x);
}
void link(int x,int y)
{
	makeroot(x);
	splay(x);
	fa[x]=y;
}
void cut(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	rrr[x]=true;
	fa[x]=son[y][0]=0;
}
int find(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	return id[y];
}
int getroot(int x)
{
	access(x);
	splay(x);
	pushdown(x);
	while (son[x][0])
	{
		x=son[x][0];
		pushdown(x);
	}
	return x;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	int i;
	for (i=1;i&lt;=m;i++) e[i].in();
	sort(e+1,e+m+1);
	int ans=inf;
	for (i=1;i&lt;=n;i++) rrr[i]=true;
	TTT=n;
	for (i=1;i&lt;=m;i++)
	{
		//printf(&quot;\n------------------------------------------------------------------\n&quot;);
		int u=e[i].u,v=e[i].v;
		if (getroot(u)!=getroot(v))
		{
			int t=++TTT;
			from[t]=i;
			rrr[t]=true;key[t]=e[i].B;
			id[t]=t;
			link(u,t),link(t,v);
		}
		else
		{
			int t=find(u,v);
			if (key[t]&lt;=e[i].B) continue;
			cut(t,e[from[t]].u),cut(t,e[from[t]].v);
			from[t]=i;
			fa[t]=son[t][0]=son[t][1]=0;
			rrr[t]=true;key[t]=e[i].B;
			id[t]=t;
			link(u,t),link(t,v);
		}
		if (getroot(1)==getroot(n))
			ans=min(ans,e[i].A+key[find(1,n)]);
	}
	if (ans&lt;inf) printf(&quot;%d\n&quot;,ans);
	else printf(&quot;-1\n&quot;);
	return 0;
}<pre><h2>Problem3669</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
#define ln printf(&quot;\n&quot;)
const int NN=100111;
int n,m,TTT,from[NN];
inline int min(int a,int b) {return a&lt;b?a:b;}
inline void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
	if (f) x=-x;
}
struct edge
{
	int u,v,A,B;
	inline void in() {read(u),read(v),read(A),read(B);}
	inline void out() {printf(&quot;u=%d v=%d A=%d B=%d\n&quot;,u,v,A,B);}
	friend bool operator &lt;(const edge &amp;a,const edge &amp;b) {return a.A&lt;b.A;}
} e[NN];
struct splaynode
{
	int fa,s[2],key,mxid;
	bool tag,r;
	inline void rev()
	{
		tag^=1;
		swap(s[0],s[1]);
	}
} T[NN];
inline void pushdown(int v)
{
	if (T[v].tag)
	{
		T[T[v].s[0]].rev();
		T[T[v].s[1]].rev();
		T[v].tag=false;
	}
}
inline void update(int t)
{
	int x=T[t].s[0],y=T[t].s[1];
	T[t].mxid=t;
	if (T[T[x].mxid].key&gt;T[T[t].mxid].key) T[t].mxid=T[x].mxid;
	if (T[T[y].mxid].key&gt;T[T[t].mxid].key) T[t].mxid=T[y].mxid;
}
inline void rotate(int t,int p)
{
	int y=T[t].fa;
	pushdown(y),pushdown(t);
	if (T[y].r) T[y].r=false,T[t].r=true;
	else if (y==T[T[y].fa].s[0]) T[T[y].fa].s[0]=t;
	else T[T[y].fa].s[1]=t;
	T[t].fa=T[y].fa;
	T[y].s[p^1]=T[t].s[p];
	if (T[t].s[p]) T[T[t].s[p]].fa=y;
	T[t].s[p]=y;
	T[y].fa=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!T[t].r)
	{
		int y=T[t].fa;
		if (T[y].r)
			if (t==T[y].s[0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==T[T[y].fa].s[0])
				if (t==T[y].s[0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==T[y].s[1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
}
void access(int x)
{
	int y=0;
	for (;x;y=x,x=T[x].fa)
	{
		splay(x);
		pushdown(x);
		T[T[x].s[1]].r=true;
		T[x].s[1]=y;
		T[y].r=false;
		update(x);
	}
}
void makeroot(int x)
{
	access(x);
	splay(x);
	T[x].rev();
}
void link(int x,int y)
{
	//printf(&quot;link %d %d\n&quot;,x,y);
	makeroot(x);
	splay(x);
	T[x].fa=y;
}
void cut(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	T[x].r=true;
	T[x].fa=T[y].s[0]=0;
}
int getroot(int x)
{
	access(x);
	splay(x);
	pushdown(x);
	while (T[x].s[0])
	{
		x=T[x].s[0];
		pushdown(x);
	}
	splay(x);
	return x;
}
void jiaru(int id,int u,int v,int w)
{
	if (getroot(u)==getroot(v))
	{
		makeroot(u);
		access(v),splay(v);
		if (T[T[v].mxid].key&lt;=w) return;
		int t=T[v].mxid;
		cut(e[from[t]].u,t);
		cut(t,e[from[t]].v);
		T[t].s[0]=T[t].s[1]=T[t].fa=0;
		T[t].key=w,T[t].mxid=t,T[t].r=true;
		from[t]=id;
		link(u,t),link(t,v);
	}
	else
	{
		int t=++TTT;
		T[t].key=w,T[t].r=true,T[t].mxid=t;
		from[t]=id;
		link(u,t),link(t,v);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	read(n),read(m);
	int i;
	for (i=1;i&lt;=m;i++) e[i].in();
	sort(e+1,e+m+1);
	//for (i=1;i&lt;=m;i++) e[i].out();ln;
	for (i=1;i&lt;=n;i++)
		T[i].r=true,T[i].key=0,T[i].mxid=i;
	TTT=n;
	int ans=inf;
	for (i=1;i&lt;=m;i++)
	{
		jiaru(i,e[i].u,e[i].v,e[i].B);
		if (getroot(1)==getroot(n))
		{
			makeroot(1);
			access(n),splay(n);
			ans=min(ans,e[i].A+T[T[n].mxid].key);
		}
	}
	if (ans&lt;inf) printf(&quot;%d\n&quot;,ans);
	else printf(&quot;-1\n&quot;);
	return 0;
}<pre><h2>Problem3670</h2><pre>const
  mo=1000000007;
var
  s:ansistring;
  p,cnt:array[0..1000000]of longint;
  ans:int64;
  tt,len:longint;
  i,j,oo:longint;
begin
  //assign(input,'aoo.in');reset(input);
  //assign(output,'aoo.out');rewrite(output);
  readln(tt);
  for oo:=1 to tt do
    begin
      readln(s);
      j:=0;
      p[1]:=0;
      cnt[1]:=1;
      len:=length(s);
      for i:=2 to len do
        begin
          while(s[j+1]&lt;&gt;s[i])and(j&gt;0)do j:=p[j];
          if s[j+1]=s[i] then inc(j);
          p[i]:=j;
          cnt[i]:=cnt[j]+1;
        end;
      ans:=1;
      j:=0;
      for i:=2 to len do
        begin
          while(s[j+1]&lt;&gt;s[i])and(j&gt;0)do j:=p[j];
          if s[j+1]=s[i] then inc(j);
          while j&lt;&lt;1&gt;i do j:=p[j];
          ans:=ans*(cnt[j]+1)mod mo;
        end;
      writeln(ans);
    end;
  //close(input);close(output);
end.<pre><h2>Problem3670</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mo 1000000007
#define limit 999999999999ll
long long ans;
int tes,tot,len,o[1001111],aa[1001111][2],next[1001111],c[1001111];
char s[1001111];
void change(int i,int x)
{
	if (!i) return;
	for (;i&lt;=len;i+=(i&amp;-i)) c[i]+=x;
}
int getsum(int i)
{
	int res=0;
	for (;i;i-=(i&amp;-i)) res+=c[i];
	return res+1;
}
void dfs(int v)
{
	ans=ans*getsum(v/2);
	if (ans&gt;limit) ans%=mo;
	change(v,1);
	for (int p=o[v];p;p=aa[p][0]) dfs(aa[p][1]);
	change(v,-1);
}
void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d\n&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%s\n&quot;,s+1);
		next[1]=0;
		int j=0,i;
		len=strlen(s+1);
		memset(o,0,4*(len+10));
		tot=0;
		addedge(0,1);
		for (i=2;i&lt;=len;i++)
		{
			while (s[j+1]!=s[i]&amp;&amp;j&gt;0) j=next[j];
			if (s[j+1]==s[i]) j++;
			next[i]=j;
			addedge(j,i);
		}
		ans=1;
		dfs(0);
		if (ans&gt;mo) ans%=mo;
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}
<pre><h2>Problem3670</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mo 1000000007
#define limit 999999999999ll
long long ans;
int tes,tot,len,o[1001111],aa[1001111][2],next[1001111],c[1001111],stack[1001111],now[1001111];
char s[1001111];
void change(int i,int x)
{
	if (!i) return;
	for (;i&lt;=len;i+=(i&amp;-i)) c[i]+=x;
}
int getsum(int i)
{
	int res=0;
	for (;i;i-=(i&amp;-i)) res+=c[i];
	return res+1;
}
void dfs()
{
	int top;
	stack[top=1]=0;
	now[0]=o[0];
	while (top&gt;0)
	{
		int v=stack[top];
		int p=now[v];
		if (p==o[v])
		{
			ans=ans*getsum(v/2);
			if (ans&gt;limit) ans%=mo;
			change(v,1);
		}
		if (p==0)
		{
			change(v,-1);
			top--;
			continue;
		}
		now[v]=aa[p][0];
		int y=aa[p][1];
		stack[++top]=y;
		now[y]=o[y];
	}
}
void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d\n&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%s\n&quot;,s+1);
		next[1]=0;
		int j=0,i;
		len=strlen(s+1);
		memset(o,0,4*(len+10));
		tot=0;
		addedge(0,1);
		for (i=2;i&lt;=len;i++)
		{
			while (s[j+1]!=s[i]&amp;&amp;j&gt;0) j=next[j];
			if (s[j+1]==s[i]) j++;
			next[i]=j;
			addedge(j,i);
		}
		ans=1;
		dfs();
		if (ans&gt;mo) ans%=mo;
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}
<pre><h2>Problem3670</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
#define mo 1000000007
#define ln printf(&quot;\n&quot;)
const int NN=1001111;
char s[NN];
int o[NN],sta[NN],num[NN],next[NN],aa[NN][2];
int tes,n,now,top,tot;
inline void addedge(int p,int q)
{
	//printf(&quot;addedge %d %d\n&quot;,p,q);
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs(int v)
{
	while (now&lt;top&amp;&amp;sta[now+1]*2&lt;=v) now++;
	//printf(&quot;dfs %d   now=%d\n&quot;,v,now);printf(&quot;sta: &quot;);for(int i=1;i&lt;=top;i++)printf(&quot;%d &quot;,sta[i]);ln;
	num[v]=now;
	sta[++top]=v;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		dfs(y);
	}
	top--;
	while (now&gt;0&amp;&amp;sta[now]*2&gt;sta[top]) now--;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d\n&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%s\n&quot;,s+1);
		//printf(&quot;\n--------------------------  s=%s  ------------------------------\n&quot;,s+1);
		n=strlen(s+1);
		//printf(&quot;n=%d\n&quot;,n);
		int i,j;
		j=0,next[1]=0;
		for (i=2;i&lt;=n;i++)
		{
			while (j&amp;&amp;s[j+1]!=s[i]) j=next[j];
			if (s[j+1]==s[i]) j++;
			next[i]=j;
		}
		//printf(&quot;next: &quot;);for(i=1;i&lt;=n;i++)printf(&quot;%d &quot;,next[i]);ln;
		tot=0;
		for (i=0;i&lt;=n;i++) o[i]=0;
		for (i=1;i&lt;=n;i++) addedge(next[i],i);
		top=0,now=0;
		dfs(0);
		//printf(&quot;num: &quot;);for(i=1;i&lt;=n;i++)printf(&quot;%d &quot;,num[i]);ln;
		LL ans=1;
		for (i=1;i&lt;=n;i++)
			ans=ans*num[i]%mo;
		printf(&quot;%d\n&quot;,(int)ans);
	}
	return 0;
}<pre><h2>Problem3671</h2><pre>#include&lt;cstdio&gt;
typedef long long LL;
int T[25000001];
int X,A,B,C,D,K,Q,n,m;
bool flag[5001][5001];
struct ppt
{
	short x,y;
} pos[25000001];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d%d%d&quot;,&amp;X,&amp;A,&amp;B,&amp;C,&amp;D);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;Q);
	int K=n*m;
	for (int i=1;i&lt;=K;i++) T[i]=i;
	//printf(&quot;0\n&quot;);
	for (int i=1;i&lt;=K;i++)
	{
		X=((LL)A*X%D*X+(LL)B*X%D+C)%D;
		//printf(&quot;X=%d\n&quot;,X);
		int t=X%i+1;
		int tt=T[i];T[i]=T[t];T[t]=tt;
	}
	//printf(&quot;0\n&quot;);
	for (int i=1;i&lt;=Q;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;A,&amp;B);
		int t=T[A];T[A]=T[B];T[B]=t;
	}
	//for (int i=1;i&lt;=n*m;i++) printf(&quot;%d &quot;,T[i]);printf(&quot;\n&quot;);
	for (int i=1;i&lt;=K;i++)
	{
		bool t=(i%m);
		pos[T[i]].x=t?i/m+1:i/m;
		pos[T[i]].y=t?i%m:m;
	}
	for (int now=1,cnt=0;now&lt;=K;now++)
	{
		int x=pos[now].x,y=pos[now].y;
		if (flag[x][y]) continue;
		cnt++;
		printf(cnt==n+m-1?&quot;%d\n&quot;:&quot;%d &quot;,now);
		if (cnt==n+m-1) break;
		for (int i=x-1;i&amp;&amp;!flag[i][y+1];i--)
			for (int j=y+1;j&lt;=m&amp;&amp;!flag[i][j];j++) flag[i][j]=true;
		for (int i=x+1;i&lt;=n&amp;&amp;!flag[i][y-1];i++)
			for (int j=y-1;j&amp;&amp;!flag[i][j];j--) flag[i][j]=true;
	}
	return 0;
}<pre><h2>Problem3671</h2><pre>#include&lt;cstdio&gt;
typedef long long LL;
int T[25000001];
int X,A,B,C,D,K,Q,n,m;
bool flag[5001][5001];
struct ppt
{
	short x,y;
} pos[25000001];
int getint()
{
	char ch=getchar();
	int tmp=0;
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9')
		tmp=tmp*10+ch-'0',ch=getchar();
	return tmp;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	X=getint(),A=getint(),B=getint(),C=getint(),D=getint();
	n=getint(),m=getint(),Q=getint();
	int K=n*m;
	for (int i=1;i&lt;=K;i++) T[i]=i;
	//printf(&quot;0\n&quot;);
	for (int i=1;i&lt;=K;i++)
	{
		X=((LL)A*X%D*X+(LL)B*X%D+C)%D;
		//printf(&quot;X=%d\n&quot;,X);
		int t=X%i+1;
		int tt=T[i];T[i]=T[t];T[t]=tt;
	}
	//printf(&quot;0\n&quot;);
	for (int i=1;i&lt;=Q;i++)
	{
		A=getint(),B=getint();
		int t=T[A];T[A]=T[B];T[B]=t;
	}
	//for (int i=1;i&lt;=n*m;i++) printf(&quot;%d &quot;,T[i]);printf(&quot;\n&quot;);
	for (int i=1;i&lt;=K;i++)
	{
		bool t=(i%m);
		pos[T[i]].x=t?i/m+1:i/m;
		pos[T[i]].y=t?i%m:m;
	}
	for (int now=1,cnt=0;now&lt;=K;now++)
	{
		int x=pos[now].x,y=pos[now].y;
		if (flag[x][y]) continue;
		cnt++;
		printf(cnt==n+m-1?&quot;%d\n&quot;:&quot;%d &quot;,now);
		if (cnt==n+m-1) break;
		for (int i=x-1;i&amp;&amp;!flag[i][y+1];i--)
			for (int j=y+1;j&lt;=m&amp;&amp;!flag[i][j];j++) flag[i][j]=true;
		for (int i=x+1;i&lt;=n&amp;&amp;!flag[i][y-1];i++)
			for (int j=y-1;j&amp;&amp;!flag[i][j];j--) flag[i][j]=true;
	}
	return 0;
}<pre><h2>Problem3671</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=5001;
int n,m,q;
long long x,a,b,c,d;
int getint(){
	int res=0;
	char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))(res*=10)+=ch-'0',ch=getchar();
	return res;
}
int rnd(){
	return x=(x*(a*x+b)+c)%d;
}
int t[maxn*maxn];
int pos[maxn*maxn];
int up[maxn],down[maxn];
int main(){//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
	x=getint();a=getint();
	b=getint();c=getint();
	d=getint();n=getint();
	m=getint();q=getint();
	for(int i=1;i&lt;=n*m;i++)t[i]=i;
	for(int i=1;i&lt;=n;i++)up[i]=m,down[i]=1;
	for(int i=1;i&lt;=n*m;i++)swap(t[i],t[(rnd()%i)+1]);
	for(int i=1;i&lt;=q;i++){
		int u=getint(),v=getint();
		swap(t[u],t[v]);
	}
	//for (int i=1;i&lt;=n*m;i++) printf(&quot;%d &quot;,t[i]);printf(&quot;\n&quot;);
	for(int i=1;i&lt;=n*m;i++)pos[t[i]]=i;
	int x,y,tot=0;
	for(int i=1;i&lt;=n*m;i++){
		if(pos[i]%m)x=pos[i]/m+1;else x=pos[i]/m;
		y=pos[i]%m?pos[i]%m:m;
		if(y&lt;=up[x]&amp;&amp;y&gt;=down[x]){
        	for(int j=1;j&lt;=n;j++)
        	if(j&lt;x)up[j]=min(y,up[j]);
        	else if(j&gt;x)down[j]=max(y,down[j]);
        	tot++;
        	printf(&quot;%d%c&quot;,i,&quot; \n&quot;[tot==n+m-1]);//drcow神犇的换行方式
			if(tot==n+m-1)break;
		}
	}
	
	return 0;
}<pre><h2>Problem3671</h2><pre>#include&lt;cstdio&gt;
typedef long long LL;
int T[25000001];
int X,A,B,C,D,K,Q,n,m;
bool flag[5001][5001];
struct ppt
{
	short x,y;
} pos[25000001];
int getint()
{
	char ch=getchar();
	int tmp=0;
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9')
		tmp=tmp*10+ch-'0',ch=getchar();
	return tmp;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	X=getint(),A=getint(),B=getint(),C=getint(),D=getint();
	n=getint(),m=getint(),Q=getint();
	int K=n*m;
	for (int i=1;i&lt;=K;i++) T[i]=i;
	//printf(&quot;0\n&quot;);
	for (int i=1;i&lt;=K;i++)
	{
		X=((LL)A*X%D*X+(LL)B*X%D+C)%D;
		//printf(&quot;X=%d\n&quot;,X);
		int t=X%i+1;
		int tt=T[i];T[i]=T[t];T[t]=tt;
	}
	//printf(&quot;0\n&quot;);
	for (int i=1;i&lt;=Q;i++)
	{
		A=getint(),B=getint();
		int t=T[A];T[A]=T[B];T[B]=t;
	}
	//for (int i=1;i&lt;=n*m;i++) printf(&quot;%d &quot;,T[i]);printf(&quot;\n&quot;);
	for (int i=1;i&lt;=K;i++)
	{
		bool t=(i%m);
		pos[T[i]].x=t?i/m+1:i/m;
		pos[T[i]].y=t?i%m:m;
	}
	for (int now=1,cnt=0;now&lt;=K;now++)
	{
		int x=pos[now].x,y=pos[now].y;
		if (flag[x][y]) continue;
		cnt++;
		printf(cnt==n+m-1?&quot;%d\n&quot;:&quot;%d &quot;,now);
		if (cnt==n+m-1) break;
		bool *it;
		int i,j;
		for (i=x-1;i&amp;&amp;!flag[i][y+1];i--)
			for (j=y+1,it=&amp;flag[i][j];j&lt;=m&amp;&amp;!*it;j++,it++) *it=true;
		for (i=x+1;i&lt;=n&amp;&amp;!flag[i][y-1];i++)
			for (j=y-1,it=&amp;flag[i][j];j&amp;&amp;!*it;j--,it--) *it=true;
	}
	return 0;
}<pre><h2>Problem3672</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
#define ln printf(&quot;\n&quot;)
typedef long long LL;
typedef double DD;
const int NN=201111;
int o[NN],fa[NN],ff[NN],deep[NN],size[NN],aa[NN*2][3],a[NN],b[NN],q[NN];
int n,tot=1,num;
LL dist[NN],s[NN],P[NN],Q[NN],f[NN],L[NN];
DD xie[NN];
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
void out(DD *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%.3f &quot;,a[i]);ln;}
void out(LL *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%lld &quot;,a[i]);ln;}
void calcsize(int v)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==ff[v]||deep[y]&lt;deep[v]) continue;
		ff[y]=v;
		calcsize(y);
		size[v]+=size[y];
	}
}
int findcore(int v)
{
	ff[v]=0;
	calcsize(v);
	for (;;)
	{
		bool flag=true;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (deep[y]&lt;deep[v]) continue;
			if (size[y]*2&gt;size[v])
			{
				size[v]-=size[y];
				size[y]+=size[v];
				v=y;
				flag=false;
				break;
			}
		}
		if (flag) return v;
	}
}
void dfs1(int v)
{
	b[++b[0]]=v;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]||y==ff[v]) continue;
		ff[y]=v;
		dfs1(y);
	}
}
DD getk(int x,int y) {return (f[x]-f[y])*1.0/(dist[x]-dist[y]);}
void ins(int x)
{
	while (num&gt;1&amp;&amp;getk(x,q[num])&gt;xie[num]) num--;
	q[++num]=x;
	if (num==1) xie[1]=inf;
	else xie[num]=getk(q[num],q[num-1]);
}
int cha(int P)
{
	if (num==0) return -1;
	int res=num;
	int l=1,r=num;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (xie[mid]&lt;P) res=mid-1,r=mid-1;
		else l=mid+1;
	}
	return q[res];
}
bool cmp(int a,int b) {return dist[a]-L[a]&gt;dist[b]-L[b];}
void update()
{
	//printf(&quot;  ====== update =======\n&quot;);
	sort(b+1,b+b[0]+1,cmp);
	//printf(&quot;  a &quot;);out(a,1,a[0]);printf(&quot;  b &quot;);out(b,1,b[0]);
	int now=1;
	num=0;
	for (int i=1;i&lt;=b[0];i++)
	{
		int t=b[i];
		for (;now&lt;=a[0]&amp;&amp;dist[a[now]]&gt;=dist[t]-L[t];now++) ins(a[now]);
		//printf(&quot;  num=%d   q &quot;,num);out(q,1,num);printf(&quot;  xie &quot;);out(xie,1,num);
		int j=cha(P[t]);
		//if (j!=-1) printf(&quot;  转移: %d-&gt;%d\n&quot;,j,t); 
		if (j!=-1) f[t]=min(f[t],f[j]+(dist[t]-dist[j])*P[t]+Q[t]);
	}
	//ln;//DEL DEL DEL DEL DEL DEL DEL DEL 
}
void work(int v)
{
	//printf(&quot;\n----------- work %d -----------------------\n&quot;,v);
	int y;
	y=fa[v];
	if (deep[y]&gt;=deep[v])
	{
		y=findcore(y);
		deep[y]=deep[v]+1;
		work(y);
	}
	a[0]=0;
	for (y=fa[v];deep[y]&gt;=deep[v];y=fa[y]) a[++a[0]]=y;
	for (int i=1;i&lt;=a[0];i++)
	{
		int j=a[i];
		if (dist[v]-dist[j]&lt;=L[v])
			f[v]=min(f[v],f[j]+(dist[v]-dist[j])*P[v]+Q[v]);
	}
	a[a[0]=1]=v;
	for (y=fa[v];deep[y]&gt;=deep[v];y=fa[y]) a[++a[0]]=y;
	b[0]=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]||y==fa[v]) continue;
		ff[y]=0;
		dfs1(y);
	}
	update();
	//printf(&quot;f &quot;);out(f,1,n);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]||y==fa[v]) continue;
		y=findcore(y);
		deep[y]=deep[v]+1;
		work(y);
	}
}
void dfs(int v)
{
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		dist[y]=dist[v]+s[y];
		dfs(y);
	}
}
void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i;
	for (scanf(&quot;%d&quot;,&amp;i),i=2;i&lt;=n;i++)
	{
		scanf(&quot;%d%lld%lld%lld%lld&quot;,&amp;fa[i],&amp;s[i],&amp;P[i],&amp;Q[i],&amp;L[i]);
		addedge(fa[i],i),addedge(i,fa[i]);
	}
	dfs(1);
	//printf(&quot;dist &quot;);out(dist,1,n);
	memset(f,60,sizeof(f));
	f[1]=0;
	memset(deep,60,sizeof(deep));
	deep[0]=0;
	deep[1]=1;
	work(1);
	//f[9]=min(f[9],f[8]+(dist[9]-dist[8])*P[9]+Q[9]);
	//ln;ln;
	for (i=2;i&lt;=n;i++) printf(&quot;%lld\n&quot;,f[i]);
	return 0;
}<pre><h2>Problem3672</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
typedef long long LL;
typedef double DD;
const int NN=201111;
int o[NN],fa[NN],ff[NN],deep[NN],size[NN],aa[NN*2][3],a[NN],b[NN],q[NN];
int n,tot=1,num;
LL dist[NN],s[NN],P[NN],Q[NN],f[NN],L[NN];
DD xie[NN];
void calcsize(int v)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==ff[v]||deep[y]&lt;deep[v]) continue;
		ff[y]=v;
		calcsize(y);
		size[v]+=size[y];
	}
}
int findcore(int v)
{
	ff[v]=0;
	calcsize(v);
	for (;;)
	{
		bool flag=true;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (deep[y]&lt;deep[v]) continue;
			if (size[y]*2&gt;size[v])
			{
				size[v]-=size[y];
				size[y]+=size[v];
				v=y;
				flag=false;
				break;
			}
		}
		if (flag) return v;
	}
}
void dfs1(int v)
{
	b[++b[0]]=v;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]||y==ff[v]) continue;
		ff[y]=v;
		dfs1(y);
	}
}
DD getk(int x,int y) {return (f[x]-f[y])*1.0/(dist[x]-dist[y]);}
void ins(int x)
{
	while (num&gt;1&amp;&amp;getk(x,q[num])&gt;xie[num]) num--;
	q[++num]=x;
	if (num==1) xie[1]=inf;
	else xie[num]=getk(q[num],q[num-1]);
}
int cha(int P)
{
	if (num==0) return -1;
	int res=num;
	int l=1,r=num;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (xie[mid]&lt;P) res=mid-1,r=mid-1;
		else l=mid+1;
	}
	return q[res];
}
bool cmp(int a,int b) {return dist[a]-L[a]&gt;dist[b]-L[b];}
void update()
{
	sort(b+1,b+b[0]+1,cmp);
	int now=1;
	num=0;
	for (int i=1;i&lt;=b[0];i++)
	{
		int t=b[i];
		for (;now&lt;=a[0]&amp;&amp;dist[a[now]]&gt;=dist[t]-L[t];now++) ins(a[now]);
		int j=cha(P[t]);
		if (j!=-1) f[t]=min(f[t],f[j]+(dist[t]-dist[j])*P[t]+Q[t]);
	}
}
void work(int v)
{
	int y;
	y=fa[v];
	if (deep[y]&gt;=deep[v])
	{
		y=findcore(y);
		deep[y]=deep[v]+1;
		work(y);
	}
	a[0]=0;
	for (y=fa[v];deep[y]&gt;=deep[v];y=fa[y]) a[++a[0]]=y;
	for (int i=1;i&lt;=a[0];i++)
	{
		int j=a[i];
		if (dist[v]-dist[j]&lt;=L[v])
			f[v]=min(f[v],f[j]+(dist[v]-dist[j])*P[v]+Q[v]);
	}
	a[a[0]=1]=v;
	for (y=fa[v];deep[y]&gt;=deep[v];y=fa[y]) a[++a[0]]=y;
	b[0]=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]||y==fa[v]) continue;
		ff[y]=0;
		dfs1(y);
	}
	update();
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]||y==fa[v]) continue;
		y=findcore(y);
		deep[y]=deep[v]+1;
		work(y);
	}
}
void dfs(int v)
{
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		dist[y]=dist[v]+s[y];
		dfs(y);
	}
}
void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i;
	for (scanf(&quot;%d&quot;,&amp;i),i=2;i&lt;=n;i++)
	{
		scanf(&quot;%d%lld%lld%lld%lld&quot;,&amp;fa[i],&amp;s[i],&amp;P[i],&amp;Q[i],&amp;L[i]);
		addedge(fa[i],i),addedge(i,fa[i]);
	}
	dfs(1);
	memset(f,60,sizeof(f));
	f[1]=0;
	memset(deep,60,sizeof(deep));
	deep[0]=0;
	deep[1]=1;
	work(1);
	for (i=2;i&lt;=n;i++) printf(&quot;%lld\n&quot;,f[i]);
	return 0;
}<pre><h2>Problem3673</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define NN 21111
#define VV 401111
int root[NN],lc[VV],rc[VV],fa[VV],deep[NN];
int n,m,TTT;
void build(int &amp;v,int l,int r)
{
	if (!v) v=++TTT;
	if (r-l==1)
	{
		fa[v]=l;
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(lc[v],l,mid);
	build(rc[v],mid,r);
}
int find(int v,int l,int r,int x)
{
	if (r-l==1) return v;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid) return find(lc[v],l,mid,x);
	else return find(rc[v],mid,r,x);
}
int getfa(int v,int x)
{
	for (;;)
	{
		int t=find(v,1,n+1,x);
		if (fa[t]==x) return x;
		x=fa[t];
	}
}
void ins(int &amp;v,int u,int l,int r,int x,int y)
{
	if (!v) v=++TTT;
	if (r-l==1) {fa[v]=y;return;}
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid)
	{
		rc[v]=rc[u];
		ins(lc[v],lc[u],l,mid,x,y);
	}
	else
	{
		lc[v]=lc[u];
		ins(rc[v],rc[u],mid,r,x,y);
	}
}
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	build(root[0],1,n+1);
	int i,x,y,kind;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;kind);
		if (kind==1)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x=getfa(root[i-1],x),y=getfa(root[i-1],y);
			if (x==y) {root[i]=root[i-1];continue;}
			if (deep[x]&gt;deep[y]) swap(x,y);
			ins(root[i],root[i-1],1,n+1,x,y);
			if (deep[x]==deep[y]) deep[y]++;
		}
		else if (kind==2)
		{
			scanf(&quot;%d&quot;,&amp;x);
			root[i]=root[x];
		}
		else
		{
			root[i]=root[i-1];
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x=getfa(root[i],x),y=getfa(root[i],y);
			printf(&quot;%d\n&quot;,x==y?1:0);
		}
	}
	return 0;
}
<pre><h2>Problem3674</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define NN 201111
#define VV 10001111
int root[NN],lc[VV],rc[VV],fa[VV],deep[NN];
int n,m,TTT;
void build(int &amp;v,int l,int r)
{
	if (!v) v=++TTT;
	if (r-l==1)
	{
		fa[v]=l;
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(lc[v],l,mid);
	build(rc[v],mid,r);
}
int find(int v,int l,int r,int x)
{
	if (r-l==1) return v;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid) return find(lc[v],l,mid,x);
	else return find(rc[v],mid,r,x);
}
int getfa(int v,int x)
{
	for (;;)
	{
		int t=find(v,1,n+1,x);
		if (fa[t]==x) return x;
		x=fa[t];
	}
}
void ins(int &amp;v,int u,int l,int r,int x,int y)
{
	if (!v) v=++TTT;
	if (r-l==1) {fa[v]=y;return;}
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid)
	{
		rc[v]=rc[u];
		ins(lc[v],lc[u],l,mid,x,y);
	}
	else
	{
		lc[v]=lc[u];
		ins(rc[v],rc[u],mid,r,x,y);
	}
}
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	build(root[0],1,n+1);
	int i,x,y,kind,lastans=0;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;kind);
		if (kind==1)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x^=lastans,y^=lastans;
			x=getfa(root[i-1],x),y=getfa(root[i-1],y);
			if (x==y) {root[i]=root[i-1];continue;}
			if (deep[x]&gt;deep[y]) swap(x,y);
			ins(root[i],root[i-1],1,n+1,x,y);
			if (deep[x]==deep[y]) deep[y]++;
		}
		else if (kind==2)
		{
			scanf(&quot;%d&quot;,&amp;x);
			root[i]=root[x^lastans];
		}
		else
		{
			root[i]=root[i-1];
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x^=lastans,y^=lastans;
			x=getfa(root[i],x),y=getfa(root[i],y);
			printf(&quot;%d\n&quot;,lastans=(x==y?1:0));
		}
	}
	return 0;
}
<pre><h2>Problem3674</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define NN 201111
#define VV 5001111
int root[NN],lc[VV],rc[VV],fa[VV],deep[NN];
int n,m,TTT;
void build(int &amp;v,int l,int r)
{
	if (!v) v=++TTT;
	if (r-l==1)
	{
		fa[v]=l;
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(lc[v],l,mid);
	build(rc[v],mid,r);
}
int find(int v,int l,int r,int x)
{
	if (r-l==1) return v;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid) return find(lc[v],l,mid,x);
	else return find(rc[v],mid,r,x);
}
int getfa(int v,int x)
{
	for (;;)
	{
		int t=find(v,1,n+1,x);
		if (fa[t]==x) return x;
		x=fa[t];
	}
}
void ins(int &amp;v,int u,int l,int r,int x,int y)
{
	if (!v) v=++TTT;
	if (r-l==1) {fa[v]=y;return;}
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid)
	{
		rc[v]=rc[u];
		ins(lc[v],lc[u],l,mid,x,y);
	}
	else
	{
		lc[v]=lc[u];
		ins(rc[v],rc[u],mid,r,x,y);
	}
}
void swap(int &amp;a,int &amp;b) {int t=a;a=b;b=t;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	build(root[0],1,n+1);
	int i,x,y,kind,lastans=0;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;kind);
		if (kind==1)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x^=lastans,y^=lastans;
			x=getfa(root[i-1],x),y=getfa(root[i-1],y);
			if (x==y) {root[i]=root[i-1];continue;}
			if (deep[x]&gt;deep[y]) swap(x,y);
			ins(root[i],root[i-1],1,n+1,x,y);
			if (deep[x]==deep[y]) deep[y]++;
		}
		else if (kind==2)
		{
			scanf(&quot;%d&quot;,&amp;x);
			root[i]=root[x^lastans];
		}
		else
		{
			root[i]=root[i-1];
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x^=lastans,y^=lastans;
			x=getfa(root[i],x),y=getfa(root[i],y);
			printf(&quot;%d\n&quot;,lastans=(x==y?1:0));
		}
	}
	return 0;
}
<pre><h2>Problem3675</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define inf 9999999999999999ll
#define ln printf(&quot;\n&quot;)
const int NN=100005;
int n,m,now;
LL sum[NN],f[NN][2];
struct point
{
	LL x,y; int id;
	point(LL a=0,LL b=0,int c=0) {x=a;y=b;id=c;}
} q[NN];
inline bool check(point t,point k,point i)
{
	return (i.y-k.y)*(k.x-t.x)&lt;=(k.y-t.y)*(i.x-k.x);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m); m++;
	int i,x,j;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		sum[i]=sum[i-1]+x;
	}
	for (i=0;i&lt;=n;i++)
		for (j=0;j&lt;=2;j++) f[i][j]=-inf;
	f[0][0]=0;
	now=1;
	for (j=1;j&lt;=m;j++)
	{
		//printf(&quot;\n--------------------------------------------------------------------\n&quot;);
		for (i=0;i&lt;=m;i++) f[i][now]=-inf;
		int head=0,tail=1;
		q[1]=point(0,f[0][now^1]);
		for (i=1;i&lt;=n;i++)
		{
			//for (int l=head+1;l&lt;=tail;l++) printf(&quot;%d &quot;,q[l].id);ln;
			int t=head+1,k=head+2;
			while (head&lt;tail-1&amp;&amp;(q[k].x-q[t].x)*sum[i]&lt;=q[k].y-q[t].y)
			{
				//printf(&quot;%I64d %I64d %I64d %I64d\n&quot;,q[k].x,q[k].y,q[t].x,q[t].y);
				head++;
				t=head+1,k=head+2;
			}
			//for (int l=head+1;l&lt;=tail;l++) printf(&quot;%d &quot;,q[l].id);ln;
			k=q[head+1].id;
			//printf(&quot;k=%d\n&quot;,k);printf(&quot;%I64d\n&quot;,f[k][now^1]);
			f[i][now]=f[k][now^1]+sum[k]*(sum[i]-sum[k]);
			//printf(&quot;f[%d][%d]=%I64d\n&quot;,i,j,f[i][now]);
			point P(-sum[i],f[i][now^1]-sum[i]*sum[i],i);
			t=tail-1,k=tail;
			while (head&lt;tail-1&amp;&amp;check(q[t],q[k],P))
			{
				tail--;
				t=tail-1,k=tail;
			}
			q[++tail]=P;
		}
		now^=1;
	}
	printf(&quot;%lld&quot;,f[n][now^1]);
	return 0;
}<pre><h2>Problem3676</h2><pre>#include&lt;cstdio&gt;

#include&lt;cstdlib&gt;

#include&lt;cmath&gt;

#include&lt;cstring&gt;

#include&lt;algorithm&gt;

#include&lt;iostream&gt;

#include&lt;vector&gt;

#include&lt;map&gt;

#include&lt;set&gt;

#include&lt;queue&gt;

#include&lt;string&gt;

#define inf 1000000000

#define maxn 650000+5

#define maxm 20000000+5

#define eps 1e-10

#define ll long long

#define pa pair&lt;int,int&gt;

#define for0(i,n) for(int i=0;i&lt;=(n);i++)

#define for1(i,n) for(int i=1;i&lt;=(n);i++)

#define for2(i,x,y) for(int i=(x);i&lt;=(y);i++)

#define for3(i,x,y) for(int i=(x);i&gt;=(y);i--)

#define mod 1000000007

using namespace std;

inline int read()

{

    int x=0,f=1;char ch=getchar();

    while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}

    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=10*x+ch-'0';ch=getchar();}

    return x*f;

}
int n,m;
int t1[maxn],t2[maxn],c[maxn],a[maxn],sa[maxn],rk[maxn],h[maxn],st[maxn][20];
int b[maxn],p[maxn];
char s[maxn];
void getsa(int m)
{
    int *x=t1,*y=t2;
    for0(i,m)c[i]=0;
    for0(i,n)c[x[i]=a[i]]++;
    for1(i,m)c[i]+=c[i-1];
    for3(i,n,0)sa[--c[x[i]]]=i;
    for(int k=1;k&lt;=n+1;k&lt;&lt;=1)
    {
        int p=0;
        for2(i,n-k+1,n)y[p++]=i;
        for0(i,n)if(sa[i]&gt;=k)y[p++]=sa[i]-k;
        for0(i,m)c[i]=0;
        for0(i,n)c[x[y[i]]]++;
        for1(i,m)c[i]+=c[i-1];
        for3(i,n,0)sa[--c[x[y[i]]]]=y[i];
        swap(x,y);p=0;x[sa[0]]=0;
        for1(i,n)x[sa[i]]=y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+k]==y[sa[i-1]+k]?p:++p;
        if(p&gt;=n)break;
        m=p;
    }
    for1(i,n)rk[sa[i]]=i;
    for(int i=0,k=0,j;i&lt;n;h[rk[i++]]=k)
        for(k?k--:0,j=sa[rk[i]-1];a[i+k]==a[j+k];k++);
}
void getst()
{
    int k=log2(n);
    for1(i,n)st[i][0]=h[i];
    for1(j,k)for1(i,n-(1&lt;&lt;j)+1)st[i][j]=min(st[i][j-1],st[i+(1&lt;&lt;(j-1))][j-1]);
}
inline int rmq(int x,int y)
{
    int k=log2(y-x+1);
    return min(st[x][k],st[y-(1&lt;&lt;k)+1][k]);
}
inline ll query(int x,int y)
{
    int l,r,mid,ql,qr;
    if(h[x+1]&lt;y)qr=x;
    else
    {
        l=x+1;r=n;
        while(l&lt;=r)
        {
            mid=(l+r)&gt;&gt;1;
            if(rmq(x+1,mid)&gt;=y)l=mid+1;else r=mid-1;
        }
        qr=r;
    }
    if(h[x]&lt;y)ql=x;
    else
    {
        l=1;r=x-1;
        while(l&lt;=r)
        {
            mid=(l+r)&gt;&gt;1;
            //cout&lt;&lt;l&lt;&lt;' '&lt;&lt;mid&lt;&lt;' '&lt;&lt;r&lt;&lt;endl;
            if(rmq(mid+1,x)&gt;=y)r=mid-1;else l=mid+1;
        }
        ql=l;
    }
    //cout&lt;&lt;x&lt;&lt;' '&lt;&lt;y&lt;&lt;' '&lt;&lt;ql&lt;&lt;' '&lt;&lt;qr&lt;&lt;endl;
    /*for2(i,sa[x],sa[x]+y-1)cout&lt;&lt;s[i];
    cout&lt;&lt;' '&lt;&lt;ql&lt;&lt;' '&lt;&lt;qr&lt;&lt;endl;*/
    return (ll)(qr-ql+1)*(ll)y;
}

int main()

{

    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);

    scanf(&quot;%s&quot;,s);n=strlen(s);
    for0(i,n-1)a[i]=s[i]-'a'+1;a[n]=0;
    getsa(26);getst();
    for0(i,n-1)b[(i+1)&lt;&lt;1]=a[i];
    m=(n&lt;&lt;1)+1;
    int id=0,mx=0;ll ans=0;
    for1(i,m)
    {
        if(mx&gt;i)p[i]=min(p[2*id-i],mx-i);
        while(i-p[i]-1&gt;0&amp;&amp;i+p[i]+1&lt;=m&amp;&amp;b[i-p[i]-1]==b[i+p[i]+1])p[i]++;
        if(i+p[i]&gt;mx)
        {
            mx=i+p[i];
            id=i;
            ans=max(ans,query(rk[(i-p[i]-1)&gt;&gt;1],p[i]));
            //cout&lt;&lt;i&lt;&lt;' '&lt;&lt;p[i]&lt;&lt;' '&lt;&lt;(i-p[i]-1&gt;&gt;1)&lt;&lt;' '&lt;&lt;(rk[(i-p[i]-1)&gt;&gt;1])&lt;&lt;endl;
        }
    }
    //for1(i,m)cout&lt;&lt;i&lt;&lt;' '&lt;&lt;b[i]&lt;&lt;' '&lt;&lt;p[i]&lt;&lt;endl;
    printf(&quot;%lld\n&quot;,ans);

    return 0;

}<pre><h2>Problem3676</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 611111
#define mo 1000007
#define LL long long
int sa[NN],sa2[NN],rank[NN],sum[NN],ss[NN],s[NN],wv[NN],height[NN],f[NN][20];
int o[mo],aa[5000000][2],mi1[NN],mi2[NN],hash1[NN],hash2[NN],ma[NN],log[NN];
int tot,len,n;
LL ans;
char sss[NN];
int min(int a,int b) {return a&lt;b?a:b;}
int max(int a,int b) {return a&gt;b?a:b;}
void suffix_array(int *r,int n,int m)
{
	int i,j,p,*x=rank,*y=sa2,*t;
	if (n==1) {sa[1]=rank[1]=1;return;}
	for (i=0;i&lt;=m;i++) sum[i]=0;
	for (i=1;i&lt;=n;i++) sum[x[i]=r[i]]++;
	for (i=1;i&lt;=m;i++) sum[i]+=sum[i-1];
	for (i=n;i;i--) sa[sum[x[i]]--]=i;
	for (p=j=1;p&lt;n;j&lt;&lt;=1,m=p)
	{
		for (p=0,i=n-j+1;i&lt;=n;i++) y[++p]=i;
		for (i=1;i&lt;=n;i++) if (sa[i]&gt;j) y[++p]=sa[i]-j;
		for (i=1;i&lt;=n;i++) wv[i]=x[y[i]];
		for (i=0;i&lt;=m;i++) sum[i]=0;
		for (i=1;i&lt;=n;i++) sum[wv[i]]++;
		for (i=1;i&lt;=m;i++) sum[i]+=sum[i-1];
		for (i=n;i;i--) sa[sum[wv[i]]--]=y[i];
		for (t=x,x=y,y=t,p=1,x[sa[1]]=1,i=2;i&lt;=n;i++)
			x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+j]==y[sa[i-1]+j])?p:++p;
	}
	for (i=1;i&lt;=n;i++) rank[i]=x[i];
	for (p=0,i=1;i&lt;=n;i++)
		if (x[i]&gt;1)
		{
			j=sa[x[i]-1];
			while (r[i+p]==r[j+p]) p++;
			height[x[i]]=p;
			if (p&gt;0) p--;
		}
}
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int getmin(int L,int R)
{
	int len=log[R-L+1];
	return min(f[L][len],f[R-(1&lt;&lt;len)+1][len]);
}
void check(int L,int R)
{
	//printf(&quot;\n======== checking %d %d =========\n&quot;,L,R);
	int t1,t2,p,y,tt,len,pos,res,l,r,mid;
	t1=(hash1[R]-hash1[L-1]*mi1[R-L+1])%mo;
	t2=hash2[R]-hash1[L-1]*mi2[R-L+1];
	for (p=o[t1];p;p=aa[p][0])
	{
		y=aa[p][1];
		if (y!=t2) continue;
		return;
	}
	addedge(t1,t2);
	pos=rank[L];
	tt=0;
	len=R-L+1;
	res=pos;
	l=1,r=pos;
	while (l&lt;=r)
	{
		//printf(&quot;lr %d %d\n&quot;,l,r);
		mid=(l+r)&gt;&gt;1;
		if (getmin(mid,pos)&gt;=len) res=mid-1,r=mid-1;
		else l=mid+1;
	}
	//printf(&quot;%d %d\n&quot;,pos,res);
	tt+=pos-res+1;
	res=pos;
	l=pos+1,r=n;
	while (l&lt;=r)
	{
		mid=(l+r)&gt;&gt;1;
		if (getmin(pos+1,mid)&gt;=len) res=mid,l=mid+1;
		else r=mid-1;
	}
	//printf(&quot;%d %d\n&quot;,pos,res);
	tt+=res-pos;
	//printf(&quot;%d\n&quot;,tt);
	if ((LL)tt*len&gt;ans) ans=(LL)tt*len;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%s&quot;,sss+1);
	int i,j,tmp,right,id;
	for (len=strlen(sss+1),i=1;i&lt;=len;i++) s[i]=sss[i]-'a'+1;
	n=len;
	suffix_array(s,len,300);
	//printf(&quot;sa: &quot;);for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,sa[i]);printf(&quot;\n&quot;);
	//printf(&quot;height: &quot;);for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,height[i]);printf(&quot;\n&quot;);
	for (i=2;i&lt;=len;i++) f[i][0]=height[i];
	for (j=1;j&lt;=19;j++)
		for (i=1;i&lt;=len;i++)
			if (i+(1&lt;&lt;(j-1))&lt;=len)
				f[i][j]=min(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]);
	//for(printf(&quot;\n&quot;),i=1;i&lt;=n;i++){for(j=0;j&lt;=5;j++)printf(&quot;%d &quot;,f[i][j]);printf(&quot;\n&quot;);}printf(&quot;\n&quot;);
	for (log[1]=0,i=2;i&lt;=len;i++)
		log[i]=(i==(i&amp;-i))?log[i-1]+1:log[i-1];
	for (mi1[0]=mi2[0]=1,hash1[0]=hash2[0]=0,i=1;i&lt;=len;i++)
	{
		mi1[i]=mi1[i-1]*31%mo;
		hash1[i]=(hash1[i-1]+s[i]*mi1[i])%mo;
		mi2[i]=mi2[i-1]*19980723;
		hash2[i]=hash2[i-1]+s[i]*mi2[i];
	}
	//printf(&quot;hash1: &quot;);for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,hash1[i]);printf(&quot;\n&quot;);
	//printf(&quot;hash2: &quot;);for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,hash2[i]);printf(&quot;\n&quot;);
	ss[0]=500,ss[1]=333;
	for (i=1;i&lt;=len;i++)
	{
		ss[i*2]=s[i];
		ss[i*2+1]=333;
	}
	ss[len*2+2]=600;
	//printf(&quot;s: &quot;);for (i=1;i&lt;=len;i++) printf(&quot;%d &quot;,s[i]);printf(&quot;\n&quot;);
	//printf(&quot;ss: &quot;);for (i=1;i&lt;=len*2+1;i++) printf(&quot;%d &quot;,ss[i]);printf(&quot;\n&quot;);
	for (right=0,tmp=len*2+1,i=1;i&lt;=tmp;i++)
	{
		//printf(&quot;\n-----------------------------------------------------\n&quot;);
		//if (ss[i]!=333) check(i/2,i/2);
		ma[i]=right&gt;i?min(ma[id*2-i],right-i):1;
		//printf(&quot;ma[%d]=%d\n&quot;,i,ma[i]);
		while (ss[i+ma[i]]==ss[i-ma[i]])
		{
			ma[i]++;
			int L=(ss[i-ma[i]+1]==333)?(i-ma[i]+1)/2+1:(i-ma[i]+1)/2;
			int R=(i+ma[i]-1)/2;
			//printf(&quot;L=%d R=%d\n&quot;,L,R);
			check(L,R);
		}
		//printf(&quot;%d %d\n&quot;,i,ma[i]);
		//printf(&quot;%d\n&quot;,ans);
		if (ma[i]+i&gt;right) right=ma[id=i]+i;
	}
	//printf(&quot;\n\n%d\n\n&quot;,getmin(3,3));
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem3676</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 611111
#define mo 1000007
#define LL long long
int sa[NN],sa2[NN],rank[NN],sum[NN],ss[NN],s[NN],wv[NN],height[NN],f[NN][20];
int o[mo],aa[5000000][2],mi1[NN],mi2[NN],hash1[NN],hash2[NN],ma[NN],log[NN];
int tot,len,n;
LL ans;
char sss[NN];
int min(int a,int b) {return a&lt;b?a:b;}
int max(int a,int b) {return a&gt;b?a:b;}
void suffix_array(int *r,int n,int m)
{
	int i,j,p,*x=rank,*y=sa2,*t;
	if (n==1) {sa[1]=rank[1]=1;return;}
	for (i=0;i&lt;=m;i++) sum[i]=0;
	for (i=1;i&lt;=n;i++) sum[x[i]=r[i]]++;
	for (i=1;i&lt;=m;i++) sum[i]+=sum[i-1];
	for (i=n;i;i--) sa[sum[x[i]]--]=i;
	for (p=j=1;p&lt;n;j&lt;&lt;=1,m=p)
	{
		for (p=0,i=n-j+1;i&lt;=n;i++) y[++p]=i;
		for (i=1;i&lt;=n;i++) if (sa[i]&gt;j) y[++p]=sa[i]-j;
		for (i=1;i&lt;=n;i++) wv[i]=x[y[i]];
		for (i=0;i&lt;=m;i++) sum[i]=0;
		for (i=1;i&lt;=n;i++) sum[wv[i]]++;
		for (i=1;i&lt;=m;i++) sum[i]+=sum[i-1];
		for (i=n;i;i--) sa[sum[wv[i]]--]=y[i];
		for (t=x,x=y,y=t,p=1,x[sa[1]]=1,i=2;i&lt;=n;i++)
			x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+j]==y[sa[i-1]+j])?p:++p;
	}
	for (i=1;i&lt;=n;i++) rank[i]=x[i];
	for (p=0,i=1;i&lt;=n;i++)
		if (x[i]&gt;1)
		{
			j=sa[x[i]-1];
			while (r[i+p]==r[j+p]) p++;
			height[x[i]]=p;
			if (p&gt;0) p--;
		}
}
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int getmin(int L,int R)
{
	int len=log[R-L+1];
	return min(f[L][len],f[R-(1&lt;&lt;len)+1][len]);
}
void check(int L,int R)
{
	//printf(&quot;\n======== checking %d %d =========\n&quot;,L,R);
	int t1,t2,p,y,tt,len,pos,res,l,r,mid;
	t1=(hash1[R]-hash1[L-1]*mi1[R-L+1])%mo;
	t2=hash2[R]-hash1[L-1]*mi2[R-L+1];
	/*for (p=o[t1];p;p=aa[p][0])
	{
		y=aa[p][1];
		if (y!=t2) continue;
		return;
	}*/
	addedge(t1,t2);
	pos=rank[L];
	tt=0;
	len=R-L+1;
	res=pos;
	l=1,r=pos;
	while (l&lt;=r)
	{
		//printf(&quot;lr %d %d\n&quot;,l,r);
		mid=(l+r)&gt;&gt;1;
		if (getmin(mid,pos)&gt;=len) res=mid-1,r=mid-1;
		else l=mid+1;
	}
	//printf(&quot;%d %d\n&quot;,pos,res);
	tt+=pos-res+1;
	res=pos;
	l=pos+1,r=n;
	while (l&lt;=r)
	{
		mid=(l+r)&gt;&gt;1;
		if (getmin(pos+1,mid)&gt;=len) res=mid,l=mid+1;
		else r=mid-1;
	}
	//printf(&quot;%d %d\n&quot;,pos,res);
	tt+=res-pos;
	//printf(&quot;%d\n&quot;,tt);
	if ((LL)tt*len&gt;ans) ans=(LL)tt*len;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%s&quot;,sss+1);
	int i,j,tmp,right,id;
	for (len=strlen(sss+1),i=1;i&lt;=len;i++) s[i]=sss[i]-'a'+1;
	n=len;
	suffix_array(s,len,300);
	//printf(&quot;sa: &quot;);for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,sa[i]);printf(&quot;\n&quot;);
	//printf(&quot;height: &quot;);for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,height[i]);printf(&quot;\n&quot;);
	for (i=2;i&lt;=len;i++) f[i][0]=height[i];
	for (j=1;j&lt;=19;j++)
		for (i=1;i&lt;=len;i++)
			if (i+(1&lt;&lt;(j-1))&lt;=len)
				f[i][j]=min(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]);
	//for(printf(&quot;\n&quot;),i=1;i&lt;=n;i++){for(j=0;j&lt;=5;j++)printf(&quot;%d &quot;,f[i][j]);printf(&quot;\n&quot;);}printf(&quot;\n&quot;);
	for (log[1]=0,i=2;i&lt;=len;i++)
		log[i]=(i==(i&amp;-i))?log[i-1]+1:log[i-1];
	for (mi1[0]=mi2[0]=1,hash1[0]=hash2[0]=0,i=1;i&lt;=len;i++)
	{
		mi1[i]=mi1[i-1]*31%mo;
		hash1[i]=(hash1[i-1]+s[i]*mi1[i])%mo;
		mi2[i]=mi2[i-1]*19980723;
		hash2[i]=hash2[i-1]+s[i]*mi2[i];
	}
	//printf(&quot;hash1: &quot;);for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,hash1[i]);printf(&quot;\n&quot;);
	//printf(&quot;hash2: &quot;);for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,hash2[i]);printf(&quot;\n&quot;);
	ss[0]=500,ss[1]=333;
	for (i=1;i&lt;=len;i++)
	{
		ss[i*2]=s[i];
		ss[i*2+1]=333;
	}
	ss[len*2+2]=600;
	//printf(&quot;s: &quot;);for (i=1;i&lt;=len;i++) printf(&quot;%d &quot;,s[i]);printf(&quot;\n&quot;);
	//printf(&quot;ss: &quot;);for (i=1;i&lt;=len*2+1;i++) printf(&quot;%d &quot;,ss[i]);printf(&quot;\n&quot;);
	for (right=0,tmp=len*2+1,i=1;i&lt;=tmp;i++)
	{
		//printf(&quot;\n-----------------------------------------------------\n&quot;);
		ma[i]=right&gt;i?min(ma[id*2-i],right-i):1;
		//printf(&quot;ma[%d]=%d\n&quot;,i,ma[i]);
		while (ss[i+ma[i]]==ss[i-ma[i]])
		{
			ma[i]++;
			int L=(ss[i-ma[i]+1]==333)?(i-ma[i]+1)/2+1:(i-ma[i]+1)/2;
			int R=(i+ma[i]-1)/2;
			//printf(&quot;L=%d R=%d\n&quot;,L,R);
			check(L,R);
		}
		//printf(&quot;%d %d\n&quot;,i,ma[i]);
		//printf(&quot;%d\n&quot;,ans);
		if (ma[i]+i&gt;right) right=ma[id=i]+i;
	}
	//printf(&quot;\n\n%d\n\n&quot;,getmin(3,3));
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem3676</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 611111
#define mo 1000007
#define LL long long
int sa[NN],sa2[NN],rank[NN],sum[NN],ss[NN],s[NN],wv[NN],height[NN],f[NN][20],ma[NN],log[NN];
int len,n;
LL ans;
char sss[NN];
int min(int a,int b) {return a&lt;b?a:b;}
int max(int a,int b) {return a&gt;b?a:b;}
void suffix_array(int *r,int n,int m)
{
	int i,j,p,*x=rank,*y=sa2,*t;
	if (n==1) {sa[1]=rank[1]=1;return;}
	for (i=0;i&lt;=m;i++) sum[i]=0;
	for (i=1;i&lt;=n;i++) sum[x[i]=r[i]]++;
	for (i=1;i&lt;=m;i++) sum[i]+=sum[i-1];
	for (i=n;i;i--) sa[sum[x[i]]--]=i;
	for (p=j=1;p&lt;n;j&lt;&lt;=1,m=p)
	{
		for (p=0,i=n-j+1;i&lt;=n;i++) y[++p]=i;
		for (i=1;i&lt;=n;i++) if (sa[i]&gt;j) y[++p]=sa[i]-j;
		for (i=1;i&lt;=n;i++) wv[i]=x[y[i]];
		for (i=0;i&lt;=m;i++) sum[i]=0;
		for (i=1;i&lt;=n;i++) sum[wv[i]]++;
		for (i=1;i&lt;=m;i++) sum[i]+=sum[i-1];
		for (i=n;i;i--) sa[sum[wv[i]]--]=y[i];
		for (t=x,x=y,y=t,p=1,x[sa[1]]=1,i=2;i&lt;=n;i++)
			x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+j]==y[sa[i-1]+j])?p:++p;
	}
	for (i=1;i&lt;=n;i++) rank[i]=x[i];
	for (p=0,i=1;i&lt;=n;i++)
		if (x[i]&gt;1)
		{
			j=sa[x[i]-1];
			while (r[i+p]==r[j+p]) p++;
			height[x[i]]=p;
			if (p&gt;0) p--;
		}
}
int getmin(int L,int R)
{
	int len=log[R-L+1];
	return min(f[L][len],f[R-(1&lt;&lt;len)+1][len]);
}
void check(int L,int R)
{
	int tt,len,pos,res,l,r,mid;
	pos=rank[L];
	tt=0;
	len=R-L+1;
	res=pos;
	l=1,r=pos;
	while (l&lt;=r)
	{
		mid=(l+r)&gt;&gt;1;
		if (getmin(mid,pos)&gt;=len) res=mid-1,r=mid-1;
		else l=mid+1;
	}
	tt+=pos-res+1;
	res=pos;
	l=pos+1,r=n;
	while (l&lt;=r)
	{
		mid=(l+r)&gt;&gt;1;
		if (getmin(pos+1,mid)&gt;=len) res=mid,l=mid+1;
		else r=mid-1;
	}
	tt+=res-pos;
	if ((LL)tt*len&gt;ans) ans=(LL)tt*len;
}
int main()
{
	scanf(&quot;%s&quot;,sss+1);
	int i,j,tmp,right,id;
	for (len=strlen(sss+1),i=1;i&lt;=len;i++) s[i]=sss[i]-'a'+1;
	n=len;
	suffix_array(s,len,300);
	for (i=2;i&lt;=len;i++) f[i][0]=height[i];
	for (j=1;j&lt;=19;j++)
		for (i=1;i&lt;=len;i++)
			if (i+(1&lt;&lt;(j-1))&lt;=len)
				f[i][j]=min(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]);
	for (log[1]=0,i=2;i&lt;=len;i++)
		log[i]=(i==(i&amp;-i))?log[i-1]+1:log[i-1];
	ss[0]=500,ss[1]=333;
	for (i=1;i&lt;=len;i++)
	{
		ss[i*2]=s[i];
		ss[i*2+1]=333;
	}
	ss[len*2+2]=600;
	for (right=0,tmp=len*2+1,i=1;i&lt;=tmp;i++)
	{
		ma[i]=right&gt;i?min(ma[id*2-i],right-i):1;
		while (ss[i+ma[i]]==ss[i-ma[i]])
		{
			ma[i]++;
			int L=(ss[i-ma[i]+1]==333)?(i-ma[i]+1)/2+1:(i-ma[i]+1)/2;
			int R=(i+ma[i]-1)/2;
			check(L,R);
		}
		if (ma[i]+i&gt;right) right=ma[id=i]+i;
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem3676</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define NN 611111
#define LL long long
int sa[NN],sa2[NN],rank[NN],sum[NN],ss[NN],s[NN],wv[NN],height[NN],f[NN][20],ma[NN],log[NN];
int len,n;
LL ans;
char sss[NN];
int min(int a,int b) {return a&lt;b?a:b;}
void suffix_array(int *r,int n,int m)
{
	int i,j,p,*x=rank,*y=sa2,*t;
	if (n==1) {sa[1]=rank[1]=1;return;}
	for (i=0;i&lt;=m;i++) sum[i]=0;
	for (i=1;i&lt;=n;i++) sum[x[i]=r[i]]++;
	for (i=1;i&lt;=m;i++) sum[i]+=sum[i-1];
	for (i=n;i;i--) sa[sum[x[i]]--]=i;
	for (p=j=1;p&lt;n;j&lt;&lt;=1,m=p)
	{
		for (p=0,i=n-j+1;i&lt;=n;i++) y[++p]=i;
		for (i=1;i&lt;=n;i++) if (sa[i]&gt;j) y[++p]=sa[i]-j;
		for (i=1;i&lt;=n;i++) wv[i]=x[y[i]];
		for (i=0;i&lt;=m;i++) sum[i]=0;
		for (i=1;i&lt;=n;i++) sum[wv[i]]++;
		for (i=1;i&lt;=m;i++) sum[i]+=sum[i-1];
		for (i=n;i;i--) sa[sum[wv[i]]--]=y[i];
		for (t=x,x=y,y=t,p=1,x[sa[1]]=1,i=2;i&lt;=n;i++)
			x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+j]==y[sa[i-1]+j])?p:++p;
	}
	for (i=1;i&lt;=n;i++) rank[i]=x[i];
	for (p=0,i=1;i&lt;=n;i++)
		if (x[i]&gt;1)
		{
			j=sa[x[i]-1];
			while (r[i+p]==r[j+p]) p++;
			height[x[i]]=p;
			if (p&gt;0) p--;
		}
}
int getmin(int L,int R)
{
	int len=log[R-L+1];
	return min(f[L][len],f[R-(1&lt;&lt;len)+1][len]);
}
void check(int L,int R)
{
	int tt,len,pos,res,l,r,mid;
	pos=rank[L];
	tt=0;
	len=R-L+1;
	res=pos;
	l=1,r=pos;
	while (l&lt;=r)
	{
		mid=(l+r)&gt;&gt;1;
		if (getmin(mid,pos)&gt;=len) res=mid-1,r=mid-1;
		else l=mid+1;
	}
	tt+=pos-res+1;
	res=pos;
	l=pos+1,r=n;
	while (l&lt;=r)
	{
		mid=(l+r)&gt;&gt;1;
		if (getmin(pos+1,mid)&gt;=len) res=mid,l=mid+1;
		else r=mid-1;
	}
	tt+=res-pos;
	if ((LL)tt*len&gt;ans) ans=(LL)tt*len;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%s&quot;,sss+1);
	int i,j,tmp,right,id;
	for (len=strlen(sss+1),i=1;i&lt;=len;i++) s[i]=sss[i]-'a'+1;
	n=len;
	suffix_array(s,len,300);
	for (i=2;i&lt;=len;i++) f[i][0]=height[i];
	for (j=1;j&lt;=19;j++)
		for (i=1;i&lt;=len;i++)
			if (i+(1&lt;&lt;(j-1))&lt;=len)
				f[i][j]=min(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]);
	for (log[1]=0,i=2;i&lt;=len;i++)
		log[i]=(i==(i&amp;-i))?log[i-1]+1:log[i-1];
	ss[0]=500,ss[1]=333;
	for (i=1;i&lt;=len;i++)
	{
		ss[i*2]=s[i];
		ss[i*2+1]=333;
	}
	ss[len*2+2]=600;
	for (right=0,tmp=len*2+1,i=1;i&lt;=tmp;i++)
	{
		ma[i]=right&gt;i?min(ma[id*2-i],right-i):1;
		for (;ss[i+ma[i]]==ss[i-ma[i]];ma[i]++)
		{
			int L=(ss[i-ma[i]]==333)?(i-ma[i])/2+1:(i-ma[i])/2;
			int R=(i+ma[i])/2;
			check(L,R);
		}
		if (ma[i]+i&gt;right) right=ma[id=i]+i;
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem3680</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#define DD double
using namespace std;
int x[11000],y[11000],w[11000],n,i;
DD ans,ansx,ansy,dx,dy,tmp,r;
DD max(DD a,DD b) {return a&gt;b?a:b;}
int random(int n)
{
	return rand()*rand()%n;
}
DD calc(DD xx,DD yy)
{
	DD res=0;
	int i;
	for (i=1;i&lt;=n;i++)
		res+=(sqrt((xx-x[i])*(xx-x[i])+(yy-y[i])*(yy-y[i]))*w[i]);
	return res;
}
int main()
{
	//freopen(&quot;balance.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;balance.out&quot;,&quot;w&quot;,stdout);
	srand(19980723);
	scanf(&quot;%d&quot;,&amp;n);
	for (i=1;i&lt;=n;i++) scanf(&quot;%d%d%d&quot;,&amp;x[i],&amp;y[i],&amp;w[i]);
	ansx=random(200000)-100000;
	ansy=random(200000)-100000;
	r=100000*1.0;
	ans=calc(ansx,ansy);
	while (r&gt;0.0001)
	{
		for (i=1;i&lt;=50;i++)
		{
			tmp=2*(random(100000)*1.0/100000-0.5);
			dx=tmp*r;
			tmp=2*(random(100000)*1.0/100000-0.5);
			dy=tmp*r;
			tmp=calc(ansx+dx,ansy+dy);
			if (tmp&lt;ans)
			{
				ans=tmp;
				ansx+=dx;
				ansy+=dy;
			}
		}
		r/=2;
	}
	printf(&quot;%.3f %.3f&quot;,ansx,ansy);
	return 0;
}
<pre><h2>Problem3687</h2><pre>#include&lt;cstdio&gt;
#include&lt;bitset&gt;
using namespace std;
int n,i,x,ans;
bitset&lt;2001111&gt; a;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	a[0]=1;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		a^=(a&lt;&lt;x);
	}
	for (i=1;i&lt;=2000000;i++)
		if (a[i]) ans^=i;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3689</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
int a[101111],a1[101111],a0[101111],b[101111],last[101111],next[101111],c[1001111];
int n,K,i,j,k,l,num,nextnum,lastnum,len;
long long res;
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);printf(&quot;\n&quot;);}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	//freopen(&quot;xorit.in&quot;,&quot;r&quot;,stdin);freopen(&quot;xorit.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	for (i=1;i&lt;=n;scanf(&quot;%d&quot;,&amp;a[i++]));
	num=2,b[1]=1,b[2]=n+1;
	for (i=30;i;i--)
	{
		//printf(&quot;\n----------------------------------------------------------\n&quot;);
		res=0;
		for (j=1;j&lt;num;j++)
		{
			len=b[j+1]-b[j];
			res+=((long long)len*(len-1))&gt;&gt;1;
		}
		//printf(&quot;res=%d\n&quot;,res);
		if (res&lt;K)
		{
			for (j=1;j&lt;lastnum;j++)
				for (k=last[j];k&lt;last[j+1]-1;k++)
					for (l=k+1;l&lt;last[j+1];l++) c[++c[0]]=a[k]^a[l];
			sort(c+1,c+c[0]+1);
			for (j=1;j&lt;=K;j++) printf(&quot;%d &quot;,c[j]);
			printf(&quot;\n&quot;);
			return 0;
		}
		lastnum=num;
		for (j=1;j&lt;=num;j++) last[j]=b[j];
		//printf(&quot;last &quot;);out(last,1,lastnum);
		nextnum=0;
		for (j=1;j&lt;num;j++)
		{
			//printf(&quot;======= %d =======\n&quot;,j);
			int l=b[j],r=b[j+1]-1,t0=0,t1=0;
			for (k=l;k&lt;=r;k++)
				if (a[k]&amp;(1&lt;&lt;(i-1))) a1[++t1]=a[k];
				else a0[++t0]=a[k];
			next[++nextnum]=b[j];
			if (t0) next[++nextnum]=b[j]+t0;
			int t=l;
			for (k=1;k&lt;=t0;k++) a[t++]=a0[k];
			for (k=1;k&lt;=t1;k++) a[t++]=a1[k];
			//printf(&quot;next &quot;);out(next,1,nextnum);
		}
		if (next[nextnum]!=n+1) next[++nextnum]=n+1;
		//printf(&quot;next &quot;);out(next,1,nextnum);
		num=nextnum;
		for (j=1;j&lt;=num;j++) b[j]=next[j];
		//printf(&quot;a &quot;);out(a,1,n);
	}
	res=0;
	for (j=1;j&lt;=num;j++)
	{
		len=b[j+1]-b[j];
		res+=(len*(len-1))&gt;&gt;1;
	}
	if (res&lt;k)
	{
		for (j=1;j&lt;=lastnum;j++)
			for (k=last[j];k&lt;last[j+1]-1;k++)
				for (l=k+1;l&lt;last[j+1];l++) c[++c[0]]=a[k]^a[l];
		sort(c+1,c+c[0]+1);
		for (j=1;j&lt;=K;j++) printf(&quot;%d &quot;,c[j]);
		printf(&quot;\n&quot;);
		return 0;
	}
	for (i=1;i&lt;=K;i++) printf(&quot;0 &quot;);
	printf(&quot;\n&quot;);
	return 0;
}
<pre><h2>Problem3689</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
int a[101111],a1[101111],a0[101111],b[101111],last[101111],next[101111],c[1001111];
int n,K,i,j,k,l,num,nextnum,lastnum,len;
long long res;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	for (i=1;i&lt;=n;scanf(&quot;%d&quot;,&amp;a[i++]));
	num=2,b[1]=1,b[2]=n+1;
	for (i=30;i;i--)
	{
		res=0;
		for (j=1;j&lt;num;j++)
		{
			len=b[j+1]-b[j];
			res+=((long long)len*(len-1))&gt;&gt;1;
		}
		if (res&lt;K)
		{
			for (j=1;j&lt;lastnum;j++)
				for (k=last[j];k&lt;last[j+1]-1;k++)
					for (l=k+1;l&lt;last[j+1];l++) c[++c[0]]=a[k]^a[l];
			sort(c+1,c+c[0]+1);
			for (j=1;j&lt;=K;j++) printf(&quot;%d &quot;,c[j]);
			printf(&quot;\n&quot;);
			return 0;
		}
		lastnum=num;
		for (j=1;j&lt;=num;j++) last[j]=b[j];
		nextnum=0;
		for (j=1;j&lt;num;j++)
		{
			int l=b[j],r=b[j+1]-1,t0=0,t1=0;
			for (k=l;k&lt;=r;k++)
				if (a[k]&amp;(1&lt;&lt;(i-1))) a1[++t1]=a[k];
				else a0[++t0]=a[k];
			next[++nextnum]=b[j];
			if (t0) next[++nextnum]=b[j]+t0;
			int t=l;
			for (k=1;k&lt;=t0;k++) a[t++]=a0[k];
			for (k=1;k&lt;=t1;k++) a[t++]=a1[k];
		}
		if (next[nextnum]!=n+1) next[++nextnum]=n+1;
		num=nextnum;
		for (j=1;j&lt;=num;j++) b[j]=next[j];
	}
	res=0;
	for (j=1;j&lt;=num;j++)
	{
		len=b[j+1]-b[j];
		res+=(len*(len-1))&gt;&gt;1;
	}
	if (res&lt;k)
	{
		for (j=1;j&lt;=lastnum;j++)
			for (k=last[j];k&lt;last[j+1]-1;k++)
				for (l=k+1;l&lt;last[j+1];l++) c[++c[0]]=a[k]^a[l];
		sort(c+1,c+c[0]+1);
		for (j=1;j&lt;=K;j++) printf(&quot;%d &quot;,c[j]);
		printf(&quot;\n&quot;);
		return 0;
	}
	for (i=1;i&lt;=K;i++) printf(&quot;0 &quot;);
	printf(&quot;\n&quot;);
	return 0;
}
<pre><h2>Problem3689</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
int a[101111],a1[101111],a0[101111],b[101111],last[101111],next[101111],c[501111];
int n,K,i,j,k,l,num,nextnum,lastnum,len;
long long res;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	for (i=1;i&lt;=n;scanf(&quot;%d&quot;,&amp;a[i++]));
	num=2,b[1]=1,b[2]=n+1;
	for (i=30;i;i--)
	{
		res=0;
		for (j=1;j&lt;num;j++)
		{
			len=b[j+1]-b[j];
			res+=((long long)len*(len-1))&gt;&gt;1;
		}
		if (res&lt;K)
		{
			for (j=1;j&lt;lastnum;j++)
				for (k=last[j];k&lt;last[j+1]-1;k++)
					for (l=k+1;l&lt;last[j+1];l++) c[++c[0]]=a[k]^a[l];
			sort(c+1,c+c[0]+1);
			for (j=1;j&lt;=K;j++) printf(&quot;%d &quot;,c[j]);
			printf(&quot;\n&quot;);
			return 0;
		}
		lastnum=num;
		for (j=1;j&lt;=num;j++) last[j]=b[j];
		nextnum=0;
		for (j=1;j&lt;num;j++)
		{
			int l=b[j],r=b[j+1]-1,t0=0,t1=0;
			for (k=l;k&lt;=r;k++)
				if (a[k]&amp;(1&lt;&lt;(i-1))) a1[++t1]=a[k];
				else a0[++t0]=a[k];
			next[++nextnum]=b[j];
			if (t0) next[++nextnum]=b[j]+t0;
			int t=l;
			for (k=1;k&lt;=t0;k++) a[t++]=a0[k];
			for (k=1;k&lt;=t1;k++) a[t++]=a1[k];
		}
		if (next[nextnum]!=n+1) next[++nextnum]=n+1;
		num=nextnum;
		for (j=1;j&lt;=num;j++) b[j]=next[j];
	}
	res=0;
	for (j=1;j&lt;=num;j++)
	{
		len=b[j+1]-b[j];
		res+=(len*(len-1))&gt;&gt;1;
	}
	if (res&lt;k)
	{
		for (j=1;j&lt;=lastnum;j++)
			for (k=last[j];k&lt;last[j+1]-1;k++)
				for (l=k+1;l&lt;last[j+1];l++) c[++c[0]]=a[k]^a[l];
		sort(c+1,c+c[0]+1);
		for (j=1;j&lt;=K;j++) printf(&quot;%d &quot;,c[j]);
		printf(&quot;\n&quot;);
		return 0;
	}
	for (i=1;i&lt;=K;i++) printf(&quot;0 &quot;);
	printf(&quot;\n&quot;);
	return 0;
}
<pre><h2>Problem3689</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define M 100100
using namespace std;
typedef pair&lt;int, pair&lt;int,int&gt; &gt; abcd;
struct Trie{
  int siz;
  Trie *son[2];
  Trie();
}*null=new Trie,*root=null;
Trie :: Trie()
{
  siz=0;
  son[0]=son[1]=null;
}
int n,a[M];
abcd heap[M];
int top;
void Push(abcd x)
{
  heap[++top]=x;
  int t=top;
  while( t&gt;1 &amp;&amp; heap[t]&lt;heap[t&gt;&gt;1] )
    swap(heap[t],heap[t&gt;&gt;1]),t&gt;&gt;=1;
}
void Pop()
{
  heap[1]=heap[top--];
  int t=2;
  while( t&lt;=top )
  {
    if( t&lt;top &amp;&amp; heap[t+1]&lt;heap[t] )
      ++t;
    if( heap[t]&lt;heap[t&gt;&gt;1] )
      swap(heap[t],heap[t&gt;&gt;1]),t&lt;&lt;=1;
    else
      break;
  }
}
void Insert(Trie*&amp;p,int x,int pos)
{
  if(p==null)	
    p=new Trie();
  p-&gt;siz++;
  if(!pos)
    return ;
  Insert(p-&gt;son[x&amp;pos?1:0],x,pos&gt;&gt;1);
}
int Get_Kth(Trie*p,int x,int pos,int k)
{
  if(!pos)
    return 0;
  if(k&lt;=p-&gt;son[x&amp;pos?1:0]-&gt;siz)
    return Get_Kth(p-&gt;son[x&amp;pos?1:0],x,pos&gt;&gt;1,k);
  else
    return Get_Kth(p-&gt;son[x&amp;pos?0:1],x,pos&gt;&gt;1,k-p-&gt;son[x&amp;pos?1:0]-&gt;siz)+pos;
}
int main()
{
  int i,k;
  cin&gt;&gt;n&gt;&gt;k;
  for(i=1;i&lt;=n;i++)
    scanf(&quot;%d&quot;,&amp;a[i]),Insert(root,a[i],1&lt;&lt;30);
  for(i=1;i&lt;=n;i++)
    Push( make_pair( Get_Kth(root,a[i],1&lt;&lt;30,2) , make_pair(i,2) ) );
  for(i=1;i&lt;=k&lt;&lt;1;i++)
  {
    abcd temp=heap[1];Pop();
    if(i&amp;1)
      printf(&quot;%d &quot;,temp.first);
    if(temp.second.second!=n)
    {
      int x=temp.second.first;
      int y=temp.second.second;
      Push( make_pair( Get_Kth(root,a[x],1&lt;&lt;30,y+1) , make_pair(x,y+1) ) );
    }
  }
}<pre><h2>Problem3689</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
#define NN 101111
int a[NN],now[NN],n,size[2000000],son[2000000][2],TTT=1,K;
struct ppt
{
	int w,id;
	ppt(int a=0,int b=0) {w=a,id=b;}
	friend bool operator &lt;(ppt a,ppt b) {return a.w&gt;b.w;}
};
priority_queue&lt;ppt&gt; Q;
void trieins(int x)
{
	//printf(&quot;ins %d\n&quot;,x);
	int now=1,deep;
	for (deep=30;deep;deep--)
	{
		size[now]++;
		//printf(&quot;%d %d\n&quot;,now,size[now]);
		int tmp=(x&gt;&gt;(deep-1))&amp;1;
		//printf(&quot;tmp=%d son[now][tmp]=%d\n&quot;,tmp,son[now][tmp]);
		if (son[now][tmp]) now=son[now][tmp];
		else
		{
			son[now][tmp]=++TTT;
			now=TTT;
		}
	}
	size[now]++;
	//printf(&quot;%d %d\n&quot;,now,size[now]);
	//printf(&quot;son[1][0]=%d son[1][1]=%d\n&quot;,son[1][0],son[1][1]);
}
int select(int x,int K)
{
	int res=0,now=1,deep;
	for (deep=30;deep;deep--)
	{
		int tmp=(x&gt;&gt;(deep-1))&amp;1;
		//printf(&quot;%d %d\n&quot;,tmp,size[son[now][tmp]]);
		if (size[son[now][tmp]]&gt;=K) now=son[now][tmp];
		else
		{
			res+=(1&lt;&lt;(deep-1));
			K-=size[son[now][tmp]];
			now=son[now][tmp^1];
		}
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	//freopen(&quot;xorit.in&quot;,&quot;r&quot;,stdin);freopen(&quot;xorit.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	int i;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		trieins(a[i]);
	}
	//printf(&quot;%d\n&quot;,select(1,3));
	for (i=1;i&lt;=n;i++)
	{
		now[i]=2;
		Q.push(ppt(select(a[i],2),i));
	}
	for (i=1;i&lt;=K*2;i++)
	{
		ppt tmp=Q.top();
		Q.pop();
		if (i&amp;1) printf(&quot;%d &quot;,tmp.w);
		Q.push(ppt(select(a[tmp.id],++now[tmp.id]),tmp.id));
	}
	return 0;
}
<pre><h2>Problem3689</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
#define NN 101111
int a[NN],now[NN],n,size[2000000],son[2000000][2],TTT=1,K;
struct ppt
{
	int w,id;
	ppt(int a=0,int b=0) {w=a,id=b;}
	friend bool operator &lt;(ppt a,ppt b) {return a.w&gt;b.w;}
};
priority_queue&lt;ppt&gt; Q;
void trieins(int x)
{
	int now=1,deep;
	for (deep=30;deep;deep--)
	{
		size[now]++;
		int tmp=(x&gt;&gt;(deep-1))&amp;1;
		if (son[now][tmp]) now=son[now][tmp];
		else
		{
			son[now][tmp]=++TTT;
			now=TTT;
		}
	}
	size[now]++;
}
int select(int x,int K)
{
	int res=0,now=1,deep;
	for (deep=30;deep;deep--)
	{
		int tmp=(x&gt;&gt;(deep-1))&amp;1;
		if (size[son[now][tmp]]&gt;=K) now=son[now][tmp];
		else
		{
			res+=(1&lt;&lt;(deep-1));
			K-=size[son[now][tmp]];
			now=son[now][tmp^1];
		}
	}
	return res;
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	int i;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		trieins(a[i]);
	}
	for (i=1;i&lt;=n;i++)
	{
		now[i]=2;
		Q.push(ppt(select(a[i],2),i));
	}
	for (i=1;i&lt;=K*2;i++)
	{
		ppt tmp=Q.top();
		Q.pop();
		if (i&amp;1) printf(&quot;%d &quot;,tmp.w);
		Q.push(ppt(select(a[tmp.id],++now[tmp.id]),tmp.id));
	}
	return 0;
}
<pre><h2>Problem3697</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;

#define maxn 200010

using namespace std;

inline int read()
{
	int ret=0;char ch=getchar();
	while(ch&lt;'!') ch=getchar();
	while(ch&gt;'!') ret=ret*10+ch-'0',ch=getchar();
	return ret;
}

typedef long long ll;
int n,tot,b[maxn],siz[maxn],f[maxn],root;
ll ans=0,g[maxn][2],met[maxn];
bool vis[maxn];

struct edge{
	int x,y,w,last;
}a[maxn&lt;&lt;1];

void add(int x,int y,int w)
{
	a[++tot]=(edge){x,y,w,b[x]};
	b[x]=tot;
}

#define v a[i].y
void calsize(int x,int fa)
{
	siz[x]=1;
	for(int i=b[x];i;i=a[i].last){
		if(vis[v]||v==fa) continue;
		calsize(v,x);
		siz[x]+=siz[v];
	}
}

void find(int x,int fa,int tot)
{
	f[x]=0;
	for(int i=b[x];i;i=a[i].last){
		if(vis[v]||v==fa) continue;
		find(v,x,tot);
		f[x]=max(f[x],siz[v]);
	}
	f[x]=max(f[x],tot-siz[x]);
	if(root==-1||f[x]&lt;f[root]) root=x;
}

void cal(int x,int fa,int val)
{
	if(!val&amp;&amp;met[val+n]) ans++;
	if(met[val+n]) ans+=g[-val+n][1]+g[-val+n][0];
	else ans+=g[-val+n][1];
	met[val+n]++;
	for(int i=b[x];i;i=a[i].last){
		if(v==fa||vis[v]) continue;
		cal(v,x,val+a[i].w);
	}
	met[val+n]--;
}

void Add(int x,int fa,int val)
{
	if(met[val+n]) g[val+n][1]++;
	else g[val+n][0]++;
	met[val+n]++;
	for(int i=b[x];i;i=a[i].last){
		if(v==fa||vis[v]) continue;
		Add(v,x,val+a[i].w);
	}
	met[val+n]--;
}

void clear(int x,int fa,int val)
{
	g[val+n][1]=g[val+n][0]=0;
	for(int i=b[x];i;i=a[i].last){
		if(v==fa||vis[v]) continue;
		clear(v,x,val+a[i].w);
	}
}

void devide(int x)
{
	calsize(x,0);
	root=-1;
	find(x,0,siz[x]);
	vis[root]=1;
	//printf(&quot;%d\n&quot;,root);
	bool flag=0;
	for(int i=b[root];i;i=a[i].last){
		if(vis[v]) continue;
		met[0+n]=0,cal(v,root,a[i].w);
		met[0+n]=1;
		Add(v,root,a[i].w);
	}
	for(int i=b[root];i;i=a[i].last){
		if(vis[v]) continue;
		clear(v,root,a[i].w);
	}
	for(int i=b[root];i;i=a[i].last){
		if(vis[v]) continue;
		devide(v);
	}
}
int main()
{
	n=read();
	for(int i=1;i&lt;n;i++){
		int x=read(),y=read(),w=read();
		if(w==0) w=-1;
		add(x,y,w);add(y,x,w);
	}
	devide(1);
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem3697</h2><pre>#include&lt;cctype&gt;
#include&lt;cstdio&gt;
using namespace std;
#define Read(x,y,z) IN(x),IN(y),IN(z)
#define Col if(!z)z=-1
#define For(x) for(int i=first[x];i;i=e[i].nt)
#define J if(flag[v]||v==fa)continue
#define Ju if(flag[v])continue
struct node{
	int v,c,nt;
	node(){}
	node(int _,int __,int ___){v=_,c=__,nt=___;}
}e[210000];
#define v e[i].v
#define c e[i].c
bool flag[210000];
int n,top,cnt;
int s[210000],son[210000],q[110000],f[210000][2],p[210000],first[210000];
long long ans;
char ch;
void add(int x,int y,int z){e[++cnt]=node(y,z,first[x]),first[x]=cnt;}
void IN(int &amp;x){
	ch=getchar();while(!isdigit(ch))ch=getchar();
	x=ch^48,ch=getchar();
	while(isdigit(ch))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48),ch=getchar();
}
void dfs(int x,int fa){
	s[x]=1,son[x]=0;
	For(x){
		J;dfs(v,x);s[x]+=s[v];
		if(s[son[x]]&lt;s[v])son[x]=v;
	}
}
int G(int x){
	dfs(x,x);
	int tip=x,tmp=s[x]&gt;&gt;1;
	while(s[son[tip]]&gt;tmp)tip=son[tip];
	return tip;
}
void Get(int x,int fa,int cost){
	ans+=f[n-cost][0];
	if(p[n+cost]||!cost)ans+=f[n-cost][1];
	if(p[n+cost]&amp;&amp;!cost)++ans;
	++p[n+cost];
	For(x){
		J;Get(v,x,cost+c);
	}
	--p[n+cost];
}
void Cal(int x,int fa,int cost){
	q[top++]=cost;
	if(p[cost])++f[cost][0];
	else ++f[cost][1];
	++p[cost];
	For(x){
		J;Cal(v,x,cost+c);
	}
	--p[cost];
}
void DFS(int x){
	flag[x]=1,top=0;
	For(x){
		Ju;Get(v,x,c);Cal(v,x,n+c);
	}
	for(int i=0;i&lt;top;i++)f[q[i]][0]=f[q[i]][1]=0;
	For(x){
		Ju;
		DFS(G(v));
	}
}
int main(){
	IN(n);
	for(int i=1,x,y,z;i&lt;n;i++){
		Read(x,y,z);Col;add(x,y,z),add(y,x,z);
	}
	DFS(G(1));
	printf(&quot;%lld\n&quot;,ans);
}<pre><h2>Problem3698</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
#define inf 999999999
#define mii(a,b) ((a)&lt;(b)?(a):(b))
typedef double DD;
const DD eps=1e-7;
const int NN=211;
int o[NN],cur[NN],deep[NN],q[NN],aa[101111][3],in[NN],out[NN];
int n,tot=1,yuan,hui,S,T,SS,TT;
DD a[NN][NN];
bool bfs()
{
	int head=0,tail=1,x,p,y;
	q[1]=yuan;
	memset(deep,0,sizeof(deep));
	deep[yuan]=1;
	while (head&lt;tail)
	{
		x=q[++head];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	for (int i=1;i&lt;=TT;i++) cur[i]=o[i];
	return deep[hui];
}
int dfs(int v,int ff)
{
	if (v==hui) return ff;
	int res=0;
	for (int &amp;p=cur[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(ff,aa[p][2]));
		ff-=tmp,aa[p][2]-=tmp;
		aa[p^1][2]+=tmp,res+=tmp;
		if (!ff) break;
	}
	return res;
}
int dinic(int S,int T)
{
	yuan=S,hui=T;
	int res=0;
	while (bfs()) res+=dfs(yuan,inf);
	return res;
}
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline void add(int p,int q,int v)
{
	//printf(&quot;add  %d %d %d\n&quot;,p,q,v);
	addedge(p,q,v);
	addedge(q,p,0);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++) scanf(&quot;%lf&quot;,&amp;a[i][j]);
	S=n+n+1,T=S+1,SS=T+1,TT=SS+1;
	add(T,S,inf);
	for (i=1;i&lt;n;i++)
	{
		DD tmp=a[i][n];
		int t=(int)tmp;
		out[S]+=t,in[i]+=t;
		if (fabs(t-tmp)&gt;eps) add(S,i,1);
	}
	for (j=1;j&lt;n;j++)
	{
		DD tmp=a[n][j];
		int t=(int)tmp;
		out[j+n]+=t,in[T]+=t;
		if (fabs(t-tmp)&gt;eps) add(j+n,T,1);
	}
	for (i=1;i&lt;n;i++)
		for (j=1;j&lt;n;j++)
		{
			DD tmp=a[i][j];
			int t=(int)tmp;
			out[i]+=t,in[j+n]+=t;
			if (fabs(t-tmp)&gt;eps) add(i,j+n,1);
		}
	for (i=1;i&lt;=T;i++)
		if (in[i]&gt;out[i]) add(SS,i,in[i]-out[i]);
		else if (out[i]&gt;in[i]) add(i,TT,out[i]-in[i]);
	dinic(SS,TT);
	int ans=aa[3][2];
	//printf(&quot;ans=%d\n&quot;,ans);
	for (int p=o[SS];p;p=aa[p][0])
		if (aa[p][2]) {printf(&quot;No\n&quot;);return 0;}
	aa[2][2]=aa[3][2]=0;
	for (int p=o[SS];p;p=aa[p][0]) aa[p][2]=aa[p^1][2]=0;
	for (int p=o[TT];p;p=aa[p][0]) aa[p][2]=aa[p^1][2]=0;
	ans+=dinic(S,T);
	printf(&quot;%d\n&quot;,ans*3);
	return 0;
}<pre><h2>Problem3698</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
#define inf 999999999
#define mii(a,b) ((a)&lt;(b)?(a):(b))
typedef double DD;
const DD eps=1e-7;
const int NN=211;
int o[NN],cur[NN],deep[NN],q[NN],aa[501111][3],in[NN],out[NN];
int n,tot=1,yuan,hui,S,T,SS,TT;
DD a[NN][NN];
bool bfs()
{
	int head=0,tail=1,x,p,y;
	q[1]=yuan;
	memset(deep,0,sizeof(deep));
	deep[yuan]=1;
	while (head&lt;tail)
	{
		x=q[++head];
		cur[x]=o[x];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[hui];
}
int dfs(int v,int ff)
{
	if (v==hui) return ff;
	int res=0;
	for (int &amp;p=cur[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(ff,aa[p][2]));
		ff-=tmp,aa[p][2]-=tmp;
		aa[p^1][2]+=tmp,res+=tmp;
		if (!ff) break;
	}
	return res;
}
int dinic(int S,int T)
{
	yuan=S,hui=T;
	int res=0;
	while (bfs()) res+=dfs(yuan,inf);
	return res;
}
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline void add(int p,int q,int v)
{
	//printf(&quot;add  %d %d %d\n&quot;,p,q,v);
	addedge(p,q,v);
	addedge(q,p,0);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++) scanf(&quot;%lf&quot;,&amp;a[i][j]);
	S=n+n+1,T=S+1,SS=T+1,TT=SS+1;
	add(T,S,inf);
	for (i=1;i&lt;n;i++)
	{
		DD tmp=a[i][n];
		int t=(int)tmp;
		out[S]+=t,in[i]+=t;
		if (fabs(t-tmp)&gt;eps) add(S,i,1);
	}
	for (j=1;j&lt;n;j++)
	{
		DD tmp=a[n][j];
		int t=(int)tmp;
		out[j+n]+=t,in[T]+=t;
		if (fabs(t-tmp)&gt;eps) add(j+n,T,1);
	}
	for (i=1;i&lt;n;i++)
		for (j=1;j&lt;n;j++)
		{
			DD tmp=a[i][j];
			int t=(int)tmp;
			out[i]+=t,in[j+n]+=t;
			if (fabs(t-tmp)&gt;eps) add(i,j+n,1);
		}
	for (i=1;i&lt;=T;i++)
		if (in[i]&gt;out[i]) add(SS,i,in[i]-out[i]);
		else if (out[i]&gt;in[i]) add(i,TT,out[i]-in[i]);
	dinic(SS,TT);
	int ans=aa[3][2];
	//printf(&quot;ans=%d\n&quot;,ans);
	for (int p=o[SS];p;p=aa[p][0])
		if (aa[p][2]) {printf(&quot;No\n&quot;);return 0;}
	aa[2][2]=aa[3][2]=0;
	for (int p=o[SS];p;p=aa[p][0]) aa[p][2]=aa[p^1][2]=0;
	for (int p=o[TT];p;p=aa[p][0]) aa[p][2]=aa[p^1][2]=0;
	ans+=dinic(S,T);
	printf(&quot;%d\n&quot;,ans*3);
	return 0;
}<pre><h2>Problem3698</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
#define inf 999999999
#define mii(a,b) ((a)&lt;(b)?(a):(b))
typedef double DD;
const DD eps=1e-7;
const int NN=211;
int o[NN],cur[NN],deep[NN],q[NN],aa[51111][3],in[NN],out[NN];
int n,tot=1,yuan,hui,S,T,SS,TT;
DD a[NN][NN];
bool bfs()
{
	int head=0,tail=1,x,p,y;
	q[1]=yuan;
	memset(deep,0,sizeof(deep));
	deep[yuan]=1;
	while (head&lt;tail)
	{
		x=q[++head];
		cur[x]=o[x];
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y]) deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[hui];
}
int dfs(int v,int ff)
{
	if (v==hui) return ff;
	int res=0;
	for (int &amp;p=cur[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(ff,aa[p][2]));
		ff-=tmp,aa[p][2]-=tmp;
		aa[p^1][2]+=tmp,res+=tmp;
		if (!ff) break;
	}
	return res;
}
int dinic(int S,int T)
{
	yuan=S,hui=T;
	int res=0;
	while (bfs()) res+=dfs(yuan,inf);
	return res;
}
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline void add(int p,int q,int v)
{
	//printf(&quot;add  %d %d %d\n&quot;,p,q,v);
	addedge(p,q,v);
	addedge(q,p,0);
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	int i,j;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++) scanf(&quot;%lf&quot;,&amp;a[i][j]);
	S=n+n+1,T=S+1,SS=T+1,TT=SS+1;
	add(T,S,inf);
	for (i=1;i&lt;n;i++)
	{
		DD tmp=a[i][n];
		int t=(int)tmp;
		out[S]+=t,in[i]+=t;
		if (fabs(t-tmp)&gt;eps) add(S,i,1);
	}
	for (j=1;j&lt;n;j++)
	{
		DD tmp=a[n][j];
		int t=(int)tmp;
		out[j+n]+=t,in[T]+=t;
		if (fabs(t-tmp)&gt;eps) add(j+n,T,1);
	}
	for (i=1;i&lt;n;i++)
		for (j=1;j&lt;n;j++)
		{
			DD tmp=a[i][j];
			int t=(int)tmp;
			out[i]+=t,in[j+n]+=t;
			if (fabs(t-tmp)&gt;eps) add(i,j+n,1);
		}
	for (i=1;i&lt;=T;i++)
		if (in[i]&gt;out[i]) add(SS,i,in[i]-out[i]);
		else if (out[i]&gt;in[i]) add(i,TT,out[i]-in[i]);
	dinic(SS,TT);
	int ans=aa[3][2];
	//printf(&quot;ans=%d\n&quot;,ans);
	for (int p=o[SS];p;p=aa[p][0])
		if (aa[p][2]) {printf(&quot;No\n&quot;);return 0;}
	aa[2][2]=aa[3][2]=0;
	for (int p=o[SS];p;p=aa[p][0]) aa[p][2]=aa[p^1][2]=0;
	for (int p=o[TT];p;p=aa[p][0]) aa[p][2]=aa[p^1][2]=0;
	ans+=dinic(S,T);
	printf(&quot;%d\n&quot;,ans*3);
	return 0;
}<pre><h2>Problem3698</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;

#define maxn 210
#define INF 0x7fffffff

using namespace std;

int n,in[maxn],out[maxn],dep[maxn],tot=1,b[maxn],aim,su,sv,ssu,ssv,sum;

struct edge{
	int x,y,w,last;
}a[maxn*maxn&lt;&lt;2];

void add(int x,int y,int w)
{
	
	a[++tot]=(edge){x,y,w,b[x]};
	b[x]=tot;
}

void Add(int x,int y,int w)
{
	add(x,y,w);
	add(y,x,0);
}

#define v a[i].y
int Dinic(int x,int flow)
{
	if(x==aim) return flow;
	int remain=flow;
	for(int i=b[x];i;i=a[i].last){
		if(dep[v]==dep[x]+1&amp;&amp;a[i].w&amp;&amp;remain){
			 int tmp=Dinic(v,min(remain,a[i].w));
			 if(!tmp){ dep[v]=0;continue; }
			 a[i].w-=tmp,a[i^1].w+=tmp,remain-=tmp;
		}
	}
	return flow-remain;
}

bool bfs(int su,int sv)
{
	queue&lt;int&gt; q;q.push(su);
	memset(dep,0,sizeof(dep));dep[su]=1;
	while(!q.empty()){
		int x=q.front();q.pop();
		for(int i=b[x];i;i=a[i].last){
			if(!dep[v]&amp;&amp;a[i].w){ 
				dep[v]=dep[x]+1; q.push(v); 
			}
		}
	}
	return dep[sv]!=0;
}

int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	su=2*n+1,sv=2*n+2;
	ssu=0,ssv=2*n+3;
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=n;j++){
			double w;scanf(&quot;%lf&quot;,&amp;w);int t=w;
			if(j==n){
				if(t!=w) Add(su,i,1);
				out[su]+=t;
				in[i]+=t;
			}else if(i==n){
				if(t!=w) Add(j+n,sv,1);
				in[sv]+=t;
				out[j+n]+=t;
			}else{
				if(t!=w)Add(i,j+n,1);
				out[i]+=t;
				in[j+n]+=t;
			}	
		}
	}
	for(int i=1;i&lt;=2*n+2;i++){
		if(in[i]&gt;out[i]) Add(ssu,i,in[i]-out[i]),sum=sum+in[i]-out[i];
		else if(out[i]&gt;in[i]) Add(i,ssv,out[i]-in[i]);
	}
	Add(sv,su,INF);
	int tmp,ans=0;
	aim=ssv;
	while(bfs(ssu,ssv)) {while(tmp=Dinic(ssu,INF)) ans+=tmp; }
	if(ans&lt;sum){ printf(&quot;No&quot;);return 0; }
	else{ ans=0;aim=sv; while(bfs(su,sv)) while(tmp=Dinic(su,INF)) ans+=tmp; }
	printf(&quot;%d\n&quot;,ans*3);;
	return 0;
}
<pre><h2>Problem3709</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int NN=101111;
int n;
LL K;
struct ppt
{
	int a,b,id;
	void in(int i)
	{
		id=i;
		scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
	}
} q[NN];
inline bool cmp1(const ppt &amp;a,const ppt &amp;b) {return a.b-a.a&gt;b.b-b.a;}
inline bool cmp2(const ppt &amp;a,const ppt &amp;b) {return a.a&lt;b.a;}
inline bool cmp3(const ppt &amp;a,const ppt &amp;b) {return a.b&gt;b.b;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%I64d&quot;,&amp;n,&amp;K);
	int i;
	for (i=1;i&lt;=n;i++) q[i].in(i);
	sort(q+1,q+n+1,cmp1);
	int t=n+1;
	for (i=1;i&lt;=n;i++)
		if (q[i].b-q[i].a&lt;0) {t=i;break;}
	sort(q+1,q+t,cmp2);
	sort(q+t,q+n+1,cmp3);
	for (i=1;i&lt;=n;i++)
	{
		if (K&lt;=q[i].a) {printf(&quot;NIE\n&quot;);return 0;}
		K+=q[i].b-q[i].a;
	}
	printf(&quot;TAK\n&quot;);
	for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,q[i].id);
	return 0;
}<pre><h2>Problem3712</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
char * c=(char *)malloc(30000000);
inline void in(int &amp;x){
    x=0;
    while(*c&lt;'0'||*c&gt;'9')++c;
    while(*c&gt;='0'&amp;&amp;*c&lt;='9')x=x*10+(*c++^'0');
}
int g[200005];
#include&lt;vector&gt;
int sonptr[200005],sonsize[200005],sonnext[200005],sonsucc[200005];
bool p[200005];
int qptr[200005],qnext[1000005],ab[1000005];
int lca[500005],bson[500005],fa[200005],wson[200005],wsn[200005];
int find(int x){
    if(fa[x]!=fa[fa[x]]){
        int ftr=fa[x];
        fa[x]=find(fa[x]);
        wson[x]=wson[ftr];
    }
    return fa[x];
}
void tarjan(int node,int ftr){
    fa[node]=node;
    for(int i=sonptr[node],j=0;i;i=sonnext[i],++j){
        wsn[node]=j;
        tarjan(sonsucc[i],node);
        wson[sonsucc[i]]=j;
    }
    for(int i=qptr[node];i;i=qnext[i])
        if(p[node^ab[i]]){
            lca[i-1&gt;&gt;1]=find(node^ab[i]);
            if(lca[i-1&gt;&gt;1]==node)bson[i-1&gt;&gt;1]=wson[node^ab[i]];
            else bson[i-1&gt;&gt;1]=wsn[lca[i-1&gt;&gt;1]];
        }
    p[node]=1;
    fa[node]=ftr;
}

int a[500005],b[500005];
int ptr[200005],sons[200005];
int next[500005],succ[500005];
long long ans;
void dfs(int node){
    int tmp;
    for(int i=sonptr[node],k=0,j;i;i=sonnext[i],++k){
        dfs(sonsucc[i]);
        for(j=ptr[sons[node]+k];j;j=next[j]){
            tmp=min(g[a[succ[j]]],g[b[succ[j]]]);
            g[a[succ[j]]]-=tmp,g[b[succ[j]]]-=tmp;
            ans+=tmp&lt;&lt;1;
            //if(tmp)cout&lt;&lt;&quot;Get(&quot;&lt;&lt;a[succ[j]]&lt;&lt;&quot;,&quot;&lt;&lt;b[succ[j]]&lt;&lt;&quot;) at &quot;&lt;&lt;node&lt;&lt;&quot;=&quot;&lt;&lt;tmp&lt;&lt;endl;
        }
    }
}
int main(){
    //freopen(&quot;fiolki.in&quot;,&quot;r&quot;,stdin);
    //freopen(&quot;fiolki.out&quot;,&quot;w&quot;,stdout);
    int n,m,k;
    fread(c,1,30000000,stdin);
    in(n),in(m),in(k);
    for(int i=1;i&lt;=n;++i)in(g[i]);
    int stot=1,rtot=1,qtot=1;
    for(int i=0;i&lt;m;++i)in(a[i]),in(b[i]);
    for(int i=m;i--;){
        ++sonsize[b[i]];
        sonnext[stot]=sonptr[b[i]];
        sonptr[b[i]]=stot;
        sonsucc[stot++]=a[i];
        p[a[i]]=1;
    }
    for(int i=n;i;--i)
        if(!p[i]){
            ++sonsize[0];
            sonnext[stot]=sonptr[0];
            sonptr[0]=stot;
            sonsucc[stot++]=i;
        }
    for(int i=0;i&lt;k;++i){
        in(a[i]),in(b[i]);
        qnext[qtot]=qptr[a[i]];
        qptr[a[i]]=qtot;
        ab[qtot++]=a[i]^b[i];

        qnext[qtot]=qptr[b[i]];
        qptr[b[i]]=qtot;
        ab[qtot++]=a[i]^b[i];
    }
    memset(p,0,sizeof(p));
    for(int i=sonptr[0];i;i=sonnext[i])tarjan(sonsucc[i],0);
    sons[1]=1;
    for(int i=2;i&lt;=n;++i)sons[i]=sons[i-1]+sonsize[i-1];
    for(int i=k;i--;)
        if(lca[i]){
            next[rtot]=ptr[sons[lca[i]]+bson[i]];
            succ[rtot]=i;
            ptr[sons[lca[i]]+bson[i]]=rtot++;
            //cout&lt;&lt;a[i]&lt;&lt;&quot;,&quot;&lt;&lt;b[i]&lt;&lt;&quot;:&quot;&lt;&lt;lca[i]&lt;&lt;&quot; &quot;&lt;&lt;bson[i]&lt;&lt;endl;
        }
    for(int i=sonptr[0];i;i=sonnext[i])dfs(sonsucc[i]);
    printf(&quot;%lld\n&quot;,ans);
}<pre><h2>Problem3712</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
typedef long long LL;
#define pb push_back
#define mii(a,b) (a&lt;b?a:b)
const int NN=201111,KK=501111;
int have[NN];
int n,m,K,tot=1;
LL ans;
bool vt[NN];
vector&lt;int&gt; go[NN],can[NN],may[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
struct Tree
{
	int deep[NN],fa[NN],f[20][NN];
	void dfs(int v)
	{
		for (int t=go[v].size(),j=0;j&lt;t;j++)
		{
			int y=go[v][j];
			deep[y]=deep[v]+1;
			dfs(y);
		}
	}
	void in()
	{
		int i,j,x,y;
		for (i=1;i&lt;=m;i++)
		{
			read(x),read(y);
			go[fa[x]=y].pb(x);
		}
		for (i=1;i&lt;=n;i++)
			if (fa[i]==0) go[n+1].pb(i);
		deep[n+1]=1;
		dfs(n+1);
		for (i=1;i&lt;=n+1;i++) f[0][i]=fa[i];
		for (j=1;j&lt;=19;j++)
			for (i=1;i&lt;=n+1;i++) f[j][i]=f[j-1][f[j-1][i]];
	}
	int getlca(int x,int y)
	{
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		for (int i=19;i&gt;=0;i--)
			if (deep[f[i][x]]&gt;=deep[y]) x=f[i][x];
		if (x==y) return x;
		for (int i=19;i&gt;=0;i--)
			if (f[i][x]!=f[i][y]) x=f[i][x],y=f[i][y];
		return f[0][x];
	}
} tree;
struct Fy
{
	int u,v,lca,id;
	void in(int i)
	{
		id=i;
		read(u),read(v);
		may[u].pb(i),may[v].pb(i);
		lca=tree.getlca(u,v);
	}
} fy[KK];
void work(int v)
{
	vt[v]=true;
	for (int t=may[v].size(),j=0;j&lt;t;j++)
	{
		int k=may[v][j];
		if (vt[fy[k].u]&amp;&amp;vt[fy[k].v]) can[fy[k].lca].pb(k);
	}
	for (int t=go[v].size(),j=0;j&lt;t;j++)
	{
		int y=go[v][j];
		work(y);
		sort(can[v].begin(),can[v].end());
		for (int t=can[v].size(),j=0;j&lt;t;j++)
		{
			int k=can[v][j];
			int tmp=min(have[fy[k].u],have[fy[k].v]);
			ans+=tmp*2;
			have[fy[k].u]-=tmp,have[fy[k].v]-=tmp;
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m),read(K);
	int i;
	for (i=1;i&lt;=n;i++) read(have[i]);
	tree.in();
	for (i=1;i&lt;=K;i++) fy[i].in(i);
	work(n+1);
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem3712</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
typedef long long LL;
#define pb push_back
const int NN=201111,KK=501111;
int n,m,K,tot=1,have[NN];
LL ans;
bool vt[NN];
vector&lt;int&gt; go[NN],can[NN],may[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
struct Tree
{
	int deep[NN],fa[NN],f[20][NN];
	void dfs(int v)
	{
		for (int t=go[v].size(),j=0;j&lt;t;j++)
		{
			int y=go[v][j];
			deep[y]=deep[v]+1;
			dfs(y);
		}
	}
	void in()
	{
		int i,j,x,y;
		for (i=1;i&lt;=m;i++)
		{
			read(x),read(y);
			go[fa[x]=y].pb(x);
		}
		for (i=1;i&lt;=n;i++)
			if (fa[i]==0) go[n+1].pb(i);
		deep[n+1]=1;
		dfs(n+1);
		for (i=1;i&lt;=n+1;i++) f[0][i]=fa[i];
		for (j=1;j&lt;=19;j++)
			for (i=1;i&lt;=n+1;i++) f[j][i]=f[j-1][f[j-1][i]];
	}
	int getlca(int x,int y)
	{
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		for (int i=19;i&gt;=0;i--)
			if (deep[f[i][x]]&gt;=deep[y]) x=f[i][x];
		if (x==y) return x;
		for (int i=19;i&gt;=0;i--)
			if (f[i][x]!=f[i][y]) x=f[i][x],y=f[i][y];
		return f[0][x];
	}
} tree;
struct Fy
{
	int u,v,lca,id;
	void in(int i)
	{
		id=i;
		read(u),read(v);
		may[u].pb(i),may[v].pb(i);
		lca=tree.getlca(u,v);
	}
} fy[KK];
void work(int v)
{
	vt[v]=true;
	for (int t=may[v].size(),j=0;j&lt;t;j++)
	{
		int k=may[v][j];
		if (vt[fy[k].u]&amp;&amp;vt[fy[k].v]) can[fy[k].lca].pb(k);
	}
	for (int t=go[v].size(),j=0;j&lt;t;j++)
	{
		int y=go[v][j];
		work(y);
		sort(can[v].begin(),can[v].end());
		for (int t=can[v].size(),j=0;j&lt;t;j++)
		{
			int k=can[v][j];
			int tmp=min(have[fy[k].u],have[fy[k].v]);
			ans+=tmp*2;
			have[fy[k].u]-=tmp,have[fy[k].v]-=tmp;
		}
	}
}
int main()
{
	read(n),read(m),read(K);
	int i;
	for (i=1;i&lt;=n;i++) read(have[i]);
	tree.in();
	for (i=1;i&lt;=K;i++) fy[i].in(i);
	work(n+1);
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem3712</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
typedef long long LL;
#define pb push_back
const int NN=201111,KK=501111;
int n,m,K,tot=1,have[NN];
LL ans;
bool vt[NN];
vector&lt;int&gt; go[NN],can[NN],may[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
struct Tree
{
	int deep[NN],fa[NN],f[20][NN];
	void dfs(int v)
	{
		for (int t=go[v].size(),j=0;j&lt;t;j++)
		{
			int y=go[v][j];
			deep[y]=deep[v]+1;
			dfs(y);
		}
	}
	void in()
	{
		int i,j,x,y;
		for (i=1;i&lt;=m;i++)
		{
			read(x),read(y);
			go[fa[x]=y].pb(x);
		}
		for (i=1;i&lt;=n;i++)
			if (fa[i]==0) go[n+1].pb(i);
		deep[n+1]=1;
		dfs(n+1);
		for (i=1;i&lt;=n+1;i++) f[0][i]=fa[i];
		for (j=1;j&lt;=19;j++)
			for (i=1;i&lt;=n+1;i++) f[j][i]=f[j-1][f[j-1][i]];
	}
	int getlca(int x,int y)
	{
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		for (int i=19;i&gt;=0;i--)
			if (deep[f[i][x]]&gt;=deep[y]) x=f[i][x];
		if (x==y) return x;
		for (int i=19;i&gt;=0;i--)
			if (f[i][x]!=f[i][y]) x=f[i][x],y=f[i][y];
		return f[0][x];
	}
} tree;
struct Fy
{
	int u,v,lca,id;
	void in(int i)
	{
		id=i;
		read(u),read(v);
		may[u].pb(i),may[v].pb(i);
		lca=tree.getlca(u,v);
	}
} fy[KK];
void work(int v)
{
	vt[v]=true;
	for (int t=may[v].size(),j=0;j&lt;t;j++)
	{
		int k=may[v][j];
		if (vt[fy[k].u]&amp;&amp;vt[fy[k].v]) can[fy[k].lca].pb(k);
	}
	for (int t=go[v].size(),j=0;j&lt;t;j++)
	{
		int y=go[v][j];
		work(y);
		sort(can[v].begin(),can[v].end());
		for (int t=can[v].size(),j=0;j&lt;t;j++)
		{
			int k=can[v][j];
			int tmp=min(have[fy[k].u],have[fy[k].v]);
			ans+=tmp*2;
			have[fy[k].u]-=tmp,have[fy[k].v]-=tmp;
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m),read(K);
	int i;
	for (i=1;i&lt;=n;i++) read(have[i]);
	tree.in();
	for (i=1;i&lt;=K;i++) fy[i].in(i);
	for (int t=go[n+1].size(),j=0;j&lt;t;j++) work(go[n+1][j]);
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem3712</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
typedef long long LL;
#define pb push_back
const int NN=201111,KK=501111;
int n,m,K,tot=1,have[NN],fa[NN];
LL ans;
bool vt[NN];
vector&lt;int&gt; go[NN],can[NN],may[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
struct Tree
{
	int deep[NN],f[20][NN];
	void dfs(int v)
	{
		for (int t=go[v].size(),j=0;j&lt;t;j++)
		{
			int y=go[v][j];
			deep[y]=deep[v]+1;
			dfs(y);
		}
	}
	void in()
	{
		int i,j,x,y;
		for (i=1;i&lt;=m;i++)
		{
			read(x),read(y);
			go[fa[x]=y].pb(x);
		}
		for (i=1;i&lt;=n;i++)
			if (fa[i]==0) deep[i]=1,dfs(i);
		for (i=1;i&lt;=n;i++) f[0][i]=fa[i];
		for (j=1;j&lt;=19;j++)
			for (i=1;i&lt;=n;i++) f[j][i]=f[j-1][f[j-1][i]];
	}
	int getlca(int x,int y)
	{
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		for (int i=19;i&gt;=0;i--)
			if (deep[f[i][x]]&gt;=deep[y]) x=f[i][x];
		if (x==y) return x;
		for (int i=19;i&gt;=0;i--)
			if (f[i][x]!=f[i][y]) x=f[i][x],y=f[i][y];
		return f[0][x];
	}
} tree;
struct Fy
{
	int u,v,lca,id;
	void in(int i)
	{
		id=i;
		read(u),read(v);
		may[u].pb(i),may[v].pb(i);
		lca=tree.getlca(u,v);
	}
} fy[KK];
void work(int v)
{
	vt[v]=true;
	for (int t=may[v].size(),j=0;j&lt;t;j++)
	{
		int k=may[v][j];
		if (vt[fy[k].u]&amp;&amp;vt[fy[k].v]) can[fy[k].lca].pb(k);
	}
	for (int t=go[v].size(),j=0;j&lt;t;j++)
	{
		int y=go[v][j];
		work(y);
		sort(can[v].begin(),can[v].end());
		for (int t=can[v].size(),j=0;j&lt;t;j++)
		{
			int k=can[v][j];
			int tmp=min(have[fy[k].u],have[fy[k].v]);
			ans+=tmp*2;
			have[fy[k].u]-=tmp,have[fy[k].v]-=tmp;
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m),read(K);
	int i;
	for (i=1;i&lt;=n;i++) read(have[i]);
	tree.in();
	for (i=1;i&lt;=K;i++) fy[i].in(i);
	for (i=1;i&lt;=n;i++)
		if (fa[i]==0) work(i);
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem3712</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
typedef long long LL;
#define pb push_back
const int NN=201111;
int n,m,K,tot=1,have[NN],fa[NN];
LL ans;
bool vt[NN];
vector&lt;int&gt; go[NN],can[NN],may[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
struct Tree
{
	int deep[NN],f[20][NN];
	void dfs(int v)
	{
		for (int j=0;j&lt;go[v].size();j++)
		{
			int y=go[v][j];
			deep[y]=deep[v]+1;
			dfs(y);
		}
	}
	void in()
	{
		int i,j,x,y;
		for (i=1;i&lt;=m;i++)
		{
			read(x),read(y);
			go[fa[x]=y].pb(x);
		}
		for (i=1;i&lt;=n;i++)
			if (fa[i]==0) deep[i]=1,dfs(i);
		for (i=1;i&lt;=n;i++) f[0][i]=fa[i];
		for (j=1;j&lt;=19;j++)
			for (i=1;i&lt;=n;i++) f[j][i]=f[j-1][f[j-1][i]];
	}
	int getlca(int x,int y)
	{
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		for (int i=19;i&gt;=0;i--)
			if (deep[f[i][x]]&gt;=deep[y]) x=f[i][x];
		if (x==y) return x;
		for (int i=19;i&gt;=0;i--)
			if (f[i][x]!=f[i][y]) x=f[i][x],y=f[i][y];
		return f[0][x];
	}
} tree;
struct Fy
{
	int u,v,lca;
	void in(int i)
	{
		read(u),read(v);
		may[u].pb(i),may[v].pb(i);
		lca=tree.getlca(u,v);
	}
} fy[501111];
void work(int v)
{
	vt[v]=true;
	for (int j=0;j&lt;may[v].size();j++)
	{
		int k=may[v][j];
		if (vt[fy[k].u]&amp;&amp;vt[fy[k].v]) can[fy[k].lca].pb(k);
	}
	for (int j=0;j&lt;go[v].size();j++)
	{
		int y=go[v][j];
		work(y);
		sort(can[v].begin(),can[v].end());
		for (int j=0;j&lt;can[v].size();j++)
		{
			int k=can[v][j];
			int tmp=min(have[fy[k].u],have[fy[k].v]);
			ans+=tmp*2;
			have[fy[k].u]-=tmp,have[fy[k].v]-=tmp;
		}
	}
}
int main()
{
	read(n),read(m),read(K);
	int i;
	for (i=1;i&lt;=n;i++) read(have[i]);
	tree.in();
	for (i=1;i&lt;=K;i++) fy[i].in(i);
	for (i=1;i&lt;=n;i++)
		if (fa[i]==0) work(i);
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem3712</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
typedef long long LL;
#define pb push_back
const int NN=201111;
int n,m,K,tot=1,have[NN],fa[NN];
LL ans;
bool vt[NN];
vector&lt;int&gt; go[NN],can[NN],may[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
struct Tree
{
	int deep[NN],f[20][NN];
	void dfs(int v)
	{
		for (int j=0;j&lt;go[v].size();j++)
		{
			int y=go[v][j];
			deep[y]=deep[v]+1;
			dfs(y);
		}
	}
	void in()
	{
		int i,j,x,y;
		for (i=1;i&lt;=m;i++)
		{
			read(x),read(y);
			go[fa[x]=y].pb(x);
		}
		for (i=1;i&lt;=n;i++)
			if (fa[i]==0) deep[i]=1,dfs(i);
		for (i=1;i&lt;=n;i++) f[0][i]=fa[i];
		for (j=1;j&lt;=19;j++)
			for (i=1;i&lt;=n;i++) f[j][i]=f[j-1][f[j-1][i]];
	}
	int getlca(int x,int y)
	{
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		for (int i=19;i&gt;=0;i--)
			if (deep[f[i][x]]&gt;=deep[y]) x=f[i][x];
		if (x==y) return x;
		for (int i=19;i&gt;=0;i--)
			if (f[i][x]!=f[i][y]) x=f[i][x],y=f[i][y];
		return f[0][x];
	}
} tree;
struct Fy
{
	int u,v,lca;
	void in(int i)
	{
		read(u),read(v);
		may[u].pb(i),may[v].pb(i);
		lca=tree.getlca(u,v);
	}
} fy[501111];
void work(int v)
{
	vt[v]=true;
	for (int j=0;j&lt;may[v].size();j++)
	{
		int k=may[v][j];
		if (vt[fy[k].u]&amp;&amp;vt[fy[k].v]) can[fy[k].lca].pb(k);
	}
	for (int j=0;j&lt;go[v].size();j++)
	{
		int y=go[v][j];
		work(y);
		sort(can[v].begin(),can[v].end());
		for (int j=0;j&lt;can[v].size();j++)
		{
			int k=can[v][j];
			int tmp=min(have[fy[k].u],have[fy[k].v]);
			ans+=tmp*2;
			have[fy[k].u]-=tmp,have[fy[k].v]-=tmp;
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m),read(K);
	int i;
	for (i=1;i&lt;=n;i++) read(have[i]);
	tree.in();
	for (i=1;i&lt;=K;i++) fy[i].in(i);
	for (i=1;i&lt;=n;i++)
		if (fa[i]==0) work(i);
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem3712</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
typedef long long LL;
#define pb push_back
#define sz size()
const int NN=201111;
int n,m,K,tot=1,cur[NN],fa[NN];
LL ans;
bool vt[NN];
vector&lt;int&gt; go[NN],can[NN],may[NN];
struct Tree
{
	int deep[NN],f[20][NN];
	void dfs(int v)
	{
		for (int j=0;j&lt;go[v].sz;j++)
		{
			int y=go[v][j];
			deep[y]=deep[v]+1;
			dfs(y);
		}
	}
	void in()
	{
		int i,j,x,y;
		for (i=1;i&lt;=m;i++)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			go[fa[x]=y].pb(x);
		}
		for (i=1;i&lt;=n;i++)
			if (fa[i]==0) deep[i]=1,dfs(i);
		for (i=1;i&lt;=n;i++) f[0][i]=fa[i];
		for (j=1;j&lt;=19;j++)
			for (i=1;i&lt;=n;i++) f[j][i]=f[j-1][f[j-1][i]];
	}
	int getlca(int x,int y)
	{
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		for (int i=19;i&gt;=0;i--)
			if (deep[f[i][x]]&gt;=deep[y]) x=f[i][x];
		if (x==y) return x;
		for (int i=19;i&gt;=0;i--)
			if (f[i][x]!=f[i][y]) x=f[i][x],y=f[i][y];
		return f[0][x];
	}
} tree;
struct Fy
{
	int u,v,lca;
	void in(int i)
	{
		scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
		may[u].pb(i),may[v].pb(i);
		lca=tree.getlca(u,v);
	}
} fy[501111];
void work(int v)
{
	vt[v]=true;
	for (int j=0;j&lt;may[v].sz;j++)
	{
		int k=may[v][j];
		if (vt[fy[k].u]&amp;&amp;vt[fy[k].v]) can[fy[k].lca].pb(k);
	}
	for (int j=0;j&lt;go[v].size();j++)
	{
		int y=go[v][j];
		work(y);
		sort(can[v].begin(),can[v].end());
		for (int j=0;j&lt;can[v].sz;j++)
		{
			int k=can[v][j];
			int tmp=min(cur[fy[k].u],cur[fy[k].v]);
			ans+=tmp*2;
			cur[fy[k].u]-=tmp,cur[fy[k].v]-=tmp;
		}
	}
}
int main()
{
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;K);
	int i;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;cur[i]);
	tree.in();
	for (i=1;i&lt;=K;i++) fy[i].in(i);
	for (i=1;i&lt;=n;i++)
		if (fa[i]==0) work(i);
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem3712</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
#define pb push_back
#define sz size()
const int NN=201111;
int n,m,K,tot=1,cur[NN],fa[NN];
long long ans;
bool vt[NN];
vector&lt;int&gt; go[NN],can[NN],may[NN];
struct Tree
{
	int deep[NN],f[20][NN];
	void dfs(int v)
	{
		for (int j=0;j&lt;go[v].sz;j++)
		{
			int y=go[v][j];
			deep[y]=deep[v]+1;
			dfs(y);
		}
	}
	void init()
	{
		int i,j,x,y;
		for (i=1;i&lt;=m;i++)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			go[fa[x]=y].pb(x);
		}
		for (i=1;i&lt;=n;i++)
			if (fa[i]==0) deep[i]=1,dfs(i);
		for (i=1;i&lt;=n;i++) f[0][i]=fa[i];
		for (j=1;j&lt;=19;j++)
			for (i=1;i&lt;=n;i++) f[j][i]=f[j-1][f[j-1][i]];
	}
	int getlca(int x,int y)
	{
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		for (int i=19;i&gt;=0;i--)
			if (deep[f[i][x]]&gt;=deep[y]) x=f[i][x];
		if (x==y) return x;
		for (int i=19;i&gt;=0;i--)
			if (f[i][x]!=f[i][y]) x=f[i][x],y=f[i][y];
		return f[0][x];
	}
} tree;
struct Fanying
{
	int u,v,lca;
	void in(int i)
	{
		scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
		may[u].pb(i),may[v].pb(i);
		lca=tree.getlca(u,v);
	}
} fy[501111];
void calc(int v)
{
	vt[v]=true;
	for (int j=0;j&lt;may[v].sz;j++)
	{
		int k=may[v][j];
		if (vt[fy[k].u]&amp;&amp;vt[fy[k].v]) can[fy[k].lca].pb(k);
	}
	for (int j=0;j&lt;go[v].size();j++)
	{
		int y=go[v][j];
		calc(y);
		sort(can[v].begin(),can[v].end());
		for (int j=0;j&lt;can[v].sz;j++)
		{
			int k=can[v][j];
			int tmp=min(cur[fy[k].u],cur[fy[k].v]);
			ans+=tmp*2;
			cur[fy[k].u]-=tmp,cur[fy[k].v]-=tmp;
		}
	}
}
int main()
{
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;K);
	int i;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;cur[i]);
	tree.init();
	for (i=1;i&lt;=K;i++) fy[i].in(i);
	for (i=1;i&lt;=n;i++)
		if (fa[i]==0) calc(i);
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem3714</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int NN=2005;
int n,m,fa[NN];
struct edge
{
	int u,v,w;
	edge(int a=0,int b=0,int c=0) {u=a;v=b;w=c;}
	void out() {printf(&quot;u=%d v=%d w=%d\n&quot;,u,v,w);}
	friend bool operator &lt;(const edge &amp;a,const edge &amp;b) {return a.w&lt;b.w;}
} e[NN*NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
int getfa(int x) {return fa[x]==x?x:fa[x]=getfa(fa[x]);}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);
	int i,j,x;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n-i+1;j++)
		{
			read(x);
			e[++m]=edge(i-1,j+i-1,x);
		}
	sort(e+1,e+m+1);
	//for (i=1;i&lt;=m;i++) e[i].out();
	for (i=0;i&lt;=n;i++) fa[i]=i;
	int cnt=0;
	long long ans=0;
	for (i=1;cnt&lt;n;i++)
	{
		int x=getfa(e[i].u),y=getfa(e[i].v);
		if (x==y) continue;
		cnt++;
		ans+=e[i].w;
		fa[x]=y;
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem3716</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
using namespace std;
typedef long long LL;
typedef long double DD;
typedef pair&lt;DD,int&gt; pdi;
#define mp make_pair
#define fi first
#define se second
#define ln printf(&quot;\n&quot;)
const DD eps=1e-10;
const int NN=201111;
int n,m;
DD cheng;
set&lt;pdi&gt; S;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar()) x=x*10+ch-'0';
	if (f) x=-x;
}
struct ppt
{
	DD x,y;int w;bool kind;
	void in(bool ff)
	{
		kind=ff;
		int xx,yy;
		read(xx),read(yy),read(w);
		x=xx,y=yy;
		DD t1=x*cheng,t2=y;
		x=t1-t2,y=t1+t2;
	}
	void out() {printf(&quot;x=%.3f y=%.3f w=%d kind=%d\n&quot;,(double)x,(double)y,w,kind);}
	friend bool operator &lt;(const ppt &amp;a,const ppt &amp;b) {return a.x&gt;b.x;}
} b[NN&lt;&lt;1];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	int i,x,y;
	read(x),read(y),cheng=(DD)y/x;
	LL ans=0;
	for (i=1;i&lt;=n;i++) b[i].in(0),ans+=b[i].w;
	for (i=1;i&lt;=m;i++) b[i+n].in(1);
	sort(b+1,b+n+m+1);
	//for (i=1;i&lt;=n+m;i++) b[i].out();ln;printf(&quot;ans=%I64d\n&quot;,ans);ln;
	for (i=1;i&lt;=n+m;i++)
	{
		//printf(&quot;\n----------------------------------------------------------------------\n&quot;);
		if (b[i].kind)
		{
			while (!S.empty())
			{
				set&lt;pdi&gt;::iterator it=S.upper_bound(mp(b[i].y,0));
				if (it==S.end()) it--;
				if ((*it).fi-b[i].y&gt;eps)
				{
					if (it==S.begin()) break;
					it--;
				}
				pdi tmp=*it;
				if (tmp.fi-b[i].y&gt;eps) break;
				if (b[i].w&gt;=tmp.se)
				{
					ans-=tmp.se;
					b[i].w-=tmp.se;
					S.erase(it);
				}
				else
				{
					S.erase(it);
					tmp.se-=b[i].w;
					S.insert(tmp);
					ans-=b[i].w;
					break;
				}
			}
		}
		else S.insert(mp(b[i].y,b[i].w));
		//printf(&quot;%I64d\n&quot;,ans);//for (set&lt;pdi&gt;::iterator it=S.begin();it!=S.end();it++) printf(&quot;%.3f %d\n&quot;,(*it).fi,(*it).se);
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem3716</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
using namespace std;
typedef long long LL;
typedef double DD;
typedef pair&lt;DD,int&gt; pdi;
#define mp make_pair
#define fi first
#define se second
const DD eps=1e-7;
const int NN=201111;
int n,m;
DD cheng;
set&lt;pdi&gt; S;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar()) x=x*10+ch-'0';
	if (f) x=-x;
}
struct ppt
{
	DD x,y;int w;bool kind;
	void in(bool ff)
	{
		kind=ff;
		int xx,yy;
		read(xx),read(yy),read(w);
		x=xx,y=yy;
		DD t1=x*cheng,t2=y;
		x=t1-t2,y=t1+t2;
	}
	friend bool operator &lt;(const ppt &amp;a,const ppt &amp;b) {return a.x&gt;b.x;}
} b[NN&lt;&lt;1];
int main()
{
	read(n),read(m);
	int i,x,y;
	read(x),read(y),cheng=(DD)y/x;
	LL ans=0;
	for (i=1;i&lt;=n;i++) b[i].in(0),ans+=b[i].w;
	for (i=1;i&lt;=m;i++) b[i+n].in(1);
	sort(b+1,b+n+m+1);
	for (i=1;i&lt;=n+m;i++)
	{
		if (b[i].kind)
		{
			while (!S.empty())
			{
				set&lt;pdi&gt;::iterator it=S.upper_bound(mp(b[i].y,0));
				if (it==S.end()) it--;
				if ((*it).fi-b[i].y&gt;eps)
				{
					if (it==S.begin()) break;
					it--;
				}
				pdi tmp=*it;
				if (tmp.fi-b[i].y&gt;eps) break;
				if (b[i].w&gt;=tmp.se)
				{
					ans-=tmp.se;
					b[i].w-=tmp.se;
					S.erase(it);
				}
				else
				{
					S.erase(it);
					tmp.se-=b[i].w;
					S.insert(tmp);
					ans-=b[i].w;
					break;
				}
			}
		}
		else S.insert(mp(b[i].y,b[i].w));
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem3720</h2><pre>#include&lt;cstdio&gt;
//#include&lt;ctime&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=60111,NNN=1301111,inf=1000000007;
int lc[NNN],rc[NNN],size[NNN],o[NN],aa[NN*2][2],b[NN],c[NN],w[NN];
int begin[NN],end[NN],up[NN],root[NN],vt[NN],fa[NN],lastw[NN];
int n,m,tot=1,cnt,num,TTT,TIME,lastn,lastans,ans;
//double tttt=0;
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
void ins(int &amp;v,int u,int l,int r,int x)
{
	if (!v) v=++TTT;
	size[v]=size[u]+1;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid)
		rc[v]=rc[u],ins(lc[v],lc[u],l,mid,x);
	else
		lc[v]=lc[u],ins(rc[v],rc[u],mid,r,x);
}
int find(int v,int u,int l,int r,int x)
{
	if (r-l==1) return 0;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid)
		return size[rc[v]]-size[rc[u]]+find(lc[v],lc[u],l,mid,x);
	else return find(rc[v],rc[u],mid,r,x);
}
void dfs(int v)
{
	begin[v]=++cnt;
	b[cnt]=v;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dfs(y);
	}
	end[v]=cnt;
}
void build()
{
	//clock_t nnnn=clock();
	cnt=0;
	fa[1]=0;
	dfs(1);
	int i;
	for (i=1;i&lt;=TTT;i++) lc[i]=rc[i]=size[i]=0;
	TTT=0;
	//printf(&quot;w &quot;);out(w,1,n);
	for (i=1;i&lt;=n;i++)
	{
		root[i]=0;
		ins(root[i],root[i-1],-inf,inf,w[b[i]]);
	}
	lastn=n;
	for (i=1;i&lt;=n;i++) up[i]=i,lastw[i]=w[i];
	num=0;
	TIME++;
	//tttt+=(double)(clock()-nnnn);
}
void dfs2(int v,int x)
{
	//printf(&quot;dfs2 %d\n&quot;,v);
	if (w[v]&gt;x) ans++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dfs2(y,x);
	}
}
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int main()
{
	//clock_t chushi=clock();tttt=0;
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j,x,y;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;w[i]);
	build();
	scanf(&quot;%d&quot;,&amp;m);
	lastans=0;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		//printf(&quot;\n-------------------- kind=%d ------------------------------------------------\n&quot;,x);
		if (x==0)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x^=lastans,y^=lastans;
			ans=0;
			if (x&lt;=lastn)
			{
				int l=begin[x],r=end[x];
				ans=find(root[end[x]],root[begin[x]-1],-inf,inf,y);
				//printf(&quot;ans=%d\n&quot;,ans);
				for (j=1;j&lt;=num;j++)
					if (l&lt;=begin[c[j]]&amp;&amp;begin[c[j]]&lt;=r)
					{
						if (lastw[c[j]]&gt;y&amp;&amp;w[c[j]]&lt;=y) ans--;
						else if (lastw[c[j]]&lt;=y&amp;&amp;w[c[j]]&gt;y) ans++;
					}
				for (j=lastn+1;j&lt;=n;j++)
					if (l&lt;=begin[up[j]]&amp;&amp;begin[up[j]]&lt;=r&amp;&amp;w[j]&gt;y) ans++;
			}
			else dfs2(x,y);
			printf(&quot;%d\n&quot;,lastans=ans);
		}
		else if (x==1)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x^=lastans,y^=lastans;
			w[x]=y;
			if (vt[x]!=TIME)
				vt[x]=TIME,w[x]=y,c[++num]=x;
		}
		else
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x^=lastans,y^=lastans;
			n++;
			fa[n]=x;
			w[n]=y;
			up[n]=up[x];
			addedge(fa[n],n),addedge(n,fa[n]);
		}
		if (i%800==0) build();
	}
	//printf(&quot;tot time = %.5f\n&quot;,(double)(clock()-chushi)/CLOCKS_PER_SEC);
	//printf(&quot;rebuild time = %.5f\n&quot;,tttt/CLOCKS_PER_SEC);
	return 0;
}<pre><h2>Problem3720</h2><pre>#include&lt;cstdio&gt;
//#include&lt;ctime&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=60111,NNN=1301111,inf=1000000007;
int lc[NNN],rc[NNN],size[NNN],o[NN],aa[NN*2][2],b[NN],c[NN],w[NN];
int begin[NN],end[NN],up[NN],root[NN],vt[NN],fa[NN],lastw[NN];
int n,m,tot=1,cnt,num,TTT,TIME,lastn,lastans,ans;
//double tttt=0;
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
void ins(int &amp;v,int u,int l,int r,int x)
{
	if (!v) v=++TTT;
	size[v]=size[u]+1;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid)
		rc[v]=rc[u],ins(lc[v],lc[u],l,mid,x);
	else
		lc[v]=lc[u],ins(rc[v],rc[u],mid,r,x);
}
int find(int v,int u,int l,int r,int x)
{
	if (r-l==1) return 0;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid)
		return size[rc[v]]-size[rc[u]]+find(lc[v],lc[u],l,mid,x);
	else return find(rc[v],rc[u],mid,r,x);
}
void dfs(int v)
{
	begin[v]=++cnt;
	b[cnt]=v;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dfs(y);
	}
	end[v]=cnt;
}
void build()
{
	//clock_t nnnn=clock();
	cnt=0;
	fa[1]=0;
	dfs(1);
	int i;
	for (i=1;i&lt;=TTT;i++) lc[i]=rc[i]=size[i]=0;
	TTT=0;
	//printf(&quot;w &quot;);out(w,1,n);
	for (i=1;i&lt;=n;i++)
	{
		root[i]=0;
		ins(root[i],root[i-1],-inf,inf,w[b[i]]);
	}
	lastn=n;
	for (i=1;i&lt;=n;i++) up[i]=i,lastw[i]=w[i];
	num=0;
	TIME++;
	//tttt+=(double)(clock()-nnnn);
}
void dfs2(int v,int x)
{
	//printf(&quot;dfs2 %d\n&quot;,v);
	if (w[v]&gt;x) ans++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dfs2(y,x);
	}
}
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int main()
{
	//clock_t chushi=clock();tttt=0;
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j,x,y;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;w[i]);
	build();
	scanf(&quot;%d&quot;,&amp;m);
	lastans=0;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		//printf(&quot;\n-------------------- kind=%d ------------------------------------------------\n&quot;,x);
		if (x==0)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x^=lastans,y^=lastans;
			ans=0;
			if (x&lt;=lastn)
			{
				int l=begin[x],r=end[x];
				ans=find(root[end[x]],root[begin[x]-1],-inf,inf,y);
				//printf(&quot;ans=%d\n&quot;,ans);
				for (j=1;j&lt;=num;j++)
					if (l&lt;=begin[c[j]]&amp;&amp;begin[c[j]]&lt;=r)
					{
						if (lastw[c[j]]&gt;y&amp;&amp;w[c[j]]&lt;=y) ans--;
						else if (lastw[c[j]]&lt;=y&amp;&amp;w[c[j]]&gt;y) ans++;
					}
				for (j=lastn+1;j&lt;=n;j++)
					if (l&lt;=begin[up[j]]&amp;&amp;begin[up[j]]&lt;=r&amp;&amp;w[j]&gt;y) ans++;
			}
			else dfs2(x,y);
			printf(&quot;%d\n&quot;,lastans=ans);
		}
		else if (x==1)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x^=lastans,y^=lastans;
			w[x]=y;
			if (vt[x]!=TIME)
				vt[x]=TIME,w[x]=y,c[++num]=x;
		}
		else
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x^=lastans,y^=lastans;
			n++;
			fa[n]=x;
			w[n]=y;
			up[n]=up[x];
			addedge(fa[n],n),addedge(n,fa[n]);
		}
		//if (i%800==0) build();
	}
	//printf(&quot;tot time = %.5f\n&quot;,(double)(clock()-chushi)/CLOCKS_PER_SEC);
	//printf(&quot;rebuild time = %.5f\n&quot;,tttt/CLOCKS_PER_SEC);
	return 0;
}<pre><h2>Problem3720</h2><pre>#include&lt;cstdio&gt;
//#include&lt;ctime&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=60111,NNN=1301111,inf=1000000007;
int lc[NNN],rc[NNN],size[NNN],o[NN],aa[NN*2][2],b[NN],c[NN],w[NN];
int begin[NN],end[NN],up[NN],root[NN],vt[NN],fa[NN],lastw[NN];
int n,m,tot=1,cnt,num,TTT,TIME,lastn,lastans,ans;
//double tttt=0;
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
void ins(int &amp;v,int u,int l,int r,int x)
{
	if (!v) v=++TTT;
	size[v]=size[u]+1;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid)
		rc[v]=rc[u],ins(lc[v],lc[u],l,mid,x);
	else
		lc[v]=lc[u],ins(rc[v],rc[u],mid,r,x);
}
int find(int v,int u,int l,int r,int x)
{
	if (r-l==1) return 0;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid)
		return size[rc[v]]-size[rc[u]]+find(lc[v],lc[u],l,mid,x);
	else return find(rc[v],rc[u],mid,r,x);
}
void dfs(int v)
{
	begin[v]=++cnt;
	b[cnt]=v;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dfs(y);
	}
	end[v]=cnt;
}
void build()
{
	//clock_t nnnn=clock();
	cnt=0;
	fa[1]=0;
	dfs(1);
	int i;
	for (i=1;i&lt;=TTT;i++) lc[i]=rc[i]=size[i]=0;
	TTT=0;
	//printf(&quot;w &quot;);out(w,1,n);
	for (i=1;i&lt;=n;i++)
	{
		root[i]=0;
		ins(root[i],root[i-1],-inf,inf,w[b[i]]);
	}
	lastn=n;
	for (i=1;i&lt;=n;i++) up[i]=i,lastw[i]=w[i];
	num=0;
	TIME++;
	//tttt+=(double)(clock()-nnnn);
}
void dfs2(int v,int x)
{
	//printf(&quot;dfs2 %d\n&quot;,v);
	if (w[v]&gt;x) ans++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dfs2(y,x);
	}
}
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int main()
{
	//clock_t chushi=clock();tttt=0;
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j,x,y;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;w[i]);
	build();
	scanf(&quot;%d&quot;,&amp;m);
	lastans=0;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		//printf(&quot;\n-------------------- kind=%d ------------------------------------------------\n&quot;,x);
		if (x==0)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x^=lastans,y^=lastans;
			ans=0;
			if (x&lt;=lastn)
			{
				int l=begin[x],r=end[x];
				ans=find(root[end[x]],root[begin[x]-1],-inf,inf,y);
				//printf(&quot;ans=%d\n&quot;,ans);
				for (j=1;j&lt;=num;j++)
					if (l&lt;=begin[c[j]]&amp;&amp;begin[c[j]]&lt;=r)
					{
						if (lastw[c[j]]&gt;y&amp;&amp;w[c[j]]&lt;=y) ans--;
						else if (lastw[c[j]]&lt;=y&amp;&amp;w[c[j]]&gt;y) ans++;
					}
				for (j=lastn+1;j&lt;=n;j++)
					if (l&lt;=begin[up[j]]&amp;&amp;begin[up[j]]&lt;=r&amp;&amp;w[j]&gt;y) ans++;
			}
			else dfs2(x,y);
			printf(&quot;%d\n&quot;,lastans=ans);
		}
		else if (x==1)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x^=lastans,y^=lastans;
			w[x]=y;
			if (vt[x]!=TIME)
				vt[x]=TIME,w[x]=y,c[++num]=x;
		}
		else
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x^=lastans,y^=lastans;
			n++;
			fa[n]=x;
			w[n]=y;
			up[n]=up[x];
			addedge(fa[n],n),addedge(n,fa[n]);
		}
		if (i%2000==0) build();
	}
	//printf(&quot;tot time = %.5f\n&quot;,(double)(clock()-chushi)/CLOCKS_PER_SEC);
	//printf(&quot;rebuild time = %.5f\n&quot;,tttt/CLOCKS_PER_SEC);
	return 0;
}<pre><h2>Problem3720</h2><pre>#include&lt;cstdio&gt;
//#include&lt;ctime&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=60111,NNN=1301111,inf=999999999;
int lc[NNN],rc[NNN],size[NNN],o[NN],aa[NN*2][2],b[NN],c[NN],w[NN];
int begin[NN],end[NN],up[NN],root[NN],vt[NN],fa[NN],lastw[NN];
int n,m,tot=1,cnt,num,TTT,TIME,lastn,lastans,ans;
//double tttt=0;
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
void ins(int &amp;v,int u,int l,int r,int x)
{
	if (!v) v=++TTT;
	size[v]=size[u]+1;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid)
		rc[v]=rc[u],ins(lc[v],lc[u],l,mid,x);
	else
		lc[v]=lc[u],ins(rc[v],rc[u],mid,r,x);
}
int find(int v,int u,int l,int r,int x)
{
	if (r-l==1) return 0;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid)
		return size[rc[v]]-size[rc[u]]+find(lc[v],lc[u],l,mid,x);
	else return find(rc[v],rc[u],mid,r,x);
}
void dfs(int v)
{
	begin[v]=++cnt;
	b[cnt]=v;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dfs(y);
	}
	end[v]=cnt;
}
void build()
{
	//clock_t nnnn=clock();
	cnt=0;
	fa[1]=0;
	dfs(1);
	int i;
	for (i=1;i&lt;=TTT;i++) lc[i]=rc[i]=size[i]=0;
	TTT=0;
	//printf(&quot;w &quot;);out(w,1,n);
	for (i=1;i&lt;=n;i++)
	{
		root[i]=0;
		ins(root[i],root[i-1],0,inf,w[b[i]]);
	}
	lastn=n;
	for (i=1;i&lt;=n;i++) up[i]=i,lastw[i]=w[i];
	num=0;
	TIME++;
	//tttt+=(double)(clock()-nnnn);
}
void dfs2(int v,int x)
{
	//printf(&quot;dfs2 %d\n&quot;,v);
	if (w[v]&gt;x) ans++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dfs2(y,x);
	}
}
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int main()
{
	//clock_t chushi=clock();tttt=0;
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j,x,y;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;w[i]);
	build();
	scanf(&quot;%d&quot;,&amp;m);
	lastans=0;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		//printf(&quot;\n-------------------- kind=%d ------------------------------------------------\n&quot;,x);
		if (x==0)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x^=lastans,y^=lastans;
			ans=0;
			if (x&lt;=lastn)
			{
				int l=begin[x],r=end[x];
				ans=find(root[end[x]],root[begin[x]-1],0,inf,y);
				//printf(&quot;ans=%d\n&quot;,ans);
				for (j=1;j&lt;=num;j++)
					if (l&lt;=begin[c[j]]&amp;&amp;begin[c[j]]&lt;=r)
					{
						if (lastw[c[j]]&gt;y&amp;&amp;w[c[j]]&lt;=y) ans--;
						else if (lastw[c[j]]&lt;=y&amp;&amp;w[c[j]]&gt;y) ans++;
					}
				for (j=lastn+1;j&lt;=n;j++)
					if (l&lt;=begin[up[j]]&amp;&amp;begin[up[j]]&lt;=r&amp;&amp;w[j]&gt;y) ans++;
			}
			else dfs2(x,y);
			printf(&quot;%d\n&quot;,lastans=ans);
		}
		else if (x==1)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x^=lastans,y^=lastans;
			w[x]=y;
			if (vt[x]!=TIME)
				vt[x]=TIME,w[x]=y,c[++num]=x;
		}
		else
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x^=lastans,y^=lastans;
			n++;
			fa[n]=x;
			w[n]=y;
			up[n]=up[x];
			addedge(fa[n],n),addedge(n,fa[n]);
		}
		//if (i%173==0) build();
	}
	//printf(&quot;tot time = %.5f\n&quot;,(double)(clock()-chushi)/CLOCKS_PER_SEC);
	//printf(&quot;rebuild time = %.5f\n&quot;,tttt/CLOCKS_PER_SEC);
	return 0;
}<pre><h2>Problem3720</h2><pre>#include&lt;cstdio&gt;
//#include&lt;ctime&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=60111,NNN=1301111,inf=999999999;
int lc[NNN],rc[NNN],size[NNN],o[NN],aa[NN*2][2],b[NN],c[NN],w[NN];
int begin[NN],end[NN],up[NN],root[NN],vt[NN],fa[NN],lastw[NN];
int n,m,tot=1,cnt,num,TTT,TIME,lastn,lastans,ans;
//double tttt=0;
void out(int *a,int l,int r){for(int i=l;i&lt;=r;i++)printf(&quot;%d &quot;,a[i]);ln;}
void ins(int &amp;v,int u,int l,int r,int x)
{
	if (!v) v=++TTT;
	size[v]=size[u]+1;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid)
		rc[v]=rc[u],ins(lc[v],lc[u],l,mid,x);
	else
		lc[v]=lc[u],ins(rc[v],rc[u],mid,r,x);
}
int find(int v,int u,int l,int r,int x)
{
	if (r-l==1) return 0;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid)
		return size[rc[v]]-size[rc[u]]+find(lc[v],lc[u],l,mid,x);
	else return find(rc[v],rc[u],mid,r,x);
}
void dfs(int v)
{
	begin[v]=++cnt;
	b[cnt]=v;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dfs(y);
	}
	end[v]=cnt;
}
void build()
{
	//clock_t nnnn=clock();
	cnt=0;
	fa[1]=0;
	dfs(1);
	int i;
	for (i=1;i&lt;=TTT;i++) lc[i]=rc[i]=size[i]=0;
	TTT=0;
	//printf(&quot;w &quot;);out(w,1,n);
	for (i=1;i&lt;=n;i++)
	{
		root[i]=0;
		ins(root[i],root[i-1],0,inf,w[b[i]]);
	}
	lastn=n;
	for (i=1;i&lt;=n;i++) up[i]=i,lastw[i]=w[i];
	num=0;
	TIME++;
	//tttt+=(double)(clock()-nnnn);
}
void dfs2(int v,int x)
{
	//printf(&quot;dfs2 %d\n&quot;,v);
	if (w[v]&gt;x) ans++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dfs2(y,x);
	}
}
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
int main()
{
	//clock_t chushi=clock();tttt=0;
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,j,x,y;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;w[i]);
	build();
	scanf(&quot;%d&quot;,&amp;m);
	lastans=0;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		//printf(&quot;\n-------------------- kind=%d ------------------------------------------------\n&quot;,x);
		if (x==0)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x^=lastans,y^=lastans;
			ans=0;
			if (x&lt;=lastn)
			{
				int l=begin[x],r=end[x];
				ans=find(root[end[x]],root[begin[x]-1],0,inf,y);
				//printf(&quot;ans=%d\n&quot;,ans);
				for (j=1;j&lt;=num;j++)
					if (l&lt;=begin[c[j]]&amp;&amp;begin[c[j]]&lt;=r)
					{
						if (lastw[c[j]]&gt;y&amp;&amp;w[c[j]]&lt;=y) ans--;
						else if (lastw[c[j]]&lt;=y&amp;&amp;w[c[j]]&gt;y) ans++;
					}
				for (j=lastn+1;j&lt;=n;j++)
					if (l&lt;=begin[up[j]]&amp;&amp;begin[up[j]]&lt;=r&amp;&amp;w[j]&gt;y) ans++;
			}
			else dfs2(x,y);
			printf(&quot;%d\n&quot;,lastans=ans);
		}
		else if (x==1)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x^=lastans,y^=lastans;
			w[x]=y;
			if (x&lt;=lastn&amp;&amp;vt[x]!=TIME)
				vt[x]=TIME,c[++num]=x;
		}
		else
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			x^=lastans,y^=lastans;
			n++;
			fa[n]=x;
			w[n]=y;
			up[n]=up[x];
			addedge(fa[n],n),addedge(n,fa[n]);
		}
		//if (i%173==0) build();
	}
	//printf(&quot;tot time = %.5f\n&quot;,(double)(clock()-chushi)/CLOCKS_PER_SEC);
	//printf(&quot;rebuild time = %.5f\n&quot;,tttt/CLOCKS_PER_SEC);
	return 0;
}<pre><h2>Problem3721</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
#define inf 1000000005
const int NN=1001111;
int a[NN],min0[NN],min1[NN],max0[NN],max1[NN];
int n,m,K;
LL sum[NN];
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);ln;}
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
inline bool cmp(const int &amp;a,const int &amp;b) {return a&gt;b;}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);
	int i;
	for (i=1;i&lt;=n;i++) read(a[i]);
	sort(a+1,a+n+1,cmp);
	min0[0]=min1[0]=inf;
	for (i=1;i&lt;=n;i++)
	{
		sum[i]=sum[i-1]+a[i];
		min0[i]=min0[i-1];
		min1[i]=min1[i-1];
		if (a[i]&amp;1) min1[i]=min(min1[i],a[i]);
		else min0[i]=min(min0[0],a[i]);
	}
	max0[n+1]=max1[n+1]=-1;
	for (i=n;i;i--)
	{
		max0[i]=max0[i+1];
		max1[i]=max1[i+1];
		if (a[i]&amp;1) max1[i]=max(max1[i],a[i]);
		else max0[i]=max(max0[i],a[i]);
	}
	//printf(&quot;a &quot;);out(a,1,n);ln;printf(&quot;min0 &quot;);out(min0,1,n);printf(&quot;min1 &quot;);out(min1,1,n);printf(&quot;max0 &quot;);out(max0,1,n);printf(&quot;max1 &quot;);out(min1,1,n);
	for (read(m);m;m--)
	{
		read(K);
		if (sum[K]&amp;1) {printf(&quot;%lld\n&quot;,sum[K]);continue;}
		LL ans=-1;
		if (min0[K]!=inf&amp;&amp;max1[K+1]!=-1) ans=sum[K]-min0[K]+max1[K+1];
		if (min1[K]!=inf&amp;&amp;max0[K+1]!=-1) ans=max(ans,sum[K]-min1[K]+max0[K+1]);
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem3721</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define inf 1000000005
const int NN=1001111;
int a[NN],min0[NN],min1[NN],max0[NN],max1[NN];
int n,m,K;
LL sum[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
inline bool cmp(const int &amp;a,const int &amp;b) {return a&gt;b;}
int main()
{
	read(n);
	int i;
	for (i=1;i&lt;=n;i++) read(a[i]);
	sort(a+1,a+n+1,cmp);
	min0[0]=min1[0]=inf;
	for (i=1;i&lt;=n;i++)
	{
		sum[i]=sum[i-1]+a[i];
		min0[i]=min0[i-1];
		min1[i]=min1[i-1];
		if (a[i]&amp;1) min1[i]=min(min1[i],a[i]);
		else min0[i]=min(min0[0],a[i]);
	}
	max0[n+1]=max1[n+1]=-1;
	for (i=n;i;i--)
	{
		max0[i]=max0[i+1];
		max1[i]=max1[i+1];
		if (a[i]&amp;1) max1[i]=max(max1[i],a[i]);
		else max0[i]=max(max0[i],a[i]);
	}
	for (read(m);m;m--)
	{
		read(K);
		if (sum[K]&amp;1) {printf(&quot;%lld\n&quot;,sum[K]);continue;}
		LL ans=-1;
		if (min0[K]!=inf&amp;&amp;max1[K+1]!=-1) ans=sum[K]-min0[K]+max1[K+1];
		if (min1[K]!=inf&amp;&amp;max0[K+1]!=-1) ans=max(ans,sum[K]-min1[K]+max0[K+1]);
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem3722</h2><pre>#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
using namespace std;
int n;
struct edge{int v,next;}e[2005];int etot=0;int g[2005];
void ae(int u,int v){
     e[etot].v=v;e[etot].next=g[u];g[u]=etot++;
}
int f[2005],dif[2005];
void dfs(int u){
     int a1=0,a2=0;
     for (int i=g[u];~i;i=e[i].next){
         dfs(e[i].v);
         if(f[e[i].v]==-2)a2++;
         else if(f[e[i].v]==-1)a1++;
     }
     if(g[u]==-1)return;
     if(a1==a2)f[u]=0;
     else if(a1&gt;a2)f[u]=-1;
     else f[u]=-2;
     dif[u]=a1-a2;
}
int ans[2005];int tot=0;
void dfs2(int u,int fl){
     if(!~g[u] &amp;&amp; f[u]==0)ans[++tot]=u;
     for (int i=g[u];~i;i=e[i].next)
         if(fl || !f[e[i].v] || dif[e[i].v]==1)dfs2(e[i].v,fl);
}
int main()
{
    memset(g,-1,sizeof(g));
    scanf(&quot;%d&quot;,&amp;n);
    for (int i=1;i&lt;=n;i++){
        int k;scanf(&quot;%d&quot;,&amp;k);
        if(k&lt;=0)f[i]=k;
        else{
             while(k--){
                        int t;scanf(&quot;%d&quot;,&amp;t);
                        ae(i,t);
             }
        }
    }
    dfs(1);
    if(f[1]==-1)printf(&quot;NIE\n&quot;);
    else{
         dfs2(1,f[1]);
         printf(&quot;TAK %d\n&quot;,tot);
         sort(ans+1,ans+1+tot);
         for (int i=1;i&lt;=tot;i++){
             if(i&gt;1)printf(&quot; &quot;);
             printf(&quot;%d&quot;,ans[i]);
         }
         printf(&quot;\n&quot;);
    }
    return 0;
}<pre><h2>Problem3722</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
int n;
struct edge{int v,next;}e[2005];int etot=0;int g[2005];
void ae(int u,int v){
     e[etot].v=v;e[etot].next=g[u];g[u]=etot++;
}
int f[2005],dif[2005];
void dfs(int u)
{
    int a1=0,a2=0;
    for (int i=g[u];~i;i=e[i].next)
	{
        dfs(e[i].v);
        if (f[e[i].v]==-2) a2++;
        else if (f[e[i].v]==-1) a1++;
    }
    if (g[u]==-1) return;
    if (a1==a2) f[u]=0;
    else if (a1&gt;a2) f[u]=-1;
    else f[u]=-2;
    dif[u]=a1-a2;
}
int ans[2005];int tot=0;
void dfs2(int u,int fl)
{
     if (!~g[u] &amp;&amp; f[u]==0) ans[++tot]=u;
     for (int i=g[u];~i;i=e[i].next)
         if (fl || !f[e[i].v] || dif[e[i].v]==1) dfs2(e[i].v,fl);
}
int main()
{
    memset(g,-1,sizeof(g));
    scanf(&quot;%d&quot;,&amp;n);
    for (int i=1;i&lt;=n;i++)
	{
        int k;
		scanf(&quot;%d&quot;,&amp;k);
        if (k&lt;=0) f[i]=k;
        else
		{
            while (k--)
			{
                int t;
				scanf(&quot;%d&quot;,&amp;t);
                ae(i,t);
            }
        }
    }
    dfs(1);
    if (f[1]==-1) printf(&quot;NIE\n&quot;);
    else
	{
        dfs2(1,f[1]);
        printf(&quot;TAK %d\n&quot;,tot);
        sort(ans+1,ans+1+tot);
        for (int i=1;i&lt;=tot;i++)
		{
            if (i&gt;1) printf(&quot; &quot;);
            printf(&quot;%d&quot;,ans[i]);
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}<pre><h2>Problem3722</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
int n;
struct edge{int v,next;}e[2005];int etot=0;int g[2005];
void ae(int u,int v){
     e[etot].v=v;e[etot].next=g[u];g[u]=etot++;
}
int f[2005],dif[2005];
void dfs(int u)
{
    int a1=0,a2=0;
    for (int i=g[u];~i;i=e[i].next)
	{
        dfs(e[i].v);
        if (f[e[i].v]==-2) a2++;
        else if (f[e[i].v]==-1) a1++;
    }
    if (g[u]==-1) return;
    if (a1==a2) f[u]=0;
    else if (a1&gt;a2) f[u]=-1;
    else f[u]=-2;
    dif[u]=a1-a2;
}
int ans[2005];int tot=0;
void dfs2(int u,int fl)
{
     if (g[u]==-1 &amp;&amp; f[u]==0) ans[++tot]=u;
     for (int i=g[u];i!=-1;i=e[i].next)
         if (fl || !f[e[i].v] || dif[e[i].v]==1) dfs2(e[i].v,fl);
}
int main()
{
    memset(g,-1,sizeof(g));
    scanf(&quot;%d&quot;,&amp;n);
    for (int i=1;i&lt;=n;i++)
	{
        int k;
		scanf(&quot;%d&quot;,&amp;k);
        if (k&lt;=0) f[i]=k;
        else
		{
            while (k--)
			{
                int t;
				scanf(&quot;%d&quot;,&amp;t);
                ae(i,t);
            }
        }
    }
    dfs(1);
    if (f[1]==-1) printf(&quot;NIE\n&quot;);
    else
	{
        dfs2(1,f[1]);
        printf(&quot;TAK %d\n&quot;,tot);
        sort(ans+1,ans+1+tot);
        for (int i=1;i&lt;=tot;i++)
		{
            if (i&gt;1) printf(&quot; &quot;);
            printf(&quot;%d&quot;,ans[i]);
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}<pre><h2>Problem3722</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
int n;
struct edge{int v,next;}e[2005];int etot=0;int g[2005];
void ae(int u,int v){
     e[etot].v=v;e[etot].next=g[u];g[u]=etot++;
}
int f[2005],dif[2005];
void dfs(int u)
{
    int a1=0,a2=0;
    for (int i=g[u];~i;i=e[i].next)
	{
        dfs(e[i].v);
        if (f[e[i].v]==-2) a2++;
        else if (f[e[i].v]==-1) a1++;
    }
    if (g[u]==-1) return;
    if (a1==a2) f[u]=0;
    else if (a1&gt;a2) f[u]=-1;
    else f[u]=-2;
    dif[u]=a1-a2;
}
int ans[2005];int tot=0;
void dfs2(int u,int fl)
{
     if (g[u]==-1 &amp;&amp; f[u]==0) ans[++tot]=u;
     for (int i=g[u];i!=-1;i=e[i].next)
         if (f[1] || !f[e[i].v] || dif[e[i].v]==1) dfs2(e[i].v,fl);
}
int main()
{
    memset(g,-1,sizeof(g));
    scanf(&quot;%d&quot;,&amp;n);
    for (int i=1;i&lt;=n;i++)
	{
        int k;
		scanf(&quot;%d&quot;,&amp;k);
        if (k&lt;=0) f[i]=k;
        else
		{
            while (k--)
			{
                int t;
				scanf(&quot;%d&quot;,&amp;t);
                ae(i,t);
            }
        }
    }
    dfs(1);
    if (f[1]==-1) printf(&quot;NIE\n&quot;);
    else
	{
        dfs2(1,f[1]);
        printf(&quot;TAK %d\n&quot;,tot);
        sort(ans+1,ans+1+tot);
        for (int i=1;i&lt;=tot;i++)
		{
            if (i&gt;1) printf(&quot; &quot;);
            printf(&quot;%d&quot;,ans[i]);
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}<pre><h2>Problem3722</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
int n;
struct edge{int v,next;}e[2005];int etot=0;int g[2005];
void ae(int u,int v){
     e[etot].v=v;e[etot].next=g[u];g[u]=etot++;
}
int f[2005],dif[2005];
void dfs(int u)
{
    int a1=0,a2=0;
    for (int i=g[u];~i;i=e[i].next)
	{
        dfs(e[i].v);
        if (f[e[i].v]==-2) a2++;
        else if (f[e[i].v]==-1) a1++;
    }
    if (g[u]==-1) return;
    if (a1==a2) f[u]=0;
    else if (a1&gt;a2) f[u]=-1;
    else f[u]=-2;
    dif[u]=a1-a2;
}
int ans[2005];int tot=0;
void dfs2(int u)
{
     if (g[u]==-1 &amp;&amp; f[u]==0) ans[++tot]=u;
     for (int i=g[u];i!=-1;i=e[i].next)
         if (f[1] || !f[e[i].v] || dif[e[i].v]==1) dfs2(e[i].v);
}
int main()
{
    memset(g,-1,sizeof(g));
    scanf(&quot;%d&quot;,&amp;n);
    for (int i=1;i&lt;=n;i++)
	{
        int k;
		scanf(&quot;%d&quot;,&amp;k);
        if (k&lt;=0) f[i]=k;
        else
		{
            while (k--)
			{
                int t;
				scanf(&quot;%d&quot;,&amp;t);
                ae(i,t);
            }
        }
    }
    dfs(1);
    if (f[1]==-1) printf(&quot;NIE\n&quot;);
    else
	{
        dfs2(1);
        printf(&quot;TAK %d\n&quot;,tot);
        sort(ans+1,ans+1+tot);
        for (int i=1;i&lt;=tot;i++)
		{
            if (i&gt;1) printf(&quot; &quot;);
            printf(&quot;%d&quot;,ans[i]);
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}<pre><h2>Problem3730</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
typedef pair&lt;int,int&gt; pii;
#define mp make_pair
#define fi first
#define se second
#define pb push_back
const int NN=100001;
int o[NN],aa[NN*2][2],deep[NN],fa[NN],size[NN],boss[NN],w[NN];
int pos[NN],dist[NN],f[21][NN&lt;&lt;1],log[NN&lt;&lt;1];
int n,m,tot=1,root,cnt;
vector&lt;pii&gt; sum1[NN],sum2[NN];
vector&lt;int&gt; C1[NN],C2[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs(int v)
{
	pos[v]=cnt+1;
	f[0][++cnt]=dist[v];
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dist[y]=dist[v]+1;
		dfs(y);
		f[0][++cnt]=dist[v];
	}
}
inline int getdist(int x,int y)
{
	int l=pos[x],r=pos[y];
	if (l&gt;r) {int t=l;l=r;r=t;}
	int t=log[r-l+1];
	return dist[x]+dist[y]-(min(f[t][l],f[t][r-(1&lt;&lt;t)+1])&lt;&lt;1);
}
void calcsize(int v)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||deep[y]&lt;deep[v]) continue;
		fa[y]=v;
		calcsize(y);
		size[v]+=size[y];
	}
}
int core(int v)
{
	fa[v]=0,calcsize(v);
	for (;;)
	{
		bool flag=false;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (deep[y]&lt;deep[v]) continue;
			if (size[y]*2&gt;size[v])
			{
				size[v]-=size[y];
				size[y]+=size[v];
				v=y;flag=true;break;
			}
		}
		if (!flag) break;
	}
	return v;
}
void work(int v)
{
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]) continue;
		y=core(y);
		boss[y]=v;
		deep[y]=deep[v]+1;
		work(y);
	}
}
void go(int x,int tt)
{
	sum1[x].pb(mp(0,tt));
	for (int y=x;boss[y];y=boss[y])
	{
		int ff=boss[y],d=getdist(x,ff);
		sum1[ff].pb(mp(d,tt));
		sum2[y].pb(mp(d,tt));
	}
}
inline int cha(vector&lt;pii&gt; &amp;a,int x)
{
	int l=1,r=a.size()-1,res=-1;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (a[mid].fi==x) return mid;
		else if (a[mid].fi&lt;x) res=mid,l=mid+1;
		else r=mid-1;
	}
	return res;
}
inline void change(vector&lt;int&gt; &amp;a,int i,int x)
{
	int n=a.size()-1;
	for (;i&lt;=n;i+=i&amp;-i) a[i]+=x;
}
inline int getsum(vector&lt;int&gt; &amp;a,int i)
{
	int res=0;
	for (;i;i-=i&amp;-i) res+=a[i];
	return res;
}
inline int query(vector&lt;pii&gt; &amp;a,vector&lt;int&gt; &amp;c,int K)
{
	int t=cha(a,K);
	if (t==-1) return 0;
	return getsum(c,t);
}
int calc(int x,int K)
{
	int res=query(sum1[x],C1[x],K);
	for (int y=x;boss[y];y=boss[y])
	{
		int ff=boss[y],d=getdist(x,ff);
		if (K&lt;d) continue;
		res+=query(sum1[ff],C1[ff],K-d);
		res-=query(sum2[y],C2[y],K-d);
	}
	return res;
}
void modify(int x,int tt)
{
	change(C1[x],cha(sum1[x],0),tt);
	for (int y=x;boss[y];y=boss[y])
	{
		int ff=boss[y],d=getdist(x,ff);
		change(C1[ff],cha(sum1[ff],d),tt);
		change(C2[y],cha(sum2[y],d),tt);
	}
}
int main()
{
	read(n),read(m);
	int i,j,x,y,z;
	for (i=1;i&lt;=n;i++) read(w[i]);
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y);
		addedge(x,y),addedge(y,x);
	}
	dfs(1);
	for (j=1;j&lt;=20;j++)
		for (i=1;i+(1&lt;&lt;(j-1))&lt;=cnt;i++)
			f[j][i]=min(f[j-1][i],f[j-1][i+(1&lt;&lt;(j-1))]);
	log[1]=0;
	for (i=2;i&lt;=cnt;i++) log[i]=(i==(i&amp;-i))?log[i-1]+1:log[i-1];
	memset(deep,60,sizeof(deep));
	root=core(1);
	deep[root]=1;
	work(root);
	for (i=1;i&lt;=n;i++)
		sum1[i].pb(mp(-1,0)),sum2[i].pb(mp(-1,0));
	for (i=1;i&lt;=n;i++) go(i,w[i]);
	for (i=1;i&lt;=n;i++)
	{
		sort(sum1[i].begin(),sum1[i].end());
		x=sum1[i].size()-1;
		C1[i].resize(x+3);
		for (j=1;j&lt;=x;j++)
			change(C1[i],cha(sum1[i],sum1[i][j].fi),sum1[i][j].se);
		sort(sum2[i].begin(),sum2[i].end());
		x=sum2[i].size()-1;
		C2[i].resize(x+3);
		for (j=1;j&lt;=x;j++)
			change(C2[i],cha(sum2[i],sum2[i][j].fi),sum2[i][j].se);
	}
	int lastans=0;
	for (;m;m--)
	{
		read(x),read(y),read(z);
		y^=lastans,z^=lastans;
		if (x==0) printf(&quot;%d\n&quot;,lastans=calc(y,z));
		else modify(y,z-w[y]),w[y]=z;
	}
	return 0;
}<pre><h2>Problem3730</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
typedef pair&lt;int,int&gt; pii;
#define mp make_pair
#define fi first
#define se second
#define pb push_back
const int NN=100001;
int o[NN],aa[NN*2][2],deep[NN],fa[NN],size[NN],boss[NN],w[NN];
int pos[NN],dist[NN],f[21][NN&lt;&lt;1],log[NN&lt;&lt;1];
int n,m,tot=1,root,cnt;
vector&lt;pii&gt; sum1[NN],sum2[NN];
vector&lt;int&gt; C1[NN],C2[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs(int v)
{
	pos[v]=cnt+1;
	f[0][++cnt]=dist[v];
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dist[y]=dist[v]+1;
		dfs(y);
		f[0][++cnt]=dist[v];
	}
}
inline int getdist(int x,int y)
{
	int l=pos[x],r=pos[y];
	if (l&gt;r) {int t=l;l=r;r=t;}
	int t=log[r-l+1];
	return dist[x]+dist[y]-(min(f[t][l],f[t][r-(1&lt;&lt;t)+1])&lt;&lt;1);
}
void calcsize(int v)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||deep[y]&lt;deep[v]) continue;
		fa[y]=v;
		calcsize(y);
		size[v]+=size[y];
	}
}
int core(int v)
{
	fa[v]=0,calcsize(v);
	for (;;)
	{
		bool flag=false;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (deep[y]&lt;deep[v]) continue;
			if (size[y]*2&gt;size[v])
			{
				size[v]-=size[y];
				size[y]+=size[v];
				v=y;flag=true;break;
			}
		}
		if (!flag) break;
	}
	return v;
}
void work(int v)
{
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]) continue;
		y=core(y);
		boss[y]=v;
		deep[y]=deep[v]+1;
		work(y);
	}
}
void go(int x,int tt)
{
	sum1[x].pb(mp(0,tt));
	for (int y=x;boss[y];y=boss[y])
	{
		int ff=boss[y],d=getdist(x,ff);
		sum1[ff].pb(mp(d,tt));
		sum2[y].pb(mp(d,tt));
	}
}
inline int cha(vector&lt;pii&gt; &amp;a,int x)
{
	int l=1,r=a.size()-1,res=-1;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (a[mid].fi==x) return mid;
		else if (a[mid].fi&lt;x) res=mid,l=mid+1;
		else r=mid-1;
	}
	return res;
}
inline void change(vector&lt;int&gt; &amp;a,int i,int x)
{
	int n=a.size()-1;
	for (;i&lt;=n;i+=i&amp;-i) a[i]+=x;
}
inline int getsum(vector&lt;int&gt; &amp;a,int i)
{
	int res=0;
	for (;i;i-=i&amp;-i) res+=a[i];
	return res;
}
inline int query(vector&lt;pii&gt; &amp;a,vector&lt;int&gt; &amp;c,int K)
{
	int t=cha(a,K);
	if (t==-1) return 0;
	return getsum(c,t);
}
int calc(int x,int K)
{
	int res=query(sum1[x],C1[x],K);
	for (int y=x;boss[y];y=boss[y])
	{
		int ff=boss[y],d=getdist(x,ff);
		if (K&lt;d) continue;
		res+=query(sum1[ff],C1[ff],K-d);
		res-=query(sum2[y],C2[y],K-d);
	}
	return res;
}
void modify(int x,int tt)
{
	change(C1[x],cha(sum1[x],0),tt);
	for (int y=x;boss[y];y=boss[y])
	{
		int ff=boss[y],d=getdist(x,ff);
		change(C1[ff],cha(sum1[ff],d),tt);
		change(C2[y],cha(sum2[y],d),tt);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	int i,j,x,y,z;
	for (i=1;i&lt;=n;i++) read(w[i]);
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y);
		addedge(x,y),addedge(y,x);
	}
	dfs(1);
	for (j=1;j&lt;=20;j++)
		for (i=1;i+(1&lt;&lt;(j-1))&lt;=cnt;i++)
			f[j][i]=min(f[j-1][i],f[j-1][i+(1&lt;&lt;(j-1))]);
	log[1]=0;
	for (i=2;i&lt;=cnt;i++) log[i]=(i==(i&amp;-i))?log[i-1]+1:log[i-1];
	memset(deep,60,sizeof(deep));
	root=core(1);
	deep[root]=1;
	work(root);
	for (i=1;i&lt;=n;i++)
		sum1[i].pb(mp(-1,0)),sum2[i].pb(mp(-1,0));
	for (i=1;i&lt;=n;i++) go(i,w[i]);
	for (i=1;i&lt;=n;i++)
	{
		sort(sum1[i].begin(),sum1[i].end());
		x=sum1[i].size()-1;
		C1[i].resize(x+3);
		for (j=1;j&lt;=x;j++)
			change(C1[i],cha(sum1[i],sum1[i][j].fi),sum1[i][j].se);
		sort(sum2[i].begin(),sum2[i].end());
		x=sum2[i].size()-1;
		C2[i].resize(x+3);
		for (j=1;j&lt;=x;j++)
			change(C2[i],cha(sum2[i],sum2[i][j].fi),sum2[i][j].se);
	}
	int lastans=0;
	for (;m;m--)
	{
		read(x),read(y),read(z);
		y^=lastans,z^=lastans;
		if (x==0) printf(&quot;%d\n&quot;,lastans=calc(y,z));
		else modify(y,z-w[y]),w[y]=z;
	}
	return 0;
}<pre><h2>Problem3732</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=15011,MM=30111;
int fa[NN],size[NN],the[NN],deep[NN];
int n,m,Q;
struct edge
{
	int u,v,w;
	inline void in() {scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);}
	friend bool operator &lt;(const edge &amp;a,const edge &amp;b) {return a.w&lt;b.w;}
} e[MM];
inline int getfa(int x)
{
	while (fa[x]!=x) x=fa[x];
	return x;
}
void getdeep(int x)
{
	if (deep[x]) return;
	if (fa[x]==x)
	{
		deep[x]=1;
		return;
	}
	getdeep(fa[x]);
	deep[x]=deep[fa[x]]+1;
}
void kruskal()
{
	sort(e+1,e+m+1);
	int i;
	for (i=1;i&lt;=n;i++) fa[i]=i,size[i]=1;
	int cnt=0;
	for (i=1;cnt&lt;n-1&amp;&amp;i&lt;=m;i++)
	{
		int x=getfa(e[i].u),y=getfa(e[i].v);
		if (x==y) continue;
		cnt++;
		if (size[x]&lt;size[y]) {int t=x;x=y;y=t;}
		fa[y]=x;
		size[x]+=size[y];
		the[y]=e[i].w;
		//printf(&quot;fa &quot;);for (int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,fa[i]);ln;ln;
	}
	for (i=1;i&lt;=n;i++) getdeep(i);
}
int work(int x,int y)
{
	if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
	int ans=0;
	while (deep[x]&gt;deep[y])
	{
		if (the[x]&gt;ans) ans=the[x];
		x=fa[x];
	}
	while (x!=y)
	{
		if (the[x]&gt;ans) ans=the[x];
		if (the[y]&gt;ans) ans=the[y];
		x=fa[x],y=fa[y];
	}
	return ans;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;Q);
	int i,x,y;
	for (i=1;i&lt;=m;i++) e[i].in();
	kruskal();
	for (;Q;Q--)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		printf(&quot;%d\n&quot;,work(x,y));
	}
	return 0;
}<pre><h2>Problem3747</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define lc(v) ((v)&lt;&lt;1)
#define rc(v) ((v)&lt;&lt;1|1)
const int NN=1000111;
int f[NN],w[NN],now[NN],pre[NN],nex[NN];
int n,m,ww,ee;
LL tag[NN&lt;&lt;2],tmax[NN&lt;&lt;2];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar());
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
}
inline void add(int v,LL x)
{
	tag[v]+=x;
	tmax[v]+=x;
}
inline void pushdown(int v)
{
	if (tag[v])
	{
		add(lc(v),tag[v]);
		add(rc(v),tag[v]);
		tag[v]=0;
	}
}
inline void update(int v)
{
	tmax[v]=max(tmax[lc(v)],tmax[rc(v)]);
}
void change(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		add(v,x);
		return;
	}
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) change(lc(v),l,mid,x);
	if (ee&gt;mid) change(rc(v),mid,r,x);
	update(v);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	int i;
	for (i=1;i&lt;=n;i++) read(f[i]);
	for (i=1;i&lt;=m;i++) read(w[i]);
	for (i=1;i&lt;=n;i++)
	{
		pre[i]=now[f[i]];
		now[f[i]]=i;
	}
	for (i=1;i&lt;=m;i++) now[i]=n+1;
	for (i=n;i;i--)
	{
		nex[i]=now[f[i]];
		now[f[i]]=i;
	}
	for (i=1;i&lt;=n;i++)
		if (pre[i]&lt;1)
		{
			ww=i,ee=nex[i];
			if (ww&lt;ee) change(1,1,n+1,w[f[i]]);
		}
	LL ans=tmax[1];
	for (i=1;i&lt;=n;i++)
	{
		ww=i,ee=nex[i];
		if (ww&lt;ee) change(1,1,n+1,-w[f[i]]);
		ww=nex[i],ee=nex[nex[i]];
		if (ww&lt;ee) change(1,1,n+1,w[f[i]]);
		if (tmax[1]&gt;ans) ans=tmax[1];
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem3757</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 110000
int num[NN],fa1[NN],fa2[NN],aa[NN*2][2],o[NN],root[NN],dfn[NN],color[NN],size[NN],ans[NN];
int tot,n,m,uu[3],wer[3],TIME,sqrtn,now;
bool vt[NN];
struct orz {int x,y,a,b,id;} ask[NN];
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
void dfs(int v)
{
	dfn[v]=++TIME;
	int rt=root[v];
	size[rt]++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa1[v]) continue;
		fa1[y]=fa2[y]=v;
		if (size[rt]&lt;sqrtn) root[y]=root[v];
		dfs(y);
	}
}
bool cmp(orz a,orz b)
{
	return (root[a.x]!=root[b.x]?root[a.x]&lt;root[b.x]:dfn[a.y]&lt;dfn[b.y]);
}
void work(int kind,int *fa,int v1,int v2)
{
	int tmp=v2;
	while (!vt[v2])
	{
		vt[v2]=true;
		if (!num[color[v2]]) ++now;
		++num[color[v2]];
		v2=fa[v2];
	}
	int lca=v2;
	while (v1!=lca)
	{
		vt[v1]=false;
		if (num[color[v1]]==1) --now;
		--num[color[v1]];
		v1=fa[v1];
	}
	uu[kind]=tmp;
}
void changeroot(int kind,int *fa,int x)
{
	int tt=x,rt=wer[kind],last=0;;
	while (x!=rt)
	{
		int tmp=fa[x];
		fa[x]=last;
		last=x;
		x=tmp;
	}
	fa[x]=last;
	wer[kind]=tt;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	sqrtn=(int)sqrt(n);
	//printf(&quot;%d\n&quot;,sqrtn);
	int i,x,y;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;color[i]),root[i]=i;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		if (x==0||y==0) continue;
		addedge(x,y),addedge(y,x);
	}
	dfs(1);
	//for (i=1;i&lt;=n;i++) printf(&quot;root: %d\n&quot;,root[i]);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;ask[i].x,&amp;ask[i].y,&amp;ask[i].a,&amp;ask[i].b);
		ask[i].id=i;
		if (dfn[ask[i].x]&gt;dfn[ask[i].y])
		{
			int t=ask[i].x;
			ask[i].x=ask[i].y;
			ask[i].y=t;
		}
	}
	sort(ask+1,ask+m+1,cmp);
	//for (i=1;i&lt;=m;i++) printf(&quot;%d %d %d %d\n&quot;,ask[i].x,ask[i].y,ask[i].a,ask[i].b);
	uu[1]=uu[2]=wer[1]=wer[2]=1;
	now=1;
	vt[1]=true;
	num[color[1]]=1;
	for (i=1;i&lt;=m;i++)
	{
		work(1,fa1,uu[1],ask[i].y);
		changeroot(1,fa1,ask[i].x);
		changeroot(2,fa2,ask[i].y);
		work(2,fa2,uu[2],ask[i].x);
		if (num[ask[i].a]&gt;0&amp;&amp;num[ask[i].b]&gt;0&amp;&amp;ask[i].a!=ask[i].b) ans[ask[i].id]=now-1;
		else ans[ask[i].id]=now;
	}
	for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem3757</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 110000
int num[NN],fa1[NN],fa2[NN],aa[NN*2][2],o[NN],root[NN],dfn[NN],color[NN],size[NN],ans[NN];
int tot,n,m,uu[3],wer[3],TIME,sqrtn,now;
bool vt[NN];
struct orz {int x,y,a,b,id;} ask[NN];
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
void dfs(int v)
{
	dfn[v]=++TIME;
	int rt=root[v];
	size[rt]++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa1[v]) continue;
		fa1[y]=fa2[y]=v;
		if (size[rt]&lt;sqrtn) root[y]=root[v];
		dfs(y);
	}
}
bool cmp(orz a,orz b)
{
	return (root[a.x]!=root[b.x]?root[a.x]&lt;root[b.x]:dfn[a.y]&lt;dfn[b.y]);
}
void work(int kind,int *fa,int v1,int v2)
{
	int tmp=v2;
	while (!vt[v2])
	{
		vt[v2]=true;
		if (!num[color[v2]]) ++now;
		++num[color[v2]];
		v2=fa[v2];
	}
	int lca=v2;
	while (v1!=lca)
	{
		vt[v1]=false;
		if (num[color[v1]]==1) --now;
		--num[color[v1]];
		v1=fa[v1];
	}
	uu[kind]=tmp;
}
void changeroot(int kind,int *fa,int x)
{
	int tt=x,rt=wer[kind],last=0;;
	while (x!=rt)
	{
		int tmp=fa[x];
		fa[x]=last;
		last=x;
		x=tmp;
	}
	fa[x]=last;
	wer[kind]=tt;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	sqrtn=(int)sqrt(n);
	int i,x,y;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;color[i]),root[i]=i;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		if (x==0||y==0) continue;
		addedge(x,y),addedge(y,x);
	}
	dfs(1);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;ask[i].x,&amp;ask[i].y,&amp;ask[i].a,&amp;ask[i].b);
		ask[i].id=i;
		if (dfn[ask[i].x]&gt;dfn[ask[i].y])
		{
			int t=ask[i].x;
			ask[i].x=ask[i].y;
			ask[i].y=t;
		}
	}
	sort(ask+1,ask+m+1,cmp);
	uu[1]=uu[2]=wer[1]=wer[2]=1;
	now=1;
	vt[1]=true;
	num[color[1]]=1;
	for (i=1;i&lt;=m;i++)
	{
		work(1,fa1,uu[1],ask[i].y);
		changeroot(1,fa1,ask[i].x);
		changeroot(2,fa2,ask[i].y);
		work(2,fa2,uu[2],ask[i].x);
		if (num[ask[i].a]&gt;0&amp;&amp;num[ask[i].b]&gt;0&amp;&amp;ask[i].a!=ask[i].b) ans[ask[i].id]=now-1;
		else ans[ask[i].id]=now;
	}
	for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem3757</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 110000
int num[NN],fa1[NN],fa2[NN],aa[NN*2][2],o[NN],root[NN],dfn[NN],color[NN],size[NN],ans[NN];
int tot,n,m,uu[3],wer[3],TIME,sqrtn,now,root1,root2;
bool vt[NN];
struct orz {int x,y,a,b,id;} ask[NN];
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
void dfs(int v)
{
	dfn[v]=++TIME;
	int rt=root[v];
	size[rt]++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa1[v]) continue;
		fa1[y]=fa2[y]=v;
		if (size[rt]&lt;sqrtn) root[y]=root[v];
		dfs(y);
	}
}
bool cmp(orz a,orz b)
{
	return (root[a.x]!=root[b.x]?root[a.x]&lt;root[b.x]:dfn[a.y]&lt;dfn[b.y]);
}
void work(int *fa,int v1,int v2)
{
	while (!vt[v2])
	{
		vt[v2]=true;
		if (!num[color[v2]]) ++now;
		++num[color[v2]];
		v2=fa[v2];
	}
	int lca=v2;
	while (v1!=lca)
	{
		vt[v1]=false;
		if (num[color[v1]]==1) --now;
		--num[color[v1]];
		v1=fa[v1];
	}
	//uu[kind]=tmp;
}
void changeroot(int *fa,int &amp;root,int x)
{
	int tt=x,last=0;
	while (x!=root)
	{
		int tmp=fa[x];
		fa[x]=last;
		last=x;
		x=tmp;
	}
	fa[x]=last;
	root=tt;
	//wer[kind]=tt;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	sqrtn=(int)sqrt(n);
	int i,x,y;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;color[i]),root[i]=i;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		if (x==0||y==0) continue;
		addedge(x,y),addedge(y,x);
	}
	dfs(1);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;ask[i].x,&amp;ask[i].y,&amp;ask[i].a,&amp;ask[i].b);
		ask[i].id=i;
		if (dfn[ask[i].x]&gt;dfn[ask[i].y])
		{
			int t=ask[i].x;
			ask[i].x=ask[i].y;
			ask[i].y=t;
		}
	}
	sort(ask+1,ask+m+1,cmp);
	uu[1]=uu[2]=wer[1]=wer[2]=1;
	root1=root2=1;
	now=1;
	vt[1]=true;
	num[color[1]]=1;
	for (i=1;i&lt;=m;i++)
	{
		work(fa1,root2,ask[i].y);
		changeroot(fa2,root2,ask[i].y);
		work(fa2,root1,ask[i].x);
		changeroot(fa1,root1,ask[i].x);
		if (num[ask[i].a]&gt;0&amp;&amp;num[ask[i].b]&gt;0&amp;&amp;ask[i].a!=ask[i].b) ans[ask[i].id]=now-1;
		else ans[ask[i].id]=now;
	}
	for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem3757</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 110000
int num[NN],fa1[NN],fa2[NN],aa[NN*2][2],o[NN],root[NN],dfn[NN],color[NN],size[NN],ans[NN];
int tot,n,m,TIME,sqrtn,now,root1,root2;
bool vt[NN];
struct orz {int x,y,a,b,id;} ask[NN];
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
void dfs(int v)
{
	dfn[v]=++TIME;
	int rt=root[v];
	size[rt]++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa1[v]) continue;
		fa1[y]=fa2[y]=v;
		if (size[rt]&lt;sqrtn) root[y]=root[v];
		dfs(y);
	}
}
bool cmp(orz a,orz b)
{
	return (root[a.x]!=root[b.x]?root[a.x]&lt;root[b.x]:dfn[a.y]&lt;dfn[b.y]);
}
void work(int *fa,int v1,int v2)
{
	while (!vt[v2])
	{
		vt[v2]=true;
		if (!num[color[v2]]) ++now;
		++num[color[v2]];
		v2=fa[v2];
	}
	int lca=v2;
	while (v1!=lca)
	{
		vt[v1]=false;
		if (num[color[v1]]==1) --now;
		--num[color[v1]];
		v1=fa[v1];
	}
}
void changeroot(int *fa,int &amp;root,int x)
{
	int tt=x,last=0;
	while (x!=root)
	{
		int tmp=fa[x];
		fa[x]=last;
		last=x;
		x=tmp;
	}
	fa[x]=last;
	root=tt;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	sqrtn=(int)sqrt(n);
	int i,x,y;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;color[i]),root[i]=i;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		if (x==0||y==0) continue;
		addedge(x,y),addedge(y,x);
	}
	dfs(1);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;ask[i].x,&amp;ask[i].y,&amp;ask[i].a,&amp;ask[i].b);
		ask[i].id=i;
		if (dfn[ask[i].x]&gt;dfn[ask[i].y])
		{
			int t=ask[i].x;
			ask[i].x=ask[i].y;
			ask[i].y=t;
		}
	}
	sort(ask+1,ask+m+1,cmp);
	root1=root2=1;
	now=1;
	vt[1]=true;
	num[color[1]]=1;
	for (i=1;i&lt;=m;i++)
	{
		work(fa1,root2,ask[i].y);
		changeroot(fa2,root2,ask[i].y);
		work(fa2,root1,ask[i].x);
		changeroot(fa1,root1,ask[i].x);
		if (num[ask[i].a]&gt;0&amp;&amp;num[ask[i].b]&gt;0&amp;&amp;ask[i].a!=ask[i].b) ans[ask[i].id]=now-1;
		else ans[ask[i].id]=now;
	}
	for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem3757</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 110000
int num[NN],fa1[NN],fa2[NN],aa[NN*2][2],o[NN],root[NN],dfn[NN],color[NN],size[NN],ans[NN];
int tot,n,m,TIME,sqrtn,now,root1,root2;
bool vt[NN];
struct orz {int x,y,a,b,id;} ask[NN];
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
void buildblock(int v)
{
	dfn[v]=++TIME;
	int rt=root[v];
	size[rt]++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa1[v]) continue;
		fa1[y]=fa2[y]=v;
		if (size[rt]&lt;sqrtn) root[y]=root[v];
		buildblock(y);
	}
}
bool cmp(orz a,orz b)
{
	return (root[a.x]!=root[b.x]?root[a.x]&lt;root[b.x]:dfn[a.y]&lt;dfn[b.y]);
}
void work(int *fa,int v1,int v2)
{
	for (;!vt[v2];v2=fa[v2])
	{
		vt[v2]=true;
		if (!num[color[v2]]) ++now;
		++num[color[v2]];
	}
	for (;v1!=v2;v1=fa[v1])
	{
		vt[v1]=false;
		if (num[color[v1]]==1) --now;
		--num[color[v1]];
	}
}
void changeroot(int *fa,int &amp;root,int x)
{
	int xx=x,last=0,tmp;
	for (;x&gt;0;x=tmp) tmp=fa[x],fa[x]=last,last=x;
	root=xx;
	/*int tt=x,last=0;
	while (x!=root)
	{
		int tmp=fa[x];
		fa[x]=last;
		last=x;
		x=tmp;
	}
	fa[x]=last;
	root=tt;*/
}
int main()
{//
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	sqrtn=(int)sqrt(n);
	int i,x,y;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;color[i]),root[i]=i;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		if (x!=0&amp;&amp;y!=0) addedge(x,y),addedge(y,x);
	}
	buildblock(1);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;ask[i].x,&amp;ask[i].y,&amp;ask[i].a,&amp;ask[i].b);
		ask[i].id=i;
		if (dfn[ask[i].x]&gt;dfn[ask[i].y])
		{
			int t=ask[i].x;
			ask[i].x=ask[i].y;
			ask[i].y=t;
		}
	}
	sort(ask+1,ask+m+1,cmp);
	root1=root2=1;
	now=1;
	vt[1]=true;
	num[color[1]]=1;
	for (i=1;i&lt;=m;i++)
	{
		work(fa1,root2,ask[i].y);
		changeroot(fa2,root2,ask[i].y);
		work(fa2,root1,ask[i].x);
		changeroot(fa1,root1,ask[i].x);
		ans[ask[i].id]=now;
		if (num[ask[i].a]&gt;0&amp;&amp;num[ask[i].b]&gt;0&amp;&amp;ask[i].a!=ask[i].b) ans[ask[i].id]=now-1;
	}
	for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem3757</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 110000
int num[NN],fa1[NN],fa2[NN],aa[NN*2][2],o[NN],root[NN],dfn[NN],color[NN],size[NN],ans[NN];
int tot,n,m,TIME,sqrtn,now,root1,root2;
bool vt[NN];
struct orz {int x,y,a,b,id;} ask[NN];
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
void buildblock(int v)
{
	dfn[v]=++TIME;
	size[root[v]]++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa1[v]) continue;
		fa1[y]=fa2[y]=v;
		if (size[root[v]]&lt;sqrtn) root[y]=root[v];
		buildblock(y);
	}
}
bool cmp(orz a,orz b)
{
	return (root[a.x]!=root[b.x]?root[a.x]&lt;root[b.x]:dfn[a.y]&lt;dfn[b.y]);
}
void work(int *fa,int v1,int v2)
{
	for (;!vt[v2];vt[v2]=true,v2=fa[v2])
	{
		if (!num[color[v2]]) ++now;
		++num[color[v2]];
	}
	for (;v1!=v2;vt[v1]=false,v1=fa[v1])
	{
		if (num[color[v1]]==1) --now;
		--num[color[v1]];
	}
}
void changeroot(int *fa,int &amp;root,int x)
{
	int xx=x,last=0,tmp;
	for (;x&gt;0;x=tmp) tmp=fa[x],fa[x]=last,last=x;
	root=xx;
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	sqrtn=(int)sqrt(n);
	int i,x,y;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;color[i]),root[i]=i;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		if (x!=0&amp;&amp;y!=0) addedge(x,y),addedge(y,x);
	}
	buildblock(1);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;ask[i].x,&amp;ask[i].y,&amp;ask[i].a,&amp;ask[i].b);
		ask[i].id=i;
		if (dfn[ask[i].x]&gt;dfn[ask[i].y]) swap(ask[i].x,ask[i].y);
	}
	sort(ask+1,ask+m+1,cmp);
	root1=root2=1;
	now=1;
	vt[1]=true;
	num[color[1]]=1;
	for (i=1;i&lt;=m;i++)
	{
		work(fa1,root2,ask[i].y);
		changeroot(fa2,root2,ask[i].y);
		work(fa2,root1,ask[i].x);
		changeroot(fa1,root1,ask[i].x);
		ans[ask[i].id]=now;
		if (num[ask[i].a]&gt;0&amp;&amp;num[ask[i].b]&gt;0&amp;&amp;ask[i].a!=ask[i].b) ans[ask[i].id]=now-1;
	}
	for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem3757</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 110000
int num[NN],fa1[NN],fa2[NN],aa[NN*2][2],o[NN],root[NN],dfn[NN],color[NN],size[NN],ans[NN];
int tot,n,m,TIME,sqrtn,now,root1,root2;
bool vt[NN];
struct orz {int x,y,a,b,id;} ask[NN];
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
void buildblock(int v)
{
	dfn[v]=++TIME;
	size[root[v]]++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa1[v]) continue;
		fa1[y]=fa2[y]=v;
		if (size[root[v]]&lt;sqrtn) root[y]=root[v];
		buildblock(y);
	}
}
bool cmp(orz a,orz b)
{
	return (root[a.x]!=root[b.x]?root[a.x]&lt;root[b.x]:dfn[a.y]&lt;dfn[b.y]);
}
void work(int *fa,int v1,int v2)
{
	for (;!vt[v2];vt[v2]=true,v2=fa[v2])
	{
		if (!num[color[v2]]) ++now;
		++num[color[v2]];
	}
	for (;v1!=v2;vt[v1]=false,v1=fa[v1])
	{
		if (num[color[v1]]==1) --now;
		--num[color[v1]];
	}
}
void changeroot(int *fa,int &amp;root,int x)
{
	int xx=x,last=0,tmp;
	for (;x&gt;0;x=tmp) tmp=fa[x],fa[x]=last,last=x;
	root=xx;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	sqrtn=(int)sqrt(n);
	int i,x,y;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;color[i]),root[i]=i;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		if (x!=0&amp;&amp;y!=0) addedge(x,y),addedge(y,x);
	}
	buildblock(1);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;ask[i].x,&amp;ask[i].y,&amp;ask[i].a,&amp;ask[i].b);
		ask[i].id=i;
		//if (dfn[ask[i].x]&gt;dfn[ask[i].y]) swap(ask[i].x,ask[i].y);
	}
	sort(ask+1,ask+m+1,cmp);
	root1=root2=1;
	now=1;
	vt[1]=true;
	num[color[1]]=1;
	for (i=1;i&lt;=m;i++)
	{
		work(fa1,root2,ask[i].y);
		changeroot(fa2,root2,ask[i].y);
		work(fa2,root1,ask[i].x);
		changeroot(fa1,root1,ask[i].x);
		ans[ask[i].id]=now;
		if (num[ask[i].a]&gt;0&amp;&amp;num[ask[i].b]&gt;0&amp;&amp;ask[i].a!=ask[i].b) ans[ask[i].id]=now-1;
	}
	for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem3757</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 110000
int num[NN],fa1[NN],fa2[NN],aa[NN*2][2],o[NN],root[NN],dfn[NN],color[NN],size[NN],ans[NN];
int tot,n,m,TIME,sqrtn,now,root1,root2;
bool vt[NN];
struct orz
{
	int x,y,a,b,id;
	friend bool operator &lt;(orz a,orz b)
	{
		return root[a.x]!=root[b.x]?root[a.x]&lt;root[b.x]:dfn[a.y]&lt;dfn[b.y];
	}
} ask[NN];
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
void buildblock(int v)
{
	dfn[v]=++TIME;
	size[root[v]]++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa1[v]) continue;
		fa1[y]=fa2[y]=v;
		if (size[root[v]]&lt;sqrtn) root[y]=root[v];
		buildblock(y);
	}
}
bool cmp(orz a,orz b)
{
	return (root[a.x]!=root[b.x]?root[a.x]&lt;root[b.x]:dfn[a.y]&lt;dfn[b.y]);
}
void work(int *fa,int v1,int v2)
{
	for (;!vt[v2];vt[v2]=true,v2=fa[v2])
	{
		if (!num[color[v2]]) ++now;
		++num[color[v2]];
	}
	for (;v1!=v2;vt[v1]=false,v1=fa[v1])
	{
		if (num[color[v1]]==1) --now;
		--num[color[v1]];
	}
}
void changeroot(int *fa,int &amp;root,int x)
{
	int xx=x,last=0,tmp;
	for (;x&gt;0;x=tmp) tmp=fa[x],fa[x]=last,last=x;
	root=xx;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	sqrtn=(int)sqrt(n);
	int i,x,y;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;color[i]),root[i]=i;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		if (x!=0&amp;&amp;y!=0) addedge(x,y),addedge(y,x);
	}
	buildblock(1);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;ask[i].x,&amp;ask[i].y,&amp;ask[i].a,&amp;ask[i].b);
		ask[i].id=i;
		if (dfn[ask[i].x]&gt;dfn[ask[i].y]) swap(ask[i].x,ask[i].y);
	}
	sort(ask+1,ask+m+1);
	root1=root2=1;
	now=1;
	vt[1]=true;
	num[color[1]]=1;
	for (i=1;i&lt;=m;i++)
	{
		work(fa1,root2,ask[i].y);
		changeroot(fa2,root2,ask[i].y);
		work(fa2,root1,ask[i].x);
		changeroot(fa1,root1,ask[i].x);
		ans[ask[i].id]=now;
		if (num[ask[i].a]&gt;0&amp;&amp;num[ask[i].b]&gt;0&amp;&amp;ask[i].a!=ask[i].b) ans[ask[i].id]=now-1;
	}
	for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem3757</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 50111
int fa1[NN],fa2[NN],up[NN],size[NN],dfn[NN],num[NN],color[NN],o[NN],aa[NN*2][2],ans[1011111];
int n,m,tot,sqrtn,root1,root2,now,TIME;
bool vt[NN];
struct ppt {int u,v,a,b,id;} ask[1011111];
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
void dfs(int v)
{
	//printf(&quot;begin %d\n&quot;,v);
	//printf(&quot;fa[v]=%d\n&quot;,fa1[v]);
	dfn[v]=++TIME;
	size[up[v]]++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa1[v]) continue;
		//printf(&quot;%d\n&quot;,y);
		fa1[y]=fa2[y]=v;
		if (size[up[v]]&lt;sqrtn) up[y]=up[v];
		dfs(y);
	}
	//printf(&quot;end\n\n&quot;);for (long long i=1;i&lt;=1000000000;i++);
}
bool cmp(ppt a,ppt b)
{
	return up[a.u]==up[b.u]?dfn[a.v]&lt;dfn[b.v]:up[a.u]&lt;up[b.u];
}
void work(int *fa,int v1,int v2)
{
	for (;!vt[v2];v2=fa[v2])
	{
		vt[v2]=true;
		if (!num[color[v2]]) now++;
		num[color[v2]]++;
	}
	for (;v1!=v2;v1=fa[v1])
	{
		vt[v1]=false;
		if (num[color[v1]]==1) now--;
		num[color[v1]]--;
	}
	//printf(&quot;num &quot;);for (int j=1;j&lt;=n;j++) printf(&quot;%d &quot;,num[j]);printf(&quot;\n&quot;);printf(&quot;now=%d\n&quot;,now);
}
void changeroot(int *fa,int &amp;root,int v)
{
	int last=0,x=v,t;
	for (;x;x=t) t=fa[x],fa[x]=last,last=x;
	root=v;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y;
	sqrtn=(int)sqrt(n)+1;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;color[i]),up[i]=i;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		if (x&amp;&amp;y) addedge(x,y),addedge(y,x);//printf(&quot;%d %d\n&quot;,x,y);
	}
	//for (long long i=1;i&lt;=500000000;i++);
	dfs(1);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;ask[i].u,&amp;ask[i].v,&amp;ask[i].a,&amp;ask[i].b);
		ask[i].id=i;
	}
	sort(ask+1,ask+m+1,cmp);
	//for (i=1;i&lt;=m;i++) printf(&quot;%d %d\n&quot;,ask[i].u,ask[i].v);
	root1=root2=1;
	num[color[1]]=1;
	vt[1]=true;
	now=1;
	for (i=1;i&lt;=m;i++)
	{
		//printf(&quot;\n--------------------------------------------------------\n&quot;);
		int u=ask[i].u,v=ask[i].v,a=ask[i].a,b=ask[i].b,id=ask[i].id;
		//printf(&quot;calcing %d %d\n&quot;,u,v);
		work(fa1,root2,v);//u1-v1 =&gt; u1-v2
		changeroot(fa2,root2,v);
		work(fa2,root1,u);//u1-v2 =&gt; u2-v2
		changeroot(fa1,root1,u);
		//printf(&quot;num &quot;);for (int j=1;j&lt;=n;j++) printf(&quot;%d &quot;,num[j]);printf(&quot;\n&quot;);
		//printf(&quot;now=%d\n&quot;,now);
		ans[id]=now;
		if (num[a]&amp;&amp;num[b]&amp;&amp;a!=b) --ans[id];
	}
	for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem3757</h2><pre>//Ê÷ÉÏÄª¶ÔÊµ¼ÊÉÏÊÇÎ¬»¤ÁËÁ½¿ÃÊ÷¡£±ÈÈçÉÏÒ»¸öÑ¯ÎÊÊ±(u1,v1),ÏÖÔÚÒª±ä³É(u2,v2)¡£
//¿ªÊ¼Ê±Á½¿ÃÊ÷µÄ¸ù·Ö±ðÊÇu1ºÍv1¡£ÏÖÔÚÏÈÔÚµÚÒ»¿ÅÊ÷ÖÐ°Ñ(u1,v1)±äÎª(u1,v2),ÔÙ
//°ÑµÚ¶þ¿ÃÊ÷µÄ¸ù±äÎªv2£¬È»ºóÔÙÔÚµÚ¶þ¿ÃÊ÷ÖÐ°Ñ(u1,v2)±äÎª(u2,v2)¡£
//vtÊý×é¶¼ÓÃÒ»¸ö£¬ËùÒÔ¾ÍÊµÏÖÁËÑ¯ÎÊµÄ×ªÒÆ¡£ 
//ÎªÊ²Ã´Òª½¨Á½¿ÃÊ÷£¿ÒòÎªÕâÊÇÄª¶Ô£¬±ØÐè±£Ö¤ÊÇu1-&gt;u2£¬È»ºóv1-&gt;v2¡£Èç¹ûÓÃÒ»¿ÃÊ÷
//µÄ»°¸´ÔÓ¶È¾Í²»ÊÇO(nsqrt(n))ÁË¡£ 
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define NN 110000
int num[NN],fa1[NN],fa2[NN],aa[NN*2][2],o[NN],root[NN],dfn[NN],color[NN],size[NN],ans[NN];
int tot,n,m,TIME,sqrtn,now,root1,root2;
bool vt[NN];
struct orz
{
	int x,y,a,b,id;
	friend bool operator &lt;(orz a,orz b)//ÖÕÓÚ¿ÉÒÔ¿ñÅ°pascalÁËhahaha 
	{
		return root[a.x]!=root[b.x]?root[a.x]&lt;root[b.x]:dfn[a.y]&lt;dfn[b.y];
	}
} ask[NN];
void addedge(int p,int q) {tot++;aa[tot][1]=q;aa[tot][0]=o[p];o[p]=tot;}
void buildblock(int v)
{
	dfn[v]=++TIME;
	size[root[v]]++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa1[v]) continue;
		fa1[y]=fa2[y]=v;
		if (size[root[v]]&lt;sqrtn) root[y]=root[v];
		buildblock(y);
	}
}
void work(int *fa,int v1,int v2)
{
	for (;!vt[v2];vt[v2]=true,v2=fa[v2])
	{
		if (!num[color[v2]]) ++now;
		++num[color[v2]];
	}
	for (;v1!=v2;vt[v1]=false,v1=fa[v1])
	{
		if (num[color[v1]]==1) --now;
		--num[color[v1]];
	}
}
void changeroot(int *fa,int &amp;root,int x)
{
	int xx=x,last=0,tmp;
	for (;x&gt;0;x=tmp) tmp=fa[x],fa[x]=last,last=x;
	root=xx;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	sqrtn=(int)sqrt(n);
	int i,x,y;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;color[i]),root[i]=i;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		if (x!=0&amp;&amp;y!=0) addedge(x,y),addedge(y,x);
	}
	buildblock(1);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d%d&quot;,&amp;ask[i].x,&amp;ask[i].y,&amp;ask[i].a,&amp;ask[i].b);
		ask[i].id=i;
		if (dfn[ask[i].x]&gt;dfn[ask[i].y]) swap(ask[i].x,ask[i].y);
	}
	sort(ask+1,ask+m+1);
	root1=root2=1;
	now=1;
	vt[1]=true;
	num[color[1]]=1;
	for (i=1;i&lt;=m;i++)
	{
		//ÒÔÏÂËÄ²½ÎªÊ÷ÉÏÄª¶ÔµÄºËÐÄ 
		work(fa1,root2,ask[i].y);
		changeroot(fa2,root2,ask[i].y);
		work(fa2,root1,ask[i].x);
		changeroot(fa1,root1,ask[i].x);
		ans[ask[i].id]=now;
		if (num[ask[i].a]&gt;0&amp;&amp;num[ask[i].b]&gt;0&amp;&amp;ask[i].a!=ask[i].b) ans[ask[i].id]=now-1;
	}
	for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem3757</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
const int NN=51111,MM=101111;
int o[NN],aa[NN*2][2],up[NN],size[NN],dfn[NN],low[NN];
int num[NN],color[NN],fa1[NN],fa2[NN],b[NN],ans[MM];
int n,m,TIME,sqrtn,now,tot,root1,root2;
bool vt[NN];
struct query
{
	int u,v,a,b,id;
	void in(int i)
	{
		id=i;
		scanf(&quot;%d%d%d%d&quot;,&amp;u,&amp;v,&amp;a,&amp;b);
		if (dfn[u]&gt;dfn[v]) {int t=u;u=v;v=t;}
		if (a==b) a=b=0;
	}
	bool check()
	{
		if (a==0&amp;&amp;b==0) return false;
		if (num[a]==0||num[b]==0) return false;
		return true;
	}
	friend bool operator &lt;(query a,query b)
	{
		if (up[a.u]!=up[b.u]) return up[a.u]&lt;up[b.u];
		return dfn[a.v]&lt;dfn[b.v];
	}
} q[MM];
void dfs(int v)
{
	int t=up[v];
	size[t]++;
	dfn[v]=low[v]=++TIME;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa1[v]) continue;
		fa1[y]=fa2[y]=v;
		if (size[t]&lt;sqrtn) up[y]=t;
		else up[y]=y;
		dfs(y);
	}
}
void work(int *fa,int v,int u)
{
	for (;!vt[u];u=fa[u])
	{
		vt[u]=true;
		int t=color[u];
		num[t]++;
		if (num[t]==1) now++;
	}
	for (;v!=u;v=fa[v])
	{
		vt[v]=false;
		int t=color[v];
		num[t]--;
		if (!num[t]) now--;
	}
}
void changeroot(int *fa,int &amp;root,int v)
{
	b[0]=0;
	for (int x=v;x!=fa[root];x=fa[x]) b[++b[0]]=x;
	for (int i=b[0];i&gt;1;i--) fa[b[i]]=b[i-1];
	root=v,fa[v]=0;
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	sqrtn=(int)sqrt(n)+1;
	int i,x,y;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;color[i]);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		if (x==0||y==0) continue;
		addedge(x,y),addedge(y,x);
	}
	up[1]=1,dfs(1);
	for (i=1;i&lt;=m;i++) q[i].in(i);
	sort(q+1,q+m+1);
	root1=root2=1;
	vt[1]=true;
	num[color[1]]=1;
	now=1;
	for (i=1;i&lt;=m;i++)
	{
		int x=q[i].u,y=q[i].v;
		work(fa1,root2,y);
		changeroot(fa2,root2,y);
		work(fa2,root1,x);
		changeroot(fa1,root1,x);
		if (q[i].check()) ans[q[i].id]=now-1;
		else ans[q[i].id]=now;
	}
	for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem3757</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=101111;
int o[NN],aa[NN*2][2],up[NN],dfn[NN],fa1[NN],fa2[NN];
int ans[NN],size[NN],num[NN],color[NN];
int n,m,tot=1,TIME,sqrtn,now,root1,root2;
bool vt[NN];
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);ln;}
struct Query
{
	int u,v,a,b,id;
	void in(int i)
	{
		id=i;
		scanf(&quot;%d%d%d%d&quot;,&amp;u,&amp;v,&amp;a,&amp;b);
		if (dfn[u]&gt;dfn[v]) {int t=u;u=v;v=t;}
	}
	void out() {printf(&quot;%d %d %d %d %d\n&quot;,u,v,a,b,id);}
	void go()
	{
		ans[id]=now;
		if (a&amp;&amp;b&amp;&amp;a!=b&amp;&amp;num[a]&amp;&amp;num[b]) ans[id]--;
	}
	friend bool operator &lt;(Query a,Query b)
	{
		if (up[a.u]!=up[b.u]) return up[a.u]&lt;up[b.u];
		return dfn[a.v]&lt;dfn[b.v];
	}
} ask[NN];
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs(int v)
{
	dfn[v]=++TIME;
	size[up[v]]++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa1[v]) continue;
		fa1[y]=fa2[y]=v;
		if (size[up[v]]&lt;sqrtn) up[y]=up[v];
		else up[y]=y;
		dfs(y);
	}
}
void work(int *fa,int v1,int v2)
{
	for (;!vt[v2];v2=fa[v2])
	{
		if (num[color[v2]]++==0) now++;
		vt[v2]=true;
	}
	for (;v1!=v2;v1=fa[v1])
	{
		if (--num[color[v1]]==0) now--;
		vt[v1]=false;
	}
}
void changeroot(int *fa,int &amp;root,int v)
{
	root=v;
	int x=v,y=fa[v],z=fa[fa[v]];
	fa[v]=0;
	while (y)
	{
		fa[y]=x;
		x=y,y=z,z=fa[z];
	}
}
int main()
{
//	freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	sqrtn=(int)sqrt(n)+1;
	int i,x,y;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;color[i]);
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		if (x&amp;&amp;y) addedge(x,y),addedge(y,x);
	}
	up[1]=1,dfs(1);
	for (i=1;i&lt;=m;i++) ask[i].in(i);
	sort(ask+1,ask+m+1);
	//for (i=1;i&lt;=m;i++) ask[i].out();ln;printf(&quot;fa1 &quot;);out(fa1,1,n);printf(&quot;fa2 &quot;);out(fa2,1,n);ln;
	root1=root2=1;
	vt[1]=true;
	num[color[1]]=1;
	now=1;
	for (i=1;i&lt;=m;i++)
	{
		//printf(&quot;\n------------------------------------------------------------------------\n&quot;);
		int u=ask[i].u,v=ask[i].v;
		work(fa1,root2,v);
		changeroot(fa2,root2,v);
		work(fa2,root1,u);
		changeroot(fa1,root1,u);
		ask[i].go();
	}
	for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem3757</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
const int NN=100111;
int o[NN],aa[NN&lt;&lt;1][2],dfn[NN],size[NN],up[NN],fa1[NN],fa2[NN],num[NN],color[NN],ans[NN];
int n,m,tot=1,TIME,blo,nowans,root1,root2;
bool vt[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar());
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
struct query
{
	int u,v,a,b,id;
	inline void in(int i)
	{
		id=i;read(u),read(v),read(a),read(b);
		if (dfn[u]&gt;dfn[v]) {int t=u;u=v;v=t;}
	}
	friend bool operator &lt;(const query &amp;a,const query &amp;b)
	{
		if (up[a.u]!=up[b.u]) return up[a.u]&lt;up[b.u];
		return dfn[a.v]&lt;dfn[b.v];
	}
} qry[NN];
void dfs(int v)
{
	dfn[v]=++TIME;
	size[up[v]]++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa1[v]) continue;
		fa1[y]=fa2[y]=v;
		if (size[up[v]]&lt;blo) up[y]=up[v];
		else up[y]=y;
		dfs(y);
	}
}
void work(int *fa,int u,int v)
{
	for (;!vt[v];v=fa[v])
	{
		vt[v]=true;
		if (++num[color[v]]==1) nowans++;
	}
	for (;u!=v;u=fa[u])
	{
		vt[u]=false;
		if (--num[color[u]]==0) nowans--;
	}
}
void changeroot(int *fa,int &amp;root,int x)
{
	int y=fa[x],z=fa[y];
	root=x,fa[x]=0;
	for (;y;x=y,y=z,z=fa[z]) fa[y]=x;
}
int main()
{
	//freopen(&quot;apple10.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	blo=(int)sqrt(n)+1;
	int i,x,y;
	for (i=1;i&lt;=n;i++) read(color[i]);
	for (i=1;i&lt;=n;i++)
	{
		read(x),read(y);
		if (!x||!y) continue;
		addedge(x,y),addedge(y,x);
	}
	up[1]=1,dfs(1);
	for (i=1;i&lt;=m;i++) qry[i].in(i);
	sort(qry+1,qry+m+1);
	root1=root2=1;
	vt[1]=true;
	num[color[1]]=1;
	nowans=1;
	for (i=1;i&lt;=m;i++)
	{
		int u=qry[i].u,v=qry[i].v,a=qry[i].a,b=qry[i].b;
		work(fa1,root2,v);
		changeroot(fa2,root2,v);
		work(fa2,root1,u);
		changeroot(fa1,root1,u);
		ans[qry[i].id]=nowans;
		if (a&amp;&amp;b&amp;&amp;a!=b&amp;&amp;num[a]&amp;&amp;num[b]) ans[qry[i].id]--;
	}
	for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem3757</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
const int NN=50111;
int o[NN],aa[NN&lt;&lt;1][2],dfn[NN],size[NN],up[NN],fa1[NN],fa2[NN],num[NN],color[NN],ans[101111];
int n,m,tot=1,TIME,blo,nowans,root1,root2;
bool vt[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar());
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
struct query
{
	int u,v,a,b,id;
	inline void in(int i)
	{
		id=i;read(u),read(v),read(a),read(b);
		if (dfn[u]&gt;dfn[v]) {int t=u;u=v;v=t;}
	}
	friend bool operator &lt;(const query &amp;a,const query &amp;b)
	{
		if (up[a.u]!=up[b.u]) return up[a.u]&lt;up[b.u];
		return dfn[a.v]&lt;dfn[b.v];
	}
} qry[101111];
void dfs(int v)
{
	dfn[v]=++TIME;
	size[up[v]]++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa1[v]) continue;
		fa1[y]=fa2[y]=v;
		if (size[up[v]]&lt;blo) up[y]=up[v];
		else up[y]=y;
		dfs(y);
	}
}
void work(int *fa,int u,int v)
{
	for (;!vt[v];v=fa[v])
	{
		vt[v]=true;
		if (++num[color[v]]==1) nowans++;
	}
	for (;u!=v;u=fa[u])
	{
		vt[u]=false;
		if (--num[color[u]]==0) nowans--;
	}
}
void changeroot(int *fa,int &amp;root,int x)
{
	int y=fa[x],z=fa[y];
	root=x,fa[x]=0;
	for (;y;x=y,y=z,z=fa[z]) fa[y]=x;
}
int main()
{
	//freopen(&quot;apple10.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	blo=(int)sqrt(n)+1;
	int i,x,y;
	for (i=1;i&lt;=n;i++) read(color[i]);
	for (i=1;i&lt;=n;i++)
	{
		read(x),read(y);
		if (!x||!y) continue;
		addedge(x,y),addedge(y,x);
	}
	up[1]=1,dfs(1);
	for (i=1;i&lt;=m;i++) qry[i].in(i);
	sort(qry+1,qry+m+1);
	root1=root2=1;
	vt[1]=true;
	num[color[1]]=1;
	nowans=1;
	for (i=1;i&lt;=m;i++)
	{
		int u=qry[i].u,v=qry[i].v,a=qry[i].a,b=qry[i].b;
		work(fa1,root2,v);
		changeroot(fa2,root2,v);
		work(fa2,root1,u);
		changeroot(fa1,root1,u);
		ans[qry[i].id]=nowans;
		if (a&amp;&amp;b&amp;&amp;a!=b&amp;&amp;num[a]&amp;&amp;num[b]) ans[qry[i].id]--;
	}
	for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem3757</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
const int NN=100111;
int color[NN],o[NN],aa[NN&lt;&lt;1][2],up[NN],dfn[NN],size[NN],fa1[NN],fa2[NN],ans[NN];
int n,m,tot=1,dfx,sqrtn,root1,root2;
bool vt[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar());
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs(int v)
{
	dfn[v]=++dfx;
	size[up[v]]++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa1[v]) continue;
		fa1[y]=fa2[y]=v;
		if (size[up[v]]&lt;sqrtn) up[y]=up[v];
		else up[y]=y;
		dfs(y);
	}
}
struct query
{
	int x,y,a,b,id;
	inline void in(int i)
	{
		id=i;
		read(x),read(y),read(a),read(b);
		if (dfn[x]&gt;dfn[y]) {int t=x;x=y;y=t;}
	}
	friend bool operator &lt;(const query &amp;a,const query &amp;b)
	{
		if (up[a.x]!=up[b.x]) return up[a.x]&lt;up[b.x];
		return dfn[a.y]&lt;dfn[b.y];
	}
} q[NN];
struct Now
{
	int num[NN],ans;
	inline void add(int x)
	{
		num[x]++;
		if (num[x]==1) ans++;
	}
	inline void del(int x)
	{
		num[x]--;
		if (num[x]==0) ans--;
	}
} now;
void work(int *fa,int u,int v)
{
	for (;!vt[v];v=fa[v])
	{
		vt[v]=true;
		now.add(color[v]);
	}
	for (;u!=v;u=fa[u])
	{
		vt[u]=false;
		now.del(color[u]);
	}
}
void changeroot(int *fa,int &amp;root,int x)
{
    int y=fa[x],z=fa[y];
    root=x,fa[x]=0;
    for (;y;x=y,y=z,z=fa[z]) fa[y]=x;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	sqrtn=(int)sqrt(n)+1;
	int i,x,y;
	for (i=1;i&lt;=n;i++) read(color[i]);
	for (i=1;i&lt;=n;i++)
	{
		read(x),read(y);
		if (!x||!y) continue;
		addedge(x,y),addedge(y,x);
	}
	up[1]=1,dfs(1);
	for (i=1;i&lt;=m;i++) q[i].in(i);
	sort(q+1,q+m+1);
	root1=root2=1;
	vt[1]=true;
	now.add(color[1]);
	for (i=1;i&lt;=m;i++)
	{
		int u=q[i].x,v=q[i].y;
		work(fa1,root2,v);
		changeroot(fa2,root2,v);
		work(fa2,root1,u);
		changeroot(fa1,root1,u);
		if (q[i].a&amp;&amp;q[i].b&amp;&amp;q[i].a!=q[i].b&amp;&amp;now.num[q[i].a]&amp;&amp;now.num[q[i].b]) ans[q[i].id]=now.ans-1;
		else ans[q[i].id]=now.ans;
	}
	for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem3757</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
const int NN=100111;
int color[NN],o[NN],aa[NN&lt;&lt;1][2],up[NN],dfn[NN],size[NN],fa1[NN],fa2[NN],ans[NN];
int n,m,tot=1,dfx,sqrtn,root1,root2;
bool vt[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar());
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs(int v)
{
	dfn[v]=++dfx;
	size[up[v]]++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa1[v]) continue;
		fa1[y]=fa2[y]=v;
		if (size[up[v]]&lt;sqrtn) up[y]=up[v];
		else up[y]=y;
		dfs(y);
	}
}
struct query
{
	int x,y,a,b,id;
	inline void in(int i)
	{
		id=i;
		read(x),read(y),read(a),read(b);
		if (dfn[x]&gt;dfn[y]) {int t=x;x=y;y=t;}
	}
	friend bool operator &lt;(const query &amp;a,const query &amp;b)
	{
		if (up[a.x]!=up[b.x]) return up[a.x]&lt;up[b.x];
		return dfn[a.y]&lt;dfn[b.y];
	}
} q[NN];
struct Now
{
	int num[NN],ans;
	inline void add(int x)
	{
		num[x]++;
		if (num[x]==1) ans++;
	}
	inline void del(int x)
	{
		num[x]--;
		if (num[x]==0) ans--;
	}
} now;
void work(int *fa,int u,int v)
{
	for (;!vt[v];v=fa[v])
	{
		vt[v]=true;
		now.add(color[v]);
	}
	for (;u!=v;u=fa[u])
	{
		vt[u]=false;
		now.del(color[u]);
	}
}
void changeroot(int *fa,int &amp;root,int v)
{
	root=v;
	int x=v,y=fa[x],z=fa[y];
	for (;y;x=y,y=z,z=fa[z]) fa[y]=x;
	fa[root]=0;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	sqrtn=(int)sqrt(n)+1;
	int i,x,y;
	for (i=1;i&lt;=n;i++) read(color[i]);
	for (i=1;i&lt;=n;i++)
	{
		read(x),read(y);
		if (!x||!y) continue;
		addedge(x,y),addedge(y,x);
	}
	up[1]=1,dfs(1);
	for (i=1;i&lt;=m;i++) q[i].in(i);
	sort(q+1,q+m+1);
	root1=root2=1;
	vt[1]=true;
	now.add(color[1]);
	for (i=1;i&lt;=m;i++)
	{
		int u=q[i].x,v=q[i].y;
		work(fa1,root2,v);
		changeroot(fa2,root2,v);
		work(fa2,root1,u);
		changeroot(fa1,root1,u);
		if (q[i].a&amp;&amp;q[i].b&amp;&amp;q[i].a!=q[i].b&amp;&amp;now.num[q[i].a]&amp;&amp;now.num[q[i].b]) ans[q[i].id]=now.ans-1;
		else ans[q[i].id]=now.ans;
	}
	for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem3757</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;

#define maxn 50010
#define maxm 100010

using namespace std;

int n,m,dfn[maxn],st[maxn],top,belong[maxn],p[maxn],tot,b[maxn],num,fa[maxn][20],dep[maxn],blo,blonum,col[maxn],ans,res[maxm];
bool vis[maxn];

int read()
{
	int ret=0;char ch=getchar();
	while(ch&lt;'!') ch=getchar();
	while(ch&gt;'!') ret=ret*10+ch-'0',ch=getchar();
	return ret;
}

struct query{
	int u,v,a,b,id;
	friend bool operator &lt; (query a,query b){
		if(belong[a.u]==belong[b.u]) return dfn[a.v]&lt;dfn[b.v];
		else return belong[a.u]&lt;belong[b.u];
	}
}q[maxm];

struct edge{
	int x,y,last;
}a[maxn&lt;&lt;1];

void add(int x,int y)
{
	a[++tot]=(edge){x,y,b[x]};
	b[x]=tot;
}

int dfs(int x)
{
	int siz=0;
	dfn[x]=++num;
	for(int i=1;i&lt;=16;i++) fa[x][i]=fa[fa[x][i-1]][i-1];
	for(int i=b[x];i;i=a[i].last){
		int v=a[i].y;
		if(!dfn[v]){
			dep[v]=dep[x]+1;
			fa[v][0]=x;
			siz+=dfs(v);
			if(siz&gt;=blo){
				blonum++;
				for(int k=1;k&lt;=siz;k++) belong[st[top--]]=blonum;
				siz=0;
			}
		}
	}
	st[++top]=x;
	return siz+1;
}

int lca(int x,int y)
{
	if(dep[x]&lt;dep[y]) swap(x,y);
	for(int i=16;i&gt;=0;i--) if(dep[fa[x][i]]&gt;=dep[y]) x=fa[x][i];
	if(x==y) return x;
	for(int i=16;i&gt;=0;i--) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}

void reserve(int x)
{
	if(!vis[x]){ vis[x]=1;p[col[x]]++;if(p[col[x]]==1) ans++; }
	else { vis[x]=0;p[col[x]]--;if(p[col[x]]==0)ans--; }
}

void slove(int u,int v)
{
	while(u!=v){
		if(dep[u]&gt;dep[v]) reserve(u),u=fa[u][0];
		else reserve(v),v=fa[v][0];
	}
}

int main()
{
	n=read();m=read();
	blo=sqrt(n);
	for(int i=1;i&lt;=n;i++) col[i]=read();
	int root;
	for(int i=1;i&lt;=n;i++){
		int u=read(),v=read();
		if(!u) root=v;
		else if(!v) root=u;
		else add(u,v),add(v,u);
	}
	dep[root]=1;
	dfs(root);
	blonum++;
	while(top) belong[st[top--]]=blonum;
	for(int i=1;i&lt;=m;i++){
		q[i].u=read();q[i].v=read();
		if(dfn[q[i].u]&gt;dfn[q[i].v]) swap(q[i].u,q[i].v);
		q[i].a=read();q[i].b=read();
		q[i].id=i;
	}
	sort(q+1,q+m+1);
	int t=lca(q[1].u,q[1].v);
	slove(q[1].u,q[1].v);
	reserve(t);
	res[q[1].id]=ans;
	if(p[q[1].a]&amp;&amp;p[q[1].b]&amp;&amp;q[1].a!=q[1].b) res[q[1].id]--;
	reserve(t);
	for(int i=2;i&lt;=m;i++){
		slove(q[i-1].u,q[i].u);
		slove(q[i-1].v,q[i].v);
		t=lca(q[i].u,q[i].v);
		reserve(t);
		res[q[i].id]=ans;
		if(p[q[i].a]&amp;&amp;p[q[i].b]&amp;&amp;q[i].a!=q[i].b) res[q[i].id]--;
		reserve(t);
	}
	for(int i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,res[i]);
	return 0;
}
<pre><h2>Problem3757</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
 
#define maxn 50010
#define maxm 100010
 
using namespace std;
 
int n,m,dfn[maxn],st[maxn],top,belong[maxn],p[maxn],tot,b[maxn],num,fa[maxn][20],dep[maxn],blo,blonum,col[maxn],ans,res[maxm];
bool vis[maxn];
 
int read()
{
    int ret=0;char ch=getchar();
    while(ch&lt;'!') ch=getchar();
    while(ch&gt;'!') ret=ret*10+ch-'0',ch=getchar();
    return ret;
}
 
struct query{
    int u,v,a,b,id;
    friend bool operator &lt; (query a,query b){
        if(belong[a.u]==belong[b.u]) return dfn[a.v]&lt;dfn[b.v];
        else return belong[a.u]&lt;belong[b.u];
    }
}q[maxm];
 
struct edge{
    int x,y,last;
}a[maxn&lt;&lt;1];
 
void add(int x,int y)
{
    a[++tot]=(edge){x,y,b[x]};
    b[x]=tot;
}
 
int dfs(int x)
{
    int siz=0;
    dfn[x]=++num;
    for(int i=1;i&lt;=16;i++) fa[x][i]=fa[fa[x][i-1]][i-1];
    for(int i=b[x];i;i=a[i].last){
        int v=a[i].y;
        if(!dfn[v]){
            dep[v]=dep[x]+1;
            fa[v][0]=x;
            siz+=dfs(v);
            if(siz&gt;=blo){
                blonum++;
                for(int k=1;k&lt;=siz;k++) belong[st[top--]]=blonum;
                siz=0;
            }
        }
    }
    st[++top]=x;
    return siz+1;
}
 
int lca(int x,int y)
{
    if(dep[x]&lt;dep[y]) swap(x,y);
    for(int i=16;i&gt;=0;i--) if(dep[fa[x][i]]&gt;=dep[y]) x=fa[x][i];
    if(x==y) return x;
    for(int i=16;i&gt;=0;i--) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];
    return fa[x][0];
}
 
void reserve(int x)
{
    if(!vis[x]){ vis[x]=1;p[col[x]]++;if(p[col[x]]==1) ans++; }
    else { vis[x]=0;p[col[x]]--;if(p[col[x]]==0)ans--; }
}
 
void slove(int u,int v)
{
    while(u!=v){
        if(dep[u]&gt;dep[v]) reserve(u),u=fa[u][0];
        else reserve(v),v=fa[v][0];
    }
}
 
int main()
{
    n=read();m=read();
    blo=sqrt(n);
    for(int i=1;i&lt;=n;i++) col[i]=read();
    int root;
    for(int i=1;i&lt;=n;i++){
        int u=read(),v=read();
        if(!u) root=v;
        else if(!v) root=u;
        else add(u,v),add(v,u);
    }
    dep[root]=1;
    dfs(root);
    blonum++;
    while(top) belong[st[top--]]=blonum;
    for(int i=1;i&lt;=m;i++){
        q[i].u=read();q[i].v=read();
        if(dfn[q[i].u]&gt;dfn[q[i].v]) swap(q[i].u,q[i].v);
        q[i].a=read();q[i].b=read();
        q[i].id=i;
    }
    sort(q+1,q+m+1);
    int t=lca(q[1].u,q[1].v);
    slove(q[1].u,q[1].v);
    reserve(t);
    res[q[1].id]=ans;
    if(p[q[1].a]&amp;&amp;p[q[1].b]&amp;&amp;q[1].a!=q[1].b) res[q[1].id]--;
    reserve(t);
    for(int i=2;i&lt;=m;i++){
        slove(q[i-1].u,q[i].u);
        slove(q[i-1].v,q[i].v);
        t=lca(q[i].u,q[i].v);
        reserve(t);
        res[q[i].id]=ans;
        if(p[q[i].a]&amp;&amp;p[q[i].b]&amp;&amp;q[i].a!=q[i].b) res[q[i].id]--;
        reserve(t);
    }
    for(int i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,res[i]);
    return 0;
}
<pre><h2>Problem3758</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int biao[]={0,376413
,832547
,1288828
,1744956
,2196800
,2647716
,3090920
,3526440
,3951372
,4366880
,4823015
,5304766
,5797144
,6290672
,6782004
,7272530
,7758910
,8238396
,8710536
,9182258
,9638539
,10130918
,10610575
,11103529
,11590745
,12080513
,12565094
,13045216
,13523103
,13996047
,14452175
,14945703
,15438658
,15913605
,16403907
,16892727
,17371943
,17858307
,18339125
,18810719
,19262563
,19753895
,20241111
,20731414
,21199399
,21684697
,22170473
,22655525
,23128982
,23601310
,24052226
,24542752
,25032520
,25521340
,26006639
,26480512
,26967738
,27450344
,27929454
,28401296
,28844500
,29330880
,29815461
,30294677
,30780453
,31267680
,31727883
,32207445
,32681531
,33151141
,33586661
,34066147
,34546269
,35032633
,35517685
,36000291
,36479854
,36928875
,37398605
,37865237
,38290169
,38762309
,39240196
,39721014
,40194471
,40673581
,41147667
,41617398
,42050819
,42514127
,42929635
,43401357
,43874301
,44345895
,44818223
,45290065
,45759675
,46226307
,46689616
,47111407
,47567542
,48049293
,48541671
,49035199
,49526531
,50017057
,50503437
,50982923
,51455063
,51926786
,52408537
,52900916
,53398017
,53897101
,54395976
,54894264
,55390376
,55882154
,56370124
,56858336
,57350715
,57847816
,58346901
,58846682
,59346650
,59846494
,60345546
,60842736
,61337762
,61832643
,62326171
,62825256
,63325037
,63822618
,64321881
,64821477
,65319367
,65818159
,66315614
,66811192
,67302524
,67801399
,68301368
,68800631
,69295186
,69792675
,70292149
,70790949
,71286703
,71781713
,72272239
,72770527
,73270371
,73769968
,74267457
,74763402
,75261351
,75759527
,76256605
,76751555
,77237935
,77734047
,78233099
,78730989
,79230464
,79728413
,80220834
,80714563
,81209373
,81704149
,82183635
,82675413
,83172603
,83671395
,84170195
,84668372
,85162101
,85646750
,86134011
,86626601
,87098741
,87586711
,88081737
,88579192
,89074946
,89572024
,90066835
,90554096
,91029271
,91513942
,91985664
,92473876
,92968757
,93464335
,93959345
,94454295
,94949071
,95441662
,95926333
,96400455
,96856736
,97349115
,97828772
,98321726
,98808942
,99298710
,99783291
,100263413
,100741300
,101214244
,101706623
,102203724
,102702809
,103202590
,103702558
,104202402
,104701454
,105198644
,105693670
,106188552
,106668209
,107167293
,107654509
,108153408
,108643571
,109140447
,109631936
,110124934
,110615086
,111104170
,111597125
,112096906
,112595804
,113093027
,113592810
,114091415
,114589181
,115087418
,115585176
,116080738
,116567954
,117067923
,117558086
,118057868
,118549357
,119048442
,119540443
,120037757
,120529913
,121025141
,121514909
,122014753
,122511630
,123010235
,123509319
,124005151
,124504320
,124999107
,125496723
,125991518
,126476099
,126975151
,127466640
,127964407
,128456408
,128955576
,129444361
,129941988
,130432181
,130927549
,131407671
,131904861
,132397859
,132896096
,133393411
,133888198
,134385824
,134870790
,135365761
,135853348
,136331235
,136826261
,137316413
,137814171
,138306327
,138803944
,139294137
,139789107
,140268613
,140761869
,141234813
,141729694
,142218778
,142714340
,143209568
,143704363
,144199732
,144687319
,145180575
,145654892
,146111020
,146604548
,147097503
,147572450
,148062752
,148551572
,149030788
,149517152
,149997970
,150469564
,150963092
,151462177
,151961958
,152459539
,152958802
,153458398
,153956288
,154455080
,154952535
,155448113
,155941068
,156440849
,156939747
,157436970
,157936753
,158435358
,158933124
,159431361
,159929119
,160424682
,160899629
,161397209
,161894432
,162373648
,162870479
,163366196
,163847035
,164342307
,164834856
,165316242
,165806545
,166305808
,166805590
,167302421
,167797533
,168296439
,168794206
,169291181
,169787227
,170282583
,170771403
,171271000
,171769605
,172265321
,172764227
,173259685
,173756939
,174255102
,174749455
,175244787
,175724003
,176221893
,176719660
,177200499
,177698265
,178195519
,178676905
,179174053
,179669962
,180151503
,180637867
,181136659
,181634896
,182130169
,182627144
,183125306
,183622454
,184112942
,184610046
,185104838
,185585656
,186083111
,186580869
,187073418
,187569465
,188063818
,188559726
,189056830
,189540680
,190034891
,190506485
,191002063
,191497625
,191979011
,192474367
,192969700
,193451241
,193946033
,194440244
,194913068
,195364912
,195856244
,196343460
,196833763
,197301748
,197787046
,198272822
,198757874
,199231331
,199703659
,200194991
,200693866
,201193835
,201693098
,202187653
,202685142
,203184616
,203683416
,204179170
,204674180
,205161396
,205661365
,206151528
,206651310
,207142799
,207641884
,208133885
,208631199
,209123355
,209618583
,210108886
,210608149
,211107931
,211604762
,212099874
,212598780
,213096547
,213593522
,214089568
,214584925
,215052910
,215547464
,216038953
,216534065
,217007522
,217499718
,217990901
,218484410
,218959905
,219446727
,219932026
,220429515
,220928599
,221427505
,221919701
,222413231
,222911993
,223409872
,223904583
,224393574
,224879350
,225378825
,225870826
,226368592
,226859775
,227358537
,227847477
,228346119
,228838089
,229333643
,229818695
,230317495
,230814810
,231311785
,231805293
,232303172
,232801814
,233291625
,233787283
,234281777
,234755234
,235250988
,235743144
,236239191
,236714686
,237209396
,237701366
,238197024
,238673284
,239165608
,239637936
,240132946
,240628174
,241123530
,241610353
,242099344
,242594898
,243089392
,243581716
,244056062
,244506978
,244997504
,245487272
,245976092
,246461391
,246935264
,247422490
,247905096
,248384206
,248856048
,249346574
,249844862
,250344706
,250844303
,251341792
,251837737
,252335686
,252833862
,253330940
,253825890
,254315658
,254815502
,255312379
,255810984
,256310068
,256805900
,257305069
,257799856
,258297472
,258792267
,259281087
,259780684
,260279289
,260775005
,261273911
,261769369
,262266623
,262764786
,263259139
,263754471
,264239770
,264737259
,265236343
,265735249
,266227445
,266720975
,267219737
,267717616
,268212327
,268701319
,269175192
,269671136
,270166968
,270662426
,271155956
,271637394
,272132980
,272626656
,273118401
,273606213
,274093440
,274591389
,275090557
,275587811
,276086573
,276582159
,277074753
,277572087
,278069041
,278564272
,279046878
,279545055
,280039842
,280538004
,281035883
,281529559
,282026893
,282513143
,283009664
,283502662
,283981772
,284478850
,284976467
,285470820
,285965530
,286457275
,286954229
,287450750
,287934208
,288427696
,288899538
,289394488
,289889283
,290384616
,290873607
,291361419
,291856650
,292349648
,292843136
,293317366
,293760570
,294246950
,294731531
,295210747
,295696523
,296183750
,296643953
,297123515
,297597601
,298067211
,298553591
,299049703
,299548755
,300046645
,300546120
,301044069
,301536490
,302030219
,302525029
,303019805
,303504386
,304003438
,304494927
,304992694
,305484695
,305983863
,306472648
,306970275
,307460468
,307955836
,308435052
,308932942
,309430709
,309911548
,310409314
,310906568
,311387954
,311885102
,312381011
,312862552
,313348328
,313847803
,314339804
,314837570
,315328753
,315827515
,316316455
,316815097
,317307067
,317802621
,318289848
,318787797
,319286965
,319784219
,320282981
,320778567
,321271161
,321768495
,322265449
,322760681
,323220884
,323713304
,324202089
,324683475
,325172415
,325665009
,326128508
,326618472
,327104745
,327585453
,328065016
,328558745
,329056371
,329553519
,330052161
,330549495
,331039459
,331524705
,332017239
,332510934
,332985020
,333479831
,333970024
,334465932
,334957902
,335454856
,335941129
,336433663
,336912903
,337405293
,337874903
,338369679
,338865048
,339346589
,339842143
,340337374
,340818082
,341311777
,341804167
,342276694
,342712214
,343191700
,343671822
,344158186
,344643238
,345125844
,345605407
,346054428
,346524158
,346990790
,347470276
,347962054
,348459244
,348958036
,349456836
,349955013
,350448742
,350933391
,351420652
,351913242
,352393364
,352890554
,353383552
,353881789
,354379104
,354873891
,355371517
,355856483
,356351454
,356839041
,357325405
,357824197
,358322434
,358817707
,359314682
,359812844
,360309992
,360800480
,361297584
,361792376
,362277428
,362776228
,363273543
,363770518
,364264026
,364761905
,365260547
,365750358
,366246016
,366740510
,367223116
,367721293
,368216080
,368714242
,369212121
,369705797
,370203131
,370689381
,371185902
,371678900
,372158463
,372652192
,373149818
,373646966
,374145608
,374642942
,375132906
,375618152
,376110686
,376604382
,377053403
,377538051
,378023017
,378513505
,379003316
,379489566
,379974812
,380427196
,380908305
,381388631
,381858362
,382345623
,382840593
,383337697
,383833355
,384329876
,384822410
,385303519
,385778157
,386266143
,386732775
,387225366
,387712953
,388207745
,388702239
,389195237
,389688932
,390169258
,390657244
,391130374
,391555306
,392027446
,392505333
,392986151
,393459608
,393938718
,394412804
,394882535
,395315956
,395779264
,396251404
,396739374
,397234400
,397731855
,398227609
,398724687
,399219498
,399706759
,400181934
,400666605
,401144492
,401639518
,402129670
,402627428
,403119584
,403617201
,404107394
,404602364
,405081870
,405575126
,406055944
,406553399
,407051157
,407543706
,408039753
,408534106
,409030014
,409527118
,410010968
,410505179
,410978636
,411474390
,411966546
,412462593
,412938088
,413432798
,413924768
,414420426
,414896686
,415389010
,415868120
,416365198
,416862815
,417357168
,417851878
,418343623
,418840577
,419337098
,419820556
,420314044
,420788130
,421282941
,421773134
,422269042
,422761012
,423257966
,423744239
,424236773
,424716013
,425208403
,425678134
,426165395
,426660365
,427157469
,427653127
,428149648
,428642182
,429123291
,429597929
,430085916
,430519337
,430994511
,431474017
,431957867
,432434127
,432917585
,433396825
,433871463
,434306086
,434779290
,435242599
,435727270
,436220526
,436714737
,437207061
,437700549
,438192939
,438680925
,439154129
,439626259
,440041767
,440513489
,440986433
,441458027
,441930355
,442402197
,442871807
,443338439
,443801748
,444223539
,444695261
,445183473
,445678354
,446173932
,446668942
,447163892
,447658668
,448151259
,448635930
,449110052
,449582996
,450077877
,450566961
,451062523
,451557751
,452052546
,452547915
,453035502
,453528758
,454003075
,454474669
,454970247
,455465809
,455947195
,456442551
,456937884
,457419425
,457914217
,458408428
,458881252
,459353580
,459848590
,460343818
,460839174
,461325997
,461814988
,462310542
,462805036
,463297360
,463771706
,464243548
,464738498
,465233293
,465728626
,466217617
,466705429
,467200660
,467693658
,468187146
,468661376
,469130986
,469625762
,470121131
,470602672
,471098226
,471593457
,472074165
,472567860
,473060250
,473532777
,473999409
,474492000
,474979587
,475474379
,475968873
,476461871
,476955566
,477435892
,477923878
,478397008
,478860317
,479344988
,479838244
,480332455
,480824779
,481318267
,481810657
,482298643
,482771847
,483243978
,483665769
,484139891
,484614208
,485087032
,485561378
,486035608
,486508135
,486981265
,487453395
,487875963};
inline bool check(int x)
{
	long long tmp=1;
	int sum=0;
	for (;x;x/=10)
	{
		int t=x%10;
		sum+=t;
		tmp|=tmp&lt;&lt;t;
	}
	if (sum&amp;1) return false;
	return tmp&amp;(1ll&lt;&lt;(sum&gt;&gt;1));
}
int calc(int l,int r)
{
	//printf(&quot;calc %d %d\n&quot;,l,r);
	int res=0;
	for (int i=l;i&lt;=r;i++)
		if (check(i)) res++;
	return res;
}
int main()
{
	int l,r;
	scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
	if (r-l&lt;=1000000)
	{
		printf(&quot;%d\n&quot;,calc(l,r));
		return 0;
	}
	int L=l/1000000,R=r/1000000;
	//printf(&quot;L=%d R=%d\n&quot;,L,R);
	int ans=biao[R]-biao[L+1];
	ans+=calc(r/1000000*1000000+1,r);
	ans+=calc(l,l/1000000*1000000+1000000);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3759</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int tes,n,a[21];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
int main()
{
	for (read(tes);tes;tes--)
	{
		int i,mm,S;
		read(n);
		for (i=1;i&lt;=n;i++) read(a[i]);
		mm=(1&lt;&lt;n)-1;
		bool flag=false;
		for (S=1;S&lt;=mm;S++)
		{
			int tmp=0;
			for (i=1;i&lt;=n;i++)
				if (S&amp;(1&lt;&lt;(i-1))) tmp^=a[i];
			if (tmp==0) {flag=true;break;}
		}
		printf(flag?&quot;Yes\n&quot;:&quot;No\n&quot;);
	}
	return 0;
}<pre><h2>Problem3771</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
#define ln printf(&quot;\n&quot;)
const DD pai=3.14159265358979;
int n,N,L,rev[132001];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9')
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar();
}
struct cp
{
	DD r,i;
	cp(DD a=0,DD b=0) {r=a;i=b;}
	friend cp operator +(cp a,cp b) {return cp(a.r+b.r,a.i+b.i);}
	friend cp operator -(cp a,cp b) {return cp(a.r-b.r,a.i-b.i);}
	friend cp operator *(cp a,cp b) {return cp(a.r*b.r-a.i*b.i,a.r*b.i+b.r*a.i);}
} a[132001],b[132001],c[132001];
void fft(cp *a,int ff)
{
	int i,j,k,p;
	for (i=0;i&lt;N;i++)
		if (i&lt;rev[i]) swap(a[i],a[rev[i]]);
	for (i=1;i&lt;N;i&lt;&lt;=1)
	{
		cp wn(cos(pai/i),ff*sin(pai/i));
		for (p=i&lt;&lt;1,j=0;j&lt;N;j+=p)
		{
			cp w(1,0);
			for (k=0;k&lt;i;k++,w=w*wn)
			{
				cp x=a[j+k],y=w*a[j+k+i];
				a[j+k]=x+y,a[j+k+i]=x-y;
			}
		}
	}
	if (ff==-1) for (i=0;i&lt;N;i++) a[i].r/=N;
}
void cheng(cp *aa,cp *bb,cp *c)
{
	static cp a[132001],b[132001];
	int i;
	for (i=0;i&lt;N;i++)
		a[i]=aa[i],b[i]=bb[i];
	fft(a,1);
	fft(b,1);
	for (i=0;i&lt;N;i++) c[i]=a[i]*b[i];
	fft(c,-1);
}
void out(cp *a)
{
	int cnt=0;
	for (int i=0;i&lt;131072;i++)
	{
		int t=a[i].r+0.5;
		if (t&gt;0)
		{
			if (++cnt!=1) printf(&quot; + &quot;);
			printf(&quot;%d*X^%d&quot;,t,i);
		}
	}ln;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);
	int i,x;
	for (i=1;i&lt;=n;i++)
	{
		read(x);
		a[x].r=1;
		b[x*2].r=1;
		c[x*3].r=1;
	}
	//printf(&quot;a &quot;);out(a);ln;
	N=1,L=0;
	while (N&lt;131071) N&lt;&lt;=1,L++;
	for (i=0;i&lt;N;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(L-1));
	static DD ans[132001];
	for (i=0;i&lt;N;i++) ans[i]=a[i].r;
	static cp a2[132001],ab[132001],a3[132001];
	cheng(a,a,a2);
	//printf(&quot;a2 &quot;);out(a2);ln;
	for (i=0;i&lt;N;i++)
		ans[i]=ans[i]+(a2[i].r-b[i].r)*0.5;
	cheng(a,a2,a3);
	cheng(a,b,ab);
	for (i=0;i&lt;N;i++)
		ans[i]=ans[i]+(a3[i].r-ab[i].r*3+c[i].r*2)/6;
	for (i=0;i&lt;N;i++)
	{
		int t=ans[i]+0.5;
		if (t&gt;0) printf(&quot;%d %d\n&quot;,i,t);
	}
	return 0;
}<pre><h2>Problem3771</h2><pre>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
#define pi 3.14159265358979323846
inline int MAX(int A,int B){return A&gt;B?A:B;}
struct cpx{
	double r,i;
	inline friend cpx operator + (cpx a,cpx b){return (cpx){a.r+b.r,a.i+b.i};}
	inline friend cpx operator - (cpx a,cpx b){return (cpx){a.r-b.r,a.i-b.i};}
	inline friend cpx operator * (cpx a,cpx b){return (cpx){a.r*b.r-a.i*b.i,a.r*b.i+a.i*b.r};}
	inline friend cpx operator * (double a,cpx b){return (cpx){a*b.r,a*b.i};}
}F[262144],G[262144],H[262144],ANS[262144],tip;
void FFT(cpx *o,int n,int tp){
	for(int i=0,j=0;i&lt;n;++i){
		if(i&gt;j) tip=o[i],o[i]=o[j],o[j]=tip;
		for(int k=n&gt;&gt;1;(j^=k)&lt;k;k&gt;&gt;=1);
	}cpx wn,w,u,t;
	for(int i=2;i&lt;=n;i&lt;&lt;=1){
		wn=(cpx){cos(pi*2/i),tp*sin(pi*2/i)},w=(cpx){1,0};
		for(int j=0;j&lt;n;j+=i,w=(cpx){1,0})
		    for(int k=0,p=i&gt;&gt;1;k&lt;p;++k,w=w*wn)
		        u=o[j+k],t=w*o[j+k+p],o[j+k]=u+t,o[j+k+p]=u-t;
	}if(tp==-1) for(int i=0;i&lt;n;++i) o[i].r/=n;
}
inline void in(int &amp;TEMP){int EPX;for(TEMP=getchar();TEMP&lt;48||TEMP&gt;57;TEMP=getchar());for(TEMP^=48,EPX=getchar();EPX&lt;58&amp;&amp;EPX&gt;47;EPX=getchar())TEMP=(TEMP&lt;&lt;3)+(TEMP&lt;&lt;1)+(EPX^48);}
int n,mx,w;
int main(){
	in(n);for(int i=0;i&lt;n;++i) in(w),F[w].r=1,G[w&lt;&lt;1].r=1,H[w*3].r=1,mx=MAX(mx,w*3);
	for(w=1;w&lt;=mx;w&lt;&lt;=1);w&lt;&lt;=1;
	FFT(F,w,1),FFT(G,w,1),FFT(H,w,1);
	for(int i=0;i&lt;w;++i) ANS[i]=0.1666666667*(F[i]*F[i]*F[i]-3*F[i]*G[i]+2*H[i])+0.5*(F[i]*F[i]-G[i])+F[i];
	FFT(ANS,w,-1);
	for(int i=0;i&lt;w;++i) if((long long)(ANS[i].r+0.5)) printf(&quot;%d %lld\n&quot;,i,(long long)(ANS[i].r+0.5));
}
<pre><h2>Problem3771</h2><pre>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
#define pi 3.14159265358979323846
inline int MAX(int A,int B){return A&gt;B?A:B;}
struct cpx{
	double r,i;
	inline friend cpx operator + (cpx a,cpx b){return (cpx){a.r+b.r,a.i+b.i};}
	inline friend cpx operator - (cpx a,cpx b){return (cpx){a.r-b.r,a.i-b.i};}
	inline friend cpx operator * (cpx a,cpx b){return (cpx){a.r*b.r-a.i*b.i,a.r*b.i+a.i*b.r};}
	inline friend cpx operator * (double a,cpx b){return (cpx){a*b.r,a*b.i};}
}F[262144],G[262144],H[262144],ANS[262144],tip;
void FFT(cpx *o,int n,int tp){
	for(int i=0,j=0;i&lt;n;++i){
		if(i&gt;j) tip=o[i],o[i]=o[j],o[j]=tip;
		for(int k=n&gt;&gt;1;(j^=k)&lt;k;k&gt;&gt;=1);
	}cpx wn,w,u,t;
	for(int i=2;i&lt;=n;i&lt;&lt;=1){
		wn=(cpx){cos(pi*2/i),tp*sin(pi*2/i)},w=(cpx){1,0};
		for(int j=0;j&lt;n;j+=i,w=(cpx){1,0})
		    for(int k=0,p=i&gt;&gt;1;k&lt;p;++k,w=w*wn)
		        u=o[j+k],t=w*o[j+k+p],o[j+k]=u+t,o[j+k+p]=u-t;
	}if(tp==-1) for(int i=0;i&lt;n;++i) o[i].r/=n;
}
inline void in(int &amp;TEMP){int EPX;for(TEMP=getchar();TEMP&lt;48||TEMP&gt;57;TEMP=getchar());for(TEMP^=48,EPX=getchar();EPX&lt;58&amp;&amp;EPX&gt;47;EPX=getchar())TEMP=(TEMP&lt;&lt;3)+(TEMP&lt;&lt;1)+(EPX^48);}
int n,mx,w;
int main(){
	in(n);for(int i=0;i&lt;n;++i) in(w),F[w].r=1,G[w&lt;&lt;1].r=1,H[w*3].r=1,mx=MAX(mx,w*3);
	for(w=1;w&lt;=mx;w&lt;&lt;=1);w&lt;&lt;=1;
	FFT(F,w,1),FFT(G,w,1),FFT(H,w,1);
	for(int i=0;i&lt;w;++i) ANS[i]=0.1666666667*(F[i]*F[i]*F[i]-3*F[i]*G[i]+2*H[i])+0.5*(F[i]*F[i]-G[i])+F[i];
	FFT(ANS,w,-1);
	for(int i=0;i&lt;w;++i) if(ANS[i].r&gt;0.1) printf(&quot;%d %lld\n&quot;,i,(long long)(ANS[i].r+0.5));
}
<pre><h2>Problem3774</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define h(i,j) (((i)-1)*m+(j))
#define h2(i,j) (h(i,j)+n*m)
#define inf 999999999
const int NN=100,AA=NN*NN*2;
int o[AA],cur[AA],deep[AA],aa[AA*50][3];
int n,m,tot=1,S,T,ans;
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline void add(int p,int q,int v)
{
	//printf(&quot;add %d %d %d\n&quot;,p,q,v);
	addedge(p,q,v);
	addedge(q,p,0);
}
bool bfs()
{
	static int que[AA];
	memset(deep,0,sizeof(deep));
	deep[S]=1;
	int head=0,tail=1;
	que[1]=S;
	while (head&lt;tail)
	{
		int x=que[++head];
		cur[x]=o[x];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y])
				deep[y]=deep[x]+1,que[++tail]=y;
		}
	}
	return deep[T];
}
int dfs(int v,int ff)
{
	if (v==T) return ff;
	int res=0;
	for (int &amp;p=cur[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,min(aa[p][2],ff));
		ff-=tmp,aa[p][2]-=tmp;
		aa[p^1][2]+=tmp,res+=tmp;
		if (ff==0) break;
	}
	if (res==0) deep[v]=inf;
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	S=n*m*2+1,T=S+1;
	int i,j,k,x;
	for (i=1;i&lt;=n;i++) for (j=1;j&lt;=m;j++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		if ((i+j)&amp;1) add(S,h(i,j),x);
		else add(h(i,j),T,x);
	}
	for (i=1;i&lt;=n;i++) for (j=1;j&lt;=m;j++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		ans+=x&lt;&lt;1;
		if ((i+j)&amp;1)
			add(h(i,j),T,x),add(S,h2(i,j),x);
		else
			add(S,h(i,j),x),add(h2(i,j),T,x);
	}
	for (i=1;i&lt;=n;i++) for (j=1;j&lt;=m;j++)
	{
		if ((i+j)&amp;1) add(h2(i,j),h(i,j),inf);
		else add(h(i,j),h2(i,j),inf);
		static int dx[4]={-1,0,0,1},dy[4]={0,1,-1,0};
		for (k=0;k&lt;4;k++)
		{
			int x=i+dx[k],y=j+dy[k];
			if (x&lt;1||x&gt;n||y&lt;1||y&gt;m) continue;
			if ((i+j)&amp;1) add(h2(i,j),h(x,y),inf);
			else add(h(x,y),h2(i,j),inf);
		}
	}
	while (bfs()) ans-=dfs(S,inf);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3779</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
const int NN=101111;
int o[NN],aa[NN&lt;&lt;1][2];
int n,m,tot=1;
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);ln;}
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar()) x=x*10+ch-'0';
	if (f) x=-x;
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
struct Tree
{
	int fa[NN],f[19][NN],deep[NN];
	void dfs(int v)
	{
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[v]) continue;
			fa[y]=v;
			deep[y]=deep[v]+1;
			dfs(y);
		}
	}
	void init()
	{
		deep[1]=1,dfs(1);
		int i,j;
		for (i=1;i&lt;=n;i++) f[0][i]=fa[i];
		for (j=1;j&lt;=18;j++)
			for (i=1;i&lt;=n;i++)
				f[j][i]=f[j-1][f[j-1][i]];
	}
	inline int getlca(int x,int y)
	{
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		for (int i=18;i&gt;=0;i--)
			if (deep[f[i][x]]&gt;=deep[y]) x=f[i][x];
		if (x==y) return x;
		for (int i=18;i&gt;=0;i--)
			if (f[i][x]!=f[i][y]) x=f[i][x],y=f[i][y];
		return f[0][x];
	}
	inline int getlast(int x,int y)
	{
		for (int i=18;i&gt;=0;i--)
			if (deep[f[i][y]]&gt;deep[x]) y=f[i][y];
		return y;
	}
} tree;
struct Dfsxu
{
	#define lc (v&lt;&lt;1)
	#define rc (v&lt;&lt;1|1)
	int st[NN],ed[NN],fa[NN],dy[NN];
	int cnt,nowrt,ww,ee;
	void dfs(int v)
	{
		st[v]=++cnt;
		dy[cnt]=v;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[v]) continue;
			fa[y]=v;
			dfs(y);
		}
		ed[v]=cnt;
	}
	struct segnode
	{
		LL sum,tag;int l,r;
		void clear(int ll,int rr)
		{
			l=ll,r=rr;
			sum=tag=0;
		}
		void add(LL x)
		{
			tag+=x;
			sum+=x*(r-l);
		}
	} t[NN&lt;&lt;2];
	inline void pushdown(int v)
	{
		if (t[v].tag)
		{
			t[lc].add(t[v].tag);
			t[rc].add(t[v].tag);
			t[v].tag=0;
		}
	}
	void build(int v,int l,int r)
	{
		t[v].l=l,t[v].r=r,t[v].tag=0;
		if (r-l==1)
		{
			t[v].sum=tree.deep[dy[l]];
			return;
		}
		int mid=(l+r)&gt;&gt;1;
		build(lc,l,mid);
		build(rc,mid,r);
		t[v].sum=t[lc].sum+t[rc].sum;
	}
	void change(int v,int l,int r,int x)
	{
		if (ww&lt;=l&amp;&amp;r&lt;=ee)
		{
			t[v].add(x);
			return;
		}
		pushdown(v);
		int mid=(l+r)&gt;&gt;1;
		if (ww&lt;mid) change(lc,l,mid,x);
		if (ee&gt;mid) change(rc,mid,r,x);
		t[v].sum=t[lc].sum+t[rc].sum;
	}
	LL find(int v,int l,int r)
	{
		if (ww&lt;=l&amp;&amp;r&lt;=ee) return t[v].sum;
		pushdown(v);
		int mid=(l+r)&gt;&gt;1;LL res=0;
		if (ww&lt;mid) res+=find(lc,l,mid);
		if (ee&gt;mid) res+=find(rc,mid,r);
		return res;
	}
	void init()
	{
		nowrt=1;
		cnt=0;
		dfs(1);
		//printf(&quot;dy &quot;);out(dy,1,n);ln;
		build(1,1,n+1);
	}
	void change(int x,int val)
	{
		if (x==0) return;
		//printf(&quot;=========== change %d %d ==========\n&quot;,x,val);
		if (x==nowrt)
		{
			t[1].add(val);
			return;
		}
		int lca=tree.getlca(x,nowrt);
		if (lca!=x)
		{
			ww=st[x],ee=ed[x]+1;
			change(1,1,n+1,val);
		}
		else
		{
			int y=tree.getlast(x,nowrt);
			ww=1,ee=st[y];
			if (ww&lt;ee) change(1,1,n+1,val);
			ww=ed[y]+1,ee=n+1;
			if (ww&lt;ee) change(1,1,n+1,val);
		}
	}
	LL getsum(int x)
	{
		if (x==nowrt) return t[1].sum;
		int lca=tree.getlca(x,nowrt);
		if (lca!=x)
		{
			ww=st[x],ee=ed[x]+1;
			return find(1,1,n+1);
		}
		else
		{
			int y=tree.getlast(x,nowrt);
			LL res=0;
			ww=1,ee=st[y];
			if (ww&lt;ee) res+=find(1,1,n+1);
			ww=ed[y]+1,ee=n+1;
			if (ww&lt;ee) res+=find(1,1,n+1);
			return res;
		}
	}
	int getsize(int x)
	{
		if (x==nowrt) return n;
		int lca=tree.getlca(x,nowrt);
		if (lca!=x) return ed[x]-st[x]+1;
		else
		{
			int y=tree.getlast(x,nowrt);
			return n-(ed[y]-st[y]+1);
		}
	}
} dfsxu;
struct LCT
{
	int fa[NN],son[NN][2];
	bool rrr[NN],tag[NN];
	void debug(int t)
	{
		if (t==0) return;
		pushdown(t);
		debug(son[t][0]);
		printf(&quot;%d &quot;,t);
		debug(son[t][1]);
	}
	void init()
	{
		memcpy(fa,tree.fa,sizeof(tree.fa));
		for (int i=1;i&lt;=n;i++)
			rrr[i]=true,tag[i]=false;
	}
	inline void rev(int v)
	{
		tag[v]=!tag[v];
		swap(son[v][0],son[v][1]);
	}
	inline void pushdown(int v)
	{
		if (tag[v])
		{
			rev(son[v][0]),rev(son[v][1]);
			tag[v]=false;
		}
	}
	inline void rotate(int t,int p)
	{
		int y=fa[t];
		pushdown(y),pushdown(t);
		if (rrr[y]) rrr[y]=false,rrr[t]=true;
		else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
		fa[t]=fa[y];
		son[y][p^1]=son[t][p];
		if (son[t][p]) fa[son[t][p]]=y;
		son[t][p]=y;
		fa[y]=t;
	}
	void splay(int t)
	{
		while (!rrr[t])
		{
			int y=fa[t];
			if (rrr[y])
				if (t==son[y][0]) rotate(t,1);
				else rotate(t,0);
			else
				if (y==son[fa[y]][0])
					if (t==son[y][0]) rotate(y,1),rotate(t,1);
					else rotate(t,0),rotate(t,1);
				else
					if (t==son[y][1]) rotate(y,0),rotate(t,0);//,printf(&quot;yes!\n&quot;);
					else rotate(t,1),rotate(t,0);
			//ln;for(int i=1;i&lt;=n;i++)if(rrr[i])printf(&quot;debug(%d) fa=%d  &quot;,i,fa[i]),debug(i),ln;
		}
	}
	inline int gettop(int x)
	{
		while (son[x][0])
			pushdown(x),x=son[x][0];
		return x;
	}
	void access(int x)
	{
		int y=0;
		for (;x;y=x,x=fa[x])
		{
			//printf(&quot;~~~~~~~~~~~~~~~~~~~~ x=%d ~~~~~~~~~~~~~~~~~~\n&quot;,x);
			splay(x);
			//printf(&quot;fa[2]=%d\n&quot;,fa[2]);
			//ln;for(int i=1;i&lt;=n;i++)if(rrr[i])printf(&quot;debug(%d) fa=%d  &quot;,i,fa[i]),debug(i),ln;
			pushdown(x);
			dfsxu.change(gettop(son[x][1]),1);
			rrr[son[x][1]]=true;
			son[x][1]=y;
			rrr[y]=false;
			dfsxu.change(gettop(y),-1);
			//ln;for(int i=1;i&lt;=n;i++)if(rrr[i])printf(&quot;debug(%d) fa=%d  &quot;,i,fa[i]),debug(i),ln;
		}
	}
	void makeroot(int x)
	{
		access(x);
		splay(x);
		rev(x);
	}
} lct;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	int i,x,y;
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y);
		addedge(x,y),addedge(y,x);
	}
	tree.init();
	dfsxu.init();
	lct.init();
	for (;m;m--)
	{
		//printf(&quot;\n------------------------------ nowrt=%d --------------------------------\n&quot;,dfsxu.nowrt);
		char s[10];
		scanf(&quot;%s&quot;,s+1);read(x);
		if (s[3]=='L')
		{
			lct.access(x);
		}
		else if (s[3]=='C')
		{
			lct.makeroot(x);
			dfsxu.nowrt=x;
		}
		else
		{
			LL fz=dfsxu.getsum(x),fm=dfsxu.getsize(x);
			printf(&quot;%.10f\n&quot;,(DD)fz/fm);
		}
		//ln;for(int i=1;i&lt;=n;i++)if(lct.rrr[i])printf(&quot;debug(%d) fa=%d  &quot;,i,lct.fa[i]),lct.debug(i),ln;
	}
	return 0;
}<pre><h2>Problem3779</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
const int NN=101111;
int o[NN],aa[NN&lt;&lt;1][2];
int n,m,tot=1;
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);ln;}
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar()) x=x*10+ch-'0';
	if (f) x=-x;
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
struct Tree
{
	int fa[NN],f[19][NN],deep[NN];
	void dfs(int v)
	{
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[v]) continue;
			fa[y]=v;
			deep[y]=deep[v]+1;
			dfs(y);
		}
	}
	void init()
	{
		deep[1]=1,dfs(1);
		int i,j;
		for (i=1;i&lt;=n;i++) f[0][i]=fa[i];
		for (j=1;j&lt;=18;j++)
			for (i=1;i&lt;=n;i++)
				f[j][i]=f[j-1][f[j-1][i]];
	}
	inline int getlca(int x,int y)
	{
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		for (int i=18;i&gt;=0;i--)
			if (deep[f[i][x]]&gt;=deep[y]) x=f[i][x];
		if (x==y) return x;
		for (int i=18;i&gt;=0;i--)
			if (f[i][x]!=f[i][y]) x=f[i][x],y=f[i][y];
		return f[0][x];
	}
	inline int getlast(int x,int y)
	{
		for (int i=18;i&gt;=0;i--)
			if (deep[f[i][y]]&gt;deep[x]) y=f[i][y];
		return y;
	}
} tree;
struct Dfsxu
{
	#define lc (v&lt;&lt;1)
	#define rc (v&lt;&lt;1|1)
	int st[NN],ed[NN],fa[NN],dy[NN];
	int cnt,nowrt,ww,ee;
	void dfs(int v)
	{
		st[v]=++cnt;
		dy[cnt]=v;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[v]) continue;
			fa[y]=v;
			dfs(y);
		}
		ed[v]=cnt;
	}
	struct segnode
	{
		LL sum,tag;int l,r;
		void clear(int ll,int rr)
		{
			l=ll,r=rr;
			sum=tag=0;
		}
		void add(LL x)
		{
			tag+=x;
			sum+=x*(r-l);
		}
	} t[NN&lt;&lt;2];
	inline void pushdown(int v)
	{
		if (t[v].tag)
		{
			t[lc].add(t[v].tag);
			t[rc].add(t[v].tag);
			t[v].tag=0;
		}
	}
	void build(int v,int l,int r)
	{
		t[v].l=l,t[v].r=r,t[v].tag=0;
		if (r-l==1)
		{
			t[v].sum=tree.deep[dy[l]];
			return;
		}
		int mid=(l+r)&gt;&gt;1;
		build(lc,l,mid);
		build(rc,mid,r);
		t[v].sum=t[lc].sum+t[rc].sum;
	}
	void change(int v,int l,int r,int x)
	{
		if (ww&lt;=l&amp;&amp;r&lt;=ee)
		{
			t[v].add(x);
			return;
		}
		pushdown(v);
		int mid=(l+r)&gt;&gt;1;
		if (ww&lt;mid) change(lc,l,mid,x);
		if (ee&gt;mid) change(rc,mid,r,x);
		t[v].sum=t[lc].sum+t[rc].sum;
	}
	LL find(int v,int l,int r)
	{
		if (ww&lt;=l&amp;&amp;r&lt;=ee) return t[v].sum;
		pushdown(v);
		int mid=(l+r)&gt;&gt;1;LL res=0;
		if (ww&lt;mid) res+=find(lc,l,mid);
		if (ee&gt;mid) res+=find(rc,mid,r);
		return res;
	}
	void init()
	{
		nowrt=1;
		cnt=0;
		dfs(1);
		//printf(&quot;dy &quot;);out(dy,1,n);ln;
		build(1,1,n+1);
	}
	void change(int x,int val)
	{
		if (x==0) return;
		//printf(&quot;=========== change %d %d ==========\n&quot;,x,val);
		if (x==nowrt)
		{
			t[1].add(val);
			return;
		}
		int lca=tree.getlca(x,nowrt);
		if (lca!=x)
		{
			ww=st[x],ee=ed[x]+1;
			change(1,1,n+1,val);
		}
		else
		{
			int y=tree.getlast(x,nowrt);
			ww=1,ee=st[y];
			if (ww&lt;ee) change(1,1,n+1,val);
			ww=ed[y]+1,ee=n+1;
			if (ww&lt;ee) change(1,1,n+1,val);
		}
	}
	LL getsum(int x)
	{
		if (x==nowrt) return t[1].sum;
		int lca=tree.getlca(x,nowrt);
		if (lca!=x)
		{
			ww=st[x],ee=ed[x]+1;
			return find(1,1,n+1);
		}
		else
		{
			int y=tree.getlast(x,nowrt);
			LL res=0;
			ww=1,ee=st[y];
			if (ww&lt;ee) res+=find(1,1,n+1);
			ww=ed[y]+1,ee=n+1;
			if (ww&lt;ee) res+=find(1,1,n+1);
			return res;
		}
	}
	int getsize(int x)
	{
		if (x==nowrt) return n;
		int lca=tree.getlca(x,nowrt);
		if (lca!=x) return ed[x]-st[x]+1;
		else
		{
			int y=tree.getlast(x,nowrt);
			return n-(ed[y]-st[y]+1);
		}
	}
} dfsxu;
struct LCT
{
	int fa[NN],son[NN][2];
	bool rrr[NN],tag[NN];
	void debug(int t)
	{
		if (t==0) return;
		pushdown(t);
		debug(son[t][0]);
		printf(&quot;%d &quot;,t);
		debug(son[t][1]);
	}
	void init()
	{
		memcpy(fa,tree.fa,sizeof(tree.fa));
		for (int i=1;i&lt;=n;i++)
			rrr[i]=true,tag[i]=false;
	}
	inline void rev(int v)
	{
		tag[v]=!tag[v];
		swap(son[v][0],son[v][1]);
	}
	inline void pushdown(int v)
	{
		if (tag[v])
		{
			rev(son[v][0]),rev(son[v][1]);
			tag[v]=false;
		}
	}
	inline void rotate(int t,int p)
	{
		int y=fa[t];
		pushdown(y),pushdown(t);
		if (rrr[y]) rrr[y]=false,rrr[t]=true;
		else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
		fa[t]=fa[y];
		son[y][p^1]=son[t][p];
		if (son[t][p]) fa[son[t][p]]=y;
		son[t][p]=y;
		fa[y]=t;
	}
	void splay(int t)
	{
		while (!rrr[t])
		{
			int y=fa[t];
			if (rrr[y])
				if (t==son[y][0]) rotate(t,1);
				else rotate(t,0);
			else
				if (y==son[fa[y]][0])
					if (t==son[y][0]) rotate(y,1),rotate(t,1);
					else rotate(t,0),rotate(t,1);
				else
					if (t==son[y][1]) rotate(y,0),rotate(t,0);//,printf(&quot;yes!\n&quot;);
					else rotate(t,1),rotate(t,0);
			//ln;for(int i=1;i&lt;=n;i++)if(rrr[i])printf(&quot;debug(%d) fa=%d  &quot;,i,fa[i]),debug(i),ln;
		}
	}
	inline int gettop(int x)
	{
		while (son[x][0])
			pushdown(x),x=son[x][0];
		return x;
	}
	void access(int x)
	{
		int y=0;
		for (;x;y=x,x=fa[x])
		{
			//printf(&quot;~~~~~~~~~~~~~~~~~~~~ x=%d ~~~~~~~~~~~~~~~~~~\n&quot;,x);
			splay(x);
			//printf(&quot;fa[2]=%d\n&quot;,fa[2]);
			//ln;for(int i=1;i&lt;=n;i++)if(rrr[i])printf(&quot;debug(%d) fa=%d  &quot;,i,fa[i]),debug(i),ln;
			pushdown(x);
			dfsxu.change(gettop(son[x][1]),1);
			rrr[son[x][1]]=true;
			son[x][1]=y;
			rrr[y]=false;
			dfsxu.change(gettop(y),-1);
			//ln;for(int i=1;i&lt;=n;i++)if(rrr[i])printf(&quot;debug(%d) fa=%d  &quot;,i,fa[i]),debug(i),ln;
		}
	}
	void makeroot(int x)
	{
		access(x);
		splay(x);
		rev(x);
	}
} lct;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	int i,x,y;
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y);
		addedge(x,y),addedge(y,x);
	}
	tree.init();
	dfsxu.init();
	lct.init();
	for (;m;m--)
	{
		//printf(&quot;\n------------------------------ nowrt=%d --------------------------------\n&quot;,dfsxu.nowrt);
		char ch=getchar();
		while (ch!='C'&amp;&amp;ch!='L'&amp;&amp;ch!='Q') ch=getchar();
		if (ch=='L')
		{
			for (i=1;i&lt;=4;i++) getchar();
			read(x);
			lct.access(x);
		}
		else if (ch=='C')
		{
			for (i=1;i&lt;=5;i++) getchar();
			read(x);
			lct.makeroot(x);
			dfsxu.nowrt=x;
		}
		else
		{
			for (i=1;i&lt;=4;i++) getchar();
			read(x);
			LL fz=dfsxu.getsum(x),fm=dfsxu.getsize(x);
			printf(&quot;%.10f\n&quot;,(DD)fz/fm);
		}
		//ln;for(int i=1;i&lt;=n;i++)if(lct.rrr[i])printf(&quot;debug(%d) fa=%d  &quot;,i,lct.fa[i]),lct.debug(i),ln;
	}
	return 0;
}<pre><h2>Problem3779</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int NN=101111;
int o[NN],aa[NN&lt;&lt;1][2];
int n,m,tot=1;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar()) x=x*10+ch-'0';
	if (f) x=-x;
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
struct Tree
{
	int fa[NN],f[19][NN],deep[NN];
	void dfs(int v)
	{
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[v]) continue;
			fa[y]=v;
			deep[y]=deep[v]+1;
			dfs(y);
		}
	}
	void init()
	{
		deep[1]=1,dfs(1);
		int i,j;
		for (i=1;i&lt;=n;i++) f[0][i]=fa[i];
		for (j=1;j&lt;=18;j++)
			for (i=1;i&lt;=n;i++)
				f[j][i]=f[j-1][f[j-1][i]];
	}
	inline int getlca(int x,int y)
	{
		if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
		for (int i=18;i&gt;=0;i--)
			if (deep[f[i][x]]&gt;=deep[y]) x=f[i][x];
		if (x==y) return x;
		for (int i=18;i&gt;=0;i--)
			if (f[i][x]!=f[i][y]) x=f[i][x],y=f[i][y];
		return f[0][x];
	}
	inline int getlast(int x,int y)
	{
		for (int i=18;i&gt;=0;i--)
			if (deep[f[i][y]]&gt;deep[x]) y=f[i][y];
		return y;
	}
} tree;
struct Dfsxu
{
	#define lc (v&lt;&lt;1)
	#define rc (v&lt;&lt;1|1)
	int st[NN],ed[NN],fa[NN],dy[NN];
	int cnt,nowrt,ww,ee;
	void dfs(int v)
	{
		st[v]=++cnt;
		dy[cnt]=v;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[v]) continue;
			fa[y]=v;
			dfs(y);
		}
		ed[v]=cnt;
	}
	struct segnode
	{
		LL sum,tag;int l,r;
		void clear(int ll,int rr)
		{
			l=ll,r=rr;
			sum=tag=0;
		}
		void add(LL x)
		{
			tag+=x;
			sum+=x*(r-l);
		}
	} t[NN&lt;&lt;2];
	inline void pushdown(int v)
	{
		if (t[v].tag)
		{
			t[lc].add(t[v].tag);
			t[rc].add(t[v].tag);
			t[v].tag=0;
		}
	}
	void build(int v,int l,int r)
	{
		t[v].l=l,t[v].r=r,t[v].tag=0;
		if (r-l==1)
		{
			t[v].sum=tree.deep[dy[l]];
			return;
		}
		int mid=(l+r)&gt;&gt;1;
		build(lc,l,mid);
		build(rc,mid,r);
		t[v].sum=t[lc].sum+t[rc].sum;
	}
	void change(int v,int l,int r,int x)
	{
		if (ww&lt;=l&amp;&amp;r&lt;=ee)
		{
			t[v].add(x);
			return;
		}
		pushdown(v);
		int mid=(l+r)&gt;&gt;1;
		if (ww&lt;mid) change(lc,l,mid,x);
		if (ee&gt;mid) change(rc,mid,r,x);
		t[v].sum=t[lc].sum+t[rc].sum;
	}
	LL find(int v,int l,int r)
	{
		if (ww&lt;=l&amp;&amp;r&lt;=ee) return t[v].sum;
		pushdown(v);
		int mid=(l+r)&gt;&gt;1;LL res=0;
		if (ww&lt;mid) res+=find(lc,l,mid);
		if (ee&gt;mid) res+=find(rc,mid,r);
		return res;
	}
	void init()
	{
		nowrt=1;
		cnt=0;
		dfs(1);
		build(1,1,n+1);
	}
	void change(int x,int val)
	{
		if (x==0) return;
		if (x==nowrt)
		{
			t[1].add(val);
			return;
		}
		int lca=tree.getlca(x,nowrt);
		if (lca!=x)
		{
			ww=st[x],ee=ed[x]+1;
			change(1,1,n+1,val);
		}
		else
		{
			int y=tree.getlast(x,nowrt);
			ww=1,ee=st[y];
			if (ww&lt;ee) change(1,1,n+1,val);
			ww=ed[y]+1,ee=n+1;
			if (ww&lt;ee) change(1,1,n+1,val);
		}
	}
	LL getsum(int x)
	{
		if (x==nowrt) return t[1].sum;
		int lca=tree.getlca(x,nowrt);
		if (lca!=x)
		{
			ww=st[x],ee=ed[x]+1;
			return find(1,1,n+1);
		}
		else
		{
			int y=tree.getlast(x,nowrt);
			LL res=0;
			ww=1,ee=st[y];
			if (ww&lt;ee) res+=find(1,1,n+1);
			ww=ed[y]+1,ee=n+1;
			if (ww&lt;ee) res+=find(1,1,n+1);
			return res;
		}
	}
	int getsize(int x)
	{
		if (x==nowrt) return n;
		int lca=tree.getlca(x,nowrt);
		if (lca!=x) return ed[x]-st[x]+1;
		else
		{
			int y=tree.getlast(x,nowrt);
			return n-(ed[y]-st[y]+1);
		}
	}
} dfsxu;
struct LCT
{
	int fa[NN],son[NN][2];
	bool rrr[NN],tag[NN];
	void init()
	{
		memcpy(fa,tree.fa,sizeof(tree.fa));
		for (int i=1;i&lt;=n;i++)
			rrr[i]=true,tag[i]=false;
	}
	inline void rev(int v)
	{
		tag[v]=!tag[v];
		swap(son[v][0],son[v][1]);
	}
	inline void pushdown(int v)
	{
		if (tag[v])
		{
			rev(son[v][0]),rev(son[v][1]);
			tag[v]=false;
		}
	}
	inline void rotate(int t,int p)
	{
		int y=fa[t];
		pushdown(y),pushdown(t);
		if (rrr[y]) rrr[y]=false,rrr[t]=true;
		else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
		else son[fa[y]][1]=t;
		fa[t]=fa[y];
		son[y][p^1]=son[t][p];
		if (son[t][p]) fa[son[t][p]]=y;
		son[t][p]=y;
		fa[y]=t;
	}
	void splay(int t)
	{
		while (!rrr[t])
		{
			int y=fa[t];
			if (rrr[y])
				if (t==son[y][0]) rotate(t,1);
				else rotate(t,0);
			else
				if (y==son[fa[y]][0])
					if (t==son[y][0]) rotate(y,1),rotate(t,1);
					else rotate(t,0),rotate(t,1);
				else
					if (t==son[y][1]) rotate(y,0),rotate(t,0);//,printf(&quot;yes!\n&quot;);
					else rotate(t,1),rotate(t,0);
		}
	}
	inline int gettop(int x)
	{
		while (son[x][0])
			pushdown(x),x=son[x][0];
		return x;
	}
	void access(int x)
	{
		int y=0;
		for (;x;y=x,x=fa[x])
		{
			splay(x);
			pushdown(x);
			dfsxu.change(gettop(son[x][1]),1);
			rrr[son[x][1]]=true;
			son[x][1]=y;
			rrr[y]=false;
			dfsxu.change(gettop(y),-1);
		}
	}
	void makeroot(int x)
	{
		access(x);
		splay(x);
		rev(x);
	}
} lct;
int main()
{
	read(n),read(m);
	int i,x,y;
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y);
		addedge(x,y),addedge(y,x);
	}
	tree.init();
	dfsxu.init();
	lct.init();
	for (;m;m--)
	{
		char ch=getchar();
		while (ch!='C'&amp;&amp;ch!='L'&amp;&amp;ch!='Q') ch=getchar();
		if (ch=='L')
		{
			for (i=1;i&lt;=4;i++) getchar();
			read(x);
			lct.access(x);
		}
		else if (ch=='C')
		{
			for (i=1;i&lt;=5;i++) getchar();
			read(x);
			lct.makeroot(x);
			dfsxu.nowrt=x;
		}
		else
		{
			for (i=1;i&lt;=4;i++) getchar();
			read(x);
			LL fz=dfsxu.getsum(x),fm=dfsxu.getsize(x);
			printf(&quot;%.10f\n&quot;,1.0*fz/fm);
		}
	}
	return 0;
}<pre><h2>Problem3782</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
typedef pair&lt;LL,LL&gt; pll;
#define mp make_pair
#define fi first
#define se second
#define ln printf(&quot;\n&quot;)
const LL NN=2005;
LL fac[10][1000005],pr[100],pp[100],e[100],phi[100],f[NN];
LL n,m,P;
LL num,tot;
struct ppt
{
	LL x,y;
	ppt(LL a=0,LL b=0) {x=a;y=b;}
	inline void in() {scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y);}
	friend bool operator &lt;(const ppt &amp;a,const ppt &amp;b)
	{
		if (a.x!=b.x) return a.x&lt;b.x;
		return a.y&lt;b.y;
	}
} pos[NN];
inline LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (a%=c;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
void prepare()
{
	LL P2=P,i,j;
	for (i=2;i*i&lt;=P2;i++) if (P2%i==0)
	{
		tot++;
		pr[tot]=i;
		pp[tot]=1;
		for (;P2%i==0;P2/=i) pp[tot]*=i;
		phi[tot]=pp[tot]/i*(i-1);
		e[tot]=P/pp[tot]*ksm(P/pp[tot],phi[tot]-1,pp[tot])%P;
	}
	if (P2&gt;1)
	{
		i=P2;
		tot++;
		pr[tot]=i;
		pp[tot]=1;
		for (;P2%i==0;P2/=i) pp[tot]*=i;
		phi[tot]=pp[tot]/i*(i-1);
		e[tot]=P/pp[tot]*ksm(P/pp[tot],phi[tot]-1,pp[tot])%P;
	}
	for (i=1;i&lt;=tot;i++)
	{
		fac[i][0]=1;
		for (j=1;j&lt;=pp[i];j++)
			if (j%pr[i]==0) fac[i][j]=fac[i][j-1];
			else fac[i][j]=fac[i][j-1]*j%pp[i];
	}
	//for(i=1;i&lt;=tot;i++)printf(&quot;pr=%lld pp=%lld phi=%lld\n&quot;,pr[i],pp[i],phi[i]);
}
pll calc(LL n,LL i)
{
	LL t1=1,t2=0;
	while (n)
	{
		t2=t2+n/pr[i];
		t1=t1*ksm(fac[i][pp[i]],n/pp[i],pp[i])%pp[i];
		t1=t1*fac[i][n%pp[i]]%pp[i];
		n/=pr[i];
	}
	return mp(t1,t2);
}
LL getC(LL n,LL m)
{
	if (m==0) return 1;
	LL ans=0;
	for (LL i=1;i&lt;=tot;i++)
	{
		pll res=calc(n,i);
		//printf(&quot;res: %lld %lld\n&quot;,res.fi,res.se);
		pll tmp=calc(m,i);
		//printf(&quot;tmp: %lld %lld\n&quot;,tmp.fi,tmp.se);
		res.fi=res.fi*ksm(tmp.fi,phi[i]-1,pp[i])%pp[i];
		res.se=res.se-tmp.se;
		tmp=calc(n-m,i);
		//printf(&quot;tmp: %lld %lld\n&quot;,tmp.fi,tmp.se);
		res.fi=res.fi*ksm(tmp.fi,phi[i]-1,pp[i])%pp[i];
		res.se=res.se-tmp.se;
		LL t=res.fi*ksm(pr[i],res.se,pp[i])%pp[i];
		ans=(ans+e[i]*t)%P;
		//printf(&quot;t=%lld\n&quot;,t);
	}
	return ans;
}
int main()
{
	//、、freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;num,&amp;P);
	LL i,j;
	for (i=1;i&lt;=num;i++) pos[i].in();
	pos[++num]=ppt(n,m);
	sort(pos+1,pos+num+1);
	prepare();
	for (i=1;i&lt;=num;i++)
	{
		LL x=pos[i].x,y=pos[i].y;
		f[i]=getC(x+y,x);
		for (j=1;j&lt;i;j++)
			if (pos[j].x&lt;=x&amp;&amp;pos[j].y&lt;=y)
			{
				f[i]-=f[j]*getC(x-pos[j].x+y-pos[j].y,x-pos[j].x)%P;
				if (f[i]&lt;0) f[i]+=P;
			}
	}
	printf(&quot;%lld\n&quot;,f[num]);
	return 0;
}<pre><h2>Problem3784</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
#define fi first
#define se second
#define mp make_pair
#define inf 999999999
const int NN=51111,AA=1000000;
int fa[NN],size[NN],o[NN],aa[NN*2][3],deep[NN],b[AA],id[AA][21],log[AA];
int n,K,cnt,tot=1;
pair&lt;int,int&gt; qujian[AA];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void calcsize(int v)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||deep[y]&lt;deep[v]) continue;
		fa[y]=v;
		calcsize(y);
		size[v]+=size[y];
	}
}
int core(int v)
{
	fa[v]=0;calcsize(v);
	for (;;)
	{
		bool flag=false;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (deep[y]&lt;deep[v]) continue;
			if (size[y]&lt;&lt;1&gt;size[v])
			{
				size[v]-=size[y];
				size[y]+=size[v];
				v=y;flag=true;break;
			}
		}
		if (!flag) break;
	}
	return v;
}
void dfs(int v,int d,int l,int r)
{
	b[++cnt]=d;
	qujian[cnt]=mp(l,r);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]||y==fa[v]) continue;
		fa[y]=v;
		dfs(y,d+aa[p][2],l,r);
	}
}
void work(int v)
{
	b[++cnt]=0;
	qujian[cnt]=mp(inf,-inf);
	int l=cnt,r=cnt;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]) continue;
		fa[y]=0;
		dfs(y,aa[p][2],l,r);
		r=cnt;
	}
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]) continue;
		y=core(y);
		deep[y]=deep[v]+1;
		work(y);
	}
}
inline int maxid(int l,int r)
{
	int t=log[r-l+1],t1=id[l][t],t2=id[r-(1&lt;&lt;t)+1][t];
	if (b[t1]&gt;b[t2]) return t1;
	else return t2;
}
struct ppt
{
	int id,l,r,the;
	ppt(int id_=0,int l_=0,int r_=0,int the_=0) {id=id_,l=l_,r=r_,the=the_;}
	friend bool operator &lt;(const ppt &amp;x,const ppt &amp;y)
	{
		return b[x.id]+b[x.the]&lt;b[y.id]+b[y.the];
	}
};
priority_queue&lt;ppt&gt; Q;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);read(K);
	int i,j,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y),read(z);
		addedge(x,y,z),addedge(y,x,z);
	}
	memset(deep,60,sizeof(deep));
	int t=core(1);
	deep[t]=1;
	work(t);
	log[1]=0;
	for (i=2;i&lt;=cnt;i++)
		if (i==(i&amp;-i)) log[i]=log[i-1]+1;
		else log[i]=log[i-1];
	for (i=1;i&lt;=cnt;i++) id[i][0]=i;
	for (j=1;j&lt;=log[n];j++)
		for (i=1;i+(1&lt;&lt;(j-1))&lt;=cnt;i++)
		{
			int t1=id[i][j-1],t2=id[i+(1&lt;&lt;(j-1))][j-1];
			if (b[t1]&gt;b[t2]) id[i][j]=t1;
			else id[i][j]=t2;
		}
	for (i=1;i&lt;=cnt;i++)
		if (qujian[i].fi&lt;=qujian[i].se)
		{
			int t=maxid(qujian[i].fi,qujian[i].se);
			Q.push(ppt(i,qujian[i].fi,qujian[i].se,t));
		}
	for (;K;K--)
	{
		ppt tmp=Q.top();Q.pop();
		printf(&quot;%d\n&quot;,b[tmp.id]+b[tmp.the]);
		int i=tmp.id,t=tmp.the,l=tmp.l,r=tmp.r;
		if (l&lt;t)
		{
			int k=maxid(l,t-1);
			Q.push(ppt(i,l,t-1,k));
		}
		if (r&gt;t)
		{
			int k=maxid(t+1,r);
			Q.push(ppt(i,t+1,r,k));
		}
	}
	return 0;
}<pre><h2>Problem3786</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const int NN=201111;
int o[NN],aa[NN][2],st[NN],ed[NN];
int n,m,tot,cnt,root;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
struct splaynode
{
	int fa,sz1,sz2,s[2];
	LL sum,tag,key;
	bool kind;
	inline void add(int x)
	{
		tag+=x;
		key+=(kind)?x:-x;
		sum+=(LL)(sz1-sz2)*x;
	}
} T[NN];
void dfs(int v)
{
	st[v]=++cnt;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		dfs(y);
	}
	ed[v]=++cnt;
}
inline void pushdown(int t)
{
	if (!T[t].tag) return;
	T[T[t].s[0]].add(T[t].tag);
	T[T[t].s[1]].add(T[t].tag);
	T[t].tag=0;
}
inline void update(int t)
{
	int x=T[t].s[0],y=T[t].s[1];
	T[t].sz1=T[x].sz1+T[y].sz1+(T[t].kind);
	T[t].sz2=T[x].sz2+T[y].sz2+(!T[t].kind);
	T[t].sum=T[x].sum+T[y].sum+T[t].key;
}
void rotate(int t,int p)
{
	int y=T[t].fa;
	pushdown(y),pushdown(t);
	if (T[y].fa)
	{
		if (y==T[T[y].fa].s[0]) T[T[y].fa].s[0]=t;
		else T[T[y].fa].s[1]=t;
	}
	T[t].fa=T[y].fa;
	T[y].s[p^1]=T[t].s[p];
	if (T[t].s[p]) T[T[t].s[p]].fa=y;
	T[t].s[p]=y;
	T[y].fa=t;
	update(y),update(t);
}
void splay(int t,int ff)
{
	while (T[t].fa!=ff)
	{
		int y=T[t].fa;
		if (T[y].fa==ff)
			if (t==T[y].s[0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==T[T[y].fa].s[0])
				if (t==T[y].s[0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==T[y].s[1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
	if (ff==0) root=t;
}
int pred(int t)
{
	splay(t,0);
	int x=T[t].s[0];
	while (T[x].s[1])
		pushdown(x),x=T[x].s[1];
	return x;
}
int succ(int t)
{
	splay(t,0);
	int x=T[t].s[1];
	while (T[x].s[0])
		pushdown(x),x=T[x].s[0];
	return x;
}
int build(int l,int r)
{
	int mid=(l+r)&gt;&gt;1,v=mid;
	T[v].sum=T[v].key;
	if (l&lt;mid) T[T[v].s[0]=build(l,mid-1)].fa=v;
	if (r&gt;mid) T[T[v].s[1]=build(mid+1,r)].fa=v;
	update(v);
	return v;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);
	int i,x,y,a,b;
	for (i=2;i&lt;=n;i++)
	{
		read(x);
		addedge(x,i);
	}
	cnt=1;
	dfs(1);
	cnt++;
	for (i=1;i&lt;=n;i++)
	{
		read(x);
		T[st[i]].kind=true,T[st[i]].key=x;
		T[ed[i]].kind=false,T[ed[i]].key=-x;
	}
	root=build(1,cnt);
	for (read(m);m;m--)
	{
		char ch=getchar();
		while (ch!='Q'&amp;&amp;ch!='F'&amp;&amp;ch!='C') ch=getchar();
		if (ch=='Q')
		{
			read(x);
			x=st[x];splay(x,0);
			y=succ(x);
			splay(1,0),splay(y,1);
			splay(x,y);
			printf(&quot;%lld\n&quot;,T[x].sum);
		}
		else if (ch=='C')
		{
			read(x),read(y);
			a=pred(st[x]),b=succ(ed[x]);
			splay(a,0),splay(b,a);
			x=T[b].s[0];
			T[x].fa=T[b].s[0]=0;
			splay(b,0);
			a=pred(st[y]),b=succ(st[y]);
			splay(a,0),splay(b,a);
			y=T[b].s[0];
			T[x].fa=y,T[y].s[1]=x;
			splay(y,0);
		}
		else
		{
			read(x),read(y);
			a=pred(st[x]),b=succ(ed[x]);
			splay(a,0),splay(b,a);
			x=T[b].s[0];
			T[x].add(y);
			splay(x,0);
		}
	}
	return 0;
}<pre><h2>Problem3787</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;

#define lowbit(i) (i&amp;-i)
#define maxn 50010
#define maxblo 400

using namespace std;

int n,m,tr[maxblo][maxn],S[maxblo][maxn],blo,blonum,T[maxn],g[maxblo][maxblo],belong[maxn],l[maxn],r[maxn];
int a[maxn],id[maxn],tim;

inline int read()
{
	int ret=0;char ch=getchar();
	while(ch&lt;'!') ch=getchar();
	while(ch&gt;'!') ret=ret*10+ch-'0',ch=getchar();
	return ret;
}

void add(int pos,int val,int tr[])
{
	for(int i=pos;i&lt;=n;i+=lowbit(i)) tr[i]+=val;
}

int ask(int pos,int tr[])
{
	int ret=0;
	for(int i=pos;i&gt;0;i-=lowbit(i))	ret+=tr[i];
	return ret;
}

void addb(int pos,int val,int tr[])
{
	for(int i=pos;i&lt;=blonum;i+=lowbit(i)) tr[i]+=val;
}

int askb(int pos,int tr[])
{
	int ret=0;
	for(int i=pos;i&gt;0;i-=lowbit(i)) ret+=tr[i];
	return ret;
}

void pre()
{
	blo=sqrt(n);
	blonum=(n-1)/blo+1;
	for(int i=1;i&lt;=n;i++) belong[i]=(i-1)/blo+1;
	for(int i=1;i&lt;=blonum;i++) l[i]=blo*(i-1)+1,r[i]=blo*i;
	//for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,belong[i]);
	r[blonum]=n;
	for(int i=1;i&lt;=blonum;i++){
		for(int j=l[i];j&lt;=r[i];j++) addb(i,ask(n,tr[i])-ask(a[j],tr[i]),g[i]),add(a[j],1,tr[i]);
	}
	for(int i=1;i&lt;=n;i++){
		for(int j=belong[i];j&lt;=blonum;j++){
			add(a[i],1,S[j]);
		}
	}
	for(int i=1;i&lt;=blonum;i++){
		for(int k=i+1;k&lt;=blonum;k++){			
			for(int j=l[k];j&lt;=r[k];j++){
				addb(k,ask(n,tr[i])-ask(a[j],tr[i]),g[i]);
			}
		}
	}
}

void work1(int pos,int val)
{
	int now=belong[pos];
	for(int i=l[now];i&lt;=r[now];i++) add(a[i],-1,tr[now]);
	int bef=a[pos];a[pos]=val;
	int sum=0;
	for(int i=l[now];i&lt;=r[now];i++) sum+=ask(n,tr[now])-ask(a[i],tr[now]),add(a[i],1,tr[now]);
	addb(now,-g[now][now],g[now]);
	addb(now,sum,g[now]);
	for(int i=now+1;i&lt;=blonum;i++){
		addb(i,-ask(bef-1,tr[i])+ask(val-1,tr[i]),g[now]);
	}
	for(int i=1;i&lt;now;i++){
		addb(now,-(ask(n,tr[i])-ask(bef,tr[i])),g[i]);
		addb(now,ask(n,tr[i])-ask(val,tr[i]),g[i]);
	}
	for(int i=now;i&lt;=blonum;i++){
		add(bef,-1,S[i]);
		add(val,1,S[i]);
	}
}

void ADD(int pos,int val)
{
	for(int i=pos;i&lt;=n;i+=lowbit(i)){
		if(id[i]==tim) T[i]++;
		else id[i]=tim,T[i]=1;
	}
}

int ASK(int pos)
{
	int ret=0;
	for(int i=pos;i&gt;0;i-=lowbit(i)){
		if(id[i]==tim) ret+=T[i];
	}
	return ret;
}

int work(int L,int R)
{
	int posl=0,posr=0,ans=0;
	while(l[posl]&lt;L) posl++;
	while(r[posr]&lt;R) posr++;posr--;
	if(posl&lt;=posr){
		for(int i=posl;i&lt;=posr;i++){
			ans+=askb(posr,g[i]);
		}
		for(int i=L;i&lt;l[posl];i++){
			ans+=ASK(n)-ASK(a[i]);
			ADD(a[i],1);
			ans+=ask(a[i]-1,S[posr])-ask(a[i]-1,S[posl-1]);
		}
		for(int i=r[posr]+1;i&lt;=R;i++){
			ans+=ASK(n)-ASK(a[i]);
			ADD(a[i],1);
			ans+=(ask(n,S[posr])-ask(a[i],S[posr]))-(ask(n,S[posl-1])-ask(a[i],S[posl-1]));
		}
	}else{
		for(int i=L;i&lt;=R;i++){
			ans+=ASK(n)-ASK(a[i]);
			ADD(a[i],1);
		}
	}
	return ans;
}

int main()
{
	n=read();
	for(int i=1;i&lt;=n;i++) a[i]=read();
	pre();
	m=read();
	int lastans=0;
	for(int i=1;i&lt;=m;i++){
		tim=i;
		int cmd=read(),x=read(),y=read();
		x^=lastans,y^=lastans;
		if(cmd){
			work1(x,y);
		}else{
			printf(&quot;%d\n&quot;,lastans=work(x,y));
		}
	}
	return 0;
}
<pre><h2>Problem3787</h2><pre>
#define MAXN 50010UL
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;

using namespace std;

int n, m, num, c[MAXN], f[250][250], w[MAXN], fv[MAXN], sa[250][MAXN], bg[MAXN], sum[250][MAXN], bk[250][2], T, idx[MAXN];
int ans;

inline void In(int &amp;x) {
	x = 0;
	char tmp = getchar();
	while(tmp&lt;'0'||tmp&gt;'9') tmp = getchar();
	while(tmp&gt;='0'&amp;&amp;tmp&lt;='9') {
		x = x*10+tmp-'0';
		tmp = getchar();
	}
	return;
}

inline void Add(int x, int *C, int k, int nw) {
	while(x&lt;=nw) {
		C[x] += k;
		x += x&amp;(-x);
	}
	return;
}

inline int Find(int x, int *C) {
	int an = 0;
	while(x&gt;0) {
		an += C[x];
		x -= x&amp;(-x);
	}
	return an;
}

inline void ADD(int x) {
	while(x&lt;=n) {
		if(idx[x]==T) ++ c[x];
		else c[x] = 1, idx[x] = T;
		x += x&amp;(-x);
	}
	return;
}

inline int FIND(int x) {
	int an = 0;
	while(x&gt;0) {
		if(idx[x]==T) an += c[x];
		else c[x] = 0, idx[x] = T;
		x -= x&amp;(-x);
	}
	return an;
}

inline void Pre() {
	In(n);
	int blo = 300;
	for(int i = 1 ; i &lt;= n ; ++ i) {
		In(w[i]);
		bg[i] = (i-1)/blo+1;
		if(bg[i]!=bg[i-1]) {
			++ num;
			bk[num-1][1] = i-1, bk[num][0] = i;
		}
	}
	bk[num][1] = n;
	for(int i = 1 ; i &lt;= num ; ++ i) {
		++ T;
		int zg = 0;
		for(int j = bk[i][0] ; j &lt;= bk[i][1] ; ++ j) {
			zg += j-bk[i][0]-FIND(w[j]);
			++ sa[i][w[j]];
			ADD(w[j]);
		}
		for(int j = 1 ; j &lt;= n ; ++ j) sa[i][j] += sa[i-1][j], Add(j, sum[i], sa[i][j], n);
		Add(i, f[i], zg, num), fv[i] = zg;
		for(int j = i+1 ; j &lt;= num ; ++ j) {
			zg = 0;
			for(int k = bk[j][0] ; k &lt;= bk[j][1] ; ++ k) {
				zg += bk[i][1]-bk[i][0]+1-(Find(w[k], sum[i])-Find(w[k], sum[i-1]));
			}
			Add(i, f[j], zg, num);
		}
	}
	return;
}

inline int MIN(int A, int B) { return A&lt;B?A:B; }

inline int Work(int l, int r) {
	ans = 0;
	int lt = bg[l]+1, rt = bg[r]-1;
	for(int i = lt ; i &lt;= rt ; ++ i) ans += Find(i, f[i])-Find(lt-1, f[i]);
	++ T;
	for(int i = l ; i &lt;= MIN(bk[bg[l]][1], r) ; ++ i) {
		if(lt&lt;=rt) ans += Find(w[i]-1, sum[rt])-Find(w[i]-1, sum[lt-1]);
		ans += i-l-FIND(w[i]);
		ADD(w[i]);
	}
	if(bg[l]!=bg[r]) {
		for(int i = bk[bg[r]][0] ; i &lt;= r ; ++ i) {
			if(lt&lt;=rt) ans += bk[rt][1]-Find(w[i], sum[rt])-(bk[lt-1][1]-Find(w[i], sum[lt-1]));
			ans += i-bk[bg[r]][0]+bk[bg[l]][1]-l+1-FIND(w[i]);
			ADD(w[i]);
		}
	}
	return ans;
}

inline void Change(int x, int y) {
//	printf(&quot;w[%d] = %d %d\n&quot;, x, w[x], y);
	for(int i = 1 ; i &lt; bg[x] ; ++ i) {                               
		int zg = bk[i][1]-bk[i-1][1]-(Find(y, sum[i])-Find(y, sum[i-1]))-(bk[i][1]-bk[i-1][1]-(Find(w[x], sum[i])-Find(w[x], sum[i-1])));
		Add(i, f[bg[x]], zg, num);
	}//+bk[i-1][1]-Find(w[x], sum[i-1])-(bk[i][1]-Find(w[x], sum[i]));
	for(int i = bg[x]+1 ; i &lt;= num ; ++ i) {
		int zg = Find(w[x]-1, sum[i-1])-Find(w[x]-1, sum[i])+Find(y-1, sum[i])-Find(y-1, sum[i-1]);
		Add(bg[x], f[i], zg, num);
	}
	Add(bg[x], f[bg[x]], -fv[bg[x]], num);
//	printf(&quot;fv[bg[x]] = %d\n&quot;, fv[bg[x]]);
	fv[bg[x]] = 0;
	for(int i = bg[x] ; i &lt;= num ; ++ i) Add(w[x], sum[i], -1, n), Add(y, sum[i], 1, n);
	++ T;
	w[x] = y;
	for(int j = bk[bg[x]][0] ; j &lt;= bk[bg[x]][1] ; ++ j) {
        fv[bg[x]] += j-bk[bg[x]][0]-FIND(w[j]);
		ADD(w[j]);
	}
//	printf(&quot;fv[bg[x]] = %d\n&quot;, fv[bg[x]]);
	Add(bg[x], f[bg[x]], fv[bg[x]], num);

//	w[x] = y;
	return;
}

int main() {
//	freopen(&quot;ts.in&quot;, &quot;r&quot;, stdin);
//	freopen(&quot;lcc.out&quot;, &quot;w&quot;, stdout);
	int x, y, z;
	Pre();
	In(m);
	for(int i = 1 ; i &lt;= m ; ++ i) {
		In(z), In(x), In(y);
		x ^= ans, y ^= ans;
	//	printf(&quot;x = %d y = %d\n&quot;, x, y);
		if(z==0) printf(&quot;%d\n&quot;, Work(x, y));
		else Change(x, y);
	}
//	while(1);
	return 0;
}
<pre><h2>Problem3790</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int NN=101111;
char s[NN],ss[NN];
int n,nex[NN];
struct seg
{
	int l,r;
	seg(int a=0,int b=0) {l=a;r=b;}
	friend bool operator &lt;(seg a,seg b)
	{
		if (a.l==b.l) return a.r&gt;b.r;
		return a.l&lt;b.l;
	}
} q[NN];
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	while (scanf(&quot;%s\n&quot;,s+1)!=EOF)
	{
		n=strlen(s+1);
		int t=0,i;
		ss[0]='@';
		for (i=1;i&lt;=n;i++)
		{
			ss[++t]='#';
			ss[++t]=s[i];
		}
		ss[++t]='#';
		ss[++t]='$';
		int id=0,R=0;
		for (i=1;i&lt;t;i++)
		{
			if (R&gt;i) nex[i]=min(nex[id*2-i],R-i);
			else nex[i]=1;
			while (ss[i-nex[i]]==ss[i+nex[i]]) nex[i]++;
			if (i+nex[i]&gt;R) R=i+nex[i],id=i;
		}
		int cnt=0;
		for (i=1;i&lt;t;i++)
			if (i&amp;1)
			{
				if (nex[i]==1) continue;
				int t1=nex[i]/2,t2=i/2;
				q[++cnt]=seg(t2-t1+1,t2+t1);
			}
			else
			{
				int t1=nex[i]/2,t2=i/2;
				q[++cnt]=seg(t2-t1+1,t2+t1-1);
			}
		sort(q+1,q+cnt+1);
		t=1;
		int num=0;
		while (t&lt;=cnt)
		{
			int k=t+1;
			while (q[k].r&lt;=q[t].r&amp;&amp;k&lt;=cnt) k++;
			k--;
			q[++num]=q[t];
			t=k+1;
		}
		cnt=num;
		t=1;
		int ans=0;
		while (t&lt;=cnt)
		{
			int k=t;
			while (q[k].l&lt;=q[t].r+1&amp;&amp;k&lt;=cnt) k++;
			k--;
			ans++;
			if (k==t) break;
			else t=k;
		}
		printf(&quot;%d\n&quot;,ans-1);
	}
	return 0;
}<pre><h2>Problem3809</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=100111,MM=1000111,AA=355;
int a[NN],num[NN],belong[NN],kuai[AA],st[AA],ed[AA],ans[MM];
int n,m,cnt,blo;
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);ln;}
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar());
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
}
struct query
{
	int l,r,a,b,id;
	inline void in(int i) {id=i;read(l),read(r),read(a),read(b);} 
	friend bool operator &lt;(const query &amp;a,const query &amp;b)
	{
		if (belong[a.l]!=belong[b.l]) return belong[a.l]&lt;belong[b.l];
		return a.r&lt;b.r;
	}
} qry[MM];
inline void add(int x)
{
	if (++num[x]==1)
		kuai[belong[x]]++;
}
inline void del(int x)
{
	if (--num[x]==0)
		kuai[belong[x]]--;
}
inline int work(int l,int r)
{
	int L=belong[l],R=belong[r],res=0,i;
	if (L==R)
	{
		for (i=l;i&lt;=r;i++)
			if (num[i]) res++;
		return res;
	}
	for (i=L+1;i&lt;R;i++) res+=kuai[i];
	for (i=ed[L];i&gt;=l;i--)
		if (num[i]) res++;
	for (i=st[R];i&lt;=r;i++)
		if (num[i]) res++;
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	int i,j;
	for (i=1;i&lt;=n;i++) read(a[i]);
	for (i=1;i&lt;=m;i++) qry[i].in(i);
	blo=(int)sqrt(n)+1;
	for (i=1;i&lt;=n;i+=blo)
	{
		cnt++;
		int r=(i+blo-1&gt;n)?n:i+blo-1;
		st[cnt]=i,ed[cnt]=r;
		for (j=i;j&lt;=r;j++) belong[j]=cnt;
	}
	//printf(&quot;belong &quot;);out(belong,1,n);ln;
	sort(qry+1,qry+m+1);
	int L=1,R=1;
	add(a[1]);
	for (i=1;i&lt;=m;i++)
	{
		//printf(&quot;\n-------------------------------------------------------------------\n&quot;);
		int l=qry[i].l,r=qry[i].r;
		if (l&lt;L) for (j=l;j&lt;L;j++) add(a[j]);
		if (r&gt;R) for (j=r;j&gt;R;j--) add(a[j]);
		if (l&gt;L) for (j=L;j&lt;l;j++) del(a[j]);
		if (r&lt;R) for (j=R;j&gt;r;j--) del(a[j]);
		ans[qry[i].id]=work(qry[i].a,qry[i].b);
		L=l,R=r;
	}
	for (i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem3813</h2><pre>#include&lt;cstdio&gt;
using namespace std;
#define mo 19961993
#define lc(v) ((v)&lt;&lt;1)
#define rc(v) ((v)&lt;&lt;1|1)
typedef long long LL;
#define ln printf(&quot;\n&quot;)
const int NN=101111;
int n,m,cnt,ww,ee;
int pr[77];
LL f[77];
bool vt[330003];
struct ppt
{
	LL w,S;
	void make(int x)
	{
		w=x,S=0;
		for (int i=1;i&lt;=60;i++)
			if (x%pr[i]==0) S|=(1ll&lt;&lt;(i-1));
	}
} t[NN*4],ttt;
LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
void prepare()
{
	vt[1]=true;
	for (int i=2;i&lt;=300;i++)
	{
		if (!vt[i]) pr[++cnt]=i;
		for (int j=1;j&lt;=cnt;j++)
		{
			int x=i*pr[j];
			if (x&gt;300) break;
			vt[x]=true;
			if (i%pr[j]==0) break;
		}
	}
	for (int i=1;i&lt;=60;i++)
		f[i]=(pr[i]-1)*ksm(pr[i],mo-2,mo)%mo;
}
void update(int v)
{
	int x=lc(v),y=rc(v);
	t[v].w=t[x].w*t[y].w%mo;
	t[v].S=t[x].S|t[y].S;
}
void build(int v,int l,int r)
{
	if (r-l==1)
	{
		t[v].make(3);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(lc(v),l,mid);
	build(rc(v),mid,r);
	update(v);
}
void find(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		ttt.w=ttt.w*t[v].w%mo;
		ttt.S|=t[v].S;
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) find(lc(v),l,mid);
	if (ee&gt;mid) find(rc(v),mid,r);
}
void change(int v,int l,int r,int i,int x)
{
	if (r-l==1)
	{
		t[v].make(x);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid) change(lc(v),l,mid,i,x);
	else change(rc(v),mid,r,i,x);
	update(v);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	prepare();
	scanf(&quot;%d&quot;,&amp;m);
	n=100000;
	build(1,1,n+1);
	int i,x,y;
	for (;m;m--)
	{
		//printf(&quot;\n---------------------------------------------------------------------------------\n&quot;);
		scanf(&quot;%d&quot;,&amp;x);
		if (x==0)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			ww=x,ee=y+1;
			ttt.w=1,ttt.S=0;
			find(1,1,n+1);
			LL ans=ttt.w;
			//printf(&quot;%I64d\n&quot;,ans);
			for (i=1;i&lt;=60;i++)
				if (ttt.S&amp;(1ll&lt;&lt;(i-1)))
				{
					ans=ans*f[i]%mo;
					//printf(&quot;%d &quot;,pr[i]);
				}
			//ln;
			printf(&quot;%lld\n&quot;,ans);
		}
		else
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			change(1,1,n+1,x,y);
		}
	}
	return 0;
}<pre><h2>Problem3823</h2><pre>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
LL n,p;
LL pw(LL x,LL k){
    LL ans=1;
    for(;k;k&gt;&gt;=1){
        if(k&amp;1)ans=(ans*x)%p;
        x=(x*x)%p;
    }return ans;
}
LL f,ans;
int inv[int(2e7+5)];
int cnt=0;
int main(){//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
    cin&gt;&gt;n&gt;&gt;p;
    ans=f=pw(2,n);cnt=0;inv[1]=1;
    for(int i=2;i&lt;=min(2*n,p-1);i++)inv[i]=(LL)(p-p/i)*inv[p%i]%p;
	//for (int i=1;i&lt;=100;i++) printf(&quot;%d\n&quot;,inv[i]);
    for(int i=1;i&lt;=n;i++){
		int tmp=n-i+1;
		while(tmp%p==0)cnt++,tmp/=p;
		f=(LL)f*tmp%p;
		tmp=2*i;
		while(tmp%p==0)cnt--,tmp/=p;
		f=(LL)f*inv[tmp%p]%p;
        ans^=cnt?0:f;
    }cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}<pre><h2>Problem3823</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define LL long long
int n,mo,pr[3000000],inv[20001111];
bool is[20001111];
LL ksm(LL a,LL b)
{
    LL res=1;
    for (a%=mo;b&gt;0;b&gt;&gt;=1,a=a*a%mo)
        if (b&amp;1) res=res*a%mo;
    return res;
}
void prepare()
{
    int i,j;
    memset(is,1,sizeof(is));
    is[1]=false;
    inv[1]=1;
    for (i=2;i&lt;=n;i++)
    {
        if (is[i])
        {
            pr[++pr[0]]=i;
            inv[i]=ksm(i,mo-2)%mo;
        }
        for (j=1;j&lt;=pr[0];j++)
        {
            LL x=(LL)i*(LL)pr[j];
            if (x&gt;n) break;
            is[x]=false;
            inv[x]=(LL)inv[i]*(LL)inv[pr[j]]%mo;
            if (i%pr[j]==0) break;
        }
    }
    //for (i=1;i&lt;=100;i++) printf(&quot;%lld\n&quot;,inv[i]);
    //for (i=1;i&lt;=100;i++) printf(&quot;%lld &quot;,pr[i]);printf(&quot;\n&quot;);
}
int main()
{
  //  freopen(&quot;cube4.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	//freopen(&quot;3823.in&quot;,&quot;r&quot;,stdin);freopen(&quot;3823.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d%d&quot;,&amp;n,&amp;mo);
    prepare();
    LL ans,now;
    LL cnt,tmp,i;
    ans=now=ksm(2,n);
    //printf(&quot;------\n&quot;);
    for (cnt=0,i=1;i&lt;=n;i++)
    {
        tmp=n-i+1;
        for (;tmp%mo==0;tmp/=mo) cnt++;
        now=(LL)now*(LL)tmp%mo;
        tmp=i;
        for (;tmp%mo==0;tmp/=mo) cnt--;
        now=(LL)now*(LL)inv[tmp%mo]%mo*(LL)inv[2]%mo;
        if (cnt&gt;0) continue;
        //printf(&quot;now=%lld\n&quot;,now);
        ans^=now;
    }
    printf(&quot;%lld\n&quot;,ans);
    return 0;
}<pre><h2>Problem3823</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define LL long long
int n,mo,pr[3000000],inv[20001111];
bool is[20001111];
LL ksm(LL a,LL b)
{
    LL res=1;
    for (a%=mo;b&gt;0;b&gt;&gt;=1,a=a*a%mo)
        if (b&amp;1) res=res*a%mo;
    return res;
}
void prepare()
{
    int i,j;
    memset(is,1,sizeof(is));
    is[1]=false;
    inv[1]=1;
    for (i=2;i&lt;=n;i++)
    {
        if (is[i])
        {
            pr[++pr[0]]=i;
            inv[i]=ksm(i,mo-2)%mo;
        }
        for (j=1;j&lt;=pr[0];j++)
        {
            LL x=(LL)i*(LL)pr[j];
            if (x&gt;n) break;
            is[x]=false;
            inv[x]=(LL)inv[i]*(LL)inv[pr[j]]%mo;
            if (i%pr[j]==0) break;
        }
    }
}
int main()
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d%d&quot;,&amp;n,&amp;mo);
    prepare();
    LL ans,now;
    LL cnt,tmp,i;
    ans=now=ksm(2,n);
    for (cnt=0,i=1;i&lt;=n;i++)
    {
        tmp=n-i+1;
        for (;tmp%mo==0;tmp/=mo) cnt++;
        now=(LL)now*(LL)tmp%mo;
        tmp=i;
        for (;tmp%mo==0;tmp/=mo) cnt--;
        now=(LL)now*inv[tmp%mo]%mo*inv[2]%mo;
        if (cnt&gt;0) continue;
        ans^=now;
    }
    printf(&quot;%lld\n&quot;,ans);
    return 0;
}<pre><h2>Problem3832</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
using namespace std;
#define pb push_back
#define inf 999999999
#define ln printf(&quot;\n&quot;)
const int NN=501111,MM=1001111;
int n,m,du[NN],f[NN],g[NN],b[NN];
vector&lt;int&gt; go1[NN],go2[NN];
multiset&lt;int&gt; S;
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);ln;}
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9')
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar();
}
void tuopu()
{
	int top=0,cnt=0;
	static int sta[NN];
	for (int i=1;i&lt;=n;i++)
		if (du[i]==0) sta[++top]=i;
	while (top)
	{
		int x=sta[top--];
		b[++cnt]=x;
		for (int p=0;p&lt;go1[x].size();p++)
		{
			int y=go1[x][p];
			if (--du[y]==0) sta[++top]=y;
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	int i,x,y;
	for (i=1;i&lt;=m;i++)
	{
		read(x),read(y);
		du[y]++;
		go1[x].pb(y),go2[y].pb(x);
	}
	tuopu();
	for (i=1;i&lt;=n;i++)
	{
		x=b[i];
		for (int p=0;p&lt;go2[x].size();p++)
		{
			int y=go2[x][p];
			if (f[y]+1&gt;f[x]) f[x]=f[y]+1;
		}
	}
	for (i=n;i;i--)
	{
		x=b[i];
		for (int p=0;p&lt;go1[x].size();p++)
		{
			int y=go1[x][p];
			if (g[y]+1&gt;g[x]) g[x]=g[y]+1;
		}
	}
	//printf(&quot;f &quot;);out(f,1,n);printf(&quot;g &quot;);out(g,1,n);ln;
	for (i=1;i&lt;=n;i++) S.insert(g[i]);
	S.insert(0);
	int ans=inf,the=0;
	for (i=1;i&lt;=n;i++)
	{
		x=b[i];
		for (int p=0;p&lt;go2[x].size();p++)
		{
			int y=go2[x][p];
			S.erase(S.find(f[y]+g[x]+1));
		}
		S.erase(S.find(g[x]));
		int tmp=*(--S.end());
		if (tmp&lt;ans) ans=tmp,the=x;
		for (int p=0;p&lt;go1[x].size();p++)
		{
			int y=go1[x][p];
			S.insert(f[x]+g[y]+1);
		}
		S.insert(f[x]);
	}
	printf(&quot;%d %d\n&quot;,the,ans);
	return 0;
}<pre><h2>Problem3832</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
using namespace std;
#define pb push_back
#define inf 999999999
const int NN=501111,MM=1001111;
int n,m,du[NN],f[NN],g[NN],b[NN];
vector&lt;int&gt; go1[NN],go2[NN];
multiset&lt;int&gt; S;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9')
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar();
}
void tuopu()
{
	int top=0,cnt=0;
	static int sta[NN];
	for (int i=1;i&lt;=n;i++)
		if (du[i]==0) sta[++top]=i;
	while (top)
	{
		int x=sta[top--];
		b[++cnt]=x;
		for (int p=0;p&lt;go1[x].size();p++)
		{
			int y=go1[x][p];
			if (--du[y]==0) sta[++top]=y;
		}
	}
}
int main()
{
	read(n),read(m);
	int i,x,y;
	for (i=1;i&lt;=m;i++)
	{
		read(x),read(y);
		du[y]++;
		go1[x].pb(y),go2[y].pb(x);
	}
	tuopu();
	for (i=1;i&lt;=n;i++)
	{
		x=b[i];
		for (int p=0;p&lt;go2[x].size();p++)
		{
			int y=go2[x][p];
			if (f[y]+1&gt;f[x]) f[x]=f[y]+1;
		}
	}
	for (i=n;i;i--)
	{
		x=b[i];
		for (int p=0;p&lt;go1[x].size();p++)
		{
			int y=go1[x][p];
			if (g[y]+1&gt;g[x]) g[x]=g[y]+1;
		}
	}
	for (i=1;i&lt;=n;i++) S.insert(g[i]);
	S.insert(0);
	int ans=inf,the=0;
	for (i=1;i&lt;=n;i++)
	{
		x=b[i];
		for (int p=0;p&lt;go2[x].size();p++)
		{
			int y=go2[x][p];
			S.erase(S.find(f[y]+g[x]+1));
		}
		S.erase(S.find(g[x]));
		int tmp=*(--S.end());
		if (tmp&lt;ans) ans=tmp,the=x;
		for (int p=0;p&lt;go1[x].size();p++)
		{
			int y=go1[x][p];
			S.insert(f[x]+g[y]+1);
		}
		S.insert(f[x]);
	}
	printf(&quot;%d %d\n&quot;,the,ans);
	return 0;
}<pre><h2>Problem3867</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define lc (v&lt;&lt;1)
#define rc (v&lt;&lt;1|1)
const int NN=101111;
int tes,n,m,ww,ee,a[NN];
struct segnode
{
	int tmax,tag;
	bool same;
	void out()
	{
		printf(&quot;tmax=%d tag=%d  same=%s\n&quot;,tmax,tag,same?&quot;true&quot;:&quot;false&quot;);
	}
	inline void set(int x)
	{
		//printf(&quot;set %d\n&quot;,x);
		tmax=tag=x;
		same=true;
	}
} t[NN*4];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
inline void update(int v)
{
	int x=lc,y=rc;
	t[v].tmax=max(t[x].tmax,t[y].tmax);
	t[v].same=(t[x].same&amp;&amp;t[y].same&amp;&amp;t[x].tmax==t[y].tmax);
}
void build(int v,int l,int r)
{
	t[v].tag=-1;
	if (r-l==1)
	{
		t[v].set(a[l]);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(lc,l,mid);
	build(rc,mid,r);
	update(v);
}
inline void pushdown(int v)
{
	if (t[v].tag&gt;=0)
	{
		t[lc].set(t[v].tag);
		t[rc].set(t[v].tag);
		t[v].tag=-1;
	}
}
void change1(int v,int l,int r,int x)
{
	//printf(&quot;change1 %d %d %d %d\n&quot;,v,l,r,x);
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		//printf(&quot;t[%d].set(%d)\n&quot;,v,x);
		t[v].set(x);
		//t[3].out();
		return;
	}
	t[v].same=false;
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) change1(lc,l,mid,x);
	if (ee&gt;mid) change1(rc,mid,r,x);
	update(v);
}
int gcd(int x,int y) {return !y?x:gcd(y,x%y);}
void change2(int v,int l,int r,int x)
{
	//printf(&quot;change2 %d %d %d %d  %d %d\n&quot;,v,l,r,x,ww,ee);
	//printf(&quot;%d\n&quot;,t[v].tmax);
	if (t[v].tmax&lt;=x) return;
	if (ww&lt;=l&amp;&amp;r&lt;=ee&amp;&amp;t[v].same)
	{
		t[v].set(gcd(t[v].tmax,x));
		return;
	}
	t[v].same=false;
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) change2(lc,l,mid,x);
	if (ee&gt;mid) change2(rc,mid,r,x);
	update(v);
}
void find(int v,int l,int r)
{
	if (r-l==1)
	{
		a[l]=t[v].tmax;
		return;
	}
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	find(lc,l,mid);
	find(rc,mid,r);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (read(tes);tes;tes--)
	{
		read(n);
		int i,kind,l,r,x;
		for (i=1;i&lt;=n;i++) read(a[i]);
		build(1,1,n+1);
		for (read(m);m;m--)
		{
			//printf(&quot;\n--------------------------------------------------------------\n&quot;);
			read(kind),read(l),read(r),read(x);
			ww=l,ee=r+1;
			if (kind==1) change1(1,1,n+1,x);
			else change2(1,1,n+1,x);
		}
		find(1,1,n+1);
		for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,a[i]);
		putchar('\n');
	}
	return 0;
}<pre><h2>Problem3867</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define lc (v&lt;&lt;1)
#define rc (v&lt;&lt;1|1)
const int NN=100005;
int tes,n,m,ww,ee,a[NN];
struct segnode
{
	int tmax,tag;
	bool same;
	inline void set(int x)
	{
		tmax=tag=x;
		same=true;
	}
} t[NN*4];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
inline void update(int v)
{
	int x=lc,y=rc;
	t[v].tmax=max(t[x].tmax,t[y].tmax);
	t[v].same=(t[x].same&amp;&amp;t[y].same&amp;&amp;t[x].tmax==t[y].tmax);
}
void build(int v,int l,int r)
{
	t[v].tag=-1;
	if (r-l==1)
	{
		t[v].set(a[l]);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(lc,l,mid);
	build(rc,mid,r);
	update(v);
}
inline void pushdown(int v)
{
	if (t[v].tag&gt;=0)
	{
		t[lc].set(t[v].tag);
		t[rc].set(t[v].tag);
		t[v].tag=-1;
	}
}
void change1(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		t[v].set(x);
		return;
	}
	t[v].same=false;
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) change1(lc,l,mid,x);
	if (ee&gt;mid) change1(rc,mid,r,x);
	update(v);
}
int gcd(int x,int y) {return !y?x:gcd(y,x%y);}
void change2(int v,int l,int r,int x)
{
	if (t[v].tmax&lt;=x) return;
	if (ww&lt;=l&amp;&amp;r&lt;=ee&amp;&amp;t[v].same)
	{
		t[v].set(gcd(t[v].tmax,x));
		return;
	}
	t[v].same=false;
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) change2(lc,l,mid,x);
	if (ee&gt;mid) change2(rc,mid,r,x);
	update(v);
}
void find(int v,int l,int r)
{
	if (r-l==1)
	{
		a[l]=t[v].tmax;
		return;
	}
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	find(lc,l,mid);
	find(rc,mid,r);
}
int main()
{
	for (read(tes);tes;tes--)
	{
		read(n);
		int i,kind,l,r,x;
		for (i=1;i&lt;=n;i++) read(a[i]);
		build(1,1,n+1);
		for (read(m);m;m--)
		{
			read(kind),read(l),read(r),read(x);
			ww=l,ee=r+1;
			if (kind==1) change1(1,1,n+1,x);
			else change2(1,1,n+1,x);
		}
		find(1,1,n+1);
		for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,a[i]);
		putchar('\n');
	}
	return 0;
}<pre><h2>Problem3867</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define lc (v&lt;&lt;1)
#define rc (v&lt;&lt;1|1)
const int NN=100005;
int tes,n,m,ww,ee,a[NN];
struct segnode
{
	int tmax,tag;
	bool same;
	inline void set(int x)
	{
		tmax=tag=x;
		same=true;
	}
} t[NN*3];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
inline void update(int v)
{
	int x=lc,y=rc;
	t[v].tmax=max(t[x].tmax,t[y].tmax);
	t[v].same=(t[x].same&amp;&amp;t[y].same&amp;&amp;t[x].tmax==t[y].tmax);
}
void build(int v,int l,int r)
{
	t[v].tag=-1;
	if (r-l==1)
	{
		t[v].set(a[l]);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(lc,l,mid);
	build(rc,mid,r);
	update(v);
}
inline void pushdown(int v)
{
	if (t[v].tag&gt;=0)
	{
		t[lc].set(t[v].tag);
		t[rc].set(t[v].tag);
		t[v].tag=-1;
	}
}
void change1(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		t[v].set(x);
		return;
	}
	t[v].same=false;
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) change1(lc,l,mid,x);
	if (ee&gt;mid) change1(rc,mid,r,x);
	update(v);
}
int gcd(int x,int y) {return !y?x:gcd(y,x%y);}
void change2(int v,int l,int r,int x)
{
	if (t[v].tmax&lt;=x) return;
	if (ww&lt;=l&amp;&amp;r&lt;=ee&amp;&amp;t[v].same)
	{
		t[v].set(gcd(t[v].tmax,x));
		return;
	}
	t[v].same=false;
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) change2(lc,l,mid,x);
	if (ee&gt;mid) change2(rc,mid,r,x);
	update(v);
}
void find(int v,int l,int r)
{
	if (r-l==1)
	{
		a[l]=t[v].tmax;
		return;
	}
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	find(lc,l,mid);
	find(rc,mid,r);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (read(tes);tes;tes--)
	{
		read(n);
		int i,kind,l,r,x;
		for (i=1;i&lt;=n;i++) read(a[i]);
		build(1,1,n+1);
		for (read(m);m;m--)
		{
			read(kind),read(l),read(r),read(x);
			ww=l,ee=r+1;
			if (kind==1) change1(1,1,n+1,x);
			else change2(1,1,n+1,x);
		}
		find(1,1,n+1);
		for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,a[i]);
		putchar('\n');
	}
	return 0;
}<pre><h2>Problem3875</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
const int NN=2001111,MM=2001111;
int o[NN],aa[MM][2],que[NN+100];
int head,tail,n,m,tot;
LL f[NN],g[NN],S[NN],K[NN],dec[NN];
bool dl[NN];
struct edge
{
	int u,v;
	edge(int a=0,int b=0) {u=a;v=b;}
} e[MM];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar()) x=x*10+ch-'0';
	if (f) x=-x;
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void spfa()
{
	while (head!=tail)
	{
		head++;if (head==NN+1) head=1;
		int x=que[head];
		dl[x]=false;
		//printf(&quot;\n-------------------------------------------------------------------\n&quot;);
		//printf(&quot;x=%d f[x]=%lld g[x]=%lld dec[x]=%lld\n\n&quot;,x,f[x],g[x],dec[x]);
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			g[y]-=dec[x];
			if (f[y]&gt;g[y])
			{
				if (dl[y]) dec[y]+=f[y]-g[y];
				else
				{
					tail++;if (tail==NN+1) tail=1;
					dl[y]=true;
					que[tail]=y;
					dec[y]=f[y]-g[y];
				}
				f[y]=g[y];
			}
			//printf(&quot;=========== y=%d ===========\n&quot;,y);printf(&quot;f[y]=%lld g[y]=%lld dec[y]=%lld\n&quot;,f[y],g[y],dec[y]);
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);
	int i,j,x,y;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%lld%lld%d&quot;,&amp;S[i],&amp;K[i],&amp;x);
		for (j=1;j&lt;=x;j++)
		{
			read(y);
			e[++m]=edge(i,y);
			addedge(i,y);
		}
	}
	head=0,tail=n;
	for (i=1;i&lt;=n;i++)
	{
		que[i]=i;
		dl[i]=true;
		f[i]=K[i];
		g[i]=S[i];
		for (int p=o[i];p;p=aa[p][0])
		{
			int y=aa[p][1];
			g[i]+=K[y];
		}
	}
	memset(o,0,sizeof(o));
	for (i=1;i&lt;=m;i++) addedge(e[i].v,e[i].u);
	spfa();
	printf(&quot;%lld\n&quot;,f[1]);
	return 0;
}<pre><h2>Problem3875</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
const int NN=201111,MM=2001111;
int o[NN],aa[MM][2],que[NN+100];
int head,tail,n,m,tot;
LL f[NN],g[NN],S[NN],K[NN],dec[NN];
bool dl[NN];
struct edge
{
	int u,v;
	edge(int a=0,int b=0) {u=a;v=b;}
} e[MM];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar()) x=x*10+ch-'0';
	if (f) x=-x;
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void spfa()
{
	while (head!=tail)
	{
		head++;if (head==NN+1) head=1;
		int x=que[head];
		dl[x]=false;
		//printf(&quot;\n-------------------------------------------------------------------\n&quot;);
		//printf(&quot;x=%d f[x]=%lld g[x]=%lld dec[x]=%lld\n\n&quot;,x,f[x],g[x],dec[x]);
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			g[y]-=dec[x];
			if (f[y]&gt;g[y])
			{
				if (dl[y]) dec[y]+=f[y]-g[y];
				else
				{
					tail++;if (tail==NN+1) tail=1;
					dl[y]=true;
					que[tail]=y;
					dec[y]=f[y]-g[y];
				}
				f[y]=g[y];
			}
			//printf(&quot;=========== y=%d ===========\n&quot;,y);printf(&quot;f[y]=%lld g[y]=%lld dec[y]=%lld\n&quot;,f[y],g[y],dec[y]);
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);
	int i,j,x,y;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%lld%lld%d&quot;,&amp;S[i],&amp;K[i],&amp;x);
		for (j=1;j&lt;=x;j++)
		{
			read(y);
			e[++m]=edge(i,y);
			addedge(i,y);
		}
	}
	head=0,tail=n;
	for (i=1;i&lt;=n;i++)
	{
		que[i]=i;
		dl[i]=true;
		f[i]=K[i];
		g[i]=S[i];
		for (int p=o[i];p;p=aa[p][0])
		{
			int y=aa[p][1];
			g[i]+=K[y];
		}
	}
	memset(o,0,sizeof(o));
	for (i=1;i&lt;=m;i++) addedge(e[i].v,e[i].u);
	spfa();
	printf(&quot;%lld\n&quot;,f[1]);
	return 0;
}<pre><h2>Problem3875</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
const int NN=201111,MM=1001111;
int o[NN],aa[MM][2],que[NN+100];
int head,tail,n,m,tot;
LL f[NN],g[NN],S[NN],K[NN],dec[NN];
bool dl[NN];
struct edge
{
	int u,v;
	edge(int a=0,int b=0) {u=a;v=b;}
} e[MM];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar()) x=x*10+ch-'0';
	if (f) x=-x;
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void spfa()
{
	while (head!=tail)
	{
		head++;if (head==NN+1) head=1;
		int x=que[head];
		dl[x]=false;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			g[y]-=dec[x];
			if (f[y]&gt;g[y])
			{
				if (dl[y]) dec[y]+=f[y]-g[y];
				else
				{
					tail++;if (tail==NN+1) tail=1;
					dl[y]=true;
					que[tail]=y;
					dec[y]=f[y]-g[y];
				}
				f[y]=g[y];
			}
		}
	}
}
int main()
{
	read(n);
	int i,j,x,y;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%lld%lld%d&quot;,&amp;S[i],&amp;K[i],&amp;x);
		for (j=1;j&lt;=x;j++)
		{
			read(y);
			e[++m]=edge(i,y);
			addedge(i,y);
		}
	}
	head=0,tail=n;
	for (i=1;i&lt;=n;i++)
	{
		que[i]=i;
		dl[i]=true;
		f[i]=K[i];
		g[i]=S[i];
		for (int p=o[i];p;p=aa[p][0])
		{
			int y=aa[p][1];
			g[i]+=K[y];
		}
	}
	memset(o,0,sizeof(o));tot=0;
	for (i=1;i&lt;=m;i++) addedge(e[i].v,e[i].u);
	spfa();
	printf(&quot;%lld\n&quot;,f[1]);
	return 0;
}<pre><h2>Problem3876</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 999999999
#define mii(a,b) ((a)&lt;(b)?(a):(b))
const int NN=311;
int aa[71111][4],o[NN],dist[NN],q[101111],pre[NN];
int n,S,T,ans,tot=1;
bool dl[NN];
bool spfa()
{
	int head=0,tail=1,p,x,y;
	memset(dist,60,sizeof(dist));
	dist[S]=0;
	memset(dl,0,sizeof(dl));
	dl[S]=true;
	q[1]=S;
	while (head&lt;tail)
	{
		x=q[++head];
		dl[x]=false;
		for (p=o[x];p;p=aa[p][0])
		{
			y=aa[p][1];
			if (aa[p][2]&amp;&amp;dist[y]&gt;dist[x]+aa[p][3])
			{
				pre[y]=p;
				dist[y]=dist[x]+aa[p][3];
				if (!dl[y]) dl[y]=true,q[++tail]=y;
			}
		}
	}
	return dist[T]&lt;dist[0];
}
void doit()
{
	int p,ff=inf;
	for (p=pre[T];p;p=pre[aa[p^1][1]]) ff=mii(ff,aa[p][2]);
	for (p=pre[T];p;p=pre[aa[p^1][1]])
	{
		ans+=ff*aa[p][3];
		aa[p][2]-=ff,aa[p^1][2]+=ff;
	}
}
inline void addedge(int p,int q,int v,int c)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][3]=c;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline void add(int p,int q,int v,int c)
{
	addedge(p,q,v,c);
	addedge(q,p,0,-c);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	S=n+1,T=S+1;
	int i,j,x,y,num;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;j);
		num=0;
		for (;j;j--)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			ans+=y;
			num++;
			add(i,x,inf,y);
			add(S,x,1,0);
		}
		add(i,T,num,0);
		if (i!=1) add(i,1,inf,0);
	}
	while (spfa()) doit();
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3876</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;

#define INF 0x7fffffff
#define maxn 310
#define maxm 5010

using namespace std;

struct edge{int x,y,w,c,last;}a[maxm&lt;&lt;3];

int n,tot=1,dis[maxn],b[maxn],pre[maxn],su,sv,ans;
bool flag[maxn];

void add(int x,int y,int w,int c)
{
	a[++tot]=(edge){x,y,w,c,b[x]};
	b[x]=tot;
}

void Add(int x,int y,int w,int c)
{
	add(x,y,w,c);
	add(y,x,0,-c);
}

#define v a[i].y
bool spfa()
{
	queue&lt;int&gt; q;
	q.push(su);
	memset(dis,0x3f,sizeof(dis));
	dis[su]=0;
	while(!q.empty()){
		int x=q.front();q.pop();flag[x]=0;
		for(int i=b[x];i;i=a[i].last){
			if(dis[v]&gt;dis[x]+a[i].c&amp;&amp;a[i].w){
				dis[v]=dis[x]+a[i].c;
				pre[v]=i;
				if(!flag[v]){
					flag[v]=1;
					q.push(v);
				}
			}
		}
	}
	if(dis[sv]==dis[n+2]) return false;
	int mn=INF,i=pre[sv];
	for(;a[i].x!=su;i=pre[a[i].x]) mn=min(mn,a[i].w);mn=min(mn,a[i].w);
	i=pre[sv];
	for(;a[i].x!=su;i=pre[a[i].x]) a[i].w-=mn,a[i^1].w+=mn;
	a[i].w-=mn,a[i^1].w+=mn;
	ans+=dis[sv]*mn;
	return true;
}

int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	sv=n+1;
	for(int i=1;i&lt;=n;i++){
		if(i!=1) Add(i,1,INF,0);
		int s,y,w;
		scanf(&quot;%d&quot;,&amp;s);
		Add(i,sv,s,0);
		for(int j=1;j&lt;=s;j++){
			scanf(&quot;%d%d&quot;,&amp;y,&amp;w);
			Add(i,y,INF,w);
			Add(su,y,1,w);
		}
	}
	while(spfa());
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem3881</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define M 2002002
using namespace std;
int n,m,limit;
char s[M];
namespace BIT{
    int c[M];
    void Update(int x,int y)
    {
        for(;x&lt;=limit;x+=x&amp;-x)
            c[x]+=y;
    }
    int Get_Ans(int x)
    {
        int re=0;
        for(;x;x-=x&amp;-x)
            re+=c[x];
        return re;
    }
}
namespace Fail_Tree{
    struct abcd{
        int to,next;
    }table[M];
    int head[M],tot;
    int fa[M],dpt[M],pos[M],into[M],ed[M];
    namespace ZKW_Segtree{
        int Q,tree[8389000];
        bool Compare(int x,int y)
        {
            if(!x) return false;
            if(!y) return true;
            return dpt[x]&lt;dpt[y];
        }
        void Build_Tree()
        {
            int i;
            for(i=Q-1;i;i--)
                tree[i]=min(tree[i&lt;&lt;1],tree[i&lt;&lt;1|1],Compare);
        }
        int Query(int x,int y)
        {
            int re=0;
            for(x+=Q-1,y+=Q+1;x^y^1;x&gt;&gt;=1,y&gt;&gt;=1)
            {
                if(~x&amp;1) re=min(re,tree[x^1],Compare);
                if( y&amp;1) re=min(re,tree[y^1],Compare);
            }
            return re;
        }
    }
    void DFS(int x,int array[])
    {
        static int cnt1,cnt2;
        int i;
        dpt[x]=dpt[fa[x]]+1;
        pos[x]=++cnt1;
        array[into[x]=++cnt2]=x;
        for(i=head[x];i;i=table[i].next)
        {
            fa[table[i].to]=x;
            DFS(table[i].to,array);
            array[++cnt2]=x;
        }
        ed[x]=cnt1;
    }
    void Add(int x,int y)
    {
        table[++tot].to=y;
        table[tot].next=head[x];
        head[x]=tot;
    }
    void Build_Tree()
    {
        using namespace ZKW_Segtree;
        for(Q=1;Q&lt;=limit+limit;Q&lt;&lt;=1);
        DFS(1,tree+Q);
        ZKW_Segtree::Build_Tree();
    }
    int LCA(int x,int y)
    {
        x=into[x];y=into[y];
        if(x&gt;y) swap(x,y);
        return ZKW_Segtree::Query(x,y);
    }
}
namespace Aho_Corasick_Automaton{
    struct Trie{
        Trie *son[26],*fail;
    }*root,mempool[M],*C=mempool;
    Trie *pos[100100];
    void Insert(Trie *&amp;p,char *s,int id)
    {
        if(!p) p=++C;
        if(!*s)
        {
            pos[id]=p;
            return ;
        }
        Insert(p-&gt;son[*s-'a'],s+1,id);
    }
    void Build_Tree()
    {
        static Trie *q[M];
        int i,r=0,h=0;
        for(i=0;i&lt;26;i++)
        {
            if(root-&gt;son[i])
                (q[++r]=root-&gt;son[i])-&gt;fail=root;
            else
                root-&gt;son[i]=root;
        }
        while(r!=h)
        {
            Trie *p=q[++h];
            for(i=0;i&lt;26;i++)
            {
                if(p-&gt;son[i])
                    (q[++r]=p-&gt;son[i])-&gt;fail=p-&gt;fail-&gt;son[i];
                else
                    p-&gt;son[i]=p-&gt;fail-&gt;son[i];
            }
        }
        for(i=2;i&lt;=C-mempool;i++)
            Fail_Tree::Add(mempool[i].fail-mempool,i);
        limit=C-mempool;
    }
    int Get_Points(char *s,int a[])
    {
        int i;
        Trie *p=root;
        for(i=1;s[i];i++)
        {
            p=p-&gt;son[s[i]-'a'];
            a[i]=p-mempool;
        }
        return a[i]=-1,i-1;
    }
}
bool Compare(int x,int y)
{
    using namespace Fail_Tree;
    return pos[x]&lt;pos[y];
}
int main()
{
    int i,j,p,x;
    cin&gt;&gt;n;
    for(i=1;i&lt;=n;i++)
    {
        scanf(&quot;%s&quot;,s+1);
        Aho_Corasick_Automaton::Insert(Aho_Corasick_Automaton::root,s+1,i);
    }
    Aho_Corasick_Automaton::Build_Tree();
    Fail_Tree::Build_Tree();
    static int a[M],top;
    cin&gt;&gt;m;
    using namespace Fail_Tree;
    for(i=1;i&lt;=m;i++)
    {
        scanf(&quot;%d&quot;,&amp;p);
        if(p==1)
        {
            scanf(&quot;%s&quot;,s+1);
            x=Aho_Corasick_Automaton::Get_Points(s,a);
            sort(a+1,a+x+1,Compare);
            for(top=0,j=1;j&lt;=x;j++)
                if(a[j]!=a[j+1])
                    a[++top]=a[j];
            for(j=1;j&lt;=top;j++)
            {
                x=a[j];
                BIT::Update(pos[x],1);
                if(j&gt;1)
                    BIT::Update(pos[LCA(a[j-1],x)],-1);
            }
        }
        else
        {
            scanf(&quot;%d&quot;,&amp;x);
            p=Aho_Corasick_Automaton::pos[x]-Aho_Corasick_Automaton::mempool;
            printf(&quot;%d\n&quot;,BIT::Get_Ans(ed[p])-BIT::Get_Ans(pos[p]-1) );
        }
    }
    return 0;
}<pre><h2>Problem3884</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
int getphi(int x)
{
	int res=1;
	for (int i=2;i*i&lt;=x;i++) if (x%i==0)
	{
		res*=i-1;
		for (x/=i;x%i==0;x/=i) res*=i;
	}
	if (x&gt;1) res*=x-1;
	return res;
}
int ksm(LL a,int b,int c)
{
	LL res=1;
	for (;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
int work(int P)
{
	if (P==1) return 0;
	int t=0,x=P;
	for (;!(x&amp;1);x&gt;&gt;=1) t++;
	int phi=getphi(P);
	int res=work(phi);
	res=(res-t)%phi;
	if (res&lt;0) res+=phi;
	res=ksm(2,res,x)%x;
	return res&lt;&lt;t;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int tes,P;
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d&quot;,&amp;P);
		printf(&quot;%d\n&quot;,work(P));
	}
	return 0;
}<pre><h2>Problem3894</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define mii(a,b) (a&lt;b?a:b)
#define inf 999999999
const int dx[4]={-1,0,0,1},dy[4]={0,1,-1,0};
const int NN=103,AA=30005,MM=141111;
int A[NN][NN],B[NN][NN],C[NN][NN],D[NN][NN],h[NN][NN][3];
int o[AA],cur[AA],q[AA],deep[AA],aa[MM*2][3];
int n,m,tot=1,TTT,S,T;
bool bfs()
{
	int head=0,tail=1;
	q[1]=S;
	memset(deep,0,sizeof(deep));
	deep[S]=1;
	while (head&lt;tail)
	{
		int x=q[++head];
		cur[x]=o[x];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (!deep[y]&amp;&amp;aa[p][2])
				deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[T];
}
int dfs(int v,int ff)
{
	if (v==T) return ff;
	int res=0;
	for (int &amp;p=cur[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,mii(ff,aa[p][2]));
		ff-=tmp,aa[p][2]-=tmp;
		aa[p^1][2]+=tmp,res+=tmp;
		if (!ff) break;
	}
	if (!res) deep[v]=inf;
	return res;
}
void addedge(int p,int q,int v) {tot++;aa[tot][1]=q;aa[tot][2]=v;aa[tot][0]=o[p];o[p]=tot;}
void add(int p,int q,int v)
{
	addedge(p,q,v);addedge(q,p,0);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j,k;
	for (i=1;i&lt;=n;i++) for (j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;A[i][j]);
	for (i=1;i&lt;=n;i++) for (j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;B[i][j]);
	for (i=1;i&lt;=n;i++) for (j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;C[i][j]);
	for (i=1;i&lt;=n;i++) for (j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;D[i][j]);
	for (i=1;i&lt;=n;i++) for (j=1;j&lt;=m;j++)
		for (k=0;k&lt;3;k++) h[i][j][k]=++TTT;
	S=++TTT,T=++TTT;
	int ans=0;
	for (i=1;i&lt;=n;i++) for (j=1;j&lt;=m;j++)
	{
		ans+=A[i][j]+B[i][j]+C[i][j]+D[i][j];
		add(S,h[i][j][0],A[i][j]);
		add(h[i][j][0],T,B[i][j]);
		add(S,h[i][j][1],C[i][j]);
		add(h[i][j][2],T,D[i][j]);
		add(h[i][j][1],h[i][j][0],inf);
		add(h[i][j][0],h[i][j][2],inf);
		for (k=0;k&lt;4;k++)
		{
			int x=i+dx[k],y=j+dy[k];
			if (x&lt;1||x&gt;n||y&lt;1||y&gt;m) continue;
			add(h[i][j][1],h[x][y][0],inf);
			add(h[x][y][0],h[i][j][2],inf);
		}
	}
	while (bfs()) ans-=dfs(S,inf);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem3895</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define M 1010
using namespace std;
char f[60][50500];
//1-先手必胜 0-先手必败
int n;
char Memorial_Search(int a,int b)
{
    if(a==0) return b&amp;1;
    //当不存在大小为1的堆时按照操作数计算必胜或必败
    if(b==1) return Memorial_Search(a+1,0);
    //若操作数为1则此时b部分只有1个石子 划到a中
    if(~f[a][b]) return f[a][b];
    char &amp;re=f[a][b];
    if( a &amp;&amp; !Memorial_Search(a-1,b) )
        return re=true;
    //取走某个大小为1的堆中的石子
    if( a &amp;&amp; b &amp;&amp; !Memorial_Search(a-1,b+1) )
        return re=true;
    //将某个大小为1的堆中的石子与某个大小不为1的堆合并
    if( a&gt;=2 &amp;&amp; !Memorial_Search(a-2,b+2+(b?1:0) ) )
        return re=true;
    //将两个大小为1的堆中石子合并
    if( b &amp;&amp; !Memorial_Search(a,b-1) )
        return re=true;
    //对大小&gt;1的堆进行合并或取走石子使操作数-1
    return re=false;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    int T,i,x;
    memset(f,-1,sizeof f);
    for(cin&gt;&gt;T;T;T--)
    {
        cin&gt;&gt;n;
        int a=0,b=-1;
        for(i=1;i&lt;=n;i++)
        {
            scanf(&quot;%d&quot;,&amp;x);
            if(x==1) ++a;
            else b+=x+1;
        }
        if(b==-1) b=0;
        puts(Memorial_Search(a,b)?&quot;YES&quot;:&quot;NO&quot;);
    }
    return 0;
}<pre><h2>Problem3895</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int tes,n;
bool vt[51][51111],f[51][51111];
bool work(int a,int b)
{
	//printf(&quot;%d %d\n&quot;,a,b);
	if (a==0) return b&amp;1;
	if (b==1) return work(a+1,0);
	if (vt[a][b]) return f[a][b];
	vt[a][b]=true;
	bool &amp;res=f[a][b];
	if (a) res|=!work(a-1,b);
	if (b) res|=!work(a,b-1);
	if (a&gt;1) res|=!work(a-2,(b==0)?2:b+3);
	if (a&amp;&amp;b) res|=!work(a-1,b+1);
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		int a=0,b=-1,i,x;
		for (i=1;i&lt;=n;i++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			if (x==1) a++;
			else b+=x+1;
		}
		if (b==-1) b=0;
		printf(work(a,b)?&quot;YES\n&quot;:&quot;NO\n&quot;);
	}
	return 0;
}<pre><h2>Problem3907</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int NN=10005;
int pr[NN],a[NN],b[NN];
int n,m,cnt;
bool is[NN];
void shai()
{
	memset(is,1,sizeof(is));
	is[1]=false;
	for (int i=2;i&lt;=10000;i++)
	{
		if (is[i]) pr[++cnt]=i;
		for (int j=1;j&lt;=cnt;j++)
		{
			int x=i*pr[j];
			if (x&gt;10000) break;
			is[x]=false;
			if (i%pr[j]==0) break;
		}
	}
	//for (int i=1;i&lt;=10;i++) printf(&quot;%d &quot;,pr[i]);printf(&quot;\n&quot;);
}
void change(int *a,int x,int kind)
{
	for (int i=1;i&lt;=cnt;i++)
	{
		int t=pr[i],xx=x;
		for (;xx;xx/=t) a[i]+=kind*(xx/t);
	}
}
struct number
{
	int l,m[10000];
	number()
	{
		memset(m,0,sizeof(m));
		l=1;
	}
	void out()
	{
		for (int i=l;i;i--) printf(&quot;%d&quot;,m[i]);
		printf(&quot;\n&quot;);
	}
	int &amp; operator [](int x) {return m[x];}
	friend number operator *(number a,int x)
	{
		int i;
		for (i=1;i&lt;=a.l;i++) a[i]*=x;
		for (i=1;i&lt;a.l;i++)
			if (a[i]&gt;9) a[i+1]+=a[i]/10,a[i]%=10;
		while (a[a.l]&gt;9)
			a[a.l+1]=a[a.l]/10,a[a.l]%=10,a.l++;//,printf(&quot;%d\n&quot;,a.l);
		return a;
	}
	friend number operator -(number a,number b)
	{
		//printf(&quot;%d %d\n&quot;,a.l,b.l);
		int i;
		for (i=1;i&lt;=b.l;i++) a[i]-=b[i];
		for (i=1;i&lt;a.l;i++)
			if (a[i]&lt;0) a[i+1]--,a[i]+=10;
		while (a[a.l]==0&amp;&amp;a.l&gt;1) a.l--;
		return a;
	}
} res1,res2;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	if (m==0) {printf(&quot;1\n&quot;);return 0;}
	shai();
	change(a,n+m,1);
	change(a,m,-1);
	change(a,n,-1);
	change(b,n+m,1);
	change(b,m-1,-1);
	change(b,n+1,-1);
	res1[1]=res2[1]=1;
	for (int i=1;i&lt;=cnt;i++)
		for (int j=1;j&lt;=a[i];j++) res1=res1*pr[i];//,printf(&quot;%d\n&quot;,pr[i]);
	for (int i=1;i&lt;=cnt;i++)
		for (int j=1;j&lt;=b[i];j++) res2=res2*pr[i];
	res1=res1-res2;
	res1.out();
	return 0;
}<pre><h2>Problem3907</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int NN=10005;
int pr[NN],a[NN],b[NN];
int n,m,cnt;
bool is[NN];
void shai()
{
	memset(is,1,sizeof(is));
	is[1]=false;
	for (int i=2;i&lt;=10000;i++)
	{
		if (is[i]) pr[++cnt]=i;
		for (int j=1;j&lt;=cnt;j++)
		{
			int x=i*pr[j];
			if (x&gt;10000) break;
			is[x]=false;
			if (i%pr[j]==0) break;
		}
	}
}
inline void change(int *a,int x,int kind)
{
	for (int i=1;i&lt;=cnt&amp;&amp;pr[i]&lt;=x;i++)
	{
		int t=pr[i],xx=x;
		for (;xx;xx/=t) a[i]+=kind*(xx/t);
	}
}
struct number
{
	int l,m[3000];
	number()
	{
		memset(m,0,sizeof(m));
		l=1;
	}
	void out()
	{
		for (int i=l;i;i--) printf(&quot;%d&quot;,m[i]);
		printf(&quot;\n&quot;);
	}
	int &amp; operator [](int x) {return m[x];}
	friend number operator *(number a,int x)
	{
		int i;
		for (i=1;i&lt;=a.l;i++) a[i]*=x;
		for (i=1;i&lt;a.l;i++)
			if (a[i]&gt;9) a[i+1]+=a[i]/10,a[i]%=10;
		while (a[a.l]&gt;9)
			a[a.l+1]=a[a.l]/10,a[a.l]%=10,a.l++;
		return a;
	}
	friend number operator -(number a,number b)
	{
		int i;
		for (i=1;i&lt;=b.l;i++) a[i]-=b[i];
		for (i=1;i&lt;a.l;i++)
			if (a[i]&lt;0) a[i+1]--,a[i]+=10;
		while (a[a.l]==0&amp;&amp;a.l&gt;1) a.l--;
		return a;
	}
} res1,res2;
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	if (m==0) {printf(&quot;1\n&quot;);return 0;}
	shai();
	change(a,n+m,1);
	change(a,m,-1);
	change(a,n,-1);
	change(b,n+m,1);
	change(b,m-1,-1);
	change(b,n+1,-1);
	res1[1]=res2[1]=1;
	for (int i=1;i&lt;=cnt;i++)
		for (int j=1;j&lt;=a[i];j++) res1=res1*pr[i];
	for (int i=1;i&lt;=cnt;i++)
		for (int j=1;j&lt;=b[i];j++) res2=res2*pr[i];
	res1=res1-res2;
	res1.out();
	return 0;
}<pre><h2>Problem3907</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int NN=10005;
int pr[NN],a[NN],b[NN];
int n,m,cnt;
bool is[NN];
void shai()
{
	memset(is,1,sizeof(is));
	is[1]=false;
	for (int i=2;i&lt;=10000;i++)
	{
		if (is[i]) pr[++cnt]=i;
		for (int j=1;j&lt;=cnt;j++)
		{
			int x=i*pr[j];
			if (x&gt;10000) break;
			is[x]=false;
			if (i%pr[j]==0) break;
		}
	}
}
inline void change(int *a,int x,int kind)
{
	for (int i=1;i&lt;=cnt&amp;&amp;pr[i]&lt;=x;i++)
	{
		int t=pr[i],xx=x;
		for (;xx;xx/=t) a[i]+=kind*(xx/t);
	}
}
struct number
{
	int l,m[2800];
	number()
	{
		memset(m,0,sizeof(m));
		l=1;
	}
	void out()
	{
		for (int i=l;i;i--) printf(&quot;%d&quot;,m[i]);
		printf(&quot;\n&quot;);
	}
	int &amp; operator [](int x) {return m[x];}
	friend number operator *(number a,int x)
	{
		int i;
		for (i=1;i&lt;=a.l;i++) a[i]*=x;
		for (i=1;i&lt;a.l;i++)
			if (a[i]&gt;9) a[i+1]+=a[i]/10,a[i]%=10;
		while (a[a.l]&gt;9)
			a[a.l+1]=a[a.l]/10,a[a.l]%=10,a.l++;
		return a;
	}
	friend number operator -(number a,number b)
	{
		int i;
		for (i=1;i&lt;=b.l;i++) a[i]-=b[i];
		for (i=1;i&lt;a.l;i++)
			if (a[i]&lt;0) a[i+1]--,a[i]+=10;
		while (a[a.l]==0&amp;&amp;a.l&gt;1) a.l--;
		return a;
	}
} res1,res2;
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	if (m==0) {printf(&quot;1\n&quot;);return 0;}
	shai();
	change(a,n+m,1);
	change(a,m,-1);
	change(a,n,-1);
	change(b,n+m,1);
	change(b,m-1,-1);
	change(b,n+1,-1);
	res1[1]=res2[1]=1;
	for (int i=1;i&lt;=cnt;i++)
		for (int j=1;j&lt;=a[i];j++) res1=res1*pr[i];
	for (int i=1;i&lt;=cnt;i++)
		for (int j=1;j&lt;=b[i];j++) res2=res2*pr[i];
	res1=res1-res2;
	res1.out();
	return 0;
}<pre><h2>Problem3907</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int NN=10005;
int pr[NN],a[NN],b[NN];
int n,m,cnt;
bool is[NN];
void shai()
{
	memset(is,1,sizeof(is));
	is[1]=false;
	for (int i=2;i&lt;=10000;i++)
	{
		if (is[i]) pr[++cnt]=i;
		for (int j=1;j&lt;=cnt;j++)
		{
			int x=i*pr[j];
			if (x&gt;10000) break;
			is[x]=false;
			if (i%pr[j]==0) break;
		}
	}
}
inline void inc(int *a,int x)
{
	for (int i=1;i&lt;=cnt&amp;&amp;pr[i]&lt;=x;i++)
	{
		int t=pr[i],xx=x;
		for (;xx;xx/=t) a[i]+=xx/t;
	}
}
inline void dec(int *a,int x)
{
	for (int i=1;i&lt;=cnt&amp;&amp;pr[i]&lt;=x;i++)
	{
		int t=pr[i],xx=x;
		for (;xx;xx/=t) a[i]-=xx/t;
	}
}
struct number
{
	int l,m[2800];
	number()
	{
		memset(m,0,sizeof(m));
		l=1;
	}
	void out()
	{
		for (int i=l;i;i--) printf(&quot;%d&quot;,m[i]);
		printf(&quot;\n&quot;);
	}
	int &amp; operator [](int x) {return m[x];}
	friend number operator *(number a,int x)
	{
		int i;
		for (i=1;i&lt;=a.l;i++) a[i]*=x;
		for (i=1;i&lt;a.l;i++)
			if (a[i]&gt;9) a[i+1]+=a[i]/10,a[i]%=10;
		while (a[a.l]&gt;9)
			a[a.l+1]=a[a.l]/10,a[a.l]%=10,a.l++;
		return a;
	}
	friend number operator -(number a,number b)
	{
		int i;
		for (i=1;i&lt;=b.l;i++) a[i]-=b[i];
		for (i=1;i&lt;a.l;i++)
			if (a[i]&lt;0) a[i+1]--,a[i]+=10;
		while (a[a.l]==0&amp;&amp;a.l&gt;1) a.l--;
		return a;
	}
} res1,res2;
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	if (m==0) {printf(&quot;1\n&quot;);return 0;}
	shai();
	inc(a,n+m);
	dec(a,m);
	dec(a,n);
	inc(b,n+m);
	dec(b,m-1);
	dec(b,n+1);
	res1[1]=res2[1]=1;
	for (int i=1;i&lt;=cnt;i++)
		for (int j=1;j&lt;=a[i];j++) res1=res1*pr[i];
	for (int i=1;i&lt;=cnt;i++)
		for (int j=1;j&lt;=b[i];j++) res2=res2*pr[i];
	res1=res1-res2;
	res1.out();
	return 0;
}<pre><h2>Problem3907</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int NN=10005;
int pr[NN],a[NN],b[NN];
int n,m,cnt;
bool is[NN];
void shai()
{
	memset(is,1,sizeof(is));
	is[1]=false;
	for (int i=2;i&lt;=10000;i++)
	{
		if (is[i]) pr[++cnt]=i;
		for (int j=1;j&lt;=cnt;j++)
		{
			int x=i*pr[j];
			if (x&gt;10000) break;
			is[x]=false;
			if (i%pr[j]==0) break;
		}
	}
}
inline void inc(int *a,int x)
{
	for (int i=1;i&lt;=cnt&amp;&amp;pr[i]&lt;=x;i++)
	{
		int t=pr[i],xx=x;
		while (xx) a[i]+=(xx/=t);
	}
}
inline void dec(int *a,int x)
{
	for (int i=1;i&lt;=cnt&amp;&amp;pr[i]&lt;=x;i++)
	{
		int t=pr[i],xx=x;
		while (xx) a[i]-=(xx/=t);
	}
}
struct number
{
	int l,m[2800];
	number()
	{
		memset(m,0,sizeof(m));
		l=1;
	}
	void out()
	{
		for (int i=l;i;i--) printf(&quot;%d&quot;,m[i]);
		printf(&quot;\n&quot;);
	}
	int &amp; operator [](int x) {return m[x];}
	friend number operator *(number a,int x)
	{
		int i;
		for (i=1;i&lt;=a.l;i++) a[i]*=x;
		for (i=1;i&lt;a.l;i++)
			if (a[i]&gt;9) a[i+1]+=a[i]/10,a[i]%=10;
		while (a[a.l]&gt;9)
			a[a.l+1]=a[a.l]/10,a[a.l]%=10,a.l++;
		return a;
	}
	friend number operator -(number a,number b)
	{
		int i;
		for (i=1;i&lt;=b.l;i++) a[i]-=b[i];
		for (i=1;i&lt;a.l;i++)
			if (a[i]&lt;0) a[i+1]--,a[i]+=10;
		while (a[a.l]==0&amp;&amp;a.l&gt;1) a.l--;
		return a;
	}
} res1,res2;
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	if (m==0) {printf(&quot;1\n&quot;);return 0;}
	shai();
	inc(a,n+m);
	dec(a,m);
	dec(a,n);
	inc(b,n+m);
	dec(b,m-1);
	dec(b,n+1);
	res1[1]=res2[1]=1;
	for (int i=1;i&lt;=cnt;i++)
		for (int j=1;j&lt;=a[i];j++) res1=res1*pr[i];
	for (int i=1;i&lt;=cnt;i++)
		for (int j=1;j&lt;=b[i];j++) res2=res2*pr[i];
	res1=res1-res2;
	res1.out();
	return 0;
}<pre><h2>Problem3924</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
const int NN=101111;
int o[NN],aa[NN*2][4],fa[NN],size[NN],pos[NN],which[NN*2],f[21][NN*2];
int dis[NN],log[NN*2],deep[NN],boss[NN],sumd[NN],upsumd[NN];
int n,m,tot=1,cnt,root;
LL sumw[NN],upsumw[NN];
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs0(int v)
{
	pos[v]=++cnt;
	which[cnt]=dis[v];
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dis[y]=dis[v]+aa[p][2];
		dfs0(y);
		which[++cnt]=dis[v];
	}
}
inline int dist(int x,int y)
{
	int l=pos[x],r=pos[y];
	if (l&gt;r) {int t=l;l=r;r=t;}
	int t=log[r-l+1];
	int tmp=min(f[t][l],f[t][r-(1&lt;&lt;t)+1])&lt;&lt;1;
	return dis[x]+dis[y]-tmp;
}
int core(int v)
{
	fa[v]=0;
	static int q[NN];
	int head=0,tail=1;
	q[1]=v;
	while (head&lt;tail)
	{
		int x=q[++head];size[x]=1;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[x]||deep[y]&lt;deep[v]) continue;
			fa[y]=x;
			q[++tail]=y;
		}
	}
	for (int i=tail;i;i--)
	{
		int x=q[i];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[v]||deep[y]&lt;deep[v]) continue;
			size[x]+=size[y];
		}
	}
	for (;;)
	{
		bool flag=false;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (deep[y]&lt;deep[v]) continue;
			if (size[y]*2&gt;size[v])
			{
				size[v]-=size[y];
				size[y]+=size[v];
				v=y;flag=true;break;
			}
		}
		if (!flag) break;
	}
	return v;
}
void work(int v)
{
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]) continue;
		y=core(y);
		aa[p][3]=y;
		boss[y]=v;
		deep[y]=deep[v]+1;
		work(y);
	}
}
void change(int x,int tt)
{
	sumd[x]+=tt;
	for (int y=x;boss[y];y=boss[y])
	{
		int ff=boss[y];
		sumd[ff]+=tt;
		upsumd[y]+=tt;
		LL dis=dist(x,ff);
		sumw[ff]+=dis*tt;
		upsumw[y]+=dis*tt;
	}
}
LL find(int x)
{
	LL res=sumw[x];
	for (int y=x;boss[y];y=boss[y])
	{
		int ff=boss[y];
		res+=sumw[ff]-upsumw[y];
		LL dis=dist(x,ff);
		res+=dis*(sumd[ff]-upsumd[y]);
	}
	return res;
}
LL calc()
{
	int x=root;LL now;
	for (;;)
	{
		now=find(x);
		bool flag=false;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (deep[y]&lt;deep[x]) continue;
			LL tmp=find(y);
			if (tmp&lt;now)
			{
				x=aa[p][3];
				flag=true;break;
			}
		}
		if (!flag) break;
	}
	return now;
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
	}
	dfs0(1);
	for (i=1;i&lt;=cnt;i++) f[0][i]=which[i];
	for (j=1;j&lt;=20;j++)
		for (i=1;i+(1&lt;&lt;(j-1))&lt;=cnt;i++)
			f[j][i]=min(f[j-1][i],f[j-1][i+(1&lt;&lt;(j-1))]);
	log[1]=0;
	for (i=2;i&lt;=cnt;i++) log[i]=(i==(i&amp;-i))?log[i-1]+1:log[i-1];
	memset(deep,60,sizeof(deep));
	root=core(1);
	deep[root]=1;
	work(root);
	for (;m;m--)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		change(x,y);
		printf(&quot;%lld\n&quot;,calc());
	}
	return 0;
}<pre><h2>Problem3924</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
const int NN=101111;
int o[NN],aa[NN*2][4],fa[NN],size[NN],pos[NN],which[NN*2],f[21][NN*2];
int dis[NN],log[NN*2],deep[NN],boss[NN],sumd[NN],upsumd[NN];
int n,m,tot=1,cnt,root;
LL sumw[NN],upsumw[NN];
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs0(int v)
{
	pos[v]=++cnt;
	which[cnt]=dis[v];
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dis[y]=dis[v]+aa[p][2];
		dfs0(y);
		which[++cnt]=dis[v];
	}
}
inline int dist(int x,int y)
{
	int l=pos[x],r=pos[y];
	if (l&gt;r) {int t=l;l=r;r=t;}
	int t=log[r-l+1];
	int tmp=min(f[t][l],f[t][r-(1&lt;&lt;t)+1])&lt;&lt;1;
	return dis[x]+dis[y]-tmp;
}
void calcsize(int v)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||deep[y]&lt;deep[v]) continue;
		fa[y]=v;
		calcsize(y);
		size[v]+=size[y];
	}
}
int core(int v)
{
	fa[v]=0;
	calcsize(v);
	for (;;)
	{
		bool flag=false;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (deep[y]&lt;deep[v]) continue;
			if (size[y]*2&gt;size[v])
			{
				size[v]-=size[y];
				size[y]+=size[v];
				v=y;flag=true;break;
			}
		}
		if (!flag) break;
	}
	return v;
}
void work(int v)
{
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]) continue;
		y=core(y);
		aa[p][3]=y;
		boss[y]=v;
		deep[y]=deep[v]+1;
		work(y);
	}
}
void change(int x,int tt)
{
	sumd[x]+=tt;
	for (int y=x;boss[y];y=boss[y])
	{
		int ff=boss[y];
		sumd[ff]+=tt;
		upsumd[y]+=tt;
		LL dis=dist(x,ff);
		sumw[ff]+=dis*tt;
		upsumw[y]+=dis*tt;
	}
}
LL find(int x)
{
	LL res=sumw[x];
	for (int y=x;boss[y];y=boss[y])
	{
		int ff=boss[y];
		res+=sumw[ff]-upsumw[y];
		LL dis=dist(x,ff);
		res+=dis*(sumd[ff]-upsumd[y]);
	}
	return res;
}
LL calc()
{
	int x=root;LL now;
	for (;;)
	{
		now=find(x);
		bool flag=false;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (deep[y]&lt;deep[x]) continue;
			LL tmp=find(y);
			if (tmp&lt;now)
			{
				x=aa[p][3];
				flag=true;break;
			}
		}
		if (!flag) break;
	}
	return now;
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
	}
	dfs0(1);
	for (i=1;i&lt;=cnt;i++) f[0][i]=which[i];
	for (j=1;j&lt;=20;j++)
		for (i=1;i+(1&lt;&lt;(j-1))&lt;=cnt;i++)
			f[j][i]=min(f[j-1][i],f[j-1][i+(1&lt;&lt;(j-1))]);
	log[1]=0;
	for (i=2;i&lt;=cnt;i++) log[i]=(i==(i&amp;-i))?log[i-1]+1:log[i-1];
	memset(deep,60,sizeof(deep));
	root=core(1);
	deep[root]=1;
	work(root);
	for (;m;m--)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		change(x,y);
		printf(&quot;%lld\n&quot;,calc());
	}
	return 0;
}<pre><h2>Problem3924</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int NN=101111;
int o[NN],aa[NN*2][4],fa[NN],size[NN],pos[NN],which[NN*2],f[21][NN*2];
int dis[NN],log[NN*2],deep[NN],boss[NN],sumd[NN],upsumd[NN];
int n,m,tot=1,cnt,root;
LL sumw[NN],upsumw[NN];
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs0(int v)
{
	pos[v]=++cnt;
	which[cnt]=dis[v];
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dis[y]=dis[v]+aa[p][2];
		dfs0(y);
		which[++cnt]=dis[v];
	}
}
inline int dist(int x,int y)
{
	int l=pos[x],r=pos[y];
	if (l&gt;r) {int t=l;l=r;r=t;}
	int t=log[r-l+1];
	int tmp=min(f[t][l],f[t][r-(1&lt;&lt;t)+1])&lt;&lt;1;
	return dis[x]+dis[y]-tmp;
}
void calcsize(int v)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||deep[y]&lt;deep[v]) continue;
		fa[y]=v;
		calcsize(y);
		size[v]+=size[y];
	}
}
int core(int v)
{
	fa[v]=0;
	calcsize(v);
	for (;;)
	{
		bool flag=false;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (deep[y]&lt;deep[v]) continue;
			if (size[y]*2&gt;size[v])
			{
				size[v]-=size[y];
				size[y]+=size[v];
				v=y;flag=true;break;
			}
		}
		if (!flag) break;
	}
	return v;
}
void work(int v)
{
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]) continue;
		y=core(y);
		aa[p][3]=y;
		boss[y]=v;
		deep[y]=deep[v]+1;
		work(y);
	}
}
void change(int x,int tt)
{
	sumd[x]+=tt;
	for (int y=x;boss[y];y=boss[y])
	{
		int ff=boss[y];
		sumd[ff]+=tt;
		upsumd[y]+=tt;
		LL dis=dist(x,ff);
		sumw[ff]+=dis*tt;
		upsumw[y]+=dis*tt;
	}
}
LL find(int x)
{
	LL res=sumw[x];
	for (int y=x;boss[y];y=boss[y])
	{
		int ff=boss[y];
		res+=sumw[ff]-upsumw[y];
		LL dis=dist(x,ff);
		res+=dis*(sumd[ff]-upsumd[y]);
	}
	return res;
}
LL calc()
{
	int x=root;LL now;
	for (;;)
	{
		now=find(x);
		bool flag=false;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (deep[y]&lt;deep[x]) continue;
			LL tmp=find(y);
			if (tmp&lt;now)
			{
				x=aa[p][3];
				flag=true;break;
			}
		}
		if (!flag) break;
	}
	return now;
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
	}
	dfs0(1);
	for (i=1;i&lt;=cnt;i++) f[0][i]=which[i];
	for (j=1;j&lt;=20;j++)
		for (i=1;i+(1&lt;&lt;(j-1))&lt;=cnt;i++)
			f[j][i]=min(f[j-1][i],f[j-1][i+(1&lt;&lt;(j-1))]);
	log[1]=0;
	for (i=2;i&lt;=cnt;i++) log[i]=(i==(i&amp;-i))?log[i-1]+1:log[i-1];
	memset(deep,60,sizeof(deep));
	root=core(1);
	deep[root]=1,work(root);
	for (;m;m--)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		change(x,y);
		printf(&quot;%lld\n&quot;,calc());
	}
	return 0;
}<pre><h2>Problem3924</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define lc (v&lt;&lt;1)
#define rc (v&lt;&lt;1|1)
#define ln printf(&quot;\n&quot;)
const int NN=1000005;
int o[NN],size[NN],aa[NN&lt;&lt;1][3],dist[NN],hea[NN],pos[NN],dy[NN];
int up[NN],fa[NN],tmax[NN],tag[NN];
int n,m,tot=1,cnt,sumw,ww,ee;
LL tsum[NN],sumdw;
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs1(int v)
{
	size[v]=1;
	int t=0,mm=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dist[y]=dist[v]+aa[p][2];
		dfs1(y);
		size[v]+=size[y];
		if (size[y]&gt;mm) mm=size[y],t=y;
	}
	hea[v]=t;
}
void dfs2(int v)
{
	pos[v]=++cnt;
	dy[cnt]=v;
	if (!hea[v]) return;
	up[hea[v]]=up[v];
	dfs2(hea[v]);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||y==hea[v]) continue;
		up[y]=y;
		dfs2(y);
	}
}
inline void add(int v,int l,int r,int x)
{
	tag[v]+=x;
	tmax[v]+=x;
	tsum[v]+=(LL)x*(dist[dy[r-1]]-dist[fa[dy[l]]]);
}
inline void pushdown(int v,int l,int r,int mid)
{
	if (!tag[v]) return;
	add(lc,l,mid,tag[v]);
	add(rc,mid,r,tag[v]);
	tag[v]=0;
}
inline void update(int v)
{
	tsum[v]=tsum[lc]+tsum[rc];
	tmax[v]=max(tmax[lc],tmax[rc]);
}
void change(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		add(v,l,r,x);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	pushdown(v,l,r,mid);
	if (ww&lt;mid) change(lc,l,mid,x);
	if (ee&gt;mid) change(rc,mid,r,x);
	update(v);
}
int find1(int v,int l,int r)
{
	if (r-l==1) return dy[l];
	int mid=(l+r)&gt;&gt;1;
	pushdown(v,l,r,mid);
	if (tmax[rc]&lt;&lt;1&gt;=sumw) return find1(rc,mid,r);
	else return find1(lc,l,mid);
}
LL find2(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tsum[v];
	int mid=(l+r)&gt;&gt;1;LL res=0;
	pushdown(v,l,r,mid);
	if (ww&lt;mid) res+=find2(lc,l,mid);
	if (ee&gt;mid) res+=find2(rc,mid,r);
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	int i,x,y,z;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
	}
	dfs1(1);
	up[1]=1;dfs2(1);
	//for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,dist[i]);ln;
	for (;m;m--)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		sumw+=y;
		sumdw+=(LL)dist[x]*y;
		z=x;
		while (z)
		{
			ww=pos[up[z]],ee=pos[z]+1;
			change(1,1,n+1,y);
			z=fa[up[z]];
		}
		x=find1(1,1,n+1);
		LL ans=(LL)dist[x]*sumw+sumdw;
		z=x;
		while (z)
		{
			ww=pos[up[z]],ee=pos[z]+1;
			ans-=find2(1,1,n+1)&lt;&lt;1;
			z=fa[up[z]];
		}
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem3924</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define lc (v&lt;&lt;1)
#define rc (v&lt;&lt;1|1)
const int NN=100005;
int o[NN],size[NN],aa[NN&lt;&lt;1][3],dist[NN],hea[NN],pos[NN],dy[NN];
int up[NN],fa[NN],tmax[NN&lt;&lt;2],tag[NN&lt;&lt;2];
int n,m,tot=1,cnt,sumw,ww,ee;
LL tsum[NN&lt;&lt;2],sumdw;
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs1(int v)
{
	size[v]=1;
	int t=0,mm=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dist[y]=dist[v]+aa[p][2];
		dfs1(y);
		size[v]+=size[y];
		if (size[y]&gt;mm) mm=size[y],t=y;
	}
	hea[v]=t;
}
void dfs2(int v)
{
	pos[v]=++cnt;
	dy[cnt]=v;
	if (!hea[v]) return;
	up[hea[v]]=up[v];
	dfs2(hea[v]);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||y==hea[v]) continue;
		up[y]=y;
		dfs2(y);
	}
}
inline void add(int v,int l,int r,int x)
{
	tag[v]+=x;
	tmax[v]+=x;
	tsum[v]+=(LL)x*(dist[dy[r-1]]-dist[fa[dy[l]]]);
}
inline void pushdown(int v,int l,int r,int mid)
{
	if (!tag[v]) return;
	add(lc,l,mid,tag[v]);
	add(rc,mid,r,tag[v]);
	tag[v]=0;
}
inline void update(int v)
{
	tsum[v]=tsum[lc]+tsum[rc];
	tmax[v]=max(tmax[lc],tmax[rc]);
}
void change(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		add(v,l,r,x);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	pushdown(v,l,r,mid);
	if (ww&lt;mid) change(lc,l,mid,x);
	if (ee&gt;mid) change(rc,mid,r,x);
	update(v);
}
int find1(int v,int l,int r)
{
	if (r-l==1) return dy[l];
	int mid=(l+r)&gt;&gt;1;
	pushdown(v,l,r,mid);
	if (tmax[rc]&lt;&lt;1&gt;=sumw) return find1(rc,mid,r);
	else return find1(lc,l,mid);
}
LL find2(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tsum[v];
	int mid=(l+r)&gt;&gt;1;LL res=0;
	pushdown(v,l,r,mid);
	if (ww&lt;mid) res+=find2(lc,l,mid);
	if (ee&gt;mid) res+=find2(rc,mid,r);
	return res;
}
int main()
{
	int i,x,y,z;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
	}
	dfs1(1);
	up[1]=1;dfs2(1);
	for (;m;m--)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		sumw+=y;
		sumdw+=(LL)dist[x]*y;
		z=x;
		while (z)
		{
			ww=pos[up[z]],ee=pos[z]+1;
			change(1,1,n+1,y);
			z=fa[up[z]];
		}
		x=find1(1,1,n+1);
		LL ans=(LL)dist[x]*sumw+sumdw;
		z=x;
		while (z)
		{
			ww=pos[up[z]],ee=pos[z]+1;
			ans-=find2(1,1,n+1)&lt;&lt;1;
			z=fa[up[z]];
		}
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem3924</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define lc (v&lt;&lt;1)
#define rc (v&lt;&lt;1|1)
const int NN=100005;
int o[NN],size[NN],aa[NN&lt;&lt;1][3],dist[NN],hea[NN],pos[NN],dy[NN];
int up[NN],fa[NN],tmax[NN&lt;&lt;2],tag[NN&lt;&lt;2];
int n,m,tot=1,cnt,sumw,ww,ee;
LL tsum[NN&lt;&lt;2],sumdw;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool flag=false;
	while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar();
	if (ch=='-') flag=true,ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
	if (flag) x=-x;
}
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs1(int v)
{
	size[v]=1;
	int t=0,mm=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dist[y]=dist[v]+aa[p][2];
		dfs1(y);
		size[v]+=size[y];
		if (size[y]&gt;mm) mm=size[y],t=y;
	}
	hea[v]=t;
}
void dfs2(int v)
{
	pos[v]=++cnt;
	dy[cnt]=v;
	if (!hea[v]) return;
	up[hea[v]]=up[v];
	dfs2(hea[v]);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||y==hea[v]) continue;
		up[y]=y;
		dfs2(y);
	}
}
inline void add(int v,int l,int r,int x)
{
	tag[v]+=x;
	tmax[v]+=x;
	tsum[v]+=(LL)x*(dist[dy[r-1]]-dist[fa[dy[l]]]);
}
inline void pushdown(int v,int l,int r,int mid)
{
	if (!tag[v]) return;
	add(lc,l,mid,tag[v]);
	add(rc,mid,r,tag[v]);
	tag[v]=0;
}
inline void update(int v)
{
	tsum[v]=tsum[lc]+tsum[rc];
	tmax[v]=max(tmax[lc],tmax[rc]);
}
void change(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		add(v,l,r,x);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	pushdown(v,l,r,mid);
	if (ww&lt;mid) change(lc,l,mid,x);
	if (ee&gt;mid) change(rc,mid,r,x);
	update(v);
}
int find1(int v,int l,int r)
{
	if (r-l==1) return dy[l];
	int mid=(l+r)&gt;&gt;1;
	pushdown(v,l,r,mid);
	if (tmax[rc]&lt;&lt;1&gt;=sumw) return find1(rc,mid,r);
	else return find1(lc,l,mid);
}
LL find2(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tsum[v];
	int mid=(l+r)&gt;&gt;1;LL res=0;
	pushdown(v,l,r,mid);
	if (ww&lt;mid) res+=find2(lc,l,mid);
	if (ee&gt;mid) res+=find2(rc,mid,r);
	return res;
}
int main()
{
	int i,x,y,z;
	read(n),read(m);
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y),read(z);
		addedge(x,y,z),addedge(y,x,z);
	}
	dfs1(1);
	up[1]=1;dfs2(1);
	for (;m;m--)
	{
		read(x),read(y);
		sumw+=y;
		sumdw+=(LL)dist[x]*y;
		z=x;
		while (z)
		{
			ww=pos[up[z]],ee=pos[z]+1;
			change(1,1,n+1,y);
			z=fa[up[z]];
		}
		x=find1(1,1,n+1);
		LL ans=(LL)dist[x]*sumw+sumdw;
		z=x;
		while (z)
		{
			ww=pos[up[z]],ee=pos[z]+1;
			ans-=find2(1,1,n+1)&lt;&lt;1;
			z=fa[up[z]];
		}
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem3924</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define lc (v&lt;&lt;1)
#define rc (v&lt;&lt;1|1)
const int NN=100005;
int o[NN],size[NN],aa[NN&lt;&lt;1][3],dist[NN],hea[NN],pos[NN],the[NN];
int up[NN],fa[NN],tmax[NN&lt;&lt;2],tag[NN&lt;&lt;2],sum_the[NN],dy[NN];
int n,m,tot=1,cnt,sumw,ww,ee;
LL tsum[NN&lt;&lt;2],sumdw;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool flag=false;
	while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar();
	if (ch=='-') flag=true,ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
	if (flag) x=-x;
}
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs1(int v)
{
	size[v]=1;
	int t=0,mm=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		the[y]=aa[p][2];
		dist[y]=dist[v]+aa[p][2];
		dfs1(y);
		size[v]+=size[y];
		if (size[y]&gt;mm) mm=size[y],t=y;
	}
	hea[v]=t;
}
void dfs2(int v)
{
	pos[v]=++cnt;
	dy[cnt]=v;
	sum_the[cnt]=sum_the[cnt-1]+the[v];
	if (!hea[v]) return;
	up[hea[v]]=up[v];
	dfs2(hea[v]);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||y==hea[v]) continue;
		up[y]=y;
		dfs2(y);
	}
}
inline void add(int v,int l,int r,int x)
{
	tag[v]+=x;
	tmax[v]+=x;
	tsum[v]+=(LL)x*(sum_the[r-1]-sum_the[l-1]);
}
inline void pushdown(int v,int l,int r,int mid)
{
	if (!tag[v]) return;
	add(lc,l,mid,tag[v]);
	add(rc,mid,r,tag[v]);
	tag[v]=0;
}
inline void update(int v)
{
	tsum[v]=tsum[lc]+tsum[rc];
	tmax[v]=max(tmax[lc],tmax[rc]);
}
void change(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		add(v,l,r,x);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	pushdown(v,l,r,mid);
	if (ww&lt;mid) change(lc,l,mid,x);
	if (ee&gt;mid) change(rc,mid,r,x);
	update(v);
}
int find1(int v,int l,int r)
{
	if (r-l==1) return dy[l];
	int mid=(l+r)&gt;&gt;1;
	pushdown(v,l,r,mid);
	if (tmax[rc]&lt;&lt;1&gt;=sumw) return find1(rc,mid,r);
	else return find1(lc,l,mid);
}
LL find2(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tsum[v];
	int mid=(l+r)&gt;&gt;1;LL res=0;
	pushdown(v,l,r,mid);
	if (ww&lt;mid) res+=find2(lc,l,mid);
	if (ee&gt;mid) res+=find2(rc,mid,r);
	return res;
}
int main()
{
	int i,x,y,z;
	read(n),read(m);
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y),read(z);
		addedge(x,y,z),addedge(y,x,z);
	}
	dfs1(1);
	up[1]=1;dfs2(1);
	for (;m;m--)
	{
		read(x),read(y);
		sumw+=y;
		sumdw+=(LL)dist[x]*y;
		z=x;
		while (z)
		{
			ww=pos[up[z]],ee=pos[z]+1;
			change(1,1,n+1,y);
			z=fa[up[z]];
		}
		x=find1(1,1,n+1);
		LL ans=(LL)dist[x]*sumw+sumdw;
		z=x;
		while (z)
		{
			ww=pos[up[z]],ee=pos[z]+1;
			ans-=find2(1,1,n+1)&lt;&lt;1;
			z=fa[up[z]];
		}
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem3924</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define lc (v&lt;&lt;1)
#define rc (v&lt;&lt;1|1)
const int NN=100005;
int o[NN],size[NN],aa[NN&lt;&lt;1][3],dist[NN],hea[NN],pos[NN],the[NN];
int up[NN],fa[NN],tmax[NN&lt;&lt;2],tag[NN&lt;&lt;2],sum_the[NN],dy[NN];
int n,m,tot=1,cnt,sumw,ww,ee;
LL tsum[NN&lt;&lt;2],sumdw;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool flag=false;
	while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar();
	if (ch=='-') flag=true,ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
	if (flag) x=-x;
}
inline void writeln(LL x)
{
	if (x==0) {putchar('0');putchar('\n');return;}
	static int sta[13],top;
	for (top=0;x;x/=10) sta[++top]=x%10;
	while (top) putchar('0'+sta[top--]);
	putchar('\n');
}
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs1(int v)
{
	size[v]=1;
	int t=0,mm=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		the[y]=aa[p][2];
		dist[y]=dist[v]+aa[p][2];
		dfs1(y);
		size[v]+=size[y];
		if (size[y]&gt;mm) mm=size[y],t=y;
	}
	hea[v]=t;
}
void dfs2(int v)
{
	pos[v]=++cnt;
	dy[cnt]=v;
	sum_the[cnt]=sum_the[cnt-1]+the[v];
	if (!hea[v]) return;
	up[hea[v]]=up[v];
	dfs2(hea[v]);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||y==hea[v]) continue;
		up[y]=y;
		dfs2(y);
	}
}
inline void add(int v,int l,int r,int x)
{
	tag[v]+=x;
	tmax[v]+=x;
	tsum[v]+=(LL)x*(sum_the[r-1]-sum_the[l-1]);
}
inline void pushdown(int v,int l,int r,int mid)
{
	if (!tag[v]) return;
	add(lc,l,mid,tag[v]);
	add(rc,mid,r,tag[v]);
	tag[v]=0;
}
inline void update(int v)
{
	tsum[v]=tsum[lc]+tsum[rc];
	tmax[v]=max(tmax[lc],tmax[rc]);
}
void change(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		add(v,l,r,x);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	pushdown(v,l,r,mid);
	if (ww&lt;mid) change(lc,l,mid,x);
	if (ee&gt;mid) change(rc,mid,r,x);
	update(v);
}
int find1(int v,int l,int r)
{
	if (r-l==1) return dy[l];
	int mid=(l+r)&gt;&gt;1;
	pushdown(v,l,r,mid);
	if (tmax[rc]&lt;&lt;1&gt;=sumw) return find1(rc,mid,r);
	else return find1(lc,l,mid);
}
LL find2(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tsum[v];
	int mid=(l+r)&gt;&gt;1;LL res=0;
	pushdown(v,l,r,mid);
	if (ww&lt;mid) res+=find2(lc,l,mid);
	if (ee&gt;mid) res+=find2(rc,mid,r);
	return res;
}
int main()
{
	int i,x,y,z;
	read(n),read(m);
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y),read(z);
		addedge(x,y,z),addedge(y,x,z);
	}
	dfs1(1);
	up[1]=1;dfs2(1);
	for (;m;m--)
	{
		read(x),read(y);
		sumw+=y;
		sumdw+=(LL)dist[x]*y;
		z=x;
		while (z)
		{
			ww=pos[up[z]],ee=pos[z]+1;
			change(1,1,n+1,y);
			z=fa[up[z]];
		}
		x=find1(1,1,n+1);
		LL ans=(LL)dist[x]*sumw+sumdw;
		z=x;
		while (z)
		{
			ww=pos[up[z]],ee=pos[z]+1;
			ans-=find2(1,1,n+1)&lt;&lt;1;
			z=fa[up[z]];
		}
		writeln(ans);
	}
	return 0;
}<pre><h2>Problem3924</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define lc (v&lt;&lt;1)
#define rc (v&lt;&lt;1|1)
const int NN=100001;
int o[NN],size[NN],aa[NN&lt;&lt;1][3],dist[NN],hea[NN],pos[NN],the[NN];
int up[NN],fa[NN],tmax[NN&lt;&lt;2],tag[NN&lt;&lt;2],sum_the[NN],dy[NN];
int n,m,tot=1,cnt,sumw,ww,ee;
LL tsum[NN&lt;&lt;2],sumdw;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool flag=false;
	while (ch!='-'&amp;&amp;(ch&lt;'0'||ch&gt;'9')) ch=getchar();
	if (ch=='-') flag=true,ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
	if (flag) x=-x;
}
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs1(int v)
{
	size[v]=1;
	int t=0,mm=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		the[y]=aa[p][2];
		dist[y]=dist[v]+aa[p][2];
		dfs1(y);
		size[v]+=size[y];
		if (size[y]&gt;mm) mm=size[y],t=y;
	}
	hea[v]=t;
}
void dfs2(int v)
{
	pos[v]=++cnt;
	dy[cnt]=v;
	sum_the[cnt]=sum_the[cnt-1]+the[v];
	if (!hea[v]) return;
	up[hea[v]]=up[v];
	dfs2(hea[v]);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||y==hea[v]) continue;
		up[y]=y;
		dfs2(y);
	}
}
inline void add(int v,int l,int r,int x)
{
	tag[v]+=x;
	tmax[v]+=x;
	tsum[v]+=(LL)x*(sum_the[r-1]-sum_the[l-1]);
}
inline void pushdown(int v,int l,int r,int mid)
{
	if (!tag[v]) return;
	add(lc,l,mid,tag[v]);
	add(rc,mid,r,tag[v]);
	tag[v]=0;
}
inline void update(int v)
{
	tsum[v]=tsum[lc]+tsum[rc];
	tmax[v]=max(tmax[lc],tmax[rc]);
}
void change(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		add(v,l,r,x);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	pushdown(v,l,r,mid);
	if (ww&lt;mid) change(lc,l,mid,x);
	if (ee&gt;mid) change(rc,mid,r,x);
	update(v);
}
int find1(int v,int l,int r)
{
	if (r-l==1) return dy[l];
	int mid=(l+r)&gt;&gt;1;
	pushdown(v,l,r,mid);
	if (tmax[rc]&lt;&lt;1&gt;=sumw) return find1(rc,mid,r);
	else return find1(lc,l,mid);
}
LL find2(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tsum[v];
	int mid=(l+r)&gt;&gt;1;LL res=0;
	pushdown(v,l,r,mid);
	if (ww&lt;mid) res+=find2(lc,l,mid);
	if (ee&gt;mid) res+=find2(rc,mid,r);
	return res;
}
int main()
{
	int i,x,y,z;
	read(n),read(m);
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y),read(z);
		addedge(x,y,z),addedge(y,x,z);
	}
	dfs1(1);
	up[1]=1;dfs2(1);
	for (;m;m--)
	{
		read(x),read(y);
		sumw+=y;
		sumdw+=(LL)dist[x]*y;
		z=x;
		while (z)
		{
			ww=pos[up[z]],ee=pos[z]+1;
			change(1,1,n+1,y);
			z=fa[up[z]];
		}
		x=find1(1,1,n+1);
		LL ans=(LL)dist[x]*sumw+sumdw;
		z=x;
		while (z)
		{
			ww=pos[up[z]],ee=pos[z]+1;
			ans-=find2(1,1,n+1)&lt;&lt;1;
			z=fa[up[z]];
		}
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem3926</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
const int NN=101111,AA=2001111;
int fa[NN],o[NN],aa[NN*2][2],color[NN],val[AA],pre[AA],son[AA][10],du[NN];
int n,TTT,tot,C;
LL f[AA];
bool vt[AA];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
int add(int p,int x)
{
	int end=++TTT;
	val[end]=val[p]+1;
	for (;p!=-1&amp;&amp;!son[p][x];p=pre[p]) son[p][x]=end;
	if (p==-1) {pre[p]=0;return end;}
	int q=son[p][x];
	if (val[q]==val[p]+1) {pre[end]=q;return end;}
	int nq=++TTT;
	val[nq]=val[p]+1;
	pre[nq]=pre[q];
	pre[q]=pre[end]=nq;
	memcpy(son[nq],son[q],sizeof(son[q]));
	for (;p!=-1&amp;&amp;son[p][x]==q;p=pre[p]) son[p][x]=nq;
	return end;
}
void dfs(int v,int x)
{
	int t=add(x,color[v]);
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dfs(y,t);
	}
}
LL DP(int v)
{
	if (vt[v]) return f[v];
	vt[v]=true;
	f[v]=1;
	for (int i=0;i&lt;C;i++)
		if (son[v][i]) f[v]+=DP(son[v][i]);
	return f[v];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(C);
	int i,x,y;
	for (i=1;i&lt;=n;i++) read(color[i]);
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y);
		du[x]++,du[y]++;
		addedge(x,y),addedge(y,x);
	}
	pre[0]=-1;
	for (i=1;i&lt;=n;i++)
		if (du[i]==1) fa[i]=0,dfs(i,0);
	printf(&quot;%lld\n&quot;,DP(0)-1);
	return 0;
}<pre><h2>Problem3931</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define INF 9999999999999999ll
#define ln printf(&quot;\n&quot;)
const int NN=1111,MM=101111;
int o[NN],cur[NN],aa[MM*2+NN][2],deep[NN];
int n,m,tot,S,T;
LL d1[NN],d2[NN],cc[MM*2+NN];
inline void addedge(int p,int q,LL v)
{
	tot++;
	aa[tot][1]=q;
	cc[tot]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline void add(int p,int q,LL v)
{
	//printf(&quot;add  %d %d %I64d\n&quot;,p,q,v);
	addedge(p,q,v);
	addedge(q,p,0);
}
struct edge
{
	int u,v,w;
	void in()
	{
		scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);
		addedge(u,v,w),addedge(v,u,w);
	}
	void check()
	{
		if (d1[u]+w+d2[v]==d1[n]) add(u+n,v,INF);
		if (d1[v]+w+d2[u]==d1[n]) add(v+n,u,INF);
	}
} e[MM];
struct ppt
{
	int v;LL d;
	ppt(int a=0,LL b=0) {v=a;d=b;}
	friend bool operator &lt;(ppt a,ppt b) {return a.d&gt;b.d;}
};
priority_queue&lt;ppt&gt; Q;
void dij(LL *dist,int S)
{
	static bool vt[NN];
	memset(vt,0,sizeof(vt));
	for (int i=1;i&lt;=n;i++) dist[i]=INF;
	dist[S]=0;
	Q.push(ppt(S,0));
	while (!Q.empty())
	{
		ppt tmp=Q.top();Q.pop();
		int v=tmp.v;LL d=tmp.d;
		if (vt[v]) continue;
		vt[v]=true;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (dist[y]&gt;d+cc[p])
			{
				dist[y]=d+cc[p];
				Q.push(ppt(y,dist[y]));
			}
		}
	}
}
bool bfs()
{
	static int que[NN];
	int head=0,tail=1;
	que[1]=S;
	memset(deep,0,sizeof(deep));
	deep[S]=1;
	while (head&lt;tail)
	{
		int x=que[++head];
		cur[x]=o[x];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (cc[p]&amp;&amp;!deep[y])
				deep[y]=deep[x]+1,que[++tail]=y;
		}
	}
	return deep[n];
}
LL dfs(int v,LL f)
{
	if (v==T) return f;
	LL res=0;
	for (int &amp;p=cur[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!cc[p]||deep[y]!=deep[v]+1) continue;
		LL tmp=dfs(y,min(f,cc[p]));
		f-=tmp,cc[p]-=tmp;
		cc[p^1]+=tmp,res+=tmp;
		if (f==0) break;
	}
	if (res==0) deep[v]=-1;
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x;
	for (i=1;i&lt;=m;i++) e[i].in();
	dij(d1,1);
	dij(d2,n);
	//for (i=1;i&lt;=n;i++) printf(&quot;%I64d &quot;,d2[i]);ln;
	memset(o,0,sizeof(o));tot=1;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		add(i,i+n,x);
	}
	for (i=1;i&lt;=m;i++) e[i].check();
	S=n+n+1,T=S+1;
	add(S,1+n,INF),add(n,T,INF);
	LL ans=0;
	while (bfs()) ans+=dfs(S,INF);
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem3932</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
typedef long long LL;
#define inf 999999999
#define pb push_back
#define ln printf(&quot;\n&quot;)
const int NN=101111,MM=10000005,AA=20000000;
int root[NN],lc[AA],rc[AA],size[AA];
int n,m,TTT;
LL tsum[AA];
vector&lt;int&gt; inc[NN],dec[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar()) x=x*10+ch-'0';
	if (f) x=-x;
}
void change(int &amp;v,int u,int l,int r,int x,int kind)
{
	if (!v) v=++TTT;
	//printf(&quot;change %d %d %d %d %d %d\n&quot;,v,u,l,r,x,kind);
	size[v]=size[u]+kind;
	tsum[v]=tsum[u]+x*kind;
	//printf(&quot;%d %I64d\n&quot;,size[v],tsum[v]);
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid) rc[v]=rc[u],change(lc[v],lc[u],l,mid,x,kind);
	else lc[v]=lc[u],change(rc[v],rc[u],mid,r,x,kind);
}
LL find(int v,int l,int r,int K)
{
	if (v==0) return 0;
	//printf(&quot;find %d %d %d %d\n&quot;,v,l,r,K);
	if (K&gt;=size[v]) return tsum[v];
	if (r-l==1) return tsum[v]/size[v]*K;
	int tmp=size[lc[v]],mid=(l+r)&gt;&gt;1;
	//printf(&quot;tmp=%d tsum[lc[v]]=%I64d\n&quot;,tmp,tsum[lc[v]]);
	if (K&lt;=tmp) return find(lc[v],l,mid,K);
	else return tsum[lc[v]]+find(rc[v],mid,r,K-tmp);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(m),read(n);
	int i,x,y,z,j;
	for (i=1;i&lt;=m;i++)
	{
		read(x),read(y),read(z);
		inc[x].pb(z),dec[y+1].pb(z);
	}
	int prert=0;
	for (i=1;i&lt;=n;i++)
	{
		//printf(&quot;\n--------------------------------------------------------------------\n&quot;);
		int t=inc[i].size();
		for (j=0;j&lt;t;j++)
		{
			change(root[i]=0,prert,0,MM,inc[i][j],1);
			prert=root[i];
		}
		t=dec[i].size();
		for (j=0;j&lt;t;j++)
		{
			change(root[i]=0,prert,0,MM,dec[i][j],-1);
			prert=root[i];
		}
		if (root[i]==0) root[i]=root[i-1];
	}
	//for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,root[i]);ln;for (i=1;i&lt;=TTT;i++) printf(&quot;%d %d\n&quot;,lc[i],rc[i]);ln;
	LL lastans=1;
	for (;n;n--)
	{
		//printf(&quot;\n---------------------------------------------------\n&quot;);
		int x,A,B,C,K;
		read(x),read(A),read(B),read(C);
		K=1+(lastans*A+B)%C;
		//read(K);
		//printf(&quot;x=%d K=%d\n&quot;,x,K);
		lastans=find(root[x],0,MM,K);
		printf(&quot;%lld\n&quot;,lastans);
	}
	return 0;
}<pre><h2>Problem3932</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
typedef long long LL;
#define inf 999999999
#define pb push_back
#define ln printf(&quot;\n&quot;)
const int NN=101111,MM=10000005,AA=6000000;
int root[NN],lc[AA],rc[AA],size[AA];
int n,m,TTT;
LL tsum[AA];
vector&lt;int&gt; inc[NN],dec[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar()) x=x*10+ch-'0';
	if (f) x=-x;
}
void change(int &amp;v,int u,int l,int r,int x,int kind)
{
	if (!v) v=++TTT;
	//printf(&quot;change %d %d %d %d %d %d\n&quot;,v,u,l,r,x,kind);
	size[v]=size[u]+kind;
	tsum[v]=tsum[u]+x*kind;
	//printf(&quot;%d %I64d\n&quot;,size[v],tsum[v]);
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid) rc[v]=rc[u],change(lc[v],lc[u],l,mid,x,kind);
	else lc[v]=lc[u],change(rc[v],rc[u],mid,r,x,kind);
}
LL find(int v,int l,int r,int K)
{
	if (v==0) return 0;
	//printf(&quot;find %d %d %d %d\n&quot;,v,l,r,K);
	if (K&gt;=size[v]) return tsum[v];
	if (r-l==1) return tsum[v]/size[v]*K;
	int tmp=size[lc[v]],mid=(l+r)&gt;&gt;1;
	//printf(&quot;tmp=%d tsum[lc[v]]=%I64d\n&quot;,tmp,tsum[lc[v]]);
	if (K&lt;=tmp) return find(lc[v],l,mid,K);
	else return tsum[lc[v]]+find(rc[v],mid,r,K-tmp);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(m),read(n);
	int i,x,y,z,j;
	for (i=1;i&lt;=m;i++)
	{
		read(x),read(y),read(z);
		inc[x].pb(z),dec[y+1].pb(z);
	}
	int prert=0;
	for (i=1;i&lt;=n;i++)
	{
		//printf(&quot;\n--------------------------------------------------------------------\n&quot;);
		int t=inc[i].size();
		for (j=0;j&lt;t;j++)
		{
			change(root[i]=0,prert,0,MM,inc[i][j],1);
			prert=root[i];
		}
		t=dec[i].size();
		for (j=0;j&lt;t;j++)
		{
			change(root[i]=0,prert,0,MM,dec[i][j],-1);
			prert=root[i];
		}
		if (root[i]==0) root[i]=root[i-1];
	}
	//for (i=1;i&lt;=n;i++) printf(&quot;%d &quot;,root[i]);ln;for (i=1;i&lt;=TTT;i++) printf(&quot;%d %d\n&quot;,lc[i],rc[i]);ln;
	LL lastans=1;
	for (;n;n--)
	{
		//printf(&quot;\n---------------------------------------------------\n&quot;);
		int x,A,B,C,K;
		read(x),read(A),read(B),read(C);
		K=1+(lastans*A+B)%C;
		//read(K);
		//printf(&quot;x=%d K=%d\n&quot;,x,K);
		lastans=find(root[x],0,MM,K);
		printf(&quot;%lld\n&quot;,lastans);
	}
	return 0;
}<pre><h2>Problem3932</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
typedef long long LL;
#define inf 999999999
#define pb push_back
const int NN=101111,MM=10000005,AA=6000000;
int root[NN],lc[AA],rc[AA],size[AA];
int n,m,TTT;
LL tsum[AA];
vector&lt;int&gt; inc[NN],dec[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar()) x=x*10+ch-'0';
	if (f) x=-x;
}
void change(int &amp;v,int u,int l,int r,int x,int kind)
{
	if (!v) v=++TTT;
	size[v]=size[u]+kind;
	tsum[v]=tsum[u]+x*kind;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid) rc[v]=rc[u],change(lc[v],lc[u],l,mid,x,kind);
	else lc[v]=lc[u],change(rc[v],rc[u],mid,r,x,kind);
}
LL find(int v,int l,int r,int K)
{
	if (v==0) return 0;
	if (K&gt;=size[v]) return tsum[v];
	if (r-l==1) return tsum[v]/size[v]*K;
	int tmp=size[lc[v]],mid=(l+r)&gt;&gt;1;
	if (K&lt;=tmp) return find(lc[v],l,mid,K);
	else return tsum[lc[v]]+find(rc[v],mid,r,K-tmp);
}
int main()
{
	read(m),read(n);
	int i,x,y,z,j;
	for (i=1;i&lt;=m;i++)
	{
		read(x),read(y),read(z);
		inc[x].pb(z),dec[y+1].pb(z);
	}
	int prert=0;
	for (i=1;i&lt;=n;i++)
	{
		int t=inc[i].size();
		for (j=0;j&lt;t;j++)
		{
			change(root[i]=0,prert,0,MM,inc[i][j],1);
			prert=root[i];
		}
		t=dec[i].size();
		for (j=0;j&lt;t;j++)
		{
			change(root[i]=0,prert,0,MM,dec[i][j],-1);
			prert=root[i];
		}
		if (root[i]==0) root[i]=root[i-1];
	}
	LL lastans=1;
	for (;n;n--)
	{
		int x,A,B,C,K;
		read(x),read(A),read(B),read(C);
		K=1+(lastans*A+B)%C;
		lastans=find(root[x],0,MM,K);
		printf(&quot;%lld\n&quot;,lastans);
	}
	return 0;
}<pre><h2>Problem3940</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int AA=101111;
int son[AA][26],from[AA],fail[AA],L[AA];
int n,m,TTT;
char s[AA],ss[AA];
void ACins(int id,int len)
{
	int now=1;
	for (int i=1;i&lt;=len;i++)
	{
		int t=ss[i]-'a';
		if (son[now][t]) now=son[now][t];
		else now=son[now][t]=++TTT;
	}
	from[now]=id;
}
void buildfail()
{
	int head=0,tail=1;
	static int que[AA];
	que[1]=1;
	while (head&lt;tail)
	{
		int x=que[++head];
		for (int i=0;i&lt;26;i++)
			if (!son[x][i]) son[x][i]=son[fail[x]][i];
			else
			{
				fail[son[x][i]]=son[fail[x]][i];
				que[++tail]=son[x][i];
			}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%s%d\n&quot;,s+1,&amp;m);
	n=strlen(s+1);
	TTT=1;
	int i;
	for (i=0;i&lt;26;i++) son[0][i]=1,son[1][i]=0;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%s\n&quot;,ss+1);
		ACins(i,L[i]=strlen(ss+1));
	}
	buildfail();
	//for (i=1;i&lt;=TTT;i++){for (int j=0;j&lt;3;j++)printf(&quot;%d &quot;,son[i][j]);ln;}ln;
	int now=1,k=0;
	static int b[AA];
	static char ans[AA];
	b[0]=1;
	//printf(&quot;%d\n&quot;,son[3][2]);
	for (i=1;i&lt;=n;i++)
	{
		int t=s[i]-'a';
		k++;
		ans[k]=s[i];
		now=son[now][t];
		b[k]=now;
		if (from[now])
		{
			k-=L[from[now]];
			now=b[k];
		}
	}
	for (i=1;i&lt;=k;i++) putchar(ans[i]);
	return 0;
}<pre><h2>Problem3944</h2><pre>#include &lt;map&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define M 5000000
using namespace std;
int n;
int prime[M/5],tot;
long long phi[M],mu[M];
bool not_prime[M];
map&lt;int,long long&gt; _phi,_mu;
void Linear_Shaker()
{
    long long i,j;
    phi[1]=1;mu[1]=1;
    for(i=2;i&lt;M;i++)
    {
        if(!not_prime[i])
        {
            phi[i]=i-1;
            mu[i]=-1;
            prime[++tot]=i;
        }
        for(j=1;prime[j]*i&lt;M;j++)
        {
            not_prime[prime[j]*i]=true;
            if(i%prime[j]==0)
            {
                phi[prime[j]*i]=phi[i]*prime[j];
                mu[prime[j]*i]=0;
                break;
            }
            phi[prime[j]*i]=phi[i]*(prime[j]-1);
            mu[prime[j]*i]=-mu[i];
        }
    }
    for(i=1;i&lt;M;i++)
    {
        phi[i]+=phi[i-1];
        mu[i]+=mu[i-1];
    }
}
long long Calculate_Phi(long long n)
{
    map&lt;int,long long&gt;::iterator it;
    if(n&lt;M)
        return phi[n];
    if((it=_phi.find(n))!=_phi.end())
        return it-&gt;second;
    long long i,last,re=(long long)n*(n+1)&gt;&gt;1;
    for(i=2;i&lt;=n;i=last+1)
    {
        last=n/(n/i);
        re-=(last-i+1)*Calculate_Phi(n/i);
    }
    return _phi[n]=re;
}
long long Calculate_Mu(long long n)
{
    map&lt;int,long long&gt;::iterator it;
    if(n&lt;M)
        return mu[n];
    if((it=_mu.find(n))!=_mu.end())
        return it-&gt;second;
    long long i,last,re=1;
    for(i=2;i&lt;=n;i=last+1)
    {
        last=n/(n/i);
        re-=(last-i+1)*Calculate_Mu(n/i);
    }
    return _mu[n]=re;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
    int T;
    Linear_Shaker();
    for(cin&gt;&gt;T;T;T--)
    {
        scanf(&quot;%d&quot;,&amp;n);
        printf(&quot;%lld %lld\n&quot;,Calculate_Phi(n),Calculate_Mu(n));
    }
}<pre><h2>Problem3944</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
const int m=5000000;
int pr[m+111];
int n,tes,prcnt;
LL phi[m+111],miu[m+111];
void shai()
{
    static bool vt[m+11];
    vt[1]=true;
    phi[1]=1,miu[1]=1;
    int i,j;
    for (i=2;i&lt;=m;i++)
    {
        if (!vt[i])
        {
            pr[++prcnt]=i;
            phi[i]=i-1,miu[i]=-1;
        }
        for (j=1;j&lt;=prcnt;j++)
        {
            int x=i*pr[j];
            if (x&gt;m) break;
            vt[x]=true;
            if (i%pr[j]==0)
            {
                phi[x]=phi[i]*pr[j];
                miu[x]=0;
                break;
            }
            phi[x]=phi[i]*(pr[j]-1);
            miu[x]=-miu[i];
        }
    }
    for (i=1;i&lt;=m;i++)
        phi[i]+=phi[i-1],miu[i]+=miu[i-1];
}
struct HT
{
    int o[100007],aa[500000][2],vt[100007];
    int tot,TIME,mod;
    LL f[500000];
    HT() {mod=100007;tot=0;}
    void clear() {tot=0;TIME++;}
    void insert(int n,LL ff)
    {
        int t=n%mod;
        if (vt[t]!=TIME) vt[t]=TIME,o[t]=0;
        tot++;aa[tot][1]=n;f[tot]=ff;
        aa[tot][0]=o[t];o[t]=tot;
    }
    LL find(int n)
    {
        int t=n%mod;
        if (vt[t]!=TIME) vt[t]=TIME,o[t]=0;
        for (int p=o[t];p;p=aa[p][0])
            if (aa[p][1]==n) return f[p];
        return -1;
    }
} ht1,ht2;
LL F1(LL n)
{
    if (n&lt;=m) return phi[n];
    LL tmp=ht1.find(n);
    if (tmp!=-1) return tmp;
    tmp=(LL)n*(n+1)&gt;&gt;1;
    LL l,r;
    for (l=2;l&lt;=n;l=r+1)
    {
        r=n/(n/l);
        tmp-=(r-l+1)*F1(n/l);
    }
    ht1.insert(n,tmp);
    return tmp;
}
LL F2(LL n)
{
    if (n&lt;=m) return miu[n];
    LL tmp=ht2.find(n);
    if (tmp!=-1) return tmp;
    tmp=1;
    LL l,r;
    for (l=2;l&lt;=n;l=r+1)
    {
        r=n/(n/l);
        tmp-=(r-l+1)*F2(n/l);
    }
    ht2.insert(n,tmp);
    return tmp;
}
int main()
{
 //   freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    shai();
    for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
    {
        scanf(&quot;%d&quot;,&amp;n);
        ht1.clear(),ht2.clear();
        printf(&quot;%lld %lld\n&quot;,F1(n),F2(n));
    }
    return 0;
}<pre><h2>Problem3969</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
#define N 1000000 + 5
  
int n, k, size, Max, A[N];
  
inline int getint()
{
    char ch = '\n';
    for (; ch &gt; '9' || ch &lt; '0'; ch = getchar()) ;
    int res = ch - '0';
    for (ch = getchar(); ch &gt;= '0' &amp;&amp; ch &lt;= '9'; ch = getchar())
        res = (res &lt;&lt; 3) + (res &lt;&lt; 1) + ch - '0';
    return res;
}
  
inline bool Judge(int m)
{
    int cnt = n;
    for (int i = 2; cnt &amp;&amp; i &lt;= size; i ++)
        if (A[i] - A[i - 1] &lt;= m)
        {
            if (size - i + 2 &lt; 2 * cnt * k) return 0;
            cnt --, i ++;
        }
    return !cnt;
}
  
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
    n = getint(), k = getint();
    size = (n * k) &lt;&lt; 1;
    for (int i = 1; i &lt;= size; i ++)
    {
        A[i] = getint();
        Max = max(Max, A[i]);
    }
    sort(A + 1, A + size + 1);
    int l = A[2] - A[1], r = Max;
    while (l &lt; r)
    {
        int mid = (l + r) &gt;&gt; 1;
        if (Judge(mid)) r = mid;
            else l = mid + 1;
    }
    printf(&quot;%d\n&quot;, l);
    return 0;
}<pre><h2>Problem3973</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
#define mp make_pair
#define fi first
#define se second
const DD eps=1e-7;
const int NN=111;
int n;
DD R;
inline int dcmp(DD x)
{
	if (fabs(x)&lt;eps) return 0;
	return x&lt;0?-1:1;
}
struct point
{
	DD x,y;
	inline void in() {scanf(&quot;%lf%lf&quot;,&amp;x,&amp;y);}
} q[NN];
DD f(DD x)
{
	static pair&lt;DD,bool&gt; b[NN];
	int cnt=0,i;
	for (i=1;i&lt;=n;i++)
	{
		DD l=min(q[i].x,q[i+1].x),r=max(q[i].x,q[i+1].x);
		if (x&lt;l||x&gt;r) continue;
		point A=q[i],B=q[i+1];
		if (A.x&gt;B.x) swap(A,B);
		DD k=(B.y-A.y)/(B.x-A.x);
		b[++cnt]=mp(A.y+k*(x-A.x),true);
	}
	b[++cnt]=mp(sqrt(R*R-x*x),false);
	sort(b+1,b+cnt+1);
	if (!b[1].se) return 0;
	DD ans=0;
	bool ok=true;
	for (i=2;i&lt;=cnt;i++)
	{
		if (ok) ans+=b[i].fi-b[i-1].fi;
		if (!b[i].se) break;
		ok^=1;
	}
	return ans;
}
inline DD simpson(DD l,DD fl,DD r,DD fr,DD fmid)
{
	return (r-l)*(fl+4*fmid+fr)/6;
}
DD calc(DD l,DD fl,DD r,DD fr,DD mid,DD fmid,DD s)
{
	DD lmid=(l+mid)*0.5,rmid=(mid+r)*0.5;
	DD flmid=f(lmid),frmid=f(rmid);
	DD ls=simpson(l,fl,mid,fmid,flmid),rs=simpson(mid,fmid,r,fr,frmid);
	if (dcmp(ls+rs-s)==0&amp;&amp;(r-l&lt;0.5)) return s;
	return calc(l,fl,mid,fmid,lmid,flmid,ls)+calc(mid,fmid,r,fr,rmid,frmid,rs);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%lf&quot;,&amp;n,&amp;R);
	for (int i=1;i&lt;=n;i++) q[i].in();
	q[n+1]=q[1];
	//printf(&quot;%.3f\n&quot;,f(-7.967));
	DD l=-R,r=R+0.02,mid=(l+r)*0.5;
	DD fl=f(l),fr=f(r),fmid=f(mid);
	printf(&quot;%.9f\n&quot;,calc(l,fl,r,fr,mid,fmid,simpson(l,fl,r,fr,fmid)));
	return 0;
}<pre><h2>Problem3973</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef double DD;
#define mp make_pair
#define fi first
#define se second
const DD eps=1e-7;
const int NN=111;
int n;
DD R;
inline int dcmp(DD x)
{
	if (fabs(x)&lt;eps) return 0;
	return x&lt;0?-1:1;
}
struct point
{
	DD x,y;
	inline void in() {scanf(&quot;%lf%lf&quot;,&amp;x,&amp;y);}
} q[NN];
DD f(DD x)
{
	static pair&lt;DD,bool&gt; b[NN];
	int cnt=0,i;
	for (i=1;i&lt;=n;i++)
	{
		DD l=min(q[i].x,q[i+1].x),r=max(q[i].x,q[i+1].x);
		if (x&lt;l||x&gt;r) continue;
		point A=q[i],B=q[i+1];
		if (A.x&gt;B.x) swap(A,B);
		DD k=(B.y-A.y)/(B.x-A.x);
		b[++cnt]=mp(A.y+k*(x-A.x),true);
	}
	b[++cnt]=mp(sqrt(R*R-x*x),false);
	sort(b+1,b+cnt+1);
	if (!b[1].se) return 0;
	DD ans=0;
	bool ok=true;
	for (i=2;i&lt;=cnt;i++)
	{
		if (ok) ans+=b[i].fi-b[i-1].fi;
		if (!b[i].se) break;
		ok^=1;
	}
	return ans;
}
inline DD simpson(DD l,DD fl,DD r,DD fr,DD fmid)
{
	return (r-l)*(fl+4*fmid+fr)/6;
}
DD calc(DD l,DD fl,DD r,DD fr,DD mid,DD fmid,DD s)
{
	DD lmid=(l+mid)*0.5,rmid=(mid+r)*0.5;
	DD flmid=f(lmid),frmid=f(rmid);
	DD ls=simpson(l,fl,mid,fmid,flmid),rs=simpson(mid,fmid,r,fr,frmid);
	if (dcmp(ls+rs-s)==0&amp;&amp;(r-l&lt;0.5)) return s;
	return calc(l,fl,mid,fmid,lmid,flmid,ls)+calc(mid,fmid,r,fr,rmid,frmid,rs);
}
int main()
{
	scanf(&quot;%d%lf&quot;,&amp;n,&amp;R);
	for (int i=1;i&lt;=n;i++) q[i].in();
	q[n+1]=q[1];
	DD l=-R,r=R+0.02,mid=(l+r)*0.5;
	DD fl=f(l),fr=f(r),fmid=f(mid);
	printf(&quot;%.9f\n&quot;,calc(l,fl,r,fr,mid,fmid,simpson(l,fl,r,fr,fmid)));
	return 0;
}<pre><h2>Problem3990</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;
inline int read()
{
	int ret=0,f=1; char ch;
	for (ch=getchar();ch&lt;'0'||ch&gt;'0';ch=getchar())
	if (ch=='-') f=-f;
	for (;'0'&lt;=ch &amp;&amp; ch&lt;='9';ch=getchar()) ret=ret*10+ch-48;
	return ret;
}
const int N = (1&lt;&lt;12)+30;
int a[N],n,k,d,pos[10],now,vis[N],R[20];
long long ans;
inline int count(int k){
	int ret=0;
	while (k){
		k-=k&amp;-k;
		ret++;
	}
	return ret;
}
inline void swap(int x,int y,int t){
	for (int i=0;i&lt;t;i++)
	swap(a[x+i],a[y+i]);
}
int dfs(int i,int now){
	if (i==d){
		for (int j=0;j&lt;d;j++) if (a[j]!=j+1) return 0;
		vis[now]=1;
		return 1;
	}
	int cnt=0;
	int pos[4];
	for (int j=0;j&lt;d;j+=i&lt;&lt;1){
		if (a[i+j]!=a[j]+i){
			pos[++cnt]=j;
			if (cnt&gt;=3){
				return 0;
			}
		}
	}
	if (cnt==0) return dfs(i*2,now);
	if (cnt==1){
		swap(pos[1],pos[1]+i,i);
		if (a[pos[1]]+i==a[pos[1]]+i) dfs(i*2,now|i);
		swap(pos[1],pos[1]+i,i);
	}else{
		swap(pos[1],pos[2],i);
		if (a[pos[1]+i]==a[pos[1]]+i &amp;&amp; a[pos[2]+i]==a[pos[2]]+i){
			dfs(i*2,now|i) ;
		}
		swap(pos[1],pos[2],i);
		swap(pos[1],pos[2]+i,i);
		if (a[pos[1]+i]==a[pos[1]]+i &amp;&amp; a[pos[2]+i]==a[pos[2]]+i){
			dfs(i*2,now|i);
		}
		swap(pos[1],pos[2]+i,i);
		swap(pos[1]+i,pos[2],i);
		if (a[pos[1]+i]==a[pos[1]]+i &amp;&amp; a[pos[2]+i]==a[pos[2]]+i){
			dfs(i*2,now|i);
		}
		swap(pos[1]+i,pos[2],i);
		swap(pos[1]+i,pos[2]+i,i);
		if (a[pos[1]+i]==a[pos[1]]+i &amp;&amp; a[pos[2]+i]==a[pos[2]]+i){
			dfs(i*2,now|i);
		}
		swap(pos[1]+i,pos[2]+i,i);
	}
	return 0;
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n); d=1&lt;&lt;n;
	for (int i=0;i&lt;d;i++)
		scanf(&quot;%d&quot;,a+i);
	dfs(1,0);
	int flag=0;
	R[0]=1;
	for (int i=1;i&lt;=n;i++) R[i]=(R[i-1]*i);
	for (int i=0;i&lt;=d;i++){
		if (vis[i]==1){
			ans+=R[count(i)];
		}
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem3991</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
using namespace std;
#define inf 999999999
typedef long long LL;
const int NN=101111;
int tmin[NN],tmax[NN],key[NN],tag[NN],o[NN],aa[NN*2][3],fa[NN],son[NN][2];
int n,m,tot=1;
LL dist[NN],dd[NN],tsum[NN];
bool rrr[NN],w[NN];
set&lt;int&gt; S;
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void prepare()
{
	static int q[NN];
	int head=0,tail=1;
	q[1]=1;
	while (head&lt;tail)
	{
		int x=q[++head];
		rrr[x]=true;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[x]) continue;
			fa[y]=x;
			dist[y]=dist[x]+aa[p][2];
			dd[y]=tsum[y]=aa[p][2];
			q[++tail]=y;
		}
	}
	tmin[0]=inf,tmax[0]=-inf;
}
inline void add(int t,int x)
{
	key[t]+=x,tag[t]+=x;
	tmin[t]+=x,tmax[t]+=x;
}
inline void pushdown(int t)
{
	if (tag[t]==0) return;
	add(son[t][0],tag[t]),add(son[t][1],tag[t]);
	tag[t]=0;
}
inline void update(int t)
{
	int x=son[t][0],y=son[t][1];
	tsum[t]=tsum[x]+tsum[y]+dd[t];
	tmin[t]=min(key[t],min(tmin[x],tmin[y]));
	tmax[t]=max(key[t],max(tmax[x],tmax[y]));
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
	else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
}
void access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
}
LL calc(int t)
{
	access(t),splay(t);
	while (t)
	{
		pushdown(t);
		if (tmin[son[t][0]]==0) t=son[t][0];
		else if (key[t]==0) break;
		else t=son[t][1];
	}
	if (t==0) return 0;
	splay(t);
	return tsum[t]-tsum[son[t][0]];
}
int getlca()
{
	int t=*S.begin(),tot=S.size();
	if (t==0) return 0;
	access(t),splay(t);
	while (t)
	{
		pushdown(t);
		if (tmax[son[t][1]]==tot) t=son[t][1];
		else if (key[t]==tot) break;
		else t=son[t][0];
	}
	return t;
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
	}
	prepare();
	LL now=0;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		if (!w[x])
		{
			now+=calc(x);
			access(x),splay(x);
			add(x,1);
			S.insert(x);
		}
		else
		{
			access(x),splay(x);
			add(x,-1);
			now-=calc(x);
			S.erase(x);
		}
		w[x]=!w[x];
		int lca=getlca();
		printf(&quot;%lld\n&quot;,(now-dist[lca])*2);
	}
	return 0;
}<pre><h2>Problem3992</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define mo 1004535809
#define ln printf(&quot;\n&quot;)
int n,m,X,S,N;
inline LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
int getyg(int n)
{
	static int ys[8111];
	int cnt=0,i,j;
	for (i=2;i*i&lt;=n;i++) if ((n-1)%i==0)
	{
		ys[++cnt]=i;
		if (i*i!=n-1) ys[++cnt]=(n-1)/i;
	}
	for (i=2;;i++)
	{
		for (j=1;j&lt;=cnt;j++)
			if (ksm(i,ys[j],n)==1) break;
		if (j==cnt+1) break;
	}
	return i;
}
void ntt(LL *a,int f)
{
	int i,j,k; LL w,wn;
	for (i=1,j=N&gt;&gt;1;i&lt;N-1;i++)
	{
		if (i&lt;j) swap(a[i],a[j]);
		for (k=N&gt;&gt;1;j&gt;=k;k&gt;&gt;=1) j-=k;
		j+=k;
	}
	for (i=2;i&lt;=N;i&lt;&lt;=1)
	{
		if (f==1) wn=ksm(3,(mo-1)/i,mo);
		else wn=ksm(3,mo-1-(mo-1)/i,mo);
		for (j=0;j&lt;N;j+=i)
		{
			w=1;
			for (k=j;k&lt;j+i/2;k++,w=w*wn%mo)
			{
				LL x=a[k],y=a[k+i/2]*w%mo;
				a[k]=x+y;
				if (a[k]&gt;=mo) a[k]-=mo;
				a[k+i/2]=x-y;
				if (a[k+i/2]&lt;0) a[k+i/2]+=mo;
			}
		}
	}
	if (f==-1)
		for (i=0;i&lt;N;i++) a[i]=a[i]*ksm(N,mo-2,mo)%mo;
}
void huifu(LL *a)
{
	for (int i=m-1;i&lt;2*(m-1)-1;i++)
	{
		a[i-(m-1)]+=a[i];
		if (a[i-(m-1)]&gt;=mo) a[i-(m-1)]-=mo;
		a[i]=0;
	}
}
int main()
{
	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;X,&amp;S);
	int rt=getyg(m),now=1,i,x;
	static int dy[8001];
	for (i=0;i&lt;m-1;i++)
	{
		dy[now]=i;
		now=now*rt%m;
	}
	X=dy[X];
	static LL a[32111],ans[32111];
	for (i=1;i&lt;=S;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		if (x==0) continue;
		a[dy[x]]++;
	}
	for (N=1;N&lt;2*(m-1)-1;N&lt;&lt;=1);
	ans[0]=1;
	for (;n;n&gt;&gt;=1)
	{
		ntt(a,1);
		if (n&amp;1)
		{
			ntt(ans,1);
			for (i=0;i&lt;N;i++) ans[i]=ans[i]*a[i]%mo;
			ntt(ans,-1);
			huifu(ans);
		}
		for (i=0;i&lt;N;i++) a[i]=a[i]*a[i]%mo;
		ntt(a,-1);
		huifu(a);
	}
	printf(&quot;%lld\n&quot;,ans[X]);
	return 0;
}<pre><h2>Problem3993</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
typedef double DD;
typedef long double LD;
const LD eps=1e-9;
const int NN=211,MM=11111;
int o[NN],cur[NN],aa[MM*2][2],q[NN],deep[NN];
int n,m,tot,S,T;
LD cc[MM*2],A[NN],B[NN],sum;
bool can[NN][NN];
inline void addedge(int p,int q,LD v)
{
	tot++;
	aa[tot][1]=q;
	cc[tot]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline void add(int p,int q,LD v)
{
	addedge(p,q,v);
	addedge(q,p,0);
}
bool bfs()
{
	int head=0,tail=1;
	q[1]=S;
	memset(deep,0,sizeof(deep));
	deep[S]=1;
	while (head&lt;tail)
	{
		int x=q[++head];
		cur[x]=o[x];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (cc[p]&gt;eps&amp;&amp;!deep[y])
				deep[y]=deep[x]+1,q[++tail]=y;
		}
	}
	return deep[T];
}
LD dfs(int v,LD f)
{
	if (v==T) return f;
	LD res=0;
	for (int &amp;p=cur[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (cc[p]&lt;eps||deep[y]!=deep[v]+1) continue;
		LD tmp=dfs(y,min(cc[p],f));
		f-=tmp,cc[p]-=tmp;
		cc[p^1]+=tmp,res+=tmp;
		if (f&lt;eps) break;
	}
	if (res&lt;eps) deep[v]=inf;
	return res;
}
bool check(LD x)
{
	memset(o,0,sizeof(o));tot=1;
	S=n+m+1,T=S+1;
	int i,j;
	for (i=1;i&lt;=m;i++) add(S,i,B[i]*x);
	for (i=1;i&lt;=n;i++) add(i+m,T,A[i]);
	for (i=1;i&lt;=m;i++)
		for (j=1;j&lt;=n;j++)
			if (can[i][j]) add(i,j+m,inf);
	LD ans=0;
	while (bfs()) ans+=dfs(S,inf);
	if (fabs(sum-ans)&lt;eps) return true;
	return false;
}
int main()
{
	//freopen(&quot;war.in&quot;,&quot;r&quot;,stdin);freopen(&quot;war.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	sum=0;
	int i,j,x;DD xx;
	for (i=1;i&lt;=n;i++)
		scanf(&quot;%lf&quot;,&amp;xx),A[i]=xx,sum+=A[i];
	for (i=1;i&lt;=m;i++)
		scanf(&quot;%lf&quot;,&amp;xx),B[i]=xx;
	for (i=1;i&lt;=m;i++)
		for (j=1;j&lt;=n;j++)
		{
			scanf(&quot;%d&quot;,&amp;x);
			can[i][j]=x;
		}
	LD l=0,r=inf;
	while (r-l&gt;0.0000001)
	{
		LD mid=(l+r)*0.5;
		if (check(mid)) r=mid;
		else l=mid;
	}
	printf(&quot;%.6f\n&quot;,(DD)l);
	return 0;
}<pre><h2>Problem3994</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int NN=51111;
int pr[NN],d[NN],miu[NN],num[NN],g[NN],sum[NN];
int n,m,tes,prcnt;
void shai()
{
	static bool vt[NN];
	vt[1]=true;
	d[1]=1;
	miu[1]=1;
	int i,j;
	for (i=2;i&lt;=50000;i++)
	{
		if (!vt[i])
		{
			pr[++prcnt]=i;
			d[i]=2;
			miu[i]=-1;
			num[i]=1;
		}
		for (j=1;j&lt;=prcnt;j++)
		{
			int x=i*pr[j];
			if (x&gt;50000) break;
			vt[x]=true;
			if (i%pr[j]==0)
			{
				num[x]=num[i]+1;
				d[x]=d[i]/(num[i]+1)*(num[x]+1);
				miu[x]=0;
				break;
			}
			num[x]=1;
			d[x]=d[i]*2;
			miu[x]=-miu[i];
		}
	}
	for (i=1;i&lt;=50000;i++)
	{
		sum[i]=sum[i-1]+miu[i];
		g[i]=g[i-1]+d[i];
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	shai();
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		if (n&gt;m) {int t=n;n=m;m=t;}
		int l,r;LL ans=0;
		for (l=1;l&lt;=n;l=r+1)
		{
			r=min(n/(n/l),m/(m/l));
			ans+=(LL)(sum[r]-sum[l-1])*g[n/l]*g[m/l];
		}
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem3998</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=501111,AA=1001111;
int val[AA],pre[AA],son[AA][26],right[AA],dp[AA];
int n,kind,K,last,TTT;
char s[NN];
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);ln;}
void samadd(int x)
{
	int end=++TTT,p=last;
	last=end;
	val[end]=val[p]+1;
	for (;p!=-1&amp;&amp;!son[p][x];p=pre[p]) son[p][x]=end;
	if (p==-1) {pre[end]=0;return;}
	int q=son[p][x];
	if (val[q]==val[p]+1) {pre[end]=q;return;}
	int nq=++TTT;
	val[nq]=val[p]+1;
	pre[nq]=pre[q];
	pre[q]=pre[end]=nq;
	memcpy(son[nq],son[q],sizeof(son[q]));
	for (;p!=-1&amp;&amp;son[p][x]==q;p=pre[p]) son[p][x]=nq;
}
void calcright()
{
	static int sum[AA],b[AA];
	int i;
	for (i=1;i&lt;=TTT;i++) sum[val[i]]++;
	for (i=2;i&lt;=n;i++) sum[i]+=sum[i-1];
	for (i=TTT;i;i--) b[sum[val[i]]--]=i;
	int x=0;
	for (i=1;i&lt;=n;i++)
		x=son[x][s[i]-'a'],right[x]=1;
	for (i=TTT;i;i--) right[pre[b[i]]]+=right[b[i]];
}
int DP(int x)
{
	if (dp[x]) return dp[x];
	dp[x]=(kind==0)?1:right[x];
	for (int i=0;i&lt;26;i++)
		if (son[x][i]) dp[x]+=DP(son[x][i]);
	return dp[x];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	char ch=getchar();
	while (ch!='\n') s[++n]=ch,ch=getchar();
	int i;
	pre[0]=-1;
	for (i=1;i&lt;=n;i++) samadd(s[i]-'a');
	scanf(&quot;%d%d&quot;,&amp;kind,&amp;K);
	if (kind==1) calcright();
	DP(0);
	if (dp[0]&lt;K) {printf(&quot;-1\n&quot;);return 0;}
	int x=0,len=0;
	K+=(kind==0)?1:right[0];
	//for(i=0;i&lt;=TTT;i++)out(son[i],0,26);ln;printf(&quot;right &quot;);out(right,0,TTT);ln;
	for (;;)
	{
		K-=(kind==0)?1:right[x];
		if (K==0) {s[len+1]=s[0];break;}
		for (i=0;i&lt;26;i++)
		{
			int y=son[x][i];
			if (!y) continue;
			if (K&gt;dp[y]) K-=dp[y];
			else
			{
				s[++len]='a'+i,x=son[x][i];
				break;
			}
		}
	}
	//ln;ln;
	printf(&quot;%s\n&quot;,s+1);
	return 0;
}<pre><h2>Problem3998</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int NN=500005,AA=1000005;
int val[AA],pre[AA],son[AA][26],right[AA],dp[AA];
int n,kind,K,last,TTT;
char s[NN];
void samadd(int x)
{
	int end=++TTT,p=last;
	last=end;
	val[end]=val[p]+1;
	for (;p!=-1&amp;&amp;!son[p][x];p=pre[p]) son[p][x]=end;
	if (p==-1) {pre[end]=0;return;}
	int q=son[p][x];
	if (val[q]==val[p]+1) {pre[end]=q;return;}
	int nq=++TTT;
	val[nq]=val[p]+1;
	pre[nq]=pre[q];
	pre[q]=pre[end]=nq;
	memcpy(son[nq],son[q],sizeof(son[q]));
	for (;p!=-1&amp;&amp;son[p][x]==q;p=pre[p]) son[p][x]=nq;
}
void calcright()
{
	static int sum[AA],b[AA];
	int i;
	for (i=1;i&lt;=TTT;i++) sum[val[i]]++;
	for (i=2;i&lt;=n;i++) sum[i]+=sum[i-1];
	for (i=TTT;i;i--) b[sum[val[i]]--]=i;
	int x=0;
	for (i=1;i&lt;=n;i++)
		x=son[x][s[i]-'a'],right[x]=1;
	for (i=TTT;i;i--) right[pre[b[i]]]+=right[b[i]];
}
int DP(int x)
{
	if (dp[x]) return dp[x];
	dp[x]=(kind==0)?1:right[x];
	for (int i=0;i&lt;26;i++)
		if (son[x][i]) dp[x]+=DP(son[x][i]);
	return dp[x];
}
int main()
{
	char ch=getchar();
	while (ch!='\n') s[++n]=ch,ch=getchar();
	int i;
	pre[0]=-1;
	for (i=1;i&lt;=n;i++) samadd(s[i]-'a');
	scanf(&quot;%d%d&quot;,&amp;kind,&amp;K);
	if (kind==1) calcright();
	DP(0);
	if (dp[0]&lt;K) {printf(&quot;-1\n&quot;);return 0;}
	int x=0,len=0;
	K+=(kind==0)?1:right[0];
	for (;;)
	{
		K-=(kind==0)?1:right[x];
		if (K==0) {s[len+1]=s[0];break;}
		for (i=0;i&lt;26;i++)
		{
			int y=son[x][i];
			if (!y) continue;
			if (K&gt;dp[y]) K-=dp[y];
			else
			{
				s[++len]='a'+i,x=son[x][i];
				break;
			}
		}
	}
	printf(&quot;%s\n&quot;,s+1);
	return 0;
}<pre><h2>Problem3998</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int NN=500005,AA=1000005;
int val[AA],pre[AA],son[AA][26],right[AA],dp[AA];
int n,kind,K,last,TTT;
char s[NN];
void samadd(int x)
{
	int end=++TTT,p=last;
	last=end;
	val[end]=val[p]+1;
	for (;p!=-1&amp;&amp;!son[p][x];p=pre[p]) son[p][x]=end;
	if (p==-1) {pre[end]=0;return;}
	int q=son[p][x];
	if (val[q]==val[p]+1) {pre[end]=q;return;}
	int nq=++TTT;
	val[nq]=val[p]+1;
	pre[nq]=pre[q];
	pre[q]=pre[end]=nq;
	memcpy(son[nq],son[q],sizeof(son[q]));
	for (;p!=-1&amp;&amp;son[p][x]==q;p=pre[p]) son[p][x]=nq;
}
void calcright()
{
	static int sum[AA],b[AA];
	int i;
	for (i=1;i&lt;=TTT;i++) sum[val[i]]++;
	for (i=2;i&lt;=n;i++) sum[i]+=sum[i-1];
	for (i=TTT;i;i--) b[sum[val[i]]--]=i;
	int x=0;
	for (i=1;i&lt;=n;i++)
	{
		x=son[x][s[i]-'a'];
		right[x]=1;
	}
	for (i=TTT;i;i--) right[pre[b[i]]]+=right[b[i]];
}
int DP(int x)
{
	if (dp[x]) return dp[x];
	dp[x]=(kind==0)?1:right[x];
	for (int i=0;i&lt;26;i++)
		if (son[x][i]) dp[x]+=DP(son[x][i]);
	return dp[x];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	char ch=getchar();
	while (ch!='\n') s[++n]=ch,ch=getchar();
	int i;
	pre[0]=-1;
	for (i=1;i&lt;=n;i++) samadd(s[i]-'a');
	scanf(&quot;%d%d&quot;,&amp;kind,&amp;K);
	if (kind==1) calcright();
	DP(0);
	if (dp[0]&lt;K) {printf(&quot;-1\n&quot;);return 0;}
	int x=0,len=0;
	K+=(kind==0)?1:right[0];
	for (;;)
	{
		K-=(kind==0)?1:right[x];
		if (K==0) {s[len+1]=s[0];break;}
		for (i=0;i&lt;26;i++)
		{
			int y=son[x][i];
			if (!y) continue;
			if (K&gt;dp[y]) K-=dp[y];
			else
			{
				s[++len]='a'+i,x=son[x][i];
				break;
			}
		}
	}
	printf(&quot;%s\n&quot;,s+1);
	return 0;
}<pre><h2>Problem4001</h2><pre>#include&lt;cstdio&gt;
using namespace std;

int main()
{
	double n;
	scanf(&quot;%lf&quot;,&amp;n);
	printf(&quot;%.9f\n&quot;,n*(n+1)/(4*n-2));
	return 0;
}<pre><h2>Problem4009</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 1000000005
const int NN=40111,AA=10000000;
int st[NN],ed[NN],o[NN],aa[NN&lt;&lt;1][2],root[NN],deep[NN],fa[NN];
int lc[AA],rc[AA],size[AA],ans[NN],f[NN][18];
int n,m,Q,tot=1,TTT,cnt;
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs()
{
	static int sta[NN],cur[NN];
	int top=1;
	sta[1]=1;
	cur[1]=o[1];
	deep[1]=1;
	st[1]=++cnt;
	while (top)
	{
		int v=sta[top];
		int p=cur[v];
		if (!p)
		{
			ed[v]=cnt;
			top--;
			continue;
		}
		cur[v]=aa[p][0];
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		st[y]=++cnt;
		cur[y]=o[y];
		sta[++top]=y;
	}
}
inline int getlca(int x,int y)
{
	if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
	for (int i=17;i&gt;=0;i--)
		if (deep[f[x][i]]&gt;=deep[y]) x=f[x][i];
	if (x==y) return x;
	for (int i=17;i&gt;=0;i--)
		if (f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
	return f[x][0];
}
inline int goup(int x,int dep)
{
	int t=deep[x]-dep;
	for (int i=17;i&gt;=0;i--)
		if (deep[f[x][i]]&gt;=t) x=f[x][i];
	return x;
}
struct info
{
	int kind,x,y,y2,w;
	friend bool operator &lt;(const info &amp;a,const info &amp;b)
	{
		if (a.x!=b.x) return a.x&lt;b.x;
		return a.kind&lt;b.kind;
	}
} q[NN*6];
inline void add(int x1,int x2,int y1,int y2,int w)
{
	if (x1&gt;x2||y1&gt;y2) return;
	q[++cnt].kind=1;
	q[cnt].x=x1,q[cnt].y=y1,q[cnt].y2=y2,q[cnt].w=w;
	q[++cnt].kind=2;
	q[cnt].x=x2+1,q[cnt].y=y1,q[cnt].y2=y2,q[cnt].w=w;
}
void ins(int &amp;v,int l,int r,int x,int kind)
{
	if (!v) v=++TTT;
	size[v]+=kind;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (x&lt;mid) ins(lc[v],l,mid,x,kind);
	else ins(rc[v],mid,r,x,kind);
}
inline void change(int i,int x,int kind)
{
	for (;i&lt;=n;i+=i&amp;-i)
		ins(root[i],0,inf,x,kind);
}
inline int getkth(int pos,int K)
{
	static int cur[NN],i;
	for (i=pos;i;i-=i&amp;-i) cur[i]=root[i];
	int l=0,r=inf;
	while (r-l&gt;1)
	{
		int tmp=0,mid=(l+r)&gt;&gt;1;
		for (i=pos;i;i-=i&amp;-i) tmp+=size[lc[cur[i]]];
		if (K&lt;=tmp)
		{
			r=mid;
			for (i=pos;i;i-=i&amp;-i) cur[i]=lc[cur[i]];
		}
		else
		{
			l=mid;
			for (i=pos;i;i-=i&amp;-i) cur[i]=rc[cur[i]];
			K-=tmp;
		}
	}
	return l;
}
int main()
{
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;Q);
	int i,j,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	dfs();
	for (i=1;i&lt;=n;i++) f[i][0]=fa[i];
	for (j=1;j&lt;=17;j++)
		for (i=1;i&lt;=n;i++) f[i][j]=f[f[i][j-1]][j-1];
	cnt=0;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		if (st[x]&gt;st[y]) {int t=x;x=y;y=t;}
		int lca=getlca(x,y);
		if (lca!=x) add(st[x],ed[x],st[y],ed[y],z);
		else
		{
			int p=goup(y,deep[y]-deep[x]-1);
			add(1,st[p]-1,st[y],ed[y],z);
			add(st[y],ed[y],ed[p]+1,n,z);
		}
	}
	for (i=1;i&lt;=Q;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		if (st[x]&gt;st[y]) {int t=x;x=y;y=t;}
		q[++cnt].kind=3;
		q[cnt].x=st[x],q[cnt].y=st[y],q[cnt].w=z;q[cnt].y2=i;
	}
	sort(q+1,q+cnt+1);
	for (i=1;i&lt;=cnt;i++)
	{
		if (q[i].kind==1)
		{
			change(q[i].y,q[i].w,1);
			change(q[i].y2+1,q[i].w,-1);
		}
		else if (q[i].kind==2)
		{
			change(q[i].y,q[i].w,-1);
			change(q[i].y2+1,q[i].w,1);
		}
		else ans[q[i].y2]=getkth(q[i].y,q[i].w);
	}
	for (i=1;i&lt;=Q;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem4010</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define lc (v&lt;&lt;1)
#define rc (v&lt;&lt;1|1)
#define inf 999999999
const int NN=1001111;
int o[NN],du[NN],aa[NN][2],tmin[NN*4],ans[NN];
int tes,n,m,tot;
inline void addedge(int p,int q)
{
	du[q]++;
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline void update(int v)
{
	tmin[v]=min(tmin[lc],tmin[rc]);
}
void build(int v,int l,int r)
{
	if (r-l==1)
	{
		tmin[v]=du[l];
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(lc,l,mid);
	build(rc,mid,r);
	update(v);
}
void change(int v,int l,int r,int i,int x)
{
	if (r-l==1)
	{
		tmin[v]=x;
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid) change(lc,l,mid,i,x);
	else change(rc,mid,r,i,x);
	update(v);
}
int find(int v,int l,int r)
{
	if (r-l==1) return l;
	int mid=(l+r)&gt;&gt;1;
	if (tmin[rc]==0) return find(rc,mid,r);
	else return find(lc,l,mid);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		memset(o,0,sizeof(o));
		memset(du,0,sizeof(du));
		int i,x,y;
		for (i=1;i&lt;=m;i++)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			addedge(y,x);
		}
		build(1,1,n+1);
		bool flag=true;
		for (i=1;i&lt;=n;i++)
		{
			if (tmin[1]&gt;0) {flag=false;break;}
			x=find(1,1,n+1);
			ans[i]=x;
			change(1,1,n+1,x,inf);
			for (int p=o[x];p;p=aa[p][0])
			{
				int y=aa[p][1];
				change(1,1,n+1,y,--du[y]);
			}
		}
		if (!flag) printf(&quot;Impossible!&quot;);
		else for (i=n;i;i--) printf(&quot;%d &quot;,ans[i]);
		printf(&quot;\n&quot;);
	}
	return 0;
}<pre><h2>Problem4010</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define lc (v&lt;&lt;1)
#define rc (v&lt;&lt;1|1)
#define inf 999999999
const int NN=101111;
int o[NN],du[NN],aa[NN][2],tmin[NN*4],ans[NN];
int tes,n,m,tot;
inline void addedge(int p,int q)
{
	du[q]++;
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline void update(int v)
{
	tmin[v]=min(tmin[lc],tmin[rc]);
}
void build(int v,int l,int r)
{
	if (r-l==1)
	{
		tmin[v]=du[l];
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(lc,l,mid);
	build(rc,mid,r);
	update(v);
}
void change(int v,int l,int r,int i,int x)
{
	if (r-l==1)
	{
		tmin[v]=x;
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid) change(lc,l,mid,i,x);
	else change(rc,mid,r,i,x);
	update(v);
}
int find(int v,int l,int r)
{
	if (r-l==1) return l;
	int mid=(l+r)&gt;&gt;1;
	if (tmin[rc]==0) return find(rc,mid,r);
	else return find(lc,l,mid);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		memset(o,0,sizeof(o));tot=0;
		memset(du,0,sizeof(du));
		int i,x,y;
		for (i=1;i&lt;=m;i++)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			addedge(y,x);
		}
		build(1,1,n+1);
		bool flag=true;
		for (i=1;i&lt;=n;i++)
		{
			if (tmin[1]&gt;0) {flag=false;break;}
			x=find(1,1,n+1);
			ans[i]=x;
			change(1,1,n+1,x,inf);
			for (int p=o[x];p;p=aa[p][0])
			{
				int y=aa[p][1];
				change(1,1,n+1,y,--du[y]);
			}
		}
		if (!flag) printf(&quot;Impossible!&quot;);
		else for (i=n;i;i--) printf(&quot;%d &quot;,ans[i]);
		printf(&quot;\n&quot;);
	}
	return 0;
}<pre><h2>Problem4010</h2><pre>program topo_heap;
const
  s1='Impossible!';
var
  d,n,m,x,y,i:longint;
  tot,qaq:longint;
  aa:array[0..200000,0..1] of longint;
  o,inn,order:array[0..200000] of longint;
  heap:array[0..200000] of longint;

  cnt:longint;
  procedure add(x,y:longint);
    begin
      inc(tot);
      aa[tot,0]:=o[x];
      aa[tot,1]:=y;
      o[x]:=tot;
      inc(inn[y]);
    end;
  procedure down(i:longint);
    var
      j,t:longint;
    begin
      while (i&lt;=(cnt&gt;&gt;1)) do
        begin
          j:=i&lt;&lt;1;
          if (j&lt;cnt) and (heap[j+1]&gt;heap[j]) then inc(j);
          if heap[j]&gt;heap[i] then
            begin
              t:=heap[i];
              heap[i]:=heap[j];
              heap[j]:=t;
              i:=j;
            end
          else break;
        end;
    end;
  procedure up(i:longint);
    var
      j,t:longint;
    begin
      while (i&gt;=2) do
        begin
          j:=i&gt;&gt;1;
          if heap[i]&gt;heap[j] then
            begin
              t:=heap[i];
              heap[i]:=heap[j];
              heap[j]:=t;
              i:=j;
            end
          else break;
        end;
    end;
  procedure topo;
    var
      t,k,now:longint;
    begin
      while (qaq&lt;n)and(cnt&gt;0) do
        begin
          now:=heap[1];
          inc(qaq);
          order[qaq]:=now;
          heap[1]:=heap[cnt];
          dec(cnt);
          down(1);
          k:=o[now];
          while k&lt;&gt;0 do
            begin
              t:=aa[k,1];
              dec(inn[t]);
              if inn[t]=0 then
                begin
                  inc(cnt);
                  heap[cnt]:=t;
                  up(cnt);
                end;
              k:=aa[k,0];
            end;
        end;
    end;

  procedure work;
    var
      i,j:longint;
    begin
      readln(n,m);
      fillchar(heap,sizeof(heap),0);
      qaq:=0;   tot:=0;
      fillchar(aa,sizeof(aa),0);
      fillchar(o,sizeof(o),0);
      fillchar(inn,sizeof(inn),0);
      fillchar(order,sizeof(order),0);
      for i:=1 to m do
        begin
          readln(x,y);
          add(y,x);
        end;
      for i:=1 to n do
        begin
          if inn[i]=0 then
            begin
              inc(cnt);
              heap[cnt]:=i;
            end;
        end;
      for i:=cnt&gt;&gt;1 downto 1 do down(i);
      topo;
      if qaq&lt;n then writeln(s1) else
        begin
          for i:=n downto 1 do write(order[i],' ');
          writeln;
        end;
    end;

begin
  readln(D);
  for i:=1 to D do
    work;
end.
<pre><h2>Problem4010</h2><pre>program topo_heap;
const
  s1='Impossible!';
var
  d,n,m,x,y,i:longint;
  tot,qaq:longint;
  aa:array[0..200000,0..1] of longint;
  o,inn,order:array[0..200000] of longint;
  heap:array[0..200000] of longint;

  cnt:longint;
  procedure add(x,y:longint);
    begin
      inc(tot);
      aa[tot,0]:=o[x];
      aa[tot,1]:=y;
      o[x]:=tot;
      inc(inn[y]);
    end;
  procedure down(i:longint);
    var
      j,t:longint;
    begin
      while (i&lt;=(cnt&gt;&gt;1)) do
        begin
          j:=i&lt;&lt;1;
          if (j&lt;cnt) and (heap[j+1]&gt;heap[j]) then inc(j);
          if heap[j]&gt;heap[i] then
            begin
              t:=heap[i];
              heap[i]:=heap[j];
              heap[j]:=t;
              i:=j;
            end
          else break;
        end;
    end;
  procedure up(i:longint);
    var
      j,t:longint;
    begin
      while (i&gt;=2) do
        begin
          j:=i&gt;&gt;1;
          if heap[i]&gt;heap[j] then
            begin
              t:=heap[i];
              heap[i]:=heap[j];
              heap[j]:=t;
              i:=j;
            end
          else break;
        end;
    end;
  procedure topo;
    var
      t,k,now:longint;
    begin
      while (qaq&lt;n)and(cnt&gt;0) do
        begin
          now:=heap[1];
          inc(qaq);
          order[qaq]:=now;
          heap[1]:=heap[cnt];
          dec(cnt);
          down(1);
          k:=o[now];
          while k&lt;&gt;0 do
            begin
              t:=aa[k,1];
              dec(inn[t]);
              if inn[t]=0 then
                begin
                  inc(cnt);
                  heap[cnt]:=t;
                  up(cnt);
                end;
              k:=aa[k,0];
            end;
        end;
    end;

  procedure work;
    var
      i,j:longint;
    begin
      readln(n,m);
      fillchar(heap,sizeof(heap),0);
      qaq:=0;   tot:=0;
      fillchar(aa,sizeof(aa),0);
      fillchar(o,sizeof(o),0);
      fillchar(inn,sizeof(inn),0);
      fillchar(order,sizeof(order),0);
      for i:=1 to m do
        begin
          readln(x,y);
          add(y,x);
        end;
      for i:=1 to n do
        begin
          if inn[i]=0 then
            begin
              inc(cnt);
              heap[cnt]:=i;
            end;
        end;
      for i:=cnt downto 1 do down(i);
      topo;
      if qaq&lt;n then writeln(s1) else
        begin
          for i:=n downto 1 do write(order[i],' ');
          writeln;
        end;
    end;

begin
  readln(D);
  for i:=1 to D do
    work;
end.
<pre><h2>Problem4012</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
typedef long long LL;
typedef pair&lt;int,LL&gt; pil;
#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define ln printf(&quot;\n&quot;)
const int NN=151111;
int fa[NN],pos[NN],f[21][NN*2],dis[NN],o[NN],aa[NN*2][3],log[NN*2];
int size[NN],deep[NN],boss[NN],age[NN];
int n,m,A,tot=1,cnt;
vector&lt;pil&gt; sum1[NN],sum2[NN];
void out(vector&lt;pil&gt; a){for(int t=a.size(),i=0;i&lt;t;i++)printf(&quot;%d %I64d   &quot;,a[i].fi,a[i].se);ln;}
inline void addedge(int p,int q,int v)
{
	//printf(&quot;addedge %d %d %d\n&quot;,p,q,v);
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs(int v)
{
	f[0][++cnt]=dis[v];
	pos[v]=cnt;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dis[y]=dis[v]+aa[p][2];
		dfs(y);
		f[0][++cnt]=dis[v];
	}
}
inline int dist(int x,int y)
{
	int l=pos[x],r=pos[y];
	if (l&gt;r) {int t=l;l=r;r=t;}
	int t=log[r-l+1];
	return dis[x]+dis[y]-2*min(f[t][l],f[t][r-(1&lt;&lt;t)+1]);
}
void getsize(int v)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||deep[y]&lt;deep[v]) continue;
		fa[y]=v;
		getsize(y);
		size[v]+=size[y];
	}
}
int core(int v)
{
	fa[v]=0,getsize(v);
	for (;;)
	{
		bool flag=false;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (deep[y]&lt;deep[v]) continue;
			if (size[y]*2&gt;size[v])
			{
				size[v]-=size[y];
				size[y]+=size[v];
				v=y;flag=true;break;
			}
		}
		if (!flag) break;
	}
	return v;
}
void work(int v)
{
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]) continue;
		y=core(y);
		deep[y]=deep[v]+1;
		boss[y]=v;
		work(y);
	}
}
void change(int x,int tt)
{
	sum1[x].pb(mp(tt,0));
	for (int y=x;boss[y];y=boss[y])
	{
		int d=dist(x,boss[y]);
		sum1[boss[y]].pb(mp(tt,d));
		sum2[y].pb(mp(tt,d));
	}
}
pil find(vector&lt;pil&gt; &amp;a,int L,int R)
{
	int l,r,mid,res1=-1,res2=-1;
	l=1,r=a.size()-1;
	while (l&lt;=r)
	{
		mid=(l+r)&gt;&gt;1;
		if (a[mid].fi&gt;=L) res1=mid,r=mid-1;
		else l=mid+1;
	}
	if (res1==-1) return mp(0,0);
	res1--;
	l=1,r=a.size()-1;
	while (l&lt;=r)
	{
		mid=(l+r)&gt;&gt;1;
		if (a[mid].fi&lt;=R) res2=mid,l=mid+1;
		else r=mid-1;
	}
	if (res2==-1) return mp(0,0);
	return mp(res2-res1,a[res2].se-a[res1].se);
}
LL query(int x,int L,int R)
{
	LL res=find(sum1[x],L,R).se;
	for (int y=x;boss[y];y=boss[y])
	{
		pil t1=find(sum1[boss[y]],L,R);
		pil t2=find(sum2[y],L,R);
		t1.fi-=t2.fi,t1.se-=t2.se;
		res+=t1.se+(LL)t1.fi*dist(boss[y],x);
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;A);
	int i,j,x,y,z;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;age[i]);
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
	}
	dfs(1);
	for (j=1;j&lt;=20;j++)
		for (i=1;i+(1&lt;&lt;(j-1))&lt;=cnt;i++)
			f[j][i]=min(f[j-1][i],f[j-1][i+(1&lt;&lt;(j-1))]);
	log[1]=0;
	for (i=2;i&lt;=cnt;i++) log[i]=(i==(i&amp;-i))?log[i-1]+1:log[i-1];
	//for(i=1;i&lt;=n;i++)for(j=1;j&lt;=n;j++)printf(&quot;dist[%d][%d]=%d\n&quot;,i,j,dist(i,j));
	memset(deep,60,sizeof(deep));
	int t=core(1);
	deep[t]=1;work(t);
	//printf(&quot;boss &quot;);for(i=1;i&lt;=n;i++)printf(&quot;%d &quot;,boss[i]);ln;
	for (i=1;i&lt;=n;i++)
		sum1[i].pb(mp(-1,0)),sum2[i].pb(mp(-1,0));
	for (i=1;i&lt;=n;i++) change(i,age[i]);
	for (i=1;i&lt;=n;i++)
	{
		sort(sum1[i].begin(),sum1[i].end());
		for (int t=sum1[i].size(),j=1;j&lt;t;j++)
			sum1[i][j].se+=sum1[i][j-1].se;
		sort(sum2[i].begin(),sum2[i].end());
		for (int t=sum2[i].size(),j=1;j&lt;t;j++)
			sum2[i][j].se+=sum2[i][j-1].se;
	}
	LL lastans=0;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		y=(y+lastans)%A,z=(z+lastans)%A;
		if (y&gt;z) {int t=y;y=z;z=t;}
		printf(&quot;%lld\n&quot;,lastans=query(x,y,z));
	}
	return 0;
}<pre><h2>Problem4012</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
typedef long long LL;
typedef pair&lt;int,LL&gt; pil;
#define mp make_pair
#define fi first
#define se second
#define pb push_back
const int NN=151111;
int fa[NN],pos[NN],f[21][NN*2],dis[NN],o[NN],aa[NN*2][3],log[NN*2];
int size[NN],deep[NN],boss[NN],age[NN];
int n,m,A,tot=1,cnt;
vector&lt;pil&gt; sum1[NN],sum2[NN];
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs(int v)
{
	f[0][++cnt]=dis[v];
	pos[v]=cnt;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		dis[y]=dis[v]+aa[p][2];
		dfs(y);
		f[0][++cnt]=dis[v];
	}
}
inline int dist(int x,int y)
{
	int l=pos[x],r=pos[y];
	if (l&gt;r) {int t=l;l=r;r=t;}
	int t=log[r-l+1];
	return dis[x]+dis[y]-2*min(f[t][l],f[t][r-(1&lt;&lt;t)+1]);
}
void getsize(int v)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||deep[y]&lt;deep[v]) continue;
		fa[y]=v;
		getsize(y);
		size[v]+=size[y];
	}
}
int core(int v)
{
	fa[v]=0,getsize(v);
	for (;;)
	{
		bool flag=false;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (deep[y]&lt;deep[v]) continue;
			if (size[y]*2&gt;size[v])
			{
				size[v]-=size[y];
				size[y]+=size[v];
				v=y;flag=true;break;
			}
		}
		if (!flag) break;
	}
	return v;
}
void work(int v)
{
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (deep[y]&lt;deep[v]) continue;
		y=core(y);
		deep[y]=deep[v]+1;
		boss[y]=v;
		work(y);
	}
}
void change(int x,int tt)
{
	sum1[x].pb(mp(tt,0));
	for (int y=x;boss[y];y=boss[y])
	{
		int d=dist(x,boss[y]);
		sum1[boss[y]].pb(mp(tt,d));
		sum2[y].pb(mp(tt,d));
	}
}
pil find(vector&lt;pil&gt; &amp;a,int L,int R)
{
	int l,r,mid,res1=-1,res2=-1;
	l=1,r=a.size()-1;
	while (l&lt;=r)
	{
		mid=(l+r)&gt;&gt;1;
		if (a[mid].fi&gt;=L) res1=mid,r=mid-1;
		else l=mid+1;
	}
	if (res1==-1) return mp(0,0);
	res1--;
	l=1,r=a.size()-1;
	while (l&lt;=r)
	{
		mid=(l+r)&gt;&gt;1;
		if (a[mid].fi&lt;=R) res2=mid,l=mid+1;
		else r=mid-1;
	}
	if (res2==-1) return mp(0,0);
	return mp(res2-res1,a[res2].se-a[res1].se);
}
LL query(int x,int L,int R)
{
	LL res=find(sum1[x],L,R).se;
	for (int y=x;boss[y];y=boss[y])
	{
		pil t1=find(sum1[boss[y]],L,R);
		pil t2=find(sum2[y],L,R);
		t1.fi-=t2.fi,t1.se-=t2.se;
		res+=t1.se+(LL)t1.fi*dist(boss[y],x);
	}
	return res;
}
int main()
{
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;A);
	int i,j,x,y,z;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;age[i]);
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
	}
	dfs(1);
	for (j=1;j&lt;=20;j++)
		for (i=1;i+(1&lt;&lt;(j-1))&lt;=cnt;i++)
			f[j][i]=min(f[j-1][i],f[j-1][i+(1&lt;&lt;(j-1))]);
	log[1]=0;
	for (i=2;i&lt;=cnt;i++) log[i]=(i==(i&amp;-i))?log[i-1]+1:log[i-1];
	memset(deep,60,sizeof(deep));
	int t=core(1);
	deep[t]=1;work(t);
	for (i=1;i&lt;=n;i++)
		sum1[i].pb(mp(-1,0)),sum2[i].pb(mp(-1,0));
	for (i=1;i&lt;=n;i++) change(i,age[i]);
	for (i=1;i&lt;=n;i++)
	{
		sort(sum1[i].begin(),sum1[i].end());
		for (int t=sum1[i].size(),j=1;j&lt;t;j++)
			sum1[i][j].se+=sum1[i][j-1].se;
		sort(sum2[i].begin(),sum2[i].end());
		for (int t=sum2[i].size(),j=1;j&lt;t;j++)
			sum2[i][j].se+=sum2[i][j-1].se;
	}
	LL lastans=0;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		y=(y+lastans)%A,z=(z+lastans)%A;
		if (y&gt;z) {int t=y;y=z;z=t;}
		printf(&quot;%lld\n&quot;,lastans=query(x,y,z));
	}
	return 0;
}<pre><h2>Problem4013</h2><pre>#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N(203);
const int MOD(1e9+7);
typedef long long LL;
struct hh{
    int v,next;
}edges[N];
int n,m,fa[N],en,c[N][N],point[N],e[N][2],tot,f[N][N],g[2][N][N],ans,deg[N];
bool vis[N],ins[N];
inline void addedge(int u,int v){
    edges[++en]=(hh){v,point[u]};
    point[u]=en;deg[v]++;
}
inline int find(int x){
    return fa[x]==x?x:fa[x]=find(fa[x]);
}
inline int add(LL x,LL y){
    x+=y;
    return x&gt;=MOD?x%MOD:x;
}
inline LL mul(LL x,LL y){
    return x*y%MOD;
}
inline int dfs(int t){
    int sz=1,now=1;
    g[0][t][0]=1;
    for(int i(point[t]),v;i;i=edges[i].next,now^=1){
        int tsz=dfs(v=edges[i].v);
        sz+=tsz;
        for(int x(0);x&lt;=sz;x++)
            for(int y(0);y&lt;=sz;y++)
                for(int z(max(x,y));z&lt;=x+y;z++)
                    g[now][t][z]=add(g[now][t][z],mul(mul(c[z][x],c[x][x+y-z]),mul(g[now^1][t][x],f[v][y])));
        memset(g[now^1][t],0,sizeof(g[now^1][t]));
    }
    for(int i(0);i&lt;=sz;i++)f[t][i+1]=g[now^1][t][i];
    return sz;
}
inline bool judge(int x){
    vis[x]=ins[x]=1;
    for(int i(point[x]);i;i=edges[i].next){
        int v(edges[i].v);
        if(vis[v]){if(ins[v])return 1;}
        else if(judge(v))return 1;
    }
    return ins[x]=0;
}
int main(){
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i(1);i&lt;=n;i++)fa[i]=i;
    memset(point,0,sizeof(point));
    for(int i(1),u,v;i&lt;=m;i++){
        char op;
        scanf(&quot;%d %c %d&quot;,&amp;u,&amp;op,&amp;v);
        if(op=='=')fa[find(u)]=find(v);
        else e[++tot][0]=u,e[tot][1]=v;
    }
    for(int i(1);i&lt;=tot;i++)
        addedge(find(e[i][0]),find(e[i][1]));
    for(int i(1);i&lt;=n;i++)
        if(!deg[find(i)])
            addedge(0,find(i)),vis[find(i)]=1;
    for(int i(1);i&lt;=n;i++)if(!vis[i]&amp;&amp;judge(i))return puts(&quot;0&quot;),0;
    for(int i(0);i&lt;=n;i++){
        c[i][0]=1;
        for(int j(1);j&lt;=i;j++)
            c[i][j]=add(c[i-1][j],c[i-1][j-1])%MOD;
    }
    int sz=dfs(0);
    for(int i(0);i&lt;=sz;i++)ans=add(ans,f[0][i]);
    printf(&quot;%d\n&quot;,ans);
    return 0;
}<pre><h2>Problem4017</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define mo 998244353
#define ln printf(&quot;\n&quot;)
const int NN=101111;
int n,a[NN];
LL b[NN];
bool c[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
int work1()
{
	static int sum[NN];
	int i,n0,n1,num,j;
	for (sum[0]=0,i=1;i&lt;=n;i++) sum[i]=sum[i-1]^a[i];
	LL ans=0;
	for (i=1;i&lt;=22;i++)
	{
		n0=1,n1=0,num=0;
		for (j=1;j&lt;=n;j++)
			if (sum[j]&amp;(1&lt;&lt;(i-1))) num+=n0,n1++;
			else num+=n1,n0++;
		ans=(ans+(LL)num*(1&lt;&lt;(i-1)))%mo;
	}
	return ans;
}
inline int cha(LL x)
{
	int l=1,r=n+1,res=-1;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (b[mid]==x) return mid;
		if (b[mid]&lt;=x) res=mid,l=mid+1;
		else r=mid-1;
	}
	if (res!=-1) return res;
	if (r==0) return 0;
	return n+1;
}
inline void change(int i)
{
	for (;i&lt;=n+1;i+=i&amp;-i) c[i]^=1;
}
inline bool getsum(int i)
{
	bool res=0;
	for (;i;i-=i&amp;-i) res^=c[i];
	return res;
}
LL work2()
{
	static LL sum[NN];
	int i,j;
	for (sum[0]=0,i=1;i&lt;=n;i++) sum[i]=sum[i-1]+a[i];
	LL ans=0,tt=sum[n];
	for (i=1;tt;tt&gt;&gt;=1,i++)
	{
		for (j=1;j&lt;=n;j++) b[j]=sum[j]&amp;((1ll&lt;&lt;i)-1);
		b[n+1]=0;
		sort(b+1,b+n+2);
		memset(c,0,sizeof(c));
		bool res=0;
		for (j=0;j&lt;=n;j++)
		{
			LL tmp=sum[j]&amp;((1ll&lt;&lt;i)-1);
			int t=cha(tmp);
			res^=getsum(cha(tmp-(1ll&lt;&lt;(i-1))));
			res^=getsum(cha(tmp+(1ll&lt;&lt;(i-1))))^getsum(t);
			change(t);
		}
		if (res) ans|=1ll&lt;&lt;(i-1);
	}
	return ans;
}
int main()
{
	read(n);
	for (int i=1;i&lt;=n;i++) read(a[i]);
	printf(&quot;%d %lld\n&quot;,work1(),work2());
	return 0;
}<pre><h2>Problem4018</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define mo1 1000000007
#define mo2 1000000009
LL f1[2001111],f2[2001111];
int tes,n,m;
void shai()
{
	static bool vt[2001111];
	static int pr[2001111],the[2001111],prcnt;
	vt[1]=true;
	f1[1]=f2[1]=1;
	int i,j;
	for (i=2;i&lt;=2000000;i++)
	{
		if (!vt[i])
		{
			pr[++prcnt]=i;
			the[i]=i;
			f1[i]=f2[i]=1-i;
		}
		for (j=1;j&lt;=prcnt;j++)
		{
			int x=i*pr[j];
			if (x&gt;2000000) break;
			vt[x]=true;
			if (i%pr[j]==0)
			{
				the[x]=the[i]*pr[j];
				if (x==the[x]) f1[x]=f2[x]=1-pr[j];
				else
				{
					f1[x]=f1[the[x]]*f1[x/the[x]]%mo1;
					f2[x]=f2[the[x]]*f2[x/the[x]]%mo2;
				}
				break;
			}
			the[x]=pr[j];
			f1[x]=f1[i]*f1[pr[j]]%mo1;
			f2[x]=f2[i]*f2[pr[j]]%mo2;
		}
	}
	for (i=1;i&lt;=2000000;i++)
	{
		f1[i]+=f1[i-1];
		if (f1[i]&gt;=mo1) f1[i]-=mo1;
		f2[i]+=f2[i-1];
		if (f2[i]&gt;=mo2) f2[i]-=mo2;
	}
}
LL calc(LL A,LL B,LL mo)
{
	if (A&lt;B) {LL t=A;A=B;B=t;}
	LL tmp=(B-1)*B*(B+1)/3+A*B*(A-B)/2;
	return tmp%mo;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	shai();
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		if (n&gt;m) {int t=n;n=m;m=t;}
		LL ans1=0,ans2=0;
		for (int l=1,r;l&lt;=n;l=r+1)
		{
			r=min(n/(n/l),m/(m/l));
			(ans1+=(f1[r]-f1[l-1])*calc(n/l,m/l,mo1))%=mo1;
			(ans2+=(f2[r]-f2[l-1])*calc(n/l,m/l,mo2))%=mo2;
		}
		if (ans1&lt;0) ans1+=mo1;
		if (ans2&lt;0) ans2+=mo2;
		printf(&quot;%lld %lld\n&quot;,ans1,ans2);
	}
	return 0;
}<pre><h2>Problem4024</h2><pre>//bzoj 4024 standard
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=111,AA=200005;
int begin[NN],L[NN],sumL[NN],o[AA],aa[20000000][3],du[AA];
int ss[AA*2],height[AA],rank[AA*2],sa[AA*2],log[AA],f[AA][21];
int n,cnt,tot,S,T0,T,ans;
void noans()
{
	printf(&quot;Infinity\n&quot;);
	exit(0);
}
void SA(int *r,int n,int m)
{
	static int wv[AA*2],sa2[AA*2],sum[AA*2];
	int i,j,p,*x=rank,*y=sa2,*t;
	for (i=0;i&lt;=m;i++) sum[i]=0;
	for (i=1;i&lt;=n;i++) sum[x[i]=r[i]]++;
	for (i=1;i&lt;=m;i++) sum[i]+=sum[i-1];
	for (i=n;i;i--) sa[sum[x[i]]--]=i;
	for (j=p=1;p&lt;n;j&lt;&lt;=1,m=p)
	{
		for (i=n-j+1,p=0;i&lt;=n;i++) y[++p]=i;
		for (i=1;i&lt;=n;i++) if (sa[i]&gt;j) y[++p]=sa[i]-j;
		for (i=0;i&lt;=m;i++) sum[i]=0;
		for (i=1;i&lt;=n;i++) sum[wv[i]=x[y[i]]]++;
		for (i=1;i&lt;=m;i++) sum[i]+=sum[i-1];
		for (i=n;i;i--) sa[sum[wv[i]]--]=y[i];
		for (t=x,x=y,y=t,i=2,x[sa[1]]=p=1;i&lt;=n;i++)
			x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+j]==y[sa[i-1]+j])?p:++p;
	}
	for (i=1;i&lt;=n;i++) rank[i]=x[i];
	for (p=0,i=1;i&lt;=n;i++) if (x[i]&gt;1)
	{
		j=sa[x[i]-1];
		while (r[i+p]==r[j+p]) p++;
		height[x[i]]=p;
		if (p) p--;
	}
	for (i=1;i&lt;=cnt;i++) f[i][0]=height[i];
	for (j=1;j&lt;=20;j++)
		for (i=1;i&lt;=cnt&amp;&amp;i+(1&lt;&lt;(j-1))&lt;=cnt;i++)
			f[i][j]=min(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]);
	log[1]=0;
	for (i=2;i&lt;=cnt;i++) log[i]=(i==(i&amp;-i))?log[i-1]+1:log[i-1];
}
inline int lcp(int a,int x,int b,int y)
{
	int i,j;
	if (x&gt;0) i=begin[a]+x-1;
	else i=begin[a]+L[a]+1+L[a]+x;
	if (y&gt;0) j=begin[b]+y-1;
	else j=begin[b]+L[b]+1+L[b]+y;
	i=rank[i],j=rank[j];
	if (i&gt;j) {int t=i;i=j;j=t;}
	i++;
	int k=log[j-i+1];
	return min(f[i][k],f[j-(1&lt;&lt;k)+1][k]);
}
inline int hao(int i,int j)
{
	if (j&gt;0) return sumL[i-1]*2+j;
	return sumL[i-1]*2+L[i]-j;
}
inline void addedge(int p,int q,int v)
{
	du[q]++;
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void init()
{
	static char s[AA];
	scanf(&quot;%d\n&quot;,&amp;n);
	int i,tt=26;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%s\n&quot;,s+1);int l=strlen(s+1);
		begin[i]=cnt+1;
		for (int j=1;j&lt;=l;j++) ss[++cnt]=s[j]-'a'+1;
		ss[++cnt]=++tt;
		for (int j=l;j;j--) ss[++cnt]=s[j]-'a'+1;
		ss[++cnt]=++tt;
		L[i]=l,sumL[i]=sumL[i-1]+l;
	}
	SA(ss,cnt,tt+10);
	for (i=1;i&lt;=n;i++)
		if (lcp(i,1,i,-L[i])==L[i]) noans();
}
void build()
{
	int i,j,k;
	S=sumL[n]*2+1,T0=S+1,T=S+2;
	for (i=1;i&lt;=n;i++)
	{
		for (j=1;j&lt;=L[i];j++)
			ans=max(ans,lcp(i,j,i,-j)*2-1);
		for (j=2;j&lt;=L[i];j++)
			ans=max(ans,lcp(i,j,i,-(j-1))*2-1);
		addedge(S,hao(i,1),0);
		addedge(S,hao(i,-L[i]),0);
		for (j=1;j&lt;=L[i];j++)
		{
			if (lcp(i,1,i,-j)==j) addedge(S,hao(i,j+1),j);
			if (lcp(i,j,i,-L[i])==L[i]-j+1) addedge(S,hao(i,-(j-1)),L[i]-j+1);
		}
		for (j=1;j&lt;=L[i];j++) for (k=1;k&lt;=n;k++)
		{
			int t=lcp(i,j,k,-L[k]);
			if (t==L[i]-j+1)
			{
				if (t==L[k]) addedge(hao(i,j),T0,0);
				addedge(hao(i,j),hao(k,-(L[k]-t)),t*2);
			}
			else if (t==L[k]) addedge(hao(i,j),hao(i,j+t),t*2);
			else addedge(hao(i,j),T,t*2);
			t=lcp(i,-j,k,1);
			if (t==j)
			{
				if (t==L[k]) addedge(hao(i,-j),T0,0);
				addedge(hao(i,-j),hao(k,t+1),t*2);
			}
			else if (t==L[k]) addedge(hao(i,-j),hao(i,-(j-t)),t*2);
			else addedge(hao(i,-j),T,t*2);
		}
	}
}
bool bfs()
{
	static int q[AA];
	static bool vt[AA];
	int head=0,tail=1;
	vt[S]=true;
	q[1]=S;
	while (head&lt;tail)
	{
		int x=q[++head];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (!vt[y]) vt[y]=true,q[++tail]=y;
		}
	}
	return vt[T0];
}
bool tuopu()
{
	static int sta[AA],f[AA],b[AA];
	int i,top=0,cnt=0;
	for (i=1;i&lt;=T;i++)
		if (du[i]==0) sta[++top]=i;
	while (top)
	{
		int x=sta[top--];
		b[++cnt]=x;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (--du[y]==0) sta[++top]=y;
		}
	}
	if (cnt&lt;T) return false;
	for (i=T;i;i--)
	{
		int x=b[i];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (f[y]+aa[p][2]&gt;f[x]) f[x]=f[y]+aa[p][2];
		}
	}
	if (f[S]&gt;ans) ans=f[S];
	return true;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	init();
	build();
	if (bfs()||!tuopu()) noans();
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
//by dxy<pre><h2>Problem4025</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;set&gt;
#include&lt;map&gt;
using namespace std;
#define inf 999999999
const int NN=201111,MM=201111,AA=301111;
int fa[AA],son[AA][2],key[AA],tid[AA],size[AA],from[AA];
int n,m,T,TTT;
bool tag[AA],rrr[AA];
vector&lt;int&gt; inc[NN];
struct edge
{
	int u,v,st,ed,id;
	void in(int i)
	{
		id=i;
		scanf(&quot;%d%d%d%d&quot;,&amp;u,&amp;v,&amp;st,&amp;ed);
		inc[st].push_back(i);
	}
} e[MM];
inline void rev(int t)
{
	tag[t]=!tag[t];
	swap(son[t][0],son[t][1]);
}
inline void pushdown(int t)
{
	if (!tag[t]) return;
	rev(son[t][0]),rev(son[t][1]);
	tag[t]=false;
}
inline void update(int t)
{
	int x=son[t][0],y=son[t][1];
	size[t]=size[x]+size[y]+1;
	tid[t]=t;
	if (key[tid[x]]&lt;key[tid[t]]) tid[t]=tid[x];
	if (key[tid[y]]&lt;key[tid[t]]) tid[t]=tid[y];
}
void rotate(int t,int p)
{
	int y=fa[t];
	pushdown(y),pushdown(t);
	if (rrr[y]) rrr[y]=false,rrr[t]=true;
	else if (y==son[fa[y]][0]) son[fa[y]][0]=t;
	else son[fa[y]][1]=t;
	fa[t]=fa[y];
	son[y][p^1]=son[t][p];
	if (son[t][p]) fa[son[t][p]]=y;
	son[t][p]=y;
	fa[y]=t;
	update(y),update(t);
}
void splay(int t)
{
	while (!rrr[t])
	{
		int y=fa[t];
		if (rrr[y])
			if (t==son[y][0]) rotate(t,1);
			else rotate(t,0);
		else
			if (y==son[fa[y]][0])
				if (t==son[y][0]) rotate(y,1),rotate(t,1);
				else rotate(t,0),rotate(t,1);
			else
				if (t==son[y][1]) rotate(y,0),rotate(t,0);
				else rotate(t,1),rotate(t,0);
	}
	update(t);
}
void access(int x)
{
	int y=0;
	for (;x;y=x,x=fa[x])
	{
		splay(x);
		pushdown(x);
		rrr[son[x][1]]=true;
		son[x][1]=y;
		rrr[y]=false;
		update(x);
	}
}
void makeroot(int x)
{
	access(x);
	splay(x);
	rev(x);
}
void link(int x,int y)
{
	makeroot(x);
	splay(x);
	fa[x]=y;
}
void cut(int x,int y)
{
	makeroot(x);
	access(y),splay(y);
	rrr[x]=true;
	fa[x]=son[y][0]=0;
}
int getroot(int x)
{
	access(x),splay(x);
	while (son[x][0]) x=son[x][0];
	return x;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;T);
	int i,t,j;
	for (i=1;i&lt;=m;i++) e[i].in(i);
	key[0]=inf;
	for (i=1;i&lt;=n;i++)
		rrr[i]=true,key[i]=inf,size[i]=1,tid[i]=i;
	TTT=n;
	int now=0;
	for (i=0;i&lt;T;i++)
	{
		for (t=inc[i].size(),j=0;j&lt;t;j++)
		{
			edge the=e[inc[i][j]];
			int u=the.u,v=the.v,ed=the.ed,id=the.id;
			if (getroot(u)!=getroot(v))
			{
				int t=++TTT;
				key[t]=ed,rrr[t]=true,size[t]=1;
				from[t]=id,tid[t]=t;
				link(u,t),link(t,v);
				continue;
			}
			makeroot(u);
			access(v),splay(v);
			int num=size[v]/2;
			if (num%2==0)
				now=max(now,min(key[tid[v]],ed));
			int t=tid[v];
			if (key[t]&gt;=ed) continue;
			cut(t,e[from[t]].u),cut(t,e[from[t]].v);
			fa[t]=son[t][0]=son[t][1]=0;
			tag[t]=false;
			key[t]=ed,rrr[t]=true,size[t]=1;
			from[t]=id,tid[t]=t;
			link(u,t),link(t,v);
		}
		printf(now&gt;i?&quot;No\n&quot;:&quot;Yes\n&quot;);
	}
	return 0;
}<pre><h2>Problem4026</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
#define mo 1000777
int pre[1000005],ji[50111],root[50111],tji[7000000],lc[7000000],rc[7000000];
int n,m,TTT;
inline int ksm(int a,int b,int c)
{
	int res=1;
	for (a%=c;b;b&gt;&gt;=1,a=(LL)a*a%c)
		if (b&amp;1) res=(LL)res*a%c;
	return res;
}
void ins(int &amp;v,int u,int l,int r,int i,int x)
{
	if (v==0) v=++TTT;
	tji[v]=(LL)tji[u]*x%mo;
	//printf(&quot;ins %d %d %d %d %d %d\n&quot;,v,u,l,r,i,x);
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid) rc[v]=rc[u],ins(lc[v],lc[u],l,mid,i,x);
	else lc[v]=lc[u],ins(rc[v],rc[u],mid,r,i,x);
}
int find(int v,int u,int l,int r,int x)
{
	//printf(&quot;find %d %d %d %d %d\n&quot;,v,u,l,r,x);
	if (r&lt;=x) return (LL)tji[v]*ksm(tji[u],mo-2,mo)%mo;
	int mid=(l+r)&gt;&gt;1;
	int res=find(lc[v],lc[u],l,mid,x);
	if (x&gt;mid) res=(LL)res*find(rc[v],rc[u],mid,r,x)%mo;
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j,x,l,r,t=0;
	tji[0]=1;
	ji[0]=1;
	for (i=1;i&lt;=n;i++)
	{
		//printf(&quot;\n--------------------------------------------------------------------\n&quot;);
		scanf(&quot;%d&quot;,&amp;x);
		ji[i]=(LL)ji[i-1]*x%mo;
		if (x==1) {root[i]=root[i-1];continue;}
		for (j=2;j*j&lt;=x;j++) if (x%j==0)
		{
			int tmp=(LL)(j-1)*ksm(j,mo-2,mo)%mo;
			ins(root[i]=0,t,0,n,pre[j],tmp);
			t=root[i];
			pre[j]=i;
			while (x%j==0) x/=j;
		}
		if (x&gt;1)
		{
			int tmp=(LL)(x-1)*ksm(x,mo-2,mo)%mo;
			//printf(&quot;x=%d tmp=%d x*tmp=%d\n&quot;,x,tmp,(int)((LL)x*tmp%mo));
			ins(root[i]=0,t,0,n,pre[x],tmp);
			t=root[i];
			pre[x]=i;
		}
	}
	int lastans=0;
	for (;m;m--)
	{
		scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
		l^=lastans,r^=lastans;
		int ans=(LL)ji[r]*ksm(ji[l-1],mo-2,mo)%mo;
		//printf(&quot;ans=%d\n&quot;,ans);
		ans=(LL)ans*find(root[r],root[l-1],0,n,l)%mo;
		printf(&quot;%d\n&quot;,lastans=ans);
	}
	return 0;
}<pre><h2>Problem4026</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
#define mo 1000777
int pre[1000005],ji[50111],root[50111],tji[7000000],lc[7000000],rc[7000000];
int n,m,TTT;
inline int ksm(int a,int b,int c)
{
	int res=1;
	for (a%=c;b;b&gt;&gt;=1,a=(LL)a*a%c)
		if (b&amp;1) res=(LL)res*a%c;
	return res;
}
void ins(int &amp;v,int u,int l,int r,int i,int x)
{
	if (v==0) v=++TTT;
	tji[v]=(LL)tji[u]*x%mo;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid) rc[v]=rc[u],ins(lc[v],lc[u],l,mid,i,x);
	else lc[v]=lc[u],ins(rc[v],rc[u],mid,r,i,x);
}
int find(int v,int u,int l,int r,int x)
{
	if (r&lt;=x) return (LL)tji[v]*ksm(tji[u],mo-2,mo)%mo;
	int mid=(l+r)&gt;&gt;1;
	int res=find(lc[v],lc[u],l,mid,x);
	if (x&gt;mid) res=(LL)res*find(rc[v],rc[u],mid,r,x)%mo;
	return res;
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j,x,l,r,preroot=0;
	tji[0]=1;
	ji[0]=1;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		ji[i]=(LL)ji[i-1]*x%mo;
		if (x==1) {root[i]=root[i-1];continue;}
		for (j=2;j*j&lt;=x;j++) if (x%j==0)
		{
			int tmp=(LL)(j-1)*ksm(j,mo-2,mo)%mo;
			ins(root[i]=0,preroot,0,n,pre[j],tmp);
			preroot=root[i];
			pre[j]=i;
			while (x%j==0) x/=j;
		}
		if (x&gt;1)
		{
			int tmp=(LL)(x-1)*ksm(x,mo-2,mo)%mo;
			ins(root[i]=0,preroot,0,n,pre[x],tmp);
			preroot=root[i];
			pre[x]=i;
		}
	}
	int lastans=0;
	for (;m;m--)
	{
		scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
		l^=lastans,r^=lastans;
		int ans=(LL)ji[r]*ksm(ji[l-1],mo-2,mo)%mo;
		ans=(LL)ans*find(root[r],root[l-1],0,n,l)%mo;
		printf(&quot;%d\n&quot;,lastans=ans);
	}
	return 0;
}<pre><h2>Problem4026</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
#define mo 1000777
int pre[1000005],ji[50111],root[50111],tji[7000000],lc[7000000],rc[7000000];
int n,m,TTT;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar());
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar()) x=x*10+ch-'0';
}
inline int ksm(int a,int b,int c)
{
	int res=1;
	for (a%=c;b;b&gt;&gt;=1,a=(LL)a*a%c)
		if (b&amp;1) res=(LL)res*a%c;
	return res;
}
void ins(int &amp;v,int u,int l,int r,int i,int x)
{
	if (v==0) v=++TTT;
	tji[v]=(LL)tji[u]*x%mo;
	if (r-l==1) return;
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid) rc[v]=rc[u],ins(lc[v],lc[u],l,mid,i,x);
	else lc[v]=lc[u],ins(rc[v],rc[u],mid,r,i,x);
}
int find(int v,int u,int l,int r,int x)
{
	if (r&lt;=x) return (LL)tji[v]*ksm(tji[u],mo-2,mo)%mo;
	int mid=(l+r)&gt;&gt;1;
	int res=find(lc[v],lc[u],l,mid,x);
	if (x&gt;mid) res=(LL)res*find(rc[v],rc[u],mid,r,x)%mo;
	return res;
}
int main()
{
	read(n),read(m);
	int i,j,x,l,r,preroot=0;
	tji[0]=1;
	ji[0]=1;
	for (i=1;i&lt;=n;i++)
	{
		read(x);
		ji[i]=(LL)ji[i-1]*x%mo;
		if (x==1) {root[i]=root[i-1];continue;}
		for (j=2;j*j&lt;=x;j++) if (x%j==0)
		{
			int tmp=(LL)(j-1)*ksm(j,mo-2,mo)%mo;
			ins(root[i]=0,preroot,0,n,pre[j],tmp);
			preroot=root[i];
			pre[j]=i;
			while (x%j==0) x/=j;
		}
		if (x&gt;1)
		{
			int tmp=(LL)(x-1)*ksm(x,mo-2,mo)%mo;
			ins(root[i]=0,preroot,0,n,pre[x],tmp);
			preroot=root[i];
			pre[x]=i;
		}
	}
	int lastans=0;
	for (;m;m--)
	{
		read(l),read(r);
		l^=lastans,r^=lastans;
		int ans=(LL)ji[r]*ksm(ji[l-1],mo-2,mo)%mo;
		ans=(LL)ans*find(root[r],root[l-1],0,n,l)%mo;
		printf(&quot;%d\n&quot;,lastans=ans);
	}
	return 0;
}<pre><h2>Problem4031</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define mo 1000000000
const int NN=11;
int n,m,hao[NN][NN];
LL K[NN*NN][NN*NN],ans;
bool a[NN][NN];
inline void add(int x,int y)
{
	K[x][y]--,K[y][x]--;
	K[x][x]++,K[y][y]++;
}
void gause(int n)
{
	for (int i=1;i&lt;=n;i++)
	{
		for (int j=i+1;j&lt;=n;j++)
			while (K[j][i])
			{
				LL t=K[i][i]/K[j][i];
				for (int k=i;k&lt;=n;k++) K[i][k]=(K[i][k]-t*K[j][k])%mo;
				for (int k=i;k&lt;=n;k++) swap(K[i][k],K[j][k]);
				ans=-ans;
			}
		ans=ans*K[i][i]%mo;
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int cnt=0,i,j;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			char ch=getchar();
			while (ch!='.'&amp;&amp;ch!='*') ch=getchar();
			a[i][j]=(ch=='.');
			if (ch=='.') hao[i][j]=++cnt;
		}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++) if (a[i][j])
		{
			if (i&lt;n&amp;&amp;a[i+1][j]) add(hao[i][j],hao[i+1][j]);
			if (j&lt;m&amp;&amp;a[i][j+1]) add(hao[i][j],hao[i][j+1]);
		}
	ans=1;
	gause(cnt-1);
	printf(&quot;%lld\n&quot;,(ans%mo+mo)%mo);
	return 0;
}<pre><h2>Problem4031</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define mo 1000000000
const int NN=10;
int n,m,hao[NN][NN];
LL K[NN*NN][NN*NN],ans;
inline void add(int x,int y)
{
	K[x][y]--,K[y][x]--;
	K[x][x]++,K[y][y]++;
}
void gause(int n)
{
	for (int i=1;i&lt;=n;i++)
	{
		for (int j=i+1;j&lt;=n;j++)
			while (K[j][i])
			{
				LL t=K[i][i]/K[j][i];
				for (int k=i;k&lt;=n;k++) K[i][k]=(K[i][k]-t*K[j][k])%mo;
				for (int k=i;k&lt;=n;k++) swap(K[i][k],K[j][k]);
				ans=-ans;
			}
		ans=ans*K[i][i]%mo;
	}
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int cnt=0,i,j;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			char ch=getchar();
			while (ch!='.'&amp;&amp;ch!='*') ch=getchar();
			if (ch=='.') hao[i][j]=++cnt;
		}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			int x=hao[i][j];
			if (x==0) continue;
			int y=hao[i+1][j];if (y) add(x,y);
			y=hao[i][j+1];if (y) add(x,y);
		}
	ans=1;
	gause(cnt-1);
	if (ans&lt;0) ans+=mo;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem4031</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define mo 1000000000
const int NN=10;
int n,m,hao[NN][NN];
LL K[NN*NN][NN*NN],ans;
inline void add(int x,int y)
{
	K[x][y]--,K[y][x]--;
	K[x][x]++,K[y][y]++;
}
void gause(int n)
{
	for (int i=1;i&lt;=n;i++)
	{
		for (int j=i+1;j&lt;=n;j++)
			while (K[j][i])
			{
				LL t=K[i][i]/K[j][i];
				for (int k=i;k&lt;=n;k++) K[i][k]=(K[i][k]-t*K[j][k])%mo;
				for (int k=i;k&lt;=n;k++) swap(K[i][k],K[j][k]);
				ans=-ans;
			}
		ans=ans*K[i][i]%mo;
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int cnt=0,i,j;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			char ch=getchar();
			while (ch!='.'&amp;&amp;ch!='*') ch=getchar();
			if (ch=='.') hao[i][j]=++cnt;
		}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++)
		{
			int x=hao[i][j];
			if (x==0) continue;
			int y=hao[i+1][j];if (y) add(x,y);
			y=hao[i][j+1];if (y) add(x,y);
		}
	ans=1;
	gause(cnt-1);
	if (ans&lt;0) ans+=mo;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem4031</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define mo 1000000000
int hao[11][11];
int n,m,cnt;
LL K[111][111];
LL gause(int n)
{
	LL ans=1;int i,j,k;
	for (i=1;i&lt;=n;i++)
	{
		for (j=i+1;j&lt;=n;j++)
			while (K[j][i])
			{
				LL tmp=K[i][i]/K[j][i];
				for (k=1;k&lt;=n;k++)
				{
					K[i][k]=(K[i][k]-tmp*K[j][k])%mo;
					swap(K[i][k],K[j][k]);
				}
				ans=-ans;
			}
		ans=ans*K[i][i]%mo;
	}
	if (ans&lt;0) ans+=mo;
	return ans;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j;
	for (i=1;i&lt;=n;i++) for (j=1;j&lt;=m;j++)
	{
		char ch=getchar();
		while (ch!='.'&amp;&amp;ch!='*') ch=getchar();
		if (ch=='.') hao[i][j]=++cnt;
	}
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=m;j++) if (hao[i][j])
		{
			int x=hao[i][j];
			if (hao[i+1][j])
			{
				int y=hao[i+1][j];
				K[x][x]++,K[y][y]++;
				K[x][y]--,K[y][x]--;
			}
			if (hao[i][j+1])
			{
				int y=hao[i][j+1];
				K[x][x]++,K[y][y]++;
				K[x][y]--,K[y][x]--;
			}
		}
	printf(&quot;%lld\n&quot;,gause(cnt-1));
	return 0;
}<pre><h2>Problem4032</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define ln printf(&quot;\n&quot;)
const int NN=4011;
char A[NN],B[NN];
int n,m;
struct Sam
{
	int pre[NN],val[NN],son[NN][26];
	int last,TTT;
	Sam() {pre[0]=-1;}
	void out()
	{
		for(int i=0;i&lt;=TTT;i++){for(int j=0;j&lt;10;j++)printf(&quot;%d &quot;,son[i][j]);ln;}
	}
	void add(int x)
	{
		int end=++TTT,p=last;
		last=end;
		val[end]=val[p]+1;
		for (;p!=-1&amp;&amp;!son[p][x];p=pre[p]) son[p][x]=end;
		if (p==-1) {pre[end]=0;return;}
		int q=son[p][x];
		if (val[q]==val[p]+1) {pre[end]=q;return;}
		int nq=++TTT;
		val[nq]=val[p]+1;
		pre[nq]=pre[q];
		pre[q]=pre[end]=nq;
		memcpy(son[nq],son[q],sizeof(son[q]));
		for (;p!=-1&amp;&amp;son[p][x]==q;p=pre[p]) son[p][x]=nq;
	}
} samA,samB;
struct Seq
{
	int last[26],TTT,son[NN][26],pre[NN];
	Seq() {pre[0]=-1;}
	void out()
	{
		for(int i=0;i&lt;=TTT;i++){for(int j=0;j&lt;10;j++)printf(&quot;%d &quot;,son[i][j]);ln;}
	}
	void add(int x)
	{
		int end=++TTT;
		for (int i=0;i&lt;26;i++)
			for (int p=last[i];p!=-1&amp;&amp;!son[p][x];p=pre[p])
				son[p][x]=end;
		pre[end]=last[x];
		last[x]=end;
	}
} seqA,seqB;
struct ppt
{
	int x,y,len;
	ppt (int a=0,int b=0,int c=0) {x=a;y=b;len=c;}
	void out() {printf(&quot;x=%d y=%d len=%d\n&quot;,x,y,len);}
} que[NN*NN];
bool vt[NN][NN];
int work1()
{
	int head=0,tail=1;
	que[1]=ppt(0,0,0);
	memset(vt,0,sizeof(vt));
	vt[0][0]=true;
	while (head&lt;tail)
	{
		head++;
		int x=que[head].x,y=que[head].y,len=que[head].len;
		for (int i=0;i&lt;26;i++) if (samA.son[x][i])
		{
			if (!samB.son[y][i]) return len+1;
			int xx=samA.son[x][i],yy=samB.son[y][i];
			if (vt[xx][yy]) continue;
			vt[xx][yy]=true;
			que[++tail]=ppt(xx,yy,len+1);
		}
	}
	return -1;
}
int work2()
{
	int head=0,tail=1;
	que[1]=ppt(0,0,0);
	memset(vt,0,sizeof(vt));
	vt[0][0]=true;
	while (head&lt;tail)
	{
		head++;
		int x=que[head].x,y=que[head].y,len=que[head].len;
		for (int i=0;i&lt;26;i++) if (samA.son[x][i])
		{
			if (!seqB.son[y][i]) return len+1;
			int xx=samA.son[x][i],yy=seqB.son[y][i];
			if (vt[xx][yy]) continue;
			vt[xx][yy]=true;
			que[++tail]=ppt(xx,yy,len+1);
		}
	}
	return -1;
}
int work3()
{
	int head=0,tail=1;
	que[1]=ppt(0,0,0);
	memset(vt,0,sizeof(vt));
	vt[0][0]=true;
	while (head&lt;tail)
	{
		head++;
		int x=que[head].x,y=que[head].y,len=que[head].len;
		for (int i=0;i&lt;26;i++) if (seqA.son[x][i])
		{
			if (!samB.son[y][i]) return len+1;
			int xx=seqA.son[x][i],yy=samB.son[y][i];
			if (vt[xx][yy]) continue;
			vt[xx][yy]=true;
			que[++tail]=ppt(xx,yy,len+1);
		}
	}
	return -1;
}
int work4()
{
	int head=0,tail=1;
	que[1]=ppt(0,0,0);
	memset(vt,0,sizeof(vt));
	vt[0][0]=true;
	while (head&lt;tail)
	{
		head++;
		int x=que[head].x,y=que[head].y,len=que[head].len;
		for (int i=0;i&lt;26;i++) if (seqA.son[x][i])
		{
			if (!seqB.son[y][i]) return len+1;
			int xx=seqA.son[x][i],yy=seqB.son[y][i];
			if (vt[xx][yy]) continue;
			vt[xx][yy]=true;
			que[++tail]=ppt(xx,yy,len+1);
		}
	}
	return -1;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%s\n%s&quot;,A+1,B+1);
	n=strlen(A+1),m=strlen(B+1);
	int i;
	for (i=1;i&lt;=n;i++)
	{
		samA.add(A[i]-'a');
		seqA.add(A[i]-'a');
	}
	for (i=1;i&lt;=m;i++)
	{
		samB.add(B[i]-'a');
		seqB.add(B[i]-'a');
	}
	//printf(&quot;samA\n&quot;);samA.out();printf(&quot;samB\n&quot;);samB.out();ln;
	//printf(&quot;seqA\n&quot;);seqA.out();printf(&quot;sqeB\n&quot;);seqB.out();ln;
	printf(&quot;%d\n%d\n%d\n%d\n&quot;,work1(),work2(),work3(),work4());
	return 0;
}<pre><h2>Problem4033</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
#define INF 99999999999999999ll
const int NN=2005;
int n,K,tot,o[NN],fa[NN],aa[NN&lt;&lt;1][3],size[NN];
LL f[NN][NN];
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline void renew(LL &amp;a,LL b)
{
	if (b&gt;a) a=b;
}
void DP(int v)
{
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		DP(y);
	}
	f[v][0]=f[v][1]=0;
	int i,j;
	for (i=2;i&lt;=K;i++) f[v][i]=-INF;
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		static LL g[NN];
		for (i=0;i&lt;=size[v]+size[y];i++) g[i]=-INF;
		for (i=0;i&lt;=size[v];i++)
			for (j=0;j&lt;=size[y];j++)
				renew(g[i+j],f[v][i]+f[y][j]+(LL)aa[p][2]*(j*(K-j)+(size[y]-j)*(n-K-(size[y]-j))));
		size[v]+=size[y];
		for (i=0;i&lt;=size[v];i++) f[v][i]=g[i];
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	int i,x,y,z;
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		addedge(x,y,z),addedge(y,x,z);
	}
	DP(1);
	printf(&quot;%lld\n&quot;,f[1][K]);
	return 0;
}<pre><h2>Problem4034</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
#define lc (v&lt;&lt;1)
#define rc (v&lt;&lt;1|1)
const int NN=101111;
int o[NN],aa[NN*2][2],size[NN],fa[NN],deep[NN],up[NN],hea[NN];
int dy[NN],w[NN],st[NN],ed[NN];
int n,m,tot=1,cnt,ww,ee;
LL tsum[NN*4],tag[NN*4];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar()) x=x*10+ch-'0';
	if (f) x=-x;
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs1(int v)
{
	int tmp=0,mm=0;
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		dfs1(y);
		size[v]+=size[y];
		if (size[y]&gt;mm) mm=size[y],tmp=y;
	}
	hea[v]=tmp;
}
void dfs2(int v)
{
	st[v]=++cnt;
	dy[cnt]=v;
	if (hea[v])
	{
		up[hea[v]]=up[v];
		dfs2(hea[v]);
	}
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||y==hea[v]) continue;
		up[y]=y;
		dfs2(y);
	}
	ed[v]=cnt;
}
inline void add(int v,int l,int r,LL x)
{
	tag[v]+=x;
	tsum[v]+=x*(r-l);
}
inline void pushdown(int v,int l,int r,int mid)
{
	if (!tag[v]) return;
	add(lc,l,mid,tag[v]);
	add(rc,mid,r,tag[v]);
	tag[v]=0;
}
inline void update(int v)
{
	tsum[v]=tsum[lc]+tsum[rc];
}
void build(int v,int l,int r)
{
	if (r-l==1)
	{
		tsum[v]=w[dy[l]];
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(lc,l,mid);
	build(rc,mid,r);
	update(v);
}
void change(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		add(v,l,r,x);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	pushdown(v,l,r,mid);
	if (ww&lt;mid) change(lc,l,mid,x);
	if (ee&gt;mid) change(rc,mid,r,x);
	update(v);
}
LL find(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return tsum[v];
	int mid=(l+r)&gt;&gt;1;LL res=0;
	pushdown(v,l,r,mid);
	if (ww&lt;mid) res+=find(lc,l,mid);
	if (ee&gt;mid) res+=find(rc,mid,r);
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	int i,x,y;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;w[i]);
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y);
		addedge(x,y),addedge(y,x);
	}
	deep[1]=1;
	dfs1(1);
	up[1]=1;
	dfs2(1);
	build(1,1,n+1);
	for (;m;m--)
	{
		read(x);
		if (x==1)
		{
			read(x),read(y);
			ww=st[x],ee=st[x]+1;
			change(1,1,n+1,y);
		}
		else if (x==2)
		{
			read(x),read(y);
			ww=st[x],ee=ed[x]+1;
			change(1,1,n+1,y);
		}
		else
		{
			read(x);
			LL ans=0;
			while (x)
			{
				ww=st[up[x]],ee=st[x]+1;
				ans+=find(1,1,n+1);
				x=fa[up[x]];
			}
			printf(&quot;%lld\n&quot;,ans);
		}
	}
	return 0;
}<pre><h2>Problem4038</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;stack&gt;
#include&lt;cstdlib&gt;
#include&lt;string&gt;
#include&lt;bitset&gt;
#define INF 100000000
#define fi first
#define se second
#define N 3005
#define debug(x) cout&lt;&lt;#x&lt;&lt;&quot;=&quot;&lt;&lt;x&lt;&lt;endl
#define MP(x,y) make_pair(x,y)
using namespace std;
typedef long long LL;
typedef pair&lt;int,int&gt; pii;
LL dp[N][N];
int a[N];
inline void upd(LL &amp;x,LL y)
{
	if(!x||x&gt;y) x=y;
}

int main()
{
	int n,i,j,T;
	LL *f1,*f2,ans=0;
	LL t1,t2;
	cin&gt;&gt;n;
	T=n*3-2;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	for(i=1;i&lt;=n;i++)
	{
		f1=dp[i-1],f2=dp[i];
		t1=(LL)(i-1)*a[i],t2=(LL)(T-i*2+1)*a[i];
		for(j=0;j&lt;i;j++,t1+=a[i],t2+=a[i])
		{
			upd(f2[j],f1[j]+t2);
			upd(f2[j+1],f1[j]+t1);
		}
	}
	for(i=0;i&lt;=n;i++)
		upd(ans,dp[n][i]);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem4038</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;stack&gt;
#include&lt;cstdlib&gt;
#include&lt;string&gt;
#include&lt;bitset&gt;
#define INF 100000000
#define fi first
#define se second
#define N 3005
#define debug(x) cout&lt;&lt;#x&lt;&lt;&quot;=&quot;&lt;&lt;x&lt;&lt;endl
#define MP(x,y) make_pair(x,y)
using namespace std;
typedef long long LL;
typedef pair&lt;int,int&gt; pii;
LL dp[N][N];
int a[N];
inline void upd(LL &amp;x,LL y)
{
	if(!x||x&gt;y) x=y;
}

int main()
{
	memset(dp,60,sizeof(dp));
	dp[0][0]=0;
	int n,i,j,T;
	LL *f1,*f2,ans=0;
	LL t1,t2;
	cin&gt;&gt;n;
	T=n*3-2;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	for(i=1;i&lt;=n;i++)
	{
		f1=dp[i-1],f2=dp[i];
		t1=(LL)(i-1)*a[i],t2=(LL)(T-i*2+1)*a[i];
		for(j=0;j&lt;i;j++,t1+=a[i],t2+=a[i])
		{
			upd(f2[j],f1[j]+t2);
			upd(f2[j+1],f1[j]+t1);
		}
	}
	for(i=0;i&lt;=n;i++) upd(ans,dp[n][i]);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem4038</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define INF 9999999999999999ll
LL f[3111][3111];
int n,a[3111],T;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	T=n*3-2;
	int i,j;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	memset(f,60,sizeof(f));
	f[0][0]=0;
	for (i=1;i&lt;=n;i++)
	{
		LL t1=(LL)(i-1)*a[i],t2=(LL)(T-i*2+1)*a[i];
		for (j=0;j&lt;i;j++,t1+=a[i],t2+=a[i])
		{
			f[i][j]=min(f[i][j],f[i-1][j]+t2);
			f[i][j+1]=min(f[i][j],f[i-1][j]+t1);
		}
	}
	LL ans=INF;
	for (i=0;i&lt;=n;i++)
		if (f[n][i]&lt;ans) ans=f[n][i];
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem4038</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define INF 9999999999999999ll
LL dp1[3001],dp2[3001];
int n,a[3111],T;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);
	T=n*3-2;
	int i,j;
	for (i=1;i&lt;=n;i++) read(a[i]);
	memset(dp1,60,sizeof(dp1));
	dp1[0]=0;
	LL *f1=dp1,*f2=dp2;
	for (i=1;i&lt;=n;i++)
	{
		for (j=0;j&lt;=n;j++) f2[j]=INF;
		LL t1=(LL)(i-1)*a[i],t2=(LL)(T-i*2+1)*a[i];
		for (j=0;j&lt;i;j++,t1+=a[i],t2+=a[i])
		{
			f2[j]=min(f2[j],f1[j]+t2);
			f2[j+1]=min(f2[j],f1[j]+t1);
		}
		LL *t=f1;f1=f2;f2=t;
	}
	LL ans=INF;
	for (i=0;i&lt;=n;i++)
		if (f1[i]&lt;ans) ans=f1[i];
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem4038</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
#define INF 9999999999999999ll
LL dp1[3001],dp2[3001];
int n,a[3001];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
int main()
{
	read(n);
	int T,i,j;
	T=n*3-2;
	for (i=1;i&lt;=n;i++) read(a[i]);
	memset(dp1,60,sizeof(dp1));
	dp1[0]=0;
	LL *f1=dp1,*f2=dp2,*x,*y;
	for (i=1;i&lt;=n;i++)
	{
		for (j=0,x=&amp;f2[j];j&lt;=n;j++,x++) *x=INF;
		int tmp=a[i];
		LL t1=(LL)(i-1)*tmp,t2=(LL)(T-i*2+1)*tmp;
		for (j=0,x=&amp;f1[j],y=&amp;f2[j];j&lt;i;j++,x++,y++)
		{
			if (*x+t2&lt;*y) *y=*x+t2;
			if (*x+t1&lt;*(y+1)) *(y+1)=*x+t1;
			t1+=tmp,t2+=tmp;
		}
		LL *t=f1;f1=f2;f2=t;
	}
	LL ans=INF;
	for (i=0,x=&amp;f1[i];i&lt;=n;i++,x++)
		if (*x&lt;ans) ans=*x;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem4038</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
#define INF 9999999999999999ll
LL dp1[3001],dp2[3001];
int n,a[3001];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
int main()
{
	read(n);
	int T,i,j;
	T=n*3-2;
	for (i=1;i&lt;=n;i++) read(a[i]);
	memset(dp1,60,sizeof(dp1));
	dp1[0]=0;
	LL *f1=dp1,*f2=dp2,*x,*y;
	for (i=1;i&lt;=n;i++)
	{
		for (j=0,x=&amp;f2[j];j&lt;=n;j++,x++) *x=INF;
		int tmp=a[i];
		LL t1=(LL)(i-1)*tmp,t2=(LL)(T-(i&lt;&lt;1)+1)*tmp;
		for (j=0,x=&amp;f1[j],y=&amp;f2[j];j&lt;i;j++,x++,y++)
		{
			if (*x+t2&lt;*y) *y=*x+t2;
			if (*x+t1&lt;*(y+1)) *(y+1)=*x+t1;
			t1+=tmp,t2+=tmp;
		}
		LL *t=f1;f1=f2;f2=t;
	}
	LL ans=INF;
	for (i=0,x=&amp;f1[i];i&lt;=n;i++,x++)
		if (*x&lt;ans) ans=*x;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem4038</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
#define INF 9999999999999999ll
LL dp1[3001],dp2[3001];
int n,a[3001];
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	int T,i,j;
	T=n*3-2;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	memset(dp1,60,sizeof(dp1));
	dp1[0]=0;
	LL *f1=dp1,*f2=dp2,*x,*y;
	for (i=1;i&lt;=n;i++)
	{
		for (j=0,x=&amp;f2[j];j&lt;=n;j++,x++) *x=INF;
		int tmp=a[i];
		LL t1=(LL)(i-1)*tmp,t2=(LL)(T-(i&lt;&lt;1)+1)*tmp;
		for (j=0,x=&amp;f1[j],y=&amp;f2[j];j&lt;i;j++,x++,y++)
		{
			if (*x+t2&lt;*y) *y=*x+t2;
			if (*x+t1&lt;*(y+1)) *(y+1)=*x+t1;
			t1+=tmp,t2+=tmp;
		}
		LL *t=f1;f1=f2;f2=t;
	}
	LL ans=INF;
	for (i=0,x=&amp;f1[i];i&lt;=n;i++,x++)
		if (*x&lt;ans) ans=*x;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem4044</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;

#define maxn 100010

using namespace std;

int T,n,len[maxn],tmp[maxn];
char s[maxn];

bool cmp(int x,int y)
{
	return len[x]&lt;len[y];
}

struct PAM{
	int son[maxn][4],last,pre[maxn],cnt,fa[maxn][20],f[maxn];
	int ID(char ch){
		if(ch=='A') return 0;
		if(ch=='G') return 1;
		if(ch=='C') return 2;
		if(ch=='T') return 3;
	}
	void extend(int idx,int n){
		int p=last;
		while(s[n-len[p]-1]!=s[n]) p=pre[p];
		if(!son[p][idx]){
			int np=++cnt,k=pre[p];
			len[np]=len[p]+2;
			while(s[n-len[k]-1]!=s[n]) k=pre[k];
			pre[np]=son[k][idx];son[p][idx]=np;
		}
		last=son[p][idx];
	}
	void build(){
		for(int i=0;i&lt;=cnt;i++) for(int j=0;j&lt;4;j++) son[i][j]=0;
		for(int i=0;i&lt;=cnt;i++) pre[i]=0;
		for(int i=0;i&lt;=n+1;i++) f[i]=0x3fffffff;
		last=cnt=1;
		pre[1]=pre[0]=1;
		len[1]=-1;
		for(int i=1;i&lt;=n;i++){
			extend(ID(s[i]),i);
		}
	}
	void solve(){
		for(int i=0;i&lt;=cnt;i++) fa[i][0]=pre[i];
		for(int k=1;k&lt;=17;k++)
			for(int i=0;i&lt;=cnt;i++) {
				fa[i][k]=fa[fa[i][k-1]][k-1];
		}
		for(int i=1;i&lt;=cnt;i++) tmp[i]=i;
		sort(tmp+1,tmp+cnt+1,cmp);
		int ans=0x7fffffff;
		for(int i=1;i&lt;=cnt;i++){
			int x=tmp[i];
			f[x]=min(min(f[pre[x]]+len[x]-len[pre[x]],len[x]),f[x]);
			if(!(len[x]&amp;1)){
				int f1=x;
				for(int k=17;k&gt;=0;k--) if(len[fa[f1][k]]&gt;len[x]/2) f1=fa[f1][k];
				f1=fa[f1][0];
				f[x]=min(f[f1]+len[x]/2-len[f1]+1,f[x]);
				for(int i=0;i&lt;4;i++) if(son[x][i]) f[son[x][i]]=min(f[son[x][i]],f[x]+1);
			}
			ans=min(ans,f[x]+n-len[x]);
		}
		printf(&quot;%d\n&quot;,ans);
	}
}pam;

int main()
{
	scanf(&quot;%d&quot;,&amp;T);
	for(int i=1;i&lt;=T;i++){
		scanf(&quot;%s&quot;,s+1);n=strlen(s+1);
		pam.build();
		pam.solve();
	}
}
<pre><h2>Problem4044</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;

#define maxn 100010

using namespace std;

int T,n,len[maxn],tmp[maxn];
char s[maxn];

bool cmp(int x,int y)
{
	return len[x]&lt;len[y];
}

struct PAM{
	int son[maxn][4],last,pre[maxn],cnt,fa[maxn][20],f[maxn];
	int ID(char ch){
		if(ch=='A') return 0;
		if(ch=='G') return 1;
		if(ch=='C') return 2;
		if(ch=='T') return 3;
	}
	void extend(int idx,int n){
		int p=last;
		while(s[n-len[p]-1]!=s[n]) p=pre[p];
		if(!son[p][idx]){
			int np=++cnt,k=pre[p];
			len[np]=len[p]+2;
			while(s[n-len[k]-1]!=s[n]) k=pre[k];
			pre[np]=son[k][idx];son[p][idx]=np;
		}
		last=son[p][idx];
	}
	void build(){
		for(int i=0;i&lt;=cnt;i++) for(int j=0;j&lt;4;j++) son[i][j]=0;
		for(int i=0;i&lt;=cnt;i++) pre[i]=0;
		for(int i=0;i&lt;=n+1;i++) f[i]=0x3fffffff;
		last=cnt=1;
		pre[1]=pre[0]=1;
		len[1]=-1;
		for(int i=1;i&lt;=n;i++){
			extend(ID(s[i]),i);
		}
	}
	void solve(){
		for(int i=0;i&lt;=cnt;i++) fa[i][0]=pre[i];
		for(int k=1;k&lt;=17;k++)
			for(int i=0;i&lt;=cnt;i++) {
				fa[i][k]=fa[fa[i][k-1]][k-1];
		}
		int ans=0x7fffffff;
		for(int i=1;i&lt;=cnt;i++){
			int x=i;
			f[x]=min(min(f[pre[x]]+len[x]-len[pre[x]],len[x]),f[x]);
			if(!(len[x]&amp;1)){
				int f1=x;
				for(int k=17;k&gt;=0;k--) if(len[fa[f1][k]]&gt;len[x]/2) f1=fa[f1][k];
				f1=fa[f1][0];
				f[x]=min(f[f1]+len[x]/2-len[f1]+1,f[x]);
				for(int i=0;i&lt;4;i++) if(son[x][i]) f[son[x][i]]=min(f[son[x][i]],f[x]+1);
			}
			ans=min(ans,f[x]+n-len[x]);
		}
		printf(&quot;%d\n&quot;,ans);
	}
}pam;

int main()
{
	scanf(&quot;%d&quot;,&amp;T);
	for(int i=1;i&lt;=T;i++){
		scanf(&quot;%s&quot;,s+1);n=strlen(s+1);
		pam.build();
		pam.solve();
	}
}
<pre><h2>Problem4052</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define mp make_pair
#define fi first
#define se second
pair&lt;LL,LL&gt; a[101111];
LL tes,n;
LL gcd(LL a,LL b) {return !b?a:gcd(b,a%b);}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%lld&quot;,&amp;n);
		LL x;
		scanf(&quot;%lld&quot;,&amp;x);
		LL ans=x;
		a[1]=mp(x,1);
		LL cnt=1;
		for (LL i=2;i&lt;=n;i++)
		{
			scanf(&quot;%lld&quot;,&amp;x);
			a[++cnt]=mp(x,i);
			for (LL j=1;j&lt;=cnt;j++)
			{
				LL y=gcd(x,a[j].fi);
				ans=max(ans,y*(i-a[j].se+1));
				a[j].fi=y;
			}
			LL t=1;
			for (LL j=2;j&lt;=cnt;j++)
				if (a[j].fi!=a[t].fi) a[++t]=a[j];
			cnt=t;
		}
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem4052</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define mp make_pair
#define fi first
#define se second
pair&lt;LL,int&gt; a[101111];
int tes,n;
LL gcd(LL a,LL b) {return !b?a:gcd(b,a%b);}
int main()
{
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		LL x;
		scanf(&quot;%lld&quot;,&amp;x);
		LL ans=x;
		a[1]=mp(x,1);
		int cnt=1;
		for (int i=2;i&lt;=n;i++)
		{
			scanf(&quot;%lld&quot;,&amp;x);
			a[++cnt]=mp(x,i);
			for (int j=1;j&lt;=cnt;j++)
			{
				LL y=gcd(x,a[j].fi);
				ans=max(ans,y*(i-a[j].se+1));
				a[j].fi=y;
			}
			int t=1;
			for (int j=2;j&lt;=cnt;j++)
				if (a[j].fi!=a[t].fi) a[++t]=a[j];
			cnt=t;
		}
		printf(&quot;%lld\n&quot;,ans);
	}
}<pre><h2>Problem4059</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;map&gt;
using namespace std;
const int NN=201111;
int n,tes,pre[NN],nex[NN],a[NN];
map&lt;int,int&gt; M;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
bool work(int l,int r)
{
	if (l&gt;=r) return false;
	for (int i=l,j=r;i&lt;=j;i++,j--)
	{
		if (pre[i]&lt;l&amp;&amp;nex[i]&gt;r)
			return work(l,i-1)||work(i+1,r);
		if (pre[j]&lt;l&amp;&amp;nex[j]&gt;r)
			return work(l,j-1)||work(j+1,r);
	}
	return true;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (read(tes);tes;tes--)
	{
		int i;
		read(n);
		for (i=1;i&lt;=n;i++) read(a[i]);
		M.clear();
		for (i=1;i&lt;=n;i++)
		{
			pre[i]=M[a[i]];
			M[a[i]]=i;
		}
		M.clear();
		for (i=n;i;i--)
		{
			
			nex[i]=M.count(a[i])?M[a[i]]:n+1;
			M[a[i]]=i;
		}
		if (!work(1,n)) printf(&quot;non-boring\n&quot;);
		else printf(&quot;boring\n&quot;);
	}
	return 0;
}<pre><h2>Problem4063</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int tes,n;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
	if (f) x=-x;
}
inline int calc(int d)
{
	static int a[]={0,20,40,60,80,100,120,140,160,180,200,220};
	int i;
	for (i=10;i;i--)
		if (d&gt;a[i]*a[i]) break;
	return 11-a[i+1]/20;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (read(tes);tes;tes--)
	{
		read(n);
		int ans=0,x,y;
		for (int i=1;i&lt;=n;i++)
		{
			read(x),read(y);
			ans+=calc(x*x+y*y);
		}
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem4069</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define inf 999999999
int a[2111];
LL sum[2111];
int n,A,B;
bool check1(LL X)
{
	static int f[2111];
	f[0]=0;
	for (int i=1;i&lt;=n;i++)
	{
		f[i]=inf;
		for (int j=0;j&lt;i;j++)
		{
			LL tmp=sum[i]-sum[j];
			if ((X|tmp)==X) f[i]=min(f[i],f[j]+1);
		}
		//printf(&quot;f[%d]=%d\n&quot;,i,f[i]);
	}
	return f[n]&lt;=B;
}
bool check2(LL X)
{
	static bool f[111][111];
	memset(f,0,sizeof(f));
	f[0][0]=true;
	int i,j,k;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=B;j++)
			for (k=0;k&lt;i;k++)
			{
				LL tmp=sum[i]-sum[k];
				if ((X|tmp)==X) f[i][j]|=f[k][j-1];
			}
	for (j=A;j&lt;=B;j++)
		if (f[n][j]) return true;
	return false;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;A,&amp;B);
	int i;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		sum[i]=sum[i-1]+a[i];
	}
	LL ans=0;
	for (i=60;i;i--)
	{
		//printf(&quot;\n------------------------------------------------------------\n&quot;);
		bool flag=false;
		LL tmp=ans+(1ll&lt;&lt;(i-1))-1;
		//printf(&quot;tmp=%I64d\n&quot;,tmp);
		if (A==1) flag=check1(tmp);
		else flag=check2(tmp);
		if (!flag) ans|=1ll&lt;&lt;(i-1);
		//printf(&quot;ans=%I64d\n&quot;,ans);
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem4069</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define inf 999999999
int a[2111];
LL sum[2111];
int n,A,B;
bool check1(LL X)
{
	static int f[2111];
	f[0]=0;
	for (int i=1;i&lt;=n;i++)
	{
		f[i]=inf;
		for (int j=0;j&lt;i;j++)
		{
			LL tmp=sum[i]-sum[j];
			if ((X|tmp)==X) f[i]=min(f[i],f[j]+1);
		}
	}
	return f[n]&lt;=B;
}
bool check2(LL X)
{
	static bool f[101][101];
	memset(f,0,sizeof(f));
	f[0][0]=true;
	int i,j,k;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=B;j++)
			for (k=0;k&lt;i;k++)
			{
				LL tmp=sum[i]-sum[k];
				if ((X|tmp)==X) f[i][j]|=f[k][j-1];
			}
	for (j=A;j&lt;=B;j++)
		if (f[n][j]) return true;
	return false;
}
int main()
{
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;A,&amp;B);
	int i;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		sum[i]=sum[i-1]+a[i];
	}
	LL ans=0;
	for (i=41;i;i--)
	{
		bool flag=false;
		LL tmp=(ans|(1ll&lt;&lt;(i-1)))-1;
		if (A==1) flag=check1(tmp);
		else flag=check2(tmp);
		if (!flag) ans|=1ll&lt;&lt;(i-1);
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem4080</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;bitset&gt;
using namespace std;
#define sqr(x) ((x)*(x))
const int NN=103;
int X[NN],Y[NN],id[NN];
int n,D;
bitset&lt;NN&gt; go[NN],ans,now,can;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;D);
	D=D*D;
	int i,j;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;X[i],&amp;Y[i]);
	for (i=1;i&lt;=n;i++)
		for (j=i+1;j&lt;=n;j++)
			if (sqr(X[i]-X[j])+sqr(Y[i]-Y[j])&lt;=D)
				go[i][j]=go[j][i]=1;
	for (i=1;i&lt;=n;i++) id[i]=i;
	for (int tt=1000;tt;tt--)
	{
		random_shuffle(id+1,id+n+1);
		can.set();
		now.reset();
		for (i=1;i&lt;=n&amp;&amp;can.count();i++)
		{
			int x=id[i];
			if (can[x]==0) continue;
			now[x]=1;
			can&amp;=go[x];
		}
		if (now.count()&gt;ans.count()) ans=now;
	}
	printf(&quot;%d\n&quot;,ans.count());
	int t=0;
	for (i=1;i&lt;=n;i++)
		if (ans[i]==1) printf(&quot;%d &quot;,i);
	return 0;
}<pre><h2>Problem4084</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
using namespace std;
typedef unsigned long long UL;
const int N = 4005000;
const UL C = 29;
char dr[N];
UL has[N];
UL ci[N];
int n,m,s,t,ave;
struct node
{
	int biao;
	bool lei;
	UL val;
}xu[N];
int cc=0;
int ever[N];
void makexu(int x,int len)
{
	int i;
	has[0]=0;
	for(i=1;i&lt;=len;i++)
		has[i]=has[i-1]*C+dr[i];
	cc++;
	xu[cc].lei=0;
	xu[cc].biao=x;
	xu[cc].val=has[len];
}
void make(int x,int len)
{
	int i;
	has[0]=0;
	for(i=1;i&lt;=len;i++)
		has[i]=has[i-1]*C+dr[i];
	int last=len-ave;
	UL key=has[len]-has[ave]*ci[last];
	for(i=last;i&lt;=ave;i++)
	{
		if(has[i]-has[i-last]*ci[last]==key)
		{
			UL now=has[i-last]+(has[ave]-has[i]*ci[ave-i])*ci[i-last];
			cc++;
			xu[cc].lei=1;
			xu[cc].val=now;
			xu[cc].biao=x;
		}
	}
	for(i=1;i&lt;last;i++)
	{
		UL now=has[i]+(has[ave]-has[ave-last+i]*ci[last-i])*ci[i];
		if(now==key)
		{
			cc++;
			xu[cc].lei=1;
			xu[cc].val=has[i+ave-last]-has[i]*ci[ave-last];
			xu[cc].biao=x;
		}
	}
}
void GetData()
{
	int i,j;
	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;s,&amp;t);
	ave=(s+t)/2;
	if(s&gt;=t)
	{
		ci[0]=1;
		for(i=1;i&lt;=s;i++)
			ci[i]=ci[i-1]*C;
		for(i=1;i&lt;=n;i++)
		{
			scanf(&quot;%s&quot;,dr+1);
			make(i,s);
		}
		for(i=1;i&lt;=m;i++)
		{
			scanf(&quot;%s&quot;,dr+1);
			makexu(i,t);
		}
	}
	else
	{
		ci[0]=1;
		for(i=1;i&lt;=t;i++)
			ci[i]=ci[i-1]*C;
		for(i=1;i&lt;=n;i++)
		{
			scanf(&quot;%s&quot;,dr+1);
			for(j=1;j&lt;=s/2;j++)
				swap(dr[j],dr[s-j+1]);
			makexu(i,s);
		}
		for(i=1;i&lt;=m;i++)
		{
			scanf(&quot;%s&quot;,dr+1);
			for(j=1;j&lt;=t/2;j++)
				swap(dr[j],dr[t-j+1]);
			make(i,t);
		}
	}
}
bool cmp(node x,node y)
{
	return(x.val&lt;y.val);
}
void DoIt()
{
	int i;
	long long ans=0;
	int tot=0;
	sort(xu+1,xu+cc+1,cmp);
	for(i=1;i&lt;=cc;)
	{
		int totx=0;
		int toty=0;
		tot++;
		UL key=xu[i].val;
		while(i&lt;=cc &amp;&amp; xu[i].val==key)
		{
			if(xu[i].lei==0)
				totx++;
			else
			{
				if(ever[xu[i].biao]!=tot)
				{
					ever[xu[i].biao]=tot;
					toty++;
				}
			}
			i++;
		}
		long long now=totx;
		now*=toty;
		ans+=now;
	}
	cout&lt;&lt;ans&lt;&lt;endl;
}
int main()
{
//	freopen(&quot;bigyration.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;bigyration.out&quot;,&quot;w&quot;,stdout);
	GetData();
	DoIt();
	return 0;
}<pre><h2>Problem4084</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
typedef pair&lt;int,int&gt; pii;
#define p1 37
#define mo1 10000019
#define p2 19980723
#define fi first
#define se second
#define mp make_pair
#define ln printf(&quot;\n&quot;)
int S,T,n,m,len,TIME,st[4000005];
int h1[8000005],h2[8000005],mi1[8000005],mi2[8000005];
char s0[4000111],s[4000005];
pii rec[4000005];
bool vt[4000005];
char s1[111][111],s2[111][111];
struct HT
{
	int o[mo1],aa[5000000][2],vt[5000000],tot;
	LL f[5000000];
	void insert(pii tt)
	{
		int X=tt.fi,Y=tt.se;
		for (int p=o[X];p;p=aa[p][0])
			if (aa[p][1]==Y)
			{
				if (vt[p]!=TIME)
					vt[p]=TIME,f[p]++;
				return;
			}
		tot++;aa[tot][1]=Y;aa[tot][0]=o[X];
		o[X]=tot;vt[tot]=TIME;f[tot]=1;
		//printf(&quot;%d\n&quot;,tot);
	}
	LL find(pii tt)
	{
		int X=tt.fi,Y=tt.se;
		for (int p=o[X];p;p=aa[p][0])
			if (aa[p][1]==Y) return f[p];
		return 0;
	}
} ht;
inline char du()
{
	char ch=getchar();
	while (ch&lt;'a'||ch&gt;'z') ch=getchar();
	return ch;
}
inline pii geth(int l,int r)
{
	//printf(&quot;get %d %d\n&quot;,l,r);
	int t1=0,t2=0;
	t1=((LL)h1[r]-(LL)h1[l-1]*mi1[r-l+1])%mo1;
	if (t1&lt;0) t1+=mo1;
	t2=h2[r]-h2[l-1]*mi2[r-l+1];
	return mp(t1,t2);
}
void init1()
{
	int cnt=0,i,j;
	for (i=1;i&lt;=S;i++)
	{
		st[i]=cnt+1;
		for (j=1;j&lt;=n;j++) s0[++cnt]=du();
	}
	for (i=1;i&lt;=T;i++)
	{
		int t1=0,t2=0;
		for (j=1;j&lt;=m;j++)
		{
			char ch=du();
			int t=ch-'a'+1;
			t1=(t1*p1+t)%mo1;
			t2=t2*p2+t;
		}
		rec[i]=mp(t1,t2);
	}
}
void work1(int e)
{
	TIME++;
	int t=st[e],i;
	for (i=1;i&lt;=n;i++) s[i]=s0[t++];
	LL t1=0,t2=0;
	for (i=len+1;i&lt;=n;i++)
	{
		t1=(t1*p1+s[i]-'a'+1)%mo1;
		t2=t2*p2+s[i]-'a'+1;
	}
	pii tmp=mp(t1,t2);
	for (i=len+1;i&lt;len+len;i++) s[i]=s[i-len];
	h1[0]=h2[0]=0;
	for (i=1;i&lt;len+len;i++)
	{
		h1[i]=(h1[i-1]*p1+s[i]-'a'+1)%mo1;
		h2[i]=h2[i-1]*p2+s[i]-'a'+1;
	}
	for (i=1;i&lt;=len;i++)
		if (geth(i,i+n-len-1)==tmp)
		{
			pii the=geth(i+n-len,i+len-1);
			ht.insert(the);
		}
}
void init2()
{
	int cnt=0,i,j;
	for (i=1;i&lt;=S;i++)
	{
		int t1=0,t2=0;
		for (j=1;j&lt;=n;j++)
		{
			char ch=du();
			int t=ch-'a'+1;
			t1=(t1*p1+t)%mo1;
			t2=t2*p2+t;
		}
		rec[i]=mp(t1,t2);
	}
	for (i=1;i&lt;=T;i++)
	{
		st[i]=cnt+1;
		for (j=1;j&lt;=m;j++) s0[++cnt]=du();
	}
}
void work2(int e)
{
	TIME++;
	int t=st[e],i;
	for (i=1;i&lt;=m;i++) s[i]=s0[t++];
	int t1=0,t2=0;
	for (i=1;i&lt;=m-len;i++)
	{
		t1=(t1*p1+s[i]-'a'+1)%mo1;
		t2=t2*p2+s[i]-'a'+1;
	}
	pii tmp=mp(t1,t2);
	for (i=1;i&lt;=len;i++) s[i]=s[i+m-len];
	for (i=len+1;i&lt;len+len;i++) s[i]=s[i-len];
	h1[0]=h2[0]=0;
	for (i=1;i&lt;len+len;i++)
	{
		h1[i]=(h1[i-1]*p1+s[i]-'a'+1)%mo1;
		h2[i]=h2[i-1]*p2+s[i]-'a'+1;
	}
	t=m-len;
	for (i=len+len-1;i&gt;=len;i--)
		if (geth(i-t+1,i)==tmp)
		{
			pii the=geth(i-len+1,i-t);
			ht.insert(the);
		}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	mi1[0]=mi2[0]=1;
	int i;
	for (i=1;i&lt;=4000005;i++)
	{
		mi1[i]=mi1[i-1]*p1%mo1;
		mi2[i]=mi2[i-1]*p2;
	}
	scanf(&quot;%d%d%d%d\n&quot;,&amp;S,&amp;T,&amp;n,&amp;m);
	len=(n+m)/2;
	LL ans=0;
	if (n&gt;=m)
	{
		init1();
		for (i=1;i&lt;=S;i++) work1(i);
		for (i=1;i&lt;=T;i++) ans+=ht.find(rec[i]);
	}
	else
	{
		init2();
		for (i=1;i&lt;=T;i++) work2(i);
		for (i=1;i&lt;=S;i++) ans+=ht.find(rec[i]);
	}
	cout&lt;&lt;ans&lt;&lt;endl;//printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem4084</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
typedef pair&lt;int,int&gt; pii;
#define p1 37
#define mo1 10000019
#define p2 19980723
#define fi first
#define se second
#define mp make_pair
int S,T,n,m,len,TIME,st[4000005];
int h1[8000005],h2[8000005],mi1[8000005],mi2[8000005];
char s0[4000111],s[4000005];
pii rec[4000005];
bool vt[4000005];
char s1[111][111],s2[111][111];
struct HT
{
	int o[mo1],aa[5000000][2],vt[5000000],tot;
	LL f[5000000];
	void insert(pii tt)
	{
		int X=tt.fi,Y=tt.se;
		for (int p=o[X];p;p=aa[p][0])
			if (aa[p][1]==Y)
			{
				if (vt[p]!=TIME)
					vt[p]=TIME,f[p]++;
				return;
			}
		tot++;aa[tot][1]=Y;aa[tot][0]=o[X];
		o[X]=tot;vt[tot]=TIME;f[tot]=1;
	}
	LL find(pii tt)
	{
		int X=tt.fi,Y=tt.se;
		for (int p=o[X];p;p=aa[p][0])
			if (aa[p][1]==Y) return f[p];
		return 0;
	}
} ht;
inline char du()
{
	char ch=getchar();
	while (ch&lt;'a'||ch&gt;'z') ch=getchar();
	return ch;
}
inline pii geth(int l,int r)
{
	int t1=0,t2=0;
	t1=((LL)h1[r]-(LL)h1[l-1]*mi1[r-l+1])%mo1;
	if (t1&lt;0) t1+=mo1;
	t2=h2[r]-h2[l-1]*mi2[r-l+1];
	return mp(t1,t2);
}
void init1()
{
	int cnt=0,i,j;
	for (i=1;i&lt;=S;i++)
	{
		st[i]=cnt+1;
		for (j=1;j&lt;=n;j++) s0[++cnt]=du();
	}
	for (i=1;i&lt;=T;i++)
	{
		int t1=0,t2=0;
		for (j=1;j&lt;=m;j++)
		{
			char ch=du();
			int t=ch-'a'+1;
			t1=(t1*p1+t)%mo1;
			t2=t2*p2+t;
		}
		rec[i]=mp(t1,t2);
	}
}
void work1(int e)
{
	TIME++;
	int t=st[e],i;
	for (i=1;i&lt;=n;i++) s[i]=s0[t++];
	LL t1=0,t2=0;
	for (i=len+1;i&lt;=n;i++)
	{
		t1=(t1*p1+s[i]-'a'+1)%mo1;
		t2=t2*p2+s[i]-'a'+1;
	}
	pii tmp=mp(t1,t2);
	for (i=len+1;i&lt;len+len;i++) s[i]=s[i-len];
	h1[0]=h2[0]=0;
	for (i=1;i&lt;len+len;i++)
	{
		h1[i]=(h1[i-1]*p1+s[i]-'a'+1)%mo1;
		h2[i]=h2[i-1]*p2+s[i]-'a'+1;
	}
	for (i=1;i&lt;=len;i++)
		if (geth(i,i+n-len-1)==tmp)
		{
			pii the=geth(i+n-len,i+len-1);
			ht.insert(the);
		}
}
void init2()
{
	int cnt=0,i,j;
	for (i=1;i&lt;=S;i++)
	{
		int t1=0,t2=0;
		for (j=1;j&lt;=n;j++)
		{
			char ch=du();
			int t=ch-'a'+1;
			t1=(t1*p1+t)%mo1;
			t2=t2*p2+t;
		}
		rec[i]=mp(t1,t2);
	}
	for (i=1;i&lt;=T;i++)
	{
		st[i]=cnt+1;
		for (j=1;j&lt;=m;j++) s0[++cnt]=du();
	}
}
void work2(int e)
{
	TIME++;
	int t=st[e],i;
	for (i=1;i&lt;=m;i++) s[i]=s0[t++];
	int t1=0,t2=0;
	for (i=1;i&lt;=m-len;i++)
	{
		t1=(t1*p1+s[i]-'a'+1)%mo1;
		t2=t2*p2+s[i]-'a'+1;
	}
	pii tmp=mp(t1,t2);
	for (i=1;i&lt;=len;i++) s[i]=s[i+m-len];
	for (i=len+1;i&lt;len+len;i++) s[i]=s[i-len];
	h1[0]=h2[0]=0;
	for (i=1;i&lt;len+len;i++)
	{
		h1[i]=(h1[i-1]*p1+s[i]-'a'+1)%mo1;
		h2[i]=h2[i-1]*p2+s[i]-'a'+1;
	}
	t=m-len;
	for (i=len+len-1;i&gt;=len;i--)
		if (geth(i-t+1,i)==tmp)
		{
			pii the=geth(i-len+1,i-t);
			ht.insert(the);
		}
}
int main()
{
	mi1[0]=mi2[0]=1;
	int i;
	for (i=1;i&lt;=4000005;i++)
	{
		mi1[i]=mi1[i-1]*p1%mo1;
		mi2[i]=mi2[i-1]*p2;
	}
	scanf(&quot;%d%d%d%d\n&quot;,&amp;S,&amp;T,&amp;n,&amp;m);
	len=(n+m)/2;
	LL ans=0;
	if (n&gt;=m)
	{
		init1();
		for (i=1;i&lt;=S;i++) work1(i);
		for (i=1;i&lt;=T;i++) ans+=ht.find(rec[i]);
	}
	else
	{
		init2();
		for (i=1;i&lt;=T;i++) work2(i);
		for (i=1;i&lt;=S;i++) ans+=ht.find(rec[i]);
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem4094</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define INF 9999999999999999ll
#define ls (v&lt;&lt;1)
#define rs (v&lt;&lt;1|1)
int n,m,a[41111];
struct segnode
{
	LL f[2][2];
	LL getmax() {return max(max(f[0][0],f[1][1]),max(f[0][1],f[1][0]));}
	void set(int x)
	{
		f[0][0]=0,f[1][1]=x;
		f[0][1]=f[1][0]=-INF;
	}
	friend segnode operator +(const segnode &amp;a,const segnode &amp;b)
	{
		segnode res;
		res.f[0][0]=max(a.f[0][0]+b.f[0][0],max(a.f[0][1]+b.f[0][0],a.f[0][0]+b.f[1][0]));
		res.f[1][1]=max(a.f[1][0]+b.f[0][1],max(a.f[1][1]+b.f[0][1],a.f[1][0]+b.f[1][1]));
		res.f[0][1]=max(a.f[0][0]+b.f[0][1],max(a.f[0][0]+b.f[1][1],a.f[0][1]+b.f[0][1]));
		res.f[1][0]=max(a.f[1][0]+b.f[0][0],max(a.f[1][0]+b.f[1][0],a.f[1][1]+b.f[0][0]));
		return res;
	}
} E[200000];
void build(int v,int l,int r)
{
	if (r-l==1)
	{
		E[v].set(a[l]);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(ls,l,mid);
	build(rs,mid,r);
	E[v]=E[ls]+E[rs];
}
void change(int v,int l,int r,int i,int x)
{
	if (r-l==1)
	{
		E[v].set(x);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid) change(ls,l,mid,i,x);
	else change(rs,mid,r,i,x);
	E[v]=E[ls]+E[rs];
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,x,y;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	build(1,1,n+1);
	LL ans=0;
	for (;m;m--)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		change(1,1,n+1,x,y);
		ans+=E[1].getmax();
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem4104</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define fi first
#define se second
int n,m;
pair&lt;int,int&gt; a[201111];
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i;
	for (i=0;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i].fi),a[i].se=i;
	sort(a,a+n+1);
	int t=a[0].se;
	for (i=1;i&lt;=n;i++,t=a[t].se) printf(&quot;%d &quot;,a[t].fi);
	return 0;
}<pre><h2>Problem4105</h2><pre>#include&lt;cstdio&gt;
int n,m,P,b[10000],l,r,ans,a[100001],x,i;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;P);
	for (i=0;i&lt;=P;i++) b[i]=i*i%P;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,a+i);
	for (;m--;)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;l,&amp;r);
		if (x==0) for (;l&lt;=r;l++) a[l]=b[a[l]];
		else
		{
			for (ans=0;l&lt;=r;l++) ans+=a[l];
			printf(&quot;%d\n&quot;,ans);
		}
	}
	return 0;
}<pre><h2>Problem4105</h2><pre>#include&lt;cstdio&gt;
int n,m,P,b[10000],l,r,ans,a[100001],x,i;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;P);
	for (i=0;i&lt;=P;i++) b[i]=i*i%P;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,a+i);
	for (;m--;)
	{
		read(x),read(l),read(r);
		if (x==0) for (;l&lt;=r;l++) a[l]=b[a[l]];
		else
		{
			for (ans=0;l&lt;=r;l++) ans+=a[l];
			printf(&quot;%d\n&quot;,ans);
		}
	}
	return 0;
}<pre><h2>Problem4105</h2><pre>#include&lt;cstdio&gt;
int n,m,P,b[10000],l,r,ans,a[100001],x,i;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;P);
	for (i=0;i&lt;=P;i++) b[i]=i*i%P;
	for (i=1;i&lt;=n;i++) read(a[i]);
	for (;m--;)
	{
		read(x),read(l),read(r);
		if (x==0) for (;l&lt;=r;l++) a[l]=b[a[l]];
		else
		{
			for (ans=0;l&lt;=r;l++) ans+=a[l];
			printf(&quot;%d\n&quot;,ans);
		}
	}
	return 0;
}<pre><h2>Problem4105</h2><pre>#include&lt;cstdio&gt;
int n,m,P,a[100001],b[9978];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m),read(P);
	int i,op,l,r,*x;
	for (i=0;i&lt;P;i++) b[i]=i*i%P;
	for (i=1;i&lt;=n;i++) read(a[i]);
	for (;m;m--)
	{
		read(op),read(l),read(r);
		if (op==0)
			for (x=&amp;a[l],i=l;i&lt;=r;i++) a[i]=b[a[i]];
		else
		{
			int ans=0;
			for (x=&amp;a[l],i=l;i&lt;=r;i++) ans+=a[i];
			printf(&quot;%d\n&quot;,ans);
		}
	}
	return 0;
}<pre><h2>Problem4105</h2><pre>#include&lt;cstdio&gt;
int n,m,P,a[100001],b[9978];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m),read(P);
	int i,op,l,r,*x;
	for (i=0;i&lt;P;i++) b[i]=i*i%P;
	for (i=1;i&lt;=n;i++) read(a[i]);
	for (;m;m--)
	{
		read(op),read(l),read(r);
		if (op==0)
			for (x=&amp;a[l],i=l;i&lt;=r;i++,x++) a[i]=b[a[i]];
		else
		{
			int ans=0;
			for (x=&amp;a[l],i=l;i&lt;=r;i++,x++) ans+=a[i];
			printf(&quot;%d\n&quot;,ans);
		}
	}
	return 0;
}<pre><h2>Problem4106</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;iostream&gt;
using namespace std;
typedef long double DD;
const DD dinf=1e30;
DD p,a,b,c,d;
int n;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	while (cin&gt;&gt;p&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;n)
	{
		DD ans=-dinf,mm=-dinf;
		for (int k=1;k&lt;=n;k++)
		{
			DD tmp= p * (sin(a * k + b) + cos(c * k + d) + 2);
			if (tmp&gt;mm) mm=tmp;
			if (mm-tmp&gt;ans) ans=mm-tmp;
		}
		printf(&quot;%.6f\n&quot;,(double)ans);
	}
	return 0;
}<pre><h2>Problem4108</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 999999999
#define h1(i) ((i)*2-1)
#define h2(i) ((i)*2)
const int NN=255;
int o[NN],aa[NN*NN*4][4],pre[NN];
int n,tot=1,S,T,K;
inline void addedge(int p,int q,int v,int c)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][3]=c;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline void add(int p,int q,int v,int c)
{
	//printf(&quot;add %d %d %d %d\n&quot;,p,q,v,c);
	addedge(p,q,v,c);
	addedge(q,p,0,-c);
}
bool spfa()
{
	static int dist[NN],que[NN+10];
	static bool dl[NN];
	memset(dist,60,sizeof(dist));
	dist[S]=0;
	memset(dl,0,sizeof(dl));
	int head=0,tail=1;
	que[1]=S;
	dl[S]=true;
	while (head!=tail)
	{
		head++;if (head&gt;NN) head=1;
		int x=que[head];
		dl[x]=false;
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;dist[y]&gt;dist[x]+aa[p][3])
			{
				dist[y]=dist[x]+aa[p][3];
				pre[y]=p;
				if (!dl[y])
				{
					dl[y]=true;
					tail++;if (tail&gt;NN) tail=1;
					que[tail]=y;
				}
			}
		}
	}
	return dist[T]&lt;dist[0];
}
int calc()
{
	int p,ff=inf,res=0;
	for (p=pre[T];p;p=pre[aa[p^1][1]])
		ff=min(ff,aa[p][2]);
	for (p=pre[T];p;p=pre[aa[p^1][1]])
	{
		res+=ff*aa[p][3];
		aa[p][2]-=ff,aa[p^1][2]+=ff;
	}
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	while (scanf(&quot;%d%d&quot;,&amp;n,&amp;K)!=EOF)
	{
		S=2*(n+1)+1,T=S+1;
		memset(o,0,sizeof(o));tot=1;
		add(S,h2(1),K,0);
		int i,j,x;
		for (i=2;i&lt;=n+1;i++)
		{
			add(S,h2(i),1,0);
			add(h1(i),T,1,0);
		}
		for (i=1;i&lt;=n;i++)
			for (j=1;j&lt;=n-i+1;j++)
			{
				scanf(&quot;%d&quot;,&amp;x);
				add(h2(i),h1(i+j),inf,x);
			}
		int ans=0;
		while (spfa()) ans+=calc();
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem4127</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define INF 9999999999999999ll
#define ls (v&lt;&lt;1)
#define rs (v&lt;&lt;1|1)
#define ln printf(&quot;\n&quot;)
const int NN=101111;
int o[NN],aa[NN&lt;&lt;1][2],size[NN],deep[NN],fa[NN],hea[NN],up[NN],pos[NN],dy[NN],w[NN];
int n,m,tot=1,cnt,ww,ee;
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);ln;}
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
	if (f) x=-x;
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs1(int v)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		dfs1(y);
		size[v]+=size[y];
		if (size[y]&gt;size[hea[v]]) hea[v]=y;
	}
}
void dfs2(int v)
{
	pos[v]=++cnt;
	dy[cnt]=v;
	if (hea[v])
	{
		up[hea[v]]=up[v];
		dfs2(hea[v]);
	}
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||y==hea[v]) continue;
		up[y]=y;
		dfs2(y);
	}
}
struct segnode
{
	int n1,n2,l,r;
	LL tsum,tmax,tag;
	void out() {printf(&quot;n1=%d n2=%d  tsum=%lld tmax=%lld\n&quot;,n1,n2,tsum,tmax);}
	void set(LL x)
	{
		if (x&gt;=0) tsum=x,tmax=-INF,n1=0,n2=1;
		else tsum=-x,tmax=x,n1=1,n2=0;
	}
	void add(LL x)
	{
		tsum+=x*(n2-n1);
		tmax+=x,tag+=x;
	}
	friend segnode operator +(segnode a,segnode b)
	{
		segnode res;
		res.tsum=a.tsum+b.tsum;
		res.tmax=max(a.tmax,b.tmax);
		res.n1=a.n1+b.n1;
		res.n2=a.n2+b.n2;
		return res;
	}
} E[NN&lt;&lt;2];
inline void pushdown(int v)
{
	if (E[v].tag)
	{
		E[ls].add(E[v].tag);
		E[rs].add(E[v].tag);
		E[v].tag=0;
	}
}
void build(int v,int l,int r)
{
	E[v].l=l,E[v].r=r;
	E[v].tag=0;
	if (r-l==1)
	{
		E[v].set(w[dy[l]]);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(ls,l,mid);
	build(rs,mid,r);
	E[v]=E[ls]+E[rs];
}
void change(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee&amp;&amp;E[v].tmax+x&lt;0)
	{
		E[v].add(x);
		return;
	}
	if (r-l==1)
	{
		E[v].set(E[v].tmax+x);
		return;
	}
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) change(ls,l,mid,x);
	if (ee&gt;mid) change(rs,mid,r,x);
	E[v]=E[ls]+E[rs];
}
LL find(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return E[v].tsum;
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;LL res=0;
	if (ww&lt;mid) res+=find(ls,l,mid);
	if (ee&gt;mid) res+=find(rs,mid,r);
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n),read(m);
	int i,x,y,z;
	for (i=1;i&lt;=n;i++) read(w[i]);
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y);
		addedge(x,y),addedge(y,x);
	}
	deep[1]=1,dfs1(1);
	up[1]=1,dfs2(1);
	build(1,1,n+1);
	//printf(&quot;up &quot;);out(up,1,n);printf(&quot;dy &quot;);out(dy,1,n);ln;
	for (;m;m--)
	{
		//printf(&quot;\n------------------------------------------------------------------------\n&quot;);
		read(z),read(x),read(y);
		if (z==1)
		{
			read(z);
			while (up[x]!=up[y])
			{
				if (deep[up[x]]&lt;deep[up[y]]) {int t=x;x=y;y=t;}
				ww=pos[up[x]],ee=pos[x]+1;
				change(1,1,n+1,z);
				x=fa[up[x]];
			}
			if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
			ww=pos[y],ee=pos[x]+1;
			if (ww&lt;ee) change(1,1,n+1,z);
		}
		else
		{
			LL ans=0;
			while (up[x]!=up[y])
			{
				if (deep[up[x]]&lt;deep[up[y]]) {int t=x;x=y;y=t;}
				ww=pos[up[x]],ee=pos[x]+1;
				ans+=find(1,1,n+1);
				x=fa[up[x]];
			}
			if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
			ww=pos[y],ee=pos[x]+1;
			if (ww&lt;ee) ans+=find(1,1,n+1);
			printf(&quot;%lld\n&quot;,ans);
		}
	}
	return 0;
}<pre><h2>Problem4127</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define INF 9999999999999999ll
#define ls (v&lt;&lt;1)
#define rs (v&lt;&lt;1|1)
const int NN=101111;
int o[NN],aa[NN&lt;&lt;1][2],size[NN],deep[NN],fa[NN],hea[NN],up[NN],pos[NN],dy[NN],w[NN];
int n,m,tot=1,cnt,ww,ee;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
	if (f) x=-x;
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs1(int v)
{
	size[v]=1;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		dfs1(y);
		size[v]+=size[y];
		if (size[y]&gt;size[hea[v]]) hea[v]=y;
	}
}
void dfs2(int v)
{
	pos[v]=++cnt;
	dy[cnt]=v;
	if (hea[v])
	{
		up[hea[v]]=up[v];
		dfs2(hea[v]);
	}
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]||y==hea[v]) continue;
		up[y]=y;
		dfs2(y);
	}
}
struct segnode
{
	int n1,n2,l,r;
	LL tsum,tmax,tag;
	void set(LL x)
	{
		if (x&gt;=0) tsum=x,tmax=-INF,n1=0,n2=1;
		else tsum=-x,tmax=x,n1=1,n2=0;
	}
	void add(LL x)
	{
		tsum+=x*(n2-n1);
		tmax+=x,tag+=x;
	}
	friend segnode operator +(const segnode &amp;a,const segnode &amp;b)
	{
		segnode res;
		res.tsum=a.tsum+b.tsum;
		res.tmax=max(a.tmax,b.tmax);
		res.n1=a.n1+b.n1;
		res.n2=a.n2+b.n2;
		return res;
	}
} E[NN&lt;&lt;2];
inline void pushdown(int v)
{
	if (E[v].tag)
	{
		E[ls].add(E[v].tag);
		E[rs].add(E[v].tag);
		E[v].tag=0;
	}
}
void build(int v,int l,int r)
{
	E[v].l=l,E[v].r=r;
	E[v].tag=0;
	if (r-l==1)
	{
		E[v].set(w[dy[l]]);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	build(ls,l,mid);
	build(rs,mid,r);
	E[v]=E[ls]+E[rs];
}
void change(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee&amp;&amp;E[v].tmax+x&lt;0)
	{
		E[v].add(x);
		return;
	}
	if (r-l==1)
	{
		E[v].set(E[v].tmax+x);
		return;
	}
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) change(ls,l,mid,x);
	if (ee&gt;mid) change(rs,mid,r,x);
	E[v]=E[ls]+E[rs];
}
LL find(int v,int l,int r)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee) return E[v].tsum;
	pushdown(v);
	int mid=(l+r)&gt;&gt;1;LL res=0;
	if (ww&lt;mid) res+=find(ls,l,mid);
	if (ee&gt;mid) res+=find(rs,mid,r);
	return res;
}
int main()
{
	read(n),read(m);
	int i,x,y,z;
	for (i=1;i&lt;=n;i++) read(w[i]);
	for (i=1;i&lt;n;i++)
	{
		read(x),read(y);
		addedge(x,y),addedge(y,x);
	}
	deep[1]=1,dfs1(1);
	up[1]=1,dfs2(1);
	build(1,1,n+1);
	for (;m;m--)
	{
		read(z),read(x),read(y);
		if (z==1)
		{
			read(z);
			while (up[x]!=up[y])
			{
				if (deep[up[x]]&lt;deep[up[y]]) {int t=x;x=y;y=t;}
				ww=pos[up[x]],ee=pos[x]+1;
				change(1,1,n+1,z);
				x=fa[up[x]];
			}
			if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
			ww=pos[y],ee=pos[x]+1;
			if (ww&lt;ee) change(1,1,n+1,z);
		}
		else
		{
			LL ans=0;
			while (up[x]!=up[y])
			{
				if (deep[up[x]]&lt;deep[up[y]]) {int t=x;x=y;y=t;}
				ww=pos[up[x]],ee=pos[x]+1;
				ans+=find(1,1,n+1);
				x=fa[up[x]];
			}
			if (deep[x]&lt;deep[y]) {int t=x;x=y;y=t;}
			ww=pos[y],ee=pos[x]+1;
			if (ww&lt;ee) ans+=find(1,1,n+1);
			printf(&quot;%lld\n&quot;,ans);
		}
	}
	return 0;
}<pre><h2>Problem4128</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
using namespace std;
const int NN=75;
int n,P;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();bool f=false;
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar())
		if (ch=='-') f=true;
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
	if (f) x=-x;
}
struct matrix
{
	int qq[NN][NN];
	matrix() {memset(qq,0,sizeof(qq));}
	int * operator [](int x) {return qq[x];}
	void in()
	{
		for (int i=1;i&lt;=n;i++)
			for (int j=1;j&lt;=n;j++) read(qq[i][j]);
	}
} A,B;
struct matrix2
{
	int qq[NN];
	matrix2() {memset(qq,0,sizeof(qq));}
	int &amp; operator [](int x) {return qq[x];}
	void out(){for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,qq[i]);printf(&quot;\n&quot;);}
} X,Y;
matrix2 operator *(matrix2 a,matrix b)
{
	matrix2 c;
	for (int i=1;i&lt;=n;i++)
		for (int j=1;j&lt;=n;j++) (c[i]+=a[j]*b[j][i])%=P;
	return c;
}
bool operator ==(matrix2 a,matrix2 b)
{
	for (int i=1;i&lt;=n;i++)
		if (a[i]!=b[i]) return false;
	return true;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;P);
	A.in(),B.in();
	int i;
	srand(19980723);
	for (i=1;i&lt;=n;i++) X[i]=rand()%P+1;
	Y=X*B;
	//Y.out();printf(&quot;\n&quot;);
	for (i=0;i&lt;=P;i++)
	{
		if (X==Y) {printf(&quot;%d\n&quot;,i);return 0;}
		X=X*A;
		//X.out();
	}
	return 0;
}<pre><h2>Problem4128</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define ln printf(&quot;\n&quot;)
int inv[20001];
int n,P;
inline LL ksm(LL a,LL b,LL c)
{
	LL res=1;
	for (;b;b&gt;&gt;=1,a=a*a%c)
		if (b&amp;1) res=res*a%c;
	return res;
}
void shai()
{
	static int a[20001],b[20001];
	int i;
	a[0]=1;
	for (i=1;i&lt;=P-1;i++) a[i]=a[i-1]*i%P;
	b[P]=1;
	for (i=P-1;i&gt;0;i--) b[i]=b[i+1]*i%P;
	int tmp=ksm(a[P-1],P-2,P);
	for (i=1;i&lt;P;i++)
		inv[i]=a[i-1]*b[i+1]%P*tmp%P;
	inv[0]=1;
	//printf(&quot;inv &quot;);for(i=1;i&lt;P;i++)printf(&quot;%d &quot;,inv[i]);ln;
}
struct matrix
{
	int qq[71][71];
	matrix() {memset(qq,0,sizeof(qq));}
	int * operator [](int x) {return qq[x];}
	friend matrix operator *(matrix a,matrix b)
	{
		matrix c;
		for (int k=1;k&lt;=n;k++)
			for (int i=1;i&lt;=n;i++) if (a[i][k])
				for (int j=1;j&lt;=n;j++) if (b[k][j])
					(c[i][j]+=a[i][k]*b[k][j])%=P;
		return c;
	}
	void out()
	{
		for (int i=1;i&lt;=n;i++)
		{
			for (int j=1;j&lt;=n;j++)printf(&quot;%d &quot;,qq[i][j]);
			printf(&quot;\n&quot;);
		}
	}
};
struct HT
{
	#define p1 19980723
	#define p2 1000000007
	#define mod 100007
	int o[mod],aa0[1000000],f[1000000],tot;
	LL aa1[1000000],aa2[1000000];
	void insert(matrix A,int x)
	{
		LL t1=0,t2=0;
		int i,j;
		for (i=1;i&lt;=n;i++) for (j=1;j&lt;=n;j++)
		{
			t1=t1*p1+A[i][j];
			t2=t2*p2+A[i][j];
		}
		//printf(&quot;t1=%I64d t2=%I64d i=%d\n&quot;,t1,t2,x);
		int t=t1%mod;if (t&lt;0) t+=mod;
		for (int p=o[t];p;p=aa0[p])
			if (aa1[p]==t1&amp;&amp;aa2[p]==t2)
			{
				if (x&lt;f[p]) f[p]=x;
				return;
			}
		tot++;aa1[tot]=t1;aa2[tot]=t2;
		aa0[tot]=o[t];o[t]=tot;f[tot]=x;
	}
	int find(matrix A)
	{
		LL t1=0,t2=0;
		int i,j;
		for (i=1;i&lt;=n;i++) for (j=1;j&lt;=n;j++)
		{
			t1=t1*p1+A[i][j];
			t2=t2*p2+A[i][j];
		}
		//printf(&quot;t1=%I64d t2=%I64d\n&quot;,t1,t2);
		int t=t1%mod;if (t&lt;0) t+=mod;
		for (int p=o[t];p;p=aa0[p])
			if (aa1[p]==t1&amp;&amp;aa2[p]==t2)
				return f[p];
		return -1;
	}
} ht;
matrix matrixinv(matrix a)
{
	matrix b;
	int i,j,k;
	for (i=1;i&lt;=n;i++) b[i][i]=1;
	for (i=1;i&lt;n;i++)
	{
		for (j=i;j&lt;=n;j++)
			if (a[j][i]) break;
		if (j!=i)
			for (k=1;k&lt;=n;k++)
			{
				swap(a[i][k],a[j][k]);
				swap(b[i][k],b[j][k]);
			}
		for (j=i+1;j&lt;=n;j++)
		{
			int tmp=a[j][i]*inv[a[i][i]]%P;
			for (k=1;k&lt;=n;k++)
			{
				a[j][k]=(a[j][k]-tmp*a[i][k])%P;
				if (a[j][k]&lt;0) a[j][k]+=P;
				b[j][k]=(b[j][k]-tmp*b[i][k])%P;
				if (b[j][k]&lt;0) b[j][k]+=P;
			}
		}
	}
	//printf(&quot;a:\n&quot;);a.out();printf(&quot;b:\n&quot;);b.out();ln;
	for (i=1;i&lt;=n;i++)
	{
		int tmp=inv[a[i][i]];
		for (j=1;j&lt;=n;j++)
		{
			a[i][j]=a[i][j]*tmp%P;
			b[i][j]=b[i][j]*tmp%P;
		}
	}
	for (i=n;i;i--)
	{
		for (j=i-1;j;j--)
		{
			int tmp=a[j][i];
			for (k=1;k&lt;=n;k++)
			{
				a[j][k]=(a[j][k]-tmp*a[i][k])%P;
				if (a[j][k]&lt;0) a[j][k]+=P;
				b[j][k]=(b[j][k]-tmp*b[i][k])%P;
				if (b[j][k]&lt;0) b[j][k]+=P;
			}
		}
	}
	return b;
}
int matrixbsbg(matrix A,matrix B)
{
	int blo=(int)sqrt(P)+1,i;
	//printf(&quot;blo=%d\n&quot;,blo);
	matrix C;
	for (i=1;i&lt;=n;i++) C[i][i]=1;
	for (i=0;i&lt;blo;i++,C=C*A) ht.insert(C,i);
	matrix D;
	for (i=1;i&lt;=n;i++) D[i][i]=1;
	for (i=0;i&lt;P;i+=blo,D=D*C)
	{
		//printf(&quot;\n-------------------------- i=%d ----------------------------\n&quot;,i);
		matrix tmp=B*matrixinv(D);
		//printf(&quot;tmp:\n&quot;);tmp.out();
		int t=ht.find(tmp);
		//printf(&quot;t=%d\n&quot;,t);
		if (t!=-1) return i+t;
	}
	return -1;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;P);
	shai();
	//static matrix A;A[1][1]=5,A[1][2]=3,A[2][1]=3,A[2][2]=2;matrixinv(A).out();ln;
	int i,j;
	static matrix A,B;
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++) scanf(&quot;%d&quot;,&amp;A[i][j]);
	for (i=1;i&lt;=n;i++)
		for (j=1;j&lt;=n;j++) scanf(&quot;%d&quot;,&amp;B[i][j]);
	printf(&quot;%d\n&quot;,matrixbsbg(A,B));
	return 0;
}<pre><h2>Problem4129</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define mp make_pair
#define fi first
#define se second
#define ln printf(&quot;\n&quot;)
const int NN=50111;
int o[NN],aa[NN&lt;&lt;1][2],size[NN],dfn[NN],up[NN],fa1[NN],fa2[NN];
int ans[NN],a[NN],a0[NN],st[311],ed[311],belong[NN];
int n,m,tot=1,TIME,blo,sqrtn,cnt,n1,n2,root1,root2;
pair&lt;int,pair&lt;int,int&gt; &gt; mdf[NN];
bool vt[NN];
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs(int v)
{
	dfn[v]=++TIME;
	size[up[v]]++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa1[v]) continue;
		fa1[y]=fa2[y]=v;
		if (size[up[v]]&lt;blo) up[y]=up[v];
		else up[y]=y;
		dfs(y);
	}
}
struct ppt
{
	int id,u,v,t;
	ppt(int a=0,int b=0,int c=0,int d=0) {id=a;u=b;v=c;t=d;}
	void out() {printf(&quot;id=%d u=%d v=%d t=%d\n&quot;,id,u,v,t);}
	friend bool operator &lt;(const ppt &amp;a,const ppt &amp;b)
	{
		if (up[a.u]!=up[b.u]) return up[a.u]&lt;up[b.u];
		if (up[a.v]!=up[b.v]) return up[a.v]&lt;up[b.v];
		return a.t&lt;b.t;
	}
} qry[NN];
struct Now
{
	int num[NN],flag[311];
	inline void add(int x)
	{
		if (x&gt;n) return;
		//printf(&quot;now.add(%d)\n&quot;,x);
		if (++num[x]==1)
			flag[belong[x]]++;
	}
	inline void del(int x)
	{
		if (x&gt;n) return;
		//printf(&quot;now.del(%d)\n&quot;,x);
		if (--num[x]==0)
			flag[belong[x]]--;
	}
	int getans()
	{
		int i;
		for (i=1;i&lt;=cnt;i++)
			if (flag[i]!=ed[i]-st[i]+1) break;
		int t=i;
		for (i=st[t];i&lt;=ed[t];i++)
			if (num[i]==0) return i;
		return -1;
	}
} now;
void work(int *fa,int u,int v)
{
	for (;!vt[v];v=fa[v])
	{
		vt[v]=true;
		now.add(a[v]);
	}
	for (;u!=v;u=fa[u])
	{
		vt[u]=false;
		now.del(a[u]);
	}
}
void changeroot(int *fa,int &amp;root,int v)
{
	int x=fa[v],y=fa[x];
	root=v,fa[root]=0;
	for (;x;v=x,x=y,y=fa[x]) fa[x]=v;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	blo=(int)pow(n,2.0/3)+1;
	sqrtn=(int)sqrt(n)+1;
	int i,j,x,y,z;
	for (i=0;i&lt;=n;i+=sqrtn)
	{
		cnt++;
		st[cnt]=i,ed[cnt]=min(i+sqrtn-1,n);
		for (j=i;j&lt;=ed[cnt];j++) belong[j]=cnt;
	}
	for (i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;a0[i]),a[i]=a0[i];
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	dfs(1);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;z,&amp;x,&amp;y);
		if (z==0)
		{
			mdf[++n1]=mp(x,mp(a[x],y));
			a[x]=y;
		}
		else
		{
			if (dfn[x]&gt;dfn[y]) {int t=x;x=y;y=t;}
			qry[++n2]=ppt(i,x,y,n1);
		}
	}
	sort(qry+1,qry+n2+1);
	for (i=1;i&lt;=n;i++) a[i]=a0[i];
	//printf(&quot;qry:\n&quot;);for (i=1;i&lt;=n2;i++) qry[i].out();ln;
	memset(ans,-1,sizeof(ans));
	root1=root2=1;
	now.add(a[1]);
	vt[1]=true;
	int pret=0;
	for (i=1;i&lt;=n2;i++)
	{
		int u=qry[i].u,v=qry[i].v,t=qry[i].t;
		//printf(&quot;\n--------------------------- u=%d v=%d t=%d ---------------------------\n&quot;,u,v,t);
		if (pret&lt;t)
			for (j=pret+1;j&lt;=t;j++)
			{
				int x=mdf[j].fi,y=mdf[j].se.se;
				if (vt[x]) now.del(a[x]);
				a[x]=y;
				if (vt[x]) now.add(a[x]);
			}
		else
			for (j=pret;j&gt;t;j--)
			{
				int x=mdf[j].fi,y=mdf[j].se.fi;
				if (vt[x]) now.del(a[x]);
				a[x]=y;
				if (vt[x]) now.add(a[x]);
			}
		//printf(&quot;==================================\n&quot;);
		work(fa1,root2,v);
		changeroot(fa2,root2,v);
		work(fa2,root1,u);
		changeroot(fa1,root1,u);
		ans[qry[i].id]=now.getans();
		pret=t;
	}
	for (i=1;i&lt;=m;i++)
		if (ans[i]!=-1) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem4129</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
#define mp make_pair
#define fi first
#define se second
const int NN=50111;
int o[NN],aa[NN&lt;&lt;1][2],size[NN],dfn[NN],up[NN],fa1[NN],fa2[NN];
int ans[NN],a[NN],a0[NN],st[311],ed[311],belong[NN];
int n,m,tot=1,TIME,blo,sqrtn,cnt,n1,n2,root1,root2;
pair&lt;int,pair&lt;int,int&gt; &gt; mdf[NN];
bool vt[NN];
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs(int v)
{
	dfn[v]=++TIME;
	size[up[v]]++;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa1[v]) continue;
		fa1[y]=fa2[y]=v;
		if (size[up[v]]&lt;blo) up[y]=up[v];
		else up[y]=y;
		dfs(y);
	}
}
struct ppt
{
	int id,u,v,t;
	ppt(int a=0,int b=0,int c=0,int d=0) {id=a;u=b;v=c;t=d;}
	friend bool operator &lt;(const ppt &amp;a,const ppt &amp;b)
	{
		if (up[a.u]!=up[b.u]) return up[a.u]&lt;up[b.u];
		if (up[a.v]!=up[b.v]) return up[a.v]&lt;up[b.v];
		return a.t&lt;b.t;
	}
} qry[NN];
struct Now
{
	int num[NN],flag[311];
	inline void add(int x)
	{
		if (x&gt;n) return;
		if (++num[x]==1)
			flag[belong[x]]++;
	}
	inline void del(int x)
	{
		if (x&gt;n) return;
		if (--num[x]==0)
			flag[belong[x]]--;
	}
	int getans()
	{
		int i;
		for (i=1;i&lt;=cnt;i++)
			if (flag[i]!=ed[i]-st[i]+1) break;
		int t=i;
		for (i=st[t];i&lt;=ed[t];i++)
			if (num[i]==0) return i;
		return -1;
	}
} now;
void work(int *fa,int u,int v)
{
	for (;!vt[v];v=fa[v])
	{
		vt[v]=true;
		now.add(a[v]);
	}
	for (;u!=v;u=fa[u])
	{
		vt[u]=false;
		now.del(a[u]);
	}
}
void changeroot(int *fa,int &amp;root,int v)
{
	int x=fa[v],y=fa[x];
	root=v,fa[root]=0;
	for (;x;v=x,x=y,y=fa[x]) fa[x]=v;
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	blo=(int)pow(n,2.0/3)+1;
	sqrtn=(int)sqrt(n)+1;
	int i,j,x,y,z;
	for (i=0;i&lt;=n;i+=sqrtn)
	{
		cnt++;
		st[cnt]=i,ed[cnt]=min(i+sqrtn-1,n);
		for (j=i;j&lt;=ed[cnt];j++) belong[j]=cnt;
	}
	for (i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;a0[i]),a[i]=a0[i];
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	dfs(1);
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;z,&amp;x,&amp;y);
		if (z==0)
		{
			mdf[++n1]=mp(x,mp(a[x],y));
			a[x]=y;
		}
		else
		{
			if (dfn[x]&gt;dfn[y]) {int t=x;x=y;y=t;}
			qry[++n2]=ppt(i,x,y,n1);
		}
	}
	sort(qry+1,qry+n2+1);
	for (i=1;i&lt;=n;i++) a[i]=a0[i];
	memset(ans,-1,sizeof(ans));
	root1=root2=1;
	now.add(a[1]);
	vt[1]=true;
	int pret=0;
	for (i=1;i&lt;=n2;i++)
	{
		int u=qry[i].u,v=qry[i].v,t=qry[i].t;
		if (pret&lt;t)
			for (j=pret+1;j&lt;=t;j++)
			{
				int x=mdf[j].fi,y=mdf[j].se.se;
				if (vt[x]) now.del(a[x]);
				a[x]=y;
				if (vt[x]) now.add(a[x]);
			}
		else
			for (j=pret;j&gt;t;j--)
			{
				int x=mdf[j].fi,y=mdf[j].se.fi;
				if (vt[x]) now.del(a[x]);
				a[x]=y;
				if (vt[x]) now.add(a[x]);
			}
		work(fa1,root2,v);
		changeroot(fa2,root2,v);
		work(fa2,root1,u);
		changeroot(fa1,root1,u);
		ans[qry[i].id]=now.getans();
		pret=t;
	}
	for (i=1;i&lt;=m;i++)
		if (ans[i]!=-1) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem4134</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int NN=101111,AA=2500000,logn=20;
int o[NN],aa[NN&lt;&lt;1][2],color[NN],f[NN],sg[NN],xorsum[NN];
int son[AA][2],tag[AA],root[NN],ans[NN],fa[NN];
int n,tot=1,TTT,cnt;
bool man[AA];
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline void make(int v,int x,int k)
{
	if (!v) return;
	tag[v]^=x;
	if (x&amp;(1&lt;&lt;(k-1))) swap(son[v][0],son[v][1]);
}
inline void pushdown(int v,int k)
{
	if (!tag[v]) return;
	make(son[v][0],tag[v],k-1);
	make(son[v][1],tag[v],k-1);
	tag[v]=0;
}
inline void update(int v)
{
	man[v]=man[son[v][0]]&amp;&amp;man[son[v][1]];
}
void ins(int &amp;v,int x,int k)
{
	if (v==0) v=++TTT;
	if (k==0) {man[v]=true;return;}
	pushdown(v,k);
	if (x&amp;(1&lt;&lt;(k-1))) ins(son[v][1],x,k-1);
	else ins(son[v][0],x,k-1);
	update(v);
}
int merge(int x,int y,int k)
{
	if (!x||!y) return x+y;
	pushdown(x,k),pushdown(y,k);
	if (k==0) return x;
	son[x][0]=merge(son[x][0],son[y][0],k-1);
	son[x][1]=merge(son[x][1],son[y][1],k-1);
	update(x);
	return x;
}
int findmex(int v,int k)
{
	if (v==0) return 0;
	pushdown(v,k);
	if (k==0) return 0;
	if (man[son[v][0]])
		return (1&lt;&lt;(k-1))+findmex(son[v][1],k-1);
	else return findmex(son[v][0],k-1);
}
void work(int v)
{
	int tmp=0;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		work(y);
		tmp^=sg[y];
	}
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		make(root[y],tmp^sg[y],logn);
		root[v]=merge(root[v],root[y],logn);
	}
	if (!color[v]) ins(root[v],tmp,logn);
	sg[v]=findmex(root[v],logn);
	xorsum[v]=tmp;
}
void dfs(int v)
{
	if (fa[v]) f[v]=f[fa[v]]^sg[v]^xorsum[v];
	else f[v]=xorsum[v];
	if (!color[v]&amp;&amp;!f[v]) ans[++cnt]=v;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		dfs(y);
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;color[i]);
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	work(1);
	if (sg[1]==0) {printf(&quot;-1\n&quot;);return 0;}
	dfs(1);
	sort(ans+1,ans+cnt+1);
	for (i=1;i&lt;=cnt;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem4134</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int NN=101111,AA=2500000,logn=20;
int o[NN],aa[NN&lt;&lt;1][2],color[NN],f[NN],sg[NN],xorsum[NN];
int son[AA][2],tag[AA],root[NN],ans[NN],fa[NN],que[NN];
int n,tot=1,TTT,cnt;
bool man[AA];
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void bfs()
{
	int head=0,tail=1;
	que[1]=1;
	while (head&lt;tail)
	{
		int x=que[++head];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[x]) continue;
			fa[y]=x;
			que[++tail]=y;
		}
	}
}
inline void make(int v,int x,int k)
{
	if (!v) return;
	tag[v]^=x;
	if (x&amp;(1&lt;&lt;(k-1))) swap(son[v][0],son[v][1]);
}
inline void pushdown(int v,int k)
{
	if (!tag[v]) return;
	make(son[v][0],tag[v],k-1);
	make(son[v][1],tag[v],k-1);
	tag[v]=0;
}
inline void update(int v)
{
	man[v]=man[son[v][0]]&amp;&amp;man[son[v][1]];
}
void ins(int &amp;v,int x,int k)
{
	if (v==0) v=++TTT;
	if (k==0) {man[v]=true;return;}
	pushdown(v,k);
	if (x&amp;(1&lt;&lt;(k-1))) ins(son[v][1],x,k-1);
	else ins(son[v][0],x,k-1);
	update(v);
}
int merge(int x,int y,int k)
{
	if (!x||!y) return x+y;
	pushdown(x,k),pushdown(y,k);
	if (k==0) return x;
	son[x][0]=merge(son[x][0],son[y][0],k-1);
	son[x][1]=merge(son[x][1],son[y][1],k-1);
	update(x);
	return x;
}
int findmex(int v,int k)
{
	if (v==0) return 0;
	pushdown(v,k);
	if (k==0) return 0;
	if (man[son[v][0]])
		return (1&lt;&lt;(k-1))+findmex(son[v][1],k-1);
	else return findmex(son[v][0],k-1);
}
void work()
{
	for (int i=n;i;i--)
	{
		int v=que[i];
		int tmp=0;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[v]) continue;
			tmp^=sg[y];
		}
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (y==fa[v]) continue;
			make(root[y],tmp^sg[y],logn);
			root[v]=merge(root[v],root[y],logn);
		}
		if (!color[v]) ins(root[v],tmp,logn);
		sg[v]=findmex(root[v],logn);
		xorsum[v]=tmp;
	}
}
void work2()
{
	for (int i=1;i&lt;=n;i++)
	{
		int v=que[i];
		if (fa[v]) f[v]=f[fa[v]]^sg[v]^xorsum[v];
		else f[v]=xorsum[v];
		if (!color[v]&amp;&amp;!f[v]) ans[++cnt]=v;
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i,x,y;
	for (i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;color[i]);
	for (i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		addedge(x,y),addedge(y,x);
	}
	bfs();
	work();
	if (sg[1]==0) {printf(&quot;-1\n&quot;);return 0;}
	work2();
	sort(ans+1,ans+cnt+1);
	for (i=1;i&lt;=cnt;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem4145</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
int f[105][69999],g[105][69999],d[105],c[105][19];
int n,m;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int i,j;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;d[i]);
		for (j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;c[i][j]);
	}
	memset(f,60,sizeof(f));
	memset(g,60,sizeof(g));
	for (i=0;i&lt;=n;i++)
		f[i][0]=0,g[i][0]=d[i];
	for (i=1;i&lt;=n;i++)
		for (int S=1;S&lt;1&lt;&lt;m;S++)
		{
			f[i][S]=f[i-1][S];
			g[i][S]=f[i-1][S]+d[i];
			for (j=1;j&lt;=m;j++) if (S&amp;(1&lt;&lt;(j-1)))
			{
				int T=S^(1&lt;&lt;(j-1));
				f[i][S]=min(f[i][S],f[i-1][T]+d[i]+c[i][j]);
				f[i][S]=min(f[i][S],g[i][T]+c[i][j]);
				g[i][S]=min(g[i][S],f[i-1][T]+d[i]+c[i][j]);
				g[i][S]=min(g[i][S],g[i][T]+c[i][j]);
			}
		}
	printf(&quot;%d\n&quot;,f[n][(1&lt;&lt;m)-1]);
	return 0;
}<pre><h2>Problem4146</h2><pre>#include&lt;cstdio&gt;
using namespace std;
typedef long long LL;
int num[2000005];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	while (ch&lt;'0'||ch&gt;'9') ch=getchar();
	while (ch&gt;='0'&amp;&amp;ch&lt;='9')
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar();
}
int n;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	read(n);
	int i,j,x;
	for (i=1;i&lt;=n;i++)
		read(x),num[x]++;
	LL ans=0;
	for (i=1;i&lt;=2000000;i++)
	{
		ans+=(LL)num[i]*(num[i]-1);
		for (j=i+i;j&lt;=2000000;j+=i)
			ans+=(LL)num[i]*num[j];
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem4152</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long LL;
int o[201111],aa[801111][3];
int n,tot;
LL dist[201111];
struct point
{
	int x,y,id;
} q[201111];
int getdist(point a,point b)
{
	return min(abs(a.x-b.x),abs(a.y-b.y));
}
inline bool cmp1(const point &amp;a,const point &amp;b)
{
	if (a.x!=b.x) return a.x&lt;b.x;
	return a.y&lt;b.y;
}
inline bool cmp2(const point &amp;a,const point &amp;b)
{
	if (a.y!=b.y) return a.y&lt;b.y;
	return a.x&lt;b.x;
}
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
struct ppt
{
	int v;LL d;
	ppt(int a=0,LL b=0) {v=a;d=b;}
	friend bool operator &lt;(const ppt &amp;a,const ppt &amp;b) {return a.d&gt;b.d;}
};
priority_queue&lt;ppt&gt; Q;
void dij(int S)
{
	static bool vt[201111];
	memset(dist,60,sizeof(dist));
	dist[S]=0;
	Q.push(ppt(S,0));
	while (!Q.empty())
	{
		int v=Q.top().v;LL d=Q.top().d;
		Q.pop();
		if (vt[v]) continue;
		vt[v]=true;
		for (int p=o[v];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (!vt[y]&amp;&amp;dist[y]&gt;d+aa[p][2])
			{
				dist[y]=d+aa[p][2];
				Q.push(ppt(y,dist[y]));
			}
		}
	}
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	int i;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;q[i].x,&amp;q[i].y);
		q[i].id=i;
	}
	sort(q+1,q+n+1,cmp1);
	for (i=1;i&lt;n;i++)
	{
		int tmp=getdist(q[i],q[i+1]);
		addedge(q[i].id,q[i+1].id,tmp);
		addedge(q[i+1].id,q[i].id,tmp);
	}
	sort(q+1,q+n+1,cmp2);
	for (i=1;i&lt;n;i++)
	{
		int tmp=getdist(q[i],q[i+1]);
		addedge(q[i].id,q[i+1].id,tmp);
		addedge(q[i+1].id,q[i].id,tmp);
	}
	dij(1);
	printf(&quot;%lld\n&quot;,dist[n]);
	return 0;
}<pre><h2>Problem4153</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
using namespace std;
typedef unsigned int UN;
typedef long long LL;
#define pb push_back
#define mo 1000000007
#define ln printf(&quot;\n&quot;)
const int NN=1000111;
int pos1[NN],pos2[NN];
int tes,n,m;
vector&lt;int&gt; v1[NN],v2[NN];
map&lt;int,int&gt; num[NN];
void out(int *a,int l,int r) {for (int i=l;i&lt;=r;i++) printf(&quot;%d &quot;,a[i]);ln;}
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar());
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
}
void debug()
{
	printf(&quot;pos1 &quot;);out(pos1,1,n);printf(&quot;pos2 &quot;);out(pos2,1,n);
	printf(&quot;v1:\n&quot;);
	for (int i=1;i&lt;=n;i++)
	{
		for (UN j=0;j&lt;v1[i].size();j++) printf(&quot;%d &quot;,v1[i][j]);
		ln;
	}ln;
	printf(&quot;v2:\n&quot;);
	for (int i=1;i&lt;=n;i++)
	{
		for (UN j=0;j&lt;v2[i].size();j++) printf(&quot;%d &quot;,v2[i][j]);
		ln;
	}ln;
	for (int i=1;i&lt;=n;i++)
	{
		for (int j=1;j&lt;=n;j++) printf(&quot;%d &quot;,num[i][j]);
		ln;
	}ln;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (read(tes);tes;tes--)
	{
		read(n),read(m);
		int i,x,y,z;
		for (i=1;i&lt;=n;i++)
		{
			v1[i].clear(),v2[i].clear();
			v1[i].pb(i),v2[i].pb(i);
			pos1[i]=pos2[i]=i;
			num[i].clear();
			num[i][i]=1;
		}
		LL now=0,ans=0;
		for (i=1;i&lt;=m;i++)
		{
			//printf(&quot;\n--------------------------------------------------------------\n&quot;);debug();
			read(z),read(x),read(y);
			if (z==1)
			{
				x=pos1[x],y=pos1[y];
				if (x==y) {(ans+=now*i)%=mo;continue;}
				if (v1[x].size()&gt;v1[y].size()) {int t=x;x=y;y=t;}
				for (UN j=0;j&lt;v1[x].size();j++)
				{
					int t=v1[x][j];
					now+=num[y][pos2[t]];
				}
				for (UN j=0;j&lt;v1[x].size();j++)
				{
					int t=v1[x][j];
					pos1[t]=y;
					v1[y].pb(t);
					num[y][pos2[t]]++;
				}
				v1[x].clear();
			}
			else
			{
				x=pos2[x],y=pos2[y];
				if (x==y) {(ans+=now*i)%=mo;continue;}
				if (v2[x].size()&gt;v2[y].size()) {int t=x;x=y;y=t;}
				for (UN j=0;j&lt;v2[x].size();j++)
				{
					int t=v2[x][j];
					now+=num[pos1[t]][y];
				}
				for (UN j=0;j&lt;v2[x].size();j++)
				{
					int t=v2[x][j];
					pos2[t]=y;
					v2[y].pb(t);
					num[pos1[t]][y]++;
				}
				v2[x].clear();
			}
			(ans+=now*i)%=mo;
		}
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem4153</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
using namespace std;
typedef unsigned int UN;
typedef long long LL;
#define pb push_back
#define mo 1000000007
const int NN=1000111;
int pos1[NN],pos2[NN];
int tes,n,m;
vector&lt;int&gt; v1[NN],v2[NN];
map&lt;int,int&gt; num[NN];
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar());
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
}
int main()
{
	for (read(tes);tes;tes--)
	{
		read(n),read(m);
		int i,x,y,z;
		for (i=1;i&lt;=n;i++)
		{
			v1[i].clear(),v2[i].clear();
			v1[i].pb(i),v2[i].pb(i);
			pos1[i]=pos2[i]=i;
			num[i].clear();
			num[i][i]=1;
		}
		LL now=0,ans=0;
		for (i=1;i&lt;=m;i++)
		{
			read(z),read(x),read(y);
			if (z==1)
			{
				x=pos1[x],y=pos1[y];
				if (x==y) {(ans+=now*i)%=mo;continue;}
				if (v1[x].size()&gt;v1[y].size()) {int t=x;x=y;y=t;}
				for (UN j=0;j&lt;v1[x].size();j++)
				{
					int t=v1[x][j];
					now+=num[y][pos2[t]];
				}
				for (UN j=0;j&lt;v1[x].size();j++)
				{
					int t=v1[x][j];
					pos1[t]=y;
					v1[y].pb(t);
					num[y][pos2[t]]++;
				}
				v1[x].clear();
			}
			else
			{
				x=pos2[x],y=pos2[y];
				if (x==y) {(ans+=now*i)%=mo;continue;}
				if (v2[x].size()&gt;v2[y].size()) {int t=x;x=y;y=t;}
				for (UN j=0;j&lt;v2[x].size();j++)
				{
					int t=v2[x][j];
					now+=num[pos1[t]][y];
				}
				for (UN j=0;j&lt;v2[x].size();j++)
				{
					int t=v2[x][j];
					pos2[t]=y;
					v2[y].pb(t);
					num[pos1[t]][y]++;
				}
				v2[x].clear();
			}
			(ans+=now*i)%=mo;
		}
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem4154</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define mo 1000000007
const int NN=100005,AA=NN&lt;&lt;2,AA2=30000000;
int fa[NN],st[NN],ed[NN],o[NN],aa[NN&lt;&lt;1][2],deep[NN],rec[NN];
int tes,n,m,Q,tot,cnt,TTT,TTT2,rt;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar());
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
}
inline void addedge(int p,int q)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][0]=o[p];
	o[p]=tot;
}
void dfs(int v)
{
	st[v]=++cnt;
	for (int p=o[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (y==fa[v]) continue;
		fa[y]=v;
		deep[y]=deep[v]+1;
		dfs(y);
	}
	ed[v]=cnt;
}
struct segnode2
{
	int lc,rc,tmax,tag;
	inline void clear() {lc=rc=tmax=tag=0;}
} t2[AA2];
void change2(int &amp;v,int l,int r,int ww,int ee,int x)
{
	if (!v) v=++TTT2;
	t2[v].tmax=max(t2[v].tmax,x);
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		t2[v].tag=max(t2[v].tag,x);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) change2(t2[v].lc,l,mid,ww,ee,x);
	if (ee&gt;mid) change2(t2[v].rc,mid,r,ww,ee,x);
}
int find2(int v,int l,int r,int i)
{
	if (v==0) return 0;
	if (r-l==1) return t2[v].tmax;
	int res=t2[v].tag;
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid) res=max(res,find2(t2[v].lc,l,mid,i));
	else res=max(res,find2(t2[v].rc,mid,r,i));
	return res;
}
struct segnode
{
	int lc,rc,rt1,rt2;
	inline void clear() {lc=rc=rt1=rt2=0;}
} t[AA];
void change(int &amp;v,int l,int r,int ww,int ee,int ww2,int ee2,int x)
{
	if (!v) v=++TTT;
	change2(t[v].rt1,1,n+1,ww2,ee2,x);
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		change2(t[v].rt2,1,n+1,ww2,ee2,x);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) change(t[v].lc,l,mid,ww,ee,ww2,ee2,x);
	if (ee&gt;mid) change(t[v].rc,mid,r,ww,ee,ww2,ee2,x);
}
int find(int v,int l,int r,int i,int i2)
{
	if (v==0) return 0;
	if (r-l==1) return find2(t[v].rt1,1,n+1,i2);
	int res=find2(t[v].rt2,1,n+1,i2);
	int mid=(l+r)&gt;&gt;1;
	if (i&lt;mid) res=max(res,find(t[v].lc,l,mid,i,i2));
	else res=max(res,find(t[v].rc,mid,r,i,i2));
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (read(tes);tes;tes--)
	{
		int i,x,y,z;
		memset(o,0,sizeof(o));tot=0;
		for (i=1;i&lt;=TTT;i++) t[i].clear();
		for (i=1;i&lt;=TTT2;i++) t2[i].clear();
		TTT=TTT2=rt=cnt=0;
		read(n),read(m),read(Q);
		for (i=2;i&lt;=n;i++)
			read(fa[i]),addedge(fa[i],i);
		deep[1]=1,dfs(1);
		LL ans=0;
		rec[0]=1;
		for (i=1;i&lt;=Q;i++)
		{
			read(x),read(y),read(z);
			if (z==0)
			{
				int tmp=find(rt,1,n+1,st[x],deep[x]);
				(ans+=(LL)i*rec[tmp])%=mo;
			}
			else
			{
				rec[i]=z;
				change(rt,1,n+1,st[x],ed[x]+1,deep[x],deep[x]+y+1,i);
			}
		}
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem4154</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define mo 1000000007
const int NN=100005,AA=NN&lt;&lt;2,AA2=10000000;
int fa[NN],st[NN],ed[NN],o[NN],aa[NN&lt;&lt;1][2],deep[NN],rec[NN];
int tes,n,m,Q,tot,cnt,TTT,TTT2,rt;
inline void read(int &amp;x)
{
    x=0;char ch=getchar();
    for (;ch&lt;'0'||ch&gt;'9';ch=getchar());
    for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
        x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
}
inline void addedge(int p,int q)
{
    tot++;
    aa[tot][1]=q;
    aa[tot][0]=o[p];
    o[p]=tot;
}
void dfs(int v)
{
    st[v]=++cnt;
    for (int p=o[v];p;p=aa[p][0])
    {
        int y=aa[p][1];
        if (y==fa[v]) continue;
        fa[y]=v;
        deep[y]=deep[v]+1;
        dfs(y);
    }
    ed[v]=cnt;
}
struct segnode2
{
    int lc,rc,tmax,tag;
    inline void clear() {lc=rc=tmax=tag=0;}
} t2[AA2];
void change2(int &amp;v,int l,int r,int ww,int ee,int x)
{
    if (!v) v=++TTT2;
    t2[v].tmax=max(t2[v].tmax,x);
    if (ww&lt;=l&amp;&amp;r&lt;=ee)
    {
        t2[v].tag=max(t2[v].tag,x);
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    if (ww&lt;mid) change2(t2[v].lc,l,mid,ww,ee,x);
    if (ee&gt;mid) change2(t2[v].rc,mid,r,ww,ee,x);
}
int find2(int v,int l,int r,int i)
{
    if (v==0) return 0;
    if (r-l==1) return t2[v].tmax;
    int res=t2[v].tag;
    int mid=(l+r)&gt;&gt;1;
    if (i&lt;mid) res=max(res,find2(t2[v].lc,l,mid,i));
    else res=max(res,find2(t2[v].rc,mid,r,i));
    return res;
}
struct segnode
{
    int lc,rc,rt1,rt2;
    inline void clear() {lc=rc=rt1=rt2=0;}
} t[AA];
void change(int &amp;v,int l,int r,int ww,int ee,int ww2,int ee2,int x)
{
    if (!v) v=++TTT;
    change2(t[v].rt1,1,n+1,ww2,ee2,x);
    if (ww&lt;=l&amp;&amp;r&lt;=ee)
    {
        change2(t[v].rt2,1,n+1,ww2,ee2,x);
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    if (ww&lt;mid) change(t[v].lc,l,mid,ww,ee,ww2,ee2,x);
    if (ee&gt;mid) change(t[v].rc,mid,r,ww,ee,ww2,ee2,x);
}
int find(int v,int l,int r,int i,int i2)
{
    if (v==0) return 0;
    if (r-l==1) return find2(t[v].rt1,1,n+1,i2);
    int res=find2(t[v].rt2,1,n+1,i2);
    int mid=(l+r)&gt;&gt;1;
    if (i&lt;mid) res=max(res,find(t[v].lc,l,mid,i,i2));
    else res=max(res,find(t[v].rc,mid,r,i,i2));
    return res;
}
int main()
{
    //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
    for (read(tes);tes;tes--)
    {
        int i,x,y,z;
        memset(o,0,sizeof(o));tot=0;
        for (i=1;i&lt;=TTT;i++) t[i].clear();
        for (i=1;i&lt;=TTT2;i++) t2[i].clear();
        TTT=TTT2=rt=cnt=0;
        read(n),read(m),read(Q);
        for (i=2;i&lt;=n;i++)
            read(fa[i]),addedge(fa[i],i);
        deep[1]=1,dfs(1);
        LL ans=0;
        rec[0]=1;
        for (i=1;i&lt;=Q;i++)
        {
            read(x),read(y),read(z);
            if (z==0)
            {
                int tmp=find(rt,1,n+1,st[x],deep[x]);
                (ans+=(LL)i*rec[tmp])%=mo;
            }
            else
            {
                rec[i]=z;
                change(rt,1,n+1,st[x],ed[x]+1,deep[x],deep[x]+y+1,i);
            }
        }
        printf(&quot;%lld\n&quot;,ans);
    }
    return 0;
}<pre><h2>Problem4155</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;bitset&gt;
using namespace std;
#define inf 999999999
const int NN=211,MM=NN*NN;
int o[NN],cur[NN],deep[NN],aa[MM&lt;&lt;1][3],du[NN];
int tes,n,m,tot,S,T;
bitset&lt;40005&gt; f;
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline void add(int p,int q,int v)
{
	//printf(&quot;add %d %d %d\n&quot;,p,q,v);
	addedge(p,q,v);
	addedge(q,p,0);
}
bool bfs()
{
	static int que[NN];
	memset(deep,0,sizeof(deep));
	deep[S]=1;
	int head=0,tail=1;
	que[1]=S;
	while (head&lt;tail)
	{
		int x=que[++head];
		cur[x]=o[x];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;!deep[y])
				deep[y]=deep[x]+1,que[++tail]=y;
		}
	}
	return deep[T];
}
int dfs(int v,int ff)
{
	if (v==T) return ff;
	int res=0;
	for (int &amp;p=cur[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,min(aa[p][2],ff));
		ff-=tmp,aa[p][2]-=tmp;
		aa[p^1][2]+=tmp,res+=tmp;
		if (ff==0) break;
	}
	if (res==0) deep[v]=inf;
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	for (scanf(&quot;%d&quot;,&amp;tes);tes;tes--)
	{
		memset(o,0,sizeof(o));tot=1;
		memset(du,0,sizeof(du));
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		int i,x,y;
		for (i=1;i&lt;=m;i++)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			du[x]++,du[y]++;
			add(x,y,1),add(y,x,1);
		}
		S=1,T=2;
		int ans=m;
		while (bfs()) ans-=dfs(S,inf);
		printf(&quot;%d &quot;,ans);
		f.reset();
		f[du[1]]=1;
		for (i=3;i&lt;=n;i++) f|=f&lt;&lt;du[i];
		ans=inf;
		for (i=0;i&lt;=40000;i++) if (f[i])
			ans=min(ans,abs(i-m));
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}	<pre><h2>Problem4159</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define inf 1000000005
int n,m;
int work(int x,int y)
{
	int l=0,r=n,res=-1;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (x*mid-y*(n-mid)&gt;0) res=mid,r=mid-1;
		else l=mid+1;
	}
	return x*res-y*(n-res);
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	int ans=inf,i,x,y;
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		ans=min(ans,work(x,y));
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem4173</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
using namespace std;
typedef long long LL;
#define mo 998244353
LL getphi(LL n)
{
	LL res=1;
	for (LL i=2;i*i&lt;=n;i++) if (n%i==0)
	{
		res*=i-1;
		for (n/=i;n%i==0;n/=i) res*=i;
	}
	if (n&gt;1) res*=n-1;
	return res%mo;
}
int main()
{
	LL n,m;
	cin&gt;&gt;n&gt;&gt;m;
	LL ans=getphi(n)*getphi(m)%mo*(n%mo)%mo*(m%mo)%mo;
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem4177</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define inf 999999999
const int NN=101111;
int o[NN],cur[NN],aa[NN*30][3],deep[NN];
int n,m,K,tot=1,S,T,ans;
inline int min(int a,int b) {return a&lt;b?a:b;}
inline void addedge(int p,int q,int v)
{
	tot++;
	aa[tot][1]=q;
	aa[tot][2]=v;
	aa[tot][0]=o[p];
	o[p]=tot;
}
inline void add(int p,int q,int v)
{
	addedge(p,q,v);
	addedge(q,p,0);
}
inline void add2(int p,int q,int v)
{
	addedge(p,q,v);
	addedge(q,p,v);
}
bool bfs()
{
	static int que[NN];
	memset(deep,0,sizeof(deep));
	deep[S]=1;
	int head=0,tail=1;
	que[1]=S;
	while (head&lt;tail)
	{
		int x=que[++head];
		cur[x]=o[x];
		for (int p=o[x];p;p=aa[p][0])
		{
			int y=aa[p][1];
			if (aa[p][2]&amp;&amp;!deep[y])
				deep[y]=deep[x]+1,que[++tail]=y;
		}
	}
	return deep[T];
}
int dfs(int v,int ff)
{
	if (v==T) return ff;
	int res=0;
	for (int &amp;p=cur[v];p;p=aa[p][0])
	{
		int y=aa[p][1];
		if (!aa[p][2]||deep[y]!=deep[v]+1) continue;
		int tmp=dfs(y,min(aa[p][2],ff));
		ff-=tmp,aa[p][2]-=tmp;
		aa[p^1][2]+=tmp,res+=tmp;
		if (ff==0) break;
	}
	if (res==0) deep[v]=inf;
	return res;
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;K);
	S=n+K+1,T=S+1;
	int i,t,x,y,z;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		ans+=x;
		add(S,i,x);
	}
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		ans+=x;
		add(i,T,x);
	}
	for (i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
		add2(x,y,z);
	}
	for (i=1;i&lt;=K;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;t,&amp;x,&amp;y);
		ans+=y;
		if (x==0) add(S,n+i,y);
		else add(n+i,T,y);
		for (;t;t--)
		{
			scanf(&quot;%d&quot;,&amp;z);
			if (x==0) add(n+i,z,inf);
			else add(z,n+i,inf);
		}
	}
	while (bfs()) ans-=dfs(S,inf);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem4180</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
#define inf 999999999
#define INF 1000000000000000005ll
const int NN=100111;
int val[NN&lt;&lt;1],pre[NN&lt;&lt;1],son[NN&lt;&lt;1][4],dp[NN&lt;&lt;1][4];
int TTT,last,len,bit;
LL n;
bool vt[NN&lt;&lt;1];
char s[NN];
void samadd(int x)
{
	int end=++TTT,p=last;
	last=end;
	val[end]=val[p]+1;
	for (;p!=-1&amp;&amp;!son[p][x];p=pre[p]) son[p][x]=end;
	if (p==-1) {pre[end]=0;return;}
	int q=son[p][x];
	if (val[q]==val[p]+1) {pre[end]=q;return;}
	int nq=++TTT;
	val[nq]=val[p]+1;
	pre[nq]=pre[q];
	pre[q]=pre[end]=nq;
	memcpy(son[nq],son[q],sizeof(son[q]));
	for (;p!=-1&amp;&amp;son[p][x]==q;p=pre[p]) son[p][x]=nq;
}
void dfs(int v)
{
	vt[v]=true;
	for (int i=0;i&lt;4;i++) dp[v][i]=inf;
	for (int i=0;i&lt;4;i++)
		if (son[v][i])
		{
			if (!vt[son[v][i]]) dfs(son[v][i]);
			for (int k=0;k&lt;4;k++)
				dp[v][k]=min(dp[v][k],dp[son[v][i]][k]+1);
		}
		else dp[v][i]=1;
}
struct matrix
{
	LL qq[4][4];
	LL * operator [](int x) {return qq[x];}
	matrix()
	{
		for (int i=0;i&lt;4;i++)
			for (int j=0;j&lt;4;j++) qq[i][j]=INF;
	}
	friend matrix operator *(matrix a,matrix b)
	{
		matrix c;
		for (int i=0;i&lt;4;i++)
			for (int j=0;j&lt;4;j++)
				for (int k=0;k&lt;4;k++)
					c[i][j]=min(c[i][j],a[i][k]+b[k][j]);
		return c;
	}
	inline bool check()
	{
		for (int i=0;i&lt;4;i++)
			for (int j=0;j&lt;4;j++)
				if (qq[i][j]&lt;n) return true;
		return false;
	}
} f[71],now;
int main()
{
	scanf(&quot;%lld\n%s&quot;,&amp;n,s+1);
	len=strlen(s+1);
	pre[0]=-1;
	int i,j;
	for (i=1;i&lt;=len;i++) samadd(s[i]-'A');
	dfs(0);
	for (i=0;i&lt;4;i++)
		for (j=0;j&lt;4;j++) f[0][i][j]=dp[son[0][i]][j];
	for (bit=1;(1ll&lt;&lt;bit)&lt;=n;bit++)
		f[bit]=f[bit-1]*f[bit-1];
	LL ans=0;
	for (i=0;i&lt;4;i++) now[i][i]=0;
	for (i=bit;i&gt;=0;i--)
		if ((now*f[i]).check())
		{
			now=now*f[i];
			ans|=1ll&lt;&lt;i;
		}
	printf(&quot;%lld\n&quot;,ans+1);
	return 0;
}<pre><h2>Problem4184</h2><pre>#include&lt;cstdio&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
using namespace std;
typedef unsigned int UN;
const int NN=500111;
#define pb push_back
#define ls (v&lt;&lt;1)
#define rs (v&lt;&lt;1|1)
#define fi first
#define se second
int n,ww,ee;
map&lt;int,int&gt; first,num;
vector&lt;int&gt; go[NN&lt;&lt;2];
struct xianxingji
{
	int a[33];
	inline void insert(int x)
	{
		for (int i=31;i;i--)
			if (x&amp;(1&lt;&lt;(i-1)))
			{
				if (a[i]==0) {a[i]=x;break;}
				x^=a[i];
			}
	}
	inline int getans()
	{
		int res=0;
		for (int i=30;i;i--)
			if ((res^a[i])&gt;res) res^=a[i];
		return res;
	}
} now[21];
void change(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		go[v].pb(x);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) change(ls,l,mid,x);
	if (ee&gt;mid) change(rs,mid,r,x);
}
void find(int v,int l,int r,int dep)
{
	now[dep]=now[dep-1];
	for (UN p=0;p&lt;go[v].size();p++)
		now[dep].insert(go[v][p]);
	if (r-l==1)
	{
		printf(&quot;%d\n&quot;,now[dep].getans());
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	find(ls,l,mid,dep+1);
	find(rs,mid,r,dep+1);
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	int i,x;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		if (x&gt;0)
		{
			num[x]++;
			if (num[x]==1) first[x]=i;
		}
		else
		{
			num[x*=-1]--;
			if (num[x]==0)
			{
				ww=first[x],ee=i;
				change(1,1,n+1,x);
			}
		}
	}
	for (map&lt;int,int&gt;::iterator it=num.begin();it!=num.end();it++)
		if ((*it).se)
		{
			int x=(*it).fi;
			ww=first[x],ee=n+1;
			change(1,1,n+1,x);
		}
	find(1,1,n+1,1);
	return 0;
}<pre><h2>Problem4184</h2><pre>#include&lt;cstdio&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
using namespace std;
typedef unsigned int UN;
const int NN=500111;
#define pb push_back
#define ls (v&lt;&lt;1)
#define rs (v&lt;&lt;1|1)
#define fi first
#define se second
int n,ww,ee;
map&lt;int,int&gt; first,num;
vector&lt;int&gt; go[NN&lt;&lt;2];
struct xxj
{
	int a[33];
	inline void insert(int x)
	{
		for (int i=31;i;i--)
			if (x&amp;(1&lt;&lt;(i-1)))
			{
				if (a[i]==0) {a[i]=x;break;}
				x^=a[i];
			}
	}
	inline int getans()
	{
		int res=0;
		for (int i=30;i;i--)
			if ((res^a[i])&gt;res) res^=a[i];
		return res;
	}
} a[21];
void change(int v,int l,int r,int x)
{
	if (ww&lt;=l&amp;&amp;r&lt;=ee)
	{
		go[v].pb(x);
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	if (ww&lt;mid) change(ls,l,mid,x);
	if (ee&gt;mid) change(rs,mid,r,x);
}
void find(int v,int l,int r,int dep)
{
	a[dep]=a[dep-1];
	for (UN p=0;p&lt;go[v].size();p++)
		a[dep].insert(go[v][p]);
	if (r-l==1)
	{
		printf(&quot;%d\n&quot;,a[dep].getans());
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	find(ls,l,mid,dep+1);
	find(rs,mid,r,dep+1);
}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	int i,x;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;x);
		if (x&gt;0)
		{
			if (++num[x]==1)
				first[x]=i;
		}
		else
		{
			if (--num[x*=-1]==0)
			{
				ww=first[x],ee=i;
				change(1,1,n+1,x);
			}
		}
	}
	for (map&lt;int,int&gt;::iterator it=num.begin();it!=num.end();it++)
		if ((*it).se)
		{
			x=(*it).fi;
			ww=first[x],ee=n+1;
			change(1,1,n+1,x);
		}
	find(1,1,n+1,1);
	return 0;
}<pre><h2>Problem4195</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int NN=200111;
int X[NN],Y[NN],E[NN],fa[NN],b[NN];
int tes,n,cnt;
inline void read(int &amp;x)
{
	x=0;char ch=getchar();
	for (;ch&lt;'0'||ch&gt;'9';ch=getchar());
	for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=getchar())
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';
}
int cha(int x)
{
	int l=1,r=cnt;
	while (l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if (b[mid]==x) return mid;
		if (x&lt;b[mid]) r=mid-1;
		else l=mid+1;
	}
	return -1;
}
int getfa(int x) {return fa[x]==x?x:fa[x]=getfa(fa[x]);}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	for (read(tes);tes;tes--)
	{
		read(n);
		cnt=0;
		int i;
		for (i=1;i&lt;=n;i++)
		{
			read(X[i]),read(Y[i]),read(E[i]);
			b[++cnt]=X[i],b[++cnt]=Y[i];
		}
		sort(b+1,b+cnt+1);
		cnt=unique(b+1,b+cnt+1)-(b+1);
		for (i=1;i&lt;=n;i++)
			X[i]=cha(X[i]),Y[i]=cha(Y[i]);
		for (i=1;i&lt;=cnt;i++) fa[i]=i;
		for (i=1;i&lt;=n;i++)
			if (E[i]==1) fa[getfa(X[i])]=getfa(Y[i]);
		bool ok=true;
		for (i=1;i&lt;=n;i++)
			if (E[i]==0&amp;&amp;getfa(X[i])==getfa(Y[i]))
				{ok=false;break;}
		printf(ok?&quot;YES\n&quot;:&quot;NO\n&quot;);
	}
	return 0;
}<pre><h2>Problem4198</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long LL;
int n,K;
LL ans;
struct ppt
{
	LL w;int dep;
	ppt(LL a=0,int b=0) {w=a;dep=b;}
	friend bool operator &lt;(const ppt &amp;a,const ppt &amp;b)
	{
		if (a.w!=b.w) return a.w&gt;b.w;
		return a.dep&gt;b.dep;
	}
};
priority_queue&lt;ppt&gt; Q;
void work(int num)
{
	LL tmp=0;int dep=0;
	for (int i=1;i&lt;=num;i++)
	{
		tmp+=Q.top().w;
		if (Q.top().dep&gt;dep) dep=Q.top().dep;
		Q.pop();
	}
	ans+=tmp;
	Q.push(ppt(tmp,dep+1));
}
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	int i;LL x;
	for (i=1;i&lt;=n;i++)
	{
		scanf(&quot;%lld&quot;,&amp;x);
		Q.push(ppt(x,0));
	}
	if ((n-1)%(K-1)) work((n-1)%(K-1)+1);
	while ((int)Q.size()&gt;=K) work(K);
	printf(&quot;%lld\n%d\n&quot;,ans,Q.top().dep);
	return 0;
}<pre><h2>Problem4200</h2><pre>#include&lt;set&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define INF 0x7fffffff
struct data{
	int a,b,c;
	friend bool operator &lt; (const data &amp;a,const data &amp;b){return a.a&lt;b.a||(a.a==b.a&amp;&amp;a.b&lt;b.b);}
}x,a[50005];
set&lt;data&gt;s;
set&lt;data&gt;::iterator it,it1;
int n,ans,Pos;
int nt[50005][3];
int f[50005],g[50005];
bool b[50005],b1[50005];
int d[50005],p[50005],h[50005];
void init(){
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n;++i)scanf(&quot;%d%d&quot;,&amp;a[i].b,&amp;a[i].a),a[i].c=i;
}
void DFS(int x){
	if(!x)return;
	if(b[x]){
		DFS(d[h[x]]);
		if(h[x]&lt;x){
			for(int i=h[x];a[i].b==a[x].b;i--)printf(&quot;%d &quot;,a[i].c);
			for(int i=h[x]+1;i&lt;x;i++)printf(&quot;%d &quot;,a[i].c);
		}else{
			for(int i=h[x];a[i].b==a[x].b;i++)printf(&quot;%d &quot;,a[i].c);
			for(int i=h[x]-1;i&gt;x;i--)printf(&quot;%d &quot;,a[i].c);
		}
	}else DFS(d[x]);
	printf(&quot;%d &quot;,a[x].c);
}
void Solve1(){
    sort(a+1,a+n+1);
    register int i,j,k,l;
	for(i=0;i&lt;=n;++i)swap(a[i].a,a[i].b),x.a=a[i].a+a[i].b,x.b=a[i].b,x.c=i,s.insert(x);
	for(it=it1=s.begin();;++it){
		++it1;if(it1==s.end())break;if(it-&gt;a==it1-&gt;a)nt[it-&gt;c][0]=it1-&gt;c;
	}
	s.clear();
	for(i=0;i&lt;=n;++i)x.a=a[i].a-a[i].b,x.b=a[i].b,x.c=i,s.insert(x);
	for(it=it1=s.begin();;++it){
		++it1;if(it1==s.end())break;if(it-&gt;a==it1-&gt;a)nt[it-&gt;c][1]=it1-&gt;c;
	}
	s.clear();
	for(i=0;i&lt;=n;++i)x.a=a[i].a,x.b=a[i].b,x.c=i,s.insert(x);
	for(it=it1=s.begin();;++it){
		++it1;if(it1==s.end())break;if(it-&gt;a==it1-&gt;a)nt[it-&gt;c][2]=it1-&gt;c;
	}
	memset(f,128,sizeof(f));
	for(i=f[0]=0,j;i&lt;=n;i=j){
		for(j=i;j&lt;=n&amp;&amp;a[j].b==a[i].b;++j)g[j]=f[j];
		for(k=i,l=0;k&lt;j;++k){
			if(l&amp;&amp;k-i+f[l]&gt;g[k])g[k]=k-i+f[l],h[k]=l;
			if(f[k]&gt;f[l])l=k;
		}
		for(k=j-1,l=0;k&gt;=i;--k){
			if(l&amp;&amp;j-k-1+f[l]&gt;g[k])g[k]=j-k-1+f[l],h[k]=l;
			if(f[k]&gt;f[l])l=k;
		}
		for(k=i;k&lt;j;++k){
			if(g[k]&gt;f[k])swap(g[k],f[k]),b[k]=1;
			for(l=0;l&lt;3;l++)if(nt[k][l])if(f[nt[k][l]]&lt;=f[k])f[nt[k][l]]=f[k]+1,d[nt[k][l]]=k,p[nt[k][l]]=1&lt;&lt;l;else if(f[nt[k][l]]==f[k]+1)p[nt[k][l]]|=1&lt;&lt;l;
		}
	}
	for(i=0;i&lt;=n;++i)if(f[i]&gt;ans)ans=f[i],Pos=i;
	printf(&quot;%d\n&quot;,ans);DFS(Pos);puts(&quot;&quot;);
}
struct node{
    int qi,zhong,flow,next;
    node(int _=0,int __=0,int ___=0,int ____=0):qi(_),zhong(__),flow(___),next(____){}
}edge[10000010];
int first[100050],cur[100050],du[100050];
int cnt=1,S,T,Maxflow;
void add(int x,int y,int z){edge[++cnt]=node(x,y,z,first[x]),first[x]=cnt,edge[++cnt]=node(y,x,0,first[y]),first[y]=cnt;}
int dis[1000050],gap[1000050],pre[100050];
int ISAP(int now,int flow){
	if(now==T)return flow;
	int sum=0,tmp;
	for(int i=cur[now];i;i=edge[i].next){
		if(edge[i].flow&amp;&amp;dis[edge[i].zhong]+1==dis[now]){
			tmp=ISAP(edge[i].zhong,min(flow-sum,edge[i].flow)),edge[i].flow-=tmp,edge[i^1].flow+=tmp,cur[now]=i;
			if((sum+=tmp)==flow)return sum;
			if(d[S]&gt;=T)return sum;
		}
	}
	if(!(--gap[dis[now]]))d[S]=T;
	++gap[++dis[now]],cur[now]=first[now];
	return sum;
}
void Solve3(){
	S=2*n+2,T=S+1;
	memset(b,0,sizeof(b));
	register int i,j,k,l;
	for(i=n;~i;i=j){
		for(j=i;(~j)&amp;&amp;a[j].b==a[i].b;--j);
		for(k=j+1;k&lt;=i;++k){
			b[k]|=f[k]==ans;
			for(l=0;l&lt;3;l++)if(b1[nt[k][l]]&amp;&amp;(p[nt[k][l]]&gt;&gt;l&amp;1))b[k]=1,--du[k],++du[nt[k][l]],add(k,nt[k][l]+n+1,INF);
		}
		for(k=j+1;k&lt;=i;++k){
			if(b[k]){
				b1[k]|=f[k]==g[k];
				for(l=j+1;l&lt;k;++l)if(g[l]+k-j-1&gt;=f[k])b1[l]=1;
				for(l=k+1;l&lt;=i;++l)if(g[l]+i-k&gt;=f[k])b1[l]=1;
			}
		}
	}
	for(i=0;i&lt;=n;++i){
		if(du[i]&gt;0)add(S,i,du[i]);else if(du[i]&lt;0)Maxflow-=du[i],add(i+n+1,T,-du[i]);
		add(i+n+1,i,INF);
	}
	while(d[S]&lt;T)Maxflow-=ISAP(S,INF);
	printf(&quot;%d\n&quot;,Maxflow);
}
int main(){init();Solve1();Solve3();}
<pre><h2>Problem4200</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;

#define maxn 50010
#define INF 0x3fffffff

using namespace std;

int f[maxn],t[maxn],q[4][maxn],inv[4][maxn],n,r[maxn],sta[maxn],l[maxn],Be[maxn],pre[2][maxn],ans;
int sum,tot=1,b[maxn],f1[maxn],in[maxn],out[maxn],dep[maxn],su,sv;

struct point{
	int x,y;
}p[maxn];

bool cmp0(const int &amp;a,const int &amp;b){ return p[a].x==p[b].x?p[a].y&lt;p[b].y:p[a].x&lt;p[b].x; }
bool cmp1(const int &amp;a,const int &amp;b){ return p[a].y==p[b].y?p[a].x&lt;p[b].x:p[a].y&lt;p[b].y; }
bool cmp2(const int &amp;a,const int &amp;b){ return (p[a].y-p[a].x==p[b].y-p[b].x)?p[a].x&lt;p[b].x:(p[a].y-p[a].x&lt;p[b].y-p[b].x); }
bool cmp3(const int &amp;a,const int &amp;b){ return (p[a].y+p[a].x==p[b].y+p[b].x)?p[a].x&gt;p[b].x:(p[a].y+p[a].x&lt;p[b].y+p[b].x); }

void DP1()
{
	int tail=1,Mxo=0;
	for(int i=1;i&lt;=n;i=tail){
		l[++l[0]]=i;
		if(f[q[1][i]]&gt;ans) ans=f[q[1][i]],Mxo=q[1][i];
		while(p[q[1][tail]].y==p[q[1][i]].y) t[q[1][tail]]=f[q[1][tail]],Be[q[1][tail]]=l[0],tail++;
		r[l[0]]=tail-1;
		int mx=-INF,mxo=0;
		for(int j=i;j&lt;tail;j++){
			int now=q[1][j],val=mx+j-i;
			if(j!=i) if(val&gt;t[now]) t[now]=val,pre[0][now]=mxo;
			if(f[now]&gt;mx) mx=f[now],mxo=now;
		}
		mx=-INF,mxo=0;
		for(int j=tail-1;j&gt;=i;j--){
			int now=q[1][j],val=mx+tail-1-j;
			if(j!=tail-1) if(val&gt;t[now]) t[now]=val,pre[0][now]=mxo;
			if(f[now]&gt;mx) mx=f[now],mxo=now;
		}
		for(int j=i;j&lt;tail;j++){
			int now=q[1][j],nex=q[2][inv[2][now]+1];
			f[now]=max(t[now],f[now]);
			if(p[nex].y-p[nex].x==p[now].y-p[now].x) if(f[now]+1&gt;f[nex])f[nex]=f[now]+1,pre[1][nex]=now;
			nex=q[3][inv[3][now]+1];
			if(p[nex].y+p[nex].x==p[now].y+p[now].x) if(f[now]+1&gt;f[nex])f[nex]=f[now]+1,pre[1][nex]=now;
			nex=q[0][inv[0][now]+1];
			if(p[nex].x==p[now].x) if(f[now]+1&gt;f[nex])f[nex]=f[now]+1,pre[1][nex]=now;
		}
	}
	for(int i=1;i&lt;=n;i++) if(f[i]&gt;ans) ans=f[i],Mxo=i;
	printf(&quot;%d\n&quot;,ans);
	int now=Mxo;
	while(1){
		if(now==0) break;
		int nex=pre[0][now];
		if(nex){
			if(inv[1][nex]&gt;inv[1][now]){
				for(int i=inv[1][now];i&lt;inv[1][nex];i++) sta[++sta[0]]=q[1][i];
				for(int i=r[Be[nex]];i&gt;=inv[1][nex];i--) sta[++sta[0]]=q[1][i];
			}else{
				for(int i=inv[1][now];i&gt;inv[1][nex];i--) sta[++sta[0]]=q[1][i];	
				for(int i=l[Be[nex]];i&lt;=inv[1][nex];i++) sta[++sta[0]]=q[1][i];
			}
			now=nex;
		}else sta[++sta[0]]=now;
		nex=pre[1][now];
		if(nex) now=nex;
		else break;
	}
	for(int i=sta[0];i&gt;0;i--) printf(&quot;%d &quot;,sta[i]);puts(&quot;&quot;);
}

void DP2(int f[])
{
	int tail=n;
	for(int i=n;i&gt;0;i=tail){
		while(p[q[1][tail]].y==p[q[1][i]].y) 
		t[q[1][tail]]=f[q[1][tail]],tail--;
		int mx=-INF,mxo=0;
		for(int j=tail+1;j&lt;=i;j++){
			int now=q[1][j],val=mx;
			if(j!=tail+1) if(val&gt;t[now]) t[now]=val;
			if(f[now]+i-j&gt;mx) mx=f[now]+i-j;
		}
		mx=-INF,mxo=0;
		for(int j=i;j&gt;=tail+1;j--){
			int now=q[1][j],val=mx;
			if(j!=i) if(val&gt;t[now]) t[now]=val;
			if(f[now]+j-tail-1&gt;mx) mx=f[now]+j-tail-1;
		}
		for(int j=tail+1;j&lt;=i;j++){
			int now=q[1][j],nex=q[2][inv[2][now]-1];
			f[now]=max(t[now],f[now]);
			if(p[nex].y-p[nex].x==p[now].y-p[now].x) if(f[now]+1&gt;f[nex])f[nex]=f[now]+1;
			nex=q[3][inv[3][now]-1];
			if(p[nex].y+p[nex].x==p[now].y+p[now].x) if(f[now]+1&gt;f[nex])f[nex]=f[now]+1;
			nex=q[0][inv[0][now]-1];
			if(p[nex].x==p[now].x) if(f[now]+1&gt;f[nex])f[nex]=f[now]+1;
		}
	}
}

void init()
{
	scanf(&quot;%d&quot;,&amp;n);
	memset(f,-0x3f,sizeof(f));
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%d%d&quot;,&amp;p[i].x,&amp;p[i].y);
		if(p[i].x==0||p[i].y==0) f[i]=1;
		else if(p[i].y-p[i].x==0||p[i].x+p[i].y==0) f[i]=1;
	}
	for(int i=1;i&lt;=n;i++) t[i]=f[i];
	for(int i=1;i&lt;=n;i++) q[0][i]=q[1][i]=q[2][i]=q[3][i]=i;
	sort(q[0]+1,q[0]+n+1,cmp0);
	sort(q[1]+1,q[1]+n+1,cmp1);
	sort(q[2]+1,q[2]+n+1,cmp2);
	sort(q[3]+1,q[3]+n+1,cmp3);
	for(int i=1;i&lt;=n;i++){
		inv[0][q[0][i]]=i;
		inv[1][q[1][i]]=i;
		inv[2][q[2][i]]=i;
		inv[3][q[3][i]]=i;
	}
}

struct edge{
	int x,y,w,last;
}a[maxn&lt;&lt;3],e[maxn&lt;&lt;3];

void add(int x,int y,int w)
{
	a[++tot]=(edge){x,y,w,b[x]};
	b[x]=tot;
}

void Add(int x,int y,int w)
{
    add(x,y,w);add(y,x,0);
}
  
void insert(int x,int y,int L,int R)
{	
	
    out[x]+=L;in[y]+=L;
    Add(x,y,R-L);
}

void build()
{
	for(int i=1;i&lt;=n;i++) if(f1[i]==ans){
		if(p[i].x==0||p[i].y==0) insert(0,i,1,INF);
		else if(p[i].y-p[i].x==0||p[i].x+p[i].y==0) insert(0,i,1,INF);
	}
	for(int i=1;i&lt;=n;i++){
		int now=i;
		int nex=q[2][inv[2][now]+1];
		if(p[nex].y-p[nex].x==p[now].y-p[now].x) if(f[now]+f1[nex]==ans) insert(now,nex,1,INF);
		nex=q[3][inv[3][now]+1];
		if(p[nex].y+p[nex].x==p[now].y+p[now].x) if(f[now]+f1[nex]==ans) insert(now,nex,1,INF);
		nex=q[0][inv[0][now]+1];
		if(p[nex].x==p[now].x) if(f[now]+f1[nex]==ans) insert(now,nex,1,INF);
	}
}

#define v a[i].y
bool bfs()
{
    queue&lt;int&gt; q;
    q.push(su);
    memset(dep,0,sizeof(dep));
    dep[su]=1;
    while(!q.empty()){
        int x=q.front();
        q.pop();
        for(int i=b[x];i;i=a[i].last){
            if(!dep[v]&amp;&amp;a[i].w&gt;0){
                dep[v]=dep[x]+1;
                if(v==sv) return 1;
                q.push(v);
            }
        }
    }
    return dep[sv]!=0;
}
   
int Dinic(int x,int flow)
{
	
    if(x==sv) return flow;
    int remain=flow;
    for(int i=b[x];i;i=a[i].last){
        if(!remain) break;
        if(dep[v]==dep[x]+1&amp;&amp;a[i].w&gt;0){
            int tmp=Dinic(v,min(a[i].w,remain));
            if(!tmp){
                dep[v]=0;
                continue;
            }
            a[i].w-=tmp;
            a[i^1].w+=tmp;
            remain-=tmp;
        }
    }
    return flow-remain;
}

inline bool check(int mid)
{
	for(int i=2;i&lt;=tot;i++) a[i]=e[i];
	a[tot-1].w=mid;
	int tmp=0,ans=0;
	while(bfs()){
		while(tmp=Dinic(su,INF)) ans+=tmp;
	}
	return ans&gt;=sum;
}

void work()
{
	su=n+1,sv=n+2;
	for(int i=0;i&lt;=n;i++){
		if(in[i]&gt;out[i]) Add(su,i,in[i]-out[i]),sum=sum+in[i]-out[i];
		else if(out[i]&gt;in[i]) Add(i,sv,out[i]-in[i]);
	}
	for(int i=0;i&lt;=n;i++) Add(n+3,i,INF);
	Add(su,n+3,INF);
	for(int i=2;i&lt;=tot;i++) e[i]=a[i];
	int l=1,r=100*n,Ans=0;
	while(l&lt;=r){
		int mid=(l+r)&gt;&gt;1;
		if(check(mid)) Ans=mid,r=mid-1;
		else l=mid+1;
	}
	printf(&quot;%d\n&quot;,Ans);
}

int main()
{
	init();
	DP1();
	memset(t,-0x3f,sizeof(t));
	for(int i=1;i&lt;=n;i++) if(f[i]==ans) t[i]=1;
	for(int i=1;i&lt;=n;i++) f1[i]=t[i];
	DP2(f1);
	build();
	work();
	return 0;
}
<pre><h2>Problem4213</h2><pre>#include&lt;queue&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define INF 0x7fffffff
struct node{
	int qi,zhong,flow,cost,next;
	node(){}
	node(int _,int __,int ___,int ____,int _____):
		qi(_),zhong(__),flow(___),cost(____),next(_____){}
}edge[60005];
int dis[305],q[305],first[305],du[305];
bool in[305],mark[305];
int cnt=1,S,T,SS,TT,tot,Mincost,Maxflow,n=1,m,CNT;
int map[15][15];
char c[15][15];
int xx[]={0,0,1,-1},yy[]={1,-1,0,0};
void add(int x,int y,int f,long long c){
	edge[++cnt]=node(x,y,f,c,first[x]),first[x]=cnt;
	edge[++cnt]=node(y,x,0,-c,first[y]),first[y]=cnt;
}
bool SPFA(){
	int head=0,tail=1;
	memset(dis,0x7f,sizeof(dis));
	q[0]=TT;dis[TT]=0;
	while(head!=tail){
		int now=q[head];head++;
		in[now]=0;
		if(head==305)head=0;
		for(int i=first[now];i;i=edge[i].next){
			if(dis[now]-edge[i].cost&lt;dis[edge[i].zhong]&amp;&amp;edge[i^1].flow){
				dis[edge[i].zhong]=dis[now]-edge[i].cost;
				if(!in[edge[i].zhong]){
					in[edge[i].zhong]=1;
					q[tail++]=edge[i].zhong;
					if(tail==305)tail=0;
				}
			}
		}
	}
	return dis[SS]!=0x7f7f7f7f;
}
int DFS(int x,int f){
	mark[x]=1;
	if(x==TT)return f;
	int w,used=0;
	for(int i=first[x];i;i=edge[i].next){
		int zhong=edge[i].zhong;
		if(!mark[zhong]&amp;&amp;edge[i].flow&amp;&amp;dis[x]-edge[i].cost==dis[zhong]){
			w=DFS(zhong,min(edge[i].flow,f));
			edge[i].flow-=w;edge[i^1].flow+=w;
			Mincost+=w*edge[i].cost;
			used+=w;
			if(used==f)return f;
		}
	}
	return used;
}
void ZKW(){
	while(SPFA()){
		memset(mark,0,sizeof(mark));
		mark[TT]=1;
		while(mark[TT]){
			mark[TT]=0;
			Maxflow+=DFS(SS,INF);
		}
	}
}
int main(){
	while(scanf(&quot;%s&quot;,c[n]+1)!=EOF)n++;n--;
	m=strlen(c[n]+1);
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)map[i][j]=++CNT;
	S=0,T=CNT+1,SS=T+1,TT=SS+1;
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=m;j++){
			if(c[i][j]=='.'){
				CNT=map[i][j];
				if((i+j)&amp;1){
					du[S]-=2,du[CNT]+=2;
					if(i==1||i==n||j==1||j==m)add(CNT,T,1,1);
					for(int k=0;k&lt;4;k++){
						int kx=i+xx[k],ky=j+yy[k];
						if(kx&amp;&amp;ky&amp;&amp;kx-n-1&amp;&amp;ky-m-1&amp;&amp;c[kx][ky]-'#'){
							add(CNT,map[kx][ky],1,0);
						}
					}
				}else{
					if(i==1||i==n||j==1||j==m)add(S,CNT,1,1);
					du[CNT]-=2,du[T]+=2;
				}
			}
		}
	}
	for(int i=0;i&lt;=T;i++){
		if(du[i]&gt;0)add(SS,i,du[i],0);
		else tot-=du[i],add(i,TT,-du[i],0);
	}
	add(T,S,INF,0);
	ZKW();
	if(Maxflow!=tot)printf(&quot;-1\n&quot;);
	else printf(&quot;%d\n&quot;,Mincost&gt;&gt;1);
}
<pre><h2>Problem4236</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
using namespace std;
typedef pair&lt;int,int&gt; pii;
#define mp make_pair
int n;
char s[200111];
map&lt;pii,int&gt; rec;
int main()
{
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d\n%s&quot;,&amp;n,s+1);
	int n1=0,n2=0,n3=0,ans=0,i;
	rec[mp(0,0)]=0;
	for (i=1;i&lt;=n;i++)
	{
		if (s[i]=='J') n1++;
		else if (s[i]=='O') n2++;
		else n3++;
		pii tmp=mp(n2-n1,n3-n2);
		if (rec.count(tmp))
			ans=max(ans,i-rec[tmp]);
		else rec[tmp]=i;
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}<pre><h2>Problem4326</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;cctype&gt;
#include &lt;cassert&gt;

#define REP(i, a, b) for (register int i = (a), _end_ = (b); i &lt; _end_; ++i)
#define debug(...) fprintf(stderr, __VA_ARGS__)

using namespace std;

template&lt;typename T&gt; inline bool chkmax(T &amp;a, T b) { return a &lt; b ? a = b, 1 : 0; }
template&lt;typename T&gt; inline bool chkmin(T &amp;a, T b) { return a &gt; b ? a = b, 1 : 0; }

const int oo = 0x3f3f3f3f;

const int maxn = 300000, maxm = 300000, max0 = 100000;

struct edge
{
	int id, g, nxt;

	edge() { }
	edge(int _id, int _g, int _nxt): id(_id), g(_g), nxt(_nxt) { }

};

edge e[(maxn &lt;&lt; 1) + 5], e0[(maxm &lt;&lt; 1) + 5];
int st[maxn + 5], en = 0, st0[maxn + 5], en0 = 0;

inline void add_edge(int x, int y, int z)
{
	e[en] = edge(y, z, st[x]), st[x] = en++;
}

inline void add_edge0(int x, int y, int z)
{
	e0[en0] = edge(y, z, st0[x]), st0[x] = en0++;
}

int n, m;

char s[max0 + 5], *ss, *tt;

#define getc() (ss == tt ? (fread(s, 1, max0, stdin), ss = s, tt = s + max0, *(ss++)) : *(ss++))

template&lt;typename T&gt; T &amp;Read(T &amp;x)
{
	static char c;
	while (1)
	{
		c = getc();
		if (c &gt;= '0' &amp;&amp; c &lt;= '9') break;
	}
	x = c - '0';
	while (1)
	{
		c = getc();
		if (c &lt; '0' || c &gt; '9') break;
		(x *= 10) += c - '0';
	}
	return x;
}

int fa[maxn + 5], pa[maxn + 5];
int cur[maxn + 5];
int dep[maxn + 5];
int len[maxn + 5];

int from[maxm + 5], to[maxm + 5], mid[maxm + 5];
int dis[maxm + 5], pos[maxm + 5];
int Maxpass[maxn + 5];
int dfs_seq[maxn + 5], dfs_tot = 0;

int fa0[maxn + 5];
int col[maxn + 5];

void simple_dfs(int S, int c, int f = -1)
{
	fa0[S] = f;
	static int q[maxn + 5];
	int head = 0, rear = 0;
	q[rear++] = S;
	while (head != rear)
	{
		int x = q[head++];
		col[x] = c;
		for (int i = st[x]; i != -1; i = e[i].nxt)
		{
			int y = e[i].id;
			if (y == fa0[x]) continue;
			if (col[y] &gt;= 0) continue;
			fa0[y] = x;
			q[rear++] = y;
		}
	}
}

int dfn[maxn + 5];

void dfs(int S)
{
	dfs_tot = 0;
	fa[S] = -1;
	dep[0] = len[0] = 0;
	int u = S;
	bool flag = 0;
	while (u != -1)
	{
		if (!flag)
		{
			dfs_seq[dfn[u] = dfs_tot++] = u;
			cur[u] = st[u];
			flag = 1;
		}
		for (int &amp;i = cur[u]; i != -1; i = e[i].nxt)
		{
			int v = e[i].id;
			if (v == fa[u]) continue;
			dep[v] = dep[u] + 1;
			len[v] = len[u] + e[i].g;
			fa[v] = u;
			u = v;
			flag = 0;
			i = e[i].nxt;
			break;
		}
		if (flag) u = fa[u];
	}
}

inline bool cmp(int x, int y) { return dis[x] &gt; dis[y]; }

inline int get(int x)
{
	int u = x;
	while (pa[u] != u) u = pa[u];
	while (pa[x] != x)
	{
		int tmp = pa[x];
		pa[x] = u;
		x = tmp;
	}
	return u;
}

int Max[maxn + 5];
bool in[maxn + 5];

int main()
{
	memset(st, -1, sizeof st), en = 0;
	int x, y, z;
	Read(n), Read(m);
	REP(i, 0, n - 1)
	{
		Read(x), Read(y), Read(z), --x, --y;
		add_edge(x, y, z);
		add_edge(y, x, z);
	}
	dfs(0);
	memset(st0, -1, sizeof st0), en0 = 0;
	REP(i, 0, m)
	{
		int &amp;x = from[i], &amp;y = to[i];
		Read(x), Read(y);
		--x, --y;
		if (dfn[x] &lt; dfn[y]) add_edge0(x, y, i);
		else add_edge0(y, x, i);
		pos[i] = i;
	}
	REP(i, 0, n) pa[i] = i;
	for (int i = n - 1; i &gt;= 0; --i)
	{
		int x = dfs_seq[i];
		for (register int j = st0[x]; j != -1; j = e0[j].nxt) mid[e0[j].g] = get(e0[j].id);
		if (fa[x] != -1) pa[x] = fa[x];
	}
	REP(i, 0, m) dis[i] = len[from[i]] + len[to[i]] - (len[mid[i]] &lt;&lt; 1);
	sort(pos, pos + m, cmp);
	REP(i, 0, n) pa[i] = i;
	REP(i, 0, m)
	{
		register int x = from[pos[i]], y = to[pos[i]], z = dep[mid[pos[i]]];
		register int val = dis[pos[i]];

		while (dep[x = get(x)] &gt; z)
		{
			Maxpass[x] = val;
			pa[x] = get(fa[x]);
			x = pa[x];
		}

		x = y;

		while (dep[x = get(x)] &gt; z)
		{
			Maxpass[x] = val;
			pa[x] = get(fa[x]);
			x = pa[x];
		}

	}
	memset(col, -1, sizeof col);
	int u = from[pos[0]], v = to[pos[0]];
	int cnt = 0;
	simple_dfs(u, -1);
	while (v != -1)
	{
		in[v] = 1;
		simple_dfs(v, cnt++, fa0[v]);
		v = fa0[v];
	}
	int *pl = Max, *pr = Max + cnt;
	REP(i, 1, m)
	{
		int *x = Max + col[from[pos[i]]], *y = Max + col[to[pos[i]]];
		if (x &gt; y) swap(x, y);
		while (pl &lt; x &amp;&amp; pl &lt;= pr) *(pl++) = dis[pos[i]];
		while (pr &gt; y &amp;&amp; pl &lt; pr) *(--pr) = dis[pos[i]];
		if (pl &gt;= pr) break;
	}
	register int ans = oo;
	if (n == 1) ans = 0;
	REP(i, 1, n)
	{
		register int outside = -1, inside = Maxpass[i];
		register int x = i, y = fa[i];
		inside -= len[x] - len[y];
		if (!in[x] || !in[y]) outside = dis[pos[0]];
		else 
		{
			if (col[x] &lt; col[y]) outside = Max[col[x]];
			else outside = Max[col[y]];
		}
		x = outside;
		if (inside &gt; x) x = inside;
		if (x &lt; ans) ans = x;
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}<pre><h2>Problem4358</h2><pre>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
#include&lt;algorithm&gt;
#define inf 0x7fffffff
inline int MAX(int A,int B){return A&gt;B?A:B;}
int n,m,tp,o[51000],id[51000];
struct ask{int l,r,ans,t;}q[51000];
inline bool comp1(ask a,ask b){return id[a.l]==id[b.l]?a.r&lt;b.r:id[a.l]&lt;id[b.l];}
inline bool comp2(ask a,ask b){return a.t&lt;b.t;}
int ANS,ans,l[51000],r[51000],f[51000],L[51000][2],R[51000][2];
bool flag[51000];
inline void addr(int x){
	flag[x]=1;
	if(!flag[x-1]&amp;&amp;!flag[x+1]) return;
	if(flag[x-1]&amp;&amp;!flag[x+1]) l[x]=l[x-1],r[l[x]]=r[x];
	if(!flag[x-1]&amp;&amp;flag[x+1]) r[x]=r[x+1],l[r[x]]=l[x];
	if(flag[x-1]&amp;&amp;flag[x+1]) l[x]=l[x-1],r[x]=r[x+1],l[r[x]]=l[x],r[l[x]]=r[x];
	ans=MAX(ans,r[x]-l[x]+1);
}
inline void addl(int x){
	flag[x]=1,f[++f[0]]=x;
	if(flag[x-1]&amp;&amp;!flag[x+1]){
		L[++L[0][0]][0]=x,L[L[0][0]][1]=l[x];
		l[x]=l[x-1];
		R[++R[0][0]][0]=l[x],R[R[0][0]][1]=r[l[x]];
		r[l[x]]=r[x];
	}
	if(!flag[x-1]&amp;&amp;flag[x+1]){
		R[++R[0][0]][0]=x,R[R[0][0]][1]=r[x];
		r[x]=r[x+1];
		L[++L[0][0]][0]=r[x],L[L[0][0]][1]=l[r[x]];
		l[r[x]]=l[x];
	}
	if(flag[x-1]&amp;&amp;flag[x+1]){
		L[++L[0][0]][0]=x,L[L[0][0]][1]=l[x];
		R[++R[0][0]][0]=x,R[R[0][0]][1]=r[x];
		l[x]=l[x-1],r[x]=r[x+1];
		L[++L[0][0]][0]=r[x],L[L[0][0]][1]=l[r[x]];
		R[++R[0][0]][0]=l[x],R[R[0][0]][1]=r[l[x]];
		l[r[x]]=l[x],r[l[x]]=r[x];
	}
	ANS=MAX(ANS,r[x]-l[x]+1);
}
inline void del(){
	for(int i=L[0][0];i;--i)
	    l[L[i][0]]=L[i][1],r[R[i][0]]=R[i][1];
	for(int i=1;i&lt;=f[0];++i) flag[f[i]]=0;
	L[0][0]=R[0][0]=f[0]=0;
}
int ls[51000],rs[51000];
int Q[51000];
bool vis[51000];
inline void ADD(int x){
	vis[x]=1,Q[++Q[0]]=x;
	if(vis[x-1]&amp;&amp;!vis[x+1]){
		ls[x]=ls[x-1];
		Q[++Q[0]]=ls[x];
		rs[ls[x]]=rs[x];
	}
	if(!vis[x-1]&amp;&amp;vis[x+1]){
		rs[x]=rs[x+1];
		Q[++Q[0]]=rs[x];
		ls[rs[x]]=ls[x];
	}
	if(vis[x-1]&amp;&amp;vis[x+1]){
		ls[x]=ls[x-1],rs[x]=rs[x+1];
		Q[++Q[0]]=rs[x],Q[++Q[0]]=ls[x];
		ls[rs[x]]=ls[x],rs[ls[x]]=rs[x];
	}
	ANS=MAX(ANS,rs[x]-ls[x]+1);
}
int main(){
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m),tp=sqrt(n);
	for(int i=1;i&lt;=n;++i) id[i]=i/tp;
	for(int i=0;i&lt;n;++i) scanf(&quot;%d&quot;,&amp;o[i]);
	for(int i=1;i&lt;=m;++i) scanf(&quot;%d%d&quot;,&amp;q[i].l,&amp;q[i].r),--q[i].l,--q[i].r,q[i].t=i;
	std::sort(q+1,q+m+1,comp1);
	for(int i=1;i&lt;=n;++i) ls[i]=rs[i]=i;
	for(int i=0,j=1,p=n/tp,ll=1,rr=0;i&lt;=p;++i){
		for(int k=1;k&lt;=n+1;++k) l[k]=r[k]=k,flag[k]=0;
		ll=tp*(i+1),rr=tp*(i+1)-1,ans=0;
		for(;id[q[j].l]==i;++j){
			ANS=0;
			if(id[q[j].l]==id[q[j].r]){
				for(int k=q[j].l;k&lt;=q[j].r;++k) ADD(o[k]);
				for(int k=1;k&lt;=Q[0];++k) rs[Q[k]]=ls[Q[k]]=Q[k],vis[Q[k]]=0;
				Q[0]=0;
			}else{
				while(rr&lt;q[j].r) addr(o[++rr]);
				while(ll&gt;q[j].l) addl(o[--ll]);
				ll=tp*(i+1),del();
			}
			q[j].ans=MAX(ans,ANS);
		}
	}
	std::sort(q+1,q+m+1,comp2);
	for(int i=1;i&lt;=m;++i) printf(&quot;%d\n&quot;,q[i].ans);
}
<pre><h2>Problem4358</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;

#define maxn 50010
#define L(x) (x&lt;&lt;1)
#define R(x) (x&lt;&lt;1|1)

using namespace std;

inline int read()
{
	int ret=0;char ch=getchar();
	while(ch&lt;'!') ch=getchar();
	while(ch&gt;'!') ret=ret*10+ch-'0',ch=getchar();
	return ret;
}

int n,m,a[maxn],belong[maxn],blo,ans,Ans[maxn],pre[maxn],suc[maxn],sta[maxn],top;
bool vis[maxn];

struct query{
	int x,y,o;
	friend bool operator &lt; (const query&amp;a,const query&amp;b){
		return belong[a.x]==belong[b.x]?a.y&lt;b.y:belong[a.x]&lt;belong[b.x];
	}
}q[maxn];

void insert(int pos)
{
	vis[pos]=1;
	pre[pos]=suc[pos]=pos;
	if(vis[pos-1]) pre[pos]=pre[pos-1];
	if(vis[pos+1]) suc[pos]=suc[pos+1];
	suc[pre[pos]]=suc[pos];
	pre[suc[pos]]=pre[pos];
	ans=max(suc[pos]-pre[pos]+1,ans);
}

void del(int pos)
{
	vis[pos]=0;
	if(vis[pos-1]) suc[pre[pos]]=pos-1;
	if(vis[pos+1]) pre[suc[pos]]=pos+1;
	pre[pos]=suc[pos]=0;
}

void clear()
{
	ans=0;
	for(int i=1;i&lt;=n;i++) vis[i]=pre[i]=suc[i]=0;
}

int main()
{
	n=read(),m=read();
	blo=sqrt(n);
	for(int i=1;i&lt;=n;i++) a[i]=read(),belong[i]=(i-1)/blo+1;
	for(int i=1;i&lt;=m;i++){
		q[i]=(query){read(),read(),i};
	}
	sort(q+1,q+m+1);
	int l;
	for(int now=1;now&lt;=m;now++){
		if(belong[q[now].x]!=belong[q[now-1].x]){
			if(now!=1) clear();
			l=belong[q[now].x]*blo;
		}
		for(;l&lt;=q[now].y;l++){
		//	puts(&quot;!&quot;);
			insert(a[l]);
		}
		int lastans=ans;
		for(int i=q[now].x;i&lt;min(blo*belong[q[now].x],q[now].y+1);i++) insert(a[i]),sta[++top]=a[i];
		Ans[q[now].o]=ans;
		for(int i=top;i&gt;0;i--)	del(sta[top--]);
		ans=lastans;
	}
	for(int i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,Ans[i]);
	return 0;
}
<pre><h2>Problem4358</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;

#define maxn 50010
#define L(x) (x&lt;&lt;1)
#define R(x) (x&lt;&lt;1|1)

using namespace std;

inline int read()
{
	int ret=0;char ch=getchar();
	while(ch&lt;'!') ch=getchar();
	while(ch&gt;'!') ret=ret*10+ch-'0',ch=getchar();
	return ret;
}

int n,m,a[maxn],belong[maxn],blo,ans,Ans[maxn],pre[maxn],suc[maxn],sta[maxn],top;
bool vis[maxn];

struct query{
	int x,y,o;
	friend bool operator &lt; (const query&amp;a,const query&amp;b){
		return belong[a.x]==belong[b.x]?a.y&lt;b.y:belong[a.x]&lt;belong[b.x];
	}
}q[maxn];

void insert(int pos)
{
	vis[pos]=1;
	pre[pos]=suc[pos]=pos;
	if(vis[pos-1]) pre[pos]=pre[pos-1];
	if(vis[pos+1]) suc[pos]=suc[pos+1];
	suc[pre[pos]]=suc[pos];
	pre[suc[pos]]=pre[pos];
	ans=max(suc[pos]-pre[pos]+1,ans);
}

void del(int pos)
{
	vis[pos]=0;
	if(vis[pos-1]) suc[pre[pos]]=pos-1;
	if(vis[pos+1]) pre[suc[pos]]=pos+1;
	pre[pos]=suc[pos]=0;
}

void clear()
{
	ans=0;
	for(int i=1;i&lt;=n;i++) vis[i]=pre[i]=suc[i]=0;
}

int main()
{
	n=read(),m=read();
	blo=sqrt(n);
	for(int i=1;i&lt;=n;i++) a[i]=read(),belong[i]=(i-1)/blo+1;
	for(int i=1;i&lt;=m;i++){
		q[i]=(query){read(),read(),i};
	}
	sort(q+1,q+m+1);
	int l;
	for(int now=1;now&lt;=m;now++){
		if(belong[q[now].x]!=belong[q[now-1].x]){
			if(now!=1) clear();
			l=belong[q[now].x]*blo;
		}
		for(;l&lt;=q[now].y;l++) insert(a[l]);
		int lastans=ans;
		int R=min(blo*belong[q[now].x],q[now].y+1);
		for(int i=q[now].x;i&lt;R;i++) insert(a[i]),sta[++top]=a[i];
		Ans[q[now].o]=ans;
		for(int i=top;i&gt;0;i--) del(sta[top--]);
		ans=lastans;
	}
	for(int i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,Ans[i]);
	return 0;
}
<pre><h2>Problem4358</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;

#define maxn 50010

using namespace std;

inline int read()
{
	int ret=0;char ch=getchar();
	while(ch&lt;'!') ch=getchar();
	while(ch&gt;'!') ret=ret*10+ch-'0',ch=getchar();
	return ret;
}

int n,m,a[maxn],belong[maxn],blo,ans,Ans[maxn],pre[maxn],suc[maxn],sta[maxn],top;
bool vis[maxn];

struct query{
	int x,y,o;
	friend bool operator &lt; (const query&amp;a,const query&amp;b){
		return belong[a.x]==belong[b.x]?a.y&lt;b.y:belong[a.x]&lt;belong[b.x];
	}
}q[maxn];

void insert(int pos)
{
	vis[pos]=1;
	pre[pos]=suc[pos]=pos;
	if(vis[pos-1]) pre[pos]=pre[pos-1];
	if(vis[pos+1]) suc[pos]=suc[pos+1];
	suc[pre[pos]]=suc[pos];
	pre[suc[pos]]=pre[pos];
	ans=max(suc[pos]-pre[pos]+1,ans);
}

void del(int pos)
{
	vis[pos]=0;
	if(vis[pos-1]) suc[pre[pos]]=pos-1;
	if(vis[pos+1]) pre[suc[pos]]=pos+1;
	pre[pos]=suc[pos]=0;
}

void clear()
{
	ans=0;
	for(int i=1;i&lt;=n;i++) vis[i]=pre[i]=suc[i]=0;
}

int main()
{
	n=read(),m=read();
	blo=sqrt(n);
	for(int i=1;i&lt;=n;i++) a[i]=read(),belong[i]=(i-1)/blo+1;
	for(int i=1;i&lt;=m;i++){
		q[i]=(query){read(),read(),i};
	}
	sort(q+1,q+m+1);
	int l;
	for(int now=1;now&lt;=m;now++){
		if(belong[q[now].x]!=belong[q[now-1].x]){
			if(now!=1) clear();
			l=belong[q[now].x]*blo;
		}
		for(;l&lt;=q[now].y;l++) insert(a[l]);
		int lastans=ans;
		int R=min(blo*belong[q[now].x],q[now].y+1);
		for(int i=q[now].x;i&lt;R;i++) insert(a[i]),sta[++top]=a[i];
		Ans[q[now].o]=ans;
		for(int i=top;i&gt;0;i--) del(sta[top--]);
		ans=lastans;
	}
	for(int i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,Ans[i]);
	return 0;
}
<pre><h2>Problem4401</h2><pre>#include&lt;cstdio&gt;
#include&lt;cctype&gt;
#include&lt;queue&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#define rep(i,s,t) for(int i=s;i&lt;=t;i++)
#define dwn(i,s,t) for(int i=s;i&gt;=t;i--)
#define ren for(int i=first[x];i;i=next[i])
using namespace std;
const int BufferSize=1&lt;&lt;16;
char buffer[BufferSize],*head,*tail;
inline char Getchar() {
    if(head==tail) {
        int l=fread(buffer,1,BufferSize,stdin);
        tail=(head=buffer)+l;
    }
    return *head++;
}
inline int read() {
    int x=0,f=1;char c=Getchar();
    for(;!isdigit(c);c=Getchar()) if(c=='-') f=-1;
    for(;isdigit(c);c=Getchar()) x=x*10+c-'0';
    return x*f;
}
const int maxn=1000010;
int n,s[maxn],first[maxn],next[maxn&lt;&lt;1],to[maxn&lt;&lt;1],e;
void AddEdge(int u,int v) {
    to[++e]=v;next[e]=first[u];first[u]=e;
    to[++e]=u;next[e]=first[v];first[v]=e;
}
int dfs(int x,int fa) {
    s[x]=1;
    ren if(to[i]!=fa) s[x]+=dfs(to[i],x);
    return s[x];
}
int A[maxn],ans;
int main() {
	//f
    n=read();
    rep(i,2,n) AddEdge(read(),read());
    dfs(1,0);
    rep(i,1,n) A[s[i]]++;
    rep(i,1,n) if(n%i==0) {
        int cnt=0;
        for(int j=i;j&lt;=n;j+=i) cnt+=A[j];
        if(cnt==n/i) ans++;
    }
    printf(&quot;%d\n&quot;,ans);
    return 0;
}<pre>﻿<br>
<a href="./"><span class=red>HOME</span></a>
<a href="javascript:history.go(-1)"><span class=red>Back</span></a>

<hr>
<center>
	<div class="footer">
			<a href=setlang.php?lang=ko>한국어</a>&nbsp;
		<a href=setlang.php?lang=cn>中文</a>&nbsp;
		<a href=setlang.php?lang=fa>فارسی</a>&nbsp;
		<a href=setlang.php?lang=en>English</a>&nbsp;
		<a href=setlang.php?lang=th>ไทย</a>
	<br><div>版权所有 &copy;2008-2018 大视野在线测评 | <a href="http://www.miitbeian.gov.cn">湘ICP备13009380号</a></div>
		<div>Based on opensource project <a href="http://hustoj.googlecode.com">hustoj</a>.</div>
	</div>
</center>
</body>
</html>
